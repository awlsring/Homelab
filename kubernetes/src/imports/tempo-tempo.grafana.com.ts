// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * TempoMonolithic manages a Tempo deployment in monolithic mode.
 *
 * @schema TempoMonolithic
 */
export class TempoMonolithic extends ApiObject {
  /**
   * Returns the apiVersion and kind for "TempoMonolithic"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'tempo.grafana.com/v1alpha1',
    kind: 'TempoMonolithic',
  }

  /**
   * Renders a Kubernetes manifest for "TempoMonolithic".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: TempoMonolithicProps = {}): any {
    return {
      ...TempoMonolithic.GVK,
      ...toJson_TempoMonolithicProps(props),
    };
  }

  /**
   * Defines a "TempoMonolithic" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: TempoMonolithicProps = {}) {
    super(scope, id, {
      ...TempoMonolithic.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...TempoMonolithic.GVK,
      ...toJson_TempoMonolithicProps(resolved),
    };
  }
}

/**
 * TempoMonolithic manages a Tempo deployment in monolithic mode.
 *
 * @schema TempoMonolithic
 */
export interface TempoMonolithicProps {
  /**
   * @schema TempoMonolithic#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * TempoMonolithicSpec defines the desired state of TempoMonolithic.
   *
   * @schema TempoMonolithic#spec
   */
  readonly spec?: TempoMonolithicSpec;

}

/**
 * Converts an object of type 'TempoMonolithicProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicProps(obj: TempoMonolithicProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_TempoMonolithicSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TempoMonolithicSpec defines the desired state of TempoMonolithic.
 *
 * @schema TempoMonolithicSpec
 */
export interface TempoMonolithicSpec {
  /**
   * Affinity defines the Affinity rules for scheduling pods.
   *
   * @schema TempoMonolithicSpec#affinity
   */
  readonly affinity?: TempoMonolithicSpecAffinity;

  /**
   * ExtraConfig defines any extra (overlay) configuration of components.
   *
   * @schema TempoMonolithicSpec#extraConfig
   */
  readonly extraConfig?: TempoMonolithicSpecExtraConfig;

  /**
   * Ingestion defines the trace ingestion configuration.
   *
   * @schema TempoMonolithicSpec#ingestion
   */
  readonly ingestion?: TempoMonolithicSpecIngestion;

  /**
   * JaegerUI defines the Jaeger UI configuration.
   *
   * @schema TempoMonolithicSpec#jaegerui
   */
  readonly jaegerui?: TempoMonolithicSpecJaegerui;

  /**
   * ManagementState defines whether this instance is managed by the operator or self-managed.
   * Default: Managed.
   *
   * @schema TempoMonolithicSpec#management
   */
  readonly management?: TempoMonolithicSpecManagement;

  /**
   * Multitenancy defines the multi-tenancy configuration.
   *
   * @schema TempoMonolithicSpec#multitenancy
   */
  readonly multitenancy?: TempoMonolithicSpecMultitenancy;

  /**
   * NodeSelector defines which labels are required by a node to schedule the pod onto it.
   *
   * @schema TempoMonolithicSpec#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * Observability defines the observability configuration of the Tempo deployment.
   *
   * @schema TempoMonolithicSpec#observability
   */
  readonly observability?: TempoMonolithicSpecObservability;

  /**
   * Query defines query configuration.
   *
   * @schema TempoMonolithicSpec#query
   */
  readonly query?: TempoMonolithicSpecQuery;

  /**
   * Resources defines the compute resource requirements of the Tempo container.
   *
   * @schema TempoMonolithicSpec#resources
   */
  readonly resources?: TempoMonolithicSpecResources;

  /**
   * ServiceAccount defines the Service Account to use for all Tempo components.
   *
   * @schema TempoMonolithicSpec#serviceAccount
   */
  readonly serviceAccount?: string;

  /**
   * Storage defines the storage configuration.
   *
   * @schema TempoMonolithicSpec#storage
   */
  readonly storage?: TempoMonolithicSpecStorage;

  /**
   * Timeout configures the same timeout on all components starting at ingress down to the ingestor/querier.
   * Timeout configuration on a specific component has a higher precedence.
   * Default is 30 seconds.
   *
   * @default 30 seconds.
   * @schema TempoMonolithicSpec#timeout
   */
  readonly timeout?: string;

  /**
   * Tolerations defines the tolerations of a node to schedule the pod onto it.
   *
   * @schema TempoMonolithicSpec#tolerations
   */
  readonly tolerations?: TempoMonolithicSpecTolerations[];

}

/**
 * Converts an object of type 'TempoMonolithicSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpec(obj: TempoMonolithicSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'affinity': toJson_TempoMonolithicSpecAffinity(obj.affinity),
    'extraConfig': toJson_TempoMonolithicSpecExtraConfig(obj.extraConfig),
    'ingestion': toJson_TempoMonolithicSpecIngestion(obj.ingestion),
    'jaegerui': toJson_TempoMonolithicSpecJaegerui(obj.jaegerui),
    'management': obj.management,
    'multitenancy': toJson_TempoMonolithicSpecMultitenancy(obj.multitenancy),
    'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'observability': toJson_TempoMonolithicSpecObservability(obj.observability),
    'query': toJson_TempoMonolithicSpecQuery(obj.query),
    'resources': toJson_TempoMonolithicSpecResources(obj.resources),
    'serviceAccount': obj.serviceAccount,
    'storage': toJson_TempoMonolithicSpecStorage(obj.storage),
    'timeout': obj.timeout,
    'tolerations': obj.tolerations?.map(y => toJson_TempoMonolithicSpecTolerations(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Affinity defines the Affinity rules for scheduling pods.
 *
 * @schema TempoMonolithicSpecAffinity
 */
export interface TempoMonolithicSpecAffinity {
  /**
   * Describes node affinity scheduling rules for the pod.
   *
   * @schema TempoMonolithicSpecAffinity#nodeAffinity
   */
  readonly nodeAffinity?: TempoMonolithicSpecAffinityNodeAffinity;

  /**
   * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
   *
   * @schema TempoMonolithicSpecAffinity#podAffinity
   */
  readonly podAffinity?: TempoMonolithicSpecAffinityPodAffinity;

  /**
   * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
   *
   * @schema TempoMonolithicSpecAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: TempoMonolithicSpecAffinityPodAntiAffinity;

}

/**
 * Converts an object of type 'TempoMonolithicSpecAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecAffinity(obj: TempoMonolithicSpecAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeAffinity': toJson_TempoMonolithicSpecAffinityNodeAffinity(obj.nodeAffinity),
    'podAffinity': toJson_TempoMonolithicSpecAffinityPodAffinity(obj.podAffinity),
    'podAntiAffinity': toJson_TempoMonolithicSpecAffinityPodAntiAffinity(obj.podAntiAffinity),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ExtraConfig defines any extra (overlay) configuration of components.
 *
 * @schema TempoMonolithicSpecExtraConfig
 */
export interface TempoMonolithicSpecExtraConfig {
  /**
   * Tempo defines any extra Tempo configuration, which will be merged with the operator's generated Tempo configuration
   *
   * @schema TempoMonolithicSpecExtraConfig#tempo
   */
  readonly tempo?: any;

}

/**
 * Converts an object of type 'TempoMonolithicSpecExtraConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecExtraConfig(obj: TempoMonolithicSpecExtraConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'tempo': obj.tempo,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Ingestion defines the trace ingestion configuration.
 *
 * @schema TempoMonolithicSpecIngestion
 */
export interface TempoMonolithicSpecIngestion {
  /**
   * OTLP defines the ingestion configuration for the OTLP protocol.
   *
   * @schema TempoMonolithicSpecIngestion#otlp
   */
  readonly otlp?: TempoMonolithicSpecIngestionOtlp;

}

/**
 * Converts an object of type 'TempoMonolithicSpecIngestion' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecIngestion(obj: TempoMonolithicSpecIngestion | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'otlp': toJson_TempoMonolithicSpecIngestionOtlp(obj.otlp),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * JaegerUI defines the Jaeger UI configuration.
 *
 * @schema TempoMonolithicSpecJaegerui
 */
export interface TempoMonolithicSpecJaegerui {
  /**
   * Authentication defines the options for the oauth proxy used to protect jaeger UI
   *
   * @schema TempoMonolithicSpecJaegerui#authentication
   */
  readonly authentication?: TempoMonolithicSpecJaegeruiAuthentication;

  /**
   * Enabled defines if the Jaeger UI component should be created.
   *
   * @schema TempoMonolithicSpecJaegerui#enabled
   */
  readonly enabled: boolean;

  /**
   * FindTracesConcurrentRequests defines how many concurrent request a single trace search can submit (defaults 2).
   * The search for traces in Jaeger submits limit+1 requests. First requests finds trace IDs and then it fetches
   * entire traces by ID. This property allows Jaeger to fetch traces in parallel.
   * Note that by default a single Tempo querier can process 20 concurrent search jobs.
   * Increasing this property might require scaling up querier instances, especially on error "job queue full"
   * See also Tempo's extraConfig:
   * querier.max_concurrent_queries (20 default)
   * query_frontend.max_outstanding_per_tenant: (2000 default). Increase if the query-frontend returns 429
   *
   * @schema TempoMonolithicSpecJaegerui#findTracesConcurrentRequests
   */
  readonly findTracesConcurrentRequests?: number;

  /**
   * Ingress defines the Ingress configuration for the Jaeger UI.
   *
   * @schema TempoMonolithicSpecJaegerui#ingress
   */
  readonly ingress?: TempoMonolithicSpecJaegeruiIngress;

  /**
   * Resources defines the compute resource requirements of the Jaeger UI container.
   *
   * @schema TempoMonolithicSpecJaegerui#resources
   */
  readonly resources?: TempoMonolithicSpecJaegeruiResources;

  /**
   * Route defines the OpenShift route configuration for the Jaeger UI.
   *
   * @schema TempoMonolithicSpecJaegerui#route
   */
  readonly route?: TempoMonolithicSpecJaegeruiRoute;

  /**
   * ServicesQueryDuration defines how long the services will be available in the services list
   *
   * @schema TempoMonolithicSpecJaegerui#servicesQueryDuration
   */
  readonly servicesQueryDuration?: string;

}

/**
 * Converts an object of type 'TempoMonolithicSpecJaegerui' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecJaegerui(obj: TempoMonolithicSpecJaegerui | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authentication': toJson_TempoMonolithicSpecJaegeruiAuthentication(obj.authentication),
    'enabled': obj.enabled,
    'findTracesConcurrentRequests': obj.findTracesConcurrentRequests,
    'ingress': toJson_TempoMonolithicSpecJaegeruiIngress(obj.ingress),
    'resources': toJson_TempoMonolithicSpecJaegeruiResources(obj.resources),
    'route': toJson_TempoMonolithicSpecJaegeruiRoute(obj.route),
    'servicesQueryDuration': obj.servicesQueryDuration,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ManagementState defines whether this instance is managed by the operator or self-managed.
 * Default: Managed.
 *
 * @schema TempoMonolithicSpecManagement
 */
export enum TempoMonolithicSpecManagement {
  /** Managed */
  MANAGED = "Managed",
  /** Unmanaged */
  UNMANAGED = "Unmanaged",
}

/**
 * Multitenancy defines the multi-tenancy configuration.
 *
 * @schema TempoMonolithicSpecMultitenancy
 */
export interface TempoMonolithicSpecMultitenancy {
  /**
   * Authentication defines the tempo-gateway component authentication configuration spec per tenant.
   *
   * @schema TempoMonolithicSpecMultitenancy#authentication
   */
  readonly authentication?: TempoMonolithicSpecMultitenancyAuthentication[];

  /**
   * Authorization defines the tempo-gateway component authorization configuration spec per tenant.
   *
   * @schema TempoMonolithicSpecMultitenancy#authorization
   */
  readonly authorization?: TempoMonolithicSpecMultitenancyAuthorization;

  /**
   * Enabled defines if multi-tenancy is enabled.
   *
   * @schema TempoMonolithicSpecMultitenancy#enabled
   */
  readonly enabled: boolean;

  /**
   * Mode defines the multitenancy mode.
   *
   * @schema TempoMonolithicSpecMultitenancy#mode
   */
  readonly mode: TempoMonolithicSpecMultitenancyMode;

  /**
   * Resources defines the compute resource requirements of the gateway container.
   * The gateway performs authentication and authorization of incoming requests when multi-tenancy is enabled.
   *
   * @schema TempoMonolithicSpecMultitenancy#resources
   */
  readonly resources?: TempoMonolithicSpecMultitenancyResources;

}

/**
 * Converts an object of type 'TempoMonolithicSpecMultitenancy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecMultitenancy(obj: TempoMonolithicSpecMultitenancy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authentication': obj.authentication?.map(y => toJson_TempoMonolithicSpecMultitenancyAuthentication(y)),
    'authorization': toJson_TempoMonolithicSpecMultitenancyAuthorization(obj.authorization),
    'enabled': obj.enabled,
    'mode': obj.mode,
    'resources': toJson_TempoMonolithicSpecMultitenancyResources(obj.resources),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Observability defines the observability configuration of the Tempo deployment.
 *
 * @schema TempoMonolithicSpecObservability
 */
export interface TempoMonolithicSpecObservability {
  /**
   * Grafana defines the Grafana configuration of the Tempo deployment.
   *
   * @schema TempoMonolithicSpecObservability#grafana
   */
  readonly grafana?: TempoMonolithicSpecObservabilityGrafana;

  /**
   * Metrics defines the metric configuration of the Tempo deployment.
   *
   * @schema TempoMonolithicSpecObservability#metrics
   */
  readonly metrics?: TempoMonolithicSpecObservabilityMetrics;

}

/**
 * Converts an object of type 'TempoMonolithicSpecObservability' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecObservability(obj: TempoMonolithicSpecObservability | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'grafana': toJson_TempoMonolithicSpecObservabilityGrafana(obj.grafana),
    'metrics': toJson_TempoMonolithicSpecObservabilityMetrics(obj.metrics),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Query defines query configuration.
 *
 * @schema TempoMonolithicSpecQuery
 */
export interface TempoMonolithicSpecQuery {
  /**
   * RBAC defines query RBAC options.
   * This option can be used only with multi-tenancy.
   *
   * @schema TempoMonolithicSpecQuery#rbac
   */
  readonly rbac?: TempoMonolithicSpecQueryRbac;

}

/**
 * Converts an object of type 'TempoMonolithicSpecQuery' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecQuery(obj: TempoMonolithicSpecQuery | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'rbac': toJson_TempoMonolithicSpecQueryRbac(obj.rbac),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resources defines the compute resource requirements of the Tempo container.
 *
 * @schema TempoMonolithicSpecResources
 */
export interface TempoMonolithicSpecResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema TempoMonolithicSpecResources#claims
   */
  readonly claims?: TempoMonolithicSpecResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema TempoMonolithicSpecResources#limits
   */
  readonly limits?: { [key: string]: TempoMonolithicSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema TempoMonolithicSpecResources#requests
   */
  readonly requests?: { [key: string]: TempoMonolithicSpecResourcesRequests };

}

/**
 * Converts an object of type 'TempoMonolithicSpecResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecResources(obj: TempoMonolithicSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claims': obj.claims?.map(y => toJson_TempoMonolithicSpecResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Storage defines the storage configuration.
 *
 * @schema TempoMonolithicSpecStorage
 */
export interface TempoMonolithicSpecStorage {
  /**
   * Traces defines the storage configuration for traces.
   *
   * @schema TempoMonolithicSpecStorage#traces
   */
  readonly traces: TempoMonolithicSpecStorageTraces;

}

/**
 * Converts an object of type 'TempoMonolithicSpecStorage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecStorage(obj: TempoMonolithicSpecStorage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'traces': toJson_TempoMonolithicSpecStorageTraces(obj.traces),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema TempoMonolithicSpecTolerations
 */
export interface TempoMonolithicSpecTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema TempoMonolithicSpecTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema TempoMonolithicSpecTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema TempoMonolithicSpecTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict). Zero and
   * negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema TempoMonolithicSpecTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema TempoMonolithicSpecTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'TempoMonolithicSpecTolerations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecTolerations(obj: TempoMonolithicSpecTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Describes node affinity scheduling rules for the pod.
 *
 * @schema TempoMonolithicSpecAffinityNodeAffinity
 */
export interface TempoMonolithicSpecAffinityNodeAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node matches the corresponding matchExpressions; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema TempoMonolithicSpecAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: TempoMonolithicSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to an update), the system
   * may or may not try to eventually evict the pod from its node.
   *
   * @schema TempoMonolithicSpecAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: TempoMonolithicSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;

}

/**
 * Converts an object of type 'TempoMonolithicSpecAffinityNodeAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecAffinityNodeAffinity(obj: TempoMonolithicSpecAffinityNodeAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_TempoMonolithicSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': toJson_TempoMonolithicSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj.requiredDuringSchedulingIgnoredDuringExecution),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
 *
 * @schema TempoMonolithicSpecAffinityPodAffinity
 */
export interface TempoMonolithicSpecAffinityPodAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema TempoMonolithicSpecAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: TempoMonolithicSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to a pod label update), the
   * system may or may not try to eventually evict the pod from its node.
   * When there are multiple elements, the lists of nodes corresponding to each
   * podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema TempoMonolithicSpecAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: TempoMonolithicSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'TempoMonolithicSpecAffinityPodAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecAffinityPodAffinity(obj: TempoMonolithicSpecAffinityPodAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_TempoMonolithicSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_TempoMonolithicSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
 *
 * @schema TempoMonolithicSpecAffinityPodAntiAffinity
 */
export interface TempoMonolithicSpecAffinityPodAntiAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the anti-affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling anti-affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema TempoMonolithicSpecAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: TempoMonolithicSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the anti-affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the anti-affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to a pod label update), the
   * system may or may not try to eventually evict the pod from its node.
   * When there are multiple elements, the lists of nodes corresponding to each
   * podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema TempoMonolithicSpecAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: TempoMonolithicSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'TempoMonolithicSpecAffinityPodAntiAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecAffinityPodAntiAffinity(obj: TempoMonolithicSpecAffinityPodAntiAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_TempoMonolithicSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_TempoMonolithicSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * OTLP defines the ingestion configuration for the OTLP protocol.
 *
 * @schema TempoMonolithicSpecIngestionOtlp
 */
export interface TempoMonolithicSpecIngestionOtlp {
  /**
   * GRPC defines the OTLP over gRPC configuration.
   *
   * @schema TempoMonolithicSpecIngestionOtlp#grpc
   */
  readonly grpc?: TempoMonolithicSpecIngestionOtlpGrpc;

  /**
   * HTTP defines the OTLP over HTTP configuration.
   *
   * @schema TempoMonolithicSpecIngestionOtlp#http
   */
  readonly http?: TempoMonolithicSpecIngestionOtlpHttp;

}

/**
 * Converts an object of type 'TempoMonolithicSpecIngestionOtlp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecIngestionOtlp(obj: TempoMonolithicSpecIngestionOtlp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'grpc': toJson_TempoMonolithicSpecIngestionOtlpGrpc(obj.grpc),
    'http': toJson_TempoMonolithicSpecIngestionOtlpHttp(obj.http),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Authentication defines the options for the oauth proxy used to protect jaeger UI
 *
 * @schema TempoMonolithicSpecJaegeruiAuthentication
 */
export interface TempoMonolithicSpecJaegeruiAuthentication {
  /**
   * Defines if the authentication will be enabled for jaeger UI.
   *
   * @schema TempoMonolithicSpecJaegeruiAuthentication#enabled
   */
  readonly enabled?: boolean;

  /**
   * Resources defines the compute resource requirements of the OAuth Proxy container.
   * The OAuth Proxy performs authentication and authorization of incoming requests to Jaeger UI when multi-tenancy is disabled.
   *
   * @schema TempoMonolithicSpecJaegeruiAuthentication#resources
   */
  readonly resources?: TempoMonolithicSpecJaegeruiAuthenticationResources;

  /**
   * SAR defines the SAR to be used in the oauth-proxy
   * default is "{"namespace": "<tempo_stack_namespace>", "resource": "pods", "verb": "get"}
   *
   * @schema TempoMonolithicSpecJaegeruiAuthentication#sar
   */
  readonly sar?: string;

}

/**
 * Converts an object of type 'TempoMonolithicSpecJaegeruiAuthentication' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecJaegeruiAuthentication(obj: TempoMonolithicSpecJaegeruiAuthentication | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'resources': toJson_TempoMonolithicSpecJaegeruiAuthenticationResources(obj.resources),
    'sar': obj.sar,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Ingress defines the Ingress configuration for the Jaeger UI.
 *
 * @schema TempoMonolithicSpecJaegeruiIngress
 */
export interface TempoMonolithicSpecJaegeruiIngress {
  /**
   * Annotations defines the annotations of the Ingress object.
   *
   * @schema TempoMonolithicSpecJaegeruiIngress#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Enabled defines if an Ingress object should be created for Jaeger UI.
   *
   * @schema TempoMonolithicSpecJaegeruiIngress#enabled
   */
  readonly enabled: boolean;

  /**
   * Host defines the hostname of the Ingress object.
   *
   * @schema TempoMonolithicSpecJaegeruiIngress#host
   */
  readonly host?: string;

  /**
   * IngressClassName defines the name of an IngressClass cluster resource.
   * Defines which ingress controller serves this ingress resource.
   *
   * @schema TempoMonolithicSpecJaegeruiIngress#ingressClassName
   */
  readonly ingressClassName?: string;

}

/**
 * Converts an object of type 'TempoMonolithicSpecJaegeruiIngress' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecJaegeruiIngress(obj: TempoMonolithicSpecJaegeruiIngress | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'enabled': obj.enabled,
    'host': obj.host,
    'ingressClassName': obj.ingressClassName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resources defines the compute resource requirements of the Jaeger UI container.
 *
 * @schema TempoMonolithicSpecJaegeruiResources
 */
export interface TempoMonolithicSpecJaegeruiResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema TempoMonolithicSpecJaegeruiResources#claims
   */
  readonly claims?: TempoMonolithicSpecJaegeruiResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema TempoMonolithicSpecJaegeruiResources#limits
   */
  readonly limits?: { [key: string]: TempoMonolithicSpecJaegeruiResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema TempoMonolithicSpecJaegeruiResources#requests
   */
  readonly requests?: { [key: string]: TempoMonolithicSpecJaegeruiResourcesRequests };

}

/**
 * Converts an object of type 'TempoMonolithicSpecJaegeruiResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecJaegeruiResources(obj: TempoMonolithicSpecJaegeruiResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claims': obj.claims?.map(y => toJson_TempoMonolithicSpecJaegeruiResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Route defines the OpenShift route configuration for the Jaeger UI.
 *
 * @schema TempoMonolithicSpecJaegeruiRoute
 */
export interface TempoMonolithicSpecJaegeruiRoute {
  /**
   * Annotations defines the annotations of the Route object.
   *
   * @schema TempoMonolithicSpecJaegeruiRoute#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Enabled defines if a Route object should be created for Jaeger UI.
   *
   * @schema TempoMonolithicSpecJaegeruiRoute#enabled
   */
  readonly enabled: boolean;

  /**
   * Host defines the hostname of the Route object.
   *
   * @schema TempoMonolithicSpecJaegeruiRoute#host
   */
  readonly host?: string;

  /**
   * Termination specifies the termination type.
   *
   * @schema TempoMonolithicSpecJaegeruiRoute#termination
   */
  readonly termination?: TempoMonolithicSpecJaegeruiRouteTermination;

}

/**
 * Converts an object of type 'TempoMonolithicSpecJaegeruiRoute' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecJaegeruiRoute(obj: TempoMonolithicSpecJaegeruiRoute | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'enabled': obj.enabled,
    'host': obj.host,
    'termination': obj.termination,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AuthenticationSpec defines the oidc configuration per tenant for tempo Gateway component.
 *
 * @schema TempoMonolithicSpecMultitenancyAuthentication
 */
export interface TempoMonolithicSpecMultitenancyAuthentication {
  /**
   * OIDC defines the spec for the OIDC tenant's authentication.
   *
   * @schema TempoMonolithicSpecMultitenancyAuthentication#oidc
   */
  readonly oidc?: TempoMonolithicSpecMultitenancyAuthenticationOidc;

  /**
   * TenantID defines a universally unique identifier of the tenant.
   * Unlike the tenantName, which must be unique at a given time, the tenantId must be unique over the entire lifetime of the Tempo deployment.
   * Tempo uses this ID to prefix objects in the object storage.
   *
   * @schema TempoMonolithicSpecMultitenancyAuthentication#tenantId
   */
  readonly tenantId: string;

  /**
   * TenantName defines a human readable, unique name of the tenant.
   * The value of this field must be specified in the X-Scope-OrgID header and in the resources field of a ClusterRole to identify the tenant.
   *
   * @schema TempoMonolithicSpecMultitenancyAuthentication#tenantName
   */
  readonly tenantName: string;

}

/**
 * Converts an object of type 'TempoMonolithicSpecMultitenancyAuthentication' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecMultitenancyAuthentication(obj: TempoMonolithicSpecMultitenancyAuthentication | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'oidc': toJson_TempoMonolithicSpecMultitenancyAuthenticationOidc(obj.oidc),
    'tenantId': obj.tenantId,
    'tenantName': obj.tenantName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Authorization defines the tempo-gateway component authorization configuration spec per tenant.
 *
 * @schema TempoMonolithicSpecMultitenancyAuthorization
 */
export interface TempoMonolithicSpecMultitenancyAuthorization {
  /**
   * RoleBindings defines configuration to bind a set of roles to a set of subjects.
   *
   * @schema TempoMonolithicSpecMultitenancyAuthorization#roleBindings
   */
  readonly roleBindings?: TempoMonolithicSpecMultitenancyAuthorizationRoleBindings[];

  /**
   * Roles defines a set of permissions to interact with a tenant.
   *
   * @schema TempoMonolithicSpecMultitenancyAuthorization#roles
   */
  readonly roles?: TempoMonolithicSpecMultitenancyAuthorizationRoles[];

}

/**
 * Converts an object of type 'TempoMonolithicSpecMultitenancyAuthorization' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecMultitenancyAuthorization(obj: TempoMonolithicSpecMultitenancyAuthorization | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'roleBindings': obj.roleBindings?.map(y => toJson_TempoMonolithicSpecMultitenancyAuthorizationRoleBindings(y)),
    'roles': obj.roles?.map(y => toJson_TempoMonolithicSpecMultitenancyAuthorizationRoles(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Mode defines the multitenancy mode.
 *
 * @schema TempoMonolithicSpecMultitenancyMode
 */
export enum TempoMonolithicSpecMultitenancyMode {
  /** static */
  STATIC = "static",
  /** openshift */
  OPENSHIFT = "openshift",
}

/**
 * Resources defines the compute resource requirements of the gateway container.
 * The gateway performs authentication and authorization of incoming requests when multi-tenancy is enabled.
 *
 * @schema TempoMonolithicSpecMultitenancyResources
 */
export interface TempoMonolithicSpecMultitenancyResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema TempoMonolithicSpecMultitenancyResources#claims
   */
  readonly claims?: TempoMonolithicSpecMultitenancyResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema TempoMonolithicSpecMultitenancyResources#limits
   */
  readonly limits?: { [key: string]: TempoMonolithicSpecMultitenancyResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema TempoMonolithicSpecMultitenancyResources#requests
   */
  readonly requests?: { [key: string]: TempoMonolithicSpecMultitenancyResourcesRequests };

}

/**
 * Converts an object of type 'TempoMonolithicSpecMultitenancyResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecMultitenancyResources(obj: TempoMonolithicSpecMultitenancyResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claims': obj.claims?.map(y => toJson_TempoMonolithicSpecMultitenancyResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Grafana defines the Grafana configuration of the Tempo deployment.
 *
 * @schema TempoMonolithicSpecObservabilityGrafana
 */
export interface TempoMonolithicSpecObservabilityGrafana {
  /**
   * DataSource defines the Grafana data source configuration.
   *
   * @schema TempoMonolithicSpecObservabilityGrafana#dataSource
   */
  readonly dataSource?: TempoMonolithicSpecObservabilityGrafanaDataSource;

}

/**
 * Converts an object of type 'TempoMonolithicSpecObservabilityGrafana' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecObservabilityGrafana(obj: TempoMonolithicSpecObservabilityGrafana | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dataSource': toJson_TempoMonolithicSpecObservabilityGrafanaDataSource(obj.dataSource),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metrics defines the metric configuration of the Tempo deployment.
 *
 * @schema TempoMonolithicSpecObservabilityMetrics
 */
export interface TempoMonolithicSpecObservabilityMetrics {
  /**
   * ServiceMonitors defines the PrometheusRule configuration.
   *
   * @schema TempoMonolithicSpecObservabilityMetrics#prometheusRules
   */
  readonly prometheusRules?: TempoMonolithicSpecObservabilityMetricsPrometheusRules;

  /**
   * ServiceMonitors defines the ServiceMonitor configuration.
   *
   * @schema TempoMonolithicSpecObservabilityMetrics#serviceMonitors
   */
  readonly serviceMonitors?: TempoMonolithicSpecObservabilityMetricsServiceMonitors;

}

/**
 * Converts an object of type 'TempoMonolithicSpecObservabilityMetrics' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecObservabilityMetrics(obj: TempoMonolithicSpecObservabilityMetrics | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'prometheusRules': toJson_TempoMonolithicSpecObservabilityMetricsPrometheusRules(obj.prometheusRules),
    'serviceMonitors': toJson_TempoMonolithicSpecObservabilityMetricsServiceMonitors(obj.serviceMonitors),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RBAC defines query RBAC options.
 * This option can be used only with multi-tenancy.
 *
 * @schema TempoMonolithicSpecQueryRbac
 */
export interface TempoMonolithicSpecQueryRbac {
  /**
   * Enabled defines if the query RBAC should be enabled.
   *
   * @schema TempoMonolithicSpecQueryRbac#enabled
   */
  readonly enabled?: boolean;

}

/**
 * Converts an object of type 'TempoMonolithicSpecQueryRbac' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecQueryRbac(obj: TempoMonolithicSpecQueryRbac | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema TempoMonolithicSpecResourcesClaims
 */
export interface TempoMonolithicSpecResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema TempoMonolithicSpecResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema TempoMonolithicSpecResourcesClaims#request
   */
  readonly request?: string;

}

/**
 * Converts an object of type 'TempoMonolithicSpecResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecResourcesClaims(obj: TempoMonolithicSpecResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'request': obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TempoMonolithicSpecResourcesLimits
 */
export class TempoMonolithicSpecResourcesLimits {
  public static fromNumber(value: number): TempoMonolithicSpecResourcesLimits {
    return new TempoMonolithicSpecResourcesLimits(value);
  }
  public static fromString(value: string): TempoMonolithicSpecResourcesLimits {
    return new TempoMonolithicSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema TempoMonolithicSpecResourcesRequests
 */
export class TempoMonolithicSpecResourcesRequests {
  public static fromNumber(value: number): TempoMonolithicSpecResourcesRequests {
    return new TempoMonolithicSpecResourcesRequests(value);
  }
  public static fromString(value: string): TempoMonolithicSpecResourcesRequests {
    return new TempoMonolithicSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Traces defines the storage configuration for traces.
 *
 * @schema TempoMonolithicSpecStorageTraces
 */
export interface TempoMonolithicSpecStorageTraces {
  /**
   * Azure defines the configuration for Azure Storage.
   *
   * @schema TempoMonolithicSpecStorageTraces#azure
   */
  readonly azure?: TempoMonolithicSpecStorageTracesAzure;

  /**
   * Backend defines the backend for storing traces.
   * Default: memory.
   *
   * @schema TempoMonolithicSpecStorageTraces#backend
   */
  readonly backend: TempoMonolithicSpecStorageTracesBackend;

  /**
   * GCP defines the configuration for Google Cloud Storage.
   *
   * @schema TempoMonolithicSpecStorageTraces#gcs
   */
  readonly gcs?: TempoMonolithicSpecStorageTracesGcs;

  /**
   * S3 defines the configuration for Amazon S3.
   *
   * @schema TempoMonolithicSpecStorageTraces#s3
   */
  readonly s3?: TempoMonolithicSpecStorageTracesS3;

  /**
   * Size defines the size of the volume where traces are stored.
   * For in-memory storage, this defines the size of the tmpfs volume.
   * For persistent volume storage, this defines the size of the persistent volume.
   * For object storage, this defines the size of the persistent volume containing the Write-Ahead Log (WAL) of Tempo.
   * Default: 2Gi for memory, 10Gi for all other backends.
   *
   * @schema TempoMonolithicSpecStorageTraces#size
   */
  readonly size?: TempoMonolithicSpecStorageTracesSize;

}

/**
 * Converts an object of type 'TempoMonolithicSpecStorageTraces' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecStorageTraces(obj: TempoMonolithicSpecStorageTraces | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'azure': toJson_TempoMonolithicSpecStorageTracesAzure(obj.azure),
    'backend': obj.backend,
    'gcs': toJson_TempoMonolithicSpecStorageTracesGcs(obj.gcs),
    's3': toJson_TempoMonolithicSpecStorageTracesS3(obj.s3),
    'size': obj.size?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * An empty preferred scheduling term matches all objects with implicit weight 0
 * (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
 *
 * @schema TempoMonolithicSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface TempoMonolithicSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * A node selector term, associated with the corresponding weight.
   *
   * @schema TempoMonolithicSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference: TempoMonolithicSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
   *
   * @schema TempoMonolithicSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;

}

/**
 * Converts an object of type 'TempoMonolithicSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: TempoMonolithicSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preference': toJson_TempoMonolithicSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj.preference),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * If the affinity requirements specified by this field are not met at
 * scheduling time, the pod will not be scheduled onto the node.
 * If the affinity requirements specified by this field cease to be met
 * at some point during pod execution (e.g. due to an update), the system
 * may or may not try to eventually evict the pod from its node.
 *
 * @schema TempoMonolithicSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface TempoMonolithicSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A list of node selector terms. The terms are ORed.
   *
   * @schema TempoMonolithicSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms: TempoMonolithicSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];

}

/**
 * Converts an object of type 'TempoMonolithicSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: TempoMonolithicSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeSelectorTerms': obj.nodeSelectorTerms?.map(y => toJson_TempoMonolithicSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema TempoMonolithicSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface TempoMonolithicSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema TempoMonolithicSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm: TempoMonolithicSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm,
   * in the range 1-100.
   *
   * @schema TempoMonolithicSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;

}

/**
 * Converts an object of type 'TempoMonolithicSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: TempoMonolithicSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podAffinityTerm': toJson_TempoMonolithicSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector
 * relative to the given namespace(s)) that this pod should be
 * co-located (affinity) or not co-located (anti-affinity) with,
 * where co-located is defined as running on a node whose value of
 * the label with key <topologyKey> matches that of any node on which
 * a pod of the set of pods is running
 *
 * @schema TempoMonolithicSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface TempoMonolithicSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema TempoMonolithicSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: TempoMonolithicSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema TempoMonolithicSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema TempoMonolithicSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema TempoMonolithicSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: TempoMonolithicSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema TempoMonolithicSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema TempoMonolithicSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'TempoMonolithicSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: TempoMonolithicSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_TempoMonolithicSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'mismatchLabelKeys': obj.mismatchLabelKeys?.map(y => y),
    'namespaceSelector': toJson_TempoMonolithicSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema TempoMonolithicSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface TempoMonolithicSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema TempoMonolithicSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm: TempoMonolithicSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm,
   * in the range 1-100.
   *
   * @schema TempoMonolithicSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;

}

/**
 * Converts an object of type 'TempoMonolithicSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: TempoMonolithicSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podAffinityTerm': toJson_TempoMonolithicSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector
 * relative to the given namespace(s)) that this pod should be
 * co-located (affinity) or not co-located (anti-affinity) with,
 * where co-located is defined as running on a node whose value of
 * the label with key <topologyKey> matches that of any node on which
 * a pod of the set of pods is running
 *
 * @schema TempoMonolithicSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface TempoMonolithicSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema TempoMonolithicSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: TempoMonolithicSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema TempoMonolithicSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema TempoMonolithicSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema TempoMonolithicSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: TempoMonolithicSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema TempoMonolithicSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema TempoMonolithicSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'TempoMonolithicSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: TempoMonolithicSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_TempoMonolithicSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'mismatchLabelKeys': obj.mismatchLabelKeys?.map(y => y),
    'namespaceSelector': toJson_TempoMonolithicSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC defines the OTLP over gRPC configuration.
 *
 * @schema TempoMonolithicSpecIngestionOtlpGrpc
 */
export interface TempoMonolithicSpecIngestionOtlpGrpc {
  /**
   * Enabled defines if OTLP over gRPC is enabled.
   * Default: enabled.
   *
   * @schema TempoMonolithicSpecIngestionOtlpGrpc#enabled
   */
  readonly enabled: boolean;

  /**
   * TLS defines the TLS configuration for OTLP/gRPC ingestion.
   *
   * On OpenShift when operator config `servingCertsService`  and TLS is enabled  but no `certName` and `caName`
   * are provided it will use OpenShift serving certificate service.
   *
   * @schema TempoMonolithicSpecIngestionOtlpGrpc#tls
   */
  readonly tls?: TempoMonolithicSpecIngestionOtlpGrpcTls;

}

/**
 * Converts an object of type 'TempoMonolithicSpecIngestionOtlpGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecIngestionOtlpGrpc(obj: TempoMonolithicSpecIngestionOtlpGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'tls': toJson_TempoMonolithicSpecIngestionOtlpGrpcTls(obj.tls),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTP defines the OTLP over HTTP configuration.
 *
 * @schema TempoMonolithicSpecIngestionOtlpHttp
 */
export interface TempoMonolithicSpecIngestionOtlpHttp {
  /**
   * Enabled defines if OTLP over HTTP is enabled.
   * Default: enabled.
   *
   * @schema TempoMonolithicSpecIngestionOtlpHttp#enabled
   */
  readonly enabled: boolean;

  /**
   * TLS defines the TLS configuration for OTLP/HTTP ingestion.
   *
   * On OpenShift when operator config `servingCertsService`  and TLS is enabled  but no `certName` and `caName`
   * are provided it will use OpenShift serving certificate service.
   *
   * @schema TempoMonolithicSpecIngestionOtlpHttp#tls
   */
  readonly tls?: TempoMonolithicSpecIngestionOtlpHttpTls;

}

/**
 * Converts an object of type 'TempoMonolithicSpecIngestionOtlpHttp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecIngestionOtlpHttp(obj: TempoMonolithicSpecIngestionOtlpHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'tls': toJson_TempoMonolithicSpecIngestionOtlpHttpTls(obj.tls),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resources defines the compute resource requirements of the OAuth Proxy container.
 * The OAuth Proxy performs authentication and authorization of incoming requests to Jaeger UI when multi-tenancy is disabled.
 *
 * @schema TempoMonolithicSpecJaegeruiAuthenticationResources
 */
export interface TempoMonolithicSpecJaegeruiAuthenticationResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema TempoMonolithicSpecJaegeruiAuthenticationResources#claims
   */
  readonly claims?: TempoMonolithicSpecJaegeruiAuthenticationResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema TempoMonolithicSpecJaegeruiAuthenticationResources#limits
   */
  readonly limits?: { [key: string]: TempoMonolithicSpecJaegeruiAuthenticationResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema TempoMonolithicSpecJaegeruiAuthenticationResources#requests
   */
  readonly requests?: { [key: string]: TempoMonolithicSpecJaegeruiAuthenticationResourcesRequests };

}

/**
 * Converts an object of type 'TempoMonolithicSpecJaegeruiAuthenticationResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecJaegeruiAuthenticationResources(obj: TempoMonolithicSpecJaegeruiAuthenticationResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claims': obj.claims?.map(y => toJson_TempoMonolithicSpecJaegeruiAuthenticationResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema TempoMonolithicSpecJaegeruiResourcesClaims
 */
export interface TempoMonolithicSpecJaegeruiResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema TempoMonolithicSpecJaegeruiResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema TempoMonolithicSpecJaegeruiResourcesClaims#request
   */
  readonly request?: string;

}

/**
 * Converts an object of type 'TempoMonolithicSpecJaegeruiResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecJaegeruiResourcesClaims(obj: TempoMonolithicSpecJaegeruiResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'request': obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TempoMonolithicSpecJaegeruiResourcesLimits
 */
export class TempoMonolithicSpecJaegeruiResourcesLimits {
  public static fromNumber(value: number): TempoMonolithicSpecJaegeruiResourcesLimits {
    return new TempoMonolithicSpecJaegeruiResourcesLimits(value);
  }
  public static fromString(value: string): TempoMonolithicSpecJaegeruiResourcesLimits {
    return new TempoMonolithicSpecJaegeruiResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema TempoMonolithicSpecJaegeruiResourcesRequests
 */
export class TempoMonolithicSpecJaegeruiResourcesRequests {
  public static fromNumber(value: number): TempoMonolithicSpecJaegeruiResourcesRequests {
    return new TempoMonolithicSpecJaegeruiResourcesRequests(value);
  }
  public static fromString(value: string): TempoMonolithicSpecJaegeruiResourcesRequests {
    return new TempoMonolithicSpecJaegeruiResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Termination specifies the termination type.
 *
 * @schema TempoMonolithicSpecJaegeruiRouteTermination
 */
export enum TempoMonolithicSpecJaegeruiRouteTermination {
  /** insecure */
  INSECURE = "insecure",
  /** edge */
  EDGE = "edge",
  /** passthrough */
  PASSTHROUGH = "passthrough",
  /** reencrypt */
  REENCRYPT = "reencrypt",
}

/**
 * OIDC defines the spec for the OIDC tenant's authentication.
 *
 * @schema TempoMonolithicSpecMultitenancyAuthenticationOidc
 */
export interface TempoMonolithicSpecMultitenancyAuthenticationOidc {
  /**
   * Group claim field from ID Token
   *
   * @schema TempoMonolithicSpecMultitenancyAuthenticationOidc#groupClaim
   */
  readonly groupClaim?: string;

  /**
   * IssuerURL defines the URL for issuer.
   *
   * @schema TempoMonolithicSpecMultitenancyAuthenticationOidc#issuerURL
   */
  readonly issuerUrl?: string;

  /**
   * RedirectURL defines the URL for redirect.
   *
   * @schema TempoMonolithicSpecMultitenancyAuthenticationOidc#redirectURL
   */
  readonly redirectUrl?: string;

  /**
   * Secret defines the spec for the clientID, clientSecret and issuerCAPath for tenant's authentication.
   *
   * @schema TempoMonolithicSpecMultitenancyAuthenticationOidc#secret
   */
  readonly secret?: TempoMonolithicSpecMultitenancyAuthenticationOidcSecret;

  /**
   * User claim field from ID Token
   *
   * @schema TempoMonolithicSpecMultitenancyAuthenticationOidc#usernameClaim
   */
  readonly usernameClaim?: string;

}

/**
 * Converts an object of type 'TempoMonolithicSpecMultitenancyAuthenticationOidc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecMultitenancyAuthenticationOidc(obj: TempoMonolithicSpecMultitenancyAuthenticationOidc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'groupClaim': obj.groupClaim,
    'issuerURL': obj.issuerUrl,
    'redirectURL': obj.redirectUrl,
    'secret': toJson_TempoMonolithicSpecMultitenancyAuthenticationOidcSecret(obj.secret),
    'usernameClaim': obj.usernameClaim,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RoleBindingsSpec binds a set of roles to a set of subjects.
 *
 * @schema TempoMonolithicSpecMultitenancyAuthorizationRoleBindings
 */
export interface TempoMonolithicSpecMultitenancyAuthorizationRoleBindings {
  /**
   * @schema TempoMonolithicSpecMultitenancyAuthorizationRoleBindings#name
   */
  readonly name: string;

  /**
   * @schema TempoMonolithicSpecMultitenancyAuthorizationRoleBindings#roles
   */
  readonly roles: string[];

  /**
   * @schema TempoMonolithicSpecMultitenancyAuthorizationRoleBindings#subjects
   */
  readonly subjects: TempoMonolithicSpecMultitenancyAuthorizationRoleBindingsSubjects[];

}

/**
 * Converts an object of type 'TempoMonolithicSpecMultitenancyAuthorizationRoleBindings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecMultitenancyAuthorizationRoleBindings(obj: TempoMonolithicSpecMultitenancyAuthorizationRoleBindings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'roles': obj.roles?.map(y => y),
    'subjects': obj.subjects?.map(y => toJson_TempoMonolithicSpecMultitenancyAuthorizationRoleBindingsSubjects(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RoleSpec describes a set of permissions to interact with a tenant.
 *
 * @schema TempoMonolithicSpecMultitenancyAuthorizationRoles
 */
export interface TempoMonolithicSpecMultitenancyAuthorizationRoles {
  /**
   * @schema TempoMonolithicSpecMultitenancyAuthorizationRoles#name
   */
  readonly name: string;

  /**
   * @schema TempoMonolithicSpecMultitenancyAuthorizationRoles#permissions
   */
  readonly permissions: TempoMonolithicSpecMultitenancyAuthorizationRolesPermissions[];

  /**
   * @schema TempoMonolithicSpecMultitenancyAuthorizationRoles#resources
   */
  readonly resources: string[];

  /**
   * @schema TempoMonolithicSpecMultitenancyAuthorizationRoles#tenants
   */
  readonly tenants: string[];

}

/**
 * Converts an object of type 'TempoMonolithicSpecMultitenancyAuthorizationRoles' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecMultitenancyAuthorizationRoles(obj: TempoMonolithicSpecMultitenancyAuthorizationRoles | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'permissions': obj.permissions?.map(y => y),
    'resources': obj.resources?.map(y => y),
    'tenants': obj.tenants?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema TempoMonolithicSpecMultitenancyResourcesClaims
 */
export interface TempoMonolithicSpecMultitenancyResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema TempoMonolithicSpecMultitenancyResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema TempoMonolithicSpecMultitenancyResourcesClaims#request
   */
  readonly request?: string;

}

/**
 * Converts an object of type 'TempoMonolithicSpecMultitenancyResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecMultitenancyResourcesClaims(obj: TempoMonolithicSpecMultitenancyResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'request': obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TempoMonolithicSpecMultitenancyResourcesLimits
 */
export class TempoMonolithicSpecMultitenancyResourcesLimits {
  public static fromNumber(value: number): TempoMonolithicSpecMultitenancyResourcesLimits {
    return new TempoMonolithicSpecMultitenancyResourcesLimits(value);
  }
  public static fromString(value: string): TempoMonolithicSpecMultitenancyResourcesLimits {
    return new TempoMonolithicSpecMultitenancyResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema TempoMonolithicSpecMultitenancyResourcesRequests
 */
export class TempoMonolithicSpecMultitenancyResourcesRequests {
  public static fromNumber(value: number): TempoMonolithicSpecMultitenancyResourcesRequests {
    return new TempoMonolithicSpecMultitenancyResourcesRequests(value);
  }
  public static fromString(value: string): TempoMonolithicSpecMultitenancyResourcesRequests {
    return new TempoMonolithicSpecMultitenancyResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * DataSource defines the Grafana data source configuration.
 *
 * @schema TempoMonolithicSpecObservabilityGrafanaDataSource
 */
export interface TempoMonolithicSpecObservabilityGrafanaDataSource {
  /**
   * Enabled defines if a Grafana data source should be created for this Tempo deployment.
   *
   * @schema TempoMonolithicSpecObservabilityGrafanaDataSource#enabled
   */
  readonly enabled: boolean;

  /**
   * InstanceSelector defines the Grafana instance where the data source should be created.
   *
   * @schema TempoMonolithicSpecObservabilityGrafanaDataSource#instanceSelector
   */
  readonly instanceSelector?: TempoMonolithicSpecObservabilityGrafanaDataSourceInstanceSelector;

}

/**
 * Converts an object of type 'TempoMonolithicSpecObservabilityGrafanaDataSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecObservabilityGrafanaDataSource(obj: TempoMonolithicSpecObservabilityGrafanaDataSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'instanceSelector': toJson_TempoMonolithicSpecObservabilityGrafanaDataSourceInstanceSelector(obj.instanceSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ServiceMonitors defines the PrometheusRule configuration.
 *
 * @schema TempoMonolithicSpecObservabilityMetricsPrometheusRules
 */
export interface TempoMonolithicSpecObservabilityMetricsPrometheusRules {
  /**
   * Enabled defines if PrometheusRule objects should be created for this Tempo deployment.
   *
   * @schema TempoMonolithicSpecObservabilityMetricsPrometheusRules#enabled
   */
  readonly enabled: boolean;

}

/**
 * Converts an object of type 'TempoMonolithicSpecObservabilityMetricsPrometheusRules' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecObservabilityMetricsPrometheusRules(obj: TempoMonolithicSpecObservabilityMetricsPrometheusRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ServiceMonitors defines the ServiceMonitor configuration.
 *
 * @schema TempoMonolithicSpecObservabilityMetricsServiceMonitors
 */
export interface TempoMonolithicSpecObservabilityMetricsServiceMonitors {
  /**
   * Enabled defines if ServiceMonitor objects should be created for this Tempo deployment.
   *
   * @schema TempoMonolithicSpecObservabilityMetricsServiceMonitors#enabled
   */
  readonly enabled: boolean;

}

/**
 * Converts an object of type 'TempoMonolithicSpecObservabilityMetricsServiceMonitors' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecObservabilityMetricsServiceMonitors(obj: TempoMonolithicSpecObservabilityMetricsServiceMonitors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Azure defines the configuration for Azure Storage.
 *
 * @schema TempoMonolithicSpecStorageTracesAzure
 */
export interface TempoMonolithicSpecStorageTracesAzure {
  /**
   * Secret is the name of a Secret containing credentials for accessing object storage.
   * It needs to be in the same namespace as the TempoMonolithic custom resource.
   *
   * @schema TempoMonolithicSpecStorageTracesAzure#secret
   */
  readonly secret: string;

}

/**
 * Converts an object of type 'TempoMonolithicSpecStorageTracesAzure' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecStorageTracesAzure(obj: TempoMonolithicSpecStorageTracesAzure | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secret': obj.secret,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Backend defines the backend for storing traces.
 * Default: memory.
 *
 * @schema TempoMonolithicSpecStorageTracesBackend
 */
export enum TempoMonolithicSpecStorageTracesBackend {
  /** memory */
  MEMORY = "memory",
  /** pv */
  PV = "pv",
  /** azure */
  AZURE = "azure",
  /** gcs */
  GCS = "gcs",
  /** s3 */
  S3 = "s3",
}

/**
 * GCP defines the configuration for Google Cloud Storage.
 *
 * @schema TempoMonolithicSpecStorageTracesGcs
 */
export interface TempoMonolithicSpecStorageTracesGcs {
  /**
   * Secret is the name of a Secret containing credentials for accessing object storage.
   * It needs to be in the same namespace as the TempoMonolithic custom resource.
   *
   * @schema TempoMonolithicSpecStorageTracesGcs#secret
   */
  readonly secret: string;

}

/**
 * Converts an object of type 'TempoMonolithicSpecStorageTracesGcs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecStorageTracesGcs(obj: TempoMonolithicSpecStorageTracesGcs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secret': obj.secret,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * S3 defines the configuration for Amazon S3.
 *
 * @schema TempoMonolithicSpecStorageTracesS3
 */
export interface TempoMonolithicSpecStorageTracesS3 {
  /**
   * CredentialMode can be used to set the desired credential mode for authenticating with the object storage.
   * If this is not set, then the operator tries to infer the credential mode from the provided secret and its
   * own configuration.
   *
   * @schema TempoMonolithicSpecStorageTracesS3#credentialMode
   */
  readonly credentialMode?: TempoMonolithicSpecStorageTracesS3CredentialMode;

  /**
   * Secret is the name of a Secret containing credentials for accessing object storage.
   * It needs to be in the same namespace as the TempoMonolithic custom resource.
   *
   * @schema TempoMonolithicSpecStorageTracesS3#secret
   */
  readonly secret: string;

  /**
   * TLS defines the TLS configuration for Amazon S3.
   *
   * @schema TempoMonolithicSpecStorageTracesS3#tls
   */
  readonly tls?: TempoMonolithicSpecStorageTracesS3Tls;

}

/**
 * Converts an object of type 'TempoMonolithicSpecStorageTracesS3' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecStorageTracesS3(obj: TempoMonolithicSpecStorageTracesS3 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentialMode': obj.credentialMode,
    'secret': obj.secret,
    'tls': toJson_TempoMonolithicSpecStorageTracesS3Tls(obj.tls),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Size defines the size of the volume where traces are stored.
 * For in-memory storage, this defines the size of the tmpfs volume.
 * For persistent volume storage, this defines the size of the persistent volume.
 * For object storage, this defines the size of the persistent volume containing the Write-Ahead Log (WAL) of Tempo.
 * Default: 2Gi for memory, 10Gi for all other backends.
 *
 * @schema TempoMonolithicSpecStorageTracesSize
 */
export class TempoMonolithicSpecStorageTracesSize {
  public static fromNumber(value: number): TempoMonolithicSpecStorageTracesSize {
    return new TempoMonolithicSpecStorageTracesSize(value);
  }
  public static fromString(value: string): TempoMonolithicSpecStorageTracesSize {
    return new TempoMonolithicSpecStorageTracesSize(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A node selector term, associated with the corresponding weight.
 *
 * @schema TempoMonolithicSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface TempoMonolithicSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema TempoMonolithicSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: TempoMonolithicSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema TempoMonolithicSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: TempoMonolithicSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];

}

/**
 * Converts an object of type 'TempoMonolithicSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj: TempoMonolithicSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_TempoMonolithicSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_TempoMonolithicSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A null or empty node selector term matches no objects. The requirements of
 * them are ANDed.
 * The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
 *
 * @schema TempoMonolithicSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface TempoMonolithicSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema TempoMonolithicSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: TempoMonolithicSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema TempoMonolithicSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: TempoMonolithicSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];

}

/**
 * Converts an object of type 'TempoMonolithicSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(obj: TempoMonolithicSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_TempoMonolithicSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_TempoMonolithicSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema TempoMonolithicSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface TempoMonolithicSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema TempoMonolithicSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: TempoMonolithicSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema TempoMonolithicSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema TempoMonolithicSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema TempoMonolithicSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: TempoMonolithicSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema TempoMonolithicSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema TempoMonolithicSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'TempoMonolithicSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: TempoMonolithicSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_TempoMonolithicSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'mismatchLabelKeys': obj.mismatchLabelKeys?.map(y => y),
    'namespaceSelector': toJson_TempoMonolithicSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema TempoMonolithicSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface TempoMonolithicSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema TempoMonolithicSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: TempoMonolithicSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema TempoMonolithicSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'TempoMonolithicSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: TempoMonolithicSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_TempoMonolithicSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema TempoMonolithicSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface TempoMonolithicSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema TempoMonolithicSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: TempoMonolithicSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema TempoMonolithicSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'TempoMonolithicSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: TempoMonolithicSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_TempoMonolithicSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema TempoMonolithicSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface TempoMonolithicSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema TempoMonolithicSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: TempoMonolithicSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema TempoMonolithicSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema TempoMonolithicSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema TempoMonolithicSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: TempoMonolithicSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema TempoMonolithicSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema TempoMonolithicSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'TempoMonolithicSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: TempoMonolithicSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_TempoMonolithicSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'mismatchLabelKeys': obj.mismatchLabelKeys?.map(y => y),
    'namespaceSelector': toJson_TempoMonolithicSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema TempoMonolithicSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface TempoMonolithicSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema TempoMonolithicSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: TempoMonolithicSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema TempoMonolithicSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'TempoMonolithicSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: TempoMonolithicSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_TempoMonolithicSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema TempoMonolithicSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface TempoMonolithicSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema TempoMonolithicSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: TempoMonolithicSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema TempoMonolithicSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'TempoMonolithicSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: TempoMonolithicSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_TempoMonolithicSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLS defines the TLS configuration for OTLP/gRPC ingestion.
 *
 * On OpenShift when operator config `servingCertsService`  and TLS is enabled  but no `certName` and `caName`
 * are provided it will use OpenShift serving certificate service.
 *
 * @schema TempoMonolithicSpecIngestionOtlpGrpcTls
 */
export interface TempoMonolithicSpecIngestionOtlpGrpcTls {
  /**
   * CA is the name of a ConfigMap containing a CA certificate (service-ca.crt).
   * It needs to be in the same namespace as the Tempo custom resource.
   *
   * @schema TempoMonolithicSpecIngestionOtlpGrpcTls#caName
   */
  readonly caName?: string;

  /**
   * Cert is the name of a Secret containing a certificate (tls.crt) and private key (tls.key).
   * It needs to be in the same namespace as the Tempo custom resource.
   *
   * @schema TempoMonolithicSpecIngestionOtlpGrpcTls#certName
   */
  readonly certName?: string;

  /**
   * Enabled defines if TLS is enabled.
   *
   * @schema TempoMonolithicSpecIngestionOtlpGrpcTls#enabled
   */
  readonly enabled?: boolean;

  /**
   * MinVersion defines the minimum acceptable TLS version.
   *
   * @schema TempoMonolithicSpecIngestionOtlpGrpcTls#minVersion
   */
  readonly minVersion?: string;

}

/**
 * Converts an object of type 'TempoMonolithicSpecIngestionOtlpGrpcTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecIngestionOtlpGrpcTls(obj: TempoMonolithicSpecIngestionOtlpGrpcTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caName': obj.caName,
    'certName': obj.certName,
    'enabled': obj.enabled,
    'minVersion': obj.minVersion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLS defines the TLS configuration for OTLP/HTTP ingestion.
 *
 * On OpenShift when operator config `servingCertsService`  and TLS is enabled  but no `certName` and `caName`
 * are provided it will use OpenShift serving certificate service.
 *
 * @schema TempoMonolithicSpecIngestionOtlpHttpTls
 */
export interface TempoMonolithicSpecIngestionOtlpHttpTls {
  /**
   * CA is the name of a ConfigMap containing a CA certificate (service-ca.crt).
   * It needs to be in the same namespace as the Tempo custom resource.
   *
   * @schema TempoMonolithicSpecIngestionOtlpHttpTls#caName
   */
  readonly caName?: string;

  /**
   * Cert is the name of a Secret containing a certificate (tls.crt) and private key (tls.key).
   * It needs to be in the same namespace as the Tempo custom resource.
   *
   * @schema TempoMonolithicSpecIngestionOtlpHttpTls#certName
   */
  readonly certName?: string;

  /**
   * Enabled defines if TLS is enabled.
   *
   * @schema TempoMonolithicSpecIngestionOtlpHttpTls#enabled
   */
  readonly enabled?: boolean;

  /**
   * MinVersion defines the minimum acceptable TLS version.
   *
   * @schema TempoMonolithicSpecIngestionOtlpHttpTls#minVersion
   */
  readonly minVersion?: string;

}

/**
 * Converts an object of type 'TempoMonolithicSpecIngestionOtlpHttpTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecIngestionOtlpHttpTls(obj: TempoMonolithicSpecIngestionOtlpHttpTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caName': obj.caName,
    'certName': obj.certName,
    'enabled': obj.enabled,
    'minVersion': obj.minVersion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema TempoMonolithicSpecJaegeruiAuthenticationResourcesClaims
 */
export interface TempoMonolithicSpecJaegeruiAuthenticationResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema TempoMonolithicSpecJaegeruiAuthenticationResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema TempoMonolithicSpecJaegeruiAuthenticationResourcesClaims#request
   */
  readonly request?: string;

}

/**
 * Converts an object of type 'TempoMonolithicSpecJaegeruiAuthenticationResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecJaegeruiAuthenticationResourcesClaims(obj: TempoMonolithicSpecJaegeruiAuthenticationResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'request': obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TempoMonolithicSpecJaegeruiAuthenticationResourcesLimits
 */
export class TempoMonolithicSpecJaegeruiAuthenticationResourcesLimits {
  public static fromNumber(value: number): TempoMonolithicSpecJaegeruiAuthenticationResourcesLimits {
    return new TempoMonolithicSpecJaegeruiAuthenticationResourcesLimits(value);
  }
  public static fromString(value: string): TempoMonolithicSpecJaegeruiAuthenticationResourcesLimits {
    return new TempoMonolithicSpecJaegeruiAuthenticationResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema TempoMonolithicSpecJaegeruiAuthenticationResourcesRequests
 */
export class TempoMonolithicSpecJaegeruiAuthenticationResourcesRequests {
  public static fromNumber(value: number): TempoMonolithicSpecJaegeruiAuthenticationResourcesRequests {
    return new TempoMonolithicSpecJaegeruiAuthenticationResourcesRequests(value);
  }
  public static fromString(value: string): TempoMonolithicSpecJaegeruiAuthenticationResourcesRequests {
    return new TempoMonolithicSpecJaegeruiAuthenticationResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Secret defines the spec for the clientID, clientSecret and issuerCAPath for tenant's authentication.
 *
 * @schema TempoMonolithicSpecMultitenancyAuthenticationOidcSecret
 */
export interface TempoMonolithicSpecMultitenancyAuthenticationOidcSecret {
  /**
   * Name of a secret in the namespace configured for tenant secrets.
   *
   * @schema TempoMonolithicSpecMultitenancyAuthenticationOidcSecret#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'TempoMonolithicSpecMultitenancyAuthenticationOidcSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecMultitenancyAuthenticationOidcSecret(obj: TempoMonolithicSpecMultitenancyAuthenticationOidcSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Subject represents a subject that has been bound to a role.
 *
 * @schema TempoMonolithicSpecMultitenancyAuthorizationRoleBindingsSubjects
 */
export interface TempoMonolithicSpecMultitenancyAuthorizationRoleBindingsSubjects {
  /**
   * SubjectKind is a kind of Tempo Gateway RBAC subject.
   *
   * @schema TempoMonolithicSpecMultitenancyAuthorizationRoleBindingsSubjects#kind
   */
  readonly kind: TempoMonolithicSpecMultitenancyAuthorizationRoleBindingsSubjectsKind;

  /**
   * @schema TempoMonolithicSpecMultitenancyAuthorizationRoleBindingsSubjects#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'TempoMonolithicSpecMultitenancyAuthorizationRoleBindingsSubjects' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecMultitenancyAuthorizationRoleBindingsSubjects(obj: TempoMonolithicSpecMultitenancyAuthorizationRoleBindingsSubjects | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PermissionType is a Tempo Gateway RBAC permission.
 *
 * @schema TempoMonolithicSpecMultitenancyAuthorizationRolesPermissions
 */
export enum TempoMonolithicSpecMultitenancyAuthorizationRolesPermissions {
  /** read */
  READ = "read",
  /** write */
  WRITE = "write",
}

/**
 * InstanceSelector defines the Grafana instance where the data source should be created.
 *
 * @schema TempoMonolithicSpecObservabilityGrafanaDataSourceInstanceSelector
 */
export interface TempoMonolithicSpecObservabilityGrafanaDataSourceInstanceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema TempoMonolithicSpecObservabilityGrafanaDataSourceInstanceSelector#matchExpressions
   */
  readonly matchExpressions?: TempoMonolithicSpecObservabilityGrafanaDataSourceInstanceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema TempoMonolithicSpecObservabilityGrafanaDataSourceInstanceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'TempoMonolithicSpecObservabilityGrafanaDataSourceInstanceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecObservabilityGrafanaDataSourceInstanceSelector(obj: TempoMonolithicSpecObservabilityGrafanaDataSourceInstanceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_TempoMonolithicSpecObservabilityGrafanaDataSourceInstanceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CredentialMode can be used to set the desired credential mode for authenticating with the object storage.
 * If this is not set, then the operator tries to infer the credential mode from the provided secret and its
 * own configuration.
 *
 * @schema TempoMonolithicSpecStorageTracesS3CredentialMode
 */
export enum TempoMonolithicSpecStorageTracesS3CredentialMode {
  /** static */
  STATIC = "static",
  /** token */
  TOKEN = "token",
  /** token-cco */
  TOKEN_HYPHEN_CCO = "token-cco",
}

/**
 * TLS defines the TLS configuration for Amazon S3.
 *
 * @schema TempoMonolithicSpecStorageTracesS3Tls
 */
export interface TempoMonolithicSpecStorageTracesS3Tls {
  /**
   * CA is the name of a ConfigMap containing a CA certificate (service-ca.crt).
   * It needs to be in the same namespace as the Tempo custom resource.
   *
   * @schema TempoMonolithicSpecStorageTracesS3Tls#caName
   */
  readonly caName?: string;

  /**
   * Cert is the name of a Secret containing a certificate (tls.crt) and private key (tls.key).
   * It needs to be in the same namespace as the Tempo custom resource.
   *
   * @schema TempoMonolithicSpecStorageTracesS3Tls#certName
   */
  readonly certName?: string;

  /**
   * Enabled defines if TLS is enabled.
   *
   * @schema TempoMonolithicSpecStorageTracesS3Tls#enabled
   */
  readonly enabled?: boolean;

  /**
   * MinVersion defines the minimum acceptable TLS version.
   *
   * @schema TempoMonolithicSpecStorageTracesS3Tls#minVersion
   */
  readonly minVersion?: string;

}

/**
 * Converts an object of type 'TempoMonolithicSpecStorageTracesS3Tls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecStorageTracesS3Tls(obj: TempoMonolithicSpecStorageTracesS3Tls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caName': obj.caName,
    'certName': obj.certName,
    'enabled': obj.enabled,
    'minVersion': obj.minVersion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema TempoMonolithicSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface TempoMonolithicSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema TempoMonolithicSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema TempoMonolithicSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema TempoMonolithicSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'TempoMonolithicSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(obj: TempoMonolithicSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema TempoMonolithicSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface TempoMonolithicSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema TempoMonolithicSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema TempoMonolithicSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema TempoMonolithicSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'TempoMonolithicSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(obj: TempoMonolithicSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema TempoMonolithicSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface TempoMonolithicSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema TempoMonolithicSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema TempoMonolithicSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema TempoMonolithicSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'TempoMonolithicSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(obj: TempoMonolithicSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema TempoMonolithicSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface TempoMonolithicSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema TempoMonolithicSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema TempoMonolithicSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema TempoMonolithicSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'TempoMonolithicSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(obj: TempoMonolithicSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema TempoMonolithicSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface TempoMonolithicSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema TempoMonolithicSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: TempoMonolithicSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema TempoMonolithicSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'TempoMonolithicSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: TempoMonolithicSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_TempoMonolithicSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema TempoMonolithicSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface TempoMonolithicSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema TempoMonolithicSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: TempoMonolithicSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema TempoMonolithicSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'TempoMonolithicSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: TempoMonolithicSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_TempoMonolithicSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema TempoMonolithicSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface TempoMonolithicSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema TempoMonolithicSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema TempoMonolithicSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema TempoMonolithicSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'TempoMonolithicSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: TempoMonolithicSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema TempoMonolithicSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface TempoMonolithicSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema TempoMonolithicSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema TempoMonolithicSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema TempoMonolithicSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'TempoMonolithicSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: TempoMonolithicSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema TempoMonolithicSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface TempoMonolithicSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema TempoMonolithicSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: TempoMonolithicSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema TempoMonolithicSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'TempoMonolithicSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: TempoMonolithicSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_TempoMonolithicSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema TempoMonolithicSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface TempoMonolithicSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema TempoMonolithicSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: TempoMonolithicSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema TempoMonolithicSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'TempoMonolithicSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: TempoMonolithicSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_TempoMonolithicSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema TempoMonolithicSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface TempoMonolithicSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema TempoMonolithicSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema TempoMonolithicSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema TempoMonolithicSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'TempoMonolithicSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: TempoMonolithicSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema TempoMonolithicSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface TempoMonolithicSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema TempoMonolithicSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema TempoMonolithicSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema TempoMonolithicSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'TempoMonolithicSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: TempoMonolithicSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SubjectKind is a kind of Tempo Gateway RBAC subject.
 *
 * @schema TempoMonolithicSpecMultitenancyAuthorizationRoleBindingsSubjectsKind
 */
export enum TempoMonolithicSpecMultitenancyAuthorizationRoleBindingsSubjectsKind {
  /** user */
  USER = "user",
  /** group */
  GROUP = "group",
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema TempoMonolithicSpecObservabilityGrafanaDataSourceInstanceSelectorMatchExpressions
 */
export interface TempoMonolithicSpecObservabilityGrafanaDataSourceInstanceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema TempoMonolithicSpecObservabilityGrafanaDataSourceInstanceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema TempoMonolithicSpecObservabilityGrafanaDataSourceInstanceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema TempoMonolithicSpecObservabilityGrafanaDataSourceInstanceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'TempoMonolithicSpecObservabilityGrafanaDataSourceInstanceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecObservabilityGrafanaDataSourceInstanceSelectorMatchExpressions(obj: TempoMonolithicSpecObservabilityGrafanaDataSourceInstanceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema TempoMonolithicSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface TempoMonolithicSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema TempoMonolithicSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema TempoMonolithicSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema TempoMonolithicSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'TempoMonolithicSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: TempoMonolithicSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema TempoMonolithicSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface TempoMonolithicSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema TempoMonolithicSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema TempoMonolithicSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema TempoMonolithicSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'TempoMonolithicSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: TempoMonolithicSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema TempoMonolithicSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface TempoMonolithicSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema TempoMonolithicSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema TempoMonolithicSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema TempoMonolithicSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'TempoMonolithicSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: TempoMonolithicSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema TempoMonolithicSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface TempoMonolithicSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema TempoMonolithicSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema TempoMonolithicSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema TempoMonolithicSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'TempoMonolithicSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoMonolithicSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: TempoMonolithicSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * TempoStack manages a Tempo deployment in microservices mode.
 *
 * @schema TempoStack
 */
export class TempoStack extends ApiObject {
  /**
   * Returns the apiVersion and kind for "TempoStack"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'tempo.grafana.com/v1alpha1',
    kind: 'TempoStack',
  }

  /**
   * Renders a Kubernetes manifest for "TempoStack".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: TempoStackProps = {}): any {
    return {
      ...TempoStack.GVK,
      ...toJson_TempoStackProps(props),
    };
  }

  /**
   * Defines a "TempoStack" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: TempoStackProps = {}) {
    super(scope, id, {
      ...TempoStack.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...TempoStack.GVK,
      ...toJson_TempoStackProps(resolved),
    };
  }
}

/**
 * TempoStack manages a Tempo deployment in microservices mode.
 *
 * @schema TempoStack
 */
export interface TempoStackProps {
  /**
   * @schema TempoStack#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * TempoStackSpec defines the desired state of TempoStack.
   *
   * @schema TempoStack#spec
   */
  readonly spec?: TempoStackSpec;

}

/**
 * Converts an object of type 'TempoStackProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackProps(obj: TempoStackProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_TempoStackSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TempoStackSpec defines the desired state of TempoStack.
 *
 * @schema TempoStackSpec
 */
export interface TempoStackSpec {
  /**
   * ExtraConfigSpec defines extra configurations for tempo that will be merged with the operator generated, configurations defined here
   * has precedence and could override generated config.
   *
   * @schema TempoStackSpec#extraConfig
   */
  readonly extraConfig?: TempoStackSpecExtraConfig;

  /**
   * HashRing defines the spec for the distributed hash ring configuration.
   *
   * @schema TempoStackSpec#hashRing
   */
  readonly hashRing?: TempoStackSpecHashRing;

  /**
   * Images defines the image for each container.
   *
   * @schema TempoStackSpec#images
   */
  readonly images?: TempoStackSpecImages;

  /**
   * LimitSpec is used to limit ingestion and querying rates.
   *
   * @schema TempoStackSpec#limits
   */
  readonly limits?: TempoStackSpecLimits;

  /**
   * ManagementState defines if the CR should be managed by the operator or not.
   * Default is managed.
   *
   * @default managed.
   * @schema TempoStackSpec#managementState
   */
  readonly managementState: TempoStackSpecManagementState;

  /**
   * ObservabilitySpec defines how telemetry data gets handled.
   *
   * @schema TempoStackSpec#observability
   */
  readonly observability?: TempoStackSpecObservability;

  /**
   * The replication factor is a configuration setting that determines how many ingesters need to acknowledge the data from the distributors before accepting a span.
   *
   * @schema TempoStackSpec#replicationFactor
   */
  readonly replicationFactor?: number;

  /**
   * Resources defines resources configuration.
   *
   * @schema TempoStackSpec#resources
   */
  readonly resources?: TempoStackSpecResources;

  /**
   * Retention period defined by dataset.
   * User can specify how long data should be stored.
   *
   * @schema TempoStackSpec#retention
   */
  readonly retention?: TempoStackSpecRetention;

  /**
   * SearchSpec control the configuration for the search capabilities.
   *
   * @schema TempoStackSpec#search
   */
  readonly search?: TempoStackSpecSearch;

  /**
   * ServiceAccount defines the service account to use for all tempo components.
   *
   * @schema TempoStackSpec#serviceAccount
   */
  readonly serviceAccount?: string;

  /**
   * Storage defines the spec for the object storage endpoint to store traces.
   * User is required to create secret and supply it.
   *
   * @schema TempoStackSpec#storage
   */
  readonly storage: TempoStackSpecStorage;

  /**
   * StorageClassName for PVCs used by ingester. Defaults to nil (default storage class in the cluster).
   *
   * @default nil (default storage class in the cluster).
   * @schema TempoStackSpec#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * StorageSize for PVCs used by ingester. Defaults to 10Gi.
   *
   * @default 10Gi.
   * @schema TempoStackSpec#storageSize
   */
  readonly storageSize?: TempoStackSpecStorageSize;

  /**
   * Template defines requirements for a set of tempo components.
   *
   * @schema TempoStackSpec#template
   */
  readonly template?: TempoStackSpecTemplate;

  /**
   * Tenants defines the per-tenant authentication and authorization spec.
   *
   * @schema TempoStackSpec#tenants
   */
  readonly tenants?: TempoStackSpecTenants;

  /**
   * Timeout configures the same timeout on all components starting at ingress down to the ingestor/querier.
   * Timeout configuration on a specific component has a higher precedence.
   * Defaults to 30 seconds.
   *
   * @default 30 seconds.
   * @schema TempoStackSpec#timeout
   */
  readonly timeout?: string;

}

/**
 * Converts an object of type 'TempoStackSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpec(obj: TempoStackSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'extraConfig': toJson_TempoStackSpecExtraConfig(obj.extraConfig),
    'hashRing': toJson_TempoStackSpecHashRing(obj.hashRing),
    'images': toJson_TempoStackSpecImages(obj.images),
    'limits': toJson_TempoStackSpecLimits(obj.limits),
    'managementState': obj.managementState,
    'observability': toJson_TempoStackSpecObservability(obj.observability),
    'replicationFactor': obj.replicationFactor,
    'resources': toJson_TempoStackSpecResources(obj.resources),
    'retention': toJson_TempoStackSpecRetention(obj.retention),
    'search': toJson_TempoStackSpecSearch(obj.search),
    'serviceAccount': obj.serviceAccount,
    'storage': toJson_TempoStackSpecStorage(obj.storage),
    'storageClassName': obj.storageClassName,
    'storageSize': obj.storageSize?.value,
    'template': toJson_TempoStackSpecTemplate(obj.template),
    'tenants': toJson_TempoStackSpecTenants(obj.tenants),
    'timeout': obj.timeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ExtraConfigSpec defines extra configurations for tempo that will be merged with the operator generated, configurations defined here
 * has precedence and could override generated config.
 *
 * @schema TempoStackSpecExtraConfig
 */
export interface TempoStackSpecExtraConfig {
  /**
   * Tempo defines any extra Tempo configuration, which will be merged with the operator's generated Tempo configuration
   *
   * @schema TempoStackSpecExtraConfig#tempo
   */
  readonly tempo?: any;

}

/**
 * Converts an object of type 'TempoStackSpecExtraConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecExtraConfig(obj: TempoStackSpecExtraConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'tempo': obj.tempo,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HashRing defines the spec for the distributed hash ring configuration.
 *
 * @schema TempoStackSpecHashRing
 */
export interface TempoStackSpecHashRing {
  /**
   * MemberList configuration spec
   *
   * @schema TempoStackSpecHashRing#memberlist
   */
  readonly memberlist?: TempoStackSpecHashRingMemberlist;

}

/**
 * Converts an object of type 'TempoStackSpecHashRing' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecHashRing(obj: TempoStackSpecHashRing | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'memberlist': toJson_TempoStackSpecHashRingMemberlist(obj.memberlist),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Images defines the image for each container.
 *
 * @schema TempoStackSpecImages
 */
export interface TempoStackSpecImages {
  /**
   * JaegerQuery defines the tempo-query container image.
   *
   * @schema TempoStackSpecImages#jaegerQuery
   */
  readonly jaegerQuery?: string;

  /**
   * OauthProxy defines the oauth proxy image used to protect the jaegerUI on single tenant.
   *
   * @schema TempoStackSpecImages#oauthProxy
   */
  readonly oauthProxy?: string;

  /**
   * Tempo defines the tempo container image.
   *
   * @schema TempoStackSpecImages#tempo
   */
  readonly tempo?: string;

  /**
   * TempoGateway defines the tempo-gateway container image.
   *
   * @schema TempoStackSpecImages#tempoGateway
   */
  readonly tempoGateway?: string;

  /**
   * TempoGatewayOpa defines the OPA sidecar container for TempoGateway.
   *
   * @schema TempoStackSpecImages#tempoGatewayOpa
   */
  readonly tempoGatewayOpa?: string;

  /**
   * TempoQuery defines the tempo-query container image.
   *
   * @schema TempoStackSpecImages#tempoQuery
   */
  readonly tempoQuery?: string;

}

/**
 * Converts an object of type 'TempoStackSpecImages' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecImages(obj: TempoStackSpecImages | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'jaegerQuery': obj.jaegerQuery,
    'oauthProxy': obj.oauthProxy,
    'tempo': obj.tempo,
    'tempoGateway': obj.tempoGateway,
    'tempoGatewayOpa': obj.tempoGatewayOpa,
    'tempoQuery': obj.tempoQuery,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LimitSpec is used to limit ingestion and querying rates.
 *
 * @schema TempoStackSpecLimits
 */
export interface TempoStackSpecLimits {
  /**
   * Global is used to define global rate limits.
   *
   * @schema TempoStackSpecLimits#global
   */
  readonly global?: TempoStackSpecLimitsGlobal;

  /**
   * PerTenant is used to define rate limits per tenant.
   *
   * @schema TempoStackSpecLimits#perTenant
   */
  readonly perTenant?: { [key: string]: TempoStackSpecLimitsPerTenant };

}

/**
 * Converts an object of type 'TempoStackSpecLimits' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecLimits(obj: TempoStackSpecLimits | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'global': toJson_TempoStackSpecLimitsGlobal(obj.global),
    'perTenant': ((obj.perTenant) === undefined) ? undefined : (Object.entries(obj.perTenant).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: toJson_TempoStackSpecLimitsPerTenant(i[1]) }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ManagementState defines if the CR should be managed by the operator or not.
 * Default is managed.
 *
 * @default managed.
 * @schema TempoStackSpecManagementState
 */
export enum TempoStackSpecManagementState {
  /** Managed */
  MANAGED = "Managed",
  /** Unmanaged */
  UNMANAGED = "Unmanaged",
}

/**
 * ObservabilitySpec defines how telemetry data gets handled.
 *
 * @schema TempoStackSpecObservability
 */
export interface TempoStackSpecObservability {
  /**
   * Grafana defines the Grafana configuration for operands.
   *
   * @schema TempoStackSpecObservability#grafana
   */
  readonly grafana?: TempoStackSpecObservabilityGrafana;

  /**
   * Metrics defines the metrics configuration for operands.
   *
   * @schema TempoStackSpecObservability#metrics
   */
  readonly metrics?: TempoStackSpecObservabilityMetrics;

  /**
   * Tracing defines a config for operands.
   *
   * @schema TempoStackSpecObservability#tracing
   */
  readonly tracing?: TempoStackSpecObservabilityTracing;

}

/**
 * Converts an object of type 'TempoStackSpecObservability' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecObservability(obj: TempoStackSpecObservability | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'grafana': toJson_TempoStackSpecObservabilityGrafana(obj.grafana),
    'metrics': toJson_TempoStackSpecObservabilityMetrics(obj.metrics),
    'tracing': toJson_TempoStackSpecObservabilityTracing(obj.tracing),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resources defines resources configuration.
 *
 * @schema TempoStackSpecResources
 */
export interface TempoStackSpecResources {
  /**
   * The total amount of resources for Tempo instance.
   * The operator autonomously splits resources between deployed Tempo components.
   * Only limits are supported, the operator calculates requests automatically.
   * See http://github.com/grafana/tempo/issues/1540.
   *
   * @schema TempoStackSpecResources#total
   */
  readonly total?: TempoStackSpecResourcesTotal;

}

/**
 * Converts an object of type 'TempoStackSpecResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecResources(obj: TempoStackSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'total': toJson_TempoStackSpecResourcesTotal(obj.total),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Retention period defined by dataset.
 * User can specify how long data should be stored.
 *
 * @schema TempoStackSpecRetention
 */
export interface TempoStackSpecRetention {
  /**
   * Global is used to configure global retention.
   *
   * @schema TempoStackSpecRetention#global
   */
  readonly global?: TempoStackSpecRetentionGlobal;

  /**
   * PerTenant is used to configure retention per tenant.
   *
   * @schema TempoStackSpecRetention#perTenant
   */
  readonly perTenant?: { [key: string]: TempoStackSpecRetentionPerTenant };

}

/**
 * Converts an object of type 'TempoStackSpecRetention' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecRetention(obj: TempoStackSpecRetention | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'global': toJson_TempoStackSpecRetentionGlobal(obj.global),
    'perTenant': ((obj.perTenant) === undefined) ? undefined : (Object.entries(obj.perTenant).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: toJson_TempoStackSpecRetentionPerTenant(i[1]) }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SearchSpec control the configuration for the search capabilities.
 *
 * @schema TempoStackSpecSearch
 */
export interface TempoStackSpecSearch {
  /**
   * Limit used for search requests if none is set by the caller (default: 20)
   *
   * @schema TempoStackSpecSearch#defaultResultLimit
   */
  readonly defaultResultLimit?: number;

  /**
   * The maximum allowed time range for a search, default: 0s which means unlimited.
   *
   * @schema TempoStackSpecSearch#maxDuration
   */
  readonly maxDuration?: string;

  /**
   * The maximum allowed value of the limit parameter on search requests. If the search request limit parameter
   * exceeds the value configured here it will be set to the value configured here.
   * The default value of 0 disables this limit.
   *
   * @schema TempoStackSpecSearch#maxResultLimit
   */
  readonly maxResultLimit?: number;

}

/**
 * Converts an object of type 'TempoStackSpecSearch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecSearch(obj: TempoStackSpecSearch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultResultLimit': obj.defaultResultLimit,
    'maxDuration': obj.maxDuration,
    'maxResultLimit': obj.maxResultLimit,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Storage defines the spec for the object storage endpoint to store traces.
 * User is required to create secret and supply it.
 *
 * @schema TempoStackSpecStorage
 */
export interface TempoStackSpecStorage {
  /**
   * Secret for object storage authentication.
   * Name of a secret in the same namespace as the TempoStack custom resource.
   *
   * @schema TempoStackSpecStorage#secret
   */
  readonly secret: TempoStackSpecStorageSecret;

  /**
   * TLS configuration for reaching the object storage endpoint.
   *
   * @schema TempoStackSpecStorage#tls
   */
  readonly tls?: TempoStackSpecStorageTls;

}

/**
 * Converts an object of type 'TempoStackSpecStorage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecStorage(obj: TempoStackSpecStorage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secret': toJson_TempoStackSpecStorageSecret(obj.secret),
    'tls': toJson_TempoStackSpecStorageTls(obj.tls),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * StorageSize for PVCs used by ingester. Defaults to 10Gi.
 *
 * @default 10Gi.
 * @schema TempoStackSpecStorageSize
 */
export class TempoStackSpecStorageSize {
  public static fromNumber(value: number): TempoStackSpecStorageSize {
    return new TempoStackSpecStorageSize(value);
  }
  public static fromString(value: string): TempoStackSpecStorageSize {
    return new TempoStackSpecStorageSize(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Template defines requirements for a set of tempo components.
 *
 * @schema TempoStackSpecTemplate
 */
export interface TempoStackSpecTemplate {
  /**
   * Compactor defines the tempo compactor component spec.
   *
   * @schema TempoStackSpecTemplate#compactor
   */
  readonly compactor?: TempoStackSpecTemplateCompactor;

  /**
   * Distributor defines the distributor component spec.
   *
   * @schema TempoStackSpecTemplate#distributor
   */
  readonly distributor?: TempoStackSpecTemplateDistributor;

  /**
   * Gateway defines the tempo gateway spec.
   *
   * @schema TempoStackSpecTemplate#gateway
   */
  readonly gateway?: TempoStackSpecTemplateGateway;

  /**
   * Ingester defines the ingester component spec.
   *
   * @schema TempoStackSpecTemplate#ingester
   */
  readonly ingester?: TempoStackSpecTemplateIngester;

  /**
   * Querier defines the querier component spec.
   *
   * @schema TempoStackSpecTemplate#querier
   */
  readonly querier?: TempoStackSpecTemplateQuerier;

  /**
   * TempoQueryFrontendSpec defines the query frontend spec.
   *
   * @schema TempoStackSpecTemplate#queryFrontend
   */
  readonly queryFrontend?: TempoStackSpecTemplateQueryFrontend;

}

/**
 * Converts an object of type 'TempoStackSpecTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplate(obj: TempoStackSpecTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'compactor': toJson_TempoStackSpecTemplateCompactor(obj.compactor),
    'distributor': toJson_TempoStackSpecTemplateDistributor(obj.distributor),
    'gateway': toJson_TempoStackSpecTemplateGateway(obj.gateway),
    'ingester': toJson_TempoStackSpecTemplateIngester(obj.ingester),
    'querier': toJson_TempoStackSpecTemplateQuerier(obj.querier),
    'queryFrontend': toJson_TempoStackSpecTemplateQueryFrontend(obj.queryFrontend),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Tenants defines the per-tenant authentication and authorization spec.
 *
 * @schema TempoStackSpecTenants
 */
export interface TempoStackSpecTenants {
  /**
   * Authentication defines the tempo-gateway component authentication configuration spec per tenant.
   *
   * @schema TempoStackSpecTenants#authentication
   */
  readonly authentication?: TempoStackSpecTenantsAuthentication[];

  /**
   * Authorization defines the tempo-gateway component authorization configuration spec per tenant.
   *
   * @schema TempoStackSpecTenants#authorization
   */
  readonly authorization?: TempoStackSpecTenantsAuthorization;

  /**
   * Mode defines the multitenancy mode.
   *
   * @schema TempoStackSpecTenants#mode
   */
  readonly mode: TempoStackSpecTenantsMode;

}

/**
 * Converts an object of type 'TempoStackSpecTenants' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTenants(obj: TempoStackSpecTenants | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authentication': obj.authentication?.map(y => toJson_TempoStackSpecTenantsAuthentication(y)),
    'authorization': toJson_TempoStackSpecTenantsAuthorization(obj.authorization),
    'mode': obj.mode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * MemberList configuration spec
 *
 * @schema TempoStackSpecHashRingMemberlist
 */
export interface TempoStackSpecHashRingMemberlist {
  /**
   * EnableIPv6 enables IPv6 support for the memberlist based hash ring.
   *
   * @schema TempoStackSpecHashRingMemberlist#enableIPv6
   */
  readonly enableIPv6?: boolean;

  /**
   * InstanceAddrType defines the type of address to use to advertise to the ring.
   * Defaults to the first address from any private network interfaces of the current pod.
   * Alternatively the public pod IP can be used in case private networks (RFC 1918 and RFC 6598)
   * are not available.
   *
   * @default the first address from any private network interfaces of the current pod.
   * @schema TempoStackSpecHashRingMemberlist#instanceAddrType
   */
  readonly instanceAddrType?: TempoStackSpecHashRingMemberlistInstanceAddrType;

}

/**
 * Converts an object of type 'TempoStackSpecHashRingMemberlist' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecHashRingMemberlist(obj: TempoStackSpecHashRingMemberlist | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableIPv6': obj.enableIPv6,
    'instanceAddrType': obj.instanceAddrType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Global is used to define global rate limits.
 *
 * @schema TempoStackSpecLimitsGlobal
 */
export interface TempoStackSpecLimitsGlobal {
  /**
   * Ingestion is used to define ingestion rate limits.
   *
   * @schema TempoStackSpecLimitsGlobal#ingestion
   */
  readonly ingestion?: TempoStackSpecLimitsGlobalIngestion;

  /**
   * Query is used to define query rate limits.
   *
   * @schema TempoStackSpecLimitsGlobal#query
   */
  readonly query?: TempoStackSpecLimitsGlobalQuery;

}

/**
 * Converts an object of type 'TempoStackSpecLimitsGlobal' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecLimitsGlobal(obj: TempoStackSpecLimitsGlobal | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ingestion': toJson_TempoStackSpecLimitsGlobalIngestion(obj.ingestion),
    'query': toJson_TempoStackSpecLimitsGlobalQuery(obj.query),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RateLimitSpec defines rate limits for Ingestion and Query components.
 *
 * @schema TempoStackSpecLimitsPerTenant
 */
export interface TempoStackSpecLimitsPerTenant {
  /**
   * Ingestion is used to define ingestion rate limits.
   *
   * @schema TempoStackSpecLimitsPerTenant#ingestion
   */
  readonly ingestion?: TempoStackSpecLimitsPerTenantIngestion;

  /**
   * Query is used to define query rate limits.
   *
   * @schema TempoStackSpecLimitsPerTenant#query
   */
  readonly query?: TempoStackSpecLimitsPerTenantQuery;

}

/**
 * Converts an object of type 'TempoStackSpecLimitsPerTenant' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecLimitsPerTenant(obj: TempoStackSpecLimitsPerTenant | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ingestion': toJson_TempoStackSpecLimitsPerTenantIngestion(obj.ingestion),
    'query': toJson_TempoStackSpecLimitsPerTenantQuery(obj.query),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Grafana defines the Grafana configuration for operands.
 *
 * @schema TempoStackSpecObservabilityGrafana
 */
export interface TempoStackSpecObservabilityGrafana {
  /**
   * CreateDatasource specifies if a Grafana Datasource should be created for Tempo.
   *
   * @schema TempoStackSpecObservabilityGrafana#createDatasource
   */
  readonly createDatasource?: boolean;

  /**
   * InstanceSelector specifies the Grafana instance where the datasource should be created.
   *
   * @schema TempoStackSpecObservabilityGrafana#instanceSelector
   */
  readonly instanceSelector?: TempoStackSpecObservabilityGrafanaInstanceSelector;

}

/**
 * Converts an object of type 'TempoStackSpecObservabilityGrafana' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecObservabilityGrafana(obj: TempoStackSpecObservabilityGrafana | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'createDatasource': obj.createDatasource,
    'instanceSelector': toJson_TempoStackSpecObservabilityGrafanaInstanceSelector(obj.instanceSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metrics defines the metrics configuration for operands.
 *
 * @schema TempoStackSpecObservabilityMetrics
 */
export interface TempoStackSpecObservabilityMetrics {
  /**
   * CreatePrometheusRules specifies if Prometheus rules for alerts should be created for Tempo components.
   *
   * @schema TempoStackSpecObservabilityMetrics#createPrometheusRules
   */
  readonly createPrometheusRules?: boolean;

  /**
   * CreateServiceMonitors specifies if ServiceMonitors should be created for Tempo components.
   *
   * @schema TempoStackSpecObservabilityMetrics#createServiceMonitors
   */
  readonly createServiceMonitors?: boolean;

}

/**
 * Converts an object of type 'TempoStackSpecObservabilityMetrics' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecObservabilityMetrics(obj: TempoStackSpecObservabilityMetrics | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'createPrometheusRules': obj.createPrometheusRules,
    'createServiceMonitors': obj.createServiceMonitors,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Tracing defines a config for operands.
 *
 * @schema TempoStackSpecObservabilityTracing
 */
export interface TempoStackSpecObservabilityTracing {
  /**
   * JaegerAgentEndpoint defines the jaeger endpoint data gets send to.
   * Deprecated: in favor of OTLPHttpEndpoint.
   *
   * @schema TempoStackSpecObservabilityTracing#jaeger_agent_endpoint
   */
  readonly jaegerAgentEndpoint?: string;

  /**
   * OTLPHttpEndpoint defines the OTLP/http endpoint data gets send to.
   * For example, "http://localhost:4320".
   * The default OTLP/http port 4318 collides with the distributor ports, therefore it is recommended to use a different port
   * on the sidecar injected to the Tempo (e.g. 4320).
   *
   * @schema TempoStackSpecObservabilityTracing#otlp_http_endpoint
   */
  readonly otlpHttpEndpoint?: string;

  /**
   * SamplingFraction defines the sampling ratio. Valid values are 0 to 1.
   * The SamplingFraction has to be defined to enable tracing.
   *
   * @schema TempoStackSpecObservabilityTracing#sampling_fraction
   */
  readonly samplingFraction?: string;

}

/**
 * Converts an object of type 'TempoStackSpecObservabilityTracing' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecObservabilityTracing(obj: TempoStackSpecObservabilityTracing | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'jaeger_agent_endpoint': obj.jaegerAgentEndpoint,
    'otlp_http_endpoint': obj.otlpHttpEndpoint,
    'sampling_fraction': obj.samplingFraction,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The total amount of resources for Tempo instance.
 * The operator autonomously splits resources between deployed Tempo components.
 * Only limits are supported, the operator calculates requests automatically.
 * See http://github.com/grafana/tempo/issues/1540.
 *
 * @schema TempoStackSpecResourcesTotal
 */
export interface TempoStackSpecResourcesTotal {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema TempoStackSpecResourcesTotal#claims
   */
  readonly claims?: TempoStackSpecResourcesTotalClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema TempoStackSpecResourcesTotal#limits
   */
  readonly limits?: { [key: string]: TempoStackSpecResourcesTotalLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema TempoStackSpecResourcesTotal#requests
   */
  readonly requests?: { [key: string]: TempoStackSpecResourcesTotalRequests };

}

/**
 * Converts an object of type 'TempoStackSpecResourcesTotal' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecResourcesTotal(obj: TempoStackSpecResourcesTotal | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claims': obj.claims?.map(y => toJson_TempoStackSpecResourcesTotalClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Global is used to configure global retention.
 *
 * @schema TempoStackSpecRetentionGlobal
 */
export interface TempoStackSpecRetentionGlobal {
  /**
   * Traces defines retention period. Supported parameter suffixes are "s", "m" and "h".
   * example: 336h
   * default: value is 48h.
   *
   * @schema TempoStackSpecRetentionGlobal#traces
   */
  readonly traces?: string;

}

/**
 * Converts an object of type 'TempoStackSpecRetentionGlobal' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecRetentionGlobal(obj: TempoStackSpecRetentionGlobal | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'traces': obj.traces,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RetentionConfig defines how long data should be provided.
 *
 * @schema TempoStackSpecRetentionPerTenant
 */
export interface TempoStackSpecRetentionPerTenant {
  /**
   * Traces defines retention period. Supported parameter suffixes are "s", "m" and "h".
   * example: 336h
   * default: value is 48h.
   *
   * @schema TempoStackSpecRetentionPerTenant#traces
   */
  readonly traces?: string;

}

/**
 * Converts an object of type 'TempoStackSpecRetentionPerTenant' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecRetentionPerTenant(obj: TempoStackSpecRetentionPerTenant | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'traces': obj.traces,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret for object storage authentication.
 * Name of a secret in the same namespace as the TempoStack custom resource.
 *
 * @schema TempoStackSpecStorageSecret
 */
export interface TempoStackSpecStorageSecret {
  /**
   * CredentialMode can be used to set the desired credential mode for authenticating with the object storage.
   * If this is not set, then the operator tries to infer the credential mode from the provided secret and its
   * own configuration.
   *
   * @schema TempoStackSpecStorageSecret#credentialMode
   */
  readonly credentialMode?: TempoStackSpecStorageSecretCredentialMode;

  /**
   * Name of a secret in the namespace configured for object storage secrets.
   *
   * @schema TempoStackSpecStorageSecret#name
   */
  readonly name: string;

  /**
   * Type of object storage that should be used
   *
   * @schema TempoStackSpecStorageSecret#type
   */
  readonly type: TempoStackSpecStorageSecretType;

}

/**
 * Converts an object of type 'TempoStackSpecStorageSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecStorageSecret(obj: TempoStackSpecStorageSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentialMode': obj.credentialMode,
    'name': obj.name,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLS configuration for reaching the object storage endpoint.
 *
 * @schema TempoStackSpecStorageTls
 */
export interface TempoStackSpecStorageTls {
  /**
   * CA is the name of a ConfigMap containing a CA certificate (service-ca.crt).
   * It needs to be in the same namespace as the Tempo custom resource.
   *
   * @schema TempoStackSpecStorageTls#caName
   */
  readonly caName?: string;

  /**
   * Cert is the name of a Secret containing a certificate (tls.crt) and private key (tls.key).
   * It needs to be in the same namespace as the Tempo custom resource.
   *
   * @schema TempoStackSpecStorageTls#certName
   */
  readonly certName?: string;

  /**
   * Enabled defines if TLS is enabled.
   *
   * @schema TempoStackSpecStorageTls#enabled
   */
  readonly enabled?: boolean;

  /**
   * MinVersion defines the minimum acceptable TLS version.
   *
   * @schema TempoStackSpecStorageTls#minVersion
   */
  readonly minVersion?: string;

}

/**
 * Converts an object of type 'TempoStackSpecStorageTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecStorageTls(obj: TempoStackSpecStorageTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caName': obj.caName,
    'certName': obj.certName,
    'enabled': obj.enabled,
    'minVersion': obj.minVersion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Compactor defines the tempo compactor component spec.
 *
 * @schema TempoStackSpecTemplateCompactor
 */
export interface TempoStackSpecTemplateCompactor {
  /**
   * NodeSelector defines the simple form of the node-selection constraint.
   *
   * @schema TempoStackSpecTemplateCompactor#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * PodSecurityContext defines security context will be applied to all pods of this component.
   *
   * @schema TempoStackSpecTemplateCompactor#podSecurityContext
   */
  readonly podSecurityContext?: TempoStackSpecTemplateCompactorPodSecurityContext;

  /**
   * Replicas defines the number of replicas to be created for this component.
   *
   * @schema TempoStackSpecTemplateCompactor#replicas
   */
  readonly replicas?: number;

  /**
   * Resources defines resources for this component, this will override the calculated resources derived from total
   *
   * @schema TempoStackSpecTemplateCompactor#resources
   */
  readonly resources?: TempoStackSpecTemplateCompactorResources;

  /**
   * Tolerations defines component-specific pod tolerations.
   *
   * @schema TempoStackSpecTemplateCompactor#tolerations
   */
  readonly tolerations?: TempoStackSpecTemplateCompactorTolerations[];

}

/**
 * Converts an object of type 'TempoStackSpecTemplateCompactor' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateCompactor(obj: TempoStackSpecTemplateCompactor | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'podSecurityContext': toJson_TempoStackSpecTemplateCompactorPodSecurityContext(obj.podSecurityContext),
    'replicas': obj.replicas,
    'resources': toJson_TempoStackSpecTemplateCompactorResources(obj.resources),
    'tolerations': obj.tolerations?.map(y => toJson_TempoStackSpecTemplateCompactorTolerations(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Distributor defines the distributor component spec.
 *
 * @schema TempoStackSpecTemplateDistributor
 */
export interface TempoStackSpecTemplateDistributor {
  /**
   * TempoComponentSpec is embedded to extend this definition with further options.
   *
   * Currently, there is no way to inline this field.
   * See: https://github.com/golang/go/issues/6213
   *
   * @schema TempoStackSpecTemplateDistributor#component
   */
  readonly component?: TempoStackSpecTemplateDistributorComponent;

  /**
   * TLS defines TLS configuration for distributor receivers
   *
   * If openshift feature flag `servingCertsService` is enabled and TLS is enabled but no
   * certName or caName is specified, OpenShift service serving certificates will  be used.
   *
   * @schema TempoStackSpecTemplateDistributor#tls
   */
  readonly tls?: TempoStackSpecTemplateDistributorTls;

}

/**
 * Converts an object of type 'TempoStackSpecTemplateDistributor' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateDistributor(obj: TempoStackSpecTemplateDistributor | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'component': toJson_TempoStackSpecTemplateDistributorComponent(obj.component),
    'tls': toJson_TempoStackSpecTemplateDistributorTls(obj.tls),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Gateway defines the tempo gateway spec.
 *
 * @schema TempoStackSpecTemplateGateway
 */
export interface TempoStackSpecTemplateGateway {
  /**
   * TempoComponentSpec is embedded to extend this definition with further options.
   *
   * Currently there is no way to inline this field.
   * See: https://github.com/golang/go/issues/6213
   *
   * @schema TempoStackSpecTemplateGateway#component
   */
  readonly component?: TempoStackSpecTemplateGatewayComponent;

  /**
   * @schema TempoStackSpecTemplateGateway#enabled
   */
  readonly enabled: boolean;

  /**
   * Ingress defines gateway Ingress options.
   *
   * @schema TempoStackSpecTemplateGateway#ingress
   */
  readonly ingress?: TempoStackSpecTemplateGatewayIngress;

  /**
   * RBAC defines query RBAC options.
   *
   * @schema TempoStackSpecTemplateGateway#rbac
   */
  readonly rbac?: TempoStackSpecTemplateGatewayRbac;

}

/**
 * Converts an object of type 'TempoStackSpecTemplateGateway' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateGateway(obj: TempoStackSpecTemplateGateway | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'component': toJson_TempoStackSpecTemplateGatewayComponent(obj.component),
    'enabled': obj.enabled,
    'ingress': toJson_TempoStackSpecTemplateGatewayIngress(obj.ingress),
    'rbac': toJson_TempoStackSpecTemplateGatewayRbac(obj.rbac),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Ingester defines the ingester component spec.
 *
 * @schema TempoStackSpecTemplateIngester
 */
export interface TempoStackSpecTemplateIngester {
  /**
   * NodeSelector defines the simple form of the node-selection constraint.
   *
   * @schema TempoStackSpecTemplateIngester#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * PodSecurityContext defines security context will be applied to all pods of this component.
   *
   * @schema TempoStackSpecTemplateIngester#podSecurityContext
   */
  readonly podSecurityContext?: TempoStackSpecTemplateIngesterPodSecurityContext;

  /**
   * Replicas defines the number of replicas to be created for this component.
   *
   * @schema TempoStackSpecTemplateIngester#replicas
   */
  readonly replicas?: number;

  /**
   * Resources defines resources for this component, this will override the calculated resources derived from total
   *
   * @schema TempoStackSpecTemplateIngester#resources
   */
  readonly resources?: TempoStackSpecTemplateIngesterResources;

  /**
   * Tolerations defines component-specific pod tolerations.
   *
   * @schema TempoStackSpecTemplateIngester#tolerations
   */
  readonly tolerations?: TempoStackSpecTemplateIngesterTolerations[];

}

/**
 * Converts an object of type 'TempoStackSpecTemplateIngester' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateIngester(obj: TempoStackSpecTemplateIngester | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'podSecurityContext': toJson_TempoStackSpecTemplateIngesterPodSecurityContext(obj.podSecurityContext),
    'replicas': obj.replicas,
    'resources': toJson_TempoStackSpecTemplateIngesterResources(obj.resources),
    'tolerations': obj.tolerations?.map(y => toJson_TempoStackSpecTemplateIngesterTolerations(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Querier defines the querier component spec.
 *
 * @schema TempoStackSpecTemplateQuerier
 */
export interface TempoStackSpecTemplateQuerier {
  /**
   * NodeSelector defines the simple form of the node-selection constraint.
   *
   * @schema TempoStackSpecTemplateQuerier#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * PodSecurityContext defines security context will be applied to all pods of this component.
   *
   * @schema TempoStackSpecTemplateQuerier#podSecurityContext
   */
  readonly podSecurityContext?: TempoStackSpecTemplateQuerierPodSecurityContext;

  /**
   * Replicas defines the number of replicas to be created for this component.
   *
   * @schema TempoStackSpecTemplateQuerier#replicas
   */
  readonly replicas?: number;

  /**
   * Resources defines resources for this component, this will override the calculated resources derived from total
   *
   * @schema TempoStackSpecTemplateQuerier#resources
   */
  readonly resources?: TempoStackSpecTemplateQuerierResources;

  /**
   * Tolerations defines component-specific pod tolerations.
   *
   * @schema TempoStackSpecTemplateQuerier#tolerations
   */
  readonly tolerations?: TempoStackSpecTemplateQuerierTolerations[];

}

/**
 * Converts an object of type 'TempoStackSpecTemplateQuerier' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateQuerier(obj: TempoStackSpecTemplateQuerier | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'podSecurityContext': toJson_TempoStackSpecTemplateQuerierPodSecurityContext(obj.podSecurityContext),
    'replicas': obj.replicas,
    'resources': toJson_TempoStackSpecTemplateQuerierResources(obj.resources),
    'tolerations': obj.tolerations?.map(y => toJson_TempoStackSpecTemplateQuerierTolerations(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TempoQueryFrontendSpec defines the query frontend spec.
 *
 * @schema TempoStackSpecTemplateQueryFrontend
 */
export interface TempoStackSpecTemplateQueryFrontend {
  /**
   * TempoComponentSpec is embedded to extend this definition with further options.
   *
   * Currently there is no way to inline this field.
   * See: https://github.com/golang/go/issues/6213
   *
   * @schema TempoStackSpecTemplateQueryFrontend#component
   */
  readonly component?: TempoStackSpecTemplateQueryFrontendComponent;

  /**
   * JaegerQuery defines options specific to the Jaeger Query component.
   *
   * @schema TempoStackSpecTemplateQueryFrontend#jaegerQuery
   */
  readonly jaegerQuery?: TempoStackSpecTemplateQueryFrontendJaegerQuery;

}

/**
 * Converts an object of type 'TempoStackSpecTemplateQueryFrontend' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateQueryFrontend(obj: TempoStackSpecTemplateQueryFrontend | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'component': toJson_TempoStackSpecTemplateQueryFrontendComponent(obj.component),
    'jaegerQuery': toJson_TempoStackSpecTemplateQueryFrontendJaegerQuery(obj.jaegerQuery),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AuthenticationSpec defines the oidc configuration per tenant for tempo Gateway component.
 *
 * @schema TempoStackSpecTenantsAuthentication
 */
export interface TempoStackSpecTenantsAuthentication {
  /**
   * OIDC defines the spec for the OIDC tenant's authentication.
   *
   * @schema TempoStackSpecTenantsAuthentication#oidc
   */
  readonly oidc?: TempoStackSpecTenantsAuthenticationOidc;

  /**
   * TenantID defines a universally unique identifier of the tenant.
   * Unlike the tenantName, which must be unique at a given time, the tenantId must be unique over the entire lifetime of the Tempo deployment.
   * Tempo uses this ID to prefix objects in the object storage.
   *
   * @schema TempoStackSpecTenantsAuthentication#tenantId
   */
  readonly tenantId: string;

  /**
   * TenantName defines a human readable, unique name of the tenant.
   * The value of this field must be specified in the X-Scope-OrgID header and in the resources field of a ClusterRole to identify the tenant.
   *
   * @schema TempoStackSpecTenantsAuthentication#tenantName
   */
  readonly tenantName: string;

}

/**
 * Converts an object of type 'TempoStackSpecTenantsAuthentication' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTenantsAuthentication(obj: TempoStackSpecTenantsAuthentication | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'oidc': toJson_TempoStackSpecTenantsAuthenticationOidc(obj.oidc),
    'tenantId': obj.tenantId,
    'tenantName': obj.tenantName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Authorization defines the tempo-gateway component authorization configuration spec per tenant.
 *
 * @schema TempoStackSpecTenantsAuthorization
 */
export interface TempoStackSpecTenantsAuthorization {
  /**
   * RoleBindings defines configuration to bind a set of roles to a set of subjects.
   *
   * @schema TempoStackSpecTenantsAuthorization#roleBindings
   */
  readonly roleBindings?: TempoStackSpecTenantsAuthorizationRoleBindings[];

  /**
   * Roles defines a set of permissions to interact with a tenant.
   *
   * @schema TempoStackSpecTenantsAuthorization#roles
   */
  readonly roles?: TempoStackSpecTenantsAuthorizationRoles[];

}

/**
 * Converts an object of type 'TempoStackSpecTenantsAuthorization' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTenantsAuthorization(obj: TempoStackSpecTenantsAuthorization | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'roleBindings': obj.roleBindings?.map(y => toJson_TempoStackSpecTenantsAuthorizationRoleBindings(y)),
    'roles': obj.roles?.map(y => toJson_TempoStackSpecTenantsAuthorizationRoles(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Mode defines the multitenancy mode.
 *
 * @schema TempoStackSpecTenantsMode
 */
export enum TempoStackSpecTenantsMode {
  /** static */
  STATIC = "static",
  /** openshift */
  OPENSHIFT = "openshift",
}

/**
 * InstanceAddrType defines the type of address to use to advertise to the ring.
 * Defaults to the first address from any private network interfaces of the current pod.
 * Alternatively the public pod IP can be used in case private networks (RFC 1918 and RFC 6598)
 * are not available.
 *
 * @default the first address from any private network interfaces of the current pod.
 * @schema TempoStackSpecHashRingMemberlistInstanceAddrType
 */
export enum TempoStackSpecHashRingMemberlistInstanceAddrType {
  /** default */
  DEFAULT = "default",
  /** podIP */
  POD_IP = "podIP",
}

/**
 * Ingestion is used to define ingestion rate limits.
 *
 * @schema TempoStackSpecLimitsGlobalIngestion
 */
export interface TempoStackSpecLimitsGlobalIngestion {
  /**
   * IngestionBurstSizeBytes defines the burst size (bytes) used in ingestion.
   *
   * @schema TempoStackSpecLimitsGlobalIngestion#ingestionBurstSizeBytes
   */
  readonly ingestionBurstSizeBytes?: number;

  /**
   * IngestionRateLimitBytes defines the Per-user ingestion rate limit (bytes) used in ingestion.
   *
   * @schema TempoStackSpecLimitsGlobalIngestion#ingestionRateLimitBytes
   */
  readonly ingestionRateLimitBytes?: number;

  /**
   * MaxBytesPerTrace defines the maximum number of bytes of an acceptable trace.
   *
   * @schema TempoStackSpecLimitsGlobalIngestion#maxBytesPerTrace
   */
  readonly maxBytesPerTrace?: number;

  /**
   * MaxTracesPerUser defines the maximum number of traces a user can send.
   *
   * @schema TempoStackSpecLimitsGlobalIngestion#maxTracesPerUser
   */
  readonly maxTracesPerUser?: number;

}

/**
 * Converts an object of type 'TempoStackSpecLimitsGlobalIngestion' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecLimitsGlobalIngestion(obj: TempoStackSpecLimitsGlobalIngestion | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ingestionBurstSizeBytes': obj.ingestionBurstSizeBytes,
    'ingestionRateLimitBytes': obj.ingestionRateLimitBytes,
    'maxBytesPerTrace': obj.maxBytesPerTrace,
    'maxTracesPerUser': obj.maxTracesPerUser,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Query is used to define query rate limits.
 *
 * @schema TempoStackSpecLimitsGlobalQuery
 */
export interface TempoStackSpecLimitsGlobalQuery {
  /**
   * MaxBytesPerTagValues defines the maximum size in bytes of a tag-values query.
   *
   * @schema TempoStackSpecLimitsGlobalQuery#maxBytesPerTagValues
   */
  readonly maxBytesPerTagValues?: number;

  /**
   * DEPRECATED. MaxSearchBytesPerTrace defines the maximum size of search data for a single
   * trace in bytes.
   * default: `0` to disable.
   *
   * @schema TempoStackSpecLimitsGlobalQuery#maxSearchBytesPerTrace
   */
  readonly maxSearchBytesPerTrace?: number;

  /**
   * MaxSearchDuration defines the maximum allowed time range for a search.
   * If this value is not set, then spec.search.maxDuration is used.
   *
   * @schema TempoStackSpecLimitsGlobalQuery#maxSearchDuration
   */
  readonly maxSearchDuration?: string;

}

/**
 * Converts an object of type 'TempoStackSpecLimitsGlobalQuery' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecLimitsGlobalQuery(obj: TempoStackSpecLimitsGlobalQuery | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxBytesPerTagValues': obj.maxBytesPerTagValues,
    'maxSearchBytesPerTrace': obj.maxSearchBytesPerTrace,
    'maxSearchDuration': obj.maxSearchDuration,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Ingestion is used to define ingestion rate limits.
 *
 * @schema TempoStackSpecLimitsPerTenantIngestion
 */
export interface TempoStackSpecLimitsPerTenantIngestion {
  /**
   * IngestionBurstSizeBytes defines the burst size (bytes) used in ingestion.
   *
   * @schema TempoStackSpecLimitsPerTenantIngestion#ingestionBurstSizeBytes
   */
  readonly ingestionBurstSizeBytes?: number;

  /**
   * IngestionRateLimitBytes defines the Per-user ingestion rate limit (bytes) used in ingestion.
   *
   * @schema TempoStackSpecLimitsPerTenantIngestion#ingestionRateLimitBytes
   */
  readonly ingestionRateLimitBytes?: number;

  /**
   * MaxBytesPerTrace defines the maximum number of bytes of an acceptable trace.
   *
   * @schema TempoStackSpecLimitsPerTenantIngestion#maxBytesPerTrace
   */
  readonly maxBytesPerTrace?: number;

  /**
   * MaxTracesPerUser defines the maximum number of traces a user can send.
   *
   * @schema TempoStackSpecLimitsPerTenantIngestion#maxTracesPerUser
   */
  readonly maxTracesPerUser?: number;

}

/**
 * Converts an object of type 'TempoStackSpecLimitsPerTenantIngestion' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecLimitsPerTenantIngestion(obj: TempoStackSpecLimitsPerTenantIngestion | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ingestionBurstSizeBytes': obj.ingestionBurstSizeBytes,
    'ingestionRateLimitBytes': obj.ingestionRateLimitBytes,
    'maxBytesPerTrace': obj.maxBytesPerTrace,
    'maxTracesPerUser': obj.maxTracesPerUser,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Query is used to define query rate limits.
 *
 * @schema TempoStackSpecLimitsPerTenantQuery
 */
export interface TempoStackSpecLimitsPerTenantQuery {
  /**
   * MaxBytesPerTagValues defines the maximum size in bytes of a tag-values query.
   *
   * @schema TempoStackSpecLimitsPerTenantQuery#maxBytesPerTagValues
   */
  readonly maxBytesPerTagValues?: number;

  /**
   * DEPRECATED. MaxSearchBytesPerTrace defines the maximum size of search data for a single
   * trace in bytes.
   * default: `0` to disable.
   *
   * @schema TempoStackSpecLimitsPerTenantQuery#maxSearchBytesPerTrace
   */
  readonly maxSearchBytesPerTrace?: number;

  /**
   * MaxSearchDuration defines the maximum allowed time range for a search.
   * If this value is not set, then spec.search.maxDuration is used.
   *
   * @schema TempoStackSpecLimitsPerTenantQuery#maxSearchDuration
   */
  readonly maxSearchDuration?: string;

}

/**
 * Converts an object of type 'TempoStackSpecLimitsPerTenantQuery' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecLimitsPerTenantQuery(obj: TempoStackSpecLimitsPerTenantQuery | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxBytesPerTagValues': obj.maxBytesPerTagValues,
    'maxSearchBytesPerTrace': obj.maxSearchBytesPerTrace,
    'maxSearchDuration': obj.maxSearchDuration,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * InstanceSelector specifies the Grafana instance where the datasource should be created.
 *
 * @schema TempoStackSpecObservabilityGrafanaInstanceSelector
 */
export interface TempoStackSpecObservabilityGrafanaInstanceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema TempoStackSpecObservabilityGrafanaInstanceSelector#matchExpressions
   */
  readonly matchExpressions?: TempoStackSpecObservabilityGrafanaInstanceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema TempoStackSpecObservabilityGrafanaInstanceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'TempoStackSpecObservabilityGrafanaInstanceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecObservabilityGrafanaInstanceSelector(obj: TempoStackSpecObservabilityGrafanaInstanceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_TempoStackSpecObservabilityGrafanaInstanceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema TempoStackSpecResourcesTotalClaims
 */
export interface TempoStackSpecResourcesTotalClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema TempoStackSpecResourcesTotalClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema TempoStackSpecResourcesTotalClaims#request
   */
  readonly request?: string;

}

/**
 * Converts an object of type 'TempoStackSpecResourcesTotalClaims' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecResourcesTotalClaims(obj: TempoStackSpecResourcesTotalClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'request': obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TempoStackSpecResourcesTotalLimits
 */
export class TempoStackSpecResourcesTotalLimits {
  public static fromNumber(value: number): TempoStackSpecResourcesTotalLimits {
    return new TempoStackSpecResourcesTotalLimits(value);
  }
  public static fromString(value: string): TempoStackSpecResourcesTotalLimits {
    return new TempoStackSpecResourcesTotalLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema TempoStackSpecResourcesTotalRequests
 */
export class TempoStackSpecResourcesTotalRequests {
  public static fromNumber(value: number): TempoStackSpecResourcesTotalRequests {
    return new TempoStackSpecResourcesTotalRequests(value);
  }
  public static fromString(value: string): TempoStackSpecResourcesTotalRequests {
    return new TempoStackSpecResourcesTotalRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * CredentialMode can be used to set the desired credential mode for authenticating with the object storage.
 * If this is not set, then the operator tries to infer the credential mode from the provided secret and its
 * own configuration.
 *
 * @schema TempoStackSpecStorageSecretCredentialMode
 */
export enum TempoStackSpecStorageSecretCredentialMode {
  /** static */
  STATIC = "static",
  /** token */
  TOKEN = "token",
  /** token-cco */
  TOKEN_HYPHEN_CCO = "token-cco",
}

/**
 * Type of object storage that should be used
 *
 * @schema TempoStackSpecStorageSecretType
 */
export enum TempoStackSpecStorageSecretType {
  /** azure */
  AZURE = "azure",
  /** gcs */
  GCS = "gcs",
  /** s3 */
  S3 = "s3",
}

/**
 * PodSecurityContext defines security context will be applied to all pods of this component.
 *
 * @schema TempoStackSpecTemplateCompactorPodSecurityContext
 */
export interface TempoStackSpecTemplateCompactorPodSecurityContext {
  /**
   * appArmorProfile is the AppArmor options to use by the containers in this pod.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema TempoStackSpecTemplateCompactorPodSecurityContext#appArmorProfile
   */
  readonly appArmorProfile?: TempoStackSpecTemplateCompactorPodSecurityContextAppArmorProfile;

  /**
   * A special supplemental group that applies to all containers in a pod.
   * Some volume types allow the Kubelet to change the ownership of that volume
   * to be owned by the pod:
   *
   * 1. The owning GID will be the FSGroup
   * 2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
   * 3. The permission bits are OR'd with rw-rw----
   *
   * If unset, the Kubelet will not modify the ownership and permissions of any volume.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema TempoStackSpecTemplateCompactorPodSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * fsGroupChangePolicy defines behavior of changing ownership and permission of the volume
   * before being exposed inside Pod. This field will only apply to
   * volume types which support fsGroup based ownership(and permissions).
   * It will have no effect on ephemeral volume types such as: secret, configmaps
   * and emptydir.
   * Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema TempoStackSpecTemplateCompactorPodSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * The GID to run the entrypoint of the container process.
   * Uses runtime default if unset.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence
   * for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema TempoStackSpecTemplateCompactorPodSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user.
   * If true, the Kubelet will validate the image at runtime to ensure that it
   * does not run as UID 0 (root) and fail to start the container if it does.
   * If unset or false, no such validation will be performed.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema TempoStackSpecTemplateCompactorPodSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process.
   * Defaults to user specified in image metadata if unspecified.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence
   * for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified.
   * @schema TempoStackSpecTemplateCompactorPodSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * seLinuxChangePolicy defines how the container's SELinux label is applied to all volumes used by the Pod.
   * It has no effect on nodes that do not support SELinux or to volumes does not support SELinux.
   * Valid values are "MountOption" and "Recursive".
   *
   * "Recursive" means relabeling of all files on all Pod volumes by the container runtime.
   * This may be slow for large volumes, but allows mixing privileged and unprivileged Pods sharing the same volume on the same node.
   *
   * "MountOption" mounts all eligible Pod volumes with `-o context` mount option.
   * This requires all Pods that share the same volume to use the same SELinux label.
   * It is not possible to share the same volume among privileged and unprivileged Pods.
   * Eligible volumes are in-tree FibreChannel and iSCSI volumes, and all CSI volumes
   * whose CSI driver announces SELinux support by setting spec.seLinuxMount: true in their
   * CSIDriver instance. Other volumes are always re-labelled recursively.
   * "MountOption" value is allowed only when SELinuxMount feature gate is enabled.
   *
   * If not specified and SELinuxMount feature gate is enabled, "MountOption" is used.
   * If not specified and SELinuxMount feature gate is disabled, "MountOption" is used for ReadWriteOncePod volumes
   * and "Recursive" for all other volumes.
   *
   * This field affects only Pods that have SELinux label set, either in PodSecurityContext or in SecurityContext of all containers.
   *
   * All Pods that use the same volume should use the same seLinuxChangePolicy, otherwise some pods can get stuck in ContainerCreating state.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema TempoStackSpecTemplateCompactorPodSecurityContext#seLinuxChangePolicy
   */
  readonly seLinuxChangePolicy?: string;

  /**
   * The SELinux context to be applied to all containers.
   * If unspecified, the container runtime will allocate a random SELinux context for each
   * container.  May also be set in SecurityContext.  If set in
   * both SecurityContext and PodSecurityContext, the value specified in SecurityContext
   * takes precedence for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema TempoStackSpecTemplateCompactorPodSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: TempoStackSpecTemplateCompactorPodSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by the containers in this pod.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema TempoStackSpecTemplateCompactorPodSecurityContext#seccompProfile
   */
  readonly seccompProfile?: TempoStackSpecTemplateCompactorPodSecurityContextSeccompProfile;

  /**
   * A list of groups applied to the first process run in each container, in
   * addition to the container's primary GID and fsGroup (if specified).  If
   * the SupplementalGroupsPolicy feature is enabled, the
   * supplementalGroupsPolicy field determines whether these are in addition
   * to or instead of any group memberships defined in the container image.
   * If unspecified, no additional groups are added, though group memberships
   * defined in the container image may still be used, depending on the
   * supplementalGroupsPolicy field.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema TempoStackSpecTemplateCompactorPodSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * Defines how supplemental groups of the first container processes are calculated.
   * Valid values are "Merge" and "Strict". If not specified, "Merge" is used.
   * (Alpha) Using the field requires the SupplementalGroupsPolicy feature gate to be enabled
   * and the container runtime must implement support for this feature.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema TempoStackSpecTemplateCompactorPodSecurityContext#supplementalGroupsPolicy
   */
  readonly supplementalGroupsPolicy?: string;

  /**
   * Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported
   * sysctls (by the container runtime) might fail to launch.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema TempoStackSpecTemplateCompactorPodSecurityContext#sysctls
   */
  readonly sysctls?: TempoStackSpecTemplateCompactorPodSecurityContextSysctls[];

  /**
   * The Windows specific settings applied to all containers.
   * If unspecified, the options within a container's SecurityContext will be used.
   * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema TempoStackSpecTemplateCompactorPodSecurityContext#windowsOptions
   */
  readonly windowsOptions?: TempoStackSpecTemplateCompactorPodSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'TempoStackSpecTemplateCompactorPodSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateCompactorPodSecurityContext(obj: TempoStackSpecTemplateCompactorPodSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'appArmorProfile': toJson_TempoStackSpecTemplateCompactorPodSecurityContextAppArmorProfile(obj.appArmorProfile),
    'fsGroup': obj.fsGroup,
    'fsGroupChangePolicy': obj.fsGroupChangePolicy,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxChangePolicy': obj.seLinuxChangePolicy,
    'seLinuxOptions': toJson_TempoStackSpecTemplateCompactorPodSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_TempoStackSpecTemplateCompactorPodSecurityContextSeccompProfile(obj.seccompProfile),
    'supplementalGroups': obj.supplementalGroups?.map(y => y),
    'supplementalGroupsPolicy': obj.supplementalGroupsPolicy,
    'sysctls': obj.sysctls?.map(y => toJson_TempoStackSpecTemplateCompactorPodSecurityContextSysctls(y)),
    'windowsOptions': toJson_TempoStackSpecTemplateCompactorPodSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resources defines resources for this component, this will override the calculated resources derived from total
 *
 * @schema TempoStackSpecTemplateCompactorResources
 */
export interface TempoStackSpecTemplateCompactorResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema TempoStackSpecTemplateCompactorResources#claims
   */
  readonly claims?: TempoStackSpecTemplateCompactorResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema TempoStackSpecTemplateCompactorResources#limits
   */
  readonly limits?: { [key: string]: TempoStackSpecTemplateCompactorResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema TempoStackSpecTemplateCompactorResources#requests
   */
  readonly requests?: { [key: string]: TempoStackSpecTemplateCompactorResourcesRequests };

}

/**
 * Converts an object of type 'TempoStackSpecTemplateCompactorResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateCompactorResources(obj: TempoStackSpecTemplateCompactorResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claims': obj.claims?.map(y => toJson_TempoStackSpecTemplateCompactorResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema TempoStackSpecTemplateCompactorTolerations
 */
export interface TempoStackSpecTemplateCompactorTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema TempoStackSpecTemplateCompactorTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema TempoStackSpecTemplateCompactorTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema TempoStackSpecTemplateCompactorTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict). Zero and
   * negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema TempoStackSpecTemplateCompactorTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema TempoStackSpecTemplateCompactorTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'TempoStackSpecTemplateCompactorTolerations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateCompactorTolerations(obj: TempoStackSpecTemplateCompactorTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TempoComponentSpec is embedded to extend this definition with further options.
 *
 * Currently, there is no way to inline this field.
 * See: https://github.com/golang/go/issues/6213
 *
 * @schema TempoStackSpecTemplateDistributorComponent
 */
export interface TempoStackSpecTemplateDistributorComponent {
  /**
   * NodeSelector defines the simple form of the node-selection constraint.
   *
   * @schema TempoStackSpecTemplateDistributorComponent#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * PodSecurityContext defines security context will be applied to all pods of this component.
   *
   * @schema TempoStackSpecTemplateDistributorComponent#podSecurityContext
   */
  readonly podSecurityContext?: TempoStackSpecTemplateDistributorComponentPodSecurityContext;

  /**
   * Replicas defines the number of replicas to be created for this component.
   *
   * @schema TempoStackSpecTemplateDistributorComponent#replicas
   */
  readonly replicas?: number;

  /**
   * Resources defines resources for this component, this will override the calculated resources derived from total
   *
   * @schema TempoStackSpecTemplateDistributorComponent#resources
   */
  readonly resources?: TempoStackSpecTemplateDistributorComponentResources;

  /**
   * Tolerations defines component-specific pod tolerations.
   *
   * @schema TempoStackSpecTemplateDistributorComponent#tolerations
   */
  readonly tolerations?: TempoStackSpecTemplateDistributorComponentTolerations[];

}

/**
 * Converts an object of type 'TempoStackSpecTemplateDistributorComponent' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateDistributorComponent(obj: TempoStackSpecTemplateDistributorComponent | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'podSecurityContext': toJson_TempoStackSpecTemplateDistributorComponentPodSecurityContext(obj.podSecurityContext),
    'replicas': obj.replicas,
    'resources': toJson_TempoStackSpecTemplateDistributorComponentResources(obj.resources),
    'tolerations': obj.tolerations?.map(y => toJson_TempoStackSpecTemplateDistributorComponentTolerations(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLS defines TLS configuration for distributor receivers
 *
 * If openshift feature flag `servingCertsService` is enabled and TLS is enabled but no
 * certName or caName is specified, OpenShift service serving certificates will  be used.
 *
 * @schema TempoStackSpecTemplateDistributorTls
 */
export interface TempoStackSpecTemplateDistributorTls {
  /**
   * CA is the name of a ConfigMap containing a CA certificate (service-ca.crt).
   * It needs to be in the same namespace as the Tempo custom resource.
   *
   * @schema TempoStackSpecTemplateDistributorTls#caName
   */
  readonly caName?: string;

  /**
   * Cert is the name of a Secret containing a certificate (tls.crt) and private key (tls.key).
   * It needs to be in the same namespace as the Tempo custom resource.
   *
   * @schema TempoStackSpecTemplateDistributorTls#certName
   */
  readonly certName?: string;

  /**
   * Enabled defines if TLS is enabled.
   *
   * @schema TempoStackSpecTemplateDistributorTls#enabled
   */
  readonly enabled?: boolean;

  /**
   * MinVersion defines the minimum acceptable TLS version.
   *
   * @schema TempoStackSpecTemplateDistributorTls#minVersion
   */
  readonly minVersion?: string;

}

/**
 * Converts an object of type 'TempoStackSpecTemplateDistributorTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateDistributorTls(obj: TempoStackSpecTemplateDistributorTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caName': obj.caName,
    'certName': obj.certName,
    'enabled': obj.enabled,
    'minVersion': obj.minVersion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TempoComponentSpec is embedded to extend this definition with further options.
 *
 * Currently there is no way to inline this field.
 * See: https://github.com/golang/go/issues/6213
 *
 * @schema TempoStackSpecTemplateGatewayComponent
 */
export interface TempoStackSpecTemplateGatewayComponent {
  /**
   * NodeSelector defines the simple form of the node-selection constraint.
   *
   * @schema TempoStackSpecTemplateGatewayComponent#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * PodSecurityContext defines security context will be applied to all pods of this component.
   *
   * @schema TempoStackSpecTemplateGatewayComponent#podSecurityContext
   */
  readonly podSecurityContext?: TempoStackSpecTemplateGatewayComponentPodSecurityContext;

  /**
   * Replicas defines the number of replicas to be created for this component.
   *
   * @schema TempoStackSpecTemplateGatewayComponent#replicas
   */
  readonly replicas?: number;

  /**
   * Resources defines resources for this component, this will override the calculated resources derived from total
   *
   * @schema TempoStackSpecTemplateGatewayComponent#resources
   */
  readonly resources?: TempoStackSpecTemplateGatewayComponentResources;

  /**
   * Tolerations defines component-specific pod tolerations.
   *
   * @schema TempoStackSpecTemplateGatewayComponent#tolerations
   */
  readonly tolerations?: TempoStackSpecTemplateGatewayComponentTolerations[];

}

/**
 * Converts an object of type 'TempoStackSpecTemplateGatewayComponent' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateGatewayComponent(obj: TempoStackSpecTemplateGatewayComponent | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'podSecurityContext': toJson_TempoStackSpecTemplateGatewayComponentPodSecurityContext(obj.podSecurityContext),
    'replicas': obj.replicas,
    'resources': toJson_TempoStackSpecTemplateGatewayComponentResources(obj.resources),
    'tolerations': obj.tolerations?.map(y => toJson_TempoStackSpecTemplateGatewayComponentTolerations(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Ingress defines gateway Ingress options.
 *
 * @schema TempoStackSpecTemplateGatewayIngress
 */
export interface TempoStackSpecTemplateGatewayIngress {
  /**
   * Annotations defines the annotations of the Ingress object.
   *
   * @schema TempoStackSpecTemplateGatewayIngress#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Host defines the hostname of the Ingress object.
   *
   * @schema TempoStackSpecTemplateGatewayIngress#host
   */
  readonly host?: string;

  /**
   * IngressClassName defines the name of an IngressClass cluster resource.
   * Defines which ingress controller serves this ingress resource.
   *
   * @schema TempoStackSpecTemplateGatewayIngress#ingressClassName
   */
  readonly ingressClassName?: string;

  /**
   * Route defines the options for the OpenShift route.
   *
   * @schema TempoStackSpecTemplateGatewayIngress#route
   */
  readonly route?: TempoStackSpecTemplateGatewayIngressRoute;

  /**
   * Type defines the type of Ingress for the Jaeger Query UI.
   * Currently ingress, route and none are supported.
   *
   * @schema TempoStackSpecTemplateGatewayIngress#type
   */
  readonly type?: TempoStackSpecTemplateGatewayIngressType;

}

/**
 * Converts an object of type 'TempoStackSpecTemplateGatewayIngress' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateGatewayIngress(obj: TempoStackSpecTemplateGatewayIngress | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'host': obj.host,
    'ingressClassName': obj.ingressClassName,
    'route': toJson_TempoStackSpecTemplateGatewayIngressRoute(obj.route),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RBAC defines query RBAC options.
 *
 * @schema TempoStackSpecTemplateGatewayRbac
 */
export interface TempoStackSpecTemplateGatewayRbac {
  /**
   * Enabled defines if the query RBAC should be enabled.
   *
   * @schema TempoStackSpecTemplateGatewayRbac#enabled
   */
  readonly enabled?: boolean;

}

/**
 * Converts an object of type 'TempoStackSpecTemplateGatewayRbac' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateGatewayRbac(obj: TempoStackSpecTemplateGatewayRbac | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PodSecurityContext defines security context will be applied to all pods of this component.
 *
 * @schema TempoStackSpecTemplateIngesterPodSecurityContext
 */
export interface TempoStackSpecTemplateIngesterPodSecurityContext {
  /**
   * appArmorProfile is the AppArmor options to use by the containers in this pod.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema TempoStackSpecTemplateIngesterPodSecurityContext#appArmorProfile
   */
  readonly appArmorProfile?: TempoStackSpecTemplateIngesterPodSecurityContextAppArmorProfile;

  /**
   * A special supplemental group that applies to all containers in a pod.
   * Some volume types allow the Kubelet to change the ownership of that volume
   * to be owned by the pod:
   *
   * 1. The owning GID will be the FSGroup
   * 2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
   * 3. The permission bits are OR'd with rw-rw----
   *
   * If unset, the Kubelet will not modify the ownership and permissions of any volume.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema TempoStackSpecTemplateIngesterPodSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * fsGroupChangePolicy defines behavior of changing ownership and permission of the volume
   * before being exposed inside Pod. This field will only apply to
   * volume types which support fsGroup based ownership(and permissions).
   * It will have no effect on ephemeral volume types such as: secret, configmaps
   * and emptydir.
   * Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema TempoStackSpecTemplateIngesterPodSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * The GID to run the entrypoint of the container process.
   * Uses runtime default if unset.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence
   * for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema TempoStackSpecTemplateIngesterPodSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user.
   * If true, the Kubelet will validate the image at runtime to ensure that it
   * does not run as UID 0 (root) and fail to start the container if it does.
   * If unset or false, no such validation will be performed.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema TempoStackSpecTemplateIngesterPodSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process.
   * Defaults to user specified in image metadata if unspecified.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence
   * for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified.
   * @schema TempoStackSpecTemplateIngesterPodSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * seLinuxChangePolicy defines how the container's SELinux label is applied to all volumes used by the Pod.
   * It has no effect on nodes that do not support SELinux or to volumes does not support SELinux.
   * Valid values are "MountOption" and "Recursive".
   *
   * "Recursive" means relabeling of all files on all Pod volumes by the container runtime.
   * This may be slow for large volumes, but allows mixing privileged and unprivileged Pods sharing the same volume on the same node.
   *
   * "MountOption" mounts all eligible Pod volumes with `-o context` mount option.
   * This requires all Pods that share the same volume to use the same SELinux label.
   * It is not possible to share the same volume among privileged and unprivileged Pods.
   * Eligible volumes are in-tree FibreChannel and iSCSI volumes, and all CSI volumes
   * whose CSI driver announces SELinux support by setting spec.seLinuxMount: true in their
   * CSIDriver instance. Other volumes are always re-labelled recursively.
   * "MountOption" value is allowed only when SELinuxMount feature gate is enabled.
   *
   * If not specified and SELinuxMount feature gate is enabled, "MountOption" is used.
   * If not specified and SELinuxMount feature gate is disabled, "MountOption" is used for ReadWriteOncePod volumes
   * and "Recursive" for all other volumes.
   *
   * This field affects only Pods that have SELinux label set, either in PodSecurityContext or in SecurityContext of all containers.
   *
   * All Pods that use the same volume should use the same seLinuxChangePolicy, otherwise some pods can get stuck in ContainerCreating state.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema TempoStackSpecTemplateIngesterPodSecurityContext#seLinuxChangePolicy
   */
  readonly seLinuxChangePolicy?: string;

  /**
   * The SELinux context to be applied to all containers.
   * If unspecified, the container runtime will allocate a random SELinux context for each
   * container.  May also be set in SecurityContext.  If set in
   * both SecurityContext and PodSecurityContext, the value specified in SecurityContext
   * takes precedence for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema TempoStackSpecTemplateIngesterPodSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: TempoStackSpecTemplateIngesterPodSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by the containers in this pod.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema TempoStackSpecTemplateIngesterPodSecurityContext#seccompProfile
   */
  readonly seccompProfile?: TempoStackSpecTemplateIngesterPodSecurityContextSeccompProfile;

  /**
   * A list of groups applied to the first process run in each container, in
   * addition to the container's primary GID and fsGroup (if specified).  If
   * the SupplementalGroupsPolicy feature is enabled, the
   * supplementalGroupsPolicy field determines whether these are in addition
   * to or instead of any group memberships defined in the container image.
   * If unspecified, no additional groups are added, though group memberships
   * defined in the container image may still be used, depending on the
   * supplementalGroupsPolicy field.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema TempoStackSpecTemplateIngesterPodSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * Defines how supplemental groups of the first container processes are calculated.
   * Valid values are "Merge" and "Strict". If not specified, "Merge" is used.
   * (Alpha) Using the field requires the SupplementalGroupsPolicy feature gate to be enabled
   * and the container runtime must implement support for this feature.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema TempoStackSpecTemplateIngesterPodSecurityContext#supplementalGroupsPolicy
   */
  readonly supplementalGroupsPolicy?: string;

  /**
   * Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported
   * sysctls (by the container runtime) might fail to launch.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema TempoStackSpecTemplateIngesterPodSecurityContext#sysctls
   */
  readonly sysctls?: TempoStackSpecTemplateIngesterPodSecurityContextSysctls[];

  /**
   * The Windows specific settings applied to all containers.
   * If unspecified, the options within a container's SecurityContext will be used.
   * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema TempoStackSpecTemplateIngesterPodSecurityContext#windowsOptions
   */
  readonly windowsOptions?: TempoStackSpecTemplateIngesterPodSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'TempoStackSpecTemplateIngesterPodSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateIngesterPodSecurityContext(obj: TempoStackSpecTemplateIngesterPodSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'appArmorProfile': toJson_TempoStackSpecTemplateIngesterPodSecurityContextAppArmorProfile(obj.appArmorProfile),
    'fsGroup': obj.fsGroup,
    'fsGroupChangePolicy': obj.fsGroupChangePolicy,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxChangePolicy': obj.seLinuxChangePolicy,
    'seLinuxOptions': toJson_TempoStackSpecTemplateIngesterPodSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_TempoStackSpecTemplateIngesterPodSecurityContextSeccompProfile(obj.seccompProfile),
    'supplementalGroups': obj.supplementalGroups?.map(y => y),
    'supplementalGroupsPolicy': obj.supplementalGroupsPolicy,
    'sysctls': obj.sysctls?.map(y => toJson_TempoStackSpecTemplateIngesterPodSecurityContextSysctls(y)),
    'windowsOptions': toJson_TempoStackSpecTemplateIngesterPodSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resources defines resources for this component, this will override the calculated resources derived from total
 *
 * @schema TempoStackSpecTemplateIngesterResources
 */
export interface TempoStackSpecTemplateIngesterResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema TempoStackSpecTemplateIngesterResources#claims
   */
  readonly claims?: TempoStackSpecTemplateIngesterResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema TempoStackSpecTemplateIngesterResources#limits
   */
  readonly limits?: { [key: string]: TempoStackSpecTemplateIngesterResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema TempoStackSpecTemplateIngesterResources#requests
   */
  readonly requests?: { [key: string]: TempoStackSpecTemplateIngesterResourcesRequests };

}

/**
 * Converts an object of type 'TempoStackSpecTemplateIngesterResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateIngesterResources(obj: TempoStackSpecTemplateIngesterResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claims': obj.claims?.map(y => toJson_TempoStackSpecTemplateIngesterResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema TempoStackSpecTemplateIngesterTolerations
 */
export interface TempoStackSpecTemplateIngesterTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema TempoStackSpecTemplateIngesterTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema TempoStackSpecTemplateIngesterTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema TempoStackSpecTemplateIngesterTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict). Zero and
   * negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema TempoStackSpecTemplateIngesterTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema TempoStackSpecTemplateIngesterTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'TempoStackSpecTemplateIngesterTolerations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateIngesterTolerations(obj: TempoStackSpecTemplateIngesterTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PodSecurityContext defines security context will be applied to all pods of this component.
 *
 * @schema TempoStackSpecTemplateQuerierPodSecurityContext
 */
export interface TempoStackSpecTemplateQuerierPodSecurityContext {
  /**
   * appArmorProfile is the AppArmor options to use by the containers in this pod.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema TempoStackSpecTemplateQuerierPodSecurityContext#appArmorProfile
   */
  readonly appArmorProfile?: TempoStackSpecTemplateQuerierPodSecurityContextAppArmorProfile;

  /**
   * A special supplemental group that applies to all containers in a pod.
   * Some volume types allow the Kubelet to change the ownership of that volume
   * to be owned by the pod:
   *
   * 1. The owning GID will be the FSGroup
   * 2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
   * 3. The permission bits are OR'd with rw-rw----
   *
   * If unset, the Kubelet will not modify the ownership and permissions of any volume.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema TempoStackSpecTemplateQuerierPodSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * fsGroupChangePolicy defines behavior of changing ownership and permission of the volume
   * before being exposed inside Pod. This field will only apply to
   * volume types which support fsGroup based ownership(and permissions).
   * It will have no effect on ephemeral volume types such as: secret, configmaps
   * and emptydir.
   * Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema TempoStackSpecTemplateQuerierPodSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * The GID to run the entrypoint of the container process.
   * Uses runtime default if unset.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence
   * for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema TempoStackSpecTemplateQuerierPodSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user.
   * If true, the Kubelet will validate the image at runtime to ensure that it
   * does not run as UID 0 (root) and fail to start the container if it does.
   * If unset or false, no such validation will be performed.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema TempoStackSpecTemplateQuerierPodSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process.
   * Defaults to user specified in image metadata if unspecified.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence
   * for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified.
   * @schema TempoStackSpecTemplateQuerierPodSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * seLinuxChangePolicy defines how the container's SELinux label is applied to all volumes used by the Pod.
   * It has no effect on nodes that do not support SELinux or to volumes does not support SELinux.
   * Valid values are "MountOption" and "Recursive".
   *
   * "Recursive" means relabeling of all files on all Pod volumes by the container runtime.
   * This may be slow for large volumes, but allows mixing privileged and unprivileged Pods sharing the same volume on the same node.
   *
   * "MountOption" mounts all eligible Pod volumes with `-o context` mount option.
   * This requires all Pods that share the same volume to use the same SELinux label.
   * It is not possible to share the same volume among privileged and unprivileged Pods.
   * Eligible volumes are in-tree FibreChannel and iSCSI volumes, and all CSI volumes
   * whose CSI driver announces SELinux support by setting spec.seLinuxMount: true in their
   * CSIDriver instance. Other volumes are always re-labelled recursively.
   * "MountOption" value is allowed only when SELinuxMount feature gate is enabled.
   *
   * If not specified and SELinuxMount feature gate is enabled, "MountOption" is used.
   * If not specified and SELinuxMount feature gate is disabled, "MountOption" is used for ReadWriteOncePod volumes
   * and "Recursive" for all other volumes.
   *
   * This field affects only Pods that have SELinux label set, either in PodSecurityContext or in SecurityContext of all containers.
   *
   * All Pods that use the same volume should use the same seLinuxChangePolicy, otherwise some pods can get stuck in ContainerCreating state.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema TempoStackSpecTemplateQuerierPodSecurityContext#seLinuxChangePolicy
   */
  readonly seLinuxChangePolicy?: string;

  /**
   * The SELinux context to be applied to all containers.
   * If unspecified, the container runtime will allocate a random SELinux context for each
   * container.  May also be set in SecurityContext.  If set in
   * both SecurityContext and PodSecurityContext, the value specified in SecurityContext
   * takes precedence for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema TempoStackSpecTemplateQuerierPodSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: TempoStackSpecTemplateQuerierPodSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by the containers in this pod.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema TempoStackSpecTemplateQuerierPodSecurityContext#seccompProfile
   */
  readonly seccompProfile?: TempoStackSpecTemplateQuerierPodSecurityContextSeccompProfile;

  /**
   * A list of groups applied to the first process run in each container, in
   * addition to the container's primary GID and fsGroup (if specified).  If
   * the SupplementalGroupsPolicy feature is enabled, the
   * supplementalGroupsPolicy field determines whether these are in addition
   * to or instead of any group memberships defined in the container image.
   * If unspecified, no additional groups are added, though group memberships
   * defined in the container image may still be used, depending on the
   * supplementalGroupsPolicy field.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema TempoStackSpecTemplateQuerierPodSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * Defines how supplemental groups of the first container processes are calculated.
   * Valid values are "Merge" and "Strict". If not specified, "Merge" is used.
   * (Alpha) Using the field requires the SupplementalGroupsPolicy feature gate to be enabled
   * and the container runtime must implement support for this feature.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema TempoStackSpecTemplateQuerierPodSecurityContext#supplementalGroupsPolicy
   */
  readonly supplementalGroupsPolicy?: string;

  /**
   * Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported
   * sysctls (by the container runtime) might fail to launch.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema TempoStackSpecTemplateQuerierPodSecurityContext#sysctls
   */
  readonly sysctls?: TempoStackSpecTemplateQuerierPodSecurityContextSysctls[];

  /**
   * The Windows specific settings applied to all containers.
   * If unspecified, the options within a container's SecurityContext will be used.
   * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema TempoStackSpecTemplateQuerierPodSecurityContext#windowsOptions
   */
  readonly windowsOptions?: TempoStackSpecTemplateQuerierPodSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'TempoStackSpecTemplateQuerierPodSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateQuerierPodSecurityContext(obj: TempoStackSpecTemplateQuerierPodSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'appArmorProfile': toJson_TempoStackSpecTemplateQuerierPodSecurityContextAppArmorProfile(obj.appArmorProfile),
    'fsGroup': obj.fsGroup,
    'fsGroupChangePolicy': obj.fsGroupChangePolicy,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxChangePolicy': obj.seLinuxChangePolicy,
    'seLinuxOptions': toJson_TempoStackSpecTemplateQuerierPodSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_TempoStackSpecTemplateQuerierPodSecurityContextSeccompProfile(obj.seccompProfile),
    'supplementalGroups': obj.supplementalGroups?.map(y => y),
    'supplementalGroupsPolicy': obj.supplementalGroupsPolicy,
    'sysctls': obj.sysctls?.map(y => toJson_TempoStackSpecTemplateQuerierPodSecurityContextSysctls(y)),
    'windowsOptions': toJson_TempoStackSpecTemplateQuerierPodSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resources defines resources for this component, this will override the calculated resources derived from total
 *
 * @schema TempoStackSpecTemplateQuerierResources
 */
export interface TempoStackSpecTemplateQuerierResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema TempoStackSpecTemplateQuerierResources#claims
   */
  readonly claims?: TempoStackSpecTemplateQuerierResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema TempoStackSpecTemplateQuerierResources#limits
   */
  readonly limits?: { [key: string]: TempoStackSpecTemplateQuerierResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema TempoStackSpecTemplateQuerierResources#requests
   */
  readonly requests?: { [key: string]: TempoStackSpecTemplateQuerierResourcesRequests };

}

/**
 * Converts an object of type 'TempoStackSpecTemplateQuerierResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateQuerierResources(obj: TempoStackSpecTemplateQuerierResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claims': obj.claims?.map(y => toJson_TempoStackSpecTemplateQuerierResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema TempoStackSpecTemplateQuerierTolerations
 */
export interface TempoStackSpecTemplateQuerierTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema TempoStackSpecTemplateQuerierTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema TempoStackSpecTemplateQuerierTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema TempoStackSpecTemplateQuerierTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict). Zero and
   * negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema TempoStackSpecTemplateQuerierTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema TempoStackSpecTemplateQuerierTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'TempoStackSpecTemplateQuerierTolerations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateQuerierTolerations(obj: TempoStackSpecTemplateQuerierTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TempoComponentSpec is embedded to extend this definition with further options.
 *
 * Currently there is no way to inline this field.
 * See: https://github.com/golang/go/issues/6213
 *
 * @schema TempoStackSpecTemplateQueryFrontendComponent
 */
export interface TempoStackSpecTemplateQueryFrontendComponent {
  /**
   * NodeSelector defines the simple form of the node-selection constraint.
   *
   * @schema TempoStackSpecTemplateQueryFrontendComponent#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * PodSecurityContext defines security context will be applied to all pods of this component.
   *
   * @schema TempoStackSpecTemplateQueryFrontendComponent#podSecurityContext
   */
  readonly podSecurityContext?: TempoStackSpecTemplateQueryFrontendComponentPodSecurityContext;

  /**
   * Replicas defines the number of replicas to be created for this component.
   *
   * @schema TempoStackSpecTemplateQueryFrontendComponent#replicas
   */
  readonly replicas?: number;

  /**
   * Resources defines resources for this component, this will override the calculated resources derived from total
   *
   * @schema TempoStackSpecTemplateQueryFrontendComponent#resources
   */
  readonly resources?: TempoStackSpecTemplateQueryFrontendComponentResources;

  /**
   * Tolerations defines component-specific pod tolerations.
   *
   * @schema TempoStackSpecTemplateQueryFrontendComponent#tolerations
   */
  readonly tolerations?: TempoStackSpecTemplateQueryFrontendComponentTolerations[];

}

/**
 * Converts an object of type 'TempoStackSpecTemplateQueryFrontendComponent' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateQueryFrontendComponent(obj: TempoStackSpecTemplateQueryFrontendComponent | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'podSecurityContext': toJson_TempoStackSpecTemplateQueryFrontendComponentPodSecurityContext(obj.podSecurityContext),
    'replicas': obj.replicas,
    'resources': toJson_TempoStackSpecTemplateQueryFrontendComponentResources(obj.resources),
    'tolerations': obj.tolerations?.map(y => toJson_TempoStackSpecTemplateQueryFrontendComponentTolerations(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * JaegerQuery defines options specific to the Jaeger Query component.
 *
 * @schema TempoStackSpecTemplateQueryFrontendJaegerQuery
 */
export interface TempoStackSpecTemplateQueryFrontendJaegerQuery {
  /**
   * Authentication defines the options for the oauth proxy used to protect jaeger UI
   *
   * @schema TempoStackSpecTemplateQueryFrontendJaegerQuery#authentication
   */
  readonly authentication?: TempoStackSpecTemplateQueryFrontendJaegerQueryAuthentication;

  /**
   * Enabled defines if the Jaeger Query component should be created.
   *
   * @schema TempoStackSpecTemplateQueryFrontendJaegerQuery#enabled
   */
  readonly enabled?: boolean;

  /**
   * FindTracesConcurrentRequests defines how many concurrent request a single trace search can submit (defaults querier.replicas*2).
   * The search for traces in Jaeger submits limit+1 requests. First requests finds trace IDs and then it fetches
   * entire traces by ID. This property allows Jaeger to fetch traces in parallel.
   * Note that by default a single Tempo querier can process 20 concurrent search jobs.
   * Increasing this property might require scaling up querier instances, especially on error "job queue full"
   * See also Tempo's extraConfig:
   * querier.max_concurrent_queries (20 default)
   * query_frontend.max_outstanding_per_tenant: (2000 default). Increase if the query-frontend returns 429
   *
   * @schema TempoStackSpecTemplateQueryFrontendJaegerQuery#findTracesConcurrentRequests
   */
  readonly findTracesConcurrentRequests?: number;

  /**
   * Ingress defines the options for the Jaeger Query ingress.
   *
   * @schema TempoStackSpecTemplateQueryFrontendJaegerQuery#ingress
   */
  readonly ingress?: TempoStackSpecTemplateQueryFrontendJaegerQueryIngress;

  /**
   * MonitorTab defines the monitor tab configuration.
   *
   * @schema TempoStackSpecTemplateQueryFrontendJaegerQuery#monitorTab
   */
  readonly monitorTab?: TempoStackSpecTemplateQueryFrontendJaegerQueryMonitorTab;

  /**
   * Resources defines resources for this component, this will override the calculated resources derived from total
   *
   * @schema TempoStackSpecTemplateQueryFrontendJaegerQuery#resources
   */
  readonly resources?: TempoStackSpecTemplateQueryFrontendJaegerQueryResources;

  /**
   * ServicesQueryDuration defines how long the services will be available in the services list
   *
   * @schema TempoStackSpecTemplateQueryFrontendJaegerQuery#servicesQueryDuration
   */
  readonly servicesQueryDuration?: string;

  /**
   * TempoQuery defines options specific to the Tempoo Query component.
   *
   * @schema TempoStackSpecTemplateQueryFrontendJaegerQuery#tempoQuery
   */
  readonly tempoQuery?: TempoStackSpecTemplateQueryFrontendJaegerQueryTempoQuery;

}

/**
 * Converts an object of type 'TempoStackSpecTemplateQueryFrontendJaegerQuery' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateQueryFrontendJaegerQuery(obj: TempoStackSpecTemplateQueryFrontendJaegerQuery | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authentication': toJson_TempoStackSpecTemplateQueryFrontendJaegerQueryAuthentication(obj.authentication),
    'enabled': obj.enabled,
    'findTracesConcurrentRequests': obj.findTracesConcurrentRequests,
    'ingress': toJson_TempoStackSpecTemplateQueryFrontendJaegerQueryIngress(obj.ingress),
    'monitorTab': toJson_TempoStackSpecTemplateQueryFrontendJaegerQueryMonitorTab(obj.monitorTab),
    'resources': toJson_TempoStackSpecTemplateQueryFrontendJaegerQueryResources(obj.resources),
    'servicesQueryDuration': obj.servicesQueryDuration,
    'tempoQuery': toJson_TempoStackSpecTemplateQueryFrontendJaegerQueryTempoQuery(obj.tempoQuery),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * OIDC defines the spec for the OIDC tenant's authentication.
 *
 * @schema TempoStackSpecTenantsAuthenticationOidc
 */
export interface TempoStackSpecTenantsAuthenticationOidc {
  /**
   * Group claim field from ID Token
   *
   * @schema TempoStackSpecTenantsAuthenticationOidc#groupClaim
   */
  readonly groupClaim?: string;

  /**
   * IssuerURL defines the URL for issuer.
   *
   * @schema TempoStackSpecTenantsAuthenticationOidc#issuerURL
   */
  readonly issuerUrl?: string;

  /**
   * RedirectURL defines the URL for redirect.
   *
   * @schema TempoStackSpecTenantsAuthenticationOidc#redirectURL
   */
  readonly redirectUrl?: string;

  /**
   * Secret defines the spec for the clientID, clientSecret and issuerCAPath for tenant's authentication.
   *
   * @schema TempoStackSpecTenantsAuthenticationOidc#secret
   */
  readonly secret?: TempoStackSpecTenantsAuthenticationOidcSecret;

  /**
   * User claim field from ID Token
   *
   * @schema TempoStackSpecTenantsAuthenticationOidc#usernameClaim
   */
  readonly usernameClaim?: string;

}

/**
 * Converts an object of type 'TempoStackSpecTenantsAuthenticationOidc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTenantsAuthenticationOidc(obj: TempoStackSpecTenantsAuthenticationOidc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'groupClaim': obj.groupClaim,
    'issuerURL': obj.issuerUrl,
    'redirectURL': obj.redirectUrl,
    'secret': toJson_TempoStackSpecTenantsAuthenticationOidcSecret(obj.secret),
    'usernameClaim': obj.usernameClaim,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RoleBindingsSpec binds a set of roles to a set of subjects.
 *
 * @schema TempoStackSpecTenantsAuthorizationRoleBindings
 */
export interface TempoStackSpecTenantsAuthorizationRoleBindings {
  /**
   * @schema TempoStackSpecTenantsAuthorizationRoleBindings#name
   */
  readonly name: string;

  /**
   * @schema TempoStackSpecTenantsAuthorizationRoleBindings#roles
   */
  readonly roles: string[];

  /**
   * @schema TempoStackSpecTenantsAuthorizationRoleBindings#subjects
   */
  readonly subjects: TempoStackSpecTenantsAuthorizationRoleBindingsSubjects[];

}

/**
 * Converts an object of type 'TempoStackSpecTenantsAuthorizationRoleBindings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTenantsAuthorizationRoleBindings(obj: TempoStackSpecTenantsAuthorizationRoleBindings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'roles': obj.roles?.map(y => y),
    'subjects': obj.subjects?.map(y => toJson_TempoStackSpecTenantsAuthorizationRoleBindingsSubjects(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RoleSpec describes a set of permissions to interact with a tenant.
 *
 * @schema TempoStackSpecTenantsAuthorizationRoles
 */
export interface TempoStackSpecTenantsAuthorizationRoles {
  /**
   * @schema TempoStackSpecTenantsAuthorizationRoles#name
   */
  readonly name: string;

  /**
   * @schema TempoStackSpecTenantsAuthorizationRoles#permissions
   */
  readonly permissions: TempoStackSpecTenantsAuthorizationRolesPermissions[];

  /**
   * @schema TempoStackSpecTenantsAuthorizationRoles#resources
   */
  readonly resources: string[];

  /**
   * @schema TempoStackSpecTenantsAuthorizationRoles#tenants
   */
  readonly tenants: string[];

}

/**
 * Converts an object of type 'TempoStackSpecTenantsAuthorizationRoles' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTenantsAuthorizationRoles(obj: TempoStackSpecTenantsAuthorizationRoles | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'permissions': obj.permissions?.map(y => y),
    'resources': obj.resources?.map(y => y),
    'tenants': obj.tenants?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema TempoStackSpecObservabilityGrafanaInstanceSelectorMatchExpressions
 */
export interface TempoStackSpecObservabilityGrafanaInstanceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema TempoStackSpecObservabilityGrafanaInstanceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema TempoStackSpecObservabilityGrafanaInstanceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema TempoStackSpecObservabilityGrafanaInstanceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'TempoStackSpecObservabilityGrafanaInstanceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecObservabilityGrafanaInstanceSelectorMatchExpressions(obj: TempoStackSpecObservabilityGrafanaInstanceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * appArmorProfile is the AppArmor options to use by the containers in this pod.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema TempoStackSpecTemplateCompactorPodSecurityContextAppArmorProfile
 */
export interface TempoStackSpecTemplateCompactorPodSecurityContextAppArmorProfile {
  /**
   * localhostProfile indicates a profile loaded on the node that should be used.
   * The profile must be preconfigured on the node to work.
   * Must match the loaded name of the profile.
   * Must be set if and only if type is "Localhost".
   *
   * @schema TempoStackSpecTemplateCompactorPodSecurityContextAppArmorProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of AppArmor profile will be applied.
   * Valid options are:
   * Localhost - a profile pre-loaded on the node.
   * RuntimeDefault - the container runtime's default profile.
   * Unconfined - no AppArmor enforcement.
   *
   * @schema TempoStackSpecTemplateCompactorPodSecurityContextAppArmorProfile#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'TempoStackSpecTemplateCompactorPodSecurityContextAppArmorProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateCompactorPodSecurityContextAppArmorProfile(obj: TempoStackSpecTemplateCompactorPodSecurityContextAppArmorProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The SELinux context to be applied to all containers.
 * If unspecified, the container runtime will allocate a random SELinux context for each
 * container.  May also be set in SecurityContext.  If set in
 * both SecurityContext and PodSecurityContext, the value specified in SecurityContext
 * takes precedence for that container.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema TempoStackSpecTemplateCompactorPodSecurityContextSeLinuxOptions
 */
export interface TempoStackSpecTemplateCompactorPodSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema TempoStackSpecTemplateCompactorPodSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema TempoStackSpecTemplateCompactorPodSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema TempoStackSpecTemplateCompactorPodSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema TempoStackSpecTemplateCompactorPodSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'TempoStackSpecTemplateCompactorPodSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateCompactorPodSecurityContextSeLinuxOptions(obj: TempoStackSpecTemplateCompactorPodSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The seccomp options to use by the containers in this pod.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema TempoStackSpecTemplateCompactorPodSecurityContextSeccompProfile
 */
export interface TempoStackSpecTemplateCompactorPodSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used.
   * The profile must be preconfigured on the node to work.
   * Must be a descending path, relative to the kubelet's configured seccomp profile location.
   * Must be set if type is "Localhost". Must NOT be set for any other type.
   *
   * @schema TempoStackSpecTemplateCompactorPodSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied.
   * Valid options are:
   *
   * Localhost - a profile defined in a file on the node should be used.
   * RuntimeDefault - the container runtime default profile should be used.
   * Unconfined - no profile should be applied.
   *
   * @schema TempoStackSpecTemplateCompactorPodSecurityContextSeccompProfile#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'TempoStackSpecTemplateCompactorPodSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateCompactorPodSecurityContextSeccompProfile(obj: TempoStackSpecTemplateCompactorPodSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Sysctl defines a kernel parameter to be set
 *
 * @schema TempoStackSpecTemplateCompactorPodSecurityContextSysctls
 */
export interface TempoStackSpecTemplateCompactorPodSecurityContextSysctls {
  /**
   * Name of a property to set
   *
   * @schema TempoStackSpecTemplateCompactorPodSecurityContextSysctls#name
   */
  readonly name: string;

  /**
   * Value of a property to set
   *
   * @schema TempoStackSpecTemplateCompactorPodSecurityContextSysctls#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'TempoStackSpecTemplateCompactorPodSecurityContextSysctls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateCompactorPodSecurityContextSysctls(obj: TempoStackSpecTemplateCompactorPodSecurityContextSysctls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Windows specific settings applied to all containers.
 * If unspecified, the options within a container's SecurityContext will be used.
 * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema TempoStackSpecTemplateCompactorPodSecurityContextWindowsOptions
 */
export interface TempoStackSpecTemplateCompactorPodSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook
   * (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
   * GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema TempoStackSpecTemplateCompactorPodSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema TempoStackSpecTemplateCompactorPodSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container.
   * All of a Pod's containers must have the same effective HostProcess value
   * (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
   * In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema TempoStackSpecTemplateCompactorPodSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process.
   * Defaults to the user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext. If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified.
   * @schema TempoStackSpecTemplateCompactorPodSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'TempoStackSpecTemplateCompactorPodSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateCompactorPodSecurityContextWindowsOptions(obj: TempoStackSpecTemplateCompactorPodSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema TempoStackSpecTemplateCompactorResourcesClaims
 */
export interface TempoStackSpecTemplateCompactorResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema TempoStackSpecTemplateCompactorResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema TempoStackSpecTemplateCompactorResourcesClaims#request
   */
  readonly request?: string;

}

/**
 * Converts an object of type 'TempoStackSpecTemplateCompactorResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateCompactorResourcesClaims(obj: TempoStackSpecTemplateCompactorResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'request': obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TempoStackSpecTemplateCompactorResourcesLimits
 */
export class TempoStackSpecTemplateCompactorResourcesLimits {
  public static fromNumber(value: number): TempoStackSpecTemplateCompactorResourcesLimits {
    return new TempoStackSpecTemplateCompactorResourcesLimits(value);
  }
  public static fromString(value: string): TempoStackSpecTemplateCompactorResourcesLimits {
    return new TempoStackSpecTemplateCompactorResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema TempoStackSpecTemplateCompactorResourcesRequests
 */
export class TempoStackSpecTemplateCompactorResourcesRequests {
  public static fromNumber(value: number): TempoStackSpecTemplateCompactorResourcesRequests {
    return new TempoStackSpecTemplateCompactorResourcesRequests(value);
  }
  public static fromString(value: string): TempoStackSpecTemplateCompactorResourcesRequests {
    return new TempoStackSpecTemplateCompactorResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * PodSecurityContext defines security context will be applied to all pods of this component.
 *
 * @schema TempoStackSpecTemplateDistributorComponentPodSecurityContext
 */
export interface TempoStackSpecTemplateDistributorComponentPodSecurityContext {
  /**
   * appArmorProfile is the AppArmor options to use by the containers in this pod.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema TempoStackSpecTemplateDistributorComponentPodSecurityContext#appArmorProfile
   */
  readonly appArmorProfile?: TempoStackSpecTemplateDistributorComponentPodSecurityContextAppArmorProfile;

  /**
   * A special supplemental group that applies to all containers in a pod.
   * Some volume types allow the Kubelet to change the ownership of that volume
   * to be owned by the pod:
   *
   * 1. The owning GID will be the FSGroup
   * 2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
   * 3. The permission bits are OR'd with rw-rw----
   *
   * If unset, the Kubelet will not modify the ownership and permissions of any volume.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema TempoStackSpecTemplateDistributorComponentPodSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * fsGroupChangePolicy defines behavior of changing ownership and permission of the volume
   * before being exposed inside Pod. This field will only apply to
   * volume types which support fsGroup based ownership(and permissions).
   * It will have no effect on ephemeral volume types such as: secret, configmaps
   * and emptydir.
   * Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema TempoStackSpecTemplateDistributorComponentPodSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * The GID to run the entrypoint of the container process.
   * Uses runtime default if unset.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence
   * for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema TempoStackSpecTemplateDistributorComponentPodSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user.
   * If true, the Kubelet will validate the image at runtime to ensure that it
   * does not run as UID 0 (root) and fail to start the container if it does.
   * If unset or false, no such validation will be performed.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema TempoStackSpecTemplateDistributorComponentPodSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process.
   * Defaults to user specified in image metadata if unspecified.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence
   * for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified.
   * @schema TempoStackSpecTemplateDistributorComponentPodSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * seLinuxChangePolicy defines how the container's SELinux label is applied to all volumes used by the Pod.
   * It has no effect on nodes that do not support SELinux or to volumes does not support SELinux.
   * Valid values are "MountOption" and "Recursive".
   *
   * "Recursive" means relabeling of all files on all Pod volumes by the container runtime.
   * This may be slow for large volumes, but allows mixing privileged and unprivileged Pods sharing the same volume on the same node.
   *
   * "MountOption" mounts all eligible Pod volumes with `-o context` mount option.
   * This requires all Pods that share the same volume to use the same SELinux label.
   * It is not possible to share the same volume among privileged and unprivileged Pods.
   * Eligible volumes are in-tree FibreChannel and iSCSI volumes, and all CSI volumes
   * whose CSI driver announces SELinux support by setting spec.seLinuxMount: true in their
   * CSIDriver instance. Other volumes are always re-labelled recursively.
   * "MountOption" value is allowed only when SELinuxMount feature gate is enabled.
   *
   * If not specified and SELinuxMount feature gate is enabled, "MountOption" is used.
   * If not specified and SELinuxMount feature gate is disabled, "MountOption" is used for ReadWriteOncePod volumes
   * and "Recursive" for all other volumes.
   *
   * This field affects only Pods that have SELinux label set, either in PodSecurityContext or in SecurityContext of all containers.
   *
   * All Pods that use the same volume should use the same seLinuxChangePolicy, otherwise some pods can get stuck in ContainerCreating state.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema TempoStackSpecTemplateDistributorComponentPodSecurityContext#seLinuxChangePolicy
   */
  readonly seLinuxChangePolicy?: string;

  /**
   * The SELinux context to be applied to all containers.
   * If unspecified, the container runtime will allocate a random SELinux context for each
   * container.  May also be set in SecurityContext.  If set in
   * both SecurityContext and PodSecurityContext, the value specified in SecurityContext
   * takes precedence for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema TempoStackSpecTemplateDistributorComponentPodSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: TempoStackSpecTemplateDistributorComponentPodSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by the containers in this pod.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema TempoStackSpecTemplateDistributorComponentPodSecurityContext#seccompProfile
   */
  readonly seccompProfile?: TempoStackSpecTemplateDistributorComponentPodSecurityContextSeccompProfile;

  /**
   * A list of groups applied to the first process run in each container, in
   * addition to the container's primary GID and fsGroup (if specified).  If
   * the SupplementalGroupsPolicy feature is enabled, the
   * supplementalGroupsPolicy field determines whether these are in addition
   * to or instead of any group memberships defined in the container image.
   * If unspecified, no additional groups are added, though group memberships
   * defined in the container image may still be used, depending on the
   * supplementalGroupsPolicy field.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema TempoStackSpecTemplateDistributorComponentPodSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * Defines how supplemental groups of the first container processes are calculated.
   * Valid values are "Merge" and "Strict". If not specified, "Merge" is used.
   * (Alpha) Using the field requires the SupplementalGroupsPolicy feature gate to be enabled
   * and the container runtime must implement support for this feature.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema TempoStackSpecTemplateDistributorComponentPodSecurityContext#supplementalGroupsPolicy
   */
  readonly supplementalGroupsPolicy?: string;

  /**
   * Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported
   * sysctls (by the container runtime) might fail to launch.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema TempoStackSpecTemplateDistributorComponentPodSecurityContext#sysctls
   */
  readonly sysctls?: TempoStackSpecTemplateDistributorComponentPodSecurityContextSysctls[];

  /**
   * The Windows specific settings applied to all containers.
   * If unspecified, the options within a container's SecurityContext will be used.
   * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema TempoStackSpecTemplateDistributorComponentPodSecurityContext#windowsOptions
   */
  readonly windowsOptions?: TempoStackSpecTemplateDistributorComponentPodSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'TempoStackSpecTemplateDistributorComponentPodSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateDistributorComponentPodSecurityContext(obj: TempoStackSpecTemplateDistributorComponentPodSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'appArmorProfile': toJson_TempoStackSpecTemplateDistributorComponentPodSecurityContextAppArmorProfile(obj.appArmorProfile),
    'fsGroup': obj.fsGroup,
    'fsGroupChangePolicy': obj.fsGroupChangePolicy,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxChangePolicy': obj.seLinuxChangePolicy,
    'seLinuxOptions': toJson_TempoStackSpecTemplateDistributorComponentPodSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_TempoStackSpecTemplateDistributorComponentPodSecurityContextSeccompProfile(obj.seccompProfile),
    'supplementalGroups': obj.supplementalGroups?.map(y => y),
    'supplementalGroupsPolicy': obj.supplementalGroupsPolicy,
    'sysctls': obj.sysctls?.map(y => toJson_TempoStackSpecTemplateDistributorComponentPodSecurityContextSysctls(y)),
    'windowsOptions': toJson_TempoStackSpecTemplateDistributorComponentPodSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resources defines resources for this component, this will override the calculated resources derived from total
 *
 * @schema TempoStackSpecTemplateDistributorComponentResources
 */
export interface TempoStackSpecTemplateDistributorComponentResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema TempoStackSpecTemplateDistributorComponentResources#claims
   */
  readonly claims?: TempoStackSpecTemplateDistributorComponentResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema TempoStackSpecTemplateDistributorComponentResources#limits
   */
  readonly limits?: { [key: string]: TempoStackSpecTemplateDistributorComponentResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema TempoStackSpecTemplateDistributorComponentResources#requests
   */
  readonly requests?: { [key: string]: TempoStackSpecTemplateDistributorComponentResourcesRequests };

}

/**
 * Converts an object of type 'TempoStackSpecTemplateDistributorComponentResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateDistributorComponentResources(obj: TempoStackSpecTemplateDistributorComponentResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claims': obj.claims?.map(y => toJson_TempoStackSpecTemplateDistributorComponentResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema TempoStackSpecTemplateDistributorComponentTolerations
 */
export interface TempoStackSpecTemplateDistributorComponentTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema TempoStackSpecTemplateDistributorComponentTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema TempoStackSpecTemplateDistributorComponentTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema TempoStackSpecTemplateDistributorComponentTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict). Zero and
   * negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema TempoStackSpecTemplateDistributorComponentTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema TempoStackSpecTemplateDistributorComponentTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'TempoStackSpecTemplateDistributorComponentTolerations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateDistributorComponentTolerations(obj: TempoStackSpecTemplateDistributorComponentTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PodSecurityContext defines security context will be applied to all pods of this component.
 *
 * @schema TempoStackSpecTemplateGatewayComponentPodSecurityContext
 */
export interface TempoStackSpecTemplateGatewayComponentPodSecurityContext {
  /**
   * appArmorProfile is the AppArmor options to use by the containers in this pod.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema TempoStackSpecTemplateGatewayComponentPodSecurityContext#appArmorProfile
   */
  readonly appArmorProfile?: TempoStackSpecTemplateGatewayComponentPodSecurityContextAppArmorProfile;

  /**
   * A special supplemental group that applies to all containers in a pod.
   * Some volume types allow the Kubelet to change the ownership of that volume
   * to be owned by the pod:
   *
   * 1. The owning GID will be the FSGroup
   * 2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
   * 3. The permission bits are OR'd with rw-rw----
   *
   * If unset, the Kubelet will not modify the ownership and permissions of any volume.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema TempoStackSpecTemplateGatewayComponentPodSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * fsGroupChangePolicy defines behavior of changing ownership and permission of the volume
   * before being exposed inside Pod. This field will only apply to
   * volume types which support fsGroup based ownership(and permissions).
   * It will have no effect on ephemeral volume types such as: secret, configmaps
   * and emptydir.
   * Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema TempoStackSpecTemplateGatewayComponentPodSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * The GID to run the entrypoint of the container process.
   * Uses runtime default if unset.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence
   * for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema TempoStackSpecTemplateGatewayComponentPodSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user.
   * If true, the Kubelet will validate the image at runtime to ensure that it
   * does not run as UID 0 (root) and fail to start the container if it does.
   * If unset or false, no such validation will be performed.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema TempoStackSpecTemplateGatewayComponentPodSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process.
   * Defaults to user specified in image metadata if unspecified.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence
   * for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified.
   * @schema TempoStackSpecTemplateGatewayComponentPodSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * seLinuxChangePolicy defines how the container's SELinux label is applied to all volumes used by the Pod.
   * It has no effect on nodes that do not support SELinux or to volumes does not support SELinux.
   * Valid values are "MountOption" and "Recursive".
   *
   * "Recursive" means relabeling of all files on all Pod volumes by the container runtime.
   * This may be slow for large volumes, but allows mixing privileged and unprivileged Pods sharing the same volume on the same node.
   *
   * "MountOption" mounts all eligible Pod volumes with `-o context` mount option.
   * This requires all Pods that share the same volume to use the same SELinux label.
   * It is not possible to share the same volume among privileged and unprivileged Pods.
   * Eligible volumes are in-tree FibreChannel and iSCSI volumes, and all CSI volumes
   * whose CSI driver announces SELinux support by setting spec.seLinuxMount: true in their
   * CSIDriver instance. Other volumes are always re-labelled recursively.
   * "MountOption" value is allowed only when SELinuxMount feature gate is enabled.
   *
   * If not specified and SELinuxMount feature gate is enabled, "MountOption" is used.
   * If not specified and SELinuxMount feature gate is disabled, "MountOption" is used for ReadWriteOncePod volumes
   * and "Recursive" for all other volumes.
   *
   * This field affects only Pods that have SELinux label set, either in PodSecurityContext or in SecurityContext of all containers.
   *
   * All Pods that use the same volume should use the same seLinuxChangePolicy, otherwise some pods can get stuck in ContainerCreating state.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema TempoStackSpecTemplateGatewayComponentPodSecurityContext#seLinuxChangePolicy
   */
  readonly seLinuxChangePolicy?: string;

  /**
   * The SELinux context to be applied to all containers.
   * If unspecified, the container runtime will allocate a random SELinux context for each
   * container.  May also be set in SecurityContext.  If set in
   * both SecurityContext and PodSecurityContext, the value specified in SecurityContext
   * takes precedence for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema TempoStackSpecTemplateGatewayComponentPodSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: TempoStackSpecTemplateGatewayComponentPodSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by the containers in this pod.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema TempoStackSpecTemplateGatewayComponentPodSecurityContext#seccompProfile
   */
  readonly seccompProfile?: TempoStackSpecTemplateGatewayComponentPodSecurityContextSeccompProfile;

  /**
   * A list of groups applied to the first process run in each container, in
   * addition to the container's primary GID and fsGroup (if specified).  If
   * the SupplementalGroupsPolicy feature is enabled, the
   * supplementalGroupsPolicy field determines whether these are in addition
   * to or instead of any group memberships defined in the container image.
   * If unspecified, no additional groups are added, though group memberships
   * defined in the container image may still be used, depending on the
   * supplementalGroupsPolicy field.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema TempoStackSpecTemplateGatewayComponentPodSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * Defines how supplemental groups of the first container processes are calculated.
   * Valid values are "Merge" and "Strict". If not specified, "Merge" is used.
   * (Alpha) Using the field requires the SupplementalGroupsPolicy feature gate to be enabled
   * and the container runtime must implement support for this feature.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema TempoStackSpecTemplateGatewayComponentPodSecurityContext#supplementalGroupsPolicy
   */
  readonly supplementalGroupsPolicy?: string;

  /**
   * Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported
   * sysctls (by the container runtime) might fail to launch.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema TempoStackSpecTemplateGatewayComponentPodSecurityContext#sysctls
   */
  readonly sysctls?: TempoStackSpecTemplateGatewayComponentPodSecurityContextSysctls[];

  /**
   * The Windows specific settings applied to all containers.
   * If unspecified, the options within a container's SecurityContext will be used.
   * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema TempoStackSpecTemplateGatewayComponentPodSecurityContext#windowsOptions
   */
  readonly windowsOptions?: TempoStackSpecTemplateGatewayComponentPodSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'TempoStackSpecTemplateGatewayComponentPodSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateGatewayComponentPodSecurityContext(obj: TempoStackSpecTemplateGatewayComponentPodSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'appArmorProfile': toJson_TempoStackSpecTemplateGatewayComponentPodSecurityContextAppArmorProfile(obj.appArmorProfile),
    'fsGroup': obj.fsGroup,
    'fsGroupChangePolicy': obj.fsGroupChangePolicy,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxChangePolicy': obj.seLinuxChangePolicy,
    'seLinuxOptions': toJson_TempoStackSpecTemplateGatewayComponentPodSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_TempoStackSpecTemplateGatewayComponentPodSecurityContextSeccompProfile(obj.seccompProfile),
    'supplementalGroups': obj.supplementalGroups?.map(y => y),
    'supplementalGroupsPolicy': obj.supplementalGroupsPolicy,
    'sysctls': obj.sysctls?.map(y => toJson_TempoStackSpecTemplateGatewayComponentPodSecurityContextSysctls(y)),
    'windowsOptions': toJson_TempoStackSpecTemplateGatewayComponentPodSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resources defines resources for this component, this will override the calculated resources derived from total
 *
 * @schema TempoStackSpecTemplateGatewayComponentResources
 */
export interface TempoStackSpecTemplateGatewayComponentResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema TempoStackSpecTemplateGatewayComponentResources#claims
   */
  readonly claims?: TempoStackSpecTemplateGatewayComponentResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema TempoStackSpecTemplateGatewayComponentResources#limits
   */
  readonly limits?: { [key: string]: TempoStackSpecTemplateGatewayComponentResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema TempoStackSpecTemplateGatewayComponentResources#requests
   */
  readonly requests?: { [key: string]: TempoStackSpecTemplateGatewayComponentResourcesRequests };

}

/**
 * Converts an object of type 'TempoStackSpecTemplateGatewayComponentResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateGatewayComponentResources(obj: TempoStackSpecTemplateGatewayComponentResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claims': obj.claims?.map(y => toJson_TempoStackSpecTemplateGatewayComponentResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema TempoStackSpecTemplateGatewayComponentTolerations
 */
export interface TempoStackSpecTemplateGatewayComponentTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema TempoStackSpecTemplateGatewayComponentTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema TempoStackSpecTemplateGatewayComponentTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema TempoStackSpecTemplateGatewayComponentTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict). Zero and
   * negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema TempoStackSpecTemplateGatewayComponentTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema TempoStackSpecTemplateGatewayComponentTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'TempoStackSpecTemplateGatewayComponentTolerations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateGatewayComponentTolerations(obj: TempoStackSpecTemplateGatewayComponentTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Route defines the options for the OpenShift route.
 *
 * @schema TempoStackSpecTemplateGatewayIngressRoute
 */
export interface TempoStackSpecTemplateGatewayIngressRoute {
  /**
   * Termination defines the termination type.
   * The default is "edge".
   *
   * @schema TempoStackSpecTemplateGatewayIngressRoute#termination
   */
  readonly termination?: TempoStackSpecTemplateGatewayIngressRouteTermination;

}

/**
 * Converts an object of type 'TempoStackSpecTemplateGatewayIngressRoute' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateGatewayIngressRoute(obj: TempoStackSpecTemplateGatewayIngressRoute | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'termination': obj.termination,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Type defines the type of Ingress for the Jaeger Query UI.
 * Currently ingress, route and none are supported.
 *
 * @schema TempoStackSpecTemplateGatewayIngressType
 */
export enum TempoStackSpecTemplateGatewayIngressType {
  /** ingress */
  INGRESS = "ingress",
  /** route */
  ROUTE = "route",
}

/**
 * appArmorProfile is the AppArmor options to use by the containers in this pod.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema TempoStackSpecTemplateIngesterPodSecurityContextAppArmorProfile
 */
export interface TempoStackSpecTemplateIngesterPodSecurityContextAppArmorProfile {
  /**
   * localhostProfile indicates a profile loaded on the node that should be used.
   * The profile must be preconfigured on the node to work.
   * Must match the loaded name of the profile.
   * Must be set if and only if type is "Localhost".
   *
   * @schema TempoStackSpecTemplateIngesterPodSecurityContextAppArmorProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of AppArmor profile will be applied.
   * Valid options are:
   * Localhost - a profile pre-loaded on the node.
   * RuntimeDefault - the container runtime's default profile.
   * Unconfined - no AppArmor enforcement.
   *
   * @schema TempoStackSpecTemplateIngesterPodSecurityContextAppArmorProfile#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'TempoStackSpecTemplateIngesterPodSecurityContextAppArmorProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateIngesterPodSecurityContextAppArmorProfile(obj: TempoStackSpecTemplateIngesterPodSecurityContextAppArmorProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The SELinux context to be applied to all containers.
 * If unspecified, the container runtime will allocate a random SELinux context for each
 * container.  May also be set in SecurityContext.  If set in
 * both SecurityContext and PodSecurityContext, the value specified in SecurityContext
 * takes precedence for that container.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema TempoStackSpecTemplateIngesterPodSecurityContextSeLinuxOptions
 */
export interface TempoStackSpecTemplateIngesterPodSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema TempoStackSpecTemplateIngesterPodSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema TempoStackSpecTemplateIngesterPodSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema TempoStackSpecTemplateIngesterPodSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema TempoStackSpecTemplateIngesterPodSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'TempoStackSpecTemplateIngesterPodSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateIngesterPodSecurityContextSeLinuxOptions(obj: TempoStackSpecTemplateIngesterPodSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The seccomp options to use by the containers in this pod.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema TempoStackSpecTemplateIngesterPodSecurityContextSeccompProfile
 */
export interface TempoStackSpecTemplateIngesterPodSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used.
   * The profile must be preconfigured on the node to work.
   * Must be a descending path, relative to the kubelet's configured seccomp profile location.
   * Must be set if type is "Localhost". Must NOT be set for any other type.
   *
   * @schema TempoStackSpecTemplateIngesterPodSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied.
   * Valid options are:
   *
   * Localhost - a profile defined in a file on the node should be used.
   * RuntimeDefault - the container runtime default profile should be used.
   * Unconfined - no profile should be applied.
   *
   * @schema TempoStackSpecTemplateIngesterPodSecurityContextSeccompProfile#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'TempoStackSpecTemplateIngesterPodSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateIngesterPodSecurityContextSeccompProfile(obj: TempoStackSpecTemplateIngesterPodSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Sysctl defines a kernel parameter to be set
 *
 * @schema TempoStackSpecTemplateIngesterPodSecurityContextSysctls
 */
export interface TempoStackSpecTemplateIngesterPodSecurityContextSysctls {
  /**
   * Name of a property to set
   *
   * @schema TempoStackSpecTemplateIngesterPodSecurityContextSysctls#name
   */
  readonly name: string;

  /**
   * Value of a property to set
   *
   * @schema TempoStackSpecTemplateIngesterPodSecurityContextSysctls#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'TempoStackSpecTemplateIngesterPodSecurityContextSysctls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateIngesterPodSecurityContextSysctls(obj: TempoStackSpecTemplateIngesterPodSecurityContextSysctls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Windows specific settings applied to all containers.
 * If unspecified, the options within a container's SecurityContext will be used.
 * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema TempoStackSpecTemplateIngesterPodSecurityContextWindowsOptions
 */
export interface TempoStackSpecTemplateIngesterPodSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook
   * (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
   * GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema TempoStackSpecTemplateIngesterPodSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema TempoStackSpecTemplateIngesterPodSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container.
   * All of a Pod's containers must have the same effective HostProcess value
   * (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
   * In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema TempoStackSpecTemplateIngesterPodSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process.
   * Defaults to the user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext. If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified.
   * @schema TempoStackSpecTemplateIngesterPodSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'TempoStackSpecTemplateIngesterPodSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateIngesterPodSecurityContextWindowsOptions(obj: TempoStackSpecTemplateIngesterPodSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema TempoStackSpecTemplateIngesterResourcesClaims
 */
export interface TempoStackSpecTemplateIngesterResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema TempoStackSpecTemplateIngesterResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema TempoStackSpecTemplateIngesterResourcesClaims#request
   */
  readonly request?: string;

}

/**
 * Converts an object of type 'TempoStackSpecTemplateIngesterResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateIngesterResourcesClaims(obj: TempoStackSpecTemplateIngesterResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'request': obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TempoStackSpecTemplateIngesterResourcesLimits
 */
export class TempoStackSpecTemplateIngesterResourcesLimits {
  public static fromNumber(value: number): TempoStackSpecTemplateIngesterResourcesLimits {
    return new TempoStackSpecTemplateIngesterResourcesLimits(value);
  }
  public static fromString(value: string): TempoStackSpecTemplateIngesterResourcesLimits {
    return new TempoStackSpecTemplateIngesterResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema TempoStackSpecTemplateIngesterResourcesRequests
 */
export class TempoStackSpecTemplateIngesterResourcesRequests {
  public static fromNumber(value: number): TempoStackSpecTemplateIngesterResourcesRequests {
    return new TempoStackSpecTemplateIngesterResourcesRequests(value);
  }
  public static fromString(value: string): TempoStackSpecTemplateIngesterResourcesRequests {
    return new TempoStackSpecTemplateIngesterResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * appArmorProfile is the AppArmor options to use by the containers in this pod.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema TempoStackSpecTemplateQuerierPodSecurityContextAppArmorProfile
 */
export interface TempoStackSpecTemplateQuerierPodSecurityContextAppArmorProfile {
  /**
   * localhostProfile indicates a profile loaded on the node that should be used.
   * The profile must be preconfigured on the node to work.
   * Must match the loaded name of the profile.
   * Must be set if and only if type is "Localhost".
   *
   * @schema TempoStackSpecTemplateQuerierPodSecurityContextAppArmorProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of AppArmor profile will be applied.
   * Valid options are:
   * Localhost - a profile pre-loaded on the node.
   * RuntimeDefault - the container runtime's default profile.
   * Unconfined - no AppArmor enforcement.
   *
   * @schema TempoStackSpecTemplateQuerierPodSecurityContextAppArmorProfile#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'TempoStackSpecTemplateQuerierPodSecurityContextAppArmorProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateQuerierPodSecurityContextAppArmorProfile(obj: TempoStackSpecTemplateQuerierPodSecurityContextAppArmorProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The SELinux context to be applied to all containers.
 * If unspecified, the container runtime will allocate a random SELinux context for each
 * container.  May also be set in SecurityContext.  If set in
 * both SecurityContext and PodSecurityContext, the value specified in SecurityContext
 * takes precedence for that container.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema TempoStackSpecTemplateQuerierPodSecurityContextSeLinuxOptions
 */
export interface TempoStackSpecTemplateQuerierPodSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema TempoStackSpecTemplateQuerierPodSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema TempoStackSpecTemplateQuerierPodSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema TempoStackSpecTemplateQuerierPodSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema TempoStackSpecTemplateQuerierPodSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'TempoStackSpecTemplateQuerierPodSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateQuerierPodSecurityContextSeLinuxOptions(obj: TempoStackSpecTemplateQuerierPodSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The seccomp options to use by the containers in this pod.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema TempoStackSpecTemplateQuerierPodSecurityContextSeccompProfile
 */
export interface TempoStackSpecTemplateQuerierPodSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used.
   * The profile must be preconfigured on the node to work.
   * Must be a descending path, relative to the kubelet's configured seccomp profile location.
   * Must be set if type is "Localhost". Must NOT be set for any other type.
   *
   * @schema TempoStackSpecTemplateQuerierPodSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied.
   * Valid options are:
   *
   * Localhost - a profile defined in a file on the node should be used.
   * RuntimeDefault - the container runtime default profile should be used.
   * Unconfined - no profile should be applied.
   *
   * @schema TempoStackSpecTemplateQuerierPodSecurityContextSeccompProfile#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'TempoStackSpecTemplateQuerierPodSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateQuerierPodSecurityContextSeccompProfile(obj: TempoStackSpecTemplateQuerierPodSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Sysctl defines a kernel parameter to be set
 *
 * @schema TempoStackSpecTemplateQuerierPodSecurityContextSysctls
 */
export interface TempoStackSpecTemplateQuerierPodSecurityContextSysctls {
  /**
   * Name of a property to set
   *
   * @schema TempoStackSpecTemplateQuerierPodSecurityContextSysctls#name
   */
  readonly name: string;

  /**
   * Value of a property to set
   *
   * @schema TempoStackSpecTemplateQuerierPodSecurityContextSysctls#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'TempoStackSpecTemplateQuerierPodSecurityContextSysctls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateQuerierPodSecurityContextSysctls(obj: TempoStackSpecTemplateQuerierPodSecurityContextSysctls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Windows specific settings applied to all containers.
 * If unspecified, the options within a container's SecurityContext will be used.
 * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema TempoStackSpecTemplateQuerierPodSecurityContextWindowsOptions
 */
export interface TempoStackSpecTemplateQuerierPodSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook
   * (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
   * GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema TempoStackSpecTemplateQuerierPodSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema TempoStackSpecTemplateQuerierPodSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container.
   * All of a Pod's containers must have the same effective HostProcess value
   * (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
   * In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema TempoStackSpecTemplateQuerierPodSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process.
   * Defaults to the user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext. If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified.
   * @schema TempoStackSpecTemplateQuerierPodSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'TempoStackSpecTemplateQuerierPodSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateQuerierPodSecurityContextWindowsOptions(obj: TempoStackSpecTemplateQuerierPodSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema TempoStackSpecTemplateQuerierResourcesClaims
 */
export interface TempoStackSpecTemplateQuerierResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema TempoStackSpecTemplateQuerierResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema TempoStackSpecTemplateQuerierResourcesClaims#request
   */
  readonly request?: string;

}

/**
 * Converts an object of type 'TempoStackSpecTemplateQuerierResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateQuerierResourcesClaims(obj: TempoStackSpecTemplateQuerierResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'request': obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TempoStackSpecTemplateQuerierResourcesLimits
 */
export class TempoStackSpecTemplateQuerierResourcesLimits {
  public static fromNumber(value: number): TempoStackSpecTemplateQuerierResourcesLimits {
    return new TempoStackSpecTemplateQuerierResourcesLimits(value);
  }
  public static fromString(value: string): TempoStackSpecTemplateQuerierResourcesLimits {
    return new TempoStackSpecTemplateQuerierResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema TempoStackSpecTemplateQuerierResourcesRequests
 */
export class TempoStackSpecTemplateQuerierResourcesRequests {
  public static fromNumber(value: number): TempoStackSpecTemplateQuerierResourcesRequests {
    return new TempoStackSpecTemplateQuerierResourcesRequests(value);
  }
  public static fromString(value: string): TempoStackSpecTemplateQuerierResourcesRequests {
    return new TempoStackSpecTemplateQuerierResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * PodSecurityContext defines security context will be applied to all pods of this component.
 *
 * @schema TempoStackSpecTemplateQueryFrontendComponentPodSecurityContext
 */
export interface TempoStackSpecTemplateQueryFrontendComponentPodSecurityContext {
  /**
   * appArmorProfile is the AppArmor options to use by the containers in this pod.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema TempoStackSpecTemplateQueryFrontendComponentPodSecurityContext#appArmorProfile
   */
  readonly appArmorProfile?: TempoStackSpecTemplateQueryFrontendComponentPodSecurityContextAppArmorProfile;

  /**
   * A special supplemental group that applies to all containers in a pod.
   * Some volume types allow the Kubelet to change the ownership of that volume
   * to be owned by the pod:
   *
   * 1. The owning GID will be the FSGroup
   * 2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
   * 3. The permission bits are OR'd with rw-rw----
   *
   * If unset, the Kubelet will not modify the ownership and permissions of any volume.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema TempoStackSpecTemplateQueryFrontendComponentPodSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * fsGroupChangePolicy defines behavior of changing ownership and permission of the volume
   * before being exposed inside Pod. This field will only apply to
   * volume types which support fsGroup based ownership(and permissions).
   * It will have no effect on ephemeral volume types such as: secret, configmaps
   * and emptydir.
   * Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema TempoStackSpecTemplateQueryFrontendComponentPodSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * The GID to run the entrypoint of the container process.
   * Uses runtime default if unset.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence
   * for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema TempoStackSpecTemplateQueryFrontendComponentPodSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user.
   * If true, the Kubelet will validate the image at runtime to ensure that it
   * does not run as UID 0 (root) and fail to start the container if it does.
   * If unset or false, no such validation will be performed.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema TempoStackSpecTemplateQueryFrontendComponentPodSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process.
   * Defaults to user specified in image metadata if unspecified.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence
   * for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified.
   * @schema TempoStackSpecTemplateQueryFrontendComponentPodSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * seLinuxChangePolicy defines how the container's SELinux label is applied to all volumes used by the Pod.
   * It has no effect on nodes that do not support SELinux or to volumes does not support SELinux.
   * Valid values are "MountOption" and "Recursive".
   *
   * "Recursive" means relabeling of all files on all Pod volumes by the container runtime.
   * This may be slow for large volumes, but allows mixing privileged and unprivileged Pods sharing the same volume on the same node.
   *
   * "MountOption" mounts all eligible Pod volumes with `-o context` mount option.
   * This requires all Pods that share the same volume to use the same SELinux label.
   * It is not possible to share the same volume among privileged and unprivileged Pods.
   * Eligible volumes are in-tree FibreChannel and iSCSI volumes, and all CSI volumes
   * whose CSI driver announces SELinux support by setting spec.seLinuxMount: true in their
   * CSIDriver instance. Other volumes are always re-labelled recursively.
   * "MountOption" value is allowed only when SELinuxMount feature gate is enabled.
   *
   * If not specified and SELinuxMount feature gate is enabled, "MountOption" is used.
   * If not specified and SELinuxMount feature gate is disabled, "MountOption" is used for ReadWriteOncePod volumes
   * and "Recursive" for all other volumes.
   *
   * This field affects only Pods that have SELinux label set, either in PodSecurityContext or in SecurityContext of all containers.
   *
   * All Pods that use the same volume should use the same seLinuxChangePolicy, otherwise some pods can get stuck in ContainerCreating state.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema TempoStackSpecTemplateQueryFrontendComponentPodSecurityContext#seLinuxChangePolicy
   */
  readonly seLinuxChangePolicy?: string;

  /**
   * The SELinux context to be applied to all containers.
   * If unspecified, the container runtime will allocate a random SELinux context for each
   * container.  May also be set in SecurityContext.  If set in
   * both SecurityContext and PodSecurityContext, the value specified in SecurityContext
   * takes precedence for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema TempoStackSpecTemplateQueryFrontendComponentPodSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: TempoStackSpecTemplateQueryFrontendComponentPodSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by the containers in this pod.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema TempoStackSpecTemplateQueryFrontendComponentPodSecurityContext#seccompProfile
   */
  readonly seccompProfile?: TempoStackSpecTemplateQueryFrontendComponentPodSecurityContextSeccompProfile;

  /**
   * A list of groups applied to the first process run in each container, in
   * addition to the container's primary GID and fsGroup (if specified).  If
   * the SupplementalGroupsPolicy feature is enabled, the
   * supplementalGroupsPolicy field determines whether these are in addition
   * to or instead of any group memberships defined in the container image.
   * If unspecified, no additional groups are added, though group memberships
   * defined in the container image may still be used, depending on the
   * supplementalGroupsPolicy field.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema TempoStackSpecTemplateQueryFrontendComponentPodSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * Defines how supplemental groups of the first container processes are calculated.
   * Valid values are "Merge" and "Strict". If not specified, "Merge" is used.
   * (Alpha) Using the field requires the SupplementalGroupsPolicy feature gate to be enabled
   * and the container runtime must implement support for this feature.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema TempoStackSpecTemplateQueryFrontendComponentPodSecurityContext#supplementalGroupsPolicy
   */
  readonly supplementalGroupsPolicy?: string;

  /**
   * Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported
   * sysctls (by the container runtime) might fail to launch.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema TempoStackSpecTemplateQueryFrontendComponentPodSecurityContext#sysctls
   */
  readonly sysctls?: TempoStackSpecTemplateQueryFrontendComponentPodSecurityContextSysctls[];

  /**
   * The Windows specific settings applied to all containers.
   * If unspecified, the options within a container's SecurityContext will be used.
   * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema TempoStackSpecTemplateQueryFrontendComponentPodSecurityContext#windowsOptions
   */
  readonly windowsOptions?: TempoStackSpecTemplateQueryFrontendComponentPodSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'TempoStackSpecTemplateQueryFrontendComponentPodSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateQueryFrontendComponentPodSecurityContext(obj: TempoStackSpecTemplateQueryFrontendComponentPodSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'appArmorProfile': toJson_TempoStackSpecTemplateQueryFrontendComponentPodSecurityContextAppArmorProfile(obj.appArmorProfile),
    'fsGroup': obj.fsGroup,
    'fsGroupChangePolicy': obj.fsGroupChangePolicy,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxChangePolicy': obj.seLinuxChangePolicy,
    'seLinuxOptions': toJson_TempoStackSpecTemplateQueryFrontendComponentPodSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_TempoStackSpecTemplateQueryFrontendComponentPodSecurityContextSeccompProfile(obj.seccompProfile),
    'supplementalGroups': obj.supplementalGroups?.map(y => y),
    'supplementalGroupsPolicy': obj.supplementalGroupsPolicy,
    'sysctls': obj.sysctls?.map(y => toJson_TempoStackSpecTemplateQueryFrontendComponentPodSecurityContextSysctls(y)),
    'windowsOptions': toJson_TempoStackSpecTemplateQueryFrontendComponentPodSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resources defines resources for this component, this will override the calculated resources derived from total
 *
 * @schema TempoStackSpecTemplateQueryFrontendComponentResources
 */
export interface TempoStackSpecTemplateQueryFrontendComponentResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema TempoStackSpecTemplateQueryFrontendComponentResources#claims
   */
  readonly claims?: TempoStackSpecTemplateQueryFrontendComponentResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema TempoStackSpecTemplateQueryFrontendComponentResources#limits
   */
  readonly limits?: { [key: string]: TempoStackSpecTemplateQueryFrontendComponentResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema TempoStackSpecTemplateQueryFrontendComponentResources#requests
   */
  readonly requests?: { [key: string]: TempoStackSpecTemplateQueryFrontendComponentResourcesRequests };

}

/**
 * Converts an object of type 'TempoStackSpecTemplateQueryFrontendComponentResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateQueryFrontendComponentResources(obj: TempoStackSpecTemplateQueryFrontendComponentResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claims': obj.claims?.map(y => toJson_TempoStackSpecTemplateQueryFrontendComponentResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema TempoStackSpecTemplateQueryFrontendComponentTolerations
 */
export interface TempoStackSpecTemplateQueryFrontendComponentTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema TempoStackSpecTemplateQueryFrontendComponentTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema TempoStackSpecTemplateQueryFrontendComponentTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema TempoStackSpecTemplateQueryFrontendComponentTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict). Zero and
   * negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema TempoStackSpecTemplateQueryFrontendComponentTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema TempoStackSpecTemplateQueryFrontendComponentTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'TempoStackSpecTemplateQueryFrontendComponentTolerations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateQueryFrontendComponentTolerations(obj: TempoStackSpecTemplateQueryFrontendComponentTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Authentication defines the options for the oauth proxy used to protect jaeger UI
 *
 * @schema TempoStackSpecTemplateQueryFrontendJaegerQueryAuthentication
 */
export interface TempoStackSpecTemplateQueryFrontendJaegerQueryAuthentication {
  /**
   * Defines if the authentication will be enabled for jaeger UI.
   *
   * @schema TempoStackSpecTemplateQueryFrontendJaegerQueryAuthentication#enabled
   */
  readonly enabled?: boolean;

  /**
   * Resources defines the compute resource requirements of the OAuth Proxy container.
   * The OAuth Proxy performs authentication and authorization of incoming requests to Jaeger UI when multi-tenancy is disabled.
   *
   * @schema TempoStackSpecTemplateQueryFrontendJaegerQueryAuthentication#resources
   */
  readonly resources?: TempoStackSpecTemplateQueryFrontendJaegerQueryAuthenticationResources;

  /**
   * SAR defines the SAR to be used in the oauth-proxy
   * default is "{"namespace": "<tempo_stack_namespace>", "resource": "pods", "verb": "get"}
   *
   * @schema TempoStackSpecTemplateQueryFrontendJaegerQueryAuthentication#sar
   */
  readonly sar?: string;

}

/**
 * Converts an object of type 'TempoStackSpecTemplateQueryFrontendJaegerQueryAuthentication' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateQueryFrontendJaegerQueryAuthentication(obj: TempoStackSpecTemplateQueryFrontendJaegerQueryAuthentication | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'resources': toJson_TempoStackSpecTemplateQueryFrontendJaegerQueryAuthenticationResources(obj.resources),
    'sar': obj.sar,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Ingress defines the options for the Jaeger Query ingress.
 *
 * @schema TempoStackSpecTemplateQueryFrontendJaegerQueryIngress
 */
export interface TempoStackSpecTemplateQueryFrontendJaegerQueryIngress {
  /**
   * Annotations defines the annotations of the Ingress object.
   *
   * @schema TempoStackSpecTemplateQueryFrontendJaegerQueryIngress#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Host defines the hostname of the Ingress object.
   *
   * @schema TempoStackSpecTemplateQueryFrontendJaegerQueryIngress#host
   */
  readonly host?: string;

  /**
   * IngressClassName defines the name of an IngressClass cluster resource.
   * Defines which ingress controller serves this ingress resource.
   *
   * @schema TempoStackSpecTemplateQueryFrontendJaegerQueryIngress#ingressClassName
   */
  readonly ingressClassName?: string;

  /**
   * Route defines the options for the OpenShift route.
   *
   * @schema TempoStackSpecTemplateQueryFrontendJaegerQueryIngress#route
   */
  readonly route?: TempoStackSpecTemplateQueryFrontendJaegerQueryIngressRoute;

  /**
   * Type defines the type of Ingress for the Jaeger Query UI.
   * Currently ingress, route and none are supported.
   *
   * @schema TempoStackSpecTemplateQueryFrontendJaegerQueryIngress#type
   */
  readonly type?: TempoStackSpecTemplateQueryFrontendJaegerQueryIngressType;

}

/**
 * Converts an object of type 'TempoStackSpecTemplateQueryFrontendJaegerQueryIngress' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateQueryFrontendJaegerQueryIngress(obj: TempoStackSpecTemplateQueryFrontendJaegerQueryIngress | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'host': obj.host,
    'ingressClassName': obj.ingressClassName,
    'route': toJson_TempoStackSpecTemplateQueryFrontendJaegerQueryIngressRoute(obj.route),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * MonitorTab defines the monitor tab configuration.
 *
 * @schema TempoStackSpecTemplateQueryFrontendJaegerQueryMonitorTab
 */
export interface TempoStackSpecTemplateQueryFrontendJaegerQueryMonitorTab {
  /**
   * Enabled enables the monitor tab in the Jaeger console.
   * The PrometheusEndpoint must be configured to enable this feature.
   *
   * @schema TempoStackSpecTemplateQueryFrontendJaegerQueryMonitorTab#enabled
   */
  readonly enabled?: boolean;

  /**
   * PrometheusEndpoint defines the endpoint to the Prometheus instance that contains the span rate, error, and duration (RED) metrics.
   * For instance on OpenShift this is set to https://thanos-querier.openshift-monitoring.svc.cluster.local:9091
   *
   * @schema TempoStackSpecTemplateQueryFrontendJaegerQueryMonitorTab#prometheusEndpoint
   */
  readonly prometheusEndpoint?: string;

  /**
   * REDMetricsNamespace defines the a prefix used retrieve span rate, error, and duration (RED) metrics.
   *
   * @schema TempoStackSpecTemplateQueryFrontendJaegerQueryMonitorTab#redMetricsNamespace
   */
  readonly redMetricsNamespace?: string;

}

/**
 * Converts an object of type 'TempoStackSpecTemplateQueryFrontendJaegerQueryMonitorTab' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateQueryFrontendJaegerQueryMonitorTab(obj: TempoStackSpecTemplateQueryFrontendJaegerQueryMonitorTab | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'prometheusEndpoint': obj.prometheusEndpoint,
    'redMetricsNamespace': obj.redMetricsNamespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resources defines resources for this component, this will override the calculated resources derived from total
 *
 * @schema TempoStackSpecTemplateQueryFrontendJaegerQueryResources
 */
export interface TempoStackSpecTemplateQueryFrontendJaegerQueryResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema TempoStackSpecTemplateQueryFrontendJaegerQueryResources#claims
   */
  readonly claims?: TempoStackSpecTemplateQueryFrontendJaegerQueryResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema TempoStackSpecTemplateQueryFrontendJaegerQueryResources#limits
   */
  readonly limits?: { [key: string]: TempoStackSpecTemplateQueryFrontendJaegerQueryResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema TempoStackSpecTemplateQueryFrontendJaegerQueryResources#requests
   */
  readonly requests?: { [key: string]: TempoStackSpecTemplateQueryFrontendJaegerQueryResourcesRequests };

}

/**
 * Converts an object of type 'TempoStackSpecTemplateQueryFrontendJaegerQueryResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateQueryFrontendJaegerQueryResources(obj: TempoStackSpecTemplateQueryFrontendJaegerQueryResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claims': obj.claims?.map(y => toJson_TempoStackSpecTemplateQueryFrontendJaegerQueryResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TempoQuery defines options specific to the Tempoo Query component.
 *
 * @schema TempoStackSpecTemplateQueryFrontendJaegerQueryTempoQuery
 */
export interface TempoStackSpecTemplateQueryFrontendJaegerQueryTempoQuery {
  /**
   * Resources defines resources for this component, this will override the calculated resources derived from total
   *
   * @schema TempoStackSpecTemplateQueryFrontendJaegerQueryTempoQuery#resources
   */
  readonly resources?: TempoStackSpecTemplateQueryFrontendJaegerQueryTempoQueryResources;

}

/**
 * Converts an object of type 'TempoStackSpecTemplateQueryFrontendJaegerQueryTempoQuery' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateQueryFrontendJaegerQueryTempoQuery(obj: TempoStackSpecTemplateQueryFrontendJaegerQueryTempoQuery | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resources': toJson_TempoStackSpecTemplateQueryFrontendJaegerQueryTempoQueryResources(obj.resources),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret defines the spec for the clientID, clientSecret and issuerCAPath for tenant's authentication.
 *
 * @schema TempoStackSpecTenantsAuthenticationOidcSecret
 */
export interface TempoStackSpecTenantsAuthenticationOidcSecret {
  /**
   * Name of a secret in the namespace configured for tenant secrets.
   *
   * @schema TempoStackSpecTenantsAuthenticationOidcSecret#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'TempoStackSpecTenantsAuthenticationOidcSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTenantsAuthenticationOidcSecret(obj: TempoStackSpecTenantsAuthenticationOidcSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Subject represents a subject that has been bound to a role.
 *
 * @schema TempoStackSpecTenantsAuthorizationRoleBindingsSubjects
 */
export interface TempoStackSpecTenantsAuthorizationRoleBindingsSubjects {
  /**
   * SubjectKind is a kind of Tempo Gateway RBAC subject.
   *
   * @schema TempoStackSpecTenantsAuthorizationRoleBindingsSubjects#kind
   */
  readonly kind: TempoStackSpecTenantsAuthorizationRoleBindingsSubjectsKind;

  /**
   * @schema TempoStackSpecTenantsAuthorizationRoleBindingsSubjects#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'TempoStackSpecTenantsAuthorizationRoleBindingsSubjects' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTenantsAuthorizationRoleBindingsSubjects(obj: TempoStackSpecTenantsAuthorizationRoleBindingsSubjects | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PermissionType is a Tempo Gateway RBAC permission.
 *
 * @schema TempoStackSpecTenantsAuthorizationRolesPermissions
 */
export enum TempoStackSpecTenantsAuthorizationRolesPermissions {
  /** read */
  READ = "read",
  /** write */
  WRITE = "write",
}

/**
 * appArmorProfile is the AppArmor options to use by the containers in this pod.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema TempoStackSpecTemplateDistributorComponentPodSecurityContextAppArmorProfile
 */
export interface TempoStackSpecTemplateDistributorComponentPodSecurityContextAppArmorProfile {
  /**
   * localhostProfile indicates a profile loaded on the node that should be used.
   * The profile must be preconfigured on the node to work.
   * Must match the loaded name of the profile.
   * Must be set if and only if type is "Localhost".
   *
   * @schema TempoStackSpecTemplateDistributorComponentPodSecurityContextAppArmorProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of AppArmor profile will be applied.
   * Valid options are:
   * Localhost - a profile pre-loaded on the node.
   * RuntimeDefault - the container runtime's default profile.
   * Unconfined - no AppArmor enforcement.
   *
   * @schema TempoStackSpecTemplateDistributorComponentPodSecurityContextAppArmorProfile#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'TempoStackSpecTemplateDistributorComponentPodSecurityContextAppArmorProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateDistributorComponentPodSecurityContextAppArmorProfile(obj: TempoStackSpecTemplateDistributorComponentPodSecurityContextAppArmorProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The SELinux context to be applied to all containers.
 * If unspecified, the container runtime will allocate a random SELinux context for each
 * container.  May also be set in SecurityContext.  If set in
 * both SecurityContext and PodSecurityContext, the value specified in SecurityContext
 * takes precedence for that container.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema TempoStackSpecTemplateDistributorComponentPodSecurityContextSeLinuxOptions
 */
export interface TempoStackSpecTemplateDistributorComponentPodSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema TempoStackSpecTemplateDistributorComponentPodSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema TempoStackSpecTemplateDistributorComponentPodSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema TempoStackSpecTemplateDistributorComponentPodSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema TempoStackSpecTemplateDistributorComponentPodSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'TempoStackSpecTemplateDistributorComponentPodSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateDistributorComponentPodSecurityContextSeLinuxOptions(obj: TempoStackSpecTemplateDistributorComponentPodSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The seccomp options to use by the containers in this pod.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema TempoStackSpecTemplateDistributorComponentPodSecurityContextSeccompProfile
 */
export interface TempoStackSpecTemplateDistributorComponentPodSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used.
   * The profile must be preconfigured on the node to work.
   * Must be a descending path, relative to the kubelet's configured seccomp profile location.
   * Must be set if type is "Localhost". Must NOT be set for any other type.
   *
   * @schema TempoStackSpecTemplateDistributorComponentPodSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied.
   * Valid options are:
   *
   * Localhost - a profile defined in a file on the node should be used.
   * RuntimeDefault - the container runtime default profile should be used.
   * Unconfined - no profile should be applied.
   *
   * @schema TempoStackSpecTemplateDistributorComponentPodSecurityContextSeccompProfile#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'TempoStackSpecTemplateDistributorComponentPodSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateDistributorComponentPodSecurityContextSeccompProfile(obj: TempoStackSpecTemplateDistributorComponentPodSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Sysctl defines a kernel parameter to be set
 *
 * @schema TempoStackSpecTemplateDistributorComponentPodSecurityContextSysctls
 */
export interface TempoStackSpecTemplateDistributorComponentPodSecurityContextSysctls {
  /**
   * Name of a property to set
   *
   * @schema TempoStackSpecTemplateDistributorComponentPodSecurityContextSysctls#name
   */
  readonly name: string;

  /**
   * Value of a property to set
   *
   * @schema TempoStackSpecTemplateDistributorComponentPodSecurityContextSysctls#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'TempoStackSpecTemplateDistributorComponentPodSecurityContextSysctls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateDistributorComponentPodSecurityContextSysctls(obj: TempoStackSpecTemplateDistributorComponentPodSecurityContextSysctls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Windows specific settings applied to all containers.
 * If unspecified, the options within a container's SecurityContext will be used.
 * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema TempoStackSpecTemplateDistributorComponentPodSecurityContextWindowsOptions
 */
export interface TempoStackSpecTemplateDistributorComponentPodSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook
   * (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
   * GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema TempoStackSpecTemplateDistributorComponentPodSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema TempoStackSpecTemplateDistributorComponentPodSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container.
   * All of a Pod's containers must have the same effective HostProcess value
   * (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
   * In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema TempoStackSpecTemplateDistributorComponentPodSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process.
   * Defaults to the user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext. If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified.
   * @schema TempoStackSpecTemplateDistributorComponentPodSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'TempoStackSpecTemplateDistributorComponentPodSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateDistributorComponentPodSecurityContextWindowsOptions(obj: TempoStackSpecTemplateDistributorComponentPodSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema TempoStackSpecTemplateDistributorComponentResourcesClaims
 */
export interface TempoStackSpecTemplateDistributorComponentResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema TempoStackSpecTemplateDistributorComponentResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema TempoStackSpecTemplateDistributorComponentResourcesClaims#request
   */
  readonly request?: string;

}

/**
 * Converts an object of type 'TempoStackSpecTemplateDistributorComponentResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateDistributorComponentResourcesClaims(obj: TempoStackSpecTemplateDistributorComponentResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'request': obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TempoStackSpecTemplateDistributorComponentResourcesLimits
 */
export class TempoStackSpecTemplateDistributorComponentResourcesLimits {
  public static fromNumber(value: number): TempoStackSpecTemplateDistributorComponentResourcesLimits {
    return new TempoStackSpecTemplateDistributorComponentResourcesLimits(value);
  }
  public static fromString(value: string): TempoStackSpecTemplateDistributorComponentResourcesLimits {
    return new TempoStackSpecTemplateDistributorComponentResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema TempoStackSpecTemplateDistributorComponentResourcesRequests
 */
export class TempoStackSpecTemplateDistributorComponentResourcesRequests {
  public static fromNumber(value: number): TempoStackSpecTemplateDistributorComponentResourcesRequests {
    return new TempoStackSpecTemplateDistributorComponentResourcesRequests(value);
  }
  public static fromString(value: string): TempoStackSpecTemplateDistributorComponentResourcesRequests {
    return new TempoStackSpecTemplateDistributorComponentResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * appArmorProfile is the AppArmor options to use by the containers in this pod.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema TempoStackSpecTemplateGatewayComponentPodSecurityContextAppArmorProfile
 */
export interface TempoStackSpecTemplateGatewayComponentPodSecurityContextAppArmorProfile {
  /**
   * localhostProfile indicates a profile loaded on the node that should be used.
   * The profile must be preconfigured on the node to work.
   * Must match the loaded name of the profile.
   * Must be set if and only if type is "Localhost".
   *
   * @schema TempoStackSpecTemplateGatewayComponentPodSecurityContextAppArmorProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of AppArmor profile will be applied.
   * Valid options are:
   * Localhost - a profile pre-loaded on the node.
   * RuntimeDefault - the container runtime's default profile.
   * Unconfined - no AppArmor enforcement.
   *
   * @schema TempoStackSpecTemplateGatewayComponentPodSecurityContextAppArmorProfile#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'TempoStackSpecTemplateGatewayComponentPodSecurityContextAppArmorProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateGatewayComponentPodSecurityContextAppArmorProfile(obj: TempoStackSpecTemplateGatewayComponentPodSecurityContextAppArmorProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The SELinux context to be applied to all containers.
 * If unspecified, the container runtime will allocate a random SELinux context for each
 * container.  May also be set in SecurityContext.  If set in
 * both SecurityContext and PodSecurityContext, the value specified in SecurityContext
 * takes precedence for that container.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema TempoStackSpecTemplateGatewayComponentPodSecurityContextSeLinuxOptions
 */
export interface TempoStackSpecTemplateGatewayComponentPodSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema TempoStackSpecTemplateGatewayComponentPodSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema TempoStackSpecTemplateGatewayComponentPodSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema TempoStackSpecTemplateGatewayComponentPodSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema TempoStackSpecTemplateGatewayComponentPodSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'TempoStackSpecTemplateGatewayComponentPodSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateGatewayComponentPodSecurityContextSeLinuxOptions(obj: TempoStackSpecTemplateGatewayComponentPodSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The seccomp options to use by the containers in this pod.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema TempoStackSpecTemplateGatewayComponentPodSecurityContextSeccompProfile
 */
export interface TempoStackSpecTemplateGatewayComponentPodSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used.
   * The profile must be preconfigured on the node to work.
   * Must be a descending path, relative to the kubelet's configured seccomp profile location.
   * Must be set if type is "Localhost". Must NOT be set for any other type.
   *
   * @schema TempoStackSpecTemplateGatewayComponentPodSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied.
   * Valid options are:
   *
   * Localhost - a profile defined in a file on the node should be used.
   * RuntimeDefault - the container runtime default profile should be used.
   * Unconfined - no profile should be applied.
   *
   * @schema TempoStackSpecTemplateGatewayComponentPodSecurityContextSeccompProfile#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'TempoStackSpecTemplateGatewayComponentPodSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateGatewayComponentPodSecurityContextSeccompProfile(obj: TempoStackSpecTemplateGatewayComponentPodSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Sysctl defines a kernel parameter to be set
 *
 * @schema TempoStackSpecTemplateGatewayComponentPodSecurityContextSysctls
 */
export interface TempoStackSpecTemplateGatewayComponentPodSecurityContextSysctls {
  /**
   * Name of a property to set
   *
   * @schema TempoStackSpecTemplateGatewayComponentPodSecurityContextSysctls#name
   */
  readonly name: string;

  /**
   * Value of a property to set
   *
   * @schema TempoStackSpecTemplateGatewayComponentPodSecurityContextSysctls#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'TempoStackSpecTemplateGatewayComponentPodSecurityContextSysctls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateGatewayComponentPodSecurityContextSysctls(obj: TempoStackSpecTemplateGatewayComponentPodSecurityContextSysctls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Windows specific settings applied to all containers.
 * If unspecified, the options within a container's SecurityContext will be used.
 * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema TempoStackSpecTemplateGatewayComponentPodSecurityContextWindowsOptions
 */
export interface TempoStackSpecTemplateGatewayComponentPodSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook
   * (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
   * GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema TempoStackSpecTemplateGatewayComponentPodSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema TempoStackSpecTemplateGatewayComponentPodSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container.
   * All of a Pod's containers must have the same effective HostProcess value
   * (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
   * In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema TempoStackSpecTemplateGatewayComponentPodSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process.
   * Defaults to the user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext. If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified.
   * @schema TempoStackSpecTemplateGatewayComponentPodSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'TempoStackSpecTemplateGatewayComponentPodSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateGatewayComponentPodSecurityContextWindowsOptions(obj: TempoStackSpecTemplateGatewayComponentPodSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema TempoStackSpecTemplateGatewayComponentResourcesClaims
 */
export interface TempoStackSpecTemplateGatewayComponentResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema TempoStackSpecTemplateGatewayComponentResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema TempoStackSpecTemplateGatewayComponentResourcesClaims#request
   */
  readonly request?: string;

}

/**
 * Converts an object of type 'TempoStackSpecTemplateGatewayComponentResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateGatewayComponentResourcesClaims(obj: TempoStackSpecTemplateGatewayComponentResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'request': obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TempoStackSpecTemplateGatewayComponentResourcesLimits
 */
export class TempoStackSpecTemplateGatewayComponentResourcesLimits {
  public static fromNumber(value: number): TempoStackSpecTemplateGatewayComponentResourcesLimits {
    return new TempoStackSpecTemplateGatewayComponentResourcesLimits(value);
  }
  public static fromString(value: string): TempoStackSpecTemplateGatewayComponentResourcesLimits {
    return new TempoStackSpecTemplateGatewayComponentResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema TempoStackSpecTemplateGatewayComponentResourcesRequests
 */
export class TempoStackSpecTemplateGatewayComponentResourcesRequests {
  public static fromNumber(value: number): TempoStackSpecTemplateGatewayComponentResourcesRequests {
    return new TempoStackSpecTemplateGatewayComponentResourcesRequests(value);
  }
  public static fromString(value: string): TempoStackSpecTemplateGatewayComponentResourcesRequests {
    return new TempoStackSpecTemplateGatewayComponentResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Termination defines the termination type.
 * The default is "edge".
 *
 * @schema TempoStackSpecTemplateGatewayIngressRouteTermination
 */
export enum TempoStackSpecTemplateGatewayIngressRouteTermination {
  /** insecure */
  INSECURE = "insecure",
  /** edge */
  EDGE = "edge",
  /** passthrough */
  PASSTHROUGH = "passthrough",
  /** reencrypt */
  REENCRYPT = "reencrypt",
}

/**
 * appArmorProfile is the AppArmor options to use by the containers in this pod.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema TempoStackSpecTemplateQueryFrontendComponentPodSecurityContextAppArmorProfile
 */
export interface TempoStackSpecTemplateQueryFrontendComponentPodSecurityContextAppArmorProfile {
  /**
   * localhostProfile indicates a profile loaded on the node that should be used.
   * The profile must be preconfigured on the node to work.
   * Must match the loaded name of the profile.
   * Must be set if and only if type is "Localhost".
   *
   * @schema TempoStackSpecTemplateQueryFrontendComponentPodSecurityContextAppArmorProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of AppArmor profile will be applied.
   * Valid options are:
   * Localhost - a profile pre-loaded on the node.
   * RuntimeDefault - the container runtime's default profile.
   * Unconfined - no AppArmor enforcement.
   *
   * @schema TempoStackSpecTemplateQueryFrontendComponentPodSecurityContextAppArmorProfile#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'TempoStackSpecTemplateQueryFrontendComponentPodSecurityContextAppArmorProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateQueryFrontendComponentPodSecurityContextAppArmorProfile(obj: TempoStackSpecTemplateQueryFrontendComponentPodSecurityContextAppArmorProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The SELinux context to be applied to all containers.
 * If unspecified, the container runtime will allocate a random SELinux context for each
 * container.  May also be set in SecurityContext.  If set in
 * both SecurityContext and PodSecurityContext, the value specified in SecurityContext
 * takes precedence for that container.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema TempoStackSpecTemplateQueryFrontendComponentPodSecurityContextSeLinuxOptions
 */
export interface TempoStackSpecTemplateQueryFrontendComponentPodSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema TempoStackSpecTemplateQueryFrontendComponentPodSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema TempoStackSpecTemplateQueryFrontendComponentPodSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema TempoStackSpecTemplateQueryFrontendComponentPodSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema TempoStackSpecTemplateQueryFrontendComponentPodSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'TempoStackSpecTemplateQueryFrontendComponentPodSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateQueryFrontendComponentPodSecurityContextSeLinuxOptions(obj: TempoStackSpecTemplateQueryFrontendComponentPodSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The seccomp options to use by the containers in this pod.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema TempoStackSpecTemplateQueryFrontendComponentPodSecurityContextSeccompProfile
 */
export interface TempoStackSpecTemplateQueryFrontendComponentPodSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used.
   * The profile must be preconfigured on the node to work.
   * Must be a descending path, relative to the kubelet's configured seccomp profile location.
   * Must be set if type is "Localhost". Must NOT be set for any other type.
   *
   * @schema TempoStackSpecTemplateQueryFrontendComponentPodSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied.
   * Valid options are:
   *
   * Localhost - a profile defined in a file on the node should be used.
   * RuntimeDefault - the container runtime default profile should be used.
   * Unconfined - no profile should be applied.
   *
   * @schema TempoStackSpecTemplateQueryFrontendComponentPodSecurityContextSeccompProfile#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'TempoStackSpecTemplateQueryFrontendComponentPodSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateQueryFrontendComponentPodSecurityContextSeccompProfile(obj: TempoStackSpecTemplateQueryFrontendComponentPodSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Sysctl defines a kernel parameter to be set
 *
 * @schema TempoStackSpecTemplateQueryFrontendComponentPodSecurityContextSysctls
 */
export interface TempoStackSpecTemplateQueryFrontendComponentPodSecurityContextSysctls {
  /**
   * Name of a property to set
   *
   * @schema TempoStackSpecTemplateQueryFrontendComponentPodSecurityContextSysctls#name
   */
  readonly name: string;

  /**
   * Value of a property to set
   *
   * @schema TempoStackSpecTemplateQueryFrontendComponentPodSecurityContextSysctls#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'TempoStackSpecTemplateQueryFrontendComponentPodSecurityContextSysctls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateQueryFrontendComponentPodSecurityContextSysctls(obj: TempoStackSpecTemplateQueryFrontendComponentPodSecurityContextSysctls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Windows specific settings applied to all containers.
 * If unspecified, the options within a container's SecurityContext will be used.
 * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema TempoStackSpecTemplateQueryFrontendComponentPodSecurityContextWindowsOptions
 */
export interface TempoStackSpecTemplateQueryFrontendComponentPodSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook
   * (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
   * GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema TempoStackSpecTemplateQueryFrontendComponentPodSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema TempoStackSpecTemplateQueryFrontendComponentPodSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container.
   * All of a Pod's containers must have the same effective HostProcess value
   * (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
   * In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema TempoStackSpecTemplateQueryFrontendComponentPodSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process.
   * Defaults to the user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext. If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified.
   * @schema TempoStackSpecTemplateQueryFrontendComponentPodSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'TempoStackSpecTemplateQueryFrontendComponentPodSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateQueryFrontendComponentPodSecurityContextWindowsOptions(obj: TempoStackSpecTemplateQueryFrontendComponentPodSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema TempoStackSpecTemplateQueryFrontendComponentResourcesClaims
 */
export interface TempoStackSpecTemplateQueryFrontendComponentResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema TempoStackSpecTemplateQueryFrontendComponentResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema TempoStackSpecTemplateQueryFrontendComponentResourcesClaims#request
   */
  readonly request?: string;

}

/**
 * Converts an object of type 'TempoStackSpecTemplateQueryFrontendComponentResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateQueryFrontendComponentResourcesClaims(obj: TempoStackSpecTemplateQueryFrontendComponentResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'request': obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TempoStackSpecTemplateQueryFrontendComponentResourcesLimits
 */
export class TempoStackSpecTemplateQueryFrontendComponentResourcesLimits {
  public static fromNumber(value: number): TempoStackSpecTemplateQueryFrontendComponentResourcesLimits {
    return new TempoStackSpecTemplateQueryFrontendComponentResourcesLimits(value);
  }
  public static fromString(value: string): TempoStackSpecTemplateQueryFrontendComponentResourcesLimits {
    return new TempoStackSpecTemplateQueryFrontendComponentResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema TempoStackSpecTemplateQueryFrontendComponentResourcesRequests
 */
export class TempoStackSpecTemplateQueryFrontendComponentResourcesRequests {
  public static fromNumber(value: number): TempoStackSpecTemplateQueryFrontendComponentResourcesRequests {
    return new TempoStackSpecTemplateQueryFrontendComponentResourcesRequests(value);
  }
  public static fromString(value: string): TempoStackSpecTemplateQueryFrontendComponentResourcesRequests {
    return new TempoStackSpecTemplateQueryFrontendComponentResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Resources defines the compute resource requirements of the OAuth Proxy container.
 * The OAuth Proxy performs authentication and authorization of incoming requests to Jaeger UI when multi-tenancy is disabled.
 *
 * @schema TempoStackSpecTemplateQueryFrontendJaegerQueryAuthenticationResources
 */
export interface TempoStackSpecTemplateQueryFrontendJaegerQueryAuthenticationResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema TempoStackSpecTemplateQueryFrontendJaegerQueryAuthenticationResources#claims
   */
  readonly claims?: TempoStackSpecTemplateQueryFrontendJaegerQueryAuthenticationResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema TempoStackSpecTemplateQueryFrontendJaegerQueryAuthenticationResources#limits
   */
  readonly limits?: { [key: string]: TempoStackSpecTemplateQueryFrontendJaegerQueryAuthenticationResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema TempoStackSpecTemplateQueryFrontendJaegerQueryAuthenticationResources#requests
   */
  readonly requests?: { [key: string]: TempoStackSpecTemplateQueryFrontendJaegerQueryAuthenticationResourcesRequests };

}

/**
 * Converts an object of type 'TempoStackSpecTemplateQueryFrontendJaegerQueryAuthenticationResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateQueryFrontendJaegerQueryAuthenticationResources(obj: TempoStackSpecTemplateQueryFrontendJaegerQueryAuthenticationResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claims': obj.claims?.map(y => toJson_TempoStackSpecTemplateQueryFrontendJaegerQueryAuthenticationResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Route defines the options for the OpenShift route.
 *
 * @schema TempoStackSpecTemplateQueryFrontendJaegerQueryIngressRoute
 */
export interface TempoStackSpecTemplateQueryFrontendJaegerQueryIngressRoute {
  /**
   * Termination defines the termination type.
   * The default is "edge".
   *
   * @schema TempoStackSpecTemplateQueryFrontendJaegerQueryIngressRoute#termination
   */
  readonly termination?: TempoStackSpecTemplateQueryFrontendJaegerQueryIngressRouteTermination;

}

/**
 * Converts an object of type 'TempoStackSpecTemplateQueryFrontendJaegerQueryIngressRoute' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateQueryFrontendJaegerQueryIngressRoute(obj: TempoStackSpecTemplateQueryFrontendJaegerQueryIngressRoute | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'termination': obj.termination,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Type defines the type of Ingress for the Jaeger Query UI.
 * Currently ingress, route and none are supported.
 *
 * @schema TempoStackSpecTemplateQueryFrontendJaegerQueryIngressType
 */
export enum TempoStackSpecTemplateQueryFrontendJaegerQueryIngressType {
  /** ingress */
  INGRESS = "ingress",
  /** route */
  ROUTE = "route",
}

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema TempoStackSpecTemplateQueryFrontendJaegerQueryResourcesClaims
 */
export interface TempoStackSpecTemplateQueryFrontendJaegerQueryResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema TempoStackSpecTemplateQueryFrontendJaegerQueryResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema TempoStackSpecTemplateQueryFrontendJaegerQueryResourcesClaims#request
   */
  readonly request?: string;

}

/**
 * Converts an object of type 'TempoStackSpecTemplateQueryFrontendJaegerQueryResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateQueryFrontendJaegerQueryResourcesClaims(obj: TempoStackSpecTemplateQueryFrontendJaegerQueryResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'request': obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TempoStackSpecTemplateQueryFrontendJaegerQueryResourcesLimits
 */
export class TempoStackSpecTemplateQueryFrontendJaegerQueryResourcesLimits {
  public static fromNumber(value: number): TempoStackSpecTemplateQueryFrontendJaegerQueryResourcesLimits {
    return new TempoStackSpecTemplateQueryFrontendJaegerQueryResourcesLimits(value);
  }
  public static fromString(value: string): TempoStackSpecTemplateQueryFrontendJaegerQueryResourcesLimits {
    return new TempoStackSpecTemplateQueryFrontendJaegerQueryResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema TempoStackSpecTemplateQueryFrontendJaegerQueryResourcesRequests
 */
export class TempoStackSpecTemplateQueryFrontendJaegerQueryResourcesRequests {
  public static fromNumber(value: number): TempoStackSpecTemplateQueryFrontendJaegerQueryResourcesRequests {
    return new TempoStackSpecTemplateQueryFrontendJaegerQueryResourcesRequests(value);
  }
  public static fromString(value: string): TempoStackSpecTemplateQueryFrontendJaegerQueryResourcesRequests {
    return new TempoStackSpecTemplateQueryFrontendJaegerQueryResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Resources defines resources for this component, this will override the calculated resources derived from total
 *
 * @schema TempoStackSpecTemplateQueryFrontendJaegerQueryTempoQueryResources
 */
export interface TempoStackSpecTemplateQueryFrontendJaegerQueryTempoQueryResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema TempoStackSpecTemplateQueryFrontendJaegerQueryTempoQueryResources#claims
   */
  readonly claims?: TempoStackSpecTemplateQueryFrontendJaegerQueryTempoQueryResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema TempoStackSpecTemplateQueryFrontendJaegerQueryTempoQueryResources#limits
   */
  readonly limits?: { [key: string]: TempoStackSpecTemplateQueryFrontendJaegerQueryTempoQueryResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema TempoStackSpecTemplateQueryFrontendJaegerQueryTempoQueryResources#requests
   */
  readonly requests?: { [key: string]: TempoStackSpecTemplateQueryFrontendJaegerQueryTempoQueryResourcesRequests };

}

/**
 * Converts an object of type 'TempoStackSpecTemplateQueryFrontendJaegerQueryTempoQueryResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateQueryFrontendJaegerQueryTempoQueryResources(obj: TempoStackSpecTemplateQueryFrontendJaegerQueryTempoQueryResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claims': obj.claims?.map(y => toJson_TempoStackSpecTemplateQueryFrontendJaegerQueryTempoQueryResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SubjectKind is a kind of Tempo Gateway RBAC subject.
 *
 * @schema TempoStackSpecTenantsAuthorizationRoleBindingsSubjectsKind
 */
export enum TempoStackSpecTenantsAuthorizationRoleBindingsSubjectsKind {
  /** user */
  USER = "user",
  /** group */
  GROUP = "group",
}

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema TempoStackSpecTemplateQueryFrontendJaegerQueryAuthenticationResourcesClaims
 */
export interface TempoStackSpecTemplateQueryFrontendJaegerQueryAuthenticationResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema TempoStackSpecTemplateQueryFrontendJaegerQueryAuthenticationResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema TempoStackSpecTemplateQueryFrontendJaegerQueryAuthenticationResourcesClaims#request
   */
  readonly request?: string;

}

/**
 * Converts an object of type 'TempoStackSpecTemplateQueryFrontendJaegerQueryAuthenticationResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateQueryFrontendJaegerQueryAuthenticationResourcesClaims(obj: TempoStackSpecTemplateQueryFrontendJaegerQueryAuthenticationResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'request': obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TempoStackSpecTemplateQueryFrontendJaegerQueryAuthenticationResourcesLimits
 */
export class TempoStackSpecTemplateQueryFrontendJaegerQueryAuthenticationResourcesLimits {
  public static fromNumber(value: number): TempoStackSpecTemplateQueryFrontendJaegerQueryAuthenticationResourcesLimits {
    return new TempoStackSpecTemplateQueryFrontendJaegerQueryAuthenticationResourcesLimits(value);
  }
  public static fromString(value: string): TempoStackSpecTemplateQueryFrontendJaegerQueryAuthenticationResourcesLimits {
    return new TempoStackSpecTemplateQueryFrontendJaegerQueryAuthenticationResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema TempoStackSpecTemplateQueryFrontendJaegerQueryAuthenticationResourcesRequests
 */
export class TempoStackSpecTemplateQueryFrontendJaegerQueryAuthenticationResourcesRequests {
  public static fromNumber(value: number): TempoStackSpecTemplateQueryFrontendJaegerQueryAuthenticationResourcesRequests {
    return new TempoStackSpecTemplateQueryFrontendJaegerQueryAuthenticationResourcesRequests(value);
  }
  public static fromString(value: string): TempoStackSpecTemplateQueryFrontendJaegerQueryAuthenticationResourcesRequests {
    return new TempoStackSpecTemplateQueryFrontendJaegerQueryAuthenticationResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Termination defines the termination type.
 * The default is "edge".
 *
 * @schema TempoStackSpecTemplateQueryFrontendJaegerQueryIngressRouteTermination
 */
export enum TempoStackSpecTemplateQueryFrontendJaegerQueryIngressRouteTermination {
  /** insecure */
  INSECURE = "insecure",
  /** edge */
  EDGE = "edge",
  /** passthrough */
  PASSTHROUGH = "passthrough",
  /** reencrypt */
  REENCRYPT = "reencrypt",
}

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema TempoStackSpecTemplateQueryFrontendJaegerQueryTempoQueryResourcesClaims
 */
export interface TempoStackSpecTemplateQueryFrontendJaegerQueryTempoQueryResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema TempoStackSpecTemplateQueryFrontendJaegerQueryTempoQueryResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema TempoStackSpecTemplateQueryFrontendJaegerQueryTempoQueryResourcesClaims#request
   */
  readonly request?: string;

}

/**
 * Converts an object of type 'TempoStackSpecTemplateQueryFrontendJaegerQueryTempoQueryResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TempoStackSpecTemplateQueryFrontendJaegerQueryTempoQueryResourcesClaims(obj: TempoStackSpecTemplateQueryFrontendJaegerQueryTempoQueryResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'request': obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TempoStackSpecTemplateQueryFrontendJaegerQueryTempoQueryResourcesLimits
 */
export class TempoStackSpecTemplateQueryFrontendJaegerQueryTempoQueryResourcesLimits {
  public static fromNumber(value: number): TempoStackSpecTemplateQueryFrontendJaegerQueryTempoQueryResourcesLimits {
    return new TempoStackSpecTemplateQueryFrontendJaegerQueryTempoQueryResourcesLimits(value);
  }
  public static fromString(value: string): TempoStackSpecTemplateQueryFrontendJaegerQueryTempoQueryResourcesLimits {
    return new TempoStackSpecTemplateQueryFrontendJaegerQueryTempoQueryResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema TempoStackSpecTemplateQueryFrontendJaegerQueryTempoQueryResourcesRequests
 */
export class TempoStackSpecTemplateQueryFrontendJaegerQueryTempoQueryResourcesRequests {
  public static fromNumber(value: number): TempoStackSpecTemplateQueryFrontendJaegerQueryTempoQueryResourcesRequests {
    return new TempoStackSpecTemplateQueryFrontendJaegerQueryTempoQueryResourcesRequests(value);
  }
  public static fromString(value: string): TempoStackSpecTemplateQueryFrontendJaegerQueryTempoQueryResourcesRequests {
    return new TempoStackSpecTemplateQueryFrontendJaegerQueryTempoQueryResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

