// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * ScrapeConfig defines a namespaced Prometheus scrape_config to be aggregated across
multiple namespaces into the Prometheus configuration.
 *
 * @schema ScrapeConfig
 */
export class ScrapeConfig extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ScrapeConfig"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'monitoring.coreos.com/v1alpha1',
    kind: 'ScrapeConfig',
  }

  /**
   * Renders a Kubernetes manifest for "ScrapeConfig".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ScrapeConfigProps): any {
    return {
      ...ScrapeConfig.GVK,
      ...toJson_ScrapeConfigProps(props),
    };
  }

  /**
   * Defines a "ScrapeConfig" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ScrapeConfigProps) {
    super(scope, id, {
      ...ScrapeConfig.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ScrapeConfig.GVK,
      ...toJson_ScrapeConfigProps(resolved),
    };
  }
}

/**
 * ScrapeConfig defines a namespaced Prometheus scrape_config to be aggregated across
 * multiple namespaces into the Prometheus configuration.
 *
 * @schema ScrapeConfig
 */
export interface ScrapeConfigProps {
  /**
   * @schema ScrapeConfig#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ScrapeConfigSpec is a specification of the desired configuration for a scrape configuration.
   *
   * @schema ScrapeConfig#spec
   */
  readonly spec: ScrapeConfigSpec;

}

/**
 * Converts an object of type 'ScrapeConfigProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigProps(obj: ScrapeConfigProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ScrapeConfigSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ScrapeConfigSpec is a specification of the desired configuration for a scrape configuration.
 *
 * @schema ScrapeConfigSpec
 */
export interface ScrapeConfigSpec {
  /**
   * NomadSDConfigs defines a list of Nomad service discovery configurations.
   *
   * @schema ScrapeConfigSpec#NomadSDConfigs
   */
  readonly nomadSdConfigs?: ScrapeConfigSpecNomadSdConfigs[];

  /**
   * Authorization header to use on every scrape request.
   *
   * @schema ScrapeConfigSpec#authorization
   */
  readonly authorization?: ScrapeConfigSpecAuthorization;

  /**
   * AzureSDConfigs defines a list of Azure service discovery configurations.
   *
   * @schema ScrapeConfigSpec#azureSDConfigs
   */
  readonly azureSdConfigs?: ScrapeConfigSpecAzureSdConfigs[];

  /**
   * BasicAuth information to use on every scrape request.
   *
   * @schema ScrapeConfigSpec#basicAuth
   */
  readonly basicAuth?: ScrapeConfigSpecBasicAuth;

  /**
   * ConsulSDConfigs defines a list of Consul service discovery configurations.
   *
   * @schema ScrapeConfigSpec#consulSDConfigs
   */
  readonly consulSdConfigs?: ScrapeConfigSpecConsulSdConfigs[];

  /**
   * DigitalOceanSDConfigs defines a list of DigitalOcean service discovery configurations.
   *
   * @schema ScrapeConfigSpec#digitalOceanSDConfigs
   */
  readonly digitalOceanSdConfigs?: ScrapeConfigSpecDigitalOceanSdConfigs[];

  /**
   * DNSSDConfigs defines a list of DNS service discovery configurations.
   *
   * @schema ScrapeConfigSpec#dnsSDConfigs
   */
  readonly dnsSdConfigs?: ScrapeConfigSpecDnsSdConfigs[];

  /**
   * DockerSDConfigs defines a list of Docker service discovery configurations.
   *
   * @schema ScrapeConfigSpec#dockerSDConfigs
   */
  readonly dockerSdConfigs?: ScrapeConfigSpecDockerSdConfigs[];

  /**
   * EC2SDConfigs defines a list of EC2 service discovery configurations.
   *
   * @schema ScrapeConfigSpec#ec2SDConfigs
   */
  readonly ec2SdConfigs?: ScrapeConfigSpecEc2SdConfigs[];

  /**
   * When false, Prometheus will request uncompressed response from the scraped target.
   *
   *
   * It requires Prometheus >= v2.49.0.
   *
   *
   * If unset, Prometheus uses true by default.
   *
   * @schema ScrapeConfigSpec#enableCompression
   */
  readonly enableCompression?: boolean;

  /**
   * EurekaSDConfigs defines a list of Eureka service discovery configurations.
   *
   * @schema ScrapeConfigSpec#eurekaSDConfigs
   */
  readonly eurekaSdConfigs?: ScrapeConfigSpecEurekaSdConfigs[];

  /**
   * FileSDConfigs defines a list of file service discovery configurations.
   *
   * @schema ScrapeConfigSpec#fileSDConfigs
   */
  readonly fileSdConfigs?: ScrapeConfigSpecFileSdConfigs[];

  /**
   * GCESDConfigs defines a list of GCE service discovery configurations.
   *
   * @schema ScrapeConfigSpec#gceSDConfigs
   */
  readonly gceSdConfigs?: ScrapeConfigSpecGceSdConfigs[];

  /**
   * HetznerSDConfigs defines a list of Hetzner service discovery configurations.
   *
   * @schema ScrapeConfigSpec#hetznerSDConfigs
   */
  readonly hetznerSdConfigs?: ScrapeConfigSpecHetznerSdConfigs[];

  /**
   * HonorLabels chooses the metric's labels on collisions with target labels.
   *
   * @schema ScrapeConfigSpec#honorLabels
   */
  readonly honorLabels?: boolean;

  /**
   * HonorTimestamps controls whether Prometheus respects the timestamps present in scraped data.
   *
   * @schema ScrapeConfigSpec#honorTimestamps
   */
  readonly honorTimestamps?: boolean;

  /**
   * HTTPSDConfigs defines a list of HTTP service discovery configurations.
   *
   * @schema ScrapeConfigSpec#httpSDConfigs
   */
  readonly httpSdConfigs?: ScrapeConfigSpecHttpSdConfigs[];

  /**
   * Per-scrape limit on the number of targets dropped by relabeling
   * that will be kept in memory. 0 means no limit.
   *
   *
   * It requires Prometheus >= v2.47.0.
   *
   * @schema ScrapeConfigSpec#keepDroppedTargets
   */
  readonly keepDroppedTargets?: number;

  /**
   * KubernetesSDConfigs defines a list of Kubernetes service discovery configurations.
   *
   * @schema ScrapeConfigSpec#kubernetesSDConfigs
   */
  readonly kubernetesSdConfigs?: ScrapeConfigSpecKubernetesSdConfigs[];

  /**
   * KumaSDConfigs defines a list of Kuma service discovery configurations.
   *
   * @schema ScrapeConfigSpec#kumaSDConfigs
   */
  readonly kumaSdConfigs?: ScrapeConfigSpecKumaSdConfigs[];

  /**
   * Per-scrape limit on number of labels that will be accepted for a sample.
   * Only valid in Prometheus versions 2.27.0 and newer.
   *
   * @schema ScrapeConfigSpec#labelLimit
   */
  readonly labelLimit?: number;

  /**
   * Per-scrape limit on length of labels name that will be accepted for a sample.
   * Only valid in Prometheus versions 2.27.0 and newer.
   *
   * @schema ScrapeConfigSpec#labelNameLengthLimit
   */
  readonly labelNameLengthLimit?: number;

  /**
   * Per-scrape limit on length of labels value that will be accepted for a sample.
   * Only valid in Prometheus versions 2.27.0 and newer.
   *
   * @schema ScrapeConfigSpec#labelValueLengthLimit
   */
  readonly labelValueLengthLimit?: number;

  /**
   * MetricRelabelConfigs to apply to samples before ingestion.
   *
   * @schema ScrapeConfigSpec#metricRelabelings
   */
  readonly metricRelabelings?: ScrapeConfigSpecMetricRelabelings[];

  /**
   * MetricsPath HTTP path to scrape for metrics. If empty, Prometheus uses the default value (e.g. /metrics).
   *
   * @schema ScrapeConfigSpec#metricsPath
   */
  readonly metricsPath?: string;

  /**
   * `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names
   * that should be excluded from proxying. IP and domain names can
   * contain port numbers.
   *
   *
   * It requires Prometheus >= v2.43.0.
   *
   * @schema ScrapeConfigSpec#noProxy
   */
  readonly noProxy?: string;

  /**
   * OpenStackSDConfigs defines a list of OpenStack service discovery configurations.
   *
   * @schema ScrapeConfigSpec#openstackSDConfigs
   */
  readonly openstackSdConfigs?: ScrapeConfigSpecOpenstackSdConfigs[];

  /**
   * Optional HTTP URL parameters
   *
   * @schema ScrapeConfigSpec#params
   */
  readonly params?: { [key: string]: string[] };

  /**
   * ProxyConnectHeader optionally specifies headers to send to
   * proxies during CONNECT requests.
   *
   *
   * It requires Prometheus >= v2.43.0.
   *
   * @schema ScrapeConfigSpec#proxyConnectHeader
   */
  readonly proxyConnectHeader?: { [key: string]: ScrapeConfigSpecProxyConnectHeader[] };

  /**
   * Whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
   * If unset, Prometheus uses its default value.
   *
   *
   * It requires Prometheus >= v2.43.0.
   *
   * @schema ScrapeConfigSpec#proxyFromEnvironment
   */
  readonly proxyFromEnvironment?: boolean;

  /**
   * `proxyURL` defines the HTTP proxy server to use.
   *
   *
   * It requires Prometheus >= v2.43.0.
   *
   * @schema ScrapeConfigSpec#proxyUrl
   */
  readonly proxyUrl?: string;

  /**
   * RelabelConfigs defines how to rewrite the target's labels before scraping.
   * Prometheus Operator automatically adds relabelings for a few standard Kubernetes fields.
   * The original scrape job's name is available via the `__tmp_prometheus_job_name` label.
   * More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
   *
   * @schema ScrapeConfigSpec#relabelings
   */
  readonly relabelings?: ScrapeConfigSpecRelabelings[];

  /**
   * SampleLimit defines per-scrape limit on number of scraped samples that will be accepted.
   *
   * @schema ScrapeConfigSpec#sampleLimit
   */
  readonly sampleLimit?: number;

  /**
   * Configures the protocol scheme used for requests.
   * If empty, Prometheus uses HTTP by default.
   *
   * @schema ScrapeConfigSpec#scheme
   */
  readonly scheme?: ScrapeConfigSpecScheme;

  /**
   * The scrape class to apply.
   *
   * @schema ScrapeConfigSpec#scrapeClass
   */
  readonly scrapeClass?: string;

  /**
   * ScrapeInterval is the interval between consecutive scrapes.
   *
   * @schema ScrapeConfigSpec#scrapeInterval
   */
  readonly scrapeInterval?: string;

  /**
   * The protocols to negotiate during a scrape. It tells clients the
   * protocols supported by Prometheus in order of preference (from most to least preferred).
   *
   *
   * If unset, Prometheus uses its default value.
   *
   *
   * It requires Prometheus >= v2.49.0.
   *
   * @schema ScrapeConfigSpec#scrapeProtocols
   */
  readonly scrapeProtocols?: ScrapeConfigSpecScrapeProtocols[];

  /**
   * ScrapeTimeout is the number of seconds to wait until a scrape request times out.
   *
   * @schema ScrapeConfigSpec#scrapeTimeout
   */
  readonly scrapeTimeout?: string;

  /**
   * StaticConfigs defines a list of static targets with a common label set.
   *
   * @schema ScrapeConfigSpec#staticConfigs
   */
  readonly staticConfigs?: ScrapeConfigSpecStaticConfigs[];

  /**
   * TargetLimit defines a limit on the number of scraped targets that will be accepted.
   *
   * @schema ScrapeConfigSpec#targetLimit
   */
  readonly targetLimit?: number;

  /**
   * TLS configuration to use on every scrape request
   *
   * @schema ScrapeConfigSpec#tlsConfig
   */
  readonly tlsConfig?: ScrapeConfigSpecTlsConfig;

  /**
   * TrackTimestampsStaleness whether Prometheus tracks staleness of
   * the metrics that have an explicit timestamp present in scraped data.
   * Has no effect if `honorTimestamps` is false.
   * It requires Prometheus >= v2.48.0.
   *
   * @schema ScrapeConfigSpec#trackTimestampsStaleness
   */
  readonly trackTimestampsStaleness?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpec(obj: ScrapeConfigSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'NomadSDConfigs': obj.nomadSdConfigs?.map(y => toJson_ScrapeConfigSpecNomadSdConfigs(y)),
    'authorization': toJson_ScrapeConfigSpecAuthorization(obj.authorization),
    'azureSDConfigs': obj.azureSdConfigs?.map(y => toJson_ScrapeConfigSpecAzureSdConfigs(y)),
    'basicAuth': toJson_ScrapeConfigSpecBasicAuth(obj.basicAuth),
    'consulSDConfigs': obj.consulSdConfigs?.map(y => toJson_ScrapeConfigSpecConsulSdConfigs(y)),
    'digitalOceanSDConfigs': obj.digitalOceanSdConfigs?.map(y => toJson_ScrapeConfigSpecDigitalOceanSdConfigs(y)),
    'dnsSDConfigs': obj.dnsSdConfigs?.map(y => toJson_ScrapeConfigSpecDnsSdConfigs(y)),
    'dockerSDConfigs': obj.dockerSdConfigs?.map(y => toJson_ScrapeConfigSpecDockerSdConfigs(y)),
    'ec2SDConfigs': obj.ec2SdConfigs?.map(y => toJson_ScrapeConfigSpecEc2SdConfigs(y)),
    'enableCompression': obj.enableCompression,
    'eurekaSDConfigs': obj.eurekaSdConfigs?.map(y => toJson_ScrapeConfigSpecEurekaSdConfigs(y)),
    'fileSDConfigs': obj.fileSdConfigs?.map(y => toJson_ScrapeConfigSpecFileSdConfigs(y)),
    'gceSDConfigs': obj.gceSdConfigs?.map(y => toJson_ScrapeConfigSpecGceSdConfigs(y)),
    'hetznerSDConfigs': obj.hetznerSdConfigs?.map(y => toJson_ScrapeConfigSpecHetznerSdConfigs(y)),
    'honorLabels': obj.honorLabels,
    'honorTimestamps': obj.honorTimestamps,
    'httpSDConfigs': obj.httpSdConfigs?.map(y => toJson_ScrapeConfigSpecHttpSdConfigs(y)),
    'keepDroppedTargets': obj.keepDroppedTargets,
    'kubernetesSDConfigs': obj.kubernetesSdConfigs?.map(y => toJson_ScrapeConfigSpecKubernetesSdConfigs(y)),
    'kumaSDConfigs': obj.kumaSdConfigs?.map(y => toJson_ScrapeConfigSpecKumaSdConfigs(y)),
    'labelLimit': obj.labelLimit,
    'labelNameLengthLimit': obj.labelNameLengthLimit,
    'labelValueLengthLimit': obj.labelValueLengthLimit,
    'metricRelabelings': obj.metricRelabelings?.map(y => toJson_ScrapeConfigSpecMetricRelabelings(y)),
    'metricsPath': obj.metricsPath,
    'noProxy': obj.noProxy,
    'openstackSDConfigs': obj.openstackSdConfigs?.map(y => toJson_ScrapeConfigSpecOpenstackSdConfigs(y)),
    'params': ((obj.params) === undefined) ? undefined : (Object.entries(obj.params).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.map(y => y) }), {})),
    'proxyConnectHeader': ((obj.proxyConnectHeader) === undefined) ? undefined : (Object.entries(obj.proxyConnectHeader).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.map(y => toJson_ScrapeConfigSpecProxyConnectHeader(y)) }), {})),
    'proxyFromEnvironment': obj.proxyFromEnvironment,
    'proxyUrl': obj.proxyUrl,
    'relabelings': obj.relabelings?.map(y => toJson_ScrapeConfigSpecRelabelings(y)),
    'sampleLimit': obj.sampleLimit,
    'scheme': obj.scheme,
    'scrapeClass': obj.scrapeClass,
    'scrapeInterval': obj.scrapeInterval,
    'scrapeProtocols': obj.scrapeProtocols?.map(y => y),
    'scrapeTimeout': obj.scrapeTimeout,
    'staticConfigs': obj.staticConfigs?.map(y => toJson_ScrapeConfigSpecStaticConfigs(y)),
    'targetLimit': obj.targetLimit,
    'tlsConfig': toJson_ScrapeConfigSpecTlsConfig(obj.tlsConfig),
    'trackTimestampsStaleness': obj.trackTimestampsStaleness,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NomadSDConfig configurations allow retrieving scrape targets from Nomad's Service API.
 * See https://prometheus.io/docs/prometheus/latest/configuration/configuration/#nomad_sd_config
 *
 * @schema ScrapeConfigSpecNomadSdConfigs
 */
export interface ScrapeConfigSpecNomadSdConfigs {
  /**
   * The information to access the Nomad API. It is to be defined
   * as the Nomad documentation requires.
   *
   * @schema ScrapeConfigSpecNomadSdConfigs#allowStale
   */
  readonly allowStale?: boolean;

  /**
   * Authorization header to use on every scrape request.
   *
   * @schema ScrapeConfigSpecNomadSdConfigs#authorization
   */
  readonly authorization?: ScrapeConfigSpecNomadSdConfigsAuthorization;

  /**
   * BasicAuth information to use on every scrape request.
   *
   * @schema ScrapeConfigSpecNomadSdConfigs#basicAuth
   */
  readonly basicAuth?: ScrapeConfigSpecNomadSdConfigsBasicAuth;

  /**
   * Whether to enable HTTP2.
   *
   * @schema ScrapeConfigSpecNomadSdConfigs#enableHTTP2
   */
  readonly enableHttp2?: boolean;

  /**
   * Configure whether HTTP requests follow HTTP 3xx redirects.
   *
   * @schema ScrapeConfigSpecNomadSdConfigs#followRedirects
   */
  readonly followRedirects?: boolean;

  /**
   * @schema ScrapeConfigSpecNomadSdConfigs#namespace
   */
  readonly namespace?: string;

  /**
   * `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names
   * that should be excluded from proxying. IP and domain names can
   * contain port numbers.
   *
   *
   * It requires Prometheus >= v2.43.0.
   *
   * @schema ScrapeConfigSpecNomadSdConfigs#noProxy
   */
  readonly noProxy?: string;

  /**
   * Optional OAuth 2.0 configuration.
   * Cannot be set at the same time as `authorization` or `basic_auth`.
   *
   * @schema ScrapeConfigSpecNomadSdConfigs#oauth2
   */
  readonly oauth2?: ScrapeConfigSpecNomadSdConfigsOauth2;

  /**
   * ProxyConnectHeader optionally specifies headers to send to
   * proxies during CONNECT requests.
   *
   *
   * It requires Prometheus >= v2.43.0.
   *
   * @schema ScrapeConfigSpecNomadSdConfigs#proxyConnectHeader
   */
  readonly proxyConnectHeader?: { [key: string]: ScrapeConfigSpecNomadSdConfigsProxyConnectHeader[] };

  /**
   * Whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
   * If unset, Prometheus uses its default value.
   *
   *
   * It requires Prometheus >= v2.43.0.
   *
   * @schema ScrapeConfigSpecNomadSdConfigs#proxyFromEnvironment
   */
  readonly proxyFromEnvironment?: boolean;

  /**
   * `proxyURL` defines the HTTP proxy server to use.
   *
   *
   * It requires Prometheus >= v2.43.0.
   *
   * @schema ScrapeConfigSpecNomadSdConfigs#proxyUrl
   */
  readonly proxyUrl?: string;

  /**
   * Duration is a valid time duration that can be parsed by Prometheus model.ParseDuration() function.
   * Supported units: y, w, d, h, m, s, ms
   * Examples: `30s`, `1m`, `1h20m15s`, `15d`
   *
   * @schema ScrapeConfigSpecNomadSdConfigs#refreshInterval
   */
  readonly refreshInterval?: string;

  /**
   * @schema ScrapeConfigSpecNomadSdConfigs#region
   */
  readonly region?: string;

  /**
   * @schema ScrapeConfigSpecNomadSdConfigs#server
   */
  readonly server: string;

  /**
   * @schema ScrapeConfigSpecNomadSdConfigs#tagSeparator
   */
  readonly tagSeparator?: string;

  /**
   * TLS configuration applying to the target HTTP endpoint.
   *
   * @schema ScrapeConfigSpecNomadSdConfigs#tlsConfig
   */
  readonly tlsConfig?: ScrapeConfigSpecNomadSdConfigsTlsConfig;

}

/**
 * Converts an object of type 'ScrapeConfigSpecNomadSdConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecNomadSdConfigs(obj: ScrapeConfigSpecNomadSdConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowStale': obj.allowStale,
    'authorization': toJson_ScrapeConfigSpecNomadSdConfigsAuthorization(obj.authorization),
    'basicAuth': toJson_ScrapeConfigSpecNomadSdConfigsBasicAuth(obj.basicAuth),
    'enableHTTP2': obj.enableHttp2,
    'followRedirects': obj.followRedirects,
    'namespace': obj.namespace,
    'noProxy': obj.noProxy,
    'oauth2': toJson_ScrapeConfigSpecNomadSdConfigsOauth2(obj.oauth2),
    'proxyConnectHeader': ((obj.proxyConnectHeader) === undefined) ? undefined : (Object.entries(obj.proxyConnectHeader).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.map(y => toJson_ScrapeConfigSpecNomadSdConfigsProxyConnectHeader(y)) }), {})),
    'proxyFromEnvironment': obj.proxyFromEnvironment,
    'proxyUrl': obj.proxyUrl,
    'refreshInterval': obj.refreshInterval,
    'region': obj.region,
    'server': obj.server,
    'tagSeparator': obj.tagSeparator,
    'tlsConfig': toJson_ScrapeConfigSpecNomadSdConfigsTlsConfig(obj.tlsConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Authorization header to use on every scrape request.
 *
 * @schema ScrapeConfigSpecAuthorization
 */
export interface ScrapeConfigSpecAuthorization {
  /**
   * Selects a key of a Secret in the namespace that contains the credentials for authentication.
   *
   * @schema ScrapeConfigSpecAuthorization#credentials
   */
  readonly credentials?: ScrapeConfigSpecAuthorizationCredentials;

  /**
   * Defines the authentication type. The value is case-insensitive.
   *
   *
   * "Basic" is not a supported value.
   *
   *
   * Default: "Bearer"
   *
   * @schema ScrapeConfigSpecAuthorization#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ScrapeConfigSpecAuthorization' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecAuthorization(obj: ScrapeConfigSpecAuthorization | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentials': toJson_ScrapeConfigSpecAuthorizationCredentials(obj.credentials),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AzureSDConfig allow retrieving scrape targets from Azure VMs.
 * See https://prometheus.io/docs/prometheus/latest/configuration/configuration/#azure_sd_config
 *
 * @schema ScrapeConfigSpecAzureSdConfigs
 */
export interface ScrapeConfigSpecAzureSdConfigs {
  /**
   * # The authentication method, either `OAuth` or `ManagedIdentity` or `SDK`.
   * See https://docs.microsoft.com/en-us/azure/active-directory/managed-identities-azure-resources/overview
   * SDK authentication method uses environment variables by default.
   * See https://learn.microsoft.com/en-us/azure/developer/go/azure-sdk-authentication
   *
   * @schema ScrapeConfigSpecAzureSdConfigs#authenticationMethod
   */
  readonly authenticationMethod?: ScrapeConfigSpecAzureSdConfigsAuthenticationMethod;

  /**
   * Optional client ID. Only required with the OAuth authentication method.
   *
   * @schema ScrapeConfigSpecAzureSdConfigs#clientID
   */
  readonly clientId?: string;

  /**
   * Optional client secret. Only required with the OAuth authentication method.
   *
   * @schema ScrapeConfigSpecAzureSdConfigs#clientSecret
   */
  readonly clientSecret?: ScrapeConfigSpecAzureSdConfigsClientSecret;

  /**
   * The Azure environment.
   *
   * @schema ScrapeConfigSpecAzureSdConfigs#environment
   */
  readonly environment?: string;

  /**
   * The port to scrape metrics from. If using the public IP address, this must
   * instead be specified in the relabeling rule.
   *
   * @schema ScrapeConfigSpecAzureSdConfigs#port
   */
  readonly port?: number;

  /**
   * RefreshInterval configures the refresh interval at which Prometheus will re-read the instance list.
   *
   * @schema ScrapeConfigSpecAzureSdConfigs#refreshInterval
   */
  readonly refreshInterval?: string;

  /**
   * Optional resource group name. Limits discovery to this resource group.
   *
   * @schema ScrapeConfigSpecAzureSdConfigs#resourceGroup
   */
  readonly resourceGroup?: string;

  /**
   * The subscription ID. Always required.
   *
   * @schema ScrapeConfigSpecAzureSdConfigs#subscriptionID
   */
  readonly subscriptionId: string;

  /**
   * Optional tenant ID. Only required with the OAuth authentication method.
   *
   * @schema ScrapeConfigSpecAzureSdConfigs#tenantID
   */
  readonly tenantId?: string;

}

/**
 * Converts an object of type 'ScrapeConfigSpecAzureSdConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecAzureSdConfigs(obj: ScrapeConfigSpecAzureSdConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authenticationMethod': obj.authenticationMethod,
    'clientID': obj.clientId,
    'clientSecret': toJson_ScrapeConfigSpecAzureSdConfigsClientSecret(obj.clientSecret),
    'environment': obj.environment,
    'port': obj.port,
    'refreshInterval': obj.refreshInterval,
    'resourceGroup': obj.resourceGroup,
    'subscriptionID': obj.subscriptionId,
    'tenantID': obj.tenantId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BasicAuth information to use on every scrape request.
 *
 * @schema ScrapeConfigSpecBasicAuth
 */
export interface ScrapeConfigSpecBasicAuth {
  /**
   * `password` specifies a key of a Secret containing the password for
   * authentication.
   *
   * @schema ScrapeConfigSpecBasicAuth#password
   */
  readonly password?: ScrapeConfigSpecBasicAuthPassword;

  /**
   * `username` specifies a key of a Secret containing the username for
   * authentication.
   *
   * @schema ScrapeConfigSpecBasicAuth#username
   */
  readonly username?: ScrapeConfigSpecBasicAuthUsername;

}

/**
 * Converts an object of type 'ScrapeConfigSpecBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecBasicAuth(obj: ScrapeConfigSpecBasicAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_ScrapeConfigSpecBasicAuthPassword(obj.password),
    'username': toJson_ScrapeConfigSpecBasicAuthUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConsulSDConfig defines a Consul service discovery configuration
 * See https://prometheus.io/docs/prometheus/latest/configuration/configuration/#consul_sd_config
 *
 * @schema ScrapeConfigSpecConsulSdConfigs
 */
export interface ScrapeConfigSpecConsulSdConfigs {
  /**
   * Allow stale Consul results (see https://www.consul.io/api/features/consistency.html). Will reduce load on Consul.
   * If unset, Prometheus uses its default value.
   *
   * @schema ScrapeConfigSpecConsulSdConfigs#allowStale
   */
  readonly allowStale?: boolean;

  /**
   * Authorization header configuration to authenticate against the Consul Server.
   *
   * @schema ScrapeConfigSpecConsulSdConfigs#authorization
   */
  readonly authorization?: ScrapeConfigSpecConsulSdConfigsAuthorization;

  /**
   * BasicAuth information to authenticate against the Consul Server.
   * More info: https://prometheus.io/docs/operating/configuration/#endpoints
   *
   * @schema ScrapeConfigSpecConsulSdConfigs#basicAuth
   */
  readonly basicAuth?: ScrapeConfigSpecConsulSdConfigsBasicAuth;

  /**
   * Consul Datacenter name, if not provided it will use the local Consul Agent Datacenter.
   *
   * @schema ScrapeConfigSpecConsulSdConfigs#datacenter
   */
  readonly datacenter?: string;

  /**
   * Whether to enable HTTP2.
   * If unset, Prometheus uses its default value.
   *
   * @schema ScrapeConfigSpecConsulSdConfigs#enableHTTP2
   */
  readonly enableHttp2?: boolean;

  /**
   * Configure whether HTTP requests follow HTTP 3xx redirects.
   * If unset, Prometheus uses its default value.
   *
   * @schema ScrapeConfigSpecConsulSdConfigs#followRedirects
   */
  readonly followRedirects?: boolean;

  /**
   * Namespaces are only supported in Consul Enterprise.
   *
   * @schema ScrapeConfigSpecConsulSdConfigs#namespace
   */
  readonly namespace?: string;

  /**
   * `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names
   * that should be excluded from proxying. IP and domain names can
   * contain port numbers.
   *
   *
   * It requires Prometheus >= v2.43.0.
   *
   * @schema ScrapeConfigSpecConsulSdConfigs#noProxy
   */
  readonly noProxy?: string;

  /**
   * Node metadata key/value pairs to filter nodes for a given service.
   *
   * @schema ScrapeConfigSpecConsulSdConfigs#nodeMeta
   */
  readonly nodeMeta?: { [key: string]: string };

  /**
   * Optional OAuth 2.0 configuration.
   *
   * @schema ScrapeConfigSpecConsulSdConfigs#oauth2
   */
  readonly oauth2?: ScrapeConfigSpecConsulSdConfigsOauth2;

  /**
   * Admin Partitions are only supported in Consul Enterprise.
   *
   * @schema ScrapeConfigSpecConsulSdConfigs#partition
   */
  readonly partition?: string;

  /**
   * ProxyConnectHeader optionally specifies headers to send to
   * proxies during CONNECT requests.
   *
   *
   * It requires Prometheus >= v2.43.0.
   *
   * @schema ScrapeConfigSpecConsulSdConfigs#proxyConnectHeader
   */
  readonly proxyConnectHeader?: { [key: string]: ScrapeConfigSpecConsulSdConfigsProxyConnectHeader[] };

  /**
   * Whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
   * If unset, Prometheus uses its default value.
   *
   *
   * It requires Prometheus >= v2.43.0.
   *
   * @schema ScrapeConfigSpecConsulSdConfigs#proxyFromEnvironment
   */
  readonly proxyFromEnvironment?: boolean;

  /**
   * `proxyURL` defines the HTTP proxy server to use.
   *
   *
   * It requires Prometheus >= v2.43.0.
   *
   * @schema ScrapeConfigSpecConsulSdConfigs#proxyUrl
   */
  readonly proxyUrl?: string;

  /**
   * The time after which the provided names are refreshed.
   * On large setup it might be a good idea to increase this value because the catalog will change all the time.
   * If unset, Prometheus uses its default value.
   *
   * @schema ScrapeConfigSpecConsulSdConfigs#refreshInterval
   */
  readonly refreshInterval?: string;

  /**
   * HTTP Scheme default "http"
   *
   * @schema ScrapeConfigSpecConsulSdConfigs#scheme
   */
  readonly scheme?: ScrapeConfigSpecConsulSdConfigsScheme;

  /**
   * A valid string consisting of a hostname or IP followed by an optional port number.
   *
   * @schema ScrapeConfigSpecConsulSdConfigs#server
   */
  readonly server: string;

  /**
   * A list of services for which targets are retrieved. If omitted, all services are scraped.
   *
   * @schema ScrapeConfigSpecConsulSdConfigs#services
   */
  readonly services?: string[];

  /**
   * The string by which Consul tags are joined into the tag label.
   * If unset, Prometheus uses its default value.
   *
   * @schema ScrapeConfigSpecConsulSdConfigs#tagSeparator
   */
  readonly tagSeparator?: string;

  /**
   * An optional list of tags used to filter nodes for a given service. Services must contain all tags in the list.
   *
   * @schema ScrapeConfigSpecConsulSdConfigs#tags
   */
  readonly tags?: string[];

  /**
   * TLS Config
   *
   * @schema ScrapeConfigSpecConsulSdConfigs#tlsConfig
   */
  readonly tlsConfig?: ScrapeConfigSpecConsulSdConfigsTlsConfig;

  /**
   * Consul ACL TokenRef, if not provided it will use the ACL from the local Consul Agent.
   *
   * @schema ScrapeConfigSpecConsulSdConfigs#tokenRef
   */
  readonly tokenRef?: ScrapeConfigSpecConsulSdConfigsTokenRef;

}

/**
 * Converts an object of type 'ScrapeConfigSpecConsulSdConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecConsulSdConfigs(obj: ScrapeConfigSpecConsulSdConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowStale': obj.allowStale,
    'authorization': toJson_ScrapeConfigSpecConsulSdConfigsAuthorization(obj.authorization),
    'basicAuth': toJson_ScrapeConfigSpecConsulSdConfigsBasicAuth(obj.basicAuth),
    'datacenter': obj.datacenter,
    'enableHTTP2': obj.enableHttp2,
    'followRedirects': obj.followRedirects,
    'namespace': obj.namespace,
    'noProxy': obj.noProxy,
    'nodeMeta': ((obj.nodeMeta) === undefined) ? undefined : (Object.entries(obj.nodeMeta).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'oauth2': toJson_ScrapeConfigSpecConsulSdConfigsOauth2(obj.oauth2),
    'partition': obj.partition,
    'proxyConnectHeader': ((obj.proxyConnectHeader) === undefined) ? undefined : (Object.entries(obj.proxyConnectHeader).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.map(y => toJson_ScrapeConfigSpecConsulSdConfigsProxyConnectHeader(y)) }), {})),
    'proxyFromEnvironment': obj.proxyFromEnvironment,
    'proxyUrl': obj.proxyUrl,
    'refreshInterval': obj.refreshInterval,
    'scheme': obj.scheme,
    'server': obj.server,
    'services': obj.services?.map(y => y),
    'tagSeparator': obj.tagSeparator,
    'tags': obj.tags?.map(y => y),
    'tlsConfig': toJson_ScrapeConfigSpecConsulSdConfigsTlsConfig(obj.tlsConfig),
    'tokenRef': toJson_ScrapeConfigSpecConsulSdConfigsTokenRef(obj.tokenRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DigitalOceanSDConfig allow retrieving scrape targets from DigitalOcean's Droplets API.
 * This service discovery uses the public IPv4 address by default, by that can be changed with relabeling
 * See https://prometheus.io/docs/prometheus/latest/configuration/configuration/#digitalocean_sd_config
 *
 * @schema ScrapeConfigSpecDigitalOceanSdConfigs
 */
export interface ScrapeConfigSpecDigitalOceanSdConfigs {
  /**
   * Authorization header configuration to authenticate against the DigitalOcean API.
   * Cannot be set at the same time as `oauth2`.
   *
   * @schema ScrapeConfigSpecDigitalOceanSdConfigs#authorization
   */
  readonly authorization?: ScrapeConfigSpecDigitalOceanSdConfigsAuthorization;

  /**
   * Whether to enable HTTP2.
   *
   * @schema ScrapeConfigSpecDigitalOceanSdConfigs#enableHTTP2
   */
  readonly enableHttp2?: boolean;

  /**
   * Configure whether HTTP requests follow HTTP 3xx redirects.
   *
   * @schema ScrapeConfigSpecDigitalOceanSdConfigs#followRedirects
   */
  readonly followRedirects?: boolean;

  /**
   * `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names
   * that should be excluded from proxying. IP and domain names can
   * contain port numbers.
   *
   *
   * It requires Prometheus >= v2.43.0.
   *
   * @schema ScrapeConfigSpecDigitalOceanSdConfigs#noProxy
   */
  readonly noProxy?: string;

  /**
   * Optional OAuth 2.0 configuration.
   * Cannot be set at the same time as `authorization`.
   *
   * @schema ScrapeConfigSpecDigitalOceanSdConfigs#oauth2
   */
  readonly oauth2?: ScrapeConfigSpecDigitalOceanSdConfigsOauth2;

  /**
   * The port to scrape metrics from.
   *
   * @schema ScrapeConfigSpecDigitalOceanSdConfigs#port
   */
  readonly port?: number;

  /**
   * ProxyConnectHeader optionally specifies headers to send to
   * proxies during CONNECT requests.
   *
   *
   * It requires Prometheus >= v2.43.0.
   *
   * @schema ScrapeConfigSpecDigitalOceanSdConfigs#proxyConnectHeader
   */
  readonly proxyConnectHeader?: { [key: string]: ScrapeConfigSpecDigitalOceanSdConfigsProxyConnectHeader[] };

  /**
   * Whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
   * If unset, Prometheus uses its default value.
   *
   *
   * It requires Prometheus >= v2.43.0.
   *
   * @schema ScrapeConfigSpecDigitalOceanSdConfigs#proxyFromEnvironment
   */
  readonly proxyFromEnvironment?: boolean;

  /**
   * `proxyURL` defines the HTTP proxy server to use.
   *
   *
   * It requires Prometheus >= v2.43.0.
   *
   * @schema ScrapeConfigSpecDigitalOceanSdConfigs#proxyUrl
   */
  readonly proxyUrl?: string;

  /**
   * Refresh interval to re-read the instance list.
   *
   * @schema ScrapeConfigSpecDigitalOceanSdConfigs#refreshInterval
   */
  readonly refreshInterval?: string;

  /**
   * TLS configuration applying to the target HTTP endpoint.
   *
   * @schema ScrapeConfigSpecDigitalOceanSdConfigs#tlsConfig
   */
  readonly tlsConfig?: ScrapeConfigSpecDigitalOceanSdConfigsTlsConfig;

}

/**
 * Converts an object of type 'ScrapeConfigSpecDigitalOceanSdConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecDigitalOceanSdConfigs(obj: ScrapeConfigSpecDigitalOceanSdConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authorization': toJson_ScrapeConfigSpecDigitalOceanSdConfigsAuthorization(obj.authorization),
    'enableHTTP2': obj.enableHttp2,
    'followRedirects': obj.followRedirects,
    'noProxy': obj.noProxy,
    'oauth2': toJson_ScrapeConfigSpecDigitalOceanSdConfigsOauth2(obj.oauth2),
    'port': obj.port,
    'proxyConnectHeader': ((obj.proxyConnectHeader) === undefined) ? undefined : (Object.entries(obj.proxyConnectHeader).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.map(y => toJson_ScrapeConfigSpecDigitalOceanSdConfigsProxyConnectHeader(y)) }), {})),
    'proxyFromEnvironment': obj.proxyFromEnvironment,
    'proxyUrl': obj.proxyUrl,
    'refreshInterval': obj.refreshInterval,
    'tlsConfig': toJson_ScrapeConfigSpecDigitalOceanSdConfigsTlsConfig(obj.tlsConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DNSSDConfig allows specifying a set of DNS domain names which are periodically queried to discover a list of targets.
 * The DNS servers to be contacted are read from /etc/resolv.conf.
 * See https://prometheus.io/docs/prometheus/latest/configuration/configuration/#dns_sd_config
 *
 * @schema ScrapeConfigSpecDnsSdConfigs
 */
export interface ScrapeConfigSpecDnsSdConfigs {
  /**
   * A list of DNS domain names to be queried.
   *
   * @schema ScrapeConfigSpecDnsSdConfigs#names
   */
  readonly names: string[];

  /**
   * The port number used if the query type is not SRV
   * Ignored for SRV records
   *
   * @schema ScrapeConfigSpecDnsSdConfigs#port
   */
  readonly port?: number;

  /**
   * RefreshInterval configures the time after which the provided names are refreshed.
   * If not set, Prometheus uses its default value.
   *
   * @schema ScrapeConfigSpecDnsSdConfigs#refreshInterval
   */
  readonly refreshInterval?: string;

  /**
   * The type of DNS query to perform. One of SRV, A, AAAA, MX or NS.
   * If not set, Prometheus uses its default value.
   *
   *
   * When set to NS, It requires Prometheus >= 2.49.0.
   *
   * @schema ScrapeConfigSpecDnsSdConfigs#type
   */
  readonly type?: ScrapeConfigSpecDnsSdConfigsType;

}

/**
 * Converts an object of type 'ScrapeConfigSpecDnsSdConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecDnsSdConfigs(obj: ScrapeConfigSpecDnsSdConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'names': obj.names?.map(y => y),
    'port': obj.port,
    'refreshInterval': obj.refreshInterval,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Docker SD configurations allow retrieving scrape targets from Docker Engine hosts.
 * This SD discovers "containers" and will create a target for each network IP and
 * port the container is configured to expose.
 * See https://prometheus.io/docs/prometheus/latest/configuration/configuration/#docker_sd_config
 *
 * @schema ScrapeConfigSpecDockerSdConfigs
 */
export interface ScrapeConfigSpecDockerSdConfigs {
  /**
   * Authorization header configuration to authenticate against the Docker API.
   * Cannot be set at the same time as `oauth2`.
   *
   * @schema ScrapeConfigSpecDockerSdConfigs#authorization
   */
  readonly authorization?: ScrapeConfigSpecDockerSdConfigsAuthorization;

  /**
   * BasicAuth information to use on every scrape request.
   *
   * @schema ScrapeConfigSpecDockerSdConfigs#basicAuth
   */
  readonly basicAuth?: ScrapeConfigSpecDockerSdConfigsBasicAuth;

  /**
   * Whether to enable HTTP2.
   *
   * @schema ScrapeConfigSpecDockerSdConfigs#enableHTTP2
   */
  readonly enableHttp2?: boolean;

  /**
   * Optional filters to limit the discovery process to a subset of the available resources.
   *
   * @schema ScrapeConfigSpecDockerSdConfigs#filters
   */
  readonly filters?: ScrapeConfigSpecDockerSdConfigsFilters[];

  /**
   * Configure whether HTTP requests follow HTTP 3xx redirects.
   *
   * @schema ScrapeConfigSpecDockerSdConfigs#followRedirects
   */
  readonly followRedirects?: boolean;

  /**
   * Address of the docker daemon
   *
   * @schema ScrapeConfigSpecDockerSdConfigs#host
   */
  readonly host: string;

  /**
   * The host to use if the container is in host networking mode.
   *
   * @schema ScrapeConfigSpecDockerSdConfigs#hostNetworkingHost
   */
  readonly hostNetworkingHost?: string;

  /**
   * `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names
   * that should be excluded from proxying. IP and domain names can
   * contain port numbers.
   *
   *
   * It requires Prometheus >= v2.43.0.
   *
   * @schema ScrapeConfigSpecDockerSdConfigs#noProxy
   */
  readonly noProxy?: string;

  /**
   * Optional OAuth 2.0 configuration.
   * Cannot be set at the same time as `authorization`.
   *
   * @schema ScrapeConfigSpecDockerSdConfigs#oauth2
   */
  readonly oauth2?: ScrapeConfigSpecDockerSdConfigsOauth2;

  /**
   * The port to scrape metrics from.
   *
   * @schema ScrapeConfigSpecDockerSdConfigs#port
   */
  readonly port?: number;

  /**
   * ProxyConnectHeader optionally specifies headers to send to
   * proxies during CONNECT requests.
   *
   *
   * It requires Prometheus >= v2.43.0.
   *
   * @schema ScrapeConfigSpecDockerSdConfigs#proxyConnectHeader
   */
  readonly proxyConnectHeader?: { [key: string]: ScrapeConfigSpecDockerSdConfigsProxyConnectHeader[] };

  /**
   * Whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
   * If unset, Prometheus uses its default value.
   *
   *
   * It requires Prometheus >= v2.43.0.
   *
   * @schema ScrapeConfigSpecDockerSdConfigs#proxyFromEnvironment
   */
  readonly proxyFromEnvironment?: boolean;

  /**
   * `proxyURL` defines the HTTP proxy server to use.
   *
   *
   * It requires Prometheus >= v2.43.0.
   *
   * @schema ScrapeConfigSpecDockerSdConfigs#proxyUrl
   */
  readonly proxyUrl?: string;

  /**
   * Time after which the container is refreshed.
   *
   * @schema ScrapeConfigSpecDockerSdConfigs#refreshInterval
   */
  readonly refreshInterval?: string;

  /**
   * TLS configuration applying to the target HTTP endpoint.
   *
   * @schema ScrapeConfigSpecDockerSdConfigs#tlsConfig
   */
  readonly tlsConfig?: ScrapeConfigSpecDockerSdConfigsTlsConfig;

}

/**
 * Converts an object of type 'ScrapeConfigSpecDockerSdConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecDockerSdConfigs(obj: ScrapeConfigSpecDockerSdConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authorization': toJson_ScrapeConfigSpecDockerSdConfigsAuthorization(obj.authorization),
    'basicAuth': toJson_ScrapeConfigSpecDockerSdConfigsBasicAuth(obj.basicAuth),
    'enableHTTP2': obj.enableHttp2,
    'filters': obj.filters?.map(y => toJson_ScrapeConfigSpecDockerSdConfigsFilters(y)),
    'followRedirects': obj.followRedirects,
    'host': obj.host,
    'hostNetworkingHost': obj.hostNetworkingHost,
    'noProxy': obj.noProxy,
    'oauth2': toJson_ScrapeConfigSpecDockerSdConfigsOauth2(obj.oauth2),
    'port': obj.port,
    'proxyConnectHeader': ((obj.proxyConnectHeader) === undefined) ? undefined : (Object.entries(obj.proxyConnectHeader).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.map(y => toJson_ScrapeConfigSpecDockerSdConfigsProxyConnectHeader(y)) }), {})),
    'proxyFromEnvironment': obj.proxyFromEnvironment,
    'proxyUrl': obj.proxyUrl,
    'refreshInterval': obj.refreshInterval,
    'tlsConfig': toJson_ScrapeConfigSpecDockerSdConfigsTlsConfig(obj.tlsConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EC2SDConfig allow retrieving scrape targets from AWS EC2 instances.
 * The private IP address is used by default, but may be changed to the public IP address with relabeling.
 * The IAM credentials used must have the ec2:DescribeInstances permission to discover scrape targets
 * See https://prometheus.io/docs/prometheus/latest/configuration/configuration/#ec2_sd_config
 *
 * @schema ScrapeConfigSpecEc2SdConfigs
 */
export interface ScrapeConfigSpecEc2SdConfigs {
  /**
   * AccessKey is the AWS API key.
   *
   * @schema ScrapeConfigSpecEc2SdConfigs#accessKey
   */
  readonly accessKey?: ScrapeConfigSpecEc2SdConfigsAccessKey;

  /**
   * Filters can be used optionally to filter the instance list by other criteria.
   * Available filter criteria can be found here:
   * https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeInstances.html
   * Filter API documentation: https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_Filter.html
   *
   * @schema ScrapeConfigSpecEc2SdConfigs#filters
   */
  readonly filters?: ScrapeConfigSpecEc2SdConfigsFilters[];

  /**
   * The port to scrape metrics from. If using the public IP address, this must
   * instead be specified in the relabeling rule.
   *
   * @schema ScrapeConfigSpecEc2SdConfigs#port
   */
  readonly port?: number;

  /**
   * RefreshInterval configures the refresh interval at which Prometheus will re-read the instance list.
   *
   * @schema ScrapeConfigSpecEc2SdConfigs#refreshInterval
   */
  readonly refreshInterval?: string;

  /**
   * The AWS region
   *
   * @schema ScrapeConfigSpecEc2SdConfigs#region
   */
  readonly region?: string;

  /**
   * AWS Role ARN, an alternative to using AWS API keys.
   *
   * @schema ScrapeConfigSpecEc2SdConfigs#roleARN
   */
  readonly roleArn?: string;

  /**
   * SecretKey is the AWS API secret.
   *
   * @schema ScrapeConfigSpecEc2SdConfigs#secretKey
   */
  readonly secretKey?: ScrapeConfigSpecEc2SdConfigsSecretKey;

}

/**
 * Converts an object of type 'ScrapeConfigSpecEc2SdConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecEc2SdConfigs(obj: ScrapeConfigSpecEc2SdConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessKey': toJson_ScrapeConfigSpecEc2SdConfigsAccessKey(obj.accessKey),
    'filters': obj.filters?.map(y => toJson_ScrapeConfigSpecEc2SdConfigsFilters(y)),
    'port': obj.port,
    'refreshInterval': obj.refreshInterval,
    'region': obj.region,
    'roleARN': obj.roleArn,
    'secretKey': toJson_ScrapeConfigSpecEc2SdConfigsSecretKey(obj.secretKey),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Eureka SD configurations allow retrieving scrape targets using the Eureka REST API.
 * Prometheus will periodically check the REST endpoint and create a target for every app instance.
 * See https://prometheus.io/docs/prometheus/latest/configuration/configuration/#eureka_sd_config
 *
 * @schema ScrapeConfigSpecEurekaSdConfigs
 */
export interface ScrapeConfigSpecEurekaSdConfigs {
  /**
   * Authorization header to use on every scrape request.
   *
   * @schema ScrapeConfigSpecEurekaSdConfigs#authorization
   */
  readonly authorization?: ScrapeConfigSpecEurekaSdConfigsAuthorization;

  /**
   * BasicAuth information to use on every scrape request.
   *
   * @schema ScrapeConfigSpecEurekaSdConfigs#basicAuth
   */
  readonly basicAuth?: ScrapeConfigSpecEurekaSdConfigsBasicAuth;

  /**
   * Whether to enable HTTP2.
   *
   * @schema ScrapeConfigSpecEurekaSdConfigs#enableHTTP2
   */
  readonly enableHttp2?: boolean;

  /**
   * Configure whether HTTP requests follow HTTP 3xx redirects.
   *
   * @schema ScrapeConfigSpecEurekaSdConfigs#followRedirects
   */
  readonly followRedirects?: boolean;

  /**
   * `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names
   * that should be excluded from proxying. IP and domain names can
   * contain port numbers.
   *
   *
   * It requires Prometheus >= v2.43.0.
   *
   * @schema ScrapeConfigSpecEurekaSdConfigs#noProxy
   */
  readonly noProxy?: string;

  /**
   * Optional OAuth 2.0 configuration.
   * Cannot be set at the same time as `authorization` or `basic_auth`.
   *
   * @schema ScrapeConfigSpecEurekaSdConfigs#oauth2
   */
  readonly oauth2?: ScrapeConfigSpecEurekaSdConfigsOauth2;

  /**
   * ProxyConnectHeader optionally specifies headers to send to
   * proxies during CONNECT requests.
   *
   *
   * It requires Prometheus >= v2.43.0.
   *
   * @schema ScrapeConfigSpecEurekaSdConfigs#proxyConnectHeader
   */
  readonly proxyConnectHeader?: { [key: string]: ScrapeConfigSpecEurekaSdConfigsProxyConnectHeader[] };

  /**
   * Whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
   * If unset, Prometheus uses its default value.
   *
   *
   * It requires Prometheus >= v2.43.0.
   *
   * @schema ScrapeConfigSpecEurekaSdConfigs#proxyFromEnvironment
   */
  readonly proxyFromEnvironment?: boolean;

  /**
   * `proxyURL` defines the HTTP proxy server to use.
   *
   *
   * It requires Prometheus >= v2.43.0.
   *
   * @schema ScrapeConfigSpecEurekaSdConfigs#proxyUrl
   */
  readonly proxyUrl?: string;

  /**
   * Refresh interval to re-read the instance list.
   *
   * @schema ScrapeConfigSpecEurekaSdConfigs#refreshInterval
   */
  readonly refreshInterval?: string;

  /**
   * The URL to connect to the Eureka server.
   *
   * @schema ScrapeConfigSpecEurekaSdConfigs#server
   */
  readonly server: string;

  /**
   * TLS configuration applying to the target HTTP endpoint.
   *
   * @schema ScrapeConfigSpecEurekaSdConfigs#tlsConfig
   */
  readonly tlsConfig?: ScrapeConfigSpecEurekaSdConfigsTlsConfig;

}

/**
 * Converts an object of type 'ScrapeConfigSpecEurekaSdConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecEurekaSdConfigs(obj: ScrapeConfigSpecEurekaSdConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authorization': toJson_ScrapeConfigSpecEurekaSdConfigsAuthorization(obj.authorization),
    'basicAuth': toJson_ScrapeConfigSpecEurekaSdConfigsBasicAuth(obj.basicAuth),
    'enableHTTP2': obj.enableHttp2,
    'followRedirects': obj.followRedirects,
    'noProxy': obj.noProxy,
    'oauth2': toJson_ScrapeConfigSpecEurekaSdConfigsOauth2(obj.oauth2),
    'proxyConnectHeader': ((obj.proxyConnectHeader) === undefined) ? undefined : (Object.entries(obj.proxyConnectHeader).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.map(y => toJson_ScrapeConfigSpecEurekaSdConfigsProxyConnectHeader(y)) }), {})),
    'proxyFromEnvironment': obj.proxyFromEnvironment,
    'proxyUrl': obj.proxyUrl,
    'refreshInterval': obj.refreshInterval,
    'server': obj.server,
    'tlsConfig': toJson_ScrapeConfigSpecEurekaSdConfigsTlsConfig(obj.tlsConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FileSDConfig defines a Prometheus file service discovery configuration
 * See https://prometheus.io/docs/prometheus/latest/configuration/configuration/#file_sd_config
 *
 * @schema ScrapeConfigSpecFileSdConfigs
 */
export interface ScrapeConfigSpecFileSdConfigs {
  /**
   * List of files to be used for file discovery. Recommendation: use absolute paths. While relative paths work, the
   * prometheus-operator project makes no guarantees about the working directory where the configuration file is
   * stored.
   * Files must be mounted using Prometheus.ConfigMaps or Prometheus.Secrets.
   *
   * @schema ScrapeConfigSpecFileSdConfigs#files
   */
  readonly files: string[];

  /**
   * RefreshInterval configures the refresh interval at which Prometheus will reload the content of the files.
   *
   * @schema ScrapeConfigSpecFileSdConfigs#refreshInterval
   */
  readonly refreshInterval?: string;

}

/**
 * Converts an object of type 'ScrapeConfigSpecFileSdConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecFileSdConfigs(obj: ScrapeConfigSpecFileSdConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'files': obj.files?.map(y => y),
    'refreshInterval': obj.refreshInterval,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GCESDConfig configures scrape targets from GCP GCE instances.
 * The private IP address is used by default, but may be changed to
 * the public IP address with relabeling.
 * See https://prometheus.io/docs/prometheus/latest/configuration/configuration/#gce_sd_config
 *
 *
 * The GCE service discovery will load the Google Cloud credentials
 * from the file specified by the GOOGLE_APPLICATION_CREDENTIALS environment variable.
 * See https://cloud.google.com/kubernetes-engine/docs/tutorials/authenticating-to-cloud-platform
 *
 *
 * A pre-requisite for using GCESDConfig is that a Secret containing valid
 * Google Cloud credentials is mounted into the Prometheus or PrometheusAgent
 * pod via the `.spec.secrets` field and that the GOOGLE_APPLICATION_CREDENTIALS
 * environment variable is set to /etc/prometheus/secrets/<secret-name>/<credentials-filename.json>.
 *
 * @schema ScrapeConfigSpecGceSdConfigs
 */
export interface ScrapeConfigSpecGceSdConfigs {
  /**
   * Filter can be used optionally to filter the instance list by other criteria
   * Syntax of this filter is described in the filter query parameter section:
   * https://cloud.google.com/compute/docs/reference/latest/instances/list
   *
   * @schema ScrapeConfigSpecGceSdConfigs#filter
   */
  readonly filter?: string;

  /**
   * The port to scrape metrics from. If using the public IP address, this must
   * instead be specified in the relabeling rule.
   *
   * @schema ScrapeConfigSpecGceSdConfigs#port
   */
  readonly port?: number;

  /**
   * The Google Cloud Project ID
   *
   * @schema ScrapeConfigSpecGceSdConfigs#project
   */
  readonly project: string;

  /**
   * RefreshInterval configures the refresh interval at which Prometheus will re-read the instance list.
   *
   * @schema ScrapeConfigSpecGceSdConfigs#refreshInterval
   */
  readonly refreshInterval?: string;

  /**
   * The tag separator is used to separate the tags on concatenation
   *
   * @schema ScrapeConfigSpecGceSdConfigs#tagSeparator
   */
  readonly tagSeparator?: string;

  /**
   * The zone of the scrape targets. If you need multiple zones use multiple GCESDConfigs.
   *
   * @schema ScrapeConfigSpecGceSdConfigs#zone
   */
  readonly zone: string;

}

/**
 * Converts an object of type 'ScrapeConfigSpecGceSdConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecGceSdConfigs(obj: ScrapeConfigSpecGceSdConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'filter': obj.filter,
    'port': obj.port,
    'project': obj.project,
    'refreshInterval': obj.refreshInterval,
    'tagSeparator': obj.tagSeparator,
    'zone': obj.zone,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HetznerSDConfig allow retrieving scrape targets from Hetzner Cloud API and Robot API.
 * This service discovery uses the public IPv4 address by default, but that can be changed with relabeling
 * See https://prometheus.io/docs/prometheus/latest/configuration/configuration/#hetzner_sd_config
 *
 * @schema ScrapeConfigSpecHetznerSdConfigs
 */
export interface ScrapeConfigSpecHetznerSdConfigs {
  /**
   * Authorization header configuration, required when role is hcloud.
   * Role robot does not support bearer token authentication.
   *
   * @schema ScrapeConfigSpecHetznerSdConfigs#authorization
   */
  readonly authorization?: ScrapeConfigSpecHetznerSdConfigsAuthorization;

  /**
   * BasicAuth information to use on every scrape request, required when role is robot.
   * Role hcloud does not support basic auth.
   *
   * @schema ScrapeConfigSpecHetznerSdConfigs#basicAuth
   */
  readonly basicAuth?: ScrapeConfigSpecHetznerSdConfigsBasicAuth;

  /**
   * Whether to enable HTTP2.
   *
   * @schema ScrapeConfigSpecHetznerSdConfigs#enableHTTP2
   */
  readonly enableHttp2?: boolean;

  /**
   * Configure whether HTTP requests follow HTTP 3xx redirects.
   *
   * @schema ScrapeConfigSpecHetznerSdConfigs#followRedirects
   */
  readonly followRedirects?: boolean;

  /**
   * `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names
   * that should be excluded from proxying. IP and domain names can
   * contain port numbers.
   *
   *
   * It requires Prometheus >= v2.43.0.
   *
   * @schema ScrapeConfigSpecHetznerSdConfigs#noProxy
   */
  readonly noProxy?: string;

  /**
   * Optional OAuth 2.0 configuration.
   * Cannot be used at the same time as `basic_auth` or `authorization`.
   *
   * @schema ScrapeConfigSpecHetznerSdConfigs#oauth2
   */
  readonly oauth2?: ScrapeConfigSpecHetznerSdConfigsOauth2;

  /**
   * The port to scrape metrics from.
   *
   * @schema ScrapeConfigSpecHetznerSdConfigs#port
   */
  readonly port?: number;

  /**
   * ProxyConnectHeader optionally specifies headers to send to
   * proxies during CONNECT requests.
   *
   *
   * It requires Prometheus >= v2.43.0.
   *
   * @schema ScrapeConfigSpecHetznerSdConfigs#proxyConnectHeader
   */
  readonly proxyConnectHeader?: { [key: string]: ScrapeConfigSpecHetznerSdConfigsProxyConnectHeader[] };

  /**
   * Whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
   * If unset, Prometheus uses its default value.
   *
   *
   * It requires Prometheus >= v2.43.0.
   *
   * @schema ScrapeConfigSpecHetznerSdConfigs#proxyFromEnvironment
   */
  readonly proxyFromEnvironment?: boolean;

  /**
   * `proxyURL` defines the HTTP proxy server to use.
   *
   *
   * It requires Prometheus >= v2.43.0.
   *
   * @schema ScrapeConfigSpecHetznerSdConfigs#proxyUrl
   */
  readonly proxyUrl?: string;

  /**
   * The time after which the servers are refreshed.
   *
   * @schema ScrapeConfigSpecHetznerSdConfigs#refreshInterval
   */
  readonly refreshInterval?: string;

  /**
   * The Hetzner role of entities that should be discovered.
   *
   * @schema ScrapeConfigSpecHetznerSdConfigs#role
   */
  readonly role: ScrapeConfigSpecHetznerSdConfigsRole;

  /**
   * TLS configuration to use on every scrape request.
   *
   * @schema ScrapeConfigSpecHetznerSdConfigs#tlsConfig
   */
  readonly tlsConfig?: ScrapeConfigSpecHetznerSdConfigsTlsConfig;

}

/**
 * Converts an object of type 'ScrapeConfigSpecHetznerSdConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecHetznerSdConfigs(obj: ScrapeConfigSpecHetznerSdConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authorization': toJson_ScrapeConfigSpecHetznerSdConfigsAuthorization(obj.authorization),
    'basicAuth': toJson_ScrapeConfigSpecHetznerSdConfigsBasicAuth(obj.basicAuth),
    'enableHTTP2': obj.enableHttp2,
    'followRedirects': obj.followRedirects,
    'noProxy': obj.noProxy,
    'oauth2': toJson_ScrapeConfigSpecHetznerSdConfigsOauth2(obj.oauth2),
    'port': obj.port,
    'proxyConnectHeader': ((obj.proxyConnectHeader) === undefined) ? undefined : (Object.entries(obj.proxyConnectHeader).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.map(y => toJson_ScrapeConfigSpecHetznerSdConfigsProxyConnectHeader(y)) }), {})),
    'proxyFromEnvironment': obj.proxyFromEnvironment,
    'proxyUrl': obj.proxyUrl,
    'refreshInterval': obj.refreshInterval,
    'role': obj.role,
    'tlsConfig': toJson_ScrapeConfigSpecHetznerSdConfigsTlsConfig(obj.tlsConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPSDConfig defines a prometheus HTTP service discovery configuration
 * See https://prometheus.io/docs/prometheus/latest/configuration/configuration/#http_sd_config
 *
 * @schema ScrapeConfigSpecHttpSdConfigs
 */
export interface ScrapeConfigSpecHttpSdConfigs {
  /**
   * Authorization header configuration to authenticate against the target HTTP endpoint.
   *
   * @schema ScrapeConfigSpecHttpSdConfigs#authorization
   */
  readonly authorization?: ScrapeConfigSpecHttpSdConfigsAuthorization;

  /**
   * BasicAuth information to authenticate against the target HTTP endpoint.
   * More info: https://prometheus.io/docs/operating/configuration/#endpoints
   *
   * @schema ScrapeConfigSpecHttpSdConfigs#basicAuth
   */
  readonly basicAuth?: ScrapeConfigSpecHttpSdConfigsBasicAuth;

  /**
   * `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names
   * that should be excluded from proxying. IP and domain names can
   * contain port numbers.
   *
   *
   * It requires Prometheus >= v2.43.0.
   *
   * @schema ScrapeConfigSpecHttpSdConfigs#noProxy
   */
  readonly noProxy?: string;

  /**
   * ProxyConnectHeader optionally specifies headers to send to
   * proxies during CONNECT requests.
   *
   *
   * It requires Prometheus >= v2.43.0.
   *
   * @schema ScrapeConfigSpecHttpSdConfigs#proxyConnectHeader
   */
  readonly proxyConnectHeader?: { [key: string]: ScrapeConfigSpecHttpSdConfigsProxyConnectHeader[] };

  /**
   * Whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
   * If unset, Prometheus uses its default value.
   *
   *
   * It requires Prometheus >= v2.43.0.
   *
   * @schema ScrapeConfigSpecHttpSdConfigs#proxyFromEnvironment
   */
  readonly proxyFromEnvironment?: boolean;

  /**
   * `proxyURL` defines the HTTP proxy server to use.
   *
   *
   * It requires Prometheus >= v2.43.0.
   *
   * @schema ScrapeConfigSpecHttpSdConfigs#proxyUrl
   */
  readonly proxyUrl?: string;

  /**
   * RefreshInterval configures the refresh interval at which Prometheus will re-query the
   * endpoint to update the target list.
   *
   * @schema ScrapeConfigSpecHttpSdConfigs#refreshInterval
   */
  readonly refreshInterval?: string;

  /**
   * TLS configuration applying to the target HTTP endpoint.
   *
   * @schema ScrapeConfigSpecHttpSdConfigs#tlsConfig
   */
  readonly tlsConfig?: ScrapeConfigSpecHttpSdConfigsTlsConfig;

  /**
   * URL from which the targets are fetched.
   *
   * @schema ScrapeConfigSpecHttpSdConfigs#url
   */
  readonly url: string;

}

/**
 * Converts an object of type 'ScrapeConfigSpecHttpSdConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecHttpSdConfigs(obj: ScrapeConfigSpecHttpSdConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authorization': toJson_ScrapeConfigSpecHttpSdConfigsAuthorization(obj.authorization),
    'basicAuth': toJson_ScrapeConfigSpecHttpSdConfigsBasicAuth(obj.basicAuth),
    'noProxy': obj.noProxy,
    'proxyConnectHeader': ((obj.proxyConnectHeader) === undefined) ? undefined : (Object.entries(obj.proxyConnectHeader).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.map(y => toJson_ScrapeConfigSpecHttpSdConfigsProxyConnectHeader(y)) }), {})),
    'proxyFromEnvironment': obj.proxyFromEnvironment,
    'proxyUrl': obj.proxyUrl,
    'refreshInterval': obj.refreshInterval,
    'tlsConfig': toJson_ScrapeConfigSpecHttpSdConfigsTlsConfig(obj.tlsConfig),
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * KubernetesSDConfig allows retrieving scrape targets from Kubernetes' REST API.
 * See https://prometheus.io/docs/prometheus/latest/configuration/configuration/#kubernetes_sd_config
 *
 * @schema ScrapeConfigSpecKubernetesSdConfigs
 */
export interface ScrapeConfigSpecKubernetesSdConfigs {
  /**
   * The API server address consisting of a hostname or IP address followed
   * by an optional port number.
   * If left empty, Prometheus is assumed to run inside
   * of the cluster. It will discover API servers automatically and use the pod's
   * CA certificate and bearer token file at /var/run/secrets/kubernetes.io/serviceaccount/.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigs#apiServer
   */
  readonly apiServer?: string;

  /**
   * Optional metadata to attach to discovered targets.
   * It requires Prometheus >= v2.35.0 for `pod` role and
   * Prometheus >= v2.37.0 for `endpoints` and `endpointslice` roles.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigs#attachMetadata
   */
  readonly attachMetadata?: ScrapeConfigSpecKubernetesSdConfigsAttachMetadata;

  /**
   * Authorization header to use on every scrape request.
   * Cannot be set at the same time as `basicAuth`, or `oauth2`.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigs#authorization
   */
  readonly authorization?: ScrapeConfigSpecKubernetesSdConfigsAuthorization;

  /**
   * BasicAuth information to use on every scrape request.
   * Cannot be set at the same time as `authorization`, or `oauth2`.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigs#basicAuth
   */
  readonly basicAuth?: ScrapeConfigSpecKubernetesSdConfigsBasicAuth;

  /**
   * Whether to enable HTTP2.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigs#enableHTTP2
   */
  readonly enableHttp2?: boolean;

  /**
   * Configure whether HTTP requests follow HTTP 3xx redirects.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigs#followRedirects
   */
  readonly followRedirects?: boolean;

  /**
   * Optional namespace discovery. If omitted, Prometheus discovers targets across all namespaces.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigs#namespaces
   */
  readonly namespaces?: ScrapeConfigSpecKubernetesSdConfigsNamespaces;

  /**
   * `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names
   * that should be excluded from proxying. IP and domain names can
   * contain port numbers.
   *
   *
   * It requires Prometheus >= v2.43.0.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigs#noProxy
   */
  readonly noProxy?: string;

  /**
   * Optional OAuth 2.0 configuration.
   * Cannot be set at the same time as `authorization`, or `basicAuth`.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigs#oauth2
   */
  readonly oauth2?: ScrapeConfigSpecKubernetesSdConfigsOauth2;

  /**
   * ProxyConnectHeader optionally specifies headers to send to
   * proxies during CONNECT requests.
   *
   *
   * It requires Prometheus >= v2.43.0.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigs#proxyConnectHeader
   */
  readonly proxyConnectHeader?: { [key: string]: ScrapeConfigSpecKubernetesSdConfigsProxyConnectHeader[] };

  /**
   * Whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
   * If unset, Prometheus uses its default value.
   *
   *
   * It requires Prometheus >= v2.43.0.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigs#proxyFromEnvironment
   */
  readonly proxyFromEnvironment?: boolean;

  /**
   * `proxyURL` defines the HTTP proxy server to use.
   *
   *
   * It requires Prometheus >= v2.43.0.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigs#proxyUrl
   */
  readonly proxyUrl?: string;

  /**
   * Role of the Kubernetes entities that should be discovered.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigs#role
   */
  readonly role: ScrapeConfigSpecKubernetesSdConfigsRole;

  /**
   * Selector to select objects.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigs#selectors
   */
  readonly selectors?: ScrapeConfigSpecKubernetesSdConfigsSelectors[];

  /**
   * TLS configuration to use on every scrape request.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigs#tlsConfig
   */
  readonly tlsConfig?: ScrapeConfigSpecKubernetesSdConfigsTlsConfig;

}

/**
 * Converts an object of type 'ScrapeConfigSpecKubernetesSdConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecKubernetesSdConfigs(obj: ScrapeConfigSpecKubernetesSdConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiServer': obj.apiServer,
    'attachMetadata': toJson_ScrapeConfigSpecKubernetesSdConfigsAttachMetadata(obj.attachMetadata),
    'authorization': toJson_ScrapeConfigSpecKubernetesSdConfigsAuthorization(obj.authorization),
    'basicAuth': toJson_ScrapeConfigSpecKubernetesSdConfigsBasicAuth(obj.basicAuth),
    'enableHTTP2': obj.enableHttp2,
    'followRedirects': obj.followRedirects,
    'namespaces': toJson_ScrapeConfigSpecKubernetesSdConfigsNamespaces(obj.namespaces),
    'noProxy': obj.noProxy,
    'oauth2': toJson_ScrapeConfigSpecKubernetesSdConfigsOauth2(obj.oauth2),
    'proxyConnectHeader': ((obj.proxyConnectHeader) === undefined) ? undefined : (Object.entries(obj.proxyConnectHeader).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.map(y => toJson_ScrapeConfigSpecKubernetesSdConfigsProxyConnectHeader(y)) }), {})),
    'proxyFromEnvironment': obj.proxyFromEnvironment,
    'proxyUrl': obj.proxyUrl,
    'role': obj.role,
    'selectors': obj.selectors?.map(y => toJson_ScrapeConfigSpecKubernetesSdConfigsSelectors(y)),
    'tlsConfig': toJson_ScrapeConfigSpecKubernetesSdConfigsTlsConfig(obj.tlsConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * KumaSDConfig allow retrieving scrape targets from Kuma's control plane.
 * See https://prometheus.io/docs/prometheus/latest/configuration/configuration/#kuma_sd_config
 *
 * @schema ScrapeConfigSpecKumaSdConfigs
 */
export interface ScrapeConfigSpecKumaSdConfigs {
  /**
   * Authorization header to use on every scrape request.
   *
   * @schema ScrapeConfigSpecKumaSdConfigs#authorization
   */
  readonly authorization?: ScrapeConfigSpecKumaSdConfigsAuthorization;

  /**
   * BasicAuth information to use on every scrape request.
   *
   * @schema ScrapeConfigSpecKumaSdConfigs#basicAuth
   */
  readonly basicAuth?: ScrapeConfigSpecKumaSdConfigsBasicAuth;

  /**
   * Client id is used by Kuma Control Plane to compute Monitoring Assignment for specific Prometheus backend.
   *
   * @schema ScrapeConfigSpecKumaSdConfigs#clientID
   */
  readonly clientId?: string;

  /**
   * Whether to enable HTTP2.
   *
   * @schema ScrapeConfigSpecKumaSdConfigs#enableHTTP2
   */
  readonly enableHttp2?: boolean;

  /**
   * The time after which the monitoring assignments are refreshed.
   *
   * @schema ScrapeConfigSpecKumaSdConfigs#fetchTimeout
   */
  readonly fetchTimeout?: string;

  /**
   * Configure whether HTTP requests follow HTTP 3xx redirects.
   *
   * @schema ScrapeConfigSpecKumaSdConfigs#followRedirects
   */
  readonly followRedirects?: boolean;

  /**
   * `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names
   * that should be excluded from proxying. IP and domain names can
   * contain port numbers.
   *
   *
   * It requires Prometheus >= v2.43.0.
   *
   * @schema ScrapeConfigSpecKumaSdConfigs#noProxy
   */
  readonly noProxy?: string;

  /**
   * Optional OAuth 2.0 configuration.
   * Cannot be set at the same time as `authorization`, or `basicAuth`.
   *
   * @schema ScrapeConfigSpecKumaSdConfigs#oauth2
   */
  readonly oauth2?: ScrapeConfigSpecKumaSdConfigsOauth2;

  /**
   * ProxyConnectHeader optionally specifies headers to send to
   * proxies during CONNECT requests.
   *
   *
   * It requires Prometheus >= v2.43.0.
   *
   * @schema ScrapeConfigSpecKumaSdConfigs#proxyConnectHeader
   */
  readonly proxyConnectHeader?: { [key: string]: ScrapeConfigSpecKumaSdConfigsProxyConnectHeader[] };

  /**
   * Whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
   * If unset, Prometheus uses its default value.
   *
   *
   * It requires Prometheus >= v2.43.0.
   *
   * @schema ScrapeConfigSpecKumaSdConfigs#proxyFromEnvironment
   */
  readonly proxyFromEnvironment?: boolean;

  /**
   * `proxyURL` defines the HTTP proxy server to use.
   *
   *
   * It requires Prometheus >= v2.43.0.
   *
   * @schema ScrapeConfigSpecKumaSdConfigs#proxyUrl
   */
  readonly proxyUrl?: string;

  /**
   * The time to wait between polling update requests.
   *
   * @schema ScrapeConfigSpecKumaSdConfigs#refreshInterval
   */
  readonly refreshInterval?: string;

  /**
   * Address of the Kuma Control Plane's MADS xDS server.
   *
   * @schema ScrapeConfigSpecKumaSdConfigs#server
   */
  readonly server: string;

  /**
   * TLS configuration to use on every scrape request
   *
   * @schema ScrapeConfigSpecKumaSdConfigs#tlsConfig
   */
  readonly tlsConfig?: ScrapeConfigSpecKumaSdConfigsTlsConfig;

}

/**
 * Converts an object of type 'ScrapeConfigSpecKumaSdConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecKumaSdConfigs(obj: ScrapeConfigSpecKumaSdConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authorization': toJson_ScrapeConfigSpecKumaSdConfigsAuthorization(obj.authorization),
    'basicAuth': toJson_ScrapeConfigSpecKumaSdConfigsBasicAuth(obj.basicAuth),
    'clientID': obj.clientId,
    'enableHTTP2': obj.enableHttp2,
    'fetchTimeout': obj.fetchTimeout,
    'followRedirects': obj.followRedirects,
    'noProxy': obj.noProxy,
    'oauth2': toJson_ScrapeConfigSpecKumaSdConfigsOauth2(obj.oauth2),
    'proxyConnectHeader': ((obj.proxyConnectHeader) === undefined) ? undefined : (Object.entries(obj.proxyConnectHeader).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.map(y => toJson_ScrapeConfigSpecKumaSdConfigsProxyConnectHeader(y)) }), {})),
    'proxyFromEnvironment': obj.proxyFromEnvironment,
    'proxyUrl': obj.proxyUrl,
    'refreshInterval': obj.refreshInterval,
    'server': obj.server,
    'tlsConfig': toJson_ScrapeConfigSpecKumaSdConfigsTlsConfig(obj.tlsConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RelabelConfig allows dynamic rewriting of the label set for targets, alerts,
 * scraped samples and remote write samples.
 *
 *
 * More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
 *
 * @schema ScrapeConfigSpecMetricRelabelings
 */
export interface ScrapeConfigSpecMetricRelabelings {
  /**
   * Action to perform based on the regex matching.
   *
   *
   * `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0.
   * `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.
   *
   *
   * Default: "Replace"
   *
   * @schema ScrapeConfigSpecMetricRelabelings#action
   */
  readonly action?: ScrapeConfigSpecMetricRelabelingsAction;

  /**
   * Modulus to take of the hash of the source label values.
   *
   *
   * Only applicable when the action is `HashMod`.
   *
   * @schema ScrapeConfigSpecMetricRelabelings#modulus
   */
  readonly modulus?: number;

  /**
   * Regular expression against which the extracted value is matched.
   *
   * @schema ScrapeConfigSpecMetricRelabelings#regex
   */
  readonly regex?: string;

  /**
   * Replacement value against which a Replace action is performed if the
   * regular expression matches.
   *
   *
   * Regex capture groups are available.
   *
   * @schema ScrapeConfigSpecMetricRelabelings#replacement
   */
  readonly replacement?: string;

  /**
   * Separator is the string between concatenated SourceLabels.
   *
   * @schema ScrapeConfigSpecMetricRelabelings#separator
   */
  readonly separator?: string;

  /**
   * The source labels select values from existing labels. Their content is
   * concatenated using the configured Separator and matched against the
   * configured regular expression.
   *
   * @schema ScrapeConfigSpecMetricRelabelings#sourceLabels
   */
  readonly sourceLabels?: string[];

  /**
   * Label to which the resulting string is written in a replacement.
   *
   *
   * It is mandatory for `Replace`, `HashMod`, `Lowercase`, `Uppercase`,
   * `KeepEqual` and `DropEqual` actions.
   *
   *
   * Regex capture groups are available.
   *
   * @schema ScrapeConfigSpecMetricRelabelings#targetLabel
   */
  readonly targetLabel?: string;

}

/**
 * Converts an object of type 'ScrapeConfigSpecMetricRelabelings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecMetricRelabelings(obj: ScrapeConfigSpecMetricRelabelings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'modulus': obj.modulus,
    'regex': obj.regex,
    'replacement': obj.replacement,
    'separator': obj.separator,
    'sourceLabels': obj.sourceLabels?.map(y => y),
    'targetLabel': obj.targetLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * OpenStackSDConfig allow retrieving scrape targets from OpenStack Nova instances.
 * See https://prometheus.io/docs/prometheus/latest/configuration/configuration/#openstack_sd_config
 *
 * @schema ScrapeConfigSpecOpenstackSdConfigs
 */
export interface ScrapeConfigSpecOpenstackSdConfigs {
  /**
   * Whether the service discovery should list all instances for all projects.
   * It is only relevant for the 'instance' role and usually requires admin permissions.
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigs#allTenants
   */
  readonly allTenants?: boolean;

  /**
   * ApplicationCredentialID
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigs#applicationCredentialId
   */
  readonly applicationCredentialId?: string;

  /**
   * The ApplicationCredentialID or ApplicationCredentialName fields are
   * required if using an application credential to authenticate. Some providers
   * allow you to create an application credential to authenticate rather than a
   * password.
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigs#applicationCredentialName
   */
  readonly applicationCredentialName?: string;

  /**
   * The applicationCredentialSecret field is required if using an application
   * credential to authenticate.
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigs#applicationCredentialSecret
   */
  readonly applicationCredentialSecret?: ScrapeConfigSpecOpenstackSdConfigsApplicationCredentialSecret;

  /**
   * Availability of the endpoint to connect to.
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigs#availability
   */
  readonly availability?: ScrapeConfigSpecOpenstackSdConfigsAvailability;

  /**
   * DomainID
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigs#domainID
   */
  readonly domainId?: string;

  /**
   * At most one of domainId and domainName must be provided if using username
   * with Identity V3. Otherwise, either are optional.
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigs#domainName
   */
  readonly domainName?: string;

  /**
   * IdentityEndpoint specifies the HTTP endpoint that is required to work with
   * the Identity API of the appropriate version.
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigs#identityEndpoint
   */
  readonly identityEndpoint?: string;

  /**
   * Password for the Identity V2 and V3 APIs. Consult with your provider's
   * control panel to discover your account's preferred method of authentication.
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigs#password
   */
  readonly password?: ScrapeConfigSpecOpenstackSdConfigsPassword;

  /**
   * The port to scrape metrics from. If using the public IP address, this must
   * instead be specified in the relabeling rule.
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigs#port
   */
  readonly port?: number;

  /**
   * ProjectID
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigs#projectID
   */
  readonly projectId?: string;

  /**
   * The ProjectId and ProjectName fields are optional for the Identity V2 API.
   * Some providers allow you to specify a ProjectName instead of the ProjectId.
   * Some require both. Your provider's authentication policies will determine
   * how these fields influence authentication.
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigs#projectName
   */
  readonly projectName?: string;

  /**
   * Refresh interval to re-read the instance list.
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigs#refreshInterval
   */
  readonly refreshInterval?: string;

  /**
   * The OpenStack Region.
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigs#region
   */
  readonly region: string;

  /**
   * The OpenStack role of entities that should be discovered.
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigs#role
   */
  readonly role: ScrapeConfigSpecOpenstackSdConfigsRole;

  /**
   * TLS configuration applying to the target HTTP endpoint.
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigs#tlsConfig
   */
  readonly tlsConfig?: ScrapeConfigSpecOpenstackSdConfigsTlsConfig;

  /**
   * UserID
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigs#userid
   */
  readonly userid?: string;

  /**
   * Username is required if using Identity V2 API. Consult with your provider's
   * control panel to discover your account's username.
   * In Identity V3, either userid or a combination of username
   * and domainId or domainName are needed
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigs#username
   */
  readonly username?: string;

}

/**
 * Converts an object of type 'ScrapeConfigSpecOpenstackSdConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecOpenstackSdConfigs(obj: ScrapeConfigSpecOpenstackSdConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allTenants': obj.allTenants,
    'applicationCredentialId': obj.applicationCredentialId,
    'applicationCredentialName': obj.applicationCredentialName,
    'applicationCredentialSecret': toJson_ScrapeConfigSpecOpenstackSdConfigsApplicationCredentialSecret(obj.applicationCredentialSecret),
    'availability': obj.availability,
    'domainID': obj.domainId,
    'domainName': obj.domainName,
    'identityEndpoint': obj.identityEndpoint,
    'password': toJson_ScrapeConfigSpecOpenstackSdConfigsPassword(obj.password),
    'port': obj.port,
    'projectID': obj.projectId,
    'projectName': obj.projectName,
    'refreshInterval': obj.refreshInterval,
    'region': obj.region,
    'role': obj.role,
    'tlsConfig': toJson_ScrapeConfigSpecOpenstackSdConfigsTlsConfig(obj.tlsConfig),
    'userid': obj.userid,
    'username': obj.username,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScrapeConfigSpecProxyConnectHeader
 */
export interface ScrapeConfigSpecProxyConnectHeader {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecProxyConnectHeader#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecProxyConnectHeader#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecProxyConnectHeader#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecProxyConnectHeader' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecProxyConnectHeader(obj: ScrapeConfigSpecProxyConnectHeader | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RelabelConfig allows dynamic rewriting of the label set for targets, alerts,
 * scraped samples and remote write samples.
 *
 *
 * More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
 *
 * @schema ScrapeConfigSpecRelabelings
 */
export interface ScrapeConfigSpecRelabelings {
  /**
   * Action to perform based on the regex matching.
   *
   *
   * `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0.
   * `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.
   *
   *
   * Default: "Replace"
   *
   * @schema ScrapeConfigSpecRelabelings#action
   */
  readonly action?: ScrapeConfigSpecRelabelingsAction;

  /**
   * Modulus to take of the hash of the source label values.
   *
   *
   * Only applicable when the action is `HashMod`.
   *
   * @schema ScrapeConfigSpecRelabelings#modulus
   */
  readonly modulus?: number;

  /**
   * Regular expression against which the extracted value is matched.
   *
   * @schema ScrapeConfigSpecRelabelings#regex
   */
  readonly regex?: string;

  /**
   * Replacement value against which a Replace action is performed if the
   * regular expression matches.
   *
   *
   * Regex capture groups are available.
   *
   * @schema ScrapeConfigSpecRelabelings#replacement
   */
  readonly replacement?: string;

  /**
   * Separator is the string between concatenated SourceLabels.
   *
   * @schema ScrapeConfigSpecRelabelings#separator
   */
  readonly separator?: string;

  /**
   * The source labels select values from existing labels. Their content is
   * concatenated using the configured Separator and matched against the
   * configured regular expression.
   *
   * @schema ScrapeConfigSpecRelabelings#sourceLabels
   */
  readonly sourceLabels?: string[];

  /**
   * Label to which the resulting string is written in a replacement.
   *
   *
   * It is mandatory for `Replace`, `HashMod`, `Lowercase`, `Uppercase`,
   * `KeepEqual` and `DropEqual` actions.
   *
   *
   * Regex capture groups are available.
   *
   * @schema ScrapeConfigSpecRelabelings#targetLabel
   */
  readonly targetLabel?: string;

}

/**
 * Converts an object of type 'ScrapeConfigSpecRelabelings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecRelabelings(obj: ScrapeConfigSpecRelabelings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'modulus': obj.modulus,
    'regex': obj.regex,
    'replacement': obj.replacement,
    'separator': obj.separator,
    'sourceLabels': obj.sourceLabels?.map(y => y),
    'targetLabel': obj.targetLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configures the protocol scheme used for requests.
 * If empty, Prometheus uses HTTP by default.
 *
 * @schema ScrapeConfigSpecScheme
 */
export enum ScrapeConfigSpecScheme {
  /** HTTP */
  HTTP = "HTTP",
  /** HTTPS */
  HTTPS = "HTTPS",
}

/**
 * ScrapeProtocol represents a protocol used by Prometheus for scraping metrics.
 * Supported values are:
 * * `OpenMetricsText0.0.1`
 * * `OpenMetricsText1.0.0`
 * * `PrometheusProto`
 * * `PrometheusText0.0.4`
 *
 * @schema ScrapeConfigSpecScrapeProtocols
 */
export enum ScrapeConfigSpecScrapeProtocols {
  /** PrometheusProto */
  PROMETHEUS_PROTO = "PrometheusProto",
  /** OpenMetricsText0.0.1 */
  OPEN_METRICS_TEXT0_0_1 = "OpenMetricsText0.0.1",
  /** OpenMetricsText1.0.0 */
  OPEN_METRICS_TEXT1_0_0 = "OpenMetricsText1.0.0",
  /** PrometheusText0.0.4 */
  PROMETHEUS_TEXT0_0_4 = "PrometheusText0.0.4",
}

/**
 * StaticConfig defines a Prometheus static configuration.
 * See https://prometheus.io/docs/prometheus/latest/configuration/configuration/#scrape_config
 *
 * @schema ScrapeConfigSpecStaticConfigs
 */
export interface ScrapeConfigSpecStaticConfigs {
  /**
   * Labels assigned to all metrics scraped from the targets.
   *
   * @schema ScrapeConfigSpecStaticConfigs#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * List of targets for this static configuration.
   *
   * @schema ScrapeConfigSpecStaticConfigs#targets
   */
  readonly targets?: string[];

}

/**
 * Converts an object of type 'ScrapeConfigSpecStaticConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecStaticConfigs(obj: ScrapeConfigSpecStaticConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'targets': obj.targets?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLS configuration to use on every scrape request
 *
 * @schema ScrapeConfigSpecTlsConfig
 */
export interface ScrapeConfigSpecTlsConfig {
  /**
   * Certificate authority used when verifying server certificates.
   *
   * @schema ScrapeConfigSpecTlsConfig#ca
   */
  readonly ca?: ScrapeConfigSpecTlsConfigCa;

  /**
   * Client certificate to present when doing client-authentication.
   *
   * @schema ScrapeConfigSpecTlsConfig#cert
   */
  readonly cert?: ScrapeConfigSpecTlsConfigCert;

  /**
   * Disable target certificate validation.
   *
   * @schema ScrapeConfigSpecTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema ScrapeConfigSpecTlsConfig#keySecret
   */
  readonly keySecret?: ScrapeConfigSpecTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema ScrapeConfigSpecTlsConfig#serverName
   */
  readonly serverName?: string;

}

/**
 * Converts an object of type 'ScrapeConfigSpecTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecTlsConfig(obj: ScrapeConfigSpecTlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ca': toJson_ScrapeConfigSpecTlsConfigCa(obj.ca),
    'cert': toJson_ScrapeConfigSpecTlsConfigCert(obj.cert),
    'insecureSkipVerify': obj.insecureSkipVerify,
    'keySecret': toJson_ScrapeConfigSpecTlsConfigKeySecret(obj.keySecret),
    'serverName': obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Authorization header to use on every scrape request.
 *
 * @schema ScrapeConfigSpecNomadSdConfigsAuthorization
 */
export interface ScrapeConfigSpecNomadSdConfigsAuthorization {
  /**
   * Selects a key of a Secret in the namespace that contains the credentials for authentication.
   *
   * @schema ScrapeConfigSpecNomadSdConfigsAuthorization#credentials
   */
  readonly credentials?: ScrapeConfigSpecNomadSdConfigsAuthorizationCredentials;

  /**
   * Defines the authentication type. The value is case-insensitive.
   *
   *
   * "Basic" is not a supported value.
   *
   *
   * Default: "Bearer"
   *
   * @schema ScrapeConfigSpecNomadSdConfigsAuthorization#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ScrapeConfigSpecNomadSdConfigsAuthorization' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecNomadSdConfigsAuthorization(obj: ScrapeConfigSpecNomadSdConfigsAuthorization | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentials': toJson_ScrapeConfigSpecNomadSdConfigsAuthorizationCredentials(obj.credentials),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BasicAuth information to use on every scrape request.
 *
 * @schema ScrapeConfigSpecNomadSdConfigsBasicAuth
 */
export interface ScrapeConfigSpecNomadSdConfigsBasicAuth {
  /**
   * `password` specifies a key of a Secret containing the password for
   * authentication.
   *
   * @schema ScrapeConfigSpecNomadSdConfigsBasicAuth#password
   */
  readonly password?: ScrapeConfigSpecNomadSdConfigsBasicAuthPassword;

  /**
   * `username` specifies a key of a Secret containing the username for
   * authentication.
   *
   * @schema ScrapeConfigSpecNomadSdConfigsBasicAuth#username
   */
  readonly username?: ScrapeConfigSpecNomadSdConfigsBasicAuthUsername;

}

/**
 * Converts an object of type 'ScrapeConfigSpecNomadSdConfigsBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecNomadSdConfigsBasicAuth(obj: ScrapeConfigSpecNomadSdConfigsBasicAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_ScrapeConfigSpecNomadSdConfigsBasicAuthPassword(obj.password),
    'username': toJson_ScrapeConfigSpecNomadSdConfigsBasicAuthUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Optional OAuth 2.0 configuration.
 * Cannot be set at the same time as `authorization` or `basic_auth`.
 *
 * @schema ScrapeConfigSpecNomadSdConfigsOauth2
 */
export interface ScrapeConfigSpecNomadSdConfigsOauth2 {
  /**
   * `clientId` specifies a key of a Secret or ConfigMap containing the
   * OAuth2 client's ID.
   *
   * @schema ScrapeConfigSpecNomadSdConfigsOauth2#clientId
   */
  readonly clientId: ScrapeConfigSpecNomadSdConfigsOauth2ClientId;

  /**
   * `clientSecret` specifies a key of a Secret containing the OAuth2
   * client's secret.
   *
   * @schema ScrapeConfigSpecNomadSdConfigsOauth2#clientSecret
   */
  readonly clientSecret: ScrapeConfigSpecNomadSdConfigsOauth2ClientSecret;

  /**
   * `endpointParams` configures the HTTP parameters to append to the token
   * URL.
   *
   * @schema ScrapeConfigSpecNomadSdConfigsOauth2#endpointParams
   */
  readonly endpointParams?: { [key: string]: string };

  /**
   * `scopes` defines the OAuth2 scopes used for the token request.
   *
   * @schema ScrapeConfigSpecNomadSdConfigsOauth2#scopes
   */
  readonly scopes?: string[];

  /**
   * `tokenURL` configures the URL to fetch the token from.
   *
   * @schema ScrapeConfigSpecNomadSdConfigsOauth2#tokenUrl
   */
  readonly tokenUrl: string;

}

/**
 * Converts an object of type 'ScrapeConfigSpecNomadSdConfigsOauth2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecNomadSdConfigsOauth2(obj: ScrapeConfigSpecNomadSdConfigsOauth2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientId': toJson_ScrapeConfigSpecNomadSdConfigsOauth2ClientId(obj.clientId),
    'clientSecret': toJson_ScrapeConfigSpecNomadSdConfigsOauth2ClientSecret(obj.clientSecret),
    'endpointParams': ((obj.endpointParams) === undefined) ? undefined : (Object.entries(obj.endpointParams).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'scopes': obj.scopes?.map(y => y),
    'tokenUrl': obj.tokenUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScrapeConfigSpecNomadSdConfigsProxyConnectHeader
 */
export interface ScrapeConfigSpecNomadSdConfigsProxyConnectHeader {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecNomadSdConfigsProxyConnectHeader#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecNomadSdConfigsProxyConnectHeader#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecNomadSdConfigsProxyConnectHeader#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecNomadSdConfigsProxyConnectHeader' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecNomadSdConfigsProxyConnectHeader(obj: ScrapeConfigSpecNomadSdConfigsProxyConnectHeader | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLS configuration applying to the target HTTP endpoint.
 *
 * @schema ScrapeConfigSpecNomadSdConfigsTlsConfig
 */
export interface ScrapeConfigSpecNomadSdConfigsTlsConfig {
  /**
   * Certificate authority used when verifying server certificates.
   *
   * @schema ScrapeConfigSpecNomadSdConfigsTlsConfig#ca
   */
  readonly ca?: ScrapeConfigSpecNomadSdConfigsTlsConfigCa;

  /**
   * Client certificate to present when doing client-authentication.
   *
   * @schema ScrapeConfigSpecNomadSdConfigsTlsConfig#cert
   */
  readonly cert?: ScrapeConfigSpecNomadSdConfigsTlsConfigCert;

  /**
   * Disable target certificate validation.
   *
   * @schema ScrapeConfigSpecNomadSdConfigsTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema ScrapeConfigSpecNomadSdConfigsTlsConfig#keySecret
   */
  readonly keySecret?: ScrapeConfigSpecNomadSdConfigsTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema ScrapeConfigSpecNomadSdConfigsTlsConfig#serverName
   */
  readonly serverName?: string;

}

/**
 * Converts an object of type 'ScrapeConfigSpecNomadSdConfigsTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecNomadSdConfigsTlsConfig(obj: ScrapeConfigSpecNomadSdConfigsTlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ca': toJson_ScrapeConfigSpecNomadSdConfigsTlsConfigCa(obj.ca),
    'cert': toJson_ScrapeConfigSpecNomadSdConfigsTlsConfigCert(obj.cert),
    'insecureSkipVerify': obj.insecureSkipVerify,
    'keySecret': toJson_ScrapeConfigSpecNomadSdConfigsTlsConfigKeySecret(obj.keySecret),
    'serverName': obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a Secret in the namespace that contains the credentials for authentication.
 *
 * @schema ScrapeConfigSpecAuthorizationCredentials
 */
export interface ScrapeConfigSpecAuthorizationCredentials {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecAuthorizationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecAuthorizationCredentials#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecAuthorizationCredentials#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecAuthorizationCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecAuthorizationCredentials(obj: ScrapeConfigSpecAuthorizationCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * # The authentication method, either `OAuth` or `ManagedIdentity` or `SDK`.
 * See https://docs.microsoft.com/en-us/azure/active-directory/managed-identities-azure-resources/overview
 * SDK authentication method uses environment variables by default.
 * See https://learn.microsoft.com/en-us/azure/developer/go/azure-sdk-authentication
 *
 * @schema ScrapeConfigSpecAzureSdConfigsAuthenticationMethod
 */
export enum ScrapeConfigSpecAzureSdConfigsAuthenticationMethod {
  /** OAuth */
  O_AUTH = "OAuth",
  /** ManagedIdentity */
  MANAGED_IDENTITY = "ManagedIdentity",
  /** SDK */
  SDK = "SDK",
}

/**
 * Optional client secret. Only required with the OAuth authentication method.
 *
 * @schema ScrapeConfigSpecAzureSdConfigsClientSecret
 */
export interface ScrapeConfigSpecAzureSdConfigsClientSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecAzureSdConfigsClientSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecAzureSdConfigsClientSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecAzureSdConfigsClientSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecAzureSdConfigsClientSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecAzureSdConfigsClientSecret(obj: ScrapeConfigSpecAzureSdConfigsClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `password` specifies a key of a Secret containing the password for
 * authentication.
 *
 * @schema ScrapeConfigSpecBasicAuthPassword
 */
export interface ScrapeConfigSpecBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecBasicAuthPassword#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecBasicAuthPassword(obj: ScrapeConfigSpecBasicAuthPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `username` specifies a key of a Secret containing the username for
 * authentication.
 *
 * @schema ScrapeConfigSpecBasicAuthUsername
 */
export interface ScrapeConfigSpecBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecBasicAuthUsername#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecBasicAuthUsername(obj: ScrapeConfigSpecBasicAuthUsername | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Authorization header configuration to authenticate against the Consul Server.
 *
 * @schema ScrapeConfigSpecConsulSdConfigsAuthorization
 */
export interface ScrapeConfigSpecConsulSdConfigsAuthorization {
  /**
   * Selects a key of a Secret in the namespace that contains the credentials for authentication.
   *
   * @schema ScrapeConfigSpecConsulSdConfigsAuthorization#credentials
   */
  readonly credentials?: ScrapeConfigSpecConsulSdConfigsAuthorizationCredentials;

  /**
   * Defines the authentication type. The value is case-insensitive.
   *
   *
   * "Basic" is not a supported value.
   *
   *
   * Default: "Bearer"
   *
   * @schema ScrapeConfigSpecConsulSdConfigsAuthorization#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ScrapeConfigSpecConsulSdConfigsAuthorization' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecConsulSdConfigsAuthorization(obj: ScrapeConfigSpecConsulSdConfigsAuthorization | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentials': toJson_ScrapeConfigSpecConsulSdConfigsAuthorizationCredentials(obj.credentials),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BasicAuth information to authenticate against the Consul Server.
 * More info: https://prometheus.io/docs/operating/configuration/#endpoints
 *
 * @schema ScrapeConfigSpecConsulSdConfigsBasicAuth
 */
export interface ScrapeConfigSpecConsulSdConfigsBasicAuth {
  /**
   * `password` specifies a key of a Secret containing the password for
   * authentication.
   *
   * @schema ScrapeConfigSpecConsulSdConfigsBasicAuth#password
   */
  readonly password?: ScrapeConfigSpecConsulSdConfigsBasicAuthPassword;

  /**
   * `username` specifies a key of a Secret containing the username for
   * authentication.
   *
   * @schema ScrapeConfigSpecConsulSdConfigsBasicAuth#username
   */
  readonly username?: ScrapeConfigSpecConsulSdConfigsBasicAuthUsername;

}

/**
 * Converts an object of type 'ScrapeConfigSpecConsulSdConfigsBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecConsulSdConfigsBasicAuth(obj: ScrapeConfigSpecConsulSdConfigsBasicAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_ScrapeConfigSpecConsulSdConfigsBasicAuthPassword(obj.password),
    'username': toJson_ScrapeConfigSpecConsulSdConfigsBasicAuthUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Optional OAuth 2.0 configuration.
 *
 * @schema ScrapeConfigSpecConsulSdConfigsOauth2
 */
export interface ScrapeConfigSpecConsulSdConfigsOauth2 {
  /**
   * `clientId` specifies a key of a Secret or ConfigMap containing the
   * OAuth2 client's ID.
   *
   * @schema ScrapeConfigSpecConsulSdConfigsOauth2#clientId
   */
  readonly clientId: ScrapeConfigSpecConsulSdConfigsOauth2ClientId;

  /**
   * `clientSecret` specifies a key of a Secret containing the OAuth2
   * client's secret.
   *
   * @schema ScrapeConfigSpecConsulSdConfigsOauth2#clientSecret
   */
  readonly clientSecret: ScrapeConfigSpecConsulSdConfigsOauth2ClientSecret;

  /**
   * `endpointParams` configures the HTTP parameters to append to the token
   * URL.
   *
   * @schema ScrapeConfigSpecConsulSdConfigsOauth2#endpointParams
   */
  readonly endpointParams?: { [key: string]: string };

  /**
   * `scopes` defines the OAuth2 scopes used for the token request.
   *
   * @schema ScrapeConfigSpecConsulSdConfigsOauth2#scopes
   */
  readonly scopes?: string[];

  /**
   * `tokenURL` configures the URL to fetch the token from.
   *
   * @schema ScrapeConfigSpecConsulSdConfigsOauth2#tokenUrl
   */
  readonly tokenUrl: string;

}

/**
 * Converts an object of type 'ScrapeConfigSpecConsulSdConfigsOauth2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecConsulSdConfigsOauth2(obj: ScrapeConfigSpecConsulSdConfigsOauth2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientId': toJson_ScrapeConfigSpecConsulSdConfigsOauth2ClientId(obj.clientId),
    'clientSecret': toJson_ScrapeConfigSpecConsulSdConfigsOauth2ClientSecret(obj.clientSecret),
    'endpointParams': ((obj.endpointParams) === undefined) ? undefined : (Object.entries(obj.endpointParams).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'scopes': obj.scopes?.map(y => y),
    'tokenUrl': obj.tokenUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScrapeConfigSpecConsulSdConfigsProxyConnectHeader
 */
export interface ScrapeConfigSpecConsulSdConfigsProxyConnectHeader {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecConsulSdConfigsProxyConnectHeader#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecConsulSdConfigsProxyConnectHeader#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecConsulSdConfigsProxyConnectHeader#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecConsulSdConfigsProxyConnectHeader' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecConsulSdConfigsProxyConnectHeader(obj: ScrapeConfigSpecConsulSdConfigsProxyConnectHeader | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTP Scheme default "http"
 *
 * @schema ScrapeConfigSpecConsulSdConfigsScheme
 */
export enum ScrapeConfigSpecConsulSdConfigsScheme {
  /** HTTP */
  HTTP = "HTTP",
  /** HTTPS */
  HTTPS = "HTTPS",
}

/**
 * TLS Config
 *
 * @schema ScrapeConfigSpecConsulSdConfigsTlsConfig
 */
export interface ScrapeConfigSpecConsulSdConfigsTlsConfig {
  /**
   * Certificate authority used when verifying server certificates.
   *
   * @schema ScrapeConfigSpecConsulSdConfigsTlsConfig#ca
   */
  readonly ca?: ScrapeConfigSpecConsulSdConfigsTlsConfigCa;

  /**
   * Client certificate to present when doing client-authentication.
   *
   * @schema ScrapeConfigSpecConsulSdConfigsTlsConfig#cert
   */
  readonly cert?: ScrapeConfigSpecConsulSdConfigsTlsConfigCert;

  /**
   * Disable target certificate validation.
   *
   * @schema ScrapeConfigSpecConsulSdConfigsTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema ScrapeConfigSpecConsulSdConfigsTlsConfig#keySecret
   */
  readonly keySecret?: ScrapeConfigSpecConsulSdConfigsTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema ScrapeConfigSpecConsulSdConfigsTlsConfig#serverName
   */
  readonly serverName?: string;

}

/**
 * Converts an object of type 'ScrapeConfigSpecConsulSdConfigsTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecConsulSdConfigsTlsConfig(obj: ScrapeConfigSpecConsulSdConfigsTlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ca': toJson_ScrapeConfigSpecConsulSdConfigsTlsConfigCa(obj.ca),
    'cert': toJson_ScrapeConfigSpecConsulSdConfigsTlsConfigCert(obj.cert),
    'insecureSkipVerify': obj.insecureSkipVerify,
    'keySecret': toJson_ScrapeConfigSpecConsulSdConfigsTlsConfigKeySecret(obj.keySecret),
    'serverName': obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Consul ACL TokenRef, if not provided it will use the ACL from the local Consul Agent.
 *
 * @schema ScrapeConfigSpecConsulSdConfigsTokenRef
 */
export interface ScrapeConfigSpecConsulSdConfigsTokenRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecConsulSdConfigsTokenRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecConsulSdConfigsTokenRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecConsulSdConfigsTokenRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecConsulSdConfigsTokenRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecConsulSdConfigsTokenRef(obj: ScrapeConfigSpecConsulSdConfigsTokenRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Authorization header configuration to authenticate against the DigitalOcean API.
 * Cannot be set at the same time as `oauth2`.
 *
 * @schema ScrapeConfigSpecDigitalOceanSdConfigsAuthorization
 */
export interface ScrapeConfigSpecDigitalOceanSdConfigsAuthorization {
  /**
   * Selects a key of a Secret in the namespace that contains the credentials for authentication.
   *
   * @schema ScrapeConfigSpecDigitalOceanSdConfigsAuthorization#credentials
   */
  readonly credentials?: ScrapeConfigSpecDigitalOceanSdConfigsAuthorizationCredentials;

  /**
   * Defines the authentication type. The value is case-insensitive.
   *
   *
   * "Basic" is not a supported value.
   *
   *
   * Default: "Bearer"
   *
   * @schema ScrapeConfigSpecDigitalOceanSdConfigsAuthorization#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ScrapeConfigSpecDigitalOceanSdConfigsAuthorization' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecDigitalOceanSdConfigsAuthorization(obj: ScrapeConfigSpecDigitalOceanSdConfigsAuthorization | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentials': toJson_ScrapeConfigSpecDigitalOceanSdConfigsAuthorizationCredentials(obj.credentials),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Optional OAuth 2.0 configuration.
 * Cannot be set at the same time as `authorization`.
 *
 * @schema ScrapeConfigSpecDigitalOceanSdConfigsOauth2
 */
export interface ScrapeConfigSpecDigitalOceanSdConfigsOauth2 {
  /**
   * `clientId` specifies a key of a Secret or ConfigMap containing the
   * OAuth2 client's ID.
   *
   * @schema ScrapeConfigSpecDigitalOceanSdConfigsOauth2#clientId
   */
  readonly clientId: ScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientId;

  /**
   * `clientSecret` specifies a key of a Secret containing the OAuth2
   * client's secret.
   *
   * @schema ScrapeConfigSpecDigitalOceanSdConfigsOauth2#clientSecret
   */
  readonly clientSecret: ScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientSecret;

  /**
   * `endpointParams` configures the HTTP parameters to append to the token
   * URL.
   *
   * @schema ScrapeConfigSpecDigitalOceanSdConfigsOauth2#endpointParams
   */
  readonly endpointParams?: { [key: string]: string };

  /**
   * `scopes` defines the OAuth2 scopes used for the token request.
   *
   * @schema ScrapeConfigSpecDigitalOceanSdConfigsOauth2#scopes
   */
  readonly scopes?: string[];

  /**
   * `tokenURL` configures the URL to fetch the token from.
   *
   * @schema ScrapeConfigSpecDigitalOceanSdConfigsOauth2#tokenUrl
   */
  readonly tokenUrl: string;

}

/**
 * Converts an object of type 'ScrapeConfigSpecDigitalOceanSdConfigsOauth2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecDigitalOceanSdConfigsOauth2(obj: ScrapeConfigSpecDigitalOceanSdConfigsOauth2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientId': toJson_ScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientId(obj.clientId),
    'clientSecret': toJson_ScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientSecret(obj.clientSecret),
    'endpointParams': ((obj.endpointParams) === undefined) ? undefined : (Object.entries(obj.endpointParams).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'scopes': obj.scopes?.map(y => y),
    'tokenUrl': obj.tokenUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScrapeConfigSpecDigitalOceanSdConfigsProxyConnectHeader
 */
export interface ScrapeConfigSpecDigitalOceanSdConfigsProxyConnectHeader {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecDigitalOceanSdConfigsProxyConnectHeader#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecDigitalOceanSdConfigsProxyConnectHeader#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecDigitalOceanSdConfigsProxyConnectHeader#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecDigitalOceanSdConfigsProxyConnectHeader' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecDigitalOceanSdConfigsProxyConnectHeader(obj: ScrapeConfigSpecDigitalOceanSdConfigsProxyConnectHeader | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLS configuration applying to the target HTTP endpoint.
 *
 * @schema ScrapeConfigSpecDigitalOceanSdConfigsTlsConfig
 */
export interface ScrapeConfigSpecDigitalOceanSdConfigsTlsConfig {
  /**
   * Certificate authority used when verifying server certificates.
   *
   * @schema ScrapeConfigSpecDigitalOceanSdConfigsTlsConfig#ca
   */
  readonly ca?: ScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCa;

  /**
   * Client certificate to present when doing client-authentication.
   *
   * @schema ScrapeConfigSpecDigitalOceanSdConfigsTlsConfig#cert
   */
  readonly cert?: ScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCert;

  /**
   * Disable target certificate validation.
   *
   * @schema ScrapeConfigSpecDigitalOceanSdConfigsTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema ScrapeConfigSpecDigitalOceanSdConfigsTlsConfig#keySecret
   */
  readonly keySecret?: ScrapeConfigSpecDigitalOceanSdConfigsTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema ScrapeConfigSpecDigitalOceanSdConfigsTlsConfig#serverName
   */
  readonly serverName?: string;

}

/**
 * Converts an object of type 'ScrapeConfigSpecDigitalOceanSdConfigsTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecDigitalOceanSdConfigsTlsConfig(obj: ScrapeConfigSpecDigitalOceanSdConfigsTlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ca': toJson_ScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCa(obj.ca),
    'cert': toJson_ScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCert(obj.cert),
    'insecureSkipVerify': obj.insecureSkipVerify,
    'keySecret': toJson_ScrapeConfigSpecDigitalOceanSdConfigsTlsConfigKeySecret(obj.keySecret),
    'serverName': obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The type of DNS query to perform. One of SRV, A, AAAA, MX or NS.
 * If not set, Prometheus uses its default value.
 *
 *
 * When set to NS, It requires Prometheus >= 2.49.0.
 *
 * @schema ScrapeConfigSpecDnsSdConfigsType
 */
export enum ScrapeConfigSpecDnsSdConfigsType {
  /** SRV */
  SRV = "SRV",
  /** A */
  A = "A",
  /** AAAA */
  AAAA = "AAAA",
  /** MX */
  MX = "MX",
  /** NS */
  NS = "NS",
}

/**
 * Authorization header configuration to authenticate against the Docker API.
 * Cannot be set at the same time as `oauth2`.
 *
 * @schema ScrapeConfigSpecDockerSdConfigsAuthorization
 */
export interface ScrapeConfigSpecDockerSdConfigsAuthorization {
  /**
   * Selects a key of a Secret in the namespace that contains the credentials for authentication.
   *
   * @schema ScrapeConfigSpecDockerSdConfigsAuthorization#credentials
   */
  readonly credentials?: ScrapeConfigSpecDockerSdConfigsAuthorizationCredentials;

  /**
   * Defines the authentication type. The value is case-insensitive.
   *
   *
   * "Basic" is not a supported value.
   *
   *
   * Default: "Bearer"
   *
   * @schema ScrapeConfigSpecDockerSdConfigsAuthorization#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ScrapeConfigSpecDockerSdConfigsAuthorization' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecDockerSdConfigsAuthorization(obj: ScrapeConfigSpecDockerSdConfigsAuthorization | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentials': toJson_ScrapeConfigSpecDockerSdConfigsAuthorizationCredentials(obj.credentials),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BasicAuth information to use on every scrape request.
 *
 * @schema ScrapeConfigSpecDockerSdConfigsBasicAuth
 */
export interface ScrapeConfigSpecDockerSdConfigsBasicAuth {
  /**
   * `password` specifies a key of a Secret containing the password for
   * authentication.
   *
   * @schema ScrapeConfigSpecDockerSdConfigsBasicAuth#password
   */
  readonly password?: ScrapeConfigSpecDockerSdConfigsBasicAuthPassword;

  /**
   * `username` specifies a key of a Secret containing the username for
   * authentication.
   *
   * @schema ScrapeConfigSpecDockerSdConfigsBasicAuth#username
   */
  readonly username?: ScrapeConfigSpecDockerSdConfigsBasicAuthUsername;

}

/**
 * Converts an object of type 'ScrapeConfigSpecDockerSdConfigsBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecDockerSdConfigsBasicAuth(obj: ScrapeConfigSpecDockerSdConfigsBasicAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_ScrapeConfigSpecDockerSdConfigsBasicAuthPassword(obj.password),
    'username': toJson_ScrapeConfigSpecDockerSdConfigsBasicAuthUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DockerFilter is the configuration to limit the discovery process to a subset of available resources.
 *
 * @schema ScrapeConfigSpecDockerSdConfigsFilters
 */
export interface ScrapeConfigSpecDockerSdConfigsFilters {
  /**
   * @schema ScrapeConfigSpecDockerSdConfigsFilters#name
   */
  readonly name: string;

  /**
   * @schema ScrapeConfigSpecDockerSdConfigsFilters#values
   */
  readonly values: string[];

}

/**
 * Converts an object of type 'ScrapeConfigSpecDockerSdConfigsFilters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecDockerSdConfigsFilters(obj: ScrapeConfigSpecDockerSdConfigsFilters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Optional OAuth 2.0 configuration.
 * Cannot be set at the same time as `authorization`.
 *
 * @schema ScrapeConfigSpecDockerSdConfigsOauth2
 */
export interface ScrapeConfigSpecDockerSdConfigsOauth2 {
  /**
   * `clientId` specifies a key of a Secret or ConfigMap containing the
   * OAuth2 client's ID.
   *
   * @schema ScrapeConfigSpecDockerSdConfigsOauth2#clientId
   */
  readonly clientId: ScrapeConfigSpecDockerSdConfigsOauth2ClientId;

  /**
   * `clientSecret` specifies a key of a Secret containing the OAuth2
   * client's secret.
   *
   * @schema ScrapeConfigSpecDockerSdConfigsOauth2#clientSecret
   */
  readonly clientSecret: ScrapeConfigSpecDockerSdConfigsOauth2ClientSecret;

  /**
   * `endpointParams` configures the HTTP parameters to append to the token
   * URL.
   *
   * @schema ScrapeConfigSpecDockerSdConfigsOauth2#endpointParams
   */
  readonly endpointParams?: { [key: string]: string };

  /**
   * `scopes` defines the OAuth2 scopes used for the token request.
   *
   * @schema ScrapeConfigSpecDockerSdConfigsOauth2#scopes
   */
  readonly scopes?: string[];

  /**
   * `tokenURL` configures the URL to fetch the token from.
   *
   * @schema ScrapeConfigSpecDockerSdConfigsOauth2#tokenUrl
   */
  readonly tokenUrl: string;

}

/**
 * Converts an object of type 'ScrapeConfigSpecDockerSdConfigsOauth2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecDockerSdConfigsOauth2(obj: ScrapeConfigSpecDockerSdConfigsOauth2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientId': toJson_ScrapeConfigSpecDockerSdConfigsOauth2ClientId(obj.clientId),
    'clientSecret': toJson_ScrapeConfigSpecDockerSdConfigsOauth2ClientSecret(obj.clientSecret),
    'endpointParams': ((obj.endpointParams) === undefined) ? undefined : (Object.entries(obj.endpointParams).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'scopes': obj.scopes?.map(y => y),
    'tokenUrl': obj.tokenUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScrapeConfigSpecDockerSdConfigsProxyConnectHeader
 */
export interface ScrapeConfigSpecDockerSdConfigsProxyConnectHeader {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecDockerSdConfigsProxyConnectHeader#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecDockerSdConfigsProxyConnectHeader#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecDockerSdConfigsProxyConnectHeader#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecDockerSdConfigsProxyConnectHeader' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecDockerSdConfigsProxyConnectHeader(obj: ScrapeConfigSpecDockerSdConfigsProxyConnectHeader | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLS configuration applying to the target HTTP endpoint.
 *
 * @schema ScrapeConfigSpecDockerSdConfigsTlsConfig
 */
export interface ScrapeConfigSpecDockerSdConfigsTlsConfig {
  /**
   * Certificate authority used when verifying server certificates.
   *
   * @schema ScrapeConfigSpecDockerSdConfigsTlsConfig#ca
   */
  readonly ca?: ScrapeConfigSpecDockerSdConfigsTlsConfigCa;

  /**
   * Client certificate to present when doing client-authentication.
   *
   * @schema ScrapeConfigSpecDockerSdConfigsTlsConfig#cert
   */
  readonly cert?: ScrapeConfigSpecDockerSdConfigsTlsConfigCert;

  /**
   * Disable target certificate validation.
   *
   * @schema ScrapeConfigSpecDockerSdConfigsTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema ScrapeConfigSpecDockerSdConfigsTlsConfig#keySecret
   */
  readonly keySecret?: ScrapeConfigSpecDockerSdConfigsTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema ScrapeConfigSpecDockerSdConfigsTlsConfig#serverName
   */
  readonly serverName?: string;

}

/**
 * Converts an object of type 'ScrapeConfigSpecDockerSdConfigsTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecDockerSdConfigsTlsConfig(obj: ScrapeConfigSpecDockerSdConfigsTlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ca': toJson_ScrapeConfigSpecDockerSdConfigsTlsConfigCa(obj.ca),
    'cert': toJson_ScrapeConfigSpecDockerSdConfigsTlsConfigCert(obj.cert),
    'insecureSkipVerify': obj.insecureSkipVerify,
    'keySecret': toJson_ScrapeConfigSpecDockerSdConfigsTlsConfigKeySecret(obj.keySecret),
    'serverName': obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AccessKey is the AWS API key.
 *
 * @schema ScrapeConfigSpecEc2SdConfigsAccessKey
 */
export interface ScrapeConfigSpecEc2SdConfigsAccessKey {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecEc2SdConfigsAccessKey#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecEc2SdConfigsAccessKey#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecEc2SdConfigsAccessKey#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecEc2SdConfigsAccessKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecEc2SdConfigsAccessKey(obj: ScrapeConfigSpecEc2SdConfigsAccessKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EC2Filter is the configuration for filtering EC2 instances.
 *
 * @schema ScrapeConfigSpecEc2SdConfigsFilters
 */
export interface ScrapeConfigSpecEc2SdConfigsFilters {
  /**
   * @schema ScrapeConfigSpecEc2SdConfigsFilters#name
   */
  readonly name: string;

  /**
   * @schema ScrapeConfigSpecEc2SdConfigsFilters#values
   */
  readonly values: string[];

}

/**
 * Converts an object of type 'ScrapeConfigSpecEc2SdConfigsFilters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecEc2SdConfigsFilters(obj: ScrapeConfigSpecEc2SdConfigsFilters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKey is the AWS API secret.
 *
 * @schema ScrapeConfigSpecEc2SdConfigsSecretKey
 */
export interface ScrapeConfigSpecEc2SdConfigsSecretKey {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecEc2SdConfigsSecretKey#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecEc2SdConfigsSecretKey#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecEc2SdConfigsSecretKey#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecEc2SdConfigsSecretKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecEc2SdConfigsSecretKey(obj: ScrapeConfigSpecEc2SdConfigsSecretKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Authorization header to use on every scrape request.
 *
 * @schema ScrapeConfigSpecEurekaSdConfigsAuthorization
 */
export interface ScrapeConfigSpecEurekaSdConfigsAuthorization {
  /**
   * Selects a key of a Secret in the namespace that contains the credentials for authentication.
   *
   * @schema ScrapeConfigSpecEurekaSdConfigsAuthorization#credentials
   */
  readonly credentials?: ScrapeConfigSpecEurekaSdConfigsAuthorizationCredentials;

  /**
   * Defines the authentication type. The value is case-insensitive.
   *
   *
   * "Basic" is not a supported value.
   *
   *
   * Default: "Bearer"
   *
   * @schema ScrapeConfigSpecEurekaSdConfigsAuthorization#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ScrapeConfigSpecEurekaSdConfigsAuthorization' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecEurekaSdConfigsAuthorization(obj: ScrapeConfigSpecEurekaSdConfigsAuthorization | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentials': toJson_ScrapeConfigSpecEurekaSdConfigsAuthorizationCredentials(obj.credentials),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BasicAuth information to use on every scrape request.
 *
 * @schema ScrapeConfigSpecEurekaSdConfigsBasicAuth
 */
export interface ScrapeConfigSpecEurekaSdConfigsBasicAuth {
  /**
   * `password` specifies a key of a Secret containing the password for
   * authentication.
   *
   * @schema ScrapeConfigSpecEurekaSdConfigsBasicAuth#password
   */
  readonly password?: ScrapeConfigSpecEurekaSdConfigsBasicAuthPassword;

  /**
   * `username` specifies a key of a Secret containing the username for
   * authentication.
   *
   * @schema ScrapeConfigSpecEurekaSdConfigsBasicAuth#username
   */
  readonly username?: ScrapeConfigSpecEurekaSdConfigsBasicAuthUsername;

}

/**
 * Converts an object of type 'ScrapeConfigSpecEurekaSdConfigsBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecEurekaSdConfigsBasicAuth(obj: ScrapeConfigSpecEurekaSdConfigsBasicAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_ScrapeConfigSpecEurekaSdConfigsBasicAuthPassword(obj.password),
    'username': toJson_ScrapeConfigSpecEurekaSdConfigsBasicAuthUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Optional OAuth 2.0 configuration.
 * Cannot be set at the same time as `authorization` or `basic_auth`.
 *
 * @schema ScrapeConfigSpecEurekaSdConfigsOauth2
 */
export interface ScrapeConfigSpecEurekaSdConfigsOauth2 {
  /**
   * `clientId` specifies a key of a Secret or ConfigMap containing the
   * OAuth2 client's ID.
   *
   * @schema ScrapeConfigSpecEurekaSdConfigsOauth2#clientId
   */
  readonly clientId: ScrapeConfigSpecEurekaSdConfigsOauth2ClientId;

  /**
   * `clientSecret` specifies a key of a Secret containing the OAuth2
   * client's secret.
   *
   * @schema ScrapeConfigSpecEurekaSdConfigsOauth2#clientSecret
   */
  readonly clientSecret: ScrapeConfigSpecEurekaSdConfigsOauth2ClientSecret;

  /**
   * `endpointParams` configures the HTTP parameters to append to the token
   * URL.
   *
   * @schema ScrapeConfigSpecEurekaSdConfigsOauth2#endpointParams
   */
  readonly endpointParams?: { [key: string]: string };

  /**
   * `scopes` defines the OAuth2 scopes used for the token request.
   *
   * @schema ScrapeConfigSpecEurekaSdConfigsOauth2#scopes
   */
  readonly scopes?: string[];

  /**
   * `tokenURL` configures the URL to fetch the token from.
   *
   * @schema ScrapeConfigSpecEurekaSdConfigsOauth2#tokenUrl
   */
  readonly tokenUrl: string;

}

/**
 * Converts an object of type 'ScrapeConfigSpecEurekaSdConfigsOauth2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecEurekaSdConfigsOauth2(obj: ScrapeConfigSpecEurekaSdConfigsOauth2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientId': toJson_ScrapeConfigSpecEurekaSdConfigsOauth2ClientId(obj.clientId),
    'clientSecret': toJson_ScrapeConfigSpecEurekaSdConfigsOauth2ClientSecret(obj.clientSecret),
    'endpointParams': ((obj.endpointParams) === undefined) ? undefined : (Object.entries(obj.endpointParams).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'scopes': obj.scopes?.map(y => y),
    'tokenUrl': obj.tokenUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScrapeConfigSpecEurekaSdConfigsProxyConnectHeader
 */
export interface ScrapeConfigSpecEurekaSdConfigsProxyConnectHeader {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecEurekaSdConfigsProxyConnectHeader#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecEurekaSdConfigsProxyConnectHeader#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecEurekaSdConfigsProxyConnectHeader#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecEurekaSdConfigsProxyConnectHeader' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecEurekaSdConfigsProxyConnectHeader(obj: ScrapeConfigSpecEurekaSdConfigsProxyConnectHeader | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLS configuration applying to the target HTTP endpoint.
 *
 * @schema ScrapeConfigSpecEurekaSdConfigsTlsConfig
 */
export interface ScrapeConfigSpecEurekaSdConfigsTlsConfig {
  /**
   * Certificate authority used when verifying server certificates.
   *
   * @schema ScrapeConfigSpecEurekaSdConfigsTlsConfig#ca
   */
  readonly ca?: ScrapeConfigSpecEurekaSdConfigsTlsConfigCa;

  /**
   * Client certificate to present when doing client-authentication.
   *
   * @schema ScrapeConfigSpecEurekaSdConfigsTlsConfig#cert
   */
  readonly cert?: ScrapeConfigSpecEurekaSdConfigsTlsConfigCert;

  /**
   * Disable target certificate validation.
   *
   * @schema ScrapeConfigSpecEurekaSdConfigsTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema ScrapeConfigSpecEurekaSdConfigsTlsConfig#keySecret
   */
  readonly keySecret?: ScrapeConfigSpecEurekaSdConfigsTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema ScrapeConfigSpecEurekaSdConfigsTlsConfig#serverName
   */
  readonly serverName?: string;

}

/**
 * Converts an object of type 'ScrapeConfigSpecEurekaSdConfigsTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecEurekaSdConfigsTlsConfig(obj: ScrapeConfigSpecEurekaSdConfigsTlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ca': toJson_ScrapeConfigSpecEurekaSdConfigsTlsConfigCa(obj.ca),
    'cert': toJson_ScrapeConfigSpecEurekaSdConfigsTlsConfigCert(obj.cert),
    'insecureSkipVerify': obj.insecureSkipVerify,
    'keySecret': toJson_ScrapeConfigSpecEurekaSdConfigsTlsConfigKeySecret(obj.keySecret),
    'serverName': obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Authorization header configuration, required when role is hcloud.
 * Role robot does not support bearer token authentication.
 *
 * @schema ScrapeConfigSpecHetznerSdConfigsAuthorization
 */
export interface ScrapeConfigSpecHetznerSdConfigsAuthorization {
  /**
   * Selects a key of a Secret in the namespace that contains the credentials for authentication.
   *
   * @schema ScrapeConfigSpecHetznerSdConfigsAuthorization#credentials
   */
  readonly credentials?: ScrapeConfigSpecHetznerSdConfigsAuthorizationCredentials;

  /**
   * Defines the authentication type. The value is case-insensitive.
   *
   *
   * "Basic" is not a supported value.
   *
   *
   * Default: "Bearer"
   *
   * @schema ScrapeConfigSpecHetznerSdConfigsAuthorization#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ScrapeConfigSpecHetznerSdConfigsAuthorization' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecHetznerSdConfigsAuthorization(obj: ScrapeConfigSpecHetznerSdConfigsAuthorization | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentials': toJson_ScrapeConfigSpecHetznerSdConfigsAuthorizationCredentials(obj.credentials),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BasicAuth information to use on every scrape request, required when role is robot.
 * Role hcloud does not support basic auth.
 *
 * @schema ScrapeConfigSpecHetznerSdConfigsBasicAuth
 */
export interface ScrapeConfigSpecHetznerSdConfigsBasicAuth {
  /**
   * `password` specifies a key of a Secret containing the password for
   * authentication.
   *
   * @schema ScrapeConfigSpecHetznerSdConfigsBasicAuth#password
   */
  readonly password?: ScrapeConfigSpecHetznerSdConfigsBasicAuthPassword;

  /**
   * `username` specifies a key of a Secret containing the username for
   * authentication.
   *
   * @schema ScrapeConfigSpecHetznerSdConfigsBasicAuth#username
   */
  readonly username?: ScrapeConfigSpecHetznerSdConfigsBasicAuthUsername;

}

/**
 * Converts an object of type 'ScrapeConfigSpecHetznerSdConfigsBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecHetznerSdConfigsBasicAuth(obj: ScrapeConfigSpecHetznerSdConfigsBasicAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_ScrapeConfigSpecHetznerSdConfigsBasicAuthPassword(obj.password),
    'username': toJson_ScrapeConfigSpecHetznerSdConfigsBasicAuthUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Optional OAuth 2.0 configuration.
 * Cannot be used at the same time as `basic_auth` or `authorization`.
 *
 * @schema ScrapeConfigSpecHetznerSdConfigsOauth2
 */
export interface ScrapeConfigSpecHetznerSdConfigsOauth2 {
  /**
   * `clientId` specifies a key of a Secret or ConfigMap containing the
   * OAuth2 client's ID.
   *
   * @schema ScrapeConfigSpecHetznerSdConfigsOauth2#clientId
   */
  readonly clientId: ScrapeConfigSpecHetznerSdConfigsOauth2ClientId;

  /**
   * `clientSecret` specifies a key of a Secret containing the OAuth2
   * client's secret.
   *
   * @schema ScrapeConfigSpecHetznerSdConfigsOauth2#clientSecret
   */
  readonly clientSecret: ScrapeConfigSpecHetznerSdConfigsOauth2ClientSecret;

  /**
   * `endpointParams` configures the HTTP parameters to append to the token
   * URL.
   *
   * @schema ScrapeConfigSpecHetznerSdConfigsOauth2#endpointParams
   */
  readonly endpointParams?: { [key: string]: string };

  /**
   * `scopes` defines the OAuth2 scopes used for the token request.
   *
   * @schema ScrapeConfigSpecHetznerSdConfigsOauth2#scopes
   */
  readonly scopes?: string[];

  /**
   * `tokenURL` configures the URL to fetch the token from.
   *
   * @schema ScrapeConfigSpecHetznerSdConfigsOauth2#tokenUrl
   */
  readonly tokenUrl: string;

}

/**
 * Converts an object of type 'ScrapeConfigSpecHetznerSdConfigsOauth2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecHetznerSdConfigsOauth2(obj: ScrapeConfigSpecHetznerSdConfigsOauth2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientId': toJson_ScrapeConfigSpecHetznerSdConfigsOauth2ClientId(obj.clientId),
    'clientSecret': toJson_ScrapeConfigSpecHetznerSdConfigsOauth2ClientSecret(obj.clientSecret),
    'endpointParams': ((obj.endpointParams) === undefined) ? undefined : (Object.entries(obj.endpointParams).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'scopes': obj.scopes?.map(y => y),
    'tokenUrl': obj.tokenUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScrapeConfigSpecHetznerSdConfigsProxyConnectHeader
 */
export interface ScrapeConfigSpecHetznerSdConfigsProxyConnectHeader {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecHetznerSdConfigsProxyConnectHeader#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecHetznerSdConfigsProxyConnectHeader#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecHetznerSdConfigsProxyConnectHeader#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecHetznerSdConfigsProxyConnectHeader' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecHetznerSdConfigsProxyConnectHeader(obj: ScrapeConfigSpecHetznerSdConfigsProxyConnectHeader | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Hetzner role of entities that should be discovered.
 *
 * @schema ScrapeConfigSpecHetznerSdConfigsRole
 */
export enum ScrapeConfigSpecHetznerSdConfigsRole {
  /** hcloud */
  HCLOUD = "hcloud",
  /** robot */
  ROBOT = "robot",
}

/**
 * TLS configuration to use on every scrape request.
 *
 * @schema ScrapeConfigSpecHetznerSdConfigsTlsConfig
 */
export interface ScrapeConfigSpecHetznerSdConfigsTlsConfig {
  /**
   * Certificate authority used when verifying server certificates.
   *
   * @schema ScrapeConfigSpecHetznerSdConfigsTlsConfig#ca
   */
  readonly ca?: ScrapeConfigSpecHetznerSdConfigsTlsConfigCa;

  /**
   * Client certificate to present when doing client-authentication.
   *
   * @schema ScrapeConfigSpecHetznerSdConfigsTlsConfig#cert
   */
  readonly cert?: ScrapeConfigSpecHetznerSdConfigsTlsConfigCert;

  /**
   * Disable target certificate validation.
   *
   * @schema ScrapeConfigSpecHetznerSdConfigsTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema ScrapeConfigSpecHetznerSdConfigsTlsConfig#keySecret
   */
  readonly keySecret?: ScrapeConfigSpecHetznerSdConfigsTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema ScrapeConfigSpecHetznerSdConfigsTlsConfig#serverName
   */
  readonly serverName?: string;

}

/**
 * Converts an object of type 'ScrapeConfigSpecHetznerSdConfigsTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecHetznerSdConfigsTlsConfig(obj: ScrapeConfigSpecHetznerSdConfigsTlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ca': toJson_ScrapeConfigSpecHetznerSdConfigsTlsConfigCa(obj.ca),
    'cert': toJson_ScrapeConfigSpecHetznerSdConfigsTlsConfigCert(obj.cert),
    'insecureSkipVerify': obj.insecureSkipVerify,
    'keySecret': toJson_ScrapeConfigSpecHetznerSdConfigsTlsConfigKeySecret(obj.keySecret),
    'serverName': obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Authorization header configuration to authenticate against the target HTTP endpoint.
 *
 * @schema ScrapeConfigSpecHttpSdConfigsAuthorization
 */
export interface ScrapeConfigSpecHttpSdConfigsAuthorization {
  /**
   * Selects a key of a Secret in the namespace that contains the credentials for authentication.
   *
   * @schema ScrapeConfigSpecHttpSdConfigsAuthorization#credentials
   */
  readonly credentials?: ScrapeConfigSpecHttpSdConfigsAuthorizationCredentials;

  /**
   * Defines the authentication type. The value is case-insensitive.
   *
   *
   * "Basic" is not a supported value.
   *
   *
   * Default: "Bearer"
   *
   * @schema ScrapeConfigSpecHttpSdConfigsAuthorization#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ScrapeConfigSpecHttpSdConfigsAuthorization' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecHttpSdConfigsAuthorization(obj: ScrapeConfigSpecHttpSdConfigsAuthorization | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentials': toJson_ScrapeConfigSpecHttpSdConfigsAuthorizationCredentials(obj.credentials),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BasicAuth information to authenticate against the target HTTP endpoint.
 * More info: https://prometheus.io/docs/operating/configuration/#endpoints
 *
 * @schema ScrapeConfigSpecHttpSdConfigsBasicAuth
 */
export interface ScrapeConfigSpecHttpSdConfigsBasicAuth {
  /**
   * `password` specifies a key of a Secret containing the password for
   * authentication.
   *
   * @schema ScrapeConfigSpecHttpSdConfigsBasicAuth#password
   */
  readonly password?: ScrapeConfigSpecHttpSdConfigsBasicAuthPassword;

  /**
   * `username` specifies a key of a Secret containing the username for
   * authentication.
   *
   * @schema ScrapeConfigSpecHttpSdConfigsBasicAuth#username
   */
  readonly username?: ScrapeConfigSpecHttpSdConfigsBasicAuthUsername;

}

/**
 * Converts an object of type 'ScrapeConfigSpecHttpSdConfigsBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecHttpSdConfigsBasicAuth(obj: ScrapeConfigSpecHttpSdConfigsBasicAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_ScrapeConfigSpecHttpSdConfigsBasicAuthPassword(obj.password),
    'username': toJson_ScrapeConfigSpecHttpSdConfigsBasicAuthUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScrapeConfigSpecHttpSdConfigsProxyConnectHeader
 */
export interface ScrapeConfigSpecHttpSdConfigsProxyConnectHeader {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecHttpSdConfigsProxyConnectHeader#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecHttpSdConfigsProxyConnectHeader#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecHttpSdConfigsProxyConnectHeader#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecHttpSdConfigsProxyConnectHeader' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecHttpSdConfigsProxyConnectHeader(obj: ScrapeConfigSpecHttpSdConfigsProxyConnectHeader | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLS configuration applying to the target HTTP endpoint.
 *
 * @schema ScrapeConfigSpecHttpSdConfigsTlsConfig
 */
export interface ScrapeConfigSpecHttpSdConfigsTlsConfig {
  /**
   * Certificate authority used when verifying server certificates.
   *
   * @schema ScrapeConfigSpecHttpSdConfigsTlsConfig#ca
   */
  readonly ca?: ScrapeConfigSpecHttpSdConfigsTlsConfigCa;

  /**
   * Client certificate to present when doing client-authentication.
   *
   * @schema ScrapeConfigSpecHttpSdConfigsTlsConfig#cert
   */
  readonly cert?: ScrapeConfigSpecHttpSdConfigsTlsConfigCert;

  /**
   * Disable target certificate validation.
   *
   * @schema ScrapeConfigSpecHttpSdConfigsTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema ScrapeConfigSpecHttpSdConfigsTlsConfig#keySecret
   */
  readonly keySecret?: ScrapeConfigSpecHttpSdConfigsTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema ScrapeConfigSpecHttpSdConfigsTlsConfig#serverName
   */
  readonly serverName?: string;

}

/**
 * Converts an object of type 'ScrapeConfigSpecHttpSdConfigsTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecHttpSdConfigsTlsConfig(obj: ScrapeConfigSpecHttpSdConfigsTlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ca': toJson_ScrapeConfigSpecHttpSdConfigsTlsConfigCa(obj.ca),
    'cert': toJson_ScrapeConfigSpecHttpSdConfigsTlsConfigCert(obj.cert),
    'insecureSkipVerify': obj.insecureSkipVerify,
    'keySecret': toJson_ScrapeConfigSpecHttpSdConfigsTlsConfigKeySecret(obj.keySecret),
    'serverName': obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Optional metadata to attach to discovered targets.
 * It requires Prometheus >= v2.35.0 for `pod` role and
 * Prometheus >= v2.37.0 for `endpoints` and `endpointslice` roles.
 *
 * @schema ScrapeConfigSpecKubernetesSdConfigsAttachMetadata
 */
export interface ScrapeConfigSpecKubernetesSdConfigsAttachMetadata {
  /**
   * Attaches node metadata to discovered targets.
   * When set to true, Prometheus must have the `get` permission on the
   * `Nodes` objects.
   * Only valid for Pod, Endpoint and Endpointslice roles.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsAttachMetadata#node
   */
  readonly node?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecKubernetesSdConfigsAttachMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecKubernetesSdConfigsAttachMetadata(obj: ScrapeConfigSpecKubernetesSdConfigsAttachMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'node': obj.node,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Authorization header to use on every scrape request.
 * Cannot be set at the same time as `basicAuth`, or `oauth2`.
 *
 * @schema ScrapeConfigSpecKubernetesSdConfigsAuthorization
 */
export interface ScrapeConfigSpecKubernetesSdConfigsAuthorization {
  /**
   * Selects a key of a Secret in the namespace that contains the credentials for authentication.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsAuthorization#credentials
   */
  readonly credentials?: ScrapeConfigSpecKubernetesSdConfigsAuthorizationCredentials;

  /**
   * Defines the authentication type. The value is case-insensitive.
   *
   *
   * "Basic" is not a supported value.
   *
   *
   * Default: "Bearer"
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsAuthorization#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ScrapeConfigSpecKubernetesSdConfigsAuthorization' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecKubernetesSdConfigsAuthorization(obj: ScrapeConfigSpecKubernetesSdConfigsAuthorization | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentials': toJson_ScrapeConfigSpecKubernetesSdConfigsAuthorizationCredentials(obj.credentials),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BasicAuth information to use on every scrape request.
 * Cannot be set at the same time as `authorization`, or `oauth2`.
 *
 * @schema ScrapeConfigSpecKubernetesSdConfigsBasicAuth
 */
export interface ScrapeConfigSpecKubernetesSdConfigsBasicAuth {
  /**
   * `password` specifies a key of a Secret containing the password for
   * authentication.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsBasicAuth#password
   */
  readonly password?: ScrapeConfigSpecKubernetesSdConfigsBasicAuthPassword;

  /**
   * `username` specifies a key of a Secret containing the username for
   * authentication.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsBasicAuth#username
   */
  readonly username?: ScrapeConfigSpecKubernetesSdConfigsBasicAuthUsername;

}

/**
 * Converts an object of type 'ScrapeConfigSpecKubernetesSdConfigsBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecKubernetesSdConfigsBasicAuth(obj: ScrapeConfigSpecKubernetesSdConfigsBasicAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_ScrapeConfigSpecKubernetesSdConfigsBasicAuthPassword(obj.password),
    'username': toJson_ScrapeConfigSpecKubernetesSdConfigsBasicAuthUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Optional namespace discovery. If omitted, Prometheus discovers targets across all namespaces.
 *
 * @schema ScrapeConfigSpecKubernetesSdConfigsNamespaces
 */
export interface ScrapeConfigSpecKubernetesSdConfigsNamespaces {
  /**
   * List of namespaces where to watch for resources.
   * If empty and `ownNamespace` isn't true, Prometheus watches for resources in all namespaces.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsNamespaces#names
   */
  readonly names?: string[];

  /**
   * Includes the namespace in which the Prometheus pod exists to the list of watched namesapces.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsNamespaces#ownNamespace
   */
  readonly ownNamespace?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecKubernetesSdConfigsNamespaces' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecKubernetesSdConfigsNamespaces(obj: ScrapeConfigSpecKubernetesSdConfigsNamespaces | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'names': obj.names?.map(y => y),
    'ownNamespace': obj.ownNamespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Optional OAuth 2.0 configuration.
 * Cannot be set at the same time as `authorization`, or `basicAuth`.
 *
 * @schema ScrapeConfigSpecKubernetesSdConfigsOauth2
 */
export interface ScrapeConfigSpecKubernetesSdConfigsOauth2 {
  /**
   * `clientId` specifies a key of a Secret or ConfigMap containing the
   * OAuth2 client's ID.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsOauth2#clientId
   */
  readonly clientId: ScrapeConfigSpecKubernetesSdConfigsOauth2ClientId;

  /**
   * `clientSecret` specifies a key of a Secret containing the OAuth2
   * client's secret.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsOauth2#clientSecret
   */
  readonly clientSecret: ScrapeConfigSpecKubernetesSdConfigsOauth2ClientSecret;

  /**
   * `endpointParams` configures the HTTP parameters to append to the token
   * URL.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsOauth2#endpointParams
   */
  readonly endpointParams?: { [key: string]: string };

  /**
   * `scopes` defines the OAuth2 scopes used for the token request.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsOauth2#scopes
   */
  readonly scopes?: string[];

  /**
   * `tokenURL` configures the URL to fetch the token from.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsOauth2#tokenUrl
   */
  readonly tokenUrl: string;

}

/**
 * Converts an object of type 'ScrapeConfigSpecKubernetesSdConfigsOauth2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecKubernetesSdConfigsOauth2(obj: ScrapeConfigSpecKubernetesSdConfigsOauth2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientId': toJson_ScrapeConfigSpecKubernetesSdConfigsOauth2ClientId(obj.clientId),
    'clientSecret': toJson_ScrapeConfigSpecKubernetesSdConfigsOauth2ClientSecret(obj.clientSecret),
    'endpointParams': ((obj.endpointParams) === undefined) ? undefined : (Object.entries(obj.endpointParams).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'scopes': obj.scopes?.map(y => y),
    'tokenUrl': obj.tokenUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScrapeConfigSpecKubernetesSdConfigsProxyConnectHeader
 */
export interface ScrapeConfigSpecKubernetesSdConfigsProxyConnectHeader {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsProxyConnectHeader#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsProxyConnectHeader#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsProxyConnectHeader#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecKubernetesSdConfigsProxyConnectHeader' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecKubernetesSdConfigsProxyConnectHeader(obj: ScrapeConfigSpecKubernetesSdConfigsProxyConnectHeader | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Role of the Kubernetes entities that should be discovered.
 *
 * @schema ScrapeConfigSpecKubernetesSdConfigsRole
 */
export enum ScrapeConfigSpecKubernetesSdConfigsRole {
  /** Node */
  NODE = "Node",
  /** Service */
  SERVICE = "Service",
  /** Pod */
  POD = "Pod",
  /** Endpoints */
  ENDPOINTS = "Endpoints",
  /** EndpointSlice */
  ENDPOINT_SLICE = "EndpointSlice",
  /** Ingress */
  INGRESS = "Ingress",
}

/**
 * K8SSelectorConfig is Kubernetes Selector Config
 *
 * @schema ScrapeConfigSpecKubernetesSdConfigsSelectors
 */
export interface ScrapeConfigSpecKubernetesSdConfigsSelectors {
  /**
   * @schema ScrapeConfigSpecKubernetesSdConfigsSelectors#field
   */
  readonly field?: string;

  /**
   * @schema ScrapeConfigSpecKubernetesSdConfigsSelectors#label
   */
  readonly label?: string;

  /**
   * Role is role of the service in Kubernetes.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsSelectors#role
   */
  readonly role: ScrapeConfigSpecKubernetesSdConfigsSelectorsRole;

}

/**
 * Converts an object of type 'ScrapeConfigSpecKubernetesSdConfigsSelectors' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecKubernetesSdConfigsSelectors(obj: ScrapeConfigSpecKubernetesSdConfigsSelectors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'field': obj.field,
    'label': obj.label,
    'role': obj.role,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLS configuration to use on every scrape request.
 *
 * @schema ScrapeConfigSpecKubernetesSdConfigsTlsConfig
 */
export interface ScrapeConfigSpecKubernetesSdConfigsTlsConfig {
  /**
   * Certificate authority used when verifying server certificates.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsTlsConfig#ca
   */
  readonly ca?: ScrapeConfigSpecKubernetesSdConfigsTlsConfigCa;

  /**
   * Client certificate to present when doing client-authentication.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsTlsConfig#cert
   */
  readonly cert?: ScrapeConfigSpecKubernetesSdConfigsTlsConfigCert;

  /**
   * Disable target certificate validation.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsTlsConfig#keySecret
   */
  readonly keySecret?: ScrapeConfigSpecKubernetesSdConfigsTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsTlsConfig#serverName
   */
  readonly serverName?: string;

}

/**
 * Converts an object of type 'ScrapeConfigSpecKubernetesSdConfigsTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecKubernetesSdConfigsTlsConfig(obj: ScrapeConfigSpecKubernetesSdConfigsTlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ca': toJson_ScrapeConfigSpecKubernetesSdConfigsTlsConfigCa(obj.ca),
    'cert': toJson_ScrapeConfigSpecKubernetesSdConfigsTlsConfigCert(obj.cert),
    'insecureSkipVerify': obj.insecureSkipVerify,
    'keySecret': toJson_ScrapeConfigSpecKubernetesSdConfigsTlsConfigKeySecret(obj.keySecret),
    'serverName': obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Authorization header to use on every scrape request.
 *
 * @schema ScrapeConfigSpecKumaSdConfigsAuthorization
 */
export interface ScrapeConfigSpecKumaSdConfigsAuthorization {
  /**
   * Selects a key of a Secret in the namespace that contains the credentials for authentication.
   *
   * @schema ScrapeConfigSpecKumaSdConfigsAuthorization#credentials
   */
  readonly credentials?: ScrapeConfigSpecKumaSdConfigsAuthorizationCredentials;

  /**
   * Defines the authentication type. The value is case-insensitive.
   *
   *
   * "Basic" is not a supported value.
   *
   *
   * Default: "Bearer"
   *
   * @schema ScrapeConfigSpecKumaSdConfigsAuthorization#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ScrapeConfigSpecKumaSdConfigsAuthorization' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecKumaSdConfigsAuthorization(obj: ScrapeConfigSpecKumaSdConfigsAuthorization | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentials': toJson_ScrapeConfigSpecKumaSdConfigsAuthorizationCredentials(obj.credentials),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BasicAuth information to use on every scrape request.
 *
 * @schema ScrapeConfigSpecKumaSdConfigsBasicAuth
 */
export interface ScrapeConfigSpecKumaSdConfigsBasicAuth {
  /**
   * `password` specifies a key of a Secret containing the password for
   * authentication.
   *
   * @schema ScrapeConfigSpecKumaSdConfigsBasicAuth#password
   */
  readonly password?: ScrapeConfigSpecKumaSdConfigsBasicAuthPassword;

  /**
   * `username` specifies a key of a Secret containing the username for
   * authentication.
   *
   * @schema ScrapeConfigSpecKumaSdConfigsBasicAuth#username
   */
  readonly username?: ScrapeConfigSpecKumaSdConfigsBasicAuthUsername;

}

/**
 * Converts an object of type 'ScrapeConfigSpecKumaSdConfigsBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecKumaSdConfigsBasicAuth(obj: ScrapeConfigSpecKumaSdConfigsBasicAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_ScrapeConfigSpecKumaSdConfigsBasicAuthPassword(obj.password),
    'username': toJson_ScrapeConfigSpecKumaSdConfigsBasicAuthUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Optional OAuth 2.0 configuration.
 * Cannot be set at the same time as `authorization`, or `basicAuth`.
 *
 * @schema ScrapeConfigSpecKumaSdConfigsOauth2
 */
export interface ScrapeConfigSpecKumaSdConfigsOauth2 {
  /**
   * `clientId` specifies a key of a Secret or ConfigMap containing the
   * OAuth2 client's ID.
   *
   * @schema ScrapeConfigSpecKumaSdConfigsOauth2#clientId
   */
  readonly clientId: ScrapeConfigSpecKumaSdConfigsOauth2ClientId;

  /**
   * `clientSecret` specifies a key of a Secret containing the OAuth2
   * client's secret.
   *
   * @schema ScrapeConfigSpecKumaSdConfigsOauth2#clientSecret
   */
  readonly clientSecret: ScrapeConfigSpecKumaSdConfigsOauth2ClientSecret;

  /**
   * `endpointParams` configures the HTTP parameters to append to the token
   * URL.
   *
   * @schema ScrapeConfigSpecKumaSdConfigsOauth2#endpointParams
   */
  readonly endpointParams?: { [key: string]: string };

  /**
   * `scopes` defines the OAuth2 scopes used for the token request.
   *
   * @schema ScrapeConfigSpecKumaSdConfigsOauth2#scopes
   */
  readonly scopes?: string[];

  /**
   * `tokenURL` configures the URL to fetch the token from.
   *
   * @schema ScrapeConfigSpecKumaSdConfigsOauth2#tokenUrl
   */
  readonly tokenUrl: string;

}

/**
 * Converts an object of type 'ScrapeConfigSpecKumaSdConfigsOauth2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecKumaSdConfigsOauth2(obj: ScrapeConfigSpecKumaSdConfigsOauth2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientId': toJson_ScrapeConfigSpecKumaSdConfigsOauth2ClientId(obj.clientId),
    'clientSecret': toJson_ScrapeConfigSpecKumaSdConfigsOauth2ClientSecret(obj.clientSecret),
    'endpointParams': ((obj.endpointParams) === undefined) ? undefined : (Object.entries(obj.endpointParams).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'scopes': obj.scopes?.map(y => y),
    'tokenUrl': obj.tokenUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScrapeConfigSpecKumaSdConfigsProxyConnectHeader
 */
export interface ScrapeConfigSpecKumaSdConfigsProxyConnectHeader {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecKumaSdConfigsProxyConnectHeader#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecKumaSdConfigsProxyConnectHeader#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecKumaSdConfigsProxyConnectHeader#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecKumaSdConfigsProxyConnectHeader' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecKumaSdConfigsProxyConnectHeader(obj: ScrapeConfigSpecKumaSdConfigsProxyConnectHeader | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLS configuration to use on every scrape request
 *
 * @schema ScrapeConfigSpecKumaSdConfigsTlsConfig
 */
export interface ScrapeConfigSpecKumaSdConfigsTlsConfig {
  /**
   * Certificate authority used when verifying server certificates.
   *
   * @schema ScrapeConfigSpecKumaSdConfigsTlsConfig#ca
   */
  readonly ca?: ScrapeConfigSpecKumaSdConfigsTlsConfigCa;

  /**
   * Client certificate to present when doing client-authentication.
   *
   * @schema ScrapeConfigSpecKumaSdConfigsTlsConfig#cert
   */
  readonly cert?: ScrapeConfigSpecKumaSdConfigsTlsConfigCert;

  /**
   * Disable target certificate validation.
   *
   * @schema ScrapeConfigSpecKumaSdConfigsTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema ScrapeConfigSpecKumaSdConfigsTlsConfig#keySecret
   */
  readonly keySecret?: ScrapeConfigSpecKumaSdConfigsTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema ScrapeConfigSpecKumaSdConfigsTlsConfig#serverName
   */
  readonly serverName?: string;

}

/**
 * Converts an object of type 'ScrapeConfigSpecKumaSdConfigsTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecKumaSdConfigsTlsConfig(obj: ScrapeConfigSpecKumaSdConfigsTlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ca': toJson_ScrapeConfigSpecKumaSdConfigsTlsConfigCa(obj.ca),
    'cert': toJson_ScrapeConfigSpecKumaSdConfigsTlsConfigCert(obj.cert),
    'insecureSkipVerify': obj.insecureSkipVerify,
    'keySecret': toJson_ScrapeConfigSpecKumaSdConfigsTlsConfigKeySecret(obj.keySecret),
    'serverName': obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Action to perform based on the regex matching.
 *
 *
 * `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0.
 * `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.
 *
 *
 * Default: "Replace"
 *
 * @schema ScrapeConfigSpecMetricRelabelingsAction
 */
export enum ScrapeConfigSpecMetricRelabelingsAction {
  /** replace */
  REPLACE = "replace",
  /** keep */
  KEEP = "keep",
  /** drop */
  DROP = "drop",
  /** hashmod */
  HASHMOD = "hashmod",
  /** labelmap */
  LABELMAP = "labelmap",
  /** labeldrop */
  LABELDROP = "labeldrop",
  /** labelkeep */
  LABELKEEP = "labelkeep",
  /** lowercase */
  LOWERCASE = "lowercase",
  /** uppercase */
  UPPERCASE = "uppercase",
  /** keepequal */
  KEEPEQUAL = "keepequal",
  /** dropequal */
  DROPEQUAL = "dropequal",
}

/**
 * The applicationCredentialSecret field is required if using an application
 * credential to authenticate.
 *
 * @schema ScrapeConfigSpecOpenstackSdConfigsApplicationCredentialSecret
 */
export interface ScrapeConfigSpecOpenstackSdConfigsApplicationCredentialSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigsApplicationCredentialSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigsApplicationCredentialSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigsApplicationCredentialSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecOpenstackSdConfigsApplicationCredentialSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecOpenstackSdConfigsApplicationCredentialSecret(obj: ScrapeConfigSpecOpenstackSdConfigsApplicationCredentialSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Availability of the endpoint to connect to.
 *
 * @schema ScrapeConfigSpecOpenstackSdConfigsAvailability
 */
export enum ScrapeConfigSpecOpenstackSdConfigsAvailability {
  /** Public */
  PUBLIC = "Public",
  /** Admin */
  ADMIN = "Admin",
  /** Internal */
  INTERNAL = "Internal",
}

/**
 * Password for the Identity V2 and V3 APIs. Consult with your provider's
 * control panel to discover your account's preferred method of authentication.
 *
 * @schema ScrapeConfigSpecOpenstackSdConfigsPassword
 */
export interface ScrapeConfigSpecOpenstackSdConfigsPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigsPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigsPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigsPassword#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecOpenstackSdConfigsPassword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecOpenstackSdConfigsPassword(obj: ScrapeConfigSpecOpenstackSdConfigsPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The OpenStack role of entities that should be discovered.
 *
 * @schema ScrapeConfigSpecOpenstackSdConfigsRole
 */
export enum ScrapeConfigSpecOpenstackSdConfigsRole {
  /** Instance */
  INSTANCE = "Instance",
  /** Hypervisor */
  HYPERVISOR = "Hypervisor",
}

/**
 * TLS configuration applying to the target HTTP endpoint.
 *
 * @schema ScrapeConfigSpecOpenstackSdConfigsTlsConfig
 */
export interface ScrapeConfigSpecOpenstackSdConfigsTlsConfig {
  /**
   * Certificate authority used when verifying server certificates.
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigsTlsConfig#ca
   */
  readonly ca?: ScrapeConfigSpecOpenstackSdConfigsTlsConfigCa;

  /**
   * Client certificate to present when doing client-authentication.
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigsTlsConfig#cert
   */
  readonly cert?: ScrapeConfigSpecOpenstackSdConfigsTlsConfigCert;

  /**
   * Disable target certificate validation.
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigsTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigsTlsConfig#keySecret
   */
  readonly keySecret?: ScrapeConfigSpecOpenstackSdConfigsTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigsTlsConfig#serverName
   */
  readonly serverName?: string;

}

/**
 * Converts an object of type 'ScrapeConfigSpecOpenstackSdConfigsTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecOpenstackSdConfigsTlsConfig(obj: ScrapeConfigSpecOpenstackSdConfigsTlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ca': toJson_ScrapeConfigSpecOpenstackSdConfigsTlsConfigCa(obj.ca),
    'cert': toJson_ScrapeConfigSpecOpenstackSdConfigsTlsConfigCert(obj.cert),
    'insecureSkipVerify': obj.insecureSkipVerify,
    'keySecret': toJson_ScrapeConfigSpecOpenstackSdConfigsTlsConfigKeySecret(obj.keySecret),
    'serverName': obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Action to perform based on the regex matching.
 *
 *
 * `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0.
 * `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.
 *
 *
 * Default: "Replace"
 *
 * @schema ScrapeConfigSpecRelabelingsAction
 */
export enum ScrapeConfigSpecRelabelingsAction {
  /** replace */
  REPLACE = "replace",
  /** keep */
  KEEP = "keep",
  /** drop */
  DROP = "drop",
  /** hashmod */
  HASHMOD = "hashmod",
  /** labelmap */
  LABELMAP = "labelmap",
  /** labeldrop */
  LABELDROP = "labeldrop",
  /** labelkeep */
  LABELKEEP = "labelkeep",
  /** lowercase */
  LOWERCASE = "lowercase",
  /** uppercase */
  UPPERCASE = "uppercase",
  /** keepequal */
  KEEPEQUAL = "keepequal",
  /** dropequal */
  DROPEQUAL = "dropequal",
}

/**
 * Certificate authority used when verifying server certificates.
 *
 * @schema ScrapeConfigSpecTlsConfigCa
 */
export interface ScrapeConfigSpecTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecTlsConfigCa#configMap
   */
  readonly configMap?: ScrapeConfigSpecTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecTlsConfigCa#secret
   */
  readonly secret?: ScrapeConfigSpecTlsConfigCaSecret;

}

/**
 * Converts an object of type 'ScrapeConfigSpecTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecTlsConfigCa(obj: ScrapeConfigSpecTlsConfigCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_ScrapeConfigSpecTlsConfigCaConfigMap(obj.configMap),
    'secret': toJson_ScrapeConfigSpecTlsConfigCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Client certificate to present when doing client-authentication.
 *
 * @schema ScrapeConfigSpecTlsConfigCert
 */
export interface ScrapeConfigSpecTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecTlsConfigCert#configMap
   */
  readonly configMap?: ScrapeConfigSpecTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecTlsConfigCert#secret
   */
  readonly secret?: ScrapeConfigSpecTlsConfigCertSecret;

}

/**
 * Converts an object of type 'ScrapeConfigSpecTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecTlsConfigCert(obj: ScrapeConfigSpecTlsConfigCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_ScrapeConfigSpecTlsConfigCertConfigMap(obj.configMap),
    'secret': toJson_ScrapeConfigSpecTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema ScrapeConfigSpecTlsConfigKeySecret
 */
export interface ScrapeConfigSpecTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecTlsConfigKeySecret(obj: ScrapeConfigSpecTlsConfigKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a Secret in the namespace that contains the credentials for authentication.
 *
 * @schema ScrapeConfigSpecNomadSdConfigsAuthorizationCredentials
 */
export interface ScrapeConfigSpecNomadSdConfigsAuthorizationCredentials {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecNomadSdConfigsAuthorizationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecNomadSdConfigsAuthorizationCredentials#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecNomadSdConfigsAuthorizationCredentials#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecNomadSdConfigsAuthorizationCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecNomadSdConfigsAuthorizationCredentials(obj: ScrapeConfigSpecNomadSdConfigsAuthorizationCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `password` specifies a key of a Secret containing the password for
 * authentication.
 *
 * @schema ScrapeConfigSpecNomadSdConfigsBasicAuthPassword
 */
export interface ScrapeConfigSpecNomadSdConfigsBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecNomadSdConfigsBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecNomadSdConfigsBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecNomadSdConfigsBasicAuthPassword#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecNomadSdConfigsBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecNomadSdConfigsBasicAuthPassword(obj: ScrapeConfigSpecNomadSdConfigsBasicAuthPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `username` specifies a key of a Secret containing the username for
 * authentication.
 *
 * @schema ScrapeConfigSpecNomadSdConfigsBasicAuthUsername
 */
export interface ScrapeConfigSpecNomadSdConfigsBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecNomadSdConfigsBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecNomadSdConfigsBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecNomadSdConfigsBasicAuthUsername#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecNomadSdConfigsBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecNomadSdConfigsBasicAuthUsername(obj: ScrapeConfigSpecNomadSdConfigsBasicAuthUsername | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `clientId` specifies a key of a Secret or ConfigMap containing the
 * OAuth2 client's ID.
 *
 * @schema ScrapeConfigSpecNomadSdConfigsOauth2ClientId
 */
export interface ScrapeConfigSpecNomadSdConfigsOauth2ClientId {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecNomadSdConfigsOauth2ClientId#configMap
   */
  readonly configMap?: ScrapeConfigSpecNomadSdConfigsOauth2ClientIdConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecNomadSdConfigsOauth2ClientId#secret
   */
  readonly secret?: ScrapeConfigSpecNomadSdConfigsOauth2ClientIdSecret;

}

/**
 * Converts an object of type 'ScrapeConfigSpecNomadSdConfigsOauth2ClientId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecNomadSdConfigsOauth2ClientId(obj: ScrapeConfigSpecNomadSdConfigsOauth2ClientId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_ScrapeConfigSpecNomadSdConfigsOauth2ClientIdConfigMap(obj.configMap),
    'secret': toJson_ScrapeConfigSpecNomadSdConfigsOauth2ClientIdSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `clientSecret` specifies a key of a Secret containing the OAuth2
 * client's secret.
 *
 * @schema ScrapeConfigSpecNomadSdConfigsOauth2ClientSecret
 */
export interface ScrapeConfigSpecNomadSdConfigsOauth2ClientSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecNomadSdConfigsOauth2ClientSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecNomadSdConfigsOauth2ClientSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecNomadSdConfigsOauth2ClientSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecNomadSdConfigsOauth2ClientSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecNomadSdConfigsOauth2ClientSecret(obj: ScrapeConfigSpecNomadSdConfigsOauth2ClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Certificate authority used when verifying server certificates.
 *
 * @schema ScrapeConfigSpecNomadSdConfigsTlsConfigCa
 */
export interface ScrapeConfigSpecNomadSdConfigsTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecNomadSdConfigsTlsConfigCa#configMap
   */
  readonly configMap?: ScrapeConfigSpecNomadSdConfigsTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecNomadSdConfigsTlsConfigCa#secret
   */
  readonly secret?: ScrapeConfigSpecNomadSdConfigsTlsConfigCaSecret;

}

/**
 * Converts an object of type 'ScrapeConfigSpecNomadSdConfigsTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecNomadSdConfigsTlsConfigCa(obj: ScrapeConfigSpecNomadSdConfigsTlsConfigCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_ScrapeConfigSpecNomadSdConfigsTlsConfigCaConfigMap(obj.configMap),
    'secret': toJson_ScrapeConfigSpecNomadSdConfigsTlsConfigCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Client certificate to present when doing client-authentication.
 *
 * @schema ScrapeConfigSpecNomadSdConfigsTlsConfigCert
 */
export interface ScrapeConfigSpecNomadSdConfigsTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecNomadSdConfigsTlsConfigCert#configMap
   */
  readonly configMap?: ScrapeConfigSpecNomadSdConfigsTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecNomadSdConfigsTlsConfigCert#secret
   */
  readonly secret?: ScrapeConfigSpecNomadSdConfigsTlsConfigCertSecret;

}

/**
 * Converts an object of type 'ScrapeConfigSpecNomadSdConfigsTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecNomadSdConfigsTlsConfigCert(obj: ScrapeConfigSpecNomadSdConfigsTlsConfigCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_ScrapeConfigSpecNomadSdConfigsTlsConfigCertConfigMap(obj.configMap),
    'secret': toJson_ScrapeConfigSpecNomadSdConfigsTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema ScrapeConfigSpecNomadSdConfigsTlsConfigKeySecret
 */
export interface ScrapeConfigSpecNomadSdConfigsTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecNomadSdConfigsTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecNomadSdConfigsTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecNomadSdConfigsTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecNomadSdConfigsTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecNomadSdConfigsTlsConfigKeySecret(obj: ScrapeConfigSpecNomadSdConfigsTlsConfigKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a Secret in the namespace that contains the credentials for authentication.
 *
 * @schema ScrapeConfigSpecConsulSdConfigsAuthorizationCredentials
 */
export interface ScrapeConfigSpecConsulSdConfigsAuthorizationCredentials {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecConsulSdConfigsAuthorizationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecConsulSdConfigsAuthorizationCredentials#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecConsulSdConfigsAuthorizationCredentials#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecConsulSdConfigsAuthorizationCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecConsulSdConfigsAuthorizationCredentials(obj: ScrapeConfigSpecConsulSdConfigsAuthorizationCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `password` specifies a key of a Secret containing the password for
 * authentication.
 *
 * @schema ScrapeConfigSpecConsulSdConfigsBasicAuthPassword
 */
export interface ScrapeConfigSpecConsulSdConfigsBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecConsulSdConfigsBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecConsulSdConfigsBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecConsulSdConfigsBasicAuthPassword#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecConsulSdConfigsBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecConsulSdConfigsBasicAuthPassword(obj: ScrapeConfigSpecConsulSdConfigsBasicAuthPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `username` specifies a key of a Secret containing the username for
 * authentication.
 *
 * @schema ScrapeConfigSpecConsulSdConfigsBasicAuthUsername
 */
export interface ScrapeConfigSpecConsulSdConfigsBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecConsulSdConfigsBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecConsulSdConfigsBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecConsulSdConfigsBasicAuthUsername#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecConsulSdConfigsBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecConsulSdConfigsBasicAuthUsername(obj: ScrapeConfigSpecConsulSdConfigsBasicAuthUsername | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `clientId` specifies a key of a Secret or ConfigMap containing the
 * OAuth2 client's ID.
 *
 * @schema ScrapeConfigSpecConsulSdConfigsOauth2ClientId
 */
export interface ScrapeConfigSpecConsulSdConfigsOauth2ClientId {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecConsulSdConfigsOauth2ClientId#configMap
   */
  readonly configMap?: ScrapeConfigSpecConsulSdConfigsOauth2ClientIdConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecConsulSdConfigsOauth2ClientId#secret
   */
  readonly secret?: ScrapeConfigSpecConsulSdConfigsOauth2ClientIdSecret;

}

/**
 * Converts an object of type 'ScrapeConfigSpecConsulSdConfigsOauth2ClientId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecConsulSdConfigsOauth2ClientId(obj: ScrapeConfigSpecConsulSdConfigsOauth2ClientId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_ScrapeConfigSpecConsulSdConfigsOauth2ClientIdConfigMap(obj.configMap),
    'secret': toJson_ScrapeConfigSpecConsulSdConfigsOauth2ClientIdSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `clientSecret` specifies a key of a Secret containing the OAuth2
 * client's secret.
 *
 * @schema ScrapeConfigSpecConsulSdConfigsOauth2ClientSecret
 */
export interface ScrapeConfigSpecConsulSdConfigsOauth2ClientSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecConsulSdConfigsOauth2ClientSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecConsulSdConfigsOauth2ClientSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecConsulSdConfigsOauth2ClientSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecConsulSdConfigsOauth2ClientSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecConsulSdConfigsOauth2ClientSecret(obj: ScrapeConfigSpecConsulSdConfigsOauth2ClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Certificate authority used when verifying server certificates.
 *
 * @schema ScrapeConfigSpecConsulSdConfigsTlsConfigCa
 */
export interface ScrapeConfigSpecConsulSdConfigsTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecConsulSdConfigsTlsConfigCa#configMap
   */
  readonly configMap?: ScrapeConfigSpecConsulSdConfigsTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecConsulSdConfigsTlsConfigCa#secret
   */
  readonly secret?: ScrapeConfigSpecConsulSdConfigsTlsConfigCaSecret;

}

/**
 * Converts an object of type 'ScrapeConfigSpecConsulSdConfigsTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecConsulSdConfigsTlsConfigCa(obj: ScrapeConfigSpecConsulSdConfigsTlsConfigCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_ScrapeConfigSpecConsulSdConfigsTlsConfigCaConfigMap(obj.configMap),
    'secret': toJson_ScrapeConfigSpecConsulSdConfigsTlsConfigCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Client certificate to present when doing client-authentication.
 *
 * @schema ScrapeConfigSpecConsulSdConfigsTlsConfigCert
 */
export interface ScrapeConfigSpecConsulSdConfigsTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecConsulSdConfigsTlsConfigCert#configMap
   */
  readonly configMap?: ScrapeConfigSpecConsulSdConfigsTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecConsulSdConfigsTlsConfigCert#secret
   */
  readonly secret?: ScrapeConfigSpecConsulSdConfigsTlsConfigCertSecret;

}

/**
 * Converts an object of type 'ScrapeConfigSpecConsulSdConfigsTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecConsulSdConfigsTlsConfigCert(obj: ScrapeConfigSpecConsulSdConfigsTlsConfigCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_ScrapeConfigSpecConsulSdConfigsTlsConfigCertConfigMap(obj.configMap),
    'secret': toJson_ScrapeConfigSpecConsulSdConfigsTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema ScrapeConfigSpecConsulSdConfigsTlsConfigKeySecret
 */
export interface ScrapeConfigSpecConsulSdConfigsTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecConsulSdConfigsTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecConsulSdConfigsTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecConsulSdConfigsTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecConsulSdConfigsTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecConsulSdConfigsTlsConfigKeySecret(obj: ScrapeConfigSpecConsulSdConfigsTlsConfigKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a Secret in the namespace that contains the credentials for authentication.
 *
 * @schema ScrapeConfigSpecDigitalOceanSdConfigsAuthorizationCredentials
 */
export interface ScrapeConfigSpecDigitalOceanSdConfigsAuthorizationCredentials {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecDigitalOceanSdConfigsAuthorizationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecDigitalOceanSdConfigsAuthorizationCredentials#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecDigitalOceanSdConfigsAuthorizationCredentials#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecDigitalOceanSdConfigsAuthorizationCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecDigitalOceanSdConfigsAuthorizationCredentials(obj: ScrapeConfigSpecDigitalOceanSdConfigsAuthorizationCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `clientId` specifies a key of a Secret or ConfigMap containing the
 * OAuth2 client's ID.
 *
 * @schema ScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientId
 */
export interface ScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientId {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientId#configMap
   */
  readonly configMap?: ScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientIdConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientId#secret
   */
  readonly secret?: ScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientIdSecret;

}

/**
 * Converts an object of type 'ScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientId(obj: ScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_ScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientIdConfigMap(obj.configMap),
    'secret': toJson_ScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientIdSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `clientSecret` specifies a key of a Secret containing the OAuth2
 * client's secret.
 *
 * @schema ScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientSecret
 */
export interface ScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientSecret(obj: ScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Certificate authority used when verifying server certificates.
 *
 * @schema ScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCa
 */
export interface ScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCa#configMap
   */
  readonly configMap?: ScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCa#secret
   */
  readonly secret?: ScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCaSecret;

}

/**
 * Converts an object of type 'ScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCa(obj: ScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_ScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCaConfigMap(obj.configMap),
    'secret': toJson_ScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Client certificate to present when doing client-authentication.
 *
 * @schema ScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCert
 */
export interface ScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCert#configMap
   */
  readonly configMap?: ScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCert#secret
   */
  readonly secret?: ScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCertSecret;

}

/**
 * Converts an object of type 'ScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCert(obj: ScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_ScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCertConfigMap(obj.configMap),
    'secret': toJson_ScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema ScrapeConfigSpecDigitalOceanSdConfigsTlsConfigKeySecret
 */
export interface ScrapeConfigSpecDigitalOceanSdConfigsTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecDigitalOceanSdConfigsTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecDigitalOceanSdConfigsTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecDigitalOceanSdConfigsTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecDigitalOceanSdConfigsTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecDigitalOceanSdConfigsTlsConfigKeySecret(obj: ScrapeConfigSpecDigitalOceanSdConfigsTlsConfigKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a Secret in the namespace that contains the credentials for authentication.
 *
 * @schema ScrapeConfigSpecDockerSdConfigsAuthorizationCredentials
 */
export interface ScrapeConfigSpecDockerSdConfigsAuthorizationCredentials {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecDockerSdConfigsAuthorizationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecDockerSdConfigsAuthorizationCredentials#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecDockerSdConfigsAuthorizationCredentials#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecDockerSdConfigsAuthorizationCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecDockerSdConfigsAuthorizationCredentials(obj: ScrapeConfigSpecDockerSdConfigsAuthorizationCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `password` specifies a key of a Secret containing the password for
 * authentication.
 *
 * @schema ScrapeConfigSpecDockerSdConfigsBasicAuthPassword
 */
export interface ScrapeConfigSpecDockerSdConfigsBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecDockerSdConfigsBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecDockerSdConfigsBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecDockerSdConfigsBasicAuthPassword#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecDockerSdConfigsBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecDockerSdConfigsBasicAuthPassword(obj: ScrapeConfigSpecDockerSdConfigsBasicAuthPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `username` specifies a key of a Secret containing the username for
 * authentication.
 *
 * @schema ScrapeConfigSpecDockerSdConfigsBasicAuthUsername
 */
export interface ScrapeConfigSpecDockerSdConfigsBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecDockerSdConfigsBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecDockerSdConfigsBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecDockerSdConfigsBasicAuthUsername#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecDockerSdConfigsBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecDockerSdConfigsBasicAuthUsername(obj: ScrapeConfigSpecDockerSdConfigsBasicAuthUsername | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `clientId` specifies a key of a Secret or ConfigMap containing the
 * OAuth2 client's ID.
 *
 * @schema ScrapeConfigSpecDockerSdConfigsOauth2ClientId
 */
export interface ScrapeConfigSpecDockerSdConfigsOauth2ClientId {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecDockerSdConfigsOauth2ClientId#configMap
   */
  readonly configMap?: ScrapeConfigSpecDockerSdConfigsOauth2ClientIdConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecDockerSdConfigsOauth2ClientId#secret
   */
  readonly secret?: ScrapeConfigSpecDockerSdConfigsOauth2ClientIdSecret;

}

/**
 * Converts an object of type 'ScrapeConfigSpecDockerSdConfigsOauth2ClientId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecDockerSdConfigsOauth2ClientId(obj: ScrapeConfigSpecDockerSdConfigsOauth2ClientId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_ScrapeConfigSpecDockerSdConfigsOauth2ClientIdConfigMap(obj.configMap),
    'secret': toJson_ScrapeConfigSpecDockerSdConfigsOauth2ClientIdSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `clientSecret` specifies a key of a Secret containing the OAuth2
 * client's secret.
 *
 * @schema ScrapeConfigSpecDockerSdConfigsOauth2ClientSecret
 */
export interface ScrapeConfigSpecDockerSdConfigsOauth2ClientSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecDockerSdConfigsOauth2ClientSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecDockerSdConfigsOauth2ClientSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecDockerSdConfigsOauth2ClientSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecDockerSdConfigsOauth2ClientSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecDockerSdConfigsOauth2ClientSecret(obj: ScrapeConfigSpecDockerSdConfigsOauth2ClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Certificate authority used when verifying server certificates.
 *
 * @schema ScrapeConfigSpecDockerSdConfigsTlsConfigCa
 */
export interface ScrapeConfigSpecDockerSdConfigsTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecDockerSdConfigsTlsConfigCa#configMap
   */
  readonly configMap?: ScrapeConfigSpecDockerSdConfigsTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecDockerSdConfigsTlsConfigCa#secret
   */
  readonly secret?: ScrapeConfigSpecDockerSdConfigsTlsConfigCaSecret;

}

/**
 * Converts an object of type 'ScrapeConfigSpecDockerSdConfigsTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecDockerSdConfigsTlsConfigCa(obj: ScrapeConfigSpecDockerSdConfigsTlsConfigCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_ScrapeConfigSpecDockerSdConfigsTlsConfigCaConfigMap(obj.configMap),
    'secret': toJson_ScrapeConfigSpecDockerSdConfigsTlsConfigCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Client certificate to present when doing client-authentication.
 *
 * @schema ScrapeConfigSpecDockerSdConfigsTlsConfigCert
 */
export interface ScrapeConfigSpecDockerSdConfigsTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecDockerSdConfigsTlsConfigCert#configMap
   */
  readonly configMap?: ScrapeConfigSpecDockerSdConfigsTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecDockerSdConfigsTlsConfigCert#secret
   */
  readonly secret?: ScrapeConfigSpecDockerSdConfigsTlsConfigCertSecret;

}

/**
 * Converts an object of type 'ScrapeConfigSpecDockerSdConfigsTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecDockerSdConfigsTlsConfigCert(obj: ScrapeConfigSpecDockerSdConfigsTlsConfigCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_ScrapeConfigSpecDockerSdConfigsTlsConfigCertConfigMap(obj.configMap),
    'secret': toJson_ScrapeConfigSpecDockerSdConfigsTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema ScrapeConfigSpecDockerSdConfigsTlsConfigKeySecret
 */
export interface ScrapeConfigSpecDockerSdConfigsTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecDockerSdConfigsTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecDockerSdConfigsTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecDockerSdConfigsTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecDockerSdConfigsTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecDockerSdConfigsTlsConfigKeySecret(obj: ScrapeConfigSpecDockerSdConfigsTlsConfigKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a Secret in the namespace that contains the credentials for authentication.
 *
 * @schema ScrapeConfigSpecEurekaSdConfigsAuthorizationCredentials
 */
export interface ScrapeConfigSpecEurekaSdConfigsAuthorizationCredentials {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecEurekaSdConfigsAuthorizationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecEurekaSdConfigsAuthorizationCredentials#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecEurekaSdConfigsAuthorizationCredentials#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecEurekaSdConfigsAuthorizationCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecEurekaSdConfigsAuthorizationCredentials(obj: ScrapeConfigSpecEurekaSdConfigsAuthorizationCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `password` specifies a key of a Secret containing the password for
 * authentication.
 *
 * @schema ScrapeConfigSpecEurekaSdConfigsBasicAuthPassword
 */
export interface ScrapeConfigSpecEurekaSdConfigsBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecEurekaSdConfigsBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecEurekaSdConfigsBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecEurekaSdConfigsBasicAuthPassword#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecEurekaSdConfigsBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecEurekaSdConfigsBasicAuthPassword(obj: ScrapeConfigSpecEurekaSdConfigsBasicAuthPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `username` specifies a key of a Secret containing the username for
 * authentication.
 *
 * @schema ScrapeConfigSpecEurekaSdConfigsBasicAuthUsername
 */
export interface ScrapeConfigSpecEurekaSdConfigsBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecEurekaSdConfigsBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecEurekaSdConfigsBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecEurekaSdConfigsBasicAuthUsername#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecEurekaSdConfigsBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecEurekaSdConfigsBasicAuthUsername(obj: ScrapeConfigSpecEurekaSdConfigsBasicAuthUsername | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `clientId` specifies a key of a Secret or ConfigMap containing the
 * OAuth2 client's ID.
 *
 * @schema ScrapeConfigSpecEurekaSdConfigsOauth2ClientId
 */
export interface ScrapeConfigSpecEurekaSdConfigsOauth2ClientId {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecEurekaSdConfigsOauth2ClientId#configMap
   */
  readonly configMap?: ScrapeConfigSpecEurekaSdConfigsOauth2ClientIdConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecEurekaSdConfigsOauth2ClientId#secret
   */
  readonly secret?: ScrapeConfigSpecEurekaSdConfigsOauth2ClientIdSecret;

}

/**
 * Converts an object of type 'ScrapeConfigSpecEurekaSdConfigsOauth2ClientId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecEurekaSdConfigsOauth2ClientId(obj: ScrapeConfigSpecEurekaSdConfigsOauth2ClientId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_ScrapeConfigSpecEurekaSdConfigsOauth2ClientIdConfigMap(obj.configMap),
    'secret': toJson_ScrapeConfigSpecEurekaSdConfigsOauth2ClientIdSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `clientSecret` specifies a key of a Secret containing the OAuth2
 * client's secret.
 *
 * @schema ScrapeConfigSpecEurekaSdConfigsOauth2ClientSecret
 */
export interface ScrapeConfigSpecEurekaSdConfigsOauth2ClientSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecEurekaSdConfigsOauth2ClientSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecEurekaSdConfigsOauth2ClientSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecEurekaSdConfigsOauth2ClientSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecEurekaSdConfigsOauth2ClientSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecEurekaSdConfigsOauth2ClientSecret(obj: ScrapeConfigSpecEurekaSdConfigsOauth2ClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Certificate authority used when verifying server certificates.
 *
 * @schema ScrapeConfigSpecEurekaSdConfigsTlsConfigCa
 */
export interface ScrapeConfigSpecEurekaSdConfigsTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecEurekaSdConfigsTlsConfigCa#configMap
   */
  readonly configMap?: ScrapeConfigSpecEurekaSdConfigsTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecEurekaSdConfigsTlsConfigCa#secret
   */
  readonly secret?: ScrapeConfigSpecEurekaSdConfigsTlsConfigCaSecret;

}

/**
 * Converts an object of type 'ScrapeConfigSpecEurekaSdConfigsTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecEurekaSdConfigsTlsConfigCa(obj: ScrapeConfigSpecEurekaSdConfigsTlsConfigCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_ScrapeConfigSpecEurekaSdConfigsTlsConfigCaConfigMap(obj.configMap),
    'secret': toJson_ScrapeConfigSpecEurekaSdConfigsTlsConfigCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Client certificate to present when doing client-authentication.
 *
 * @schema ScrapeConfigSpecEurekaSdConfigsTlsConfigCert
 */
export interface ScrapeConfigSpecEurekaSdConfigsTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecEurekaSdConfigsTlsConfigCert#configMap
   */
  readonly configMap?: ScrapeConfigSpecEurekaSdConfigsTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecEurekaSdConfigsTlsConfigCert#secret
   */
  readonly secret?: ScrapeConfigSpecEurekaSdConfigsTlsConfigCertSecret;

}

/**
 * Converts an object of type 'ScrapeConfigSpecEurekaSdConfigsTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecEurekaSdConfigsTlsConfigCert(obj: ScrapeConfigSpecEurekaSdConfigsTlsConfigCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_ScrapeConfigSpecEurekaSdConfigsTlsConfigCertConfigMap(obj.configMap),
    'secret': toJson_ScrapeConfigSpecEurekaSdConfigsTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema ScrapeConfigSpecEurekaSdConfigsTlsConfigKeySecret
 */
export interface ScrapeConfigSpecEurekaSdConfigsTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecEurekaSdConfigsTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecEurekaSdConfigsTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecEurekaSdConfigsTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecEurekaSdConfigsTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecEurekaSdConfigsTlsConfigKeySecret(obj: ScrapeConfigSpecEurekaSdConfigsTlsConfigKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a Secret in the namespace that contains the credentials for authentication.
 *
 * @schema ScrapeConfigSpecHetznerSdConfigsAuthorizationCredentials
 */
export interface ScrapeConfigSpecHetznerSdConfigsAuthorizationCredentials {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecHetznerSdConfigsAuthorizationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecHetznerSdConfigsAuthorizationCredentials#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecHetznerSdConfigsAuthorizationCredentials#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecHetznerSdConfigsAuthorizationCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecHetznerSdConfigsAuthorizationCredentials(obj: ScrapeConfigSpecHetznerSdConfigsAuthorizationCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `password` specifies a key of a Secret containing the password for
 * authentication.
 *
 * @schema ScrapeConfigSpecHetznerSdConfigsBasicAuthPassword
 */
export interface ScrapeConfigSpecHetznerSdConfigsBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecHetznerSdConfigsBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecHetznerSdConfigsBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecHetznerSdConfigsBasicAuthPassword#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecHetznerSdConfigsBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecHetznerSdConfigsBasicAuthPassword(obj: ScrapeConfigSpecHetznerSdConfigsBasicAuthPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `username` specifies a key of a Secret containing the username for
 * authentication.
 *
 * @schema ScrapeConfigSpecHetznerSdConfigsBasicAuthUsername
 */
export interface ScrapeConfigSpecHetznerSdConfigsBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecHetznerSdConfigsBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecHetznerSdConfigsBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecHetznerSdConfigsBasicAuthUsername#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecHetznerSdConfigsBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecHetznerSdConfigsBasicAuthUsername(obj: ScrapeConfigSpecHetznerSdConfigsBasicAuthUsername | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `clientId` specifies a key of a Secret or ConfigMap containing the
 * OAuth2 client's ID.
 *
 * @schema ScrapeConfigSpecHetznerSdConfigsOauth2ClientId
 */
export interface ScrapeConfigSpecHetznerSdConfigsOauth2ClientId {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecHetznerSdConfigsOauth2ClientId#configMap
   */
  readonly configMap?: ScrapeConfigSpecHetznerSdConfigsOauth2ClientIdConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecHetznerSdConfigsOauth2ClientId#secret
   */
  readonly secret?: ScrapeConfigSpecHetznerSdConfigsOauth2ClientIdSecret;

}

/**
 * Converts an object of type 'ScrapeConfigSpecHetznerSdConfigsOauth2ClientId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecHetznerSdConfigsOauth2ClientId(obj: ScrapeConfigSpecHetznerSdConfigsOauth2ClientId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_ScrapeConfigSpecHetznerSdConfigsOauth2ClientIdConfigMap(obj.configMap),
    'secret': toJson_ScrapeConfigSpecHetznerSdConfigsOauth2ClientIdSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `clientSecret` specifies a key of a Secret containing the OAuth2
 * client's secret.
 *
 * @schema ScrapeConfigSpecHetznerSdConfigsOauth2ClientSecret
 */
export interface ScrapeConfigSpecHetznerSdConfigsOauth2ClientSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecHetznerSdConfigsOauth2ClientSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecHetznerSdConfigsOauth2ClientSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecHetznerSdConfigsOauth2ClientSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecHetznerSdConfigsOauth2ClientSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecHetznerSdConfigsOauth2ClientSecret(obj: ScrapeConfigSpecHetznerSdConfigsOauth2ClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Certificate authority used when verifying server certificates.
 *
 * @schema ScrapeConfigSpecHetznerSdConfigsTlsConfigCa
 */
export interface ScrapeConfigSpecHetznerSdConfigsTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecHetznerSdConfigsTlsConfigCa#configMap
   */
  readonly configMap?: ScrapeConfigSpecHetznerSdConfigsTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecHetznerSdConfigsTlsConfigCa#secret
   */
  readonly secret?: ScrapeConfigSpecHetznerSdConfigsTlsConfigCaSecret;

}

/**
 * Converts an object of type 'ScrapeConfigSpecHetznerSdConfigsTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecHetznerSdConfigsTlsConfigCa(obj: ScrapeConfigSpecHetznerSdConfigsTlsConfigCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_ScrapeConfigSpecHetznerSdConfigsTlsConfigCaConfigMap(obj.configMap),
    'secret': toJson_ScrapeConfigSpecHetznerSdConfigsTlsConfigCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Client certificate to present when doing client-authentication.
 *
 * @schema ScrapeConfigSpecHetznerSdConfigsTlsConfigCert
 */
export interface ScrapeConfigSpecHetznerSdConfigsTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecHetznerSdConfigsTlsConfigCert#configMap
   */
  readonly configMap?: ScrapeConfigSpecHetznerSdConfigsTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecHetznerSdConfigsTlsConfigCert#secret
   */
  readonly secret?: ScrapeConfigSpecHetznerSdConfigsTlsConfigCertSecret;

}

/**
 * Converts an object of type 'ScrapeConfigSpecHetznerSdConfigsTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecHetznerSdConfigsTlsConfigCert(obj: ScrapeConfigSpecHetznerSdConfigsTlsConfigCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_ScrapeConfigSpecHetznerSdConfigsTlsConfigCertConfigMap(obj.configMap),
    'secret': toJson_ScrapeConfigSpecHetznerSdConfigsTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema ScrapeConfigSpecHetznerSdConfigsTlsConfigKeySecret
 */
export interface ScrapeConfigSpecHetznerSdConfigsTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecHetznerSdConfigsTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecHetznerSdConfigsTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecHetznerSdConfigsTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecHetznerSdConfigsTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecHetznerSdConfigsTlsConfigKeySecret(obj: ScrapeConfigSpecHetznerSdConfigsTlsConfigKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a Secret in the namespace that contains the credentials for authentication.
 *
 * @schema ScrapeConfigSpecHttpSdConfigsAuthorizationCredentials
 */
export interface ScrapeConfigSpecHttpSdConfigsAuthorizationCredentials {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecHttpSdConfigsAuthorizationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecHttpSdConfigsAuthorizationCredentials#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecHttpSdConfigsAuthorizationCredentials#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecHttpSdConfigsAuthorizationCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecHttpSdConfigsAuthorizationCredentials(obj: ScrapeConfigSpecHttpSdConfigsAuthorizationCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `password` specifies a key of a Secret containing the password for
 * authentication.
 *
 * @schema ScrapeConfigSpecHttpSdConfigsBasicAuthPassword
 */
export interface ScrapeConfigSpecHttpSdConfigsBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecHttpSdConfigsBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecHttpSdConfigsBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecHttpSdConfigsBasicAuthPassword#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecHttpSdConfigsBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecHttpSdConfigsBasicAuthPassword(obj: ScrapeConfigSpecHttpSdConfigsBasicAuthPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `username` specifies a key of a Secret containing the username for
 * authentication.
 *
 * @schema ScrapeConfigSpecHttpSdConfigsBasicAuthUsername
 */
export interface ScrapeConfigSpecHttpSdConfigsBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecHttpSdConfigsBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecHttpSdConfigsBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecHttpSdConfigsBasicAuthUsername#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecHttpSdConfigsBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecHttpSdConfigsBasicAuthUsername(obj: ScrapeConfigSpecHttpSdConfigsBasicAuthUsername | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Certificate authority used when verifying server certificates.
 *
 * @schema ScrapeConfigSpecHttpSdConfigsTlsConfigCa
 */
export interface ScrapeConfigSpecHttpSdConfigsTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecHttpSdConfigsTlsConfigCa#configMap
   */
  readonly configMap?: ScrapeConfigSpecHttpSdConfigsTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecHttpSdConfigsTlsConfigCa#secret
   */
  readonly secret?: ScrapeConfigSpecHttpSdConfigsTlsConfigCaSecret;

}

/**
 * Converts an object of type 'ScrapeConfigSpecHttpSdConfigsTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecHttpSdConfigsTlsConfigCa(obj: ScrapeConfigSpecHttpSdConfigsTlsConfigCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_ScrapeConfigSpecHttpSdConfigsTlsConfigCaConfigMap(obj.configMap),
    'secret': toJson_ScrapeConfigSpecHttpSdConfigsTlsConfigCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Client certificate to present when doing client-authentication.
 *
 * @schema ScrapeConfigSpecHttpSdConfigsTlsConfigCert
 */
export interface ScrapeConfigSpecHttpSdConfigsTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecHttpSdConfigsTlsConfigCert#configMap
   */
  readonly configMap?: ScrapeConfigSpecHttpSdConfigsTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecHttpSdConfigsTlsConfigCert#secret
   */
  readonly secret?: ScrapeConfigSpecHttpSdConfigsTlsConfigCertSecret;

}

/**
 * Converts an object of type 'ScrapeConfigSpecHttpSdConfigsTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecHttpSdConfigsTlsConfigCert(obj: ScrapeConfigSpecHttpSdConfigsTlsConfigCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_ScrapeConfigSpecHttpSdConfigsTlsConfigCertConfigMap(obj.configMap),
    'secret': toJson_ScrapeConfigSpecHttpSdConfigsTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema ScrapeConfigSpecHttpSdConfigsTlsConfigKeySecret
 */
export interface ScrapeConfigSpecHttpSdConfigsTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecHttpSdConfigsTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecHttpSdConfigsTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecHttpSdConfigsTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecHttpSdConfigsTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecHttpSdConfigsTlsConfigKeySecret(obj: ScrapeConfigSpecHttpSdConfigsTlsConfigKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a Secret in the namespace that contains the credentials for authentication.
 *
 * @schema ScrapeConfigSpecKubernetesSdConfigsAuthorizationCredentials
 */
export interface ScrapeConfigSpecKubernetesSdConfigsAuthorizationCredentials {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsAuthorizationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsAuthorizationCredentials#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsAuthorizationCredentials#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecKubernetesSdConfigsAuthorizationCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecKubernetesSdConfigsAuthorizationCredentials(obj: ScrapeConfigSpecKubernetesSdConfigsAuthorizationCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `password` specifies a key of a Secret containing the password for
 * authentication.
 *
 * @schema ScrapeConfigSpecKubernetesSdConfigsBasicAuthPassword
 */
export interface ScrapeConfigSpecKubernetesSdConfigsBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsBasicAuthPassword#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecKubernetesSdConfigsBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecKubernetesSdConfigsBasicAuthPassword(obj: ScrapeConfigSpecKubernetesSdConfigsBasicAuthPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `username` specifies a key of a Secret containing the username for
 * authentication.
 *
 * @schema ScrapeConfigSpecKubernetesSdConfigsBasicAuthUsername
 */
export interface ScrapeConfigSpecKubernetesSdConfigsBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsBasicAuthUsername#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecKubernetesSdConfigsBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecKubernetesSdConfigsBasicAuthUsername(obj: ScrapeConfigSpecKubernetesSdConfigsBasicAuthUsername | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `clientId` specifies a key of a Secret or ConfigMap containing the
 * OAuth2 client's ID.
 *
 * @schema ScrapeConfigSpecKubernetesSdConfigsOauth2ClientId
 */
export interface ScrapeConfigSpecKubernetesSdConfigsOauth2ClientId {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsOauth2ClientId#configMap
   */
  readonly configMap?: ScrapeConfigSpecKubernetesSdConfigsOauth2ClientIdConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsOauth2ClientId#secret
   */
  readonly secret?: ScrapeConfigSpecKubernetesSdConfigsOauth2ClientIdSecret;

}

/**
 * Converts an object of type 'ScrapeConfigSpecKubernetesSdConfigsOauth2ClientId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecKubernetesSdConfigsOauth2ClientId(obj: ScrapeConfigSpecKubernetesSdConfigsOauth2ClientId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_ScrapeConfigSpecKubernetesSdConfigsOauth2ClientIdConfigMap(obj.configMap),
    'secret': toJson_ScrapeConfigSpecKubernetesSdConfigsOauth2ClientIdSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `clientSecret` specifies a key of a Secret containing the OAuth2
 * client's secret.
 *
 * @schema ScrapeConfigSpecKubernetesSdConfigsOauth2ClientSecret
 */
export interface ScrapeConfigSpecKubernetesSdConfigsOauth2ClientSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsOauth2ClientSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsOauth2ClientSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsOauth2ClientSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecKubernetesSdConfigsOauth2ClientSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecKubernetesSdConfigsOauth2ClientSecret(obj: ScrapeConfigSpecKubernetesSdConfigsOauth2ClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Role is role of the service in Kubernetes.
 *
 * @schema ScrapeConfigSpecKubernetesSdConfigsSelectorsRole
 */
export enum ScrapeConfigSpecKubernetesSdConfigsSelectorsRole {
  /** Node */
  NODE = "Node",
  /** Service */
  SERVICE = "Service",
  /** Pod */
  POD = "Pod",
  /** Endpoints */
  ENDPOINTS = "Endpoints",
  /** EndpointSlice */
  ENDPOINT_SLICE = "EndpointSlice",
  /** Ingress */
  INGRESS = "Ingress",
}

/**
 * Certificate authority used when verifying server certificates.
 *
 * @schema ScrapeConfigSpecKubernetesSdConfigsTlsConfigCa
 */
export interface ScrapeConfigSpecKubernetesSdConfigsTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsTlsConfigCa#configMap
   */
  readonly configMap?: ScrapeConfigSpecKubernetesSdConfigsTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsTlsConfigCa#secret
   */
  readonly secret?: ScrapeConfigSpecKubernetesSdConfigsTlsConfigCaSecret;

}

/**
 * Converts an object of type 'ScrapeConfigSpecKubernetesSdConfigsTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecKubernetesSdConfigsTlsConfigCa(obj: ScrapeConfigSpecKubernetesSdConfigsTlsConfigCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_ScrapeConfigSpecKubernetesSdConfigsTlsConfigCaConfigMap(obj.configMap),
    'secret': toJson_ScrapeConfigSpecKubernetesSdConfigsTlsConfigCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Client certificate to present when doing client-authentication.
 *
 * @schema ScrapeConfigSpecKubernetesSdConfigsTlsConfigCert
 */
export interface ScrapeConfigSpecKubernetesSdConfigsTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsTlsConfigCert#configMap
   */
  readonly configMap?: ScrapeConfigSpecKubernetesSdConfigsTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsTlsConfigCert#secret
   */
  readonly secret?: ScrapeConfigSpecKubernetesSdConfigsTlsConfigCertSecret;

}

/**
 * Converts an object of type 'ScrapeConfigSpecKubernetesSdConfigsTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecKubernetesSdConfigsTlsConfigCert(obj: ScrapeConfigSpecKubernetesSdConfigsTlsConfigCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_ScrapeConfigSpecKubernetesSdConfigsTlsConfigCertConfigMap(obj.configMap),
    'secret': toJson_ScrapeConfigSpecKubernetesSdConfigsTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema ScrapeConfigSpecKubernetesSdConfigsTlsConfigKeySecret
 */
export interface ScrapeConfigSpecKubernetesSdConfigsTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecKubernetesSdConfigsTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecKubernetesSdConfigsTlsConfigKeySecret(obj: ScrapeConfigSpecKubernetesSdConfigsTlsConfigKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a Secret in the namespace that contains the credentials for authentication.
 *
 * @schema ScrapeConfigSpecKumaSdConfigsAuthorizationCredentials
 */
export interface ScrapeConfigSpecKumaSdConfigsAuthorizationCredentials {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecKumaSdConfigsAuthorizationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecKumaSdConfigsAuthorizationCredentials#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecKumaSdConfigsAuthorizationCredentials#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecKumaSdConfigsAuthorizationCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecKumaSdConfigsAuthorizationCredentials(obj: ScrapeConfigSpecKumaSdConfigsAuthorizationCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `password` specifies a key of a Secret containing the password for
 * authentication.
 *
 * @schema ScrapeConfigSpecKumaSdConfigsBasicAuthPassword
 */
export interface ScrapeConfigSpecKumaSdConfigsBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecKumaSdConfigsBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecKumaSdConfigsBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecKumaSdConfigsBasicAuthPassword#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecKumaSdConfigsBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecKumaSdConfigsBasicAuthPassword(obj: ScrapeConfigSpecKumaSdConfigsBasicAuthPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `username` specifies a key of a Secret containing the username for
 * authentication.
 *
 * @schema ScrapeConfigSpecKumaSdConfigsBasicAuthUsername
 */
export interface ScrapeConfigSpecKumaSdConfigsBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecKumaSdConfigsBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecKumaSdConfigsBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecKumaSdConfigsBasicAuthUsername#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecKumaSdConfigsBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecKumaSdConfigsBasicAuthUsername(obj: ScrapeConfigSpecKumaSdConfigsBasicAuthUsername | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `clientId` specifies a key of a Secret or ConfigMap containing the
 * OAuth2 client's ID.
 *
 * @schema ScrapeConfigSpecKumaSdConfigsOauth2ClientId
 */
export interface ScrapeConfigSpecKumaSdConfigsOauth2ClientId {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecKumaSdConfigsOauth2ClientId#configMap
   */
  readonly configMap?: ScrapeConfigSpecKumaSdConfigsOauth2ClientIdConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecKumaSdConfigsOauth2ClientId#secret
   */
  readonly secret?: ScrapeConfigSpecKumaSdConfigsOauth2ClientIdSecret;

}

/**
 * Converts an object of type 'ScrapeConfigSpecKumaSdConfigsOauth2ClientId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecKumaSdConfigsOauth2ClientId(obj: ScrapeConfigSpecKumaSdConfigsOauth2ClientId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_ScrapeConfigSpecKumaSdConfigsOauth2ClientIdConfigMap(obj.configMap),
    'secret': toJson_ScrapeConfigSpecKumaSdConfigsOauth2ClientIdSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `clientSecret` specifies a key of a Secret containing the OAuth2
 * client's secret.
 *
 * @schema ScrapeConfigSpecKumaSdConfigsOauth2ClientSecret
 */
export interface ScrapeConfigSpecKumaSdConfigsOauth2ClientSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecKumaSdConfigsOauth2ClientSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecKumaSdConfigsOauth2ClientSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecKumaSdConfigsOauth2ClientSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecKumaSdConfigsOauth2ClientSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecKumaSdConfigsOauth2ClientSecret(obj: ScrapeConfigSpecKumaSdConfigsOauth2ClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Certificate authority used when verifying server certificates.
 *
 * @schema ScrapeConfigSpecKumaSdConfigsTlsConfigCa
 */
export interface ScrapeConfigSpecKumaSdConfigsTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecKumaSdConfigsTlsConfigCa#configMap
   */
  readonly configMap?: ScrapeConfigSpecKumaSdConfigsTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecKumaSdConfigsTlsConfigCa#secret
   */
  readonly secret?: ScrapeConfigSpecKumaSdConfigsTlsConfigCaSecret;

}

/**
 * Converts an object of type 'ScrapeConfigSpecKumaSdConfigsTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecKumaSdConfigsTlsConfigCa(obj: ScrapeConfigSpecKumaSdConfigsTlsConfigCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_ScrapeConfigSpecKumaSdConfigsTlsConfigCaConfigMap(obj.configMap),
    'secret': toJson_ScrapeConfigSpecKumaSdConfigsTlsConfigCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Client certificate to present when doing client-authentication.
 *
 * @schema ScrapeConfigSpecKumaSdConfigsTlsConfigCert
 */
export interface ScrapeConfigSpecKumaSdConfigsTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecKumaSdConfigsTlsConfigCert#configMap
   */
  readonly configMap?: ScrapeConfigSpecKumaSdConfigsTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecKumaSdConfigsTlsConfigCert#secret
   */
  readonly secret?: ScrapeConfigSpecKumaSdConfigsTlsConfigCertSecret;

}

/**
 * Converts an object of type 'ScrapeConfigSpecKumaSdConfigsTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecKumaSdConfigsTlsConfigCert(obj: ScrapeConfigSpecKumaSdConfigsTlsConfigCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_ScrapeConfigSpecKumaSdConfigsTlsConfigCertConfigMap(obj.configMap),
    'secret': toJson_ScrapeConfigSpecKumaSdConfigsTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema ScrapeConfigSpecKumaSdConfigsTlsConfigKeySecret
 */
export interface ScrapeConfigSpecKumaSdConfigsTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecKumaSdConfigsTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecKumaSdConfigsTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecKumaSdConfigsTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecKumaSdConfigsTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecKumaSdConfigsTlsConfigKeySecret(obj: ScrapeConfigSpecKumaSdConfigsTlsConfigKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Certificate authority used when verifying server certificates.
 *
 * @schema ScrapeConfigSpecOpenstackSdConfigsTlsConfigCa
 */
export interface ScrapeConfigSpecOpenstackSdConfigsTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigsTlsConfigCa#configMap
   */
  readonly configMap?: ScrapeConfigSpecOpenstackSdConfigsTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigsTlsConfigCa#secret
   */
  readonly secret?: ScrapeConfigSpecOpenstackSdConfigsTlsConfigCaSecret;

}

/**
 * Converts an object of type 'ScrapeConfigSpecOpenstackSdConfigsTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecOpenstackSdConfigsTlsConfigCa(obj: ScrapeConfigSpecOpenstackSdConfigsTlsConfigCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_ScrapeConfigSpecOpenstackSdConfigsTlsConfigCaConfigMap(obj.configMap),
    'secret': toJson_ScrapeConfigSpecOpenstackSdConfigsTlsConfigCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Client certificate to present when doing client-authentication.
 *
 * @schema ScrapeConfigSpecOpenstackSdConfigsTlsConfigCert
 */
export interface ScrapeConfigSpecOpenstackSdConfigsTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigsTlsConfigCert#configMap
   */
  readonly configMap?: ScrapeConfigSpecOpenstackSdConfigsTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigsTlsConfigCert#secret
   */
  readonly secret?: ScrapeConfigSpecOpenstackSdConfigsTlsConfigCertSecret;

}

/**
 * Converts an object of type 'ScrapeConfigSpecOpenstackSdConfigsTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecOpenstackSdConfigsTlsConfigCert(obj: ScrapeConfigSpecOpenstackSdConfigsTlsConfigCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_ScrapeConfigSpecOpenstackSdConfigsTlsConfigCertConfigMap(obj.configMap),
    'secret': toJson_ScrapeConfigSpecOpenstackSdConfigsTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema ScrapeConfigSpecOpenstackSdConfigsTlsConfigKeySecret
 */
export interface ScrapeConfigSpecOpenstackSdConfigsTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigsTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigsTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigsTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecOpenstackSdConfigsTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecOpenstackSdConfigsTlsConfigKeySecret(obj: ScrapeConfigSpecOpenstackSdConfigsTlsConfigKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecTlsConfigCaConfigMap
 */
export interface ScrapeConfigSpecTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema ScrapeConfigSpecTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema ScrapeConfigSpecTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecTlsConfigCaConfigMap(obj: ScrapeConfigSpecTlsConfigCaConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecTlsConfigCaSecret
 */
export interface ScrapeConfigSpecTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecTlsConfigCaSecret(obj: ScrapeConfigSpecTlsConfigCaSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecTlsConfigCertConfigMap
 */
export interface ScrapeConfigSpecTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema ScrapeConfigSpecTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema ScrapeConfigSpecTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecTlsConfigCertConfigMap(obj: ScrapeConfigSpecTlsConfigCertConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecTlsConfigCertSecret
 */
export interface ScrapeConfigSpecTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecTlsConfigCertSecret(obj: ScrapeConfigSpecTlsConfigCertSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecNomadSdConfigsOauth2ClientIdConfigMap
 */
export interface ScrapeConfigSpecNomadSdConfigsOauth2ClientIdConfigMap {
  /**
   * The key to select.
   *
   * @schema ScrapeConfigSpecNomadSdConfigsOauth2ClientIdConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecNomadSdConfigsOauth2ClientIdConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema ScrapeConfigSpecNomadSdConfigsOauth2ClientIdConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecNomadSdConfigsOauth2ClientIdConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecNomadSdConfigsOauth2ClientIdConfigMap(obj: ScrapeConfigSpecNomadSdConfigsOauth2ClientIdConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecNomadSdConfigsOauth2ClientIdSecret
 */
export interface ScrapeConfigSpecNomadSdConfigsOauth2ClientIdSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecNomadSdConfigsOauth2ClientIdSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecNomadSdConfigsOauth2ClientIdSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecNomadSdConfigsOauth2ClientIdSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecNomadSdConfigsOauth2ClientIdSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecNomadSdConfigsOauth2ClientIdSecret(obj: ScrapeConfigSpecNomadSdConfigsOauth2ClientIdSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecNomadSdConfigsTlsConfigCaConfigMap
 */
export interface ScrapeConfigSpecNomadSdConfigsTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema ScrapeConfigSpecNomadSdConfigsTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecNomadSdConfigsTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema ScrapeConfigSpecNomadSdConfigsTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecNomadSdConfigsTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecNomadSdConfigsTlsConfigCaConfigMap(obj: ScrapeConfigSpecNomadSdConfigsTlsConfigCaConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecNomadSdConfigsTlsConfigCaSecret
 */
export interface ScrapeConfigSpecNomadSdConfigsTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecNomadSdConfigsTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecNomadSdConfigsTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecNomadSdConfigsTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecNomadSdConfigsTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecNomadSdConfigsTlsConfigCaSecret(obj: ScrapeConfigSpecNomadSdConfigsTlsConfigCaSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecNomadSdConfigsTlsConfigCertConfigMap
 */
export interface ScrapeConfigSpecNomadSdConfigsTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema ScrapeConfigSpecNomadSdConfigsTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecNomadSdConfigsTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema ScrapeConfigSpecNomadSdConfigsTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecNomadSdConfigsTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecNomadSdConfigsTlsConfigCertConfigMap(obj: ScrapeConfigSpecNomadSdConfigsTlsConfigCertConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecNomadSdConfigsTlsConfigCertSecret
 */
export interface ScrapeConfigSpecNomadSdConfigsTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecNomadSdConfigsTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecNomadSdConfigsTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecNomadSdConfigsTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecNomadSdConfigsTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecNomadSdConfigsTlsConfigCertSecret(obj: ScrapeConfigSpecNomadSdConfigsTlsConfigCertSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecConsulSdConfigsOauth2ClientIdConfigMap
 */
export interface ScrapeConfigSpecConsulSdConfigsOauth2ClientIdConfigMap {
  /**
   * The key to select.
   *
   * @schema ScrapeConfigSpecConsulSdConfigsOauth2ClientIdConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecConsulSdConfigsOauth2ClientIdConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema ScrapeConfigSpecConsulSdConfigsOauth2ClientIdConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecConsulSdConfigsOauth2ClientIdConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecConsulSdConfigsOauth2ClientIdConfigMap(obj: ScrapeConfigSpecConsulSdConfigsOauth2ClientIdConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecConsulSdConfigsOauth2ClientIdSecret
 */
export interface ScrapeConfigSpecConsulSdConfigsOauth2ClientIdSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecConsulSdConfigsOauth2ClientIdSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecConsulSdConfigsOauth2ClientIdSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecConsulSdConfigsOauth2ClientIdSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecConsulSdConfigsOauth2ClientIdSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecConsulSdConfigsOauth2ClientIdSecret(obj: ScrapeConfigSpecConsulSdConfigsOauth2ClientIdSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecConsulSdConfigsTlsConfigCaConfigMap
 */
export interface ScrapeConfigSpecConsulSdConfigsTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema ScrapeConfigSpecConsulSdConfigsTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecConsulSdConfigsTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema ScrapeConfigSpecConsulSdConfigsTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecConsulSdConfigsTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecConsulSdConfigsTlsConfigCaConfigMap(obj: ScrapeConfigSpecConsulSdConfigsTlsConfigCaConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecConsulSdConfigsTlsConfigCaSecret
 */
export interface ScrapeConfigSpecConsulSdConfigsTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecConsulSdConfigsTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecConsulSdConfigsTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecConsulSdConfigsTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecConsulSdConfigsTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecConsulSdConfigsTlsConfigCaSecret(obj: ScrapeConfigSpecConsulSdConfigsTlsConfigCaSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecConsulSdConfigsTlsConfigCertConfigMap
 */
export interface ScrapeConfigSpecConsulSdConfigsTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema ScrapeConfigSpecConsulSdConfigsTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecConsulSdConfigsTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema ScrapeConfigSpecConsulSdConfigsTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecConsulSdConfigsTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecConsulSdConfigsTlsConfigCertConfigMap(obj: ScrapeConfigSpecConsulSdConfigsTlsConfigCertConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecConsulSdConfigsTlsConfigCertSecret
 */
export interface ScrapeConfigSpecConsulSdConfigsTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecConsulSdConfigsTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecConsulSdConfigsTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecConsulSdConfigsTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecConsulSdConfigsTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecConsulSdConfigsTlsConfigCertSecret(obj: ScrapeConfigSpecConsulSdConfigsTlsConfigCertSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientIdConfigMap
 */
export interface ScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientIdConfigMap {
  /**
   * The key to select.
   *
   * @schema ScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientIdConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientIdConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema ScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientIdConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientIdConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientIdConfigMap(obj: ScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientIdConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientIdSecret
 */
export interface ScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientIdSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientIdSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientIdSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientIdSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientIdSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientIdSecret(obj: ScrapeConfigSpecDigitalOceanSdConfigsOauth2ClientIdSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCaConfigMap
 */
export interface ScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema ScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema ScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCaConfigMap(obj: ScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCaConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCaSecret
 */
export interface ScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCaSecret(obj: ScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCaSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCertConfigMap
 */
export interface ScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema ScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema ScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCertConfigMap(obj: ScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCertConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCertSecret
 */
export interface ScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCertSecret(obj: ScrapeConfigSpecDigitalOceanSdConfigsTlsConfigCertSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecDockerSdConfigsOauth2ClientIdConfigMap
 */
export interface ScrapeConfigSpecDockerSdConfigsOauth2ClientIdConfigMap {
  /**
   * The key to select.
   *
   * @schema ScrapeConfigSpecDockerSdConfigsOauth2ClientIdConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecDockerSdConfigsOauth2ClientIdConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema ScrapeConfigSpecDockerSdConfigsOauth2ClientIdConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecDockerSdConfigsOauth2ClientIdConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecDockerSdConfigsOauth2ClientIdConfigMap(obj: ScrapeConfigSpecDockerSdConfigsOauth2ClientIdConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecDockerSdConfigsOauth2ClientIdSecret
 */
export interface ScrapeConfigSpecDockerSdConfigsOauth2ClientIdSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecDockerSdConfigsOauth2ClientIdSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecDockerSdConfigsOauth2ClientIdSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecDockerSdConfigsOauth2ClientIdSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecDockerSdConfigsOauth2ClientIdSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecDockerSdConfigsOauth2ClientIdSecret(obj: ScrapeConfigSpecDockerSdConfigsOauth2ClientIdSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecDockerSdConfigsTlsConfigCaConfigMap
 */
export interface ScrapeConfigSpecDockerSdConfigsTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema ScrapeConfigSpecDockerSdConfigsTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecDockerSdConfigsTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema ScrapeConfigSpecDockerSdConfigsTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecDockerSdConfigsTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecDockerSdConfigsTlsConfigCaConfigMap(obj: ScrapeConfigSpecDockerSdConfigsTlsConfigCaConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecDockerSdConfigsTlsConfigCaSecret
 */
export interface ScrapeConfigSpecDockerSdConfigsTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecDockerSdConfigsTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecDockerSdConfigsTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecDockerSdConfigsTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecDockerSdConfigsTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecDockerSdConfigsTlsConfigCaSecret(obj: ScrapeConfigSpecDockerSdConfigsTlsConfigCaSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecDockerSdConfigsTlsConfigCertConfigMap
 */
export interface ScrapeConfigSpecDockerSdConfigsTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema ScrapeConfigSpecDockerSdConfigsTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecDockerSdConfigsTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema ScrapeConfigSpecDockerSdConfigsTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecDockerSdConfigsTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecDockerSdConfigsTlsConfigCertConfigMap(obj: ScrapeConfigSpecDockerSdConfigsTlsConfigCertConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecDockerSdConfigsTlsConfigCertSecret
 */
export interface ScrapeConfigSpecDockerSdConfigsTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecDockerSdConfigsTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecDockerSdConfigsTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecDockerSdConfigsTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecDockerSdConfigsTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecDockerSdConfigsTlsConfigCertSecret(obj: ScrapeConfigSpecDockerSdConfigsTlsConfigCertSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecEurekaSdConfigsOauth2ClientIdConfigMap
 */
export interface ScrapeConfigSpecEurekaSdConfigsOauth2ClientIdConfigMap {
  /**
   * The key to select.
   *
   * @schema ScrapeConfigSpecEurekaSdConfigsOauth2ClientIdConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecEurekaSdConfigsOauth2ClientIdConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema ScrapeConfigSpecEurekaSdConfigsOauth2ClientIdConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecEurekaSdConfigsOauth2ClientIdConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecEurekaSdConfigsOauth2ClientIdConfigMap(obj: ScrapeConfigSpecEurekaSdConfigsOauth2ClientIdConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecEurekaSdConfigsOauth2ClientIdSecret
 */
export interface ScrapeConfigSpecEurekaSdConfigsOauth2ClientIdSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecEurekaSdConfigsOauth2ClientIdSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecEurekaSdConfigsOauth2ClientIdSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecEurekaSdConfigsOauth2ClientIdSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecEurekaSdConfigsOauth2ClientIdSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecEurekaSdConfigsOauth2ClientIdSecret(obj: ScrapeConfigSpecEurekaSdConfigsOauth2ClientIdSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecEurekaSdConfigsTlsConfigCaConfigMap
 */
export interface ScrapeConfigSpecEurekaSdConfigsTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema ScrapeConfigSpecEurekaSdConfigsTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecEurekaSdConfigsTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema ScrapeConfigSpecEurekaSdConfigsTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecEurekaSdConfigsTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecEurekaSdConfigsTlsConfigCaConfigMap(obj: ScrapeConfigSpecEurekaSdConfigsTlsConfigCaConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecEurekaSdConfigsTlsConfigCaSecret
 */
export interface ScrapeConfigSpecEurekaSdConfigsTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecEurekaSdConfigsTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecEurekaSdConfigsTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecEurekaSdConfigsTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecEurekaSdConfigsTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecEurekaSdConfigsTlsConfigCaSecret(obj: ScrapeConfigSpecEurekaSdConfigsTlsConfigCaSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecEurekaSdConfigsTlsConfigCertConfigMap
 */
export interface ScrapeConfigSpecEurekaSdConfigsTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema ScrapeConfigSpecEurekaSdConfigsTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecEurekaSdConfigsTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema ScrapeConfigSpecEurekaSdConfigsTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecEurekaSdConfigsTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecEurekaSdConfigsTlsConfigCertConfigMap(obj: ScrapeConfigSpecEurekaSdConfigsTlsConfigCertConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecEurekaSdConfigsTlsConfigCertSecret
 */
export interface ScrapeConfigSpecEurekaSdConfigsTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecEurekaSdConfigsTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecEurekaSdConfigsTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecEurekaSdConfigsTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecEurekaSdConfigsTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecEurekaSdConfigsTlsConfigCertSecret(obj: ScrapeConfigSpecEurekaSdConfigsTlsConfigCertSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecHetznerSdConfigsOauth2ClientIdConfigMap
 */
export interface ScrapeConfigSpecHetznerSdConfigsOauth2ClientIdConfigMap {
  /**
   * The key to select.
   *
   * @schema ScrapeConfigSpecHetznerSdConfigsOauth2ClientIdConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecHetznerSdConfigsOauth2ClientIdConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema ScrapeConfigSpecHetznerSdConfigsOauth2ClientIdConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecHetznerSdConfigsOauth2ClientIdConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecHetznerSdConfigsOauth2ClientIdConfigMap(obj: ScrapeConfigSpecHetznerSdConfigsOauth2ClientIdConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecHetznerSdConfigsOauth2ClientIdSecret
 */
export interface ScrapeConfigSpecHetznerSdConfigsOauth2ClientIdSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecHetznerSdConfigsOauth2ClientIdSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecHetznerSdConfigsOauth2ClientIdSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecHetznerSdConfigsOauth2ClientIdSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecHetznerSdConfigsOauth2ClientIdSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecHetznerSdConfigsOauth2ClientIdSecret(obj: ScrapeConfigSpecHetznerSdConfigsOauth2ClientIdSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecHetznerSdConfigsTlsConfigCaConfigMap
 */
export interface ScrapeConfigSpecHetznerSdConfigsTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema ScrapeConfigSpecHetznerSdConfigsTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecHetznerSdConfigsTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema ScrapeConfigSpecHetznerSdConfigsTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecHetznerSdConfigsTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecHetznerSdConfigsTlsConfigCaConfigMap(obj: ScrapeConfigSpecHetznerSdConfigsTlsConfigCaConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecHetznerSdConfigsTlsConfigCaSecret
 */
export interface ScrapeConfigSpecHetznerSdConfigsTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecHetznerSdConfigsTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecHetznerSdConfigsTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecHetznerSdConfigsTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecHetznerSdConfigsTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecHetznerSdConfigsTlsConfigCaSecret(obj: ScrapeConfigSpecHetznerSdConfigsTlsConfigCaSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecHetznerSdConfigsTlsConfigCertConfigMap
 */
export interface ScrapeConfigSpecHetznerSdConfigsTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema ScrapeConfigSpecHetznerSdConfigsTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecHetznerSdConfigsTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema ScrapeConfigSpecHetznerSdConfigsTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecHetznerSdConfigsTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecHetznerSdConfigsTlsConfigCertConfigMap(obj: ScrapeConfigSpecHetznerSdConfigsTlsConfigCertConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecHetznerSdConfigsTlsConfigCertSecret
 */
export interface ScrapeConfigSpecHetznerSdConfigsTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecHetznerSdConfigsTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecHetznerSdConfigsTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecHetznerSdConfigsTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecHetznerSdConfigsTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecHetznerSdConfigsTlsConfigCertSecret(obj: ScrapeConfigSpecHetznerSdConfigsTlsConfigCertSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecHttpSdConfigsTlsConfigCaConfigMap
 */
export interface ScrapeConfigSpecHttpSdConfigsTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema ScrapeConfigSpecHttpSdConfigsTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecHttpSdConfigsTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema ScrapeConfigSpecHttpSdConfigsTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecHttpSdConfigsTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecHttpSdConfigsTlsConfigCaConfigMap(obj: ScrapeConfigSpecHttpSdConfigsTlsConfigCaConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecHttpSdConfigsTlsConfigCaSecret
 */
export interface ScrapeConfigSpecHttpSdConfigsTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecHttpSdConfigsTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecHttpSdConfigsTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecHttpSdConfigsTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecHttpSdConfigsTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecHttpSdConfigsTlsConfigCaSecret(obj: ScrapeConfigSpecHttpSdConfigsTlsConfigCaSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecHttpSdConfigsTlsConfigCertConfigMap
 */
export interface ScrapeConfigSpecHttpSdConfigsTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema ScrapeConfigSpecHttpSdConfigsTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecHttpSdConfigsTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema ScrapeConfigSpecHttpSdConfigsTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecHttpSdConfigsTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecHttpSdConfigsTlsConfigCertConfigMap(obj: ScrapeConfigSpecHttpSdConfigsTlsConfigCertConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecHttpSdConfigsTlsConfigCertSecret
 */
export interface ScrapeConfigSpecHttpSdConfigsTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecHttpSdConfigsTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecHttpSdConfigsTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecHttpSdConfigsTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecHttpSdConfigsTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecHttpSdConfigsTlsConfigCertSecret(obj: ScrapeConfigSpecHttpSdConfigsTlsConfigCertSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecKubernetesSdConfigsOauth2ClientIdConfigMap
 */
export interface ScrapeConfigSpecKubernetesSdConfigsOauth2ClientIdConfigMap {
  /**
   * The key to select.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsOauth2ClientIdConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsOauth2ClientIdConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsOauth2ClientIdConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecKubernetesSdConfigsOauth2ClientIdConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecKubernetesSdConfigsOauth2ClientIdConfigMap(obj: ScrapeConfigSpecKubernetesSdConfigsOauth2ClientIdConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecKubernetesSdConfigsOauth2ClientIdSecret
 */
export interface ScrapeConfigSpecKubernetesSdConfigsOauth2ClientIdSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsOauth2ClientIdSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsOauth2ClientIdSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsOauth2ClientIdSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecKubernetesSdConfigsOauth2ClientIdSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecKubernetesSdConfigsOauth2ClientIdSecret(obj: ScrapeConfigSpecKubernetesSdConfigsOauth2ClientIdSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecKubernetesSdConfigsTlsConfigCaConfigMap
 */
export interface ScrapeConfigSpecKubernetesSdConfigsTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecKubernetesSdConfigsTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecKubernetesSdConfigsTlsConfigCaConfigMap(obj: ScrapeConfigSpecKubernetesSdConfigsTlsConfigCaConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecKubernetesSdConfigsTlsConfigCaSecret
 */
export interface ScrapeConfigSpecKubernetesSdConfigsTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecKubernetesSdConfigsTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecKubernetesSdConfigsTlsConfigCaSecret(obj: ScrapeConfigSpecKubernetesSdConfigsTlsConfigCaSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecKubernetesSdConfigsTlsConfigCertConfigMap
 */
export interface ScrapeConfigSpecKubernetesSdConfigsTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecKubernetesSdConfigsTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecKubernetesSdConfigsTlsConfigCertConfigMap(obj: ScrapeConfigSpecKubernetesSdConfigsTlsConfigCertConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecKubernetesSdConfigsTlsConfigCertSecret
 */
export interface ScrapeConfigSpecKubernetesSdConfigsTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecKubernetesSdConfigsTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecKubernetesSdConfigsTlsConfigCertSecret(obj: ScrapeConfigSpecKubernetesSdConfigsTlsConfigCertSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecKumaSdConfigsOauth2ClientIdConfigMap
 */
export interface ScrapeConfigSpecKumaSdConfigsOauth2ClientIdConfigMap {
  /**
   * The key to select.
   *
   * @schema ScrapeConfigSpecKumaSdConfigsOauth2ClientIdConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecKumaSdConfigsOauth2ClientIdConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema ScrapeConfigSpecKumaSdConfigsOauth2ClientIdConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecKumaSdConfigsOauth2ClientIdConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecKumaSdConfigsOauth2ClientIdConfigMap(obj: ScrapeConfigSpecKumaSdConfigsOauth2ClientIdConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecKumaSdConfigsOauth2ClientIdSecret
 */
export interface ScrapeConfigSpecKumaSdConfigsOauth2ClientIdSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecKumaSdConfigsOauth2ClientIdSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecKumaSdConfigsOauth2ClientIdSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecKumaSdConfigsOauth2ClientIdSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecKumaSdConfigsOauth2ClientIdSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecKumaSdConfigsOauth2ClientIdSecret(obj: ScrapeConfigSpecKumaSdConfigsOauth2ClientIdSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecKumaSdConfigsTlsConfigCaConfigMap
 */
export interface ScrapeConfigSpecKumaSdConfigsTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema ScrapeConfigSpecKumaSdConfigsTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecKumaSdConfigsTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema ScrapeConfigSpecKumaSdConfigsTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecKumaSdConfigsTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecKumaSdConfigsTlsConfigCaConfigMap(obj: ScrapeConfigSpecKumaSdConfigsTlsConfigCaConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecKumaSdConfigsTlsConfigCaSecret
 */
export interface ScrapeConfigSpecKumaSdConfigsTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecKumaSdConfigsTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecKumaSdConfigsTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecKumaSdConfigsTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecKumaSdConfigsTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecKumaSdConfigsTlsConfigCaSecret(obj: ScrapeConfigSpecKumaSdConfigsTlsConfigCaSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecKumaSdConfigsTlsConfigCertConfigMap
 */
export interface ScrapeConfigSpecKumaSdConfigsTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema ScrapeConfigSpecKumaSdConfigsTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecKumaSdConfigsTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema ScrapeConfigSpecKumaSdConfigsTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecKumaSdConfigsTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecKumaSdConfigsTlsConfigCertConfigMap(obj: ScrapeConfigSpecKumaSdConfigsTlsConfigCertConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecKumaSdConfigsTlsConfigCertSecret
 */
export interface ScrapeConfigSpecKumaSdConfigsTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecKumaSdConfigsTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecKumaSdConfigsTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecKumaSdConfigsTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecKumaSdConfigsTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecKumaSdConfigsTlsConfigCertSecret(obj: ScrapeConfigSpecKumaSdConfigsTlsConfigCertSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecOpenstackSdConfigsTlsConfigCaConfigMap
 */
export interface ScrapeConfigSpecOpenstackSdConfigsTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigsTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigsTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigsTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecOpenstackSdConfigsTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecOpenstackSdConfigsTlsConfigCaConfigMap(obj: ScrapeConfigSpecOpenstackSdConfigsTlsConfigCaConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecOpenstackSdConfigsTlsConfigCaSecret
 */
export interface ScrapeConfigSpecOpenstackSdConfigsTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigsTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigsTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigsTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecOpenstackSdConfigsTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecOpenstackSdConfigsTlsConfigCaSecret(obj: ScrapeConfigSpecOpenstackSdConfigsTlsConfigCaSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecOpenstackSdConfigsTlsConfigCertConfigMap
 */
export interface ScrapeConfigSpecOpenstackSdConfigsTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigsTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigsTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigsTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecOpenstackSdConfigsTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecOpenstackSdConfigsTlsConfigCertConfigMap(obj: ScrapeConfigSpecOpenstackSdConfigsTlsConfigCertConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecOpenstackSdConfigsTlsConfigCertSecret
 */
export interface ScrapeConfigSpecOpenstackSdConfigsTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigsTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigsTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigsTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ScrapeConfigSpecOpenstackSdConfigsTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecOpenstackSdConfigsTlsConfigCertSecret(obj: ScrapeConfigSpecOpenstackSdConfigsTlsConfigCertSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

