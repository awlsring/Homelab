// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * TunnelBinding is the Schema for the tunnelbindings API
 *
 * @schema TunnelBinding
 */
export class TunnelBinding extends ApiObject {
  /**
   * Returns the apiVersion and kind for "TunnelBinding"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networking.cfargotunnel.com/v1alpha1',
    kind: 'TunnelBinding',
  }

  /**
   * Renders a Kubernetes manifest for "TunnelBinding".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: TunnelBindingProps): any {
    return {
      ...TunnelBinding.GVK,
      ...toJson_TunnelBindingProps(props),
    };
  }

  /**
   * Defines a "TunnelBinding" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: TunnelBindingProps) {
    super(scope, id, {
      ...TunnelBinding.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...TunnelBinding.GVK,
      ...toJson_TunnelBindingProps(resolved),
    };
  }
}

/**
 * TunnelBinding is the Schema for the tunnelbindings API
 *
 * @schema TunnelBinding
 */
export interface TunnelBindingProps {
  /**
   * @schema TunnelBinding#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema TunnelBinding#subjects
   */
  readonly subjects: TunnelBindingSubjects[];

  /**
   * TunnelRef defines the Tunnel TunnelBinding connects to
   *
   * @schema TunnelBinding#tunnelRef
   */
  readonly tunnelRef: TunnelBindingTunnelRef;

}

/**
 * Converts an object of type 'TunnelBindingProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TunnelBindingProps(obj: TunnelBindingProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'subjects': obj.subjects?.map(y => toJson_TunnelBindingSubjects(y)),
    'tunnelRef': toJson_TunnelBindingTunnelRef(obj.tunnelRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TunnelBindingSubject defines the subject TunnelBinding connects to the Tunnel
 *
 * @schema TunnelBindingSubjects
 */
export interface TunnelBindingSubjects {
  /**
   * Kind can be Service
   *
   * @schema TunnelBindingSubjects#kind
   */
  readonly kind?: string;

  /**
   * @schema TunnelBindingSubjects#name
   */
  readonly name: string;

  /**
   * @schema TunnelBindingSubjects#spec
   */
  readonly spec?: TunnelBindingSubjectsSpec;

}

/**
 * Converts an object of type 'TunnelBindingSubjects' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TunnelBindingSubjects(obj: TunnelBindingSubjects | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kind': obj.kind,
    'name': obj.name,
    'spec': toJson_TunnelBindingSubjectsSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TunnelRef defines the Tunnel TunnelBinding connects to
 *
 * @schema TunnelBindingTunnelRef
 */
export interface TunnelBindingTunnelRef {
  /**
   * DisableDNSUpdates disables the DNS updates on Cloudflare, just managing the configs. Assumes the DNS entries are manually added.
   *
   * @schema TunnelBindingTunnelRef#disableDNSUpdates
   */
  readonly disableDnsUpdates?: boolean;

  /**
   * Kind can be Tunnel or ClusterTunnel
   *
   * @schema TunnelBindingTunnelRef#kind
   */
  readonly kind: string;

  /**
   * Name of the tunnel resource
   *
   * @schema TunnelBindingTunnelRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'TunnelBindingTunnelRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TunnelBindingTunnelRef(obj: TunnelBindingTunnelRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disableDNSUpdates': obj.disableDnsUpdates,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TunnelBindingSubjectsSpec
 */
export interface TunnelBindingSubjectsSpec {
  /**
   * CaPool trusts the CA certificate referenced by the key in the secret specified in tunnel.spec.originCaPool. tls.crt is trusted globally and does not need to be specified. Only useful if the protocol is HTTPS.
   *
   * @schema TunnelBindingSubjectsSpec#caPool
   */
  readonly caPool?: string;

  /**
   * Fqdn specifies the DNS name to access this service from. Defaults to the service.metadata.name + tunnel.spec.domain. If specifying this, make sure to use the same domain that the tunnel belongs to. This is not validated and used as provided
   *
   * @default the service.metadata.name + tunnel.spec.domain. If specifying this, make sure to use the same domain that the tunnel belongs to. This is not validated and used as provided
   * @schema TunnelBindingSubjectsSpec#fqdn
   */
  readonly fqdn?: string;

  /**
   * NoTlsVerify sisables TLS verification for this service. Only useful if the protocol is HTTPS.
   *
   * @schema TunnelBindingSubjectsSpec#noTlsVerify
   */
  readonly noTlsVerify?: boolean;

  /**
   * Protocol specifies the protocol for the service. Should be one of http, https, tcp, udp, ssh or rdp. Defaults to http, with the exceptions of https for 443, smb for 139 and 445, rdp for 3389 and ssh for 22 if the service has a TCP port. The only available option for a UDP port is udp, which is default.
   *
   * @default http, with the exceptions of https for 443, smb for 139 and 445, rdp for 3389 and ssh for 22 if the service has a TCP port. The only available option for a UDP port is udp, which is default.
   * @schema TunnelBindingSubjectsSpec#protocol
   */
  readonly protocol?: string;

  /**
   * Target specified where the tunnel should proxy to. Defaults to the form of <protocol>://<service.metadata.name>.<service.metadata.namespace>.svc:<port>
   *
   * @default the form of <protocol>://<service.metadata.name>.<service.metadata.namespace>.svc:<port>
   * @schema TunnelBindingSubjectsSpec#target
   */
  readonly target?: string;

}

/**
 * Converts an object of type 'TunnelBindingSubjectsSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TunnelBindingSubjectsSpec(obj: TunnelBindingSubjectsSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caPool': obj.caPool,
    'fqdn': obj.fqdn,
    'noTlsVerify': obj.noTlsVerify,
    'protocol': obj.protocol,
    'target': obj.target,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

