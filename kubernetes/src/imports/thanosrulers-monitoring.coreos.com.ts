// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * ThanosRuler defines a ThanosRuler deployment.
 *
 * @schema ThanosRuler
 */
export class ThanosRuler extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ThanosRuler"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'monitoring.coreos.com/v1',
    kind: 'ThanosRuler',
  }

  /**
   * Renders a Kubernetes manifest for "ThanosRuler".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ThanosRulerProps): any {
    return {
      ...ThanosRuler.GVK,
      ...toJson_ThanosRulerProps(props),
    };
  }

  /**
   * Defines a "ThanosRuler" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ThanosRulerProps) {
    super(scope, id, {
      ...ThanosRuler.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ThanosRuler.GVK,
      ...toJson_ThanosRulerProps(resolved),
    };
  }
}

/**
 * ThanosRuler defines a ThanosRuler deployment.
 *
 * @schema ThanosRuler
 */
export interface ThanosRulerProps {
  /**
   * @schema ThanosRuler#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Specification of the desired behavior of the ThanosRuler cluster. More info:
   * https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
   *
   * @schema ThanosRuler#spec
   */
  readonly spec: ThanosRulerSpec;

}

/**
 * Converts an object of type 'ThanosRulerProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerProps(obj: ThanosRulerProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ThanosRulerSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specification of the desired behavior of the ThanosRuler cluster. More info:
 * https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
 *
 * @schema ThanosRulerSpec
 */
export interface ThanosRulerSpec {
  /**
   * AdditionalArgs allows setting additional arguments for the ThanosRuler container.
   * It is intended for e.g. activating hidden flags which are not supported by
   * the dedicated configuration options yet. The arguments are passed as-is to the
   * ThanosRuler container which may cause issues if they are invalid or not supported
   * by the given ThanosRuler version.
   * In case of an argument conflict (e.g. an argument which is already set by the
   * operator itself) or when providing an invalid argument the reconciliation will
   * fail and an error will be logged.
   *
   * @schema ThanosRulerSpec#additionalArgs
   */
  readonly additionalArgs?: ThanosRulerSpecAdditionalArgs[];

  /**
   * If specified, the pod's scheduling constraints.
   *
   * @schema ThanosRulerSpec#affinity
   */
  readonly affinity?: ThanosRulerSpecAffinity;

  /**
   * AlertDropLabels configure the label names which should be dropped in ThanosRuler alerts.
   * The replica label `thanos_ruler_replica` will always be dropped in alerts.
   *
   * @schema ThanosRulerSpec#alertDropLabels
   */
  readonly alertDropLabels?: string[];

  /**
   * The external Query URL the Thanos Ruler will set in the 'Source' field
   * of all alerts.
   * Maps to the '--alert.query-url' CLI arg.
   *
   * @schema ThanosRulerSpec#alertQueryUrl
   */
  readonly alertQueryUrl?: string;

  /**
   * AlertRelabelConfigFile specifies the path of the alert relabeling configuration file.
   * When used alongside with AlertRelabelConfigs, alertRelabelConfigFile takes precedence.
   *
   * @schema ThanosRulerSpec#alertRelabelConfigFile
   */
  readonly alertRelabelConfigFile?: string;

  /**
   * AlertRelabelConfigs configures alert relabeling in ThanosRuler.
   * Alert relabel configurations must have the form as specified in the official Prometheus documentation:
   * https://prometheus.io/docs/prometheus/latest/configuration/configuration/#alert_relabel_configs
   * Alternative to AlertRelabelConfigFile, and lower order priority.
   *
   * @schema ThanosRulerSpec#alertRelabelConfigs
   */
  readonly alertRelabelConfigs?: ThanosRulerSpecAlertRelabelConfigs;

  /**
   * Define configuration for connecting to alertmanager.  Only available with thanos v0.10.0
   * and higher.  Maps to the `alertmanagers.config` arg.
   *
   * @schema ThanosRulerSpec#alertmanagersConfig
   */
  readonly alertmanagersConfig?: ThanosRulerSpecAlertmanagersConfig;

  /**
   * Define URLs to send alerts to Alertmanager.  For Thanos v0.10.0 and higher,
   * AlertManagersConfig should be used instead.  Note: this field will be ignored
   * if AlertManagersConfig is specified.
   * Maps to the `alertmanagers.url` arg.
   *
   * @schema ThanosRulerSpec#alertmanagersUrl
   */
  readonly alertmanagersUrl?: string[];

  /**
   * Containers allows injecting additional containers or modifying operator generated
   * containers. This can be used to allow adding an authentication proxy to a ThanosRuler pod or
   * to change the behavior of an operator generated container. Containers described here modify
   * an operator generated container if they share the same name and modifications are done via a
   * strategic merge patch. The current container names are: `thanos-ruler` and `config-reloader`.
   * Overriding containers is entirely outside the scope of what the maintainers will support and by doing
   * so, you accept that this behaviour may break at any time without notice.
   *
   * @schema ThanosRulerSpec#containers
   */
  readonly containers?: ThanosRulerSpecContainers[];

  /**
   * EnforcedNamespaceLabel enforces adding a namespace label of origin for each alert
   * and metric that is user created. The label value will always be the namespace of the object that is
   * being created.
   *
   * @schema ThanosRulerSpec#enforcedNamespaceLabel
   */
  readonly enforcedNamespaceLabel?: string;

  /**
   * Interval between consecutive evaluations.
   *
   * @schema ThanosRulerSpec#evaluationInterval
   */
  readonly evaluationInterval?: string;

  /**
   * List of references to PrometheusRule objects
   * to be excluded from enforcing a namespace label of origin.
   * Applies only if enforcedNamespaceLabel set to true.
   *
   * @schema ThanosRulerSpec#excludedFromEnforcement
   */
  readonly excludedFromEnforcement?: ThanosRulerSpecExcludedFromEnforcement[];

  /**
   * The external URL the Thanos Ruler instances will be available under. This is
   * necessary to generate correct URLs. This is necessary if Thanos Ruler is not
   * served from root of a DNS name.
   *
   * @schema ThanosRulerSpec#externalPrefix
   */
  readonly externalPrefix?: string;

  /**
   * GRPCServerTLSConfig configures the gRPC server from which Thanos Querier reads
   * recorded rule data.
   * Note: Currently only the CAFile, CertFile, and KeyFile fields are supported.
   * Maps to the '--grpc-server-tls-*' CLI args.
   *
   * @schema ThanosRulerSpec#grpcServerTlsConfig
   */
  readonly grpcServerTlsConfig?: ThanosRulerSpecGrpcServerTlsConfig;

  /**
   * Pods' hostAliases configuration
   *
   * @schema ThanosRulerSpec#hostAliases
   */
  readonly hostAliases?: ThanosRulerSpecHostAliases[];

  /**
   * Thanos container image URL.
   *
   * @schema ThanosRulerSpec#image
   */
  readonly image?: string;

  /**
   * Image pull policy for the 'thanos', 'init-config-reloader' and 'config-reloader' containers.
   * See https://kubernetes.io/docs/concepts/containers/images/#image-pull-policy for more details.
   *
   * @schema ThanosRulerSpec#imagePullPolicy
   */
  readonly imagePullPolicy?: ThanosRulerSpecImagePullPolicy;

  /**
   * An optional list of references to secrets in the same namespace
   * to use for pulling thanos images from registries
   * see http://kubernetes.io/docs/user-guide/images#specifying-imagepullsecrets-on-a-pod
   *
   * @schema ThanosRulerSpec#imagePullSecrets
   */
  readonly imagePullSecrets?: ThanosRulerSpecImagePullSecrets[];

  /**
   * InitContainers allows adding initContainers to the pod definition. Those can be used to e.g.
   * fetch secrets for injection into the ThanosRuler configuration from external sources. Any
   * errors during the execution of an initContainer will lead to a restart of the Pod.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
   * Using initContainers for any use case other then secret fetching is entirely outside the scope
   * of what the maintainers will support and by doing so, you accept that this behaviour may break
   * at any time without notice.
   *
   * @schema ThanosRulerSpec#initContainers
   */
  readonly initContainers?: ThanosRulerSpecInitContainers[];

  /**
   * Labels configure the external label pairs to ThanosRuler. A default replica label
   * `thanos_ruler_replica` will be always added  as a label with the value of the pod's name and it will be dropped in the alerts.
   *
   * @schema ThanosRulerSpec#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * ListenLocal makes the Thanos ruler listen on loopback, so that it
   * does not bind against the Pod IP.
   *
   * @schema ThanosRulerSpec#listenLocal
   */
  readonly listenLocal?: boolean;

  /**
   * Log format for ThanosRuler to be configured with.
   *
   * @schema ThanosRulerSpec#logFormat
   */
  readonly logFormat?: ThanosRulerSpecLogFormat;

  /**
   * Log level for ThanosRuler to be configured with.
   *
   * @schema ThanosRulerSpec#logLevel
   */
  readonly logLevel?: ThanosRulerSpecLogLevel;

  /**
   * Minimum number of seconds for which a newly created pod should be ready
   * without any of its container crashing for it to be considered available.
   * Defaults to 0 (pod will be considered available as soon as it is ready)
   * This is an alpha field from kubernetes 1.22 until 1.24 which requires enabling the StatefulSetMinReadySeconds feature gate.
   *
   * @default 0 (pod will be considered available as soon as it is ready)
   * @schema ThanosRulerSpec#minReadySeconds
   */
  readonly minReadySeconds?: number;

  /**
   * Define which Nodes the Pods are scheduled on.
   *
   * @schema ThanosRulerSpec#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * ObjectStorageConfig configures object storage in Thanos.
   * Alternative to ObjectStorageConfigFile, and lower order priority.
   *
   * @schema ThanosRulerSpec#objectStorageConfig
   */
  readonly objectStorageConfig?: ThanosRulerSpecObjectStorageConfig;

  /**
   * ObjectStorageConfigFile specifies the path of the object storage configuration file.
   * When used alongside with ObjectStorageConfig, ObjectStorageConfigFile takes precedence.
   *
   * @schema ThanosRulerSpec#objectStorageConfigFile
   */
  readonly objectStorageConfigFile?: string;

  /**
   * When a ThanosRuler deployment is paused, no actions except for deletion
   * will be performed on the underlying objects.
   *
   * @schema ThanosRulerSpec#paused
   */
  readonly paused?: boolean;

  /**
   * PodMetadata configures labels and annotations which are propagated to the ThanosRuler pods.
   *
   *
   * The following items are reserved and cannot be overridden:
   * * "app.kubernetes.io/name" label, set to "thanos-ruler".
   * * "app.kubernetes.io/managed-by" label, set to "prometheus-operator".
   * * "app.kubernetes.io/instance" label, set to the name of the ThanosRuler instance.
   * * "thanos-ruler" label, set to the name of the ThanosRuler instance.
   * * "kubectl.kubernetes.io/default-container" annotation, set to "thanos-ruler".
   *
   * @schema ThanosRulerSpec#podMetadata
   */
  readonly podMetadata?: ThanosRulerSpecPodMetadata;

  /**
   * Port name used for the pods and governing service.
   * Defaults to `web`.
   *
   * @default web`.
   * @schema ThanosRulerSpec#portName
   */
  readonly portName?: string;

  /**
   * Priority class assigned to the Pods
   *
   * @schema ThanosRulerSpec#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * PrometheusRulesExcludedFromEnforce - list of Prometheus rules to be excluded from enforcing
   * of adding namespace labels. Works only if enforcedNamespaceLabel set to true.
   * Make sure both ruleNamespace and ruleName are set for each pair
   * Deprecated: use excludedFromEnforcement instead.
   *
   * @schema ThanosRulerSpec#prometheusRulesExcludedFromEnforce
   */
  readonly prometheusRulesExcludedFromEnforce?: ThanosRulerSpecPrometheusRulesExcludedFromEnforce[];

  /**
   * Define configuration for connecting to thanos query instances.
   * If this is defined, the QueryEndpoints field will be ignored.
   * Maps to the `query.config` CLI argument.
   * Only available with thanos v0.11.0 and higher.
   *
   * @schema ThanosRulerSpec#queryConfig
   */
  readonly queryConfig?: ThanosRulerSpecQueryConfig;

  /**
   * QueryEndpoints defines Thanos querier endpoints from which to query metrics.
   * Maps to the --query flag of thanos ruler.
   *
   * @schema ThanosRulerSpec#queryEndpoints
   */
  readonly queryEndpoints?: string[];

  /**
   * Number of thanos ruler instances to deploy.
   *
   * @schema ThanosRulerSpec#replicas
   */
  readonly replicas?: number;

  /**
   * Resources defines the resource requirements for single Pods.
   * If not provided, no requests/limits will be set
   *
   * @schema ThanosRulerSpec#resources
   */
  readonly resources?: ThanosRulerSpecResources;

  /**
   * Time duration ThanosRuler shall retain data for. Default is '24h',
   * and must match the regular expression `[0-9]+(ms|s|m|h|d|w|y)` (milliseconds seconds minutes hours days weeks years).
   *
   * @default 24h',
   * @schema ThanosRulerSpec#retention
   */
  readonly retention?: string;

  /**
   * The route prefix ThanosRuler registers HTTP handlers for. This allows thanos UI to be served on a sub-path.
   *
   * @schema ThanosRulerSpec#routePrefix
   */
  readonly routePrefix?: string;

  /**
   * Namespaces to be selected for Rules discovery. If unspecified, only
   * the same namespace as the ThanosRuler object is in is used.
   *
   * @schema ThanosRulerSpec#ruleNamespaceSelector
   */
  readonly ruleNamespaceSelector?: ThanosRulerSpecRuleNamespaceSelector;

  /**
   * A label selector to select which PrometheusRules to mount for alerting and
   * recording.
   *
   * @schema ThanosRulerSpec#ruleSelector
   */
  readonly ruleSelector?: ThanosRulerSpecRuleSelector;

  /**
   * SecurityContext holds pod-level security attributes and common container settings.
   * This defaults to the default PodSecurityContext.
   *
   * @schema ThanosRulerSpec#securityContext
   */
  readonly securityContext?: ThanosRulerSpecSecurityContext;

  /**
   * ServiceAccountName is the name of the ServiceAccount to use to run the
   * Thanos Ruler Pods.
   *
   * @schema ThanosRulerSpec#serviceAccountName
   */
  readonly serviceAccountName?: string;

  /**
   * Storage spec to specify how storage shall be used.
   *
   * @schema ThanosRulerSpec#storage
   */
  readonly storage?: ThanosRulerSpecStorage;

  /**
   * If specified, the pod's tolerations.
   *
   * @schema ThanosRulerSpec#tolerations
   */
  readonly tolerations?: ThanosRulerSpecTolerations[];

  /**
   * If specified, the pod's topology spread constraints.
   *
   * @schema ThanosRulerSpec#topologySpreadConstraints
   */
  readonly topologySpreadConstraints?: ThanosRulerSpecTopologySpreadConstraints[];

  /**
   * TracingConfig configures tracing in Thanos.
   *
   *
   * `tracingConfigFile` takes precedence over this field.
   *
   *
   * This is an *experimental feature*, it may change in any upcoming release
   * in a breaking way.
   *
   * @schema ThanosRulerSpec#tracingConfig
   */
  readonly tracingConfig?: ThanosRulerSpecTracingConfig;

  /**
   * TracingConfig specifies the path of the tracing configuration file.
   *
   *
   * This field takes precedence over `tracingConfig`.
   *
   *
   * This is an *experimental feature*, it may change in any upcoming release
   * in a breaking way.
   *
   * @schema ThanosRulerSpec#tracingConfigFile
   */
  readonly tracingConfigFile?: string;

  /**
   * Version of Thanos to be deployed.
   *
   * @schema ThanosRulerSpec#version
   */
  readonly version?: string;

  /**
   * VolumeMounts allows configuration of additional VolumeMounts on the output StatefulSet definition.
   * VolumeMounts specified will be appended to other VolumeMounts in the ruler container,
   * that are generated as a result of StorageSpec objects.
   *
   * @schema ThanosRulerSpec#volumeMounts
   */
  readonly volumeMounts?: ThanosRulerSpecVolumeMounts[];

  /**
   * Volumes allows configuration of additional volumes on the output StatefulSet definition. Volumes specified will
   * be appended to other volumes that are generated as a result of StorageSpec objects.
   *
   * @schema ThanosRulerSpec#volumes
   */
  readonly volumes?: ThanosRulerSpecVolumes[];

  /**
   * Defines the configuration of the ThanosRuler web server.
   *
   * @schema ThanosRulerSpec#web
   */
  readonly web?: ThanosRulerSpecWeb;

}

/**
 * Converts an object of type 'ThanosRulerSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpec(obj: ThanosRulerSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalArgs': obj.additionalArgs?.map(y => toJson_ThanosRulerSpecAdditionalArgs(y)),
    'affinity': toJson_ThanosRulerSpecAffinity(obj.affinity),
    'alertDropLabels': obj.alertDropLabels?.map(y => y),
    'alertQueryUrl': obj.alertQueryUrl,
    'alertRelabelConfigFile': obj.alertRelabelConfigFile,
    'alertRelabelConfigs': toJson_ThanosRulerSpecAlertRelabelConfigs(obj.alertRelabelConfigs),
    'alertmanagersConfig': toJson_ThanosRulerSpecAlertmanagersConfig(obj.alertmanagersConfig),
    'alertmanagersUrl': obj.alertmanagersUrl?.map(y => y),
    'containers': obj.containers?.map(y => toJson_ThanosRulerSpecContainers(y)),
    'enforcedNamespaceLabel': obj.enforcedNamespaceLabel,
    'evaluationInterval': obj.evaluationInterval,
    'excludedFromEnforcement': obj.excludedFromEnforcement?.map(y => toJson_ThanosRulerSpecExcludedFromEnforcement(y)),
    'externalPrefix': obj.externalPrefix,
    'grpcServerTlsConfig': toJson_ThanosRulerSpecGrpcServerTlsConfig(obj.grpcServerTlsConfig),
    'hostAliases': obj.hostAliases?.map(y => toJson_ThanosRulerSpecHostAliases(y)),
    'image': obj.image,
    'imagePullPolicy': obj.imagePullPolicy,
    'imagePullSecrets': obj.imagePullSecrets?.map(y => toJson_ThanosRulerSpecImagePullSecrets(y)),
    'initContainers': obj.initContainers?.map(y => toJson_ThanosRulerSpecInitContainers(y)),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'listenLocal': obj.listenLocal,
    'logFormat': obj.logFormat,
    'logLevel': obj.logLevel,
    'minReadySeconds': obj.minReadySeconds,
    'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'objectStorageConfig': toJson_ThanosRulerSpecObjectStorageConfig(obj.objectStorageConfig),
    'objectStorageConfigFile': obj.objectStorageConfigFile,
    'paused': obj.paused,
    'podMetadata': toJson_ThanosRulerSpecPodMetadata(obj.podMetadata),
    'portName': obj.portName,
    'priorityClassName': obj.priorityClassName,
    'prometheusRulesExcludedFromEnforce': obj.prometheusRulesExcludedFromEnforce?.map(y => toJson_ThanosRulerSpecPrometheusRulesExcludedFromEnforce(y)),
    'queryConfig': toJson_ThanosRulerSpecQueryConfig(obj.queryConfig),
    'queryEndpoints': obj.queryEndpoints?.map(y => y),
    'replicas': obj.replicas,
    'resources': toJson_ThanosRulerSpecResources(obj.resources),
    'retention': obj.retention,
    'routePrefix': obj.routePrefix,
    'ruleNamespaceSelector': toJson_ThanosRulerSpecRuleNamespaceSelector(obj.ruleNamespaceSelector),
    'ruleSelector': toJson_ThanosRulerSpecRuleSelector(obj.ruleSelector),
    'securityContext': toJson_ThanosRulerSpecSecurityContext(obj.securityContext),
    'serviceAccountName': obj.serviceAccountName,
    'storage': toJson_ThanosRulerSpecStorage(obj.storage),
    'tolerations': obj.tolerations?.map(y => toJson_ThanosRulerSpecTolerations(y)),
    'topologySpreadConstraints': obj.topologySpreadConstraints?.map(y => toJson_ThanosRulerSpecTopologySpreadConstraints(y)),
    'tracingConfig': toJson_ThanosRulerSpecTracingConfig(obj.tracingConfig),
    'tracingConfigFile': obj.tracingConfigFile,
    'version': obj.version,
    'volumeMounts': obj.volumeMounts?.map(y => toJson_ThanosRulerSpecVolumeMounts(y)),
    'volumes': obj.volumes?.map(y => toJson_ThanosRulerSpecVolumes(y)),
    'web': toJson_ThanosRulerSpecWeb(obj.web),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Argument as part of the AdditionalArgs list.
 *
 * @schema ThanosRulerSpecAdditionalArgs
 */
export interface ThanosRulerSpecAdditionalArgs {
  /**
   * Name of the argument, e.g. "scrape.discovery-reload-interval".
   *
   * @schema ThanosRulerSpecAdditionalArgs#name
   */
  readonly name: string;

  /**
   * Argument value, e.g. 30s. Can be empty for name-only arguments (e.g. --storage.tsdb.no-lockfile)
   *
   * @schema ThanosRulerSpecAdditionalArgs#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecAdditionalArgs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecAdditionalArgs(obj: ThanosRulerSpecAdditionalArgs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * If specified, the pod's scheduling constraints.
 *
 * @schema ThanosRulerSpecAffinity
 */
export interface ThanosRulerSpecAffinity {
  /**
   * Describes node affinity scheduling rules for the pod.
   *
   * @schema ThanosRulerSpecAffinity#nodeAffinity
   */
  readonly nodeAffinity?: ThanosRulerSpecAffinityNodeAffinity;

  /**
   * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
   *
   * @schema ThanosRulerSpecAffinity#podAffinity
   */
  readonly podAffinity?: ThanosRulerSpecAffinityPodAffinity;

  /**
   * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
   *
   * @schema ThanosRulerSpecAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: ThanosRulerSpecAffinityPodAntiAffinity;

}

/**
 * Converts an object of type 'ThanosRulerSpecAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecAffinity(obj: ThanosRulerSpecAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeAffinity': toJson_ThanosRulerSpecAffinityNodeAffinity(obj.nodeAffinity),
    'podAffinity': toJson_ThanosRulerSpecAffinityPodAffinity(obj.podAffinity),
    'podAntiAffinity': toJson_ThanosRulerSpecAffinityPodAntiAffinity(obj.podAntiAffinity),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AlertRelabelConfigs configures alert relabeling in ThanosRuler.
 * Alert relabel configurations must have the form as specified in the official Prometheus documentation:
 * https://prometheus.io/docs/prometheus/latest/configuration/configuration/#alert_relabel_configs
 * Alternative to AlertRelabelConfigFile, and lower order priority.
 *
 * @schema ThanosRulerSpecAlertRelabelConfigs
 */
export interface ThanosRulerSpecAlertRelabelConfigs {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ThanosRulerSpecAlertRelabelConfigs#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ThanosRulerSpecAlertRelabelConfigs#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ThanosRulerSpecAlertRelabelConfigs#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ThanosRulerSpecAlertRelabelConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecAlertRelabelConfigs(obj: ThanosRulerSpecAlertRelabelConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Define configuration for connecting to alertmanager.  Only available with thanos v0.10.0
 * and higher.  Maps to the `alertmanagers.config` arg.
 *
 * @schema ThanosRulerSpecAlertmanagersConfig
 */
export interface ThanosRulerSpecAlertmanagersConfig {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ThanosRulerSpecAlertmanagersConfig#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ThanosRulerSpecAlertmanagersConfig#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ThanosRulerSpecAlertmanagersConfig#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ThanosRulerSpecAlertmanagersConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecAlertmanagersConfig(obj: ThanosRulerSpecAlertmanagersConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A single application container that you want to run within a pod.
 *
 * @schema ThanosRulerSpecContainers
 */
export interface ThanosRulerSpecContainers {
  /**
   * Arguments to the entrypoint.
   * The container image's CMD is used if this is not provided.
   * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
   * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
   * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
   * of whether the variable exists or not. Cannot be updated.
   * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema ThanosRulerSpecContainers#args
   */
  readonly args?: string[];

  /**
   * Entrypoint array. Not executed within a shell.
   * The container image's ENTRYPOINT is used if this is not provided.
   * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
   * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
   * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
   * of whether the variable exists or not. Cannot be updated.
   * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema ThanosRulerSpecContainers#command
   */
  readonly command?: string[];

  /**
   * List of environment variables to set in the container.
   * Cannot be updated.
   *
   * @schema ThanosRulerSpecContainers#env
   */
  readonly env?: ThanosRulerSpecContainersEnv[];

  /**
   * List of sources to populate environment variables in the container.
   * The keys defined within a source must be a C_IDENTIFIER. All invalid keys
   * will be reported as an event when the container is starting. When a key exists in multiple
   * sources, the value associated with the last source will take precedence.
   * Values defined by an Env with a duplicate key will take precedence.
   * Cannot be updated.
   *
   * @schema ThanosRulerSpecContainers#envFrom
   */
  readonly envFrom?: ThanosRulerSpecContainersEnvFrom[];

  /**
   * Container image name.
   * More info: https://kubernetes.io/docs/concepts/containers/images
   * This field is optional to allow higher level config management to default or override
   * container images in workload controllers like Deployments and StatefulSets.
   *
   * @schema ThanosRulerSpecContainers#image
   */
  readonly image?: string;

  /**
   * Image pull policy.
   * One of Always, Never, IfNotPresent.
   * Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   *
   * @default Always if :latest tag is specified, or IfNotPresent otherwise.
   * @schema ThanosRulerSpecContainers#imagePullPolicy
   */
  readonly imagePullPolicy?: string;

  /**
   * Actions that the management system should take in response to container lifecycle events.
   * Cannot be updated.
   *
   * @schema ThanosRulerSpecContainers#lifecycle
   */
  readonly lifecycle?: ThanosRulerSpecContainersLifecycle;

  /**
   * Periodic probe of container liveness.
   * Container will be restarted if the probe fails.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema ThanosRulerSpecContainers#livenessProbe
   */
  readonly livenessProbe?: ThanosRulerSpecContainersLivenessProbe;

  /**
   * Name of the container specified as a DNS_LABEL.
   * Each container in a pod must have a unique name (DNS_LABEL).
   * Cannot be updated.
   *
   * @schema ThanosRulerSpecContainers#name
   */
  readonly name: string;

  /**
   * List of ports to expose from the container. Not specifying a port here
   * DOES NOT prevent that port from being exposed. Any port which is
   * listening on the default "0.0.0.0" address inside a container will be
   * accessible from the network.
   * Modifying this array with strategic merge patch may corrupt the data.
   * For more information See https://github.com/kubernetes/kubernetes/issues/108255.
   * Cannot be updated.
   *
   * @schema ThanosRulerSpecContainers#ports
   */
  readonly ports?: ThanosRulerSpecContainersPorts[];

  /**
   * Periodic probe of container service readiness.
   * Container will be removed from service endpoints if the probe fails.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema ThanosRulerSpecContainers#readinessProbe
   */
  readonly readinessProbe?: ThanosRulerSpecContainersReadinessProbe;

  /**
   * Resources resize policy for the container.
   *
   * @schema ThanosRulerSpecContainers#resizePolicy
   */
  readonly resizePolicy?: ThanosRulerSpecContainersResizePolicy[];

  /**
   * Compute Resources required by this container.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ThanosRulerSpecContainers#resources
   */
  readonly resources?: ThanosRulerSpecContainersResources;

  /**
   * RestartPolicy defines the restart behavior of individual containers in a pod.
   * This field may only be set for init containers, and the only allowed value is "Always".
   * For non-init containers or when this field is not specified,
   * the restart behavior is defined by the Pod's restart policy and the container type.
   * Setting the RestartPolicy as "Always" for the init container will have the following effect:
   * this init container will be continually restarted on
   * exit until all regular containers have terminated. Once all regular
   * containers have completed, all init containers with restartPolicy "Always"
   * will be shut down. This lifecycle differs from normal init containers and
   * is often referred to as a "sidecar" container. Although this init
   * container still starts in the init container sequence, it does not wait
   * for the container to complete before proceeding to the next init
   * container. Instead, the next init container starts immediately after this
   * init container is started, or after any startupProbe has successfully
   * completed.
   *
   * @schema ThanosRulerSpecContainers#restartPolicy
   */
  readonly restartPolicy?: string;

  /**
   * SecurityContext defines the security options the container should be run with.
   * If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
   * More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
   *
   * @schema ThanosRulerSpecContainers#securityContext
   */
  readonly securityContext?: ThanosRulerSpecContainersSecurityContext;

  /**
   * StartupProbe indicates that the Pod has successfully initialized.
   * If specified, no other probes are executed until this completes successfully.
   * If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
   * This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
   * when it might take a long time to load data or warm a cache, than during steady-state operation.
   * This cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema ThanosRulerSpecContainers#startupProbe
   */
  readonly startupProbe?: ThanosRulerSpecContainersStartupProbe;

  /**
   * Whether this container should allocate a buffer for stdin in the container runtime. If this
   * is not set, reads from stdin in the container will always result in EOF.
   * Default is false.
   *
   * @default false.
   * @schema ThanosRulerSpecContainers#stdin
   */
  readonly stdin?: boolean;

  /**
   * Whether the container runtime should close the stdin channel after it has been opened by
   * a single attach. When stdin is true the stdin stream will remain open across multiple attach
   * sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
   * first client attaches to stdin, and then remains open and accepts data until the client disconnects,
   * at which time stdin is closed and remains closed until the container is restarted. If this
   * flag is false, a container processes that reads from stdin will never receive an EOF.
   * Default is false
   *
   * @default false
   * @schema ThanosRulerSpecContainers#stdinOnce
   */
  readonly stdinOnce?: boolean;

  /**
   * Optional: Path at which the file to which the container's termination message
   * will be written is mounted into the container's filesystem.
   * Message written is intended to be brief final status, such as an assertion failure message.
   * Will be truncated by the node if greater than 4096 bytes. The total message length across
   * all containers will be limited to 12kb.
   * Defaults to /dev/termination-log.
   * Cannot be updated.
   *
   * @default dev/termination-log.
   * @schema ThanosRulerSpecContainers#terminationMessagePath
   */
  readonly terminationMessagePath?: string;

  /**
   * Indicate how the termination message should be populated. File will use the contents of
   * terminationMessagePath to populate the container status message on both success and failure.
   * FallbackToLogsOnError will use the last chunk of container log output if the termination
   * message file is empty and the container exited with an error.
   * The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
   * Defaults to File.
   * Cannot be updated.
   *
   * @default File.
   * @schema ThanosRulerSpecContainers#terminationMessagePolicy
   */
  readonly terminationMessagePolicy?: string;

  /**
   * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
   * Default is false.
   *
   * @default false.
   * @schema ThanosRulerSpecContainers#tty
   */
  readonly tty?: boolean;

  /**
   * volumeDevices is the list of block devices to be used by the container.
   *
   * @schema ThanosRulerSpecContainers#volumeDevices
   */
  readonly volumeDevices?: ThanosRulerSpecContainersVolumeDevices[];

  /**
   * Pod volumes to mount into the container's filesystem.
   * Cannot be updated.
   *
   * @schema ThanosRulerSpecContainers#volumeMounts
   */
  readonly volumeMounts?: ThanosRulerSpecContainersVolumeMounts[];

  /**
   * Container's working directory.
   * If not specified, the container runtime's default will be used, which
   * might be configured in the container image.
   * Cannot be updated.
   *
   * @schema ThanosRulerSpecContainers#workingDir
   */
  readonly workingDir?: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecContainers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainers(obj: ThanosRulerSpecContainers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'args': obj.args?.map(y => y),
    'command': obj.command?.map(y => y),
    'env': obj.env?.map(y => toJson_ThanosRulerSpecContainersEnv(y)),
    'envFrom': obj.envFrom?.map(y => toJson_ThanosRulerSpecContainersEnvFrom(y)),
    'image': obj.image,
    'imagePullPolicy': obj.imagePullPolicy,
    'lifecycle': toJson_ThanosRulerSpecContainersLifecycle(obj.lifecycle),
    'livenessProbe': toJson_ThanosRulerSpecContainersLivenessProbe(obj.livenessProbe),
    'name': obj.name,
    'ports': obj.ports?.map(y => toJson_ThanosRulerSpecContainersPorts(y)),
    'readinessProbe': toJson_ThanosRulerSpecContainersReadinessProbe(obj.readinessProbe),
    'resizePolicy': obj.resizePolicy?.map(y => toJson_ThanosRulerSpecContainersResizePolicy(y)),
    'resources': toJson_ThanosRulerSpecContainersResources(obj.resources),
    'restartPolicy': obj.restartPolicy,
    'securityContext': toJson_ThanosRulerSpecContainersSecurityContext(obj.securityContext),
    'startupProbe': toJson_ThanosRulerSpecContainersStartupProbe(obj.startupProbe),
    'stdin': obj.stdin,
    'stdinOnce': obj.stdinOnce,
    'terminationMessagePath': obj.terminationMessagePath,
    'terminationMessagePolicy': obj.terminationMessagePolicy,
    'tty': obj.tty,
    'volumeDevices': obj.volumeDevices?.map(y => toJson_ThanosRulerSpecContainersVolumeDevices(y)),
    'volumeMounts': obj.volumeMounts?.map(y => toJson_ThanosRulerSpecContainersVolumeMounts(y)),
    'workingDir': obj.workingDir,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ObjectReference references a PodMonitor, ServiceMonitor, Probe or PrometheusRule object.
 *
 * @schema ThanosRulerSpecExcludedFromEnforcement
 */
export interface ThanosRulerSpecExcludedFromEnforcement {
  /**
   * Group of the referent. When not specified, it defaults to `monitoring.coreos.com`
   *
   * @schema ThanosRulerSpecExcludedFromEnforcement#group
   */
  readonly group?: ThanosRulerSpecExcludedFromEnforcementGroup;

  /**
   * Name of the referent. When not set, all resources in the namespace are matched.
   *
   * @schema ThanosRulerSpecExcludedFromEnforcement#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ThanosRulerSpecExcludedFromEnforcement#namespace
   */
  readonly namespace: string;

  /**
   * Resource of the referent.
   *
   * @schema ThanosRulerSpecExcludedFromEnforcement#resource
   */
  readonly resource: ThanosRulerSpecExcludedFromEnforcementResource;

}

/**
 * Converts an object of type 'ThanosRulerSpecExcludedFromEnforcement' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecExcludedFromEnforcement(obj: ThanosRulerSpecExcludedFromEnforcement | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'name': obj.name,
    'namespace': obj.namespace,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPCServerTLSConfig configures the gRPC server from which Thanos Querier reads
 * recorded rule data.
 * Note: Currently only the CAFile, CertFile, and KeyFile fields are supported.
 * Maps to the '--grpc-server-tls-*' CLI args.
 *
 * @schema ThanosRulerSpecGrpcServerTlsConfig
 */
export interface ThanosRulerSpecGrpcServerTlsConfig {
  /**
   * Certificate authority used when verifying server certificates.
   *
   * @schema ThanosRulerSpecGrpcServerTlsConfig#ca
   */
  readonly ca?: ThanosRulerSpecGrpcServerTlsConfigCa;

  /**
   * Path to the CA cert in the Prometheus container to use for the targets.
   *
   * @schema ThanosRulerSpecGrpcServerTlsConfig#caFile
   */
  readonly caFile?: string;

  /**
   * Client certificate to present when doing client-authentication.
   *
   * @schema ThanosRulerSpecGrpcServerTlsConfig#cert
   */
  readonly cert?: ThanosRulerSpecGrpcServerTlsConfigCert;

  /**
   * Path to the client cert file in the Prometheus container for the targets.
   *
   * @schema ThanosRulerSpecGrpcServerTlsConfig#certFile
   */
  readonly certFile?: string;

  /**
   * Disable target certificate validation.
   *
   * @schema ThanosRulerSpecGrpcServerTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Path to the client key file in the Prometheus container for the targets.
   *
   * @schema ThanosRulerSpecGrpcServerTlsConfig#keyFile
   */
  readonly keyFile?: string;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema ThanosRulerSpecGrpcServerTlsConfig#keySecret
   */
  readonly keySecret?: ThanosRulerSpecGrpcServerTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema ThanosRulerSpecGrpcServerTlsConfig#serverName
   */
  readonly serverName?: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecGrpcServerTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecGrpcServerTlsConfig(obj: ThanosRulerSpecGrpcServerTlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ca': toJson_ThanosRulerSpecGrpcServerTlsConfigCa(obj.ca),
    'caFile': obj.caFile,
    'cert': toJson_ThanosRulerSpecGrpcServerTlsConfigCert(obj.cert),
    'certFile': obj.certFile,
    'insecureSkipVerify': obj.insecureSkipVerify,
    'keyFile': obj.keyFile,
    'keySecret': toJson_ThanosRulerSpecGrpcServerTlsConfigKeySecret(obj.keySecret),
    'serverName': obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the
 * pod's hosts file.
 *
 * @schema ThanosRulerSpecHostAliases
 */
export interface ThanosRulerSpecHostAliases {
  /**
   * Hostnames for the above IP address.
   *
   * @schema ThanosRulerSpecHostAliases#hostnames
   */
  readonly hostnames: string[];

  /**
   * IP address of the host file entry.
   *
   * @schema ThanosRulerSpecHostAliases#ip
   */
  readonly ip: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecHostAliases' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecHostAliases(obj: ThanosRulerSpecHostAliases | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostnames': obj.hostnames?.map(y => y),
    'ip': obj.ip,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Image pull policy for the 'thanos', 'init-config-reloader' and 'config-reloader' containers.
 * See https://kubernetes.io/docs/concepts/containers/images/#image-pull-policy for more details.
 *
 * @schema ThanosRulerSpecImagePullPolicy
 */
export enum ThanosRulerSpecImagePullPolicy {
  /** Always */
  ALWAYS = "Always",
  /** Never */
  NEVER = "Never",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * LocalObjectReference contains enough information to let you locate the
 * referenced object inside the same namespace.
 *
 * @schema ThanosRulerSpecImagePullSecrets
 */
export interface ThanosRulerSpecImagePullSecrets {
  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ThanosRulerSpecImagePullSecrets#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecImagePullSecrets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecImagePullSecrets(obj: ThanosRulerSpecImagePullSecrets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A single application container that you want to run within a pod.
 *
 * @schema ThanosRulerSpecInitContainers
 */
export interface ThanosRulerSpecInitContainers {
  /**
   * Arguments to the entrypoint.
   * The container image's CMD is used if this is not provided.
   * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
   * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
   * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
   * of whether the variable exists or not. Cannot be updated.
   * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema ThanosRulerSpecInitContainers#args
   */
  readonly args?: string[];

  /**
   * Entrypoint array. Not executed within a shell.
   * The container image's ENTRYPOINT is used if this is not provided.
   * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
   * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
   * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
   * of whether the variable exists or not. Cannot be updated.
   * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema ThanosRulerSpecInitContainers#command
   */
  readonly command?: string[];

  /**
   * List of environment variables to set in the container.
   * Cannot be updated.
   *
   * @schema ThanosRulerSpecInitContainers#env
   */
  readonly env?: ThanosRulerSpecInitContainersEnv[];

  /**
   * List of sources to populate environment variables in the container.
   * The keys defined within a source must be a C_IDENTIFIER. All invalid keys
   * will be reported as an event when the container is starting. When a key exists in multiple
   * sources, the value associated with the last source will take precedence.
   * Values defined by an Env with a duplicate key will take precedence.
   * Cannot be updated.
   *
   * @schema ThanosRulerSpecInitContainers#envFrom
   */
  readonly envFrom?: ThanosRulerSpecInitContainersEnvFrom[];

  /**
   * Container image name.
   * More info: https://kubernetes.io/docs/concepts/containers/images
   * This field is optional to allow higher level config management to default or override
   * container images in workload controllers like Deployments and StatefulSets.
   *
   * @schema ThanosRulerSpecInitContainers#image
   */
  readonly image?: string;

  /**
   * Image pull policy.
   * One of Always, Never, IfNotPresent.
   * Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   *
   * @default Always if :latest tag is specified, or IfNotPresent otherwise.
   * @schema ThanosRulerSpecInitContainers#imagePullPolicy
   */
  readonly imagePullPolicy?: string;

  /**
   * Actions that the management system should take in response to container lifecycle events.
   * Cannot be updated.
   *
   * @schema ThanosRulerSpecInitContainers#lifecycle
   */
  readonly lifecycle?: ThanosRulerSpecInitContainersLifecycle;

  /**
   * Periodic probe of container liveness.
   * Container will be restarted if the probe fails.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema ThanosRulerSpecInitContainers#livenessProbe
   */
  readonly livenessProbe?: ThanosRulerSpecInitContainersLivenessProbe;

  /**
   * Name of the container specified as a DNS_LABEL.
   * Each container in a pod must have a unique name (DNS_LABEL).
   * Cannot be updated.
   *
   * @schema ThanosRulerSpecInitContainers#name
   */
  readonly name: string;

  /**
   * List of ports to expose from the container. Not specifying a port here
   * DOES NOT prevent that port from being exposed. Any port which is
   * listening on the default "0.0.0.0" address inside a container will be
   * accessible from the network.
   * Modifying this array with strategic merge patch may corrupt the data.
   * For more information See https://github.com/kubernetes/kubernetes/issues/108255.
   * Cannot be updated.
   *
   * @schema ThanosRulerSpecInitContainers#ports
   */
  readonly ports?: ThanosRulerSpecInitContainersPorts[];

  /**
   * Periodic probe of container service readiness.
   * Container will be removed from service endpoints if the probe fails.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema ThanosRulerSpecInitContainers#readinessProbe
   */
  readonly readinessProbe?: ThanosRulerSpecInitContainersReadinessProbe;

  /**
   * Resources resize policy for the container.
   *
   * @schema ThanosRulerSpecInitContainers#resizePolicy
   */
  readonly resizePolicy?: ThanosRulerSpecInitContainersResizePolicy[];

  /**
   * Compute Resources required by this container.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ThanosRulerSpecInitContainers#resources
   */
  readonly resources?: ThanosRulerSpecInitContainersResources;

  /**
   * RestartPolicy defines the restart behavior of individual containers in a pod.
   * This field may only be set for init containers, and the only allowed value is "Always".
   * For non-init containers or when this field is not specified,
   * the restart behavior is defined by the Pod's restart policy and the container type.
   * Setting the RestartPolicy as "Always" for the init container will have the following effect:
   * this init container will be continually restarted on
   * exit until all regular containers have terminated. Once all regular
   * containers have completed, all init containers with restartPolicy "Always"
   * will be shut down. This lifecycle differs from normal init containers and
   * is often referred to as a "sidecar" container. Although this init
   * container still starts in the init container sequence, it does not wait
   * for the container to complete before proceeding to the next init
   * container. Instead, the next init container starts immediately after this
   * init container is started, or after any startupProbe has successfully
   * completed.
   *
   * @schema ThanosRulerSpecInitContainers#restartPolicy
   */
  readonly restartPolicy?: string;

  /**
   * SecurityContext defines the security options the container should be run with.
   * If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
   * More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
   *
   * @schema ThanosRulerSpecInitContainers#securityContext
   */
  readonly securityContext?: ThanosRulerSpecInitContainersSecurityContext;

  /**
   * StartupProbe indicates that the Pod has successfully initialized.
   * If specified, no other probes are executed until this completes successfully.
   * If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
   * This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
   * when it might take a long time to load data or warm a cache, than during steady-state operation.
   * This cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema ThanosRulerSpecInitContainers#startupProbe
   */
  readonly startupProbe?: ThanosRulerSpecInitContainersStartupProbe;

  /**
   * Whether this container should allocate a buffer for stdin in the container runtime. If this
   * is not set, reads from stdin in the container will always result in EOF.
   * Default is false.
   *
   * @default false.
   * @schema ThanosRulerSpecInitContainers#stdin
   */
  readonly stdin?: boolean;

  /**
   * Whether the container runtime should close the stdin channel after it has been opened by
   * a single attach. When stdin is true the stdin stream will remain open across multiple attach
   * sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
   * first client attaches to stdin, and then remains open and accepts data until the client disconnects,
   * at which time stdin is closed and remains closed until the container is restarted. If this
   * flag is false, a container processes that reads from stdin will never receive an EOF.
   * Default is false
   *
   * @default false
   * @schema ThanosRulerSpecInitContainers#stdinOnce
   */
  readonly stdinOnce?: boolean;

  /**
   * Optional: Path at which the file to which the container's termination message
   * will be written is mounted into the container's filesystem.
   * Message written is intended to be brief final status, such as an assertion failure message.
   * Will be truncated by the node if greater than 4096 bytes. The total message length across
   * all containers will be limited to 12kb.
   * Defaults to /dev/termination-log.
   * Cannot be updated.
   *
   * @default dev/termination-log.
   * @schema ThanosRulerSpecInitContainers#terminationMessagePath
   */
  readonly terminationMessagePath?: string;

  /**
   * Indicate how the termination message should be populated. File will use the contents of
   * terminationMessagePath to populate the container status message on both success and failure.
   * FallbackToLogsOnError will use the last chunk of container log output if the termination
   * message file is empty and the container exited with an error.
   * The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
   * Defaults to File.
   * Cannot be updated.
   *
   * @default File.
   * @schema ThanosRulerSpecInitContainers#terminationMessagePolicy
   */
  readonly terminationMessagePolicy?: string;

  /**
   * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
   * Default is false.
   *
   * @default false.
   * @schema ThanosRulerSpecInitContainers#tty
   */
  readonly tty?: boolean;

  /**
   * volumeDevices is the list of block devices to be used by the container.
   *
   * @schema ThanosRulerSpecInitContainers#volumeDevices
   */
  readonly volumeDevices?: ThanosRulerSpecInitContainersVolumeDevices[];

  /**
   * Pod volumes to mount into the container's filesystem.
   * Cannot be updated.
   *
   * @schema ThanosRulerSpecInitContainers#volumeMounts
   */
  readonly volumeMounts?: ThanosRulerSpecInitContainersVolumeMounts[];

  /**
   * Container's working directory.
   * If not specified, the container runtime's default will be used, which
   * might be configured in the container image.
   * Cannot be updated.
   *
   * @schema ThanosRulerSpecInitContainers#workingDir
   */
  readonly workingDir?: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainers(obj: ThanosRulerSpecInitContainers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'args': obj.args?.map(y => y),
    'command': obj.command?.map(y => y),
    'env': obj.env?.map(y => toJson_ThanosRulerSpecInitContainersEnv(y)),
    'envFrom': obj.envFrom?.map(y => toJson_ThanosRulerSpecInitContainersEnvFrom(y)),
    'image': obj.image,
    'imagePullPolicy': obj.imagePullPolicy,
    'lifecycle': toJson_ThanosRulerSpecInitContainersLifecycle(obj.lifecycle),
    'livenessProbe': toJson_ThanosRulerSpecInitContainersLivenessProbe(obj.livenessProbe),
    'name': obj.name,
    'ports': obj.ports?.map(y => toJson_ThanosRulerSpecInitContainersPorts(y)),
    'readinessProbe': toJson_ThanosRulerSpecInitContainersReadinessProbe(obj.readinessProbe),
    'resizePolicy': obj.resizePolicy?.map(y => toJson_ThanosRulerSpecInitContainersResizePolicy(y)),
    'resources': toJson_ThanosRulerSpecInitContainersResources(obj.resources),
    'restartPolicy': obj.restartPolicy,
    'securityContext': toJson_ThanosRulerSpecInitContainersSecurityContext(obj.securityContext),
    'startupProbe': toJson_ThanosRulerSpecInitContainersStartupProbe(obj.startupProbe),
    'stdin': obj.stdin,
    'stdinOnce': obj.stdinOnce,
    'terminationMessagePath': obj.terminationMessagePath,
    'terminationMessagePolicy': obj.terminationMessagePolicy,
    'tty': obj.tty,
    'volumeDevices': obj.volumeDevices?.map(y => toJson_ThanosRulerSpecInitContainersVolumeDevices(y)),
    'volumeMounts': obj.volumeMounts?.map(y => toJson_ThanosRulerSpecInitContainersVolumeMounts(y)),
    'workingDir': obj.workingDir,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Log format for ThanosRuler to be configured with.
 *
 * @schema ThanosRulerSpecLogFormat
 */
export enum ThanosRulerSpecLogFormat {
  /** logfmt */
  LOGFMT = "logfmt",
  /** json */
  JSON = "json",
}

/**
 * Log level for ThanosRuler to be configured with.
 *
 * @schema ThanosRulerSpecLogLevel
 */
export enum ThanosRulerSpecLogLevel {
  /** debug */
  DEBUG = "debug",
  /** info */
  INFO = "info",
  /** warn */
  WARN = "warn",
  /** error */
  ERROR = "error",
}

/**
 * ObjectStorageConfig configures object storage in Thanos.
 * Alternative to ObjectStorageConfigFile, and lower order priority.
 *
 * @schema ThanosRulerSpecObjectStorageConfig
 */
export interface ThanosRulerSpecObjectStorageConfig {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ThanosRulerSpecObjectStorageConfig#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ThanosRulerSpecObjectStorageConfig#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ThanosRulerSpecObjectStorageConfig#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ThanosRulerSpecObjectStorageConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecObjectStorageConfig(obj: ThanosRulerSpecObjectStorageConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PodMetadata configures labels and annotations which are propagated to the ThanosRuler pods.
 *
 *
 * The following items are reserved and cannot be overridden:
 * * "app.kubernetes.io/name" label, set to "thanos-ruler".
 * * "app.kubernetes.io/managed-by" label, set to "prometheus-operator".
 * * "app.kubernetes.io/instance" label, set to the name of the ThanosRuler instance.
 * * "thanos-ruler" label, set to the name of the ThanosRuler instance.
 * * "kubectl.kubernetes.io/default-container" annotation, set to "thanos-ruler".
 *
 * @schema ThanosRulerSpecPodMetadata
 */
export interface ThanosRulerSpecPodMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be
   * set by external tools to store and retrieve arbitrary metadata. They are not
   * queryable and should be preserved when modifying objects.
   * More info: http://kubernetes.io/docs/user-guide/annotations
   *
   * @schema ThanosRulerSpecPodMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Map of string keys and values that can be used to organize and categorize
   * (scope and select) objects. May match selectors of replication controllers
   * and services.
   * More info: http://kubernetes.io/docs/user-guide/labels
   *
   * @schema ThanosRulerSpecPodMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Name must be unique within a namespace. Is required when creating resources, although
   * some resources may allow a client to request the generation of an appropriate name
   * automatically. Name is primarily intended for creation idempotence and configuration
   * definition.
   * Cannot be updated.
   * More info: http://kubernetes.io/docs/user-guide/identifiers#names
   *
   * @schema ThanosRulerSpecPodMetadata#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecPodMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecPodMetadata(obj: ThanosRulerSpecPodMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PrometheusRuleExcludeConfig enables users to configure excluded
 * PrometheusRule names and their namespaces to be ignored while enforcing
 * namespace label for alerts and metrics.
 *
 * @schema ThanosRulerSpecPrometheusRulesExcludedFromEnforce
 */
export interface ThanosRulerSpecPrometheusRulesExcludedFromEnforce {
  /**
   * Name of the excluded PrometheusRule object.
   *
   * @schema ThanosRulerSpecPrometheusRulesExcludedFromEnforce#ruleName
   */
  readonly ruleName: string;

  /**
   * Namespace of the excluded PrometheusRule object.
   *
   * @schema ThanosRulerSpecPrometheusRulesExcludedFromEnforce#ruleNamespace
   */
  readonly ruleNamespace: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecPrometheusRulesExcludedFromEnforce' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecPrometheusRulesExcludedFromEnforce(obj: ThanosRulerSpecPrometheusRulesExcludedFromEnforce | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ruleName': obj.ruleName,
    'ruleNamespace': obj.ruleNamespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Define configuration for connecting to thanos query instances.
 * If this is defined, the QueryEndpoints field will be ignored.
 * Maps to the `query.config` CLI argument.
 * Only available with thanos v0.11.0 and higher.
 *
 * @schema ThanosRulerSpecQueryConfig
 */
export interface ThanosRulerSpecQueryConfig {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ThanosRulerSpecQueryConfig#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ThanosRulerSpecQueryConfig#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ThanosRulerSpecQueryConfig#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ThanosRulerSpecQueryConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecQueryConfig(obj: ThanosRulerSpecQueryConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resources defines the resource requirements for single Pods.
 * If not provided, no requests/limits will be set
 *
 * @schema ThanosRulerSpecResources
 */
export interface ThanosRulerSpecResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema ThanosRulerSpecResources#claims
   */
  readonly claims?: ThanosRulerSpecResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ThanosRulerSpecResources#limits
   */
  readonly limits?: { [key: string]: ThanosRulerSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ThanosRulerSpecResources#requests
   */
  readonly requests?: { [key: string]: ThanosRulerSpecResourcesRequests };

}

/**
 * Converts an object of type 'ThanosRulerSpecResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecResources(obj: ThanosRulerSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claims': obj.claims?.map(y => toJson_ThanosRulerSpecResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Namespaces to be selected for Rules discovery. If unspecified, only
 * the same namespace as the ThanosRuler object is in is used.
 *
 * @schema ThanosRulerSpecRuleNamespaceSelector
 */
export interface ThanosRulerSpecRuleNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ThanosRulerSpecRuleNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: ThanosRulerSpecRuleNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ThanosRulerSpecRuleNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ThanosRulerSpecRuleNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecRuleNamespaceSelector(obj: ThanosRulerSpecRuleNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ThanosRulerSpecRuleNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector to select which PrometheusRules to mount for alerting and
 * recording.
 *
 * @schema ThanosRulerSpecRuleSelector
 */
export interface ThanosRulerSpecRuleSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ThanosRulerSpecRuleSelector#matchExpressions
   */
  readonly matchExpressions?: ThanosRulerSpecRuleSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ThanosRulerSpecRuleSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ThanosRulerSpecRuleSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecRuleSelector(obj: ThanosRulerSpecRuleSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ThanosRulerSpecRuleSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecurityContext holds pod-level security attributes and common container settings.
 * This defaults to the default PodSecurityContext.
 *
 * @schema ThanosRulerSpecSecurityContext
 */
export interface ThanosRulerSpecSecurityContext {
  /**
   * A special supplemental group that applies to all containers in a pod.
   * Some volume types allow the Kubelet to change the ownership of that volume
   * to be owned by the pod:
   *
   *
   * 1. The owning GID will be the FSGroup
   * 2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
   * 3. The permission bits are OR'd with rw-rw----
   *
   *
   * If unset, the Kubelet will not modify the ownership and permissions of any volume.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ThanosRulerSpecSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * fsGroupChangePolicy defines behavior of changing ownership and permission of the volume
   * before being exposed inside Pod. This field will only apply to
   * volume types which support fsGroup based ownership(and permissions).
   * It will have no effect on ephemeral volume types such as: secret, configmaps
   * and emptydir.
   * Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ThanosRulerSpecSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * The GID to run the entrypoint of the container process.
   * Uses runtime default if unset.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence
   * for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ThanosRulerSpecSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user.
   * If true, the Kubelet will validate the image at runtime to ensure that it
   * does not run as UID 0 (root) and fail to start the container if it does.
   * If unset or false, no such validation will be performed.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema ThanosRulerSpecSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process.
   * Defaults to user specified in image metadata if unspecified.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence
   * for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified.
   * @schema ThanosRulerSpecSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to all containers.
   * If unspecified, the container runtime will allocate a random SELinux context for each
   * container.  May also be set in SecurityContext.  If set in
   * both SecurityContext and PodSecurityContext, the value specified in SecurityContext
   * takes precedence for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ThanosRulerSpecSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: ThanosRulerSpecSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by the containers in this pod.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ThanosRulerSpecSecurityContext#seccompProfile
   */
  readonly seccompProfile?: ThanosRulerSpecSecurityContextSeccompProfile;

  /**
   * A list of groups applied to the first process run in each container, in addition
   * to the container's primary GID, the fsGroup (if specified), and group memberships
   * defined in the container image for the uid of the container process. If unspecified,
   * no additional groups are added to any container. Note that group memberships
   * defined in the container image for the uid of the container process are still effective,
   * even if they are not included in this list.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ThanosRulerSpecSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported
   * sysctls (by the container runtime) might fail to launch.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ThanosRulerSpecSecurityContext#sysctls
   */
  readonly sysctls?: ThanosRulerSpecSecurityContextSysctls[];

  /**
   * The Windows specific settings applied to all containers.
   * If unspecified, the options within a container's SecurityContext will be used.
   * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema ThanosRulerSpecSecurityContext#windowsOptions
   */
  readonly windowsOptions?: ThanosRulerSpecSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'ThanosRulerSpecSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecSecurityContext(obj: ThanosRulerSpecSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsGroup': obj.fsGroup,
    'fsGroupChangePolicy': obj.fsGroupChangePolicy,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_ThanosRulerSpecSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_ThanosRulerSpecSecurityContextSeccompProfile(obj.seccompProfile),
    'supplementalGroups': obj.supplementalGroups?.map(y => y),
    'sysctls': obj.sysctls?.map(y => toJson_ThanosRulerSpecSecurityContextSysctls(y)),
    'windowsOptions': toJson_ThanosRulerSpecSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Storage spec to specify how storage shall be used.
 *
 * @schema ThanosRulerSpecStorage
 */
export interface ThanosRulerSpecStorage {
  /**
   * Deprecated: subPath usage will be removed in a future release.
   *
   * @schema ThanosRulerSpecStorage#disableMountSubPath
   */
  readonly disableMountSubPath?: boolean;

  /**
   * EmptyDirVolumeSource to be used by the StatefulSet.
   * If specified, it takes precedence over `ephemeral` and `volumeClaimTemplate`.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes/#emptydir
   *
   * @schema ThanosRulerSpecStorage#emptyDir
   */
  readonly emptyDir?: ThanosRulerSpecStorageEmptyDir;

  /**
   * EphemeralVolumeSource to be used by the StatefulSet.
   * This is a beta field in k8s 1.21 and GA in 1.15.
   * For lower versions, starting with k8s 1.19, it requires enabling the GenericEphemeralVolume feature gate.
   * More info: https://kubernetes.io/docs/concepts/storage/ephemeral-volumes/#generic-ephemeral-volumes
   *
   * @schema ThanosRulerSpecStorage#ephemeral
   */
  readonly ephemeral?: ThanosRulerSpecStorageEphemeral;

  /**
   * Defines the PVC spec to be used by the Prometheus StatefulSets.
   * The easiest way to use a volume that cannot be automatically provisioned
   * is to use a label selector alongside manually created PersistentVolumes.
   *
   * @schema ThanosRulerSpecStorage#volumeClaimTemplate
   */
  readonly volumeClaimTemplate?: ThanosRulerSpecStorageVolumeClaimTemplate;

}

/**
 * Converts an object of type 'ThanosRulerSpecStorage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecStorage(obj: ThanosRulerSpecStorage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disableMountSubPath': obj.disableMountSubPath,
    'emptyDir': toJson_ThanosRulerSpecStorageEmptyDir(obj.emptyDir),
    'ephemeral': toJson_ThanosRulerSpecStorageEphemeral(obj.ephemeral),
    'volumeClaimTemplate': toJson_ThanosRulerSpecStorageVolumeClaimTemplate(obj.volumeClaimTemplate),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema ThanosRulerSpecTolerations
 */
export interface ThanosRulerSpecTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema ThanosRulerSpecTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema ThanosRulerSpecTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema ThanosRulerSpecTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict). Zero and
   * negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema ThanosRulerSpecTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema ThanosRulerSpecTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecTolerations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecTolerations(obj: ThanosRulerSpecTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TopologySpreadConstraint specifies how to spread matching pods among the given topology.
 *
 * @schema ThanosRulerSpecTopologySpreadConstraints
 */
export interface ThanosRulerSpecTopologySpreadConstraints {
  /**
   * LabelSelector is used to find matching pods.
   * Pods that match this label selector are counted to determine the number of pods
   * in their corresponding topology domain.
   *
   * @schema ThanosRulerSpecTopologySpreadConstraints#labelSelector
   */
  readonly labelSelector?: ThanosRulerSpecTopologySpreadConstraintsLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select the pods over which
   * spreading will be calculated. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are ANDed with labelSelector
   * to select the group of existing pods over which spreading will be calculated
   * for the incoming pod. The same key is forbidden to exist in both MatchLabelKeys and LabelSelector.
   * MatchLabelKeys cannot be set when LabelSelector isn't set.
   * Keys that don't exist in the incoming pod labels will
   * be ignored. A null or empty list means only match against labelSelector.
   *
   *
   * This is a beta field and requires the MatchLabelKeysInPodTopologySpread feature gate to be enabled (enabled by default).
   *
   * @schema ThanosRulerSpecTopologySpreadConstraints#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MaxSkew describes the degree to which pods may be unevenly distributed.
   * When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted difference
   * between the number of matching pods in the target topology and the global minimum.
   * The global minimum is the minimum number of matching pods in an eligible domain
   * or zero if the number of eligible domains is less than MinDomains.
   * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
   * labelSelector spread as 2/2/1:
   * In this case, the global minimum is 1.
   * | zone1 | zone2 | zone3 |
   * |  P P  |  P P  |   P   |
   * - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 2/2/2;
   * scheduling it onto zone1(zone2) would make the ActualSkew(3-1) on zone1(zone2)
   * violate MaxSkew(1).
   * - if MaxSkew is 2, incoming pod can be scheduled onto any zone.
   * When `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher precedence
   * to topologies that satisfy it.
   * It's a required field. Default value is 1 and 0 is not allowed.
   *
   * @schema ThanosRulerSpecTopologySpreadConstraints#maxSkew
   */
  readonly maxSkew: number;

  /**
   * MinDomains indicates a minimum number of eligible domains.
   * When the number of eligible domains with matching topology keys is less than minDomains,
   * Pod Topology Spread treats "global minimum" as 0, and then the calculation of Skew is performed.
   * And when the number of eligible domains with matching topology keys equals or greater than minDomains,
   * this value has no effect on scheduling.
   * As a result, when the number of eligible domains is less than minDomains,
   * scheduler won't schedule more than maxSkew Pods to those domains.
   * If value is nil, the constraint behaves as if MinDomains is equal to 1.
   * Valid values are integers greater than 0.
   * When value is not nil, WhenUnsatisfiable must be DoNotSchedule.
   *
   *
   * For example, in a 3-zone cluster, MaxSkew is set to 2, MinDomains is set to 5 and pods with the same
   * labelSelector spread as 2/2/2:
   * | zone1 | zone2 | zone3 |
   * |  P P  |  P P  |  P P  |
   * The number of domains is less than 5(MinDomains), so "global minimum" is treated as 0.
   * In this situation, new pod with the same labelSelector cannot be scheduled,
   * because computed skew will be 3(3 - 0) if new Pod is scheduled to any of the three zones,
   * it will violate MaxSkew.
   *
   *
   * This is a beta field and requires the MinDomainsInPodTopologySpread feature gate to be enabled (enabled by default).
   *
   * @schema ThanosRulerSpecTopologySpreadConstraints#minDomains
   */
  readonly minDomains?: number;

  /**
   * NodeAffinityPolicy indicates how we will treat Pod's nodeAffinity/nodeSelector
   * when calculating pod topology spread skew. Options are:
   * - Honor: only nodes matching nodeAffinity/nodeSelector are included in the calculations.
   * - Ignore: nodeAffinity/nodeSelector are ignored. All nodes are included in the calculations.
   *
   *
   * If this value is nil, the behavior is equivalent to the Honor policy.
   * This is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.
   *
   * @schema ThanosRulerSpecTopologySpreadConstraints#nodeAffinityPolicy
   */
  readonly nodeAffinityPolicy?: string;

  /**
   * NodeTaintsPolicy indicates how we will treat node taints when calculating
   * pod topology spread skew. Options are:
   * - Honor: nodes without taints, along with tainted nodes for which the incoming pod
   * has a toleration, are included.
   * - Ignore: node taints are ignored. All nodes are included.
   *
   *
   * If this value is nil, the behavior is equivalent to the Ignore policy.
   * This is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.
   *
   * @schema ThanosRulerSpecTopologySpreadConstraints#nodeTaintsPolicy
   */
  readonly nodeTaintsPolicy?: string;

  /**
   * TopologyKey is the key of node labels. Nodes that have a label with this key
   * and identical values are considered to be in the same topology.
   * We consider each <key, value> as a "bucket", and try to put balanced number
   * of pods into each bucket.
   * We define a domain as a particular instance of a topology.
   * Also, we define an eligible domain as a domain whose nodes meet the requirements of
   * nodeAffinityPolicy and nodeTaintsPolicy.
   * e.g. If TopologyKey is "kubernetes.io/hostname", each Node is a domain of that topology.
   * And, if TopologyKey is "topology.kubernetes.io/zone", each zone is a domain of that topology.
   * It's a required field.
   *
   * @schema ThanosRulerSpecTopologySpreadConstraints#topologyKey
   */
  readonly topologyKey: string;

  /**
   * WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy
   * the spread constraint.
   * - DoNotSchedule (default) tells the scheduler not to schedule it.
   * - ScheduleAnyway tells the scheduler to schedule the pod in any location,
   * but giving higher precedence to topologies that would help reduce the
   * skew.
   * A constraint is considered "Unsatisfiable" for an incoming pod
   * if and only if every possible node assignment for that pod would violate
   * "MaxSkew" on some topology.
   * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
   * labelSelector spread as 3/1/1:
   * | zone1 | zone2 | zone3 |
   * | P P P |   P   |   P   |
   * If WhenUnsatisfiable is set to DoNotSchedule, incoming pod can only be scheduled
   * to zone2(zone3) to become 3/2/1(3/1/2) as ActualSkew(2-1) on zone2(zone3) satisfies
   * MaxSkew(1). In other words, the cluster can still be imbalanced, but scheduler
   * won't make it *more* imbalanced.
   * It's a required field.
   *
   * @schema ThanosRulerSpecTopologySpreadConstraints#whenUnsatisfiable
   */
  readonly whenUnsatisfiable: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecTopologySpreadConstraints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecTopologySpreadConstraints(obj: ThanosRulerSpecTopologySpreadConstraints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_ThanosRulerSpecTopologySpreadConstraintsLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'maxSkew': obj.maxSkew,
    'minDomains': obj.minDomains,
    'nodeAffinityPolicy': obj.nodeAffinityPolicy,
    'nodeTaintsPolicy': obj.nodeTaintsPolicy,
    'topologyKey': obj.topologyKey,
    'whenUnsatisfiable': obj.whenUnsatisfiable,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TracingConfig configures tracing in Thanos.
 *
 *
 * `tracingConfigFile` takes precedence over this field.
 *
 *
 * This is an *experimental feature*, it may change in any upcoming release
 * in a breaking way.
 *
 * @schema ThanosRulerSpecTracingConfig
 */
export interface ThanosRulerSpecTracingConfig {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ThanosRulerSpecTracingConfig#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ThanosRulerSpecTracingConfig#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ThanosRulerSpecTracingConfig#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ThanosRulerSpecTracingConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecTracingConfig(obj: ThanosRulerSpecTracingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema ThanosRulerSpecVolumeMounts
 */
export interface ThanosRulerSpecVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must
   * not contain ':'.
   *
   * @schema ThanosRulerSpecVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host
   * to container and the other way around.
   * When not set, MountPropagationNone is used.
   * This field is beta in 1.10.
   *
   * @schema ThanosRulerSpecVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema ThanosRulerSpecVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified).
   * Defaults to false.
   *
   * @default false.
   * @schema ThanosRulerSpecVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Path within the volume from which the container's volume should be mounted.
   * Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema ThanosRulerSpecVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted.
   * Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
   * Defaults to "" (volume's root).
   * SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root).
   * @schema ThanosRulerSpecVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumeMounts(obj: ThanosRulerSpecVolumeMounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'mountPropagation': obj.mountPropagation,
    'name': obj.name,
    'readOnly': obj.readOnly,
    'subPath': obj.subPath,
    'subPathExpr': obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Volume represents a named volume in a pod that may be accessed by any container in the pod.
 *
 * @schema ThanosRulerSpecVolumes
 */
export interface ThanosRulerSpecVolumes {
  /**
   * awsElasticBlockStore represents an AWS Disk resource that is attached to a
   * kubelet's host machine and then exposed to the pod.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema ThanosRulerSpecVolumes#awsElasticBlockStore
   */
  readonly awsElasticBlockStore?: ThanosRulerSpecVolumesAwsElasticBlockStore;

  /**
   * azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
   *
   * @schema ThanosRulerSpecVolumes#azureDisk
   */
  readonly azureDisk?: ThanosRulerSpecVolumesAzureDisk;

  /**
   * azureFile represents an Azure File Service mount on the host and bind mount to the pod.
   *
   * @schema ThanosRulerSpecVolumes#azureFile
   */
  readonly azureFile?: ThanosRulerSpecVolumesAzureFile;

  /**
   * cephFS represents a Ceph FS mount on the host that shares a pod's lifetime
   *
   * @schema ThanosRulerSpecVolumes#cephfs
   */
  readonly cephfs?: ThanosRulerSpecVolumesCephfs;

  /**
   * cinder represents a cinder volume attached and mounted on kubelets host machine.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema ThanosRulerSpecVolumes#cinder
   */
  readonly cinder?: ThanosRulerSpecVolumesCinder;

  /**
   * configMap represents a configMap that should populate this volume
   *
   * @schema ThanosRulerSpecVolumes#configMap
   */
  readonly configMap?: ThanosRulerSpecVolumesConfigMap;

  /**
   * csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers (Beta feature).
   *
   * @schema ThanosRulerSpecVolumes#csi
   */
  readonly csi?: ThanosRulerSpecVolumesCsi;

  /**
   * downwardAPI represents downward API about the pod that should populate this volume
   *
   * @schema ThanosRulerSpecVolumes#downwardAPI
   */
  readonly downwardApi?: ThanosRulerSpecVolumesDownwardApi;

  /**
   * emptyDir represents a temporary directory that shares a pod's lifetime.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema ThanosRulerSpecVolumes#emptyDir
   */
  readonly emptyDir?: ThanosRulerSpecVolumesEmptyDir;

  /**
   * ephemeral represents a volume that is handled by a cluster storage driver.
   * The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts,
   * and deleted when the pod is removed.
   *
   *
   * Use this if:
   * a) the volume is only needed while the pod runs,
   * b) features of normal volumes like restoring from snapshot or capacity
   * tracking are needed,
   * c) the storage driver is specified through a storage class, and
   * d) the storage driver supports dynamic volume provisioning through
   * a PersistentVolumeClaim (see EphemeralVolumeSource for more
   * information on the connection between this volume type
   * and PersistentVolumeClaim).
   *
   *
   * Use PersistentVolumeClaim or one of the vendor-specific
   * APIs for volumes that persist for longer than the lifecycle
   * of an individual pod.
   *
   *
   * Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to
   * be used that way - see the documentation of the driver for
   * more information.
   *
   *
   * A pod can use both types of ephemeral volumes and
   * persistent volumes at the same time.
   *
   * @schema ThanosRulerSpecVolumes#ephemeral
   */
  readonly ephemeral?: ThanosRulerSpecVolumesEphemeral;

  /**
   * fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
   *
   * @schema ThanosRulerSpecVolumes#fc
   */
  readonly fc?: ThanosRulerSpecVolumesFc;

  /**
   * flexVolume represents a generic volume resource that is
   * provisioned/attached using an exec based plugin.
   *
   * @schema ThanosRulerSpecVolumes#flexVolume
   */
  readonly flexVolume?: ThanosRulerSpecVolumesFlexVolume;

  /**
   * flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running
   *
   * @schema ThanosRulerSpecVolumes#flocker
   */
  readonly flocker?: ThanosRulerSpecVolumesFlocker;

  /**
   * gcePersistentDisk represents a GCE Disk resource that is attached to a
   * kubelet's host machine and then exposed to the pod.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema ThanosRulerSpecVolumes#gcePersistentDisk
   */
  readonly gcePersistentDisk?: ThanosRulerSpecVolumesGcePersistentDisk;

  /**
   * gitRepo represents a git repository at a particular revision.
   * DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an
   * EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir
   * into the Pod's container.
   *
   * @schema ThanosRulerSpecVolumes#gitRepo
   */
  readonly gitRepo?: ThanosRulerSpecVolumesGitRepo;

  /**
   * glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md
   *
   * @schema ThanosRulerSpecVolumes#glusterfs
   */
  readonly glusterfs?: ThanosRulerSpecVolumesGlusterfs;

  /**
   * hostPath represents a pre-existing file or directory on the host
   * machine that is directly exposed to the container. This is generally
   * used for system agents or other privileged things that are allowed
   * to see the host machine. Most containers will NOT need this.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   * ---
   * TODO(jonesdl) We need to restrict who can use host directory mounts and who can/can not
   * mount host directories as read/write.
   *
   * @schema ThanosRulerSpecVolumes#hostPath
   */
  readonly hostPath?: ThanosRulerSpecVolumesHostPath;

  /**
   * iscsi represents an ISCSI Disk resource that is attached to a
   * kubelet's host machine and then exposed to the pod.
   * More info: https://examples.k8s.io/volumes/iscsi/README.md
   *
   * @schema ThanosRulerSpecVolumes#iscsi
   */
  readonly iscsi?: ThanosRulerSpecVolumesIscsi;

  /**
   * name of the volume.
   * Must be a DNS_LABEL and unique within the pod.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ThanosRulerSpecVolumes#name
   */
  readonly name: string;

  /**
   * nfs represents an NFS mount on the host that shares a pod's lifetime
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema ThanosRulerSpecVolumes#nfs
   */
  readonly nfs?: ThanosRulerSpecVolumesNfs;

  /**
   * persistentVolumeClaimVolumeSource represents a reference to a
   * PersistentVolumeClaim in the same namespace.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema ThanosRulerSpecVolumes#persistentVolumeClaim
   */
  readonly persistentVolumeClaim?: ThanosRulerSpecVolumesPersistentVolumeClaim;

  /**
   * photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
   *
   * @schema ThanosRulerSpecVolumes#photonPersistentDisk
   */
  readonly photonPersistentDisk?: ThanosRulerSpecVolumesPhotonPersistentDisk;

  /**
   * portworxVolume represents a portworx volume attached and mounted on kubelets host machine
   *
   * @schema ThanosRulerSpecVolumes#portworxVolume
   */
  readonly portworxVolume?: ThanosRulerSpecVolumesPortworxVolume;

  /**
   * projected items for all in one resources secrets, configmaps, and downward API
   *
   * @schema ThanosRulerSpecVolumes#projected
   */
  readonly projected?: ThanosRulerSpecVolumesProjected;

  /**
   * quobyte represents a Quobyte mount on the host that shares a pod's lifetime
   *
   * @schema ThanosRulerSpecVolumes#quobyte
   */
  readonly quobyte?: ThanosRulerSpecVolumesQuobyte;

  /**
   * rbd represents a Rados Block Device mount on the host that shares a pod's lifetime.
   * More info: https://examples.k8s.io/volumes/rbd/README.md
   *
   * @schema ThanosRulerSpecVolumes#rbd
   */
  readonly rbd?: ThanosRulerSpecVolumesRbd;

  /**
   * scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
   *
   * @schema ThanosRulerSpecVolumes#scaleIO
   */
  readonly scaleIo?: ThanosRulerSpecVolumesScaleIo;

  /**
   * secret represents a secret that should populate this volume.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   *
   * @schema ThanosRulerSpecVolumes#secret
   */
  readonly secret?: ThanosRulerSpecVolumesSecret;

  /**
   * storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
   *
   * @schema ThanosRulerSpecVolumes#storageos
   */
  readonly storageos?: ThanosRulerSpecVolumesStorageos;

  /**
   * vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
   *
   * @schema ThanosRulerSpecVolumes#vsphereVolume
   */
  readonly vsphereVolume?: ThanosRulerSpecVolumesVsphereVolume;

}

/**
 * Converts an object of type 'ThanosRulerSpecVolumes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumes(obj: ThanosRulerSpecVolumes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'awsElasticBlockStore': toJson_ThanosRulerSpecVolumesAwsElasticBlockStore(obj.awsElasticBlockStore),
    'azureDisk': toJson_ThanosRulerSpecVolumesAzureDisk(obj.azureDisk),
    'azureFile': toJson_ThanosRulerSpecVolumesAzureFile(obj.azureFile),
    'cephfs': toJson_ThanosRulerSpecVolumesCephfs(obj.cephfs),
    'cinder': toJson_ThanosRulerSpecVolumesCinder(obj.cinder),
    'configMap': toJson_ThanosRulerSpecVolumesConfigMap(obj.configMap),
    'csi': toJson_ThanosRulerSpecVolumesCsi(obj.csi),
    'downwardAPI': toJson_ThanosRulerSpecVolumesDownwardApi(obj.downwardApi),
    'emptyDir': toJson_ThanosRulerSpecVolumesEmptyDir(obj.emptyDir),
    'ephemeral': toJson_ThanosRulerSpecVolumesEphemeral(obj.ephemeral),
    'fc': toJson_ThanosRulerSpecVolumesFc(obj.fc),
    'flexVolume': toJson_ThanosRulerSpecVolumesFlexVolume(obj.flexVolume),
    'flocker': toJson_ThanosRulerSpecVolumesFlocker(obj.flocker),
    'gcePersistentDisk': toJson_ThanosRulerSpecVolumesGcePersistentDisk(obj.gcePersistentDisk),
    'gitRepo': toJson_ThanosRulerSpecVolumesGitRepo(obj.gitRepo),
    'glusterfs': toJson_ThanosRulerSpecVolumesGlusterfs(obj.glusterfs),
    'hostPath': toJson_ThanosRulerSpecVolumesHostPath(obj.hostPath),
    'iscsi': toJson_ThanosRulerSpecVolumesIscsi(obj.iscsi),
    'name': obj.name,
    'nfs': toJson_ThanosRulerSpecVolumesNfs(obj.nfs),
    'persistentVolumeClaim': toJson_ThanosRulerSpecVolumesPersistentVolumeClaim(obj.persistentVolumeClaim),
    'photonPersistentDisk': toJson_ThanosRulerSpecVolumesPhotonPersistentDisk(obj.photonPersistentDisk),
    'portworxVolume': toJson_ThanosRulerSpecVolumesPortworxVolume(obj.portworxVolume),
    'projected': toJson_ThanosRulerSpecVolumesProjected(obj.projected),
    'quobyte': toJson_ThanosRulerSpecVolumesQuobyte(obj.quobyte),
    'rbd': toJson_ThanosRulerSpecVolumesRbd(obj.rbd),
    'scaleIO': toJson_ThanosRulerSpecVolumesScaleIo(obj.scaleIo),
    'secret': toJson_ThanosRulerSpecVolumesSecret(obj.secret),
    'storageos': toJson_ThanosRulerSpecVolumesStorageos(obj.storageos),
    'vsphereVolume': toJson_ThanosRulerSpecVolumesVsphereVolume(obj.vsphereVolume),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Defines the configuration of the ThanosRuler web server.
 *
 * @schema ThanosRulerSpecWeb
 */
export interface ThanosRulerSpecWeb {
  /**
   * Defines HTTP parameters for web server.
   *
   * @schema ThanosRulerSpecWeb#httpConfig
   */
  readonly httpConfig?: ThanosRulerSpecWebHttpConfig;

  /**
   * Defines the TLS parameters for HTTPS.
   *
   * @schema ThanosRulerSpecWeb#tlsConfig
   */
  readonly tlsConfig?: ThanosRulerSpecWebTlsConfig;

}

/**
 * Converts an object of type 'ThanosRulerSpecWeb' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecWeb(obj: ThanosRulerSpecWeb | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpConfig': toJson_ThanosRulerSpecWebHttpConfig(obj.httpConfig),
    'tlsConfig': toJson_ThanosRulerSpecWebTlsConfig(obj.tlsConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Describes node affinity scheduling rules for the pod.
 *
 * @schema ThanosRulerSpecAffinityNodeAffinity
 */
export interface ThanosRulerSpecAffinityNodeAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node matches the corresponding matchExpressions; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema ThanosRulerSpecAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: ThanosRulerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to an update), the system
   * may or may not try to eventually evict the pod from its node.
   *
   * @schema ThanosRulerSpecAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: ThanosRulerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;

}

/**
 * Converts an object of type 'ThanosRulerSpecAffinityNodeAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecAffinityNodeAffinity(obj: ThanosRulerSpecAffinityNodeAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_ThanosRulerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': toJson_ThanosRulerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj.requiredDuringSchedulingIgnoredDuringExecution),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
 *
 * @schema ThanosRulerSpecAffinityPodAffinity
 */
export interface ThanosRulerSpecAffinityPodAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema ThanosRulerSpecAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to a pod label update), the
   * system may or may not try to eventually evict the pod from its node.
   * When there are multiple elements, the lists of nodes corresponding to each
   * podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema ThanosRulerSpecAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'ThanosRulerSpecAffinityPodAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecAffinityPodAffinity(obj: ThanosRulerSpecAffinityPodAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
 *
 * @schema ThanosRulerSpecAffinityPodAntiAffinity
 */
export interface ThanosRulerSpecAffinityPodAntiAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the anti-affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling anti-affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema ThanosRulerSpecAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the anti-affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the anti-affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to a pod label update), the
   * system may or may not try to eventually evict the pod from its node.
   * When there are multiple elements, the lists of nodes corresponding to each
   * podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema ThanosRulerSpecAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'ThanosRulerSpecAffinityPodAntiAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecAffinityPodAntiAffinity(obj: ThanosRulerSpecAffinityPodAntiAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema ThanosRulerSpecContainersEnv
 */
export interface ThanosRulerSpecContainersEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema ThanosRulerSpecContainersEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded
   * using the previously defined environment variables in the container and
   * any service environment variables. If a variable cannot be resolved,
   * the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
   * "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
   * Escaped references will never be expanded, regardless of whether the variable
   * exists or not.
   * Defaults to "".
   *
   * @default .
   * @schema ThanosRulerSpecContainersEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema ThanosRulerSpecContainersEnv#valueFrom
   */
  readonly valueFrom?: ThanosRulerSpecContainersEnvValueFrom;

}

/**
 * Converts an object of type 'ThanosRulerSpecContainersEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersEnv(obj: ThanosRulerSpecContainersEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
    'valueFrom': toJson_ThanosRulerSpecContainersEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema ThanosRulerSpecContainersEnvFrom
 */
export interface ThanosRulerSpecContainersEnvFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema ThanosRulerSpecContainersEnvFrom#configMapRef
   */
  readonly configMapRef?: ThanosRulerSpecContainersEnvFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema ThanosRulerSpecContainersEnvFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema ThanosRulerSpecContainersEnvFrom#secretRef
   */
  readonly secretRef?: ThanosRulerSpecContainersEnvFromSecretRef;

}

/**
 * Converts an object of type 'ThanosRulerSpecContainersEnvFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersEnvFrom(obj: ThanosRulerSpecContainersEnvFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapRef': toJson_ThanosRulerSpecContainersEnvFromConfigMapRef(obj.configMapRef),
    'prefix': obj.prefix,
    'secretRef': toJson_ThanosRulerSpecContainersEnvFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Actions that the management system should take in response to container lifecycle events.
 * Cannot be updated.
 *
 * @schema ThanosRulerSpecContainersLifecycle
 */
export interface ThanosRulerSpecContainersLifecycle {
  /**
   * PostStart is called immediately after a container is created. If the handler fails,
   * the container is terminated and restarted according to its restart policy.
   * Other management of the container blocks until the hook completes.
   * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema ThanosRulerSpecContainersLifecycle#postStart
   */
  readonly postStart?: ThanosRulerSpecContainersLifecyclePostStart;

  /**
   * PreStop is called immediately before a container is terminated due to an
   * API request or management event such as liveness/startup probe failure,
   * preemption, resource contention, etc. The handler is not called if the
   * container crashes or exits. The Pod's termination grace period countdown begins before the
   * PreStop hook is executed. Regardless of the outcome of the handler, the
   * container will eventually terminate within the Pod's termination grace
   * period (unless delayed by finalizers). Other management of the container blocks until the hook completes
   * or until the termination grace period is reached.
   * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema ThanosRulerSpecContainersLifecycle#preStop
   */
  readonly preStop?: ThanosRulerSpecContainersLifecyclePreStop;

}

/**
 * Converts an object of type 'ThanosRulerSpecContainersLifecycle' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersLifecycle(obj: ThanosRulerSpecContainersLifecycle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'postStart': toJson_ThanosRulerSpecContainersLifecyclePostStart(obj.postStart),
    'preStop': toJson_ThanosRulerSpecContainersLifecyclePreStop(obj.preStop),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Periodic probe of container liveness.
 * Container will be restarted if the probe fails.
 * Cannot be updated.
 * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema ThanosRulerSpecContainersLivenessProbe
 */
export interface ThanosRulerSpecContainersLivenessProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema ThanosRulerSpecContainersLivenessProbe#exec
   */
  readonly exec?: ThanosRulerSpecContainersLivenessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   * Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema ThanosRulerSpecContainersLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port.
   *
   * @schema ThanosRulerSpecContainersLivenessProbe#grpc
   */
  readonly grpc?: ThanosRulerSpecContainersLivenessProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema ThanosRulerSpecContainersLivenessProbe#httpGet
   */
  readonly httpGet?: ThanosRulerSpecContainersLivenessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema ThanosRulerSpecContainersLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe.
   * Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema ThanosRulerSpecContainersLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema ThanosRulerSpecContainersLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema ThanosRulerSpecContainersLivenessProbe#tcpSocket
   */
  readonly tcpSocket?: ThanosRulerSpecContainersLivenessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
   * value overrides the value provided by the pod spec.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
   * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema ThanosRulerSpecContainersLivenessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out.
   * Defaults to 1 second. Minimum value is 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1.
   * @schema ThanosRulerSpecContainersLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'ThanosRulerSpecContainersLivenessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersLivenessProbe(obj: ThanosRulerSpecContainersLivenessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_ThanosRulerSpecContainersLivenessProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_ThanosRulerSpecContainersLivenessProbeGrpc(obj.grpc),
    'httpGet': toJson_ThanosRulerSpecContainersLivenessProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_ThanosRulerSpecContainersLivenessProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ContainerPort represents a network port in a single container.
 *
 * @schema ThanosRulerSpecContainersPorts
 */
export interface ThanosRulerSpecContainersPorts {
  /**
   * Number of port to expose on the pod's IP address.
   * This must be a valid port number, 0 < x < 65536.
   *
   * @schema ThanosRulerSpecContainersPorts#containerPort
   */
  readonly containerPort: number;

  /**
   * What host IP to bind the external port to.
   *
   * @schema ThanosRulerSpecContainersPorts#hostIP
   */
  readonly hostIp?: string;

  /**
   * Number of port to expose on the host.
   * If specified, this must be a valid port number, 0 < x < 65536.
   * If HostNetwork is specified, this must match ContainerPort.
   * Most containers do not need this.
   *
   * @schema ThanosRulerSpecContainersPorts#hostPort
   */
  readonly hostPort?: number;

  /**
   * If specified, this must be an IANA_SVC_NAME and unique within the pod. Each
   * named port in a pod must have a unique name. Name for the port that can be
   * referred to by services.
   *
   * @schema ThanosRulerSpecContainersPorts#name
   */
  readonly name?: string;

  /**
   * Protocol for port. Must be UDP, TCP, or SCTP.
   * Defaults to "TCP".
   *
   * @default TCP".
   * @schema ThanosRulerSpecContainersPorts#protocol
   */
  readonly protocol?: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecContainersPorts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersPorts(obj: ThanosRulerSpecContainersPorts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerPort': obj.containerPort,
    'hostIP': obj.hostIp,
    'hostPort': obj.hostPort,
    'name': obj.name,
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Periodic probe of container service readiness.
 * Container will be removed from service endpoints if the probe fails.
 * Cannot be updated.
 * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema ThanosRulerSpecContainersReadinessProbe
 */
export interface ThanosRulerSpecContainersReadinessProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema ThanosRulerSpecContainersReadinessProbe#exec
   */
  readonly exec?: ThanosRulerSpecContainersReadinessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   * Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema ThanosRulerSpecContainersReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port.
   *
   * @schema ThanosRulerSpecContainersReadinessProbe#grpc
   */
  readonly grpc?: ThanosRulerSpecContainersReadinessProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema ThanosRulerSpecContainersReadinessProbe#httpGet
   */
  readonly httpGet?: ThanosRulerSpecContainersReadinessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema ThanosRulerSpecContainersReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe.
   * Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema ThanosRulerSpecContainersReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema ThanosRulerSpecContainersReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema ThanosRulerSpecContainersReadinessProbe#tcpSocket
   */
  readonly tcpSocket?: ThanosRulerSpecContainersReadinessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
   * value overrides the value provided by the pod spec.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
   * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema ThanosRulerSpecContainersReadinessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out.
   * Defaults to 1 second. Minimum value is 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1.
   * @schema ThanosRulerSpecContainersReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'ThanosRulerSpecContainersReadinessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersReadinessProbe(obj: ThanosRulerSpecContainersReadinessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_ThanosRulerSpecContainersReadinessProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_ThanosRulerSpecContainersReadinessProbeGrpc(obj.grpc),
    'httpGet': toJson_ThanosRulerSpecContainersReadinessProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_ThanosRulerSpecContainersReadinessProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ContainerResizePolicy represents resource resize policy for the container.
 *
 * @schema ThanosRulerSpecContainersResizePolicy
 */
export interface ThanosRulerSpecContainersResizePolicy {
  /**
   * Name of the resource to which this resource resize policy applies.
   * Supported values: cpu, memory.
   *
   * @schema ThanosRulerSpecContainersResizePolicy#resourceName
   */
  readonly resourceName: string;

  /**
   * Restart policy to apply when specified resource is resized.
   * If not specified, it defaults to NotRequired.
   *
   * @schema ThanosRulerSpecContainersResizePolicy#restartPolicy
   */
  readonly restartPolicy: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecContainersResizePolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersResizePolicy(obj: ThanosRulerSpecContainersResizePolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resourceName': obj.resourceName,
    'restartPolicy': obj.restartPolicy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Compute Resources required by this container.
 * Cannot be updated.
 * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
 *
 * @schema ThanosRulerSpecContainersResources
 */
export interface ThanosRulerSpecContainersResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema ThanosRulerSpecContainersResources#claims
   */
  readonly claims?: ThanosRulerSpecContainersResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ThanosRulerSpecContainersResources#limits
   */
  readonly limits?: { [key: string]: ThanosRulerSpecContainersResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ThanosRulerSpecContainersResources#requests
   */
  readonly requests?: { [key: string]: ThanosRulerSpecContainersResourcesRequests };

}

/**
 * Converts an object of type 'ThanosRulerSpecContainersResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersResources(obj: ThanosRulerSpecContainersResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claims': obj.claims?.map(y => toJson_ThanosRulerSpecContainersResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecurityContext defines the security options the container should be run with.
 * If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
 * More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
 *
 * @schema ThanosRulerSpecContainersSecurityContext
 */
export interface ThanosRulerSpecContainersSecurityContext {
  /**
   * AllowPrivilegeEscalation controls whether a process can gain more
   * privileges than its parent process. This bool directly controls if
   * the no_new_privs flag will be set on the container process.
   * AllowPrivilegeEscalation is true always when the container is:
   * 1) run as Privileged
   * 2) has CAP_SYS_ADMIN
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ThanosRulerSpecContainersSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * The capabilities to add/drop when running containers.
   * Defaults to the default set of capabilities granted by the container runtime.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default the default set of capabilities granted by the container runtime.
   * @schema ThanosRulerSpecContainersSecurityContext#capabilities
   */
  readonly capabilities?: ThanosRulerSpecContainersSecurityContextCapabilities;

  /**
   * Run container in privileged mode.
   * Processes in privileged containers are essentially equivalent to root on the host.
   * Defaults to false.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false.
   * @schema ThanosRulerSpecContainersSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * procMount denotes the type of proc mount to use for the containers.
   * The default is DefaultProcMount which uses the container runtime defaults for
   * readonly paths and masked paths.
   * This requires the ProcMountType feature flag to be enabled.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ThanosRulerSpecContainersSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * Whether this container has a read-only root filesystem.
   * Default is false.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false.
   * @schema ThanosRulerSpecContainersSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * The GID to run the entrypoint of the container process.
   * Uses runtime default if unset.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ThanosRulerSpecContainersSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user.
   * If true, the Kubelet will validate the image at runtime to ensure that it
   * does not run as UID 0 (root) and fail to start the container if it does.
   * If unset or false, no such validation will be performed.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema ThanosRulerSpecContainersSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process.
   * Defaults to user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified.
   * @schema ThanosRulerSpecContainersSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to the container.
   * If unspecified, the container runtime will allocate a random SELinux context for each
   * container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ThanosRulerSpecContainersSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: ThanosRulerSpecContainersSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by this container. If seccomp options are
   * provided at both the pod & container level, the container options
   * override the pod options.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ThanosRulerSpecContainersSecurityContext#seccompProfile
   */
  readonly seccompProfile?: ThanosRulerSpecContainersSecurityContextSeccompProfile;

  /**
   * The Windows specific settings applied to all containers.
   * If unspecified, the options from the PodSecurityContext will be used.
   * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema ThanosRulerSpecContainersSecurityContext#windowsOptions
   */
  readonly windowsOptions?: ThanosRulerSpecContainersSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'ThanosRulerSpecContainersSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersSecurityContext(obj: ThanosRulerSpecContainersSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowPrivilegeEscalation': obj.allowPrivilegeEscalation,
    'capabilities': toJson_ThanosRulerSpecContainersSecurityContextCapabilities(obj.capabilities),
    'privileged': obj.privileged,
    'procMount': obj.procMount,
    'readOnlyRootFilesystem': obj.readOnlyRootFilesystem,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_ThanosRulerSpecContainersSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_ThanosRulerSpecContainersSecurityContextSeccompProfile(obj.seccompProfile),
    'windowsOptions': toJson_ThanosRulerSpecContainersSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * StartupProbe indicates that the Pod has successfully initialized.
 * If specified, no other probes are executed until this completes successfully.
 * If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
 * This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
 * when it might take a long time to load data or warm a cache, than during steady-state operation.
 * This cannot be updated.
 * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema ThanosRulerSpecContainersStartupProbe
 */
export interface ThanosRulerSpecContainersStartupProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema ThanosRulerSpecContainersStartupProbe#exec
   */
  readonly exec?: ThanosRulerSpecContainersStartupProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   * Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema ThanosRulerSpecContainersStartupProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port.
   *
   * @schema ThanosRulerSpecContainersStartupProbe#grpc
   */
  readonly grpc?: ThanosRulerSpecContainersStartupProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema ThanosRulerSpecContainersStartupProbe#httpGet
   */
  readonly httpGet?: ThanosRulerSpecContainersStartupProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema ThanosRulerSpecContainersStartupProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe.
   * Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema ThanosRulerSpecContainersStartupProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema ThanosRulerSpecContainersStartupProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema ThanosRulerSpecContainersStartupProbe#tcpSocket
   */
  readonly tcpSocket?: ThanosRulerSpecContainersStartupProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
   * value overrides the value provided by the pod spec.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
   * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema ThanosRulerSpecContainersStartupProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out.
   * Defaults to 1 second. Minimum value is 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1.
   * @schema ThanosRulerSpecContainersStartupProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'ThanosRulerSpecContainersStartupProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersStartupProbe(obj: ThanosRulerSpecContainersStartupProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_ThanosRulerSpecContainersStartupProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_ThanosRulerSpecContainersStartupProbeGrpc(obj.grpc),
    'httpGet': toJson_ThanosRulerSpecContainersStartupProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_ThanosRulerSpecContainersStartupProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * volumeDevice describes a mapping of a raw block device within a container.
 *
 * @schema ThanosRulerSpecContainersVolumeDevices
 */
export interface ThanosRulerSpecContainersVolumeDevices {
  /**
   * devicePath is the path inside of the container that the device will be mapped to.
   *
   * @schema ThanosRulerSpecContainersVolumeDevices#devicePath
   */
  readonly devicePath: string;

  /**
   * name must match the name of a persistentVolumeClaim in the pod
   *
   * @schema ThanosRulerSpecContainersVolumeDevices#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecContainersVolumeDevices' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersVolumeDevices(obj: ThanosRulerSpecContainersVolumeDevices | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'devicePath': obj.devicePath,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema ThanosRulerSpecContainersVolumeMounts
 */
export interface ThanosRulerSpecContainersVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must
   * not contain ':'.
   *
   * @schema ThanosRulerSpecContainersVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host
   * to container and the other way around.
   * When not set, MountPropagationNone is used.
   * This field is beta in 1.10.
   *
   * @schema ThanosRulerSpecContainersVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema ThanosRulerSpecContainersVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified).
   * Defaults to false.
   *
   * @default false.
   * @schema ThanosRulerSpecContainersVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Path within the volume from which the container's volume should be mounted.
   * Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema ThanosRulerSpecContainersVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted.
   * Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
   * Defaults to "" (volume's root).
   * SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root).
   * @schema ThanosRulerSpecContainersVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecContainersVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersVolumeMounts(obj: ThanosRulerSpecContainersVolumeMounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'mountPropagation': obj.mountPropagation,
    'name': obj.name,
    'readOnly': obj.readOnly,
    'subPath': obj.subPath,
    'subPathExpr': obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Group of the referent. When not specified, it defaults to `monitoring.coreos.com`
 *
 * @schema ThanosRulerSpecExcludedFromEnforcementGroup
 */
export enum ThanosRulerSpecExcludedFromEnforcementGroup {
  /** monitoring.coreos.com */
  MONITORING_PERIOD_COREOS_PERIOD_COM = "monitoring.coreos.com",
}

/**
 * Resource of the referent.
 *
 * @schema ThanosRulerSpecExcludedFromEnforcementResource
 */
export enum ThanosRulerSpecExcludedFromEnforcementResource {
  /** prometheusrules */
  PROMETHEUSRULES = "prometheusrules",
  /** servicemonitors */
  SERVICEMONITORS = "servicemonitors",
  /** podmonitors */
  PODMONITORS = "podmonitors",
  /** probes */
  PROBES = "probes",
  /** scrapeconfigs */
  SCRAPECONFIGS = "scrapeconfigs",
}

/**
 * Certificate authority used when verifying server certificates.
 *
 * @schema ThanosRulerSpecGrpcServerTlsConfigCa
 */
export interface ThanosRulerSpecGrpcServerTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema ThanosRulerSpecGrpcServerTlsConfigCa#configMap
   */
  readonly configMap?: ThanosRulerSpecGrpcServerTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema ThanosRulerSpecGrpcServerTlsConfigCa#secret
   */
  readonly secret?: ThanosRulerSpecGrpcServerTlsConfigCaSecret;

}

/**
 * Converts an object of type 'ThanosRulerSpecGrpcServerTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecGrpcServerTlsConfigCa(obj: ThanosRulerSpecGrpcServerTlsConfigCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_ThanosRulerSpecGrpcServerTlsConfigCaConfigMap(obj.configMap),
    'secret': toJson_ThanosRulerSpecGrpcServerTlsConfigCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Client certificate to present when doing client-authentication.
 *
 * @schema ThanosRulerSpecGrpcServerTlsConfigCert
 */
export interface ThanosRulerSpecGrpcServerTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema ThanosRulerSpecGrpcServerTlsConfigCert#configMap
   */
  readonly configMap?: ThanosRulerSpecGrpcServerTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema ThanosRulerSpecGrpcServerTlsConfigCert#secret
   */
  readonly secret?: ThanosRulerSpecGrpcServerTlsConfigCertSecret;

}

/**
 * Converts an object of type 'ThanosRulerSpecGrpcServerTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecGrpcServerTlsConfigCert(obj: ThanosRulerSpecGrpcServerTlsConfigCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_ThanosRulerSpecGrpcServerTlsConfigCertConfigMap(obj.configMap),
    'secret': toJson_ThanosRulerSpecGrpcServerTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema ThanosRulerSpecGrpcServerTlsConfigKeySecret
 */
export interface ThanosRulerSpecGrpcServerTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ThanosRulerSpecGrpcServerTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ThanosRulerSpecGrpcServerTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ThanosRulerSpecGrpcServerTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ThanosRulerSpecGrpcServerTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecGrpcServerTlsConfigKeySecret(obj: ThanosRulerSpecGrpcServerTlsConfigKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema ThanosRulerSpecInitContainersEnv
 */
export interface ThanosRulerSpecInitContainersEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema ThanosRulerSpecInitContainersEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded
   * using the previously defined environment variables in the container and
   * any service environment variables. If a variable cannot be resolved,
   * the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
   * "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
   * Escaped references will never be expanded, regardless of whether the variable
   * exists or not.
   * Defaults to "".
   *
   * @default .
   * @schema ThanosRulerSpecInitContainersEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema ThanosRulerSpecInitContainersEnv#valueFrom
   */
  readonly valueFrom?: ThanosRulerSpecInitContainersEnvValueFrom;

}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersEnv(obj: ThanosRulerSpecInitContainersEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
    'valueFrom': toJson_ThanosRulerSpecInitContainersEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema ThanosRulerSpecInitContainersEnvFrom
 */
export interface ThanosRulerSpecInitContainersEnvFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema ThanosRulerSpecInitContainersEnvFrom#configMapRef
   */
  readonly configMapRef?: ThanosRulerSpecInitContainersEnvFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema ThanosRulerSpecInitContainersEnvFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema ThanosRulerSpecInitContainersEnvFrom#secretRef
   */
  readonly secretRef?: ThanosRulerSpecInitContainersEnvFromSecretRef;

}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersEnvFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersEnvFrom(obj: ThanosRulerSpecInitContainersEnvFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapRef': toJson_ThanosRulerSpecInitContainersEnvFromConfigMapRef(obj.configMapRef),
    'prefix': obj.prefix,
    'secretRef': toJson_ThanosRulerSpecInitContainersEnvFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Actions that the management system should take in response to container lifecycle events.
 * Cannot be updated.
 *
 * @schema ThanosRulerSpecInitContainersLifecycle
 */
export interface ThanosRulerSpecInitContainersLifecycle {
  /**
   * PostStart is called immediately after a container is created. If the handler fails,
   * the container is terminated and restarted according to its restart policy.
   * Other management of the container blocks until the hook completes.
   * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema ThanosRulerSpecInitContainersLifecycle#postStart
   */
  readonly postStart?: ThanosRulerSpecInitContainersLifecyclePostStart;

  /**
   * PreStop is called immediately before a container is terminated due to an
   * API request or management event such as liveness/startup probe failure,
   * preemption, resource contention, etc. The handler is not called if the
   * container crashes or exits. The Pod's termination grace period countdown begins before the
   * PreStop hook is executed. Regardless of the outcome of the handler, the
   * container will eventually terminate within the Pod's termination grace
   * period (unless delayed by finalizers). Other management of the container blocks until the hook completes
   * or until the termination grace period is reached.
   * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema ThanosRulerSpecInitContainersLifecycle#preStop
   */
  readonly preStop?: ThanosRulerSpecInitContainersLifecyclePreStop;

}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersLifecycle' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersLifecycle(obj: ThanosRulerSpecInitContainersLifecycle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'postStart': toJson_ThanosRulerSpecInitContainersLifecyclePostStart(obj.postStart),
    'preStop': toJson_ThanosRulerSpecInitContainersLifecyclePreStop(obj.preStop),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Periodic probe of container liveness.
 * Container will be restarted if the probe fails.
 * Cannot be updated.
 * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema ThanosRulerSpecInitContainersLivenessProbe
 */
export interface ThanosRulerSpecInitContainersLivenessProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema ThanosRulerSpecInitContainersLivenessProbe#exec
   */
  readonly exec?: ThanosRulerSpecInitContainersLivenessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   * Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema ThanosRulerSpecInitContainersLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port.
   *
   * @schema ThanosRulerSpecInitContainersLivenessProbe#grpc
   */
  readonly grpc?: ThanosRulerSpecInitContainersLivenessProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema ThanosRulerSpecInitContainersLivenessProbe#httpGet
   */
  readonly httpGet?: ThanosRulerSpecInitContainersLivenessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema ThanosRulerSpecInitContainersLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe.
   * Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema ThanosRulerSpecInitContainersLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema ThanosRulerSpecInitContainersLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema ThanosRulerSpecInitContainersLivenessProbe#tcpSocket
   */
  readonly tcpSocket?: ThanosRulerSpecInitContainersLivenessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
   * value overrides the value provided by the pod spec.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
   * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema ThanosRulerSpecInitContainersLivenessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out.
   * Defaults to 1 second. Minimum value is 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1.
   * @schema ThanosRulerSpecInitContainersLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersLivenessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersLivenessProbe(obj: ThanosRulerSpecInitContainersLivenessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_ThanosRulerSpecInitContainersLivenessProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_ThanosRulerSpecInitContainersLivenessProbeGrpc(obj.grpc),
    'httpGet': toJson_ThanosRulerSpecInitContainersLivenessProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_ThanosRulerSpecInitContainersLivenessProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ContainerPort represents a network port in a single container.
 *
 * @schema ThanosRulerSpecInitContainersPorts
 */
export interface ThanosRulerSpecInitContainersPorts {
  /**
   * Number of port to expose on the pod's IP address.
   * This must be a valid port number, 0 < x < 65536.
   *
   * @schema ThanosRulerSpecInitContainersPorts#containerPort
   */
  readonly containerPort: number;

  /**
   * What host IP to bind the external port to.
   *
   * @schema ThanosRulerSpecInitContainersPorts#hostIP
   */
  readonly hostIp?: string;

  /**
   * Number of port to expose on the host.
   * If specified, this must be a valid port number, 0 < x < 65536.
   * If HostNetwork is specified, this must match ContainerPort.
   * Most containers do not need this.
   *
   * @schema ThanosRulerSpecInitContainersPorts#hostPort
   */
  readonly hostPort?: number;

  /**
   * If specified, this must be an IANA_SVC_NAME and unique within the pod. Each
   * named port in a pod must have a unique name. Name for the port that can be
   * referred to by services.
   *
   * @schema ThanosRulerSpecInitContainersPorts#name
   */
  readonly name?: string;

  /**
   * Protocol for port. Must be UDP, TCP, or SCTP.
   * Defaults to "TCP".
   *
   * @default TCP".
   * @schema ThanosRulerSpecInitContainersPorts#protocol
   */
  readonly protocol?: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersPorts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersPorts(obj: ThanosRulerSpecInitContainersPorts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerPort': obj.containerPort,
    'hostIP': obj.hostIp,
    'hostPort': obj.hostPort,
    'name': obj.name,
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Periodic probe of container service readiness.
 * Container will be removed from service endpoints if the probe fails.
 * Cannot be updated.
 * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema ThanosRulerSpecInitContainersReadinessProbe
 */
export interface ThanosRulerSpecInitContainersReadinessProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema ThanosRulerSpecInitContainersReadinessProbe#exec
   */
  readonly exec?: ThanosRulerSpecInitContainersReadinessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   * Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema ThanosRulerSpecInitContainersReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port.
   *
   * @schema ThanosRulerSpecInitContainersReadinessProbe#grpc
   */
  readonly grpc?: ThanosRulerSpecInitContainersReadinessProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema ThanosRulerSpecInitContainersReadinessProbe#httpGet
   */
  readonly httpGet?: ThanosRulerSpecInitContainersReadinessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema ThanosRulerSpecInitContainersReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe.
   * Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema ThanosRulerSpecInitContainersReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema ThanosRulerSpecInitContainersReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema ThanosRulerSpecInitContainersReadinessProbe#tcpSocket
   */
  readonly tcpSocket?: ThanosRulerSpecInitContainersReadinessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
   * value overrides the value provided by the pod spec.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
   * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema ThanosRulerSpecInitContainersReadinessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out.
   * Defaults to 1 second. Minimum value is 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1.
   * @schema ThanosRulerSpecInitContainersReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersReadinessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersReadinessProbe(obj: ThanosRulerSpecInitContainersReadinessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_ThanosRulerSpecInitContainersReadinessProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_ThanosRulerSpecInitContainersReadinessProbeGrpc(obj.grpc),
    'httpGet': toJson_ThanosRulerSpecInitContainersReadinessProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_ThanosRulerSpecInitContainersReadinessProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ContainerResizePolicy represents resource resize policy for the container.
 *
 * @schema ThanosRulerSpecInitContainersResizePolicy
 */
export interface ThanosRulerSpecInitContainersResizePolicy {
  /**
   * Name of the resource to which this resource resize policy applies.
   * Supported values: cpu, memory.
   *
   * @schema ThanosRulerSpecInitContainersResizePolicy#resourceName
   */
  readonly resourceName: string;

  /**
   * Restart policy to apply when specified resource is resized.
   * If not specified, it defaults to NotRequired.
   *
   * @schema ThanosRulerSpecInitContainersResizePolicy#restartPolicy
   */
  readonly restartPolicy: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersResizePolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersResizePolicy(obj: ThanosRulerSpecInitContainersResizePolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resourceName': obj.resourceName,
    'restartPolicy': obj.restartPolicy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Compute Resources required by this container.
 * Cannot be updated.
 * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
 *
 * @schema ThanosRulerSpecInitContainersResources
 */
export interface ThanosRulerSpecInitContainersResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema ThanosRulerSpecInitContainersResources#claims
   */
  readonly claims?: ThanosRulerSpecInitContainersResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ThanosRulerSpecInitContainersResources#limits
   */
  readonly limits?: { [key: string]: ThanosRulerSpecInitContainersResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ThanosRulerSpecInitContainersResources#requests
   */
  readonly requests?: { [key: string]: ThanosRulerSpecInitContainersResourcesRequests };

}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersResources(obj: ThanosRulerSpecInitContainersResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claims': obj.claims?.map(y => toJson_ThanosRulerSpecInitContainersResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecurityContext defines the security options the container should be run with.
 * If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
 * More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
 *
 * @schema ThanosRulerSpecInitContainersSecurityContext
 */
export interface ThanosRulerSpecInitContainersSecurityContext {
  /**
   * AllowPrivilegeEscalation controls whether a process can gain more
   * privileges than its parent process. This bool directly controls if
   * the no_new_privs flag will be set on the container process.
   * AllowPrivilegeEscalation is true always when the container is:
   * 1) run as Privileged
   * 2) has CAP_SYS_ADMIN
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ThanosRulerSpecInitContainersSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * The capabilities to add/drop when running containers.
   * Defaults to the default set of capabilities granted by the container runtime.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default the default set of capabilities granted by the container runtime.
   * @schema ThanosRulerSpecInitContainersSecurityContext#capabilities
   */
  readonly capabilities?: ThanosRulerSpecInitContainersSecurityContextCapabilities;

  /**
   * Run container in privileged mode.
   * Processes in privileged containers are essentially equivalent to root on the host.
   * Defaults to false.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false.
   * @schema ThanosRulerSpecInitContainersSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * procMount denotes the type of proc mount to use for the containers.
   * The default is DefaultProcMount which uses the container runtime defaults for
   * readonly paths and masked paths.
   * This requires the ProcMountType feature flag to be enabled.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ThanosRulerSpecInitContainersSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * Whether this container has a read-only root filesystem.
   * Default is false.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false.
   * @schema ThanosRulerSpecInitContainersSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * The GID to run the entrypoint of the container process.
   * Uses runtime default if unset.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ThanosRulerSpecInitContainersSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user.
   * If true, the Kubelet will validate the image at runtime to ensure that it
   * does not run as UID 0 (root) and fail to start the container if it does.
   * If unset or false, no such validation will be performed.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema ThanosRulerSpecInitContainersSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process.
   * Defaults to user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified.
   * @schema ThanosRulerSpecInitContainersSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to the container.
   * If unspecified, the container runtime will allocate a random SELinux context for each
   * container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ThanosRulerSpecInitContainersSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: ThanosRulerSpecInitContainersSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by this container. If seccomp options are
   * provided at both the pod & container level, the container options
   * override the pod options.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ThanosRulerSpecInitContainersSecurityContext#seccompProfile
   */
  readonly seccompProfile?: ThanosRulerSpecInitContainersSecurityContextSeccompProfile;

  /**
   * The Windows specific settings applied to all containers.
   * If unspecified, the options from the PodSecurityContext will be used.
   * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema ThanosRulerSpecInitContainersSecurityContext#windowsOptions
   */
  readonly windowsOptions?: ThanosRulerSpecInitContainersSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersSecurityContext(obj: ThanosRulerSpecInitContainersSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowPrivilegeEscalation': obj.allowPrivilegeEscalation,
    'capabilities': toJson_ThanosRulerSpecInitContainersSecurityContextCapabilities(obj.capabilities),
    'privileged': obj.privileged,
    'procMount': obj.procMount,
    'readOnlyRootFilesystem': obj.readOnlyRootFilesystem,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_ThanosRulerSpecInitContainersSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_ThanosRulerSpecInitContainersSecurityContextSeccompProfile(obj.seccompProfile),
    'windowsOptions': toJson_ThanosRulerSpecInitContainersSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * StartupProbe indicates that the Pod has successfully initialized.
 * If specified, no other probes are executed until this completes successfully.
 * If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
 * This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
 * when it might take a long time to load data or warm a cache, than during steady-state operation.
 * This cannot be updated.
 * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema ThanosRulerSpecInitContainersStartupProbe
 */
export interface ThanosRulerSpecInitContainersStartupProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema ThanosRulerSpecInitContainersStartupProbe#exec
   */
  readonly exec?: ThanosRulerSpecInitContainersStartupProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   * Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema ThanosRulerSpecInitContainersStartupProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port.
   *
   * @schema ThanosRulerSpecInitContainersStartupProbe#grpc
   */
  readonly grpc?: ThanosRulerSpecInitContainersStartupProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema ThanosRulerSpecInitContainersStartupProbe#httpGet
   */
  readonly httpGet?: ThanosRulerSpecInitContainersStartupProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema ThanosRulerSpecInitContainersStartupProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe.
   * Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema ThanosRulerSpecInitContainersStartupProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema ThanosRulerSpecInitContainersStartupProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema ThanosRulerSpecInitContainersStartupProbe#tcpSocket
   */
  readonly tcpSocket?: ThanosRulerSpecInitContainersStartupProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
   * value overrides the value provided by the pod spec.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
   * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema ThanosRulerSpecInitContainersStartupProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out.
   * Defaults to 1 second. Minimum value is 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1.
   * @schema ThanosRulerSpecInitContainersStartupProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersStartupProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersStartupProbe(obj: ThanosRulerSpecInitContainersStartupProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_ThanosRulerSpecInitContainersStartupProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_ThanosRulerSpecInitContainersStartupProbeGrpc(obj.grpc),
    'httpGet': toJson_ThanosRulerSpecInitContainersStartupProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_ThanosRulerSpecInitContainersStartupProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * volumeDevice describes a mapping of a raw block device within a container.
 *
 * @schema ThanosRulerSpecInitContainersVolumeDevices
 */
export interface ThanosRulerSpecInitContainersVolumeDevices {
  /**
   * devicePath is the path inside of the container that the device will be mapped to.
   *
   * @schema ThanosRulerSpecInitContainersVolumeDevices#devicePath
   */
  readonly devicePath: string;

  /**
   * name must match the name of a persistentVolumeClaim in the pod
   *
   * @schema ThanosRulerSpecInitContainersVolumeDevices#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersVolumeDevices' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersVolumeDevices(obj: ThanosRulerSpecInitContainersVolumeDevices | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'devicePath': obj.devicePath,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema ThanosRulerSpecInitContainersVolumeMounts
 */
export interface ThanosRulerSpecInitContainersVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must
   * not contain ':'.
   *
   * @schema ThanosRulerSpecInitContainersVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host
   * to container and the other way around.
   * When not set, MountPropagationNone is used.
   * This field is beta in 1.10.
   *
   * @schema ThanosRulerSpecInitContainersVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema ThanosRulerSpecInitContainersVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified).
   * Defaults to false.
   *
   * @default false.
   * @schema ThanosRulerSpecInitContainersVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Path within the volume from which the container's volume should be mounted.
   * Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema ThanosRulerSpecInitContainersVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted.
   * Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
   * Defaults to "" (volume's root).
   * SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root).
   * @schema ThanosRulerSpecInitContainersVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersVolumeMounts(obj: ThanosRulerSpecInitContainersVolumeMounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'mountPropagation': obj.mountPropagation,
    'name': obj.name,
    'readOnly': obj.readOnly,
    'subPath': obj.subPath,
    'subPathExpr': obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema ThanosRulerSpecResourcesClaims
 */
export interface ThanosRulerSpecResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema ThanosRulerSpecResourcesClaims#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecResourcesClaims(obj: ThanosRulerSpecResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ThanosRulerSpecResourcesLimits
 */
export class ThanosRulerSpecResourcesLimits {
  public static fromNumber(value: number): ThanosRulerSpecResourcesLimits {
    return new ThanosRulerSpecResourcesLimits(value);
  }
  public static fromString(value: string): ThanosRulerSpecResourcesLimits {
    return new ThanosRulerSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema ThanosRulerSpecResourcesRequests
 */
export class ThanosRulerSpecResourcesRequests {
  public static fromNumber(value: number): ThanosRulerSpecResourcesRequests {
    return new ThanosRulerSpecResourcesRequests(value);
  }
  public static fromString(value: string): ThanosRulerSpecResourcesRequests {
    return new ThanosRulerSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ThanosRulerSpecRuleNamespaceSelectorMatchExpressions
 */
export interface ThanosRulerSpecRuleNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ThanosRulerSpecRuleNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ThanosRulerSpecRuleNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ThanosRulerSpecRuleNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ThanosRulerSpecRuleNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecRuleNamespaceSelectorMatchExpressions(obj: ThanosRulerSpecRuleNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ThanosRulerSpecRuleSelectorMatchExpressions
 */
export interface ThanosRulerSpecRuleSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ThanosRulerSpecRuleSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ThanosRulerSpecRuleSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ThanosRulerSpecRuleSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ThanosRulerSpecRuleSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecRuleSelectorMatchExpressions(obj: ThanosRulerSpecRuleSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The SELinux context to be applied to all containers.
 * If unspecified, the container runtime will allocate a random SELinux context for each
 * container.  May also be set in SecurityContext.  If set in
 * both SecurityContext and PodSecurityContext, the value specified in SecurityContext
 * takes precedence for that container.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema ThanosRulerSpecSecurityContextSeLinuxOptions
 */
export interface ThanosRulerSpecSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema ThanosRulerSpecSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema ThanosRulerSpecSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema ThanosRulerSpecSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema ThanosRulerSpecSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecSecurityContextSeLinuxOptions(obj: ThanosRulerSpecSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The seccomp options to use by the containers in this pod.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema ThanosRulerSpecSecurityContextSeccompProfile
 */
export interface ThanosRulerSpecSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used.
   * The profile must be preconfigured on the node to work.
   * Must be a descending path, relative to the kubelet's configured seccomp profile location.
   * Must be set if type is "Localhost". Must NOT be set for any other type.
   *
   * @schema ThanosRulerSpecSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied.
   * Valid options are:
   *
   *
   * Localhost - a profile defined in a file on the node should be used.
   * RuntimeDefault - the container runtime default profile should be used.
   * Unconfined - no profile should be applied.
   *
   * @schema ThanosRulerSpecSecurityContextSeccompProfile#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecSecurityContextSeccompProfile(obj: ThanosRulerSpecSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Sysctl defines a kernel parameter to be set
 *
 * @schema ThanosRulerSpecSecurityContextSysctls
 */
export interface ThanosRulerSpecSecurityContextSysctls {
  /**
   * Name of a property to set
   *
   * @schema ThanosRulerSpecSecurityContextSysctls#name
   */
  readonly name: string;

  /**
   * Value of a property to set
   *
   * @schema ThanosRulerSpecSecurityContextSysctls#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecSecurityContextSysctls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecSecurityContextSysctls(obj: ThanosRulerSpecSecurityContextSysctls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Windows specific settings applied to all containers.
 * If unspecified, the options within a container's SecurityContext will be used.
 * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema ThanosRulerSpecSecurityContextWindowsOptions
 */
export interface ThanosRulerSpecSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook
   * (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
   * GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema ThanosRulerSpecSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema ThanosRulerSpecSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container.
   * All of a Pod's containers must have the same effective HostProcess value
   * (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
   * In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema ThanosRulerSpecSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process.
   * Defaults to the user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext. If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified.
   * @schema ThanosRulerSpecSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecSecurityContextWindowsOptions(obj: ThanosRulerSpecSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EmptyDirVolumeSource to be used by the StatefulSet.
 * If specified, it takes precedence over `ephemeral` and `volumeClaimTemplate`.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes/#emptydir
 *
 * @schema ThanosRulerSpecStorageEmptyDir
 */
export interface ThanosRulerSpecStorageEmptyDir {
  /**
   * medium represents what type of storage medium should back this directory.
   * The default is "" which means to use the node's default medium.
   * Must be an empty string (default) or Memory.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema ThanosRulerSpecStorageEmptyDir#medium
   */
  readonly medium?: string;

  /**
   * sizeLimit is the total amount of local storage required for this EmptyDir volume.
   * The size limit is also applicable for memory medium.
   * The maximum usage on memory medium EmptyDir would be the minimum value between
   * the SizeLimit specified here and the sum of memory limits of all containers in a pod.
   * The default is nil which means that the limit is undefined.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema ThanosRulerSpecStorageEmptyDir#sizeLimit
   */
  readonly sizeLimit?: ThanosRulerSpecStorageEmptyDirSizeLimit;

}

/**
 * Converts an object of type 'ThanosRulerSpecStorageEmptyDir' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecStorageEmptyDir(obj: ThanosRulerSpecStorageEmptyDir | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'medium': obj.medium,
    'sizeLimit': obj.sizeLimit?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EphemeralVolumeSource to be used by the StatefulSet.
 * This is a beta field in k8s 1.21 and GA in 1.15.
 * For lower versions, starting with k8s 1.19, it requires enabling the GenericEphemeralVolume feature gate.
 * More info: https://kubernetes.io/docs/concepts/storage/ephemeral-volumes/#generic-ephemeral-volumes
 *
 * @schema ThanosRulerSpecStorageEphemeral
 */
export interface ThanosRulerSpecStorageEphemeral {
  /**
   * Will be used to create a stand-alone PVC to provision the volume.
   * The pod in which this EphemeralVolumeSource is embedded will be the
   * owner of the PVC, i.e. the PVC will be deleted together with the
   * pod.  The name of the PVC will be `<pod name>-<volume name>` where
   * `<volume name>` is the name from the `PodSpec.Volumes` array
   * entry. Pod validation will reject the pod if the concatenated name
   * is not valid for a PVC (for example, too long).
   *
   *
   * An existing PVC with that name that is not owned by the pod
   * will *not* be used for the pod to avoid using an unrelated
   * volume by mistake. Starting the pod is then blocked until
   * the unrelated PVC is removed. If such a pre-created PVC is
   * meant to be used by the pod, the PVC has to updated with an
   * owner reference to the pod once the pod exists. Normally
   * this should not be necessary, but it may be useful when
   * manually reconstructing a broken cluster.
   *
   *
   * This field is read-only and no changes will be made by Kubernetes
   * to the PVC after it has been created.
   *
   *
   * Required, must not be nil.
   *
   * @schema ThanosRulerSpecStorageEphemeral#volumeClaimTemplate
   */
  readonly volumeClaimTemplate?: ThanosRulerSpecStorageEphemeralVolumeClaimTemplate;

}

/**
 * Converts an object of type 'ThanosRulerSpecStorageEphemeral' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecStorageEphemeral(obj: ThanosRulerSpecStorageEphemeral | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'volumeClaimTemplate': toJson_ThanosRulerSpecStorageEphemeralVolumeClaimTemplate(obj.volumeClaimTemplate),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Defines the PVC spec to be used by the Prometheus StatefulSets.
 * The easiest way to use a volume that cannot be automatically provisioned
 * is to use a label selector alongside manually created PersistentVolumes.
 *
 * @schema ThanosRulerSpecStorageVolumeClaimTemplate
 */
export interface ThanosRulerSpecStorageVolumeClaimTemplate {
  /**
   * APIVersion defines the versioned schema of this representation of an object.
   * Servers should convert recognized schemas to the latest internal value, and
   * may reject unrecognized values.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplate#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Kind is a string value representing the REST resource this object represents.
   * Servers may infer this from the endpoint the client submits requests to.
   * Cannot be updated.
   * In CamelCase.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplate#kind
   */
  readonly kind?: string;

  /**
   * EmbeddedMetadata contains metadata relevant to an EmbeddedResource.
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplate#metadata
   */
  readonly metadata?: ThanosRulerSpecStorageVolumeClaimTemplateMetadata;

  /**
   * Defines the desired characteristics of a volume requested by a pod author.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplate#spec
   */
  readonly spec?: ThanosRulerSpecStorageVolumeClaimTemplateSpec;

  /**
   * Deprecated: this field is never set.
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplate#status
   */
  readonly status?: ThanosRulerSpecStorageVolumeClaimTemplateStatus;

}

/**
 * Converts an object of type 'ThanosRulerSpecStorageVolumeClaimTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecStorageVolumeClaimTemplate(obj: ThanosRulerSpecStorageVolumeClaimTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'kind': obj.kind,
    'metadata': toJson_ThanosRulerSpecStorageVolumeClaimTemplateMetadata(obj.metadata),
    'spec': toJson_ThanosRulerSpecStorageVolumeClaimTemplateSpec(obj.spec),
    'status': toJson_ThanosRulerSpecStorageVolumeClaimTemplateStatus(obj.status),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LabelSelector is used to find matching pods.
 * Pods that match this label selector are counted to determine the number of pods
 * in their corresponding topology domain.
 *
 * @schema ThanosRulerSpecTopologySpreadConstraintsLabelSelector
 */
export interface ThanosRulerSpecTopologySpreadConstraintsLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ThanosRulerSpecTopologySpreadConstraintsLabelSelector#matchExpressions
   */
  readonly matchExpressions?: ThanosRulerSpecTopologySpreadConstraintsLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ThanosRulerSpecTopologySpreadConstraintsLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ThanosRulerSpecTopologySpreadConstraintsLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecTopologySpreadConstraintsLabelSelector(obj: ThanosRulerSpecTopologySpreadConstraintsLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ThanosRulerSpecTopologySpreadConstraintsLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * awsElasticBlockStore represents an AWS Disk resource that is attached to a
 * kubelet's host machine and then exposed to the pod.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
 *
 * @schema ThanosRulerSpecVolumesAwsElasticBlockStore
 */
export interface ThanosRulerSpecVolumesAwsElasticBlockStore {
  /**
   * fsType is the filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   * TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema ThanosRulerSpecVolumesAwsElasticBlockStore#fsType
   */
  readonly fsType?: string;

  /**
   * partition is the partition in the volume that you want to mount.
   * If omitted, the default is to mount by volume name.
   * Examples: For volume /dev/sda1, you specify the partition as "1".
   * Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
   *
   * @schema ThanosRulerSpecVolumesAwsElasticBlockStore#partition
   */
  readonly partition?: number;

  /**
   * readOnly value true will force the readOnly setting in VolumeMounts.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema ThanosRulerSpecVolumesAwsElasticBlockStore#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * volumeID is unique ID of the persistent disk resource in AWS (Amazon EBS volume).
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema ThanosRulerSpecVolumesAwsElasticBlockStore#volumeID
   */
  readonly volumeId: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesAwsElasticBlockStore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesAwsElasticBlockStore(obj: ThanosRulerSpecVolumesAwsElasticBlockStore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'partition': obj.partition,
    'readOnly': obj.readOnly,
    'volumeID': obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
 *
 * @schema ThanosRulerSpecVolumesAzureDisk
 */
export interface ThanosRulerSpecVolumesAzureDisk {
  /**
   * cachingMode is the Host Caching mode: None, Read Only, Read Write.
   *
   * @schema ThanosRulerSpecVolumesAzureDisk#cachingMode
   */
  readonly cachingMode?: string;

  /**
   * diskName is the Name of the data disk in the blob storage
   *
   * @schema ThanosRulerSpecVolumesAzureDisk#diskName
   */
  readonly diskName: string;

  /**
   * diskURI is the URI of data disk in the blob storage
   *
   * @schema ThanosRulerSpecVolumesAzureDisk#diskURI
   */
  readonly diskUri: string;

  /**
   * fsType is Filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema ThanosRulerSpecVolumesAzureDisk#fsType
   */
  readonly fsType?: string;

  /**
   * kind expected values are Shared: multiple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared
   *
   * @schema ThanosRulerSpecVolumesAzureDisk#kind
   */
  readonly kind?: string;

  /**
   * readOnly Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force
   * @schema ThanosRulerSpecVolumesAzureDisk#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesAzureDisk' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesAzureDisk(obj: ThanosRulerSpecVolumesAzureDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cachingMode': obj.cachingMode,
    'diskName': obj.diskName,
    'diskURI': obj.diskUri,
    'fsType': obj.fsType,
    'kind': obj.kind,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * azureFile represents an Azure File Service mount on the host and bind mount to the pod.
 *
 * @schema ThanosRulerSpecVolumesAzureFile
 */
export interface ThanosRulerSpecVolumesAzureFile {
  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @schema ThanosRulerSpecVolumesAzureFile#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretName is the  name of secret that contains Azure Storage Account Name and Key
   *
   * @schema ThanosRulerSpecVolumesAzureFile#secretName
   */
  readonly secretName: string;

  /**
   * shareName is the azure share Name
   *
   * @schema ThanosRulerSpecVolumesAzureFile#shareName
   */
  readonly shareName: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesAzureFile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesAzureFile(obj: ThanosRulerSpecVolumesAzureFile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'readOnly': obj.readOnly,
    'secretName': obj.secretName,
    'shareName': obj.shareName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * cephFS represents a Ceph FS mount on the host that shares a pod's lifetime
 *
 * @schema ThanosRulerSpecVolumesCephfs
 */
export interface ThanosRulerSpecVolumesCephfs {
  /**
   * monitors is Required: Monitors is a collection of Ceph monitors
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema ThanosRulerSpecVolumesCephfs#monitors
   */
  readonly monitors: string[];

  /**
   * path is Optional: Used as the mounted root, rather than the full Ceph tree, default is /
   *
   * @schema ThanosRulerSpecVolumesCephfs#path
   */
  readonly path?: string;

  /**
   * readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @default false (read/write). ReadOnly here will force
   * @schema ThanosRulerSpecVolumesCephfs#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretFile is Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema ThanosRulerSpecVolumesCephfs#secretFile
   */
  readonly secretFile?: string;

  /**
   * secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty.
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema ThanosRulerSpecVolumesCephfs#secretRef
   */
  readonly secretRef?: ThanosRulerSpecVolumesCephfsSecretRef;

  /**
   * user is optional: User is the rados user name, default is admin
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema ThanosRulerSpecVolumesCephfs#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesCephfs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesCephfs(obj: ThanosRulerSpecVolumesCephfs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'monitors': obj.monitors?.map(y => y),
    'path': obj.path,
    'readOnly': obj.readOnly,
    'secretFile': obj.secretFile,
    'secretRef': toJson_ThanosRulerSpecVolumesCephfsSecretRef(obj.secretRef),
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * cinder represents a cinder volume attached and mounted on kubelets host machine.
 * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
 *
 * @schema ThanosRulerSpecVolumesCinder
 */
export interface ThanosRulerSpecVolumesCinder {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema ThanosRulerSpecVolumesCinder#fsType
   */
  readonly fsType?: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema ThanosRulerSpecVolumesCinder#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is optional: points to a secret object containing parameters used to connect
   * to OpenStack.
   *
   * @schema ThanosRulerSpecVolumesCinder#secretRef
   */
  readonly secretRef?: ThanosRulerSpecVolumesCinderSecretRef;

  /**
   * volumeID used to identify the volume in cinder.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema ThanosRulerSpecVolumesCinder#volumeID
   */
  readonly volumeId: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesCinder' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesCinder(obj: ThanosRulerSpecVolumesCinder | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'readOnly': obj.readOnly,
    'secretRef': toJson_ThanosRulerSpecVolumesCinderSecretRef(obj.secretRef),
    'volumeID': obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * configMap represents a configMap that should populate this volume
 *
 * @schema ThanosRulerSpecVolumesConfigMap
 */
export interface ThanosRulerSpecVolumesConfigMap {
  /**
   * defaultMode is optional: mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * Defaults to 0644.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644.
   * @schema ThanosRulerSpecVolumesConfigMap#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * items if unspecified, each key-value pair in the Data field of the referenced
   * ConfigMap will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the ConfigMap,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   *
   * @schema ThanosRulerSpecVolumesConfigMap#items
   */
  readonly items?: ThanosRulerSpecVolumesConfigMapItems[];

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ThanosRulerSpecVolumesConfigMap#name
   */
  readonly name?: string;

  /**
   * optional specify whether the ConfigMap or its keys must be defined
   *
   * @schema ThanosRulerSpecVolumesConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesConfigMap(obj: ThanosRulerSpecVolumesConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_ThanosRulerSpecVolumesConfigMapItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers (Beta feature).
 *
 * @schema ThanosRulerSpecVolumesCsi
 */
export interface ThanosRulerSpecVolumesCsi {
  /**
   * driver is the name of the CSI driver that handles this volume.
   * Consult with your admin for the correct name as registered in the cluster.
   *
   * @schema ThanosRulerSpecVolumesCsi#driver
   */
  readonly driver: string;

  /**
   * fsType to mount. Ex. "ext4", "xfs", "ntfs".
   * If not provided, the empty value is passed to the associated CSI driver
   * which will determine the default filesystem to apply.
   *
   * @schema ThanosRulerSpecVolumesCsi#fsType
   */
  readonly fsType?: string;

  /**
   * nodePublishSecretRef is a reference to the secret object containing
   * sensitive information to pass to the CSI driver to complete the CSI
   * NodePublishVolume and NodeUnpublishVolume calls.
   * This field is optional, and  may be empty if no secret is required. If the
   * secret object contains more than one secret, all secret references are passed.
   *
   * @schema ThanosRulerSpecVolumesCsi#nodePublishSecretRef
   */
  readonly nodePublishSecretRef?: ThanosRulerSpecVolumesCsiNodePublishSecretRef;

  /**
   * readOnly specifies a read-only configuration for the volume.
   * Defaults to false (read/write).
   *
   * @default false (read/write).
   * @schema ThanosRulerSpecVolumesCsi#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * volumeAttributes stores driver-specific properties that are passed to the CSI
   * driver. Consult your driver's documentation for supported values.
   *
   * @schema ThanosRulerSpecVolumesCsi#volumeAttributes
   */
  readonly volumeAttributes?: { [key: string]: string };

}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesCsi' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesCsi(obj: ThanosRulerSpecVolumesCsi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'driver': obj.driver,
    'fsType': obj.fsType,
    'nodePublishSecretRef': toJson_ThanosRulerSpecVolumesCsiNodePublishSecretRef(obj.nodePublishSecretRef),
    'readOnly': obj.readOnly,
    'volumeAttributes': ((obj.volumeAttributes) === undefined) ? undefined : (Object.entries(obj.volumeAttributes).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * downwardAPI represents downward API about the pod that should populate this volume
 *
 * @schema ThanosRulerSpecVolumesDownwardApi
 */
export interface ThanosRulerSpecVolumesDownwardApi {
  /**
   * Optional: mode bits to use on created files by default. Must be a
   * Optional: mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * Defaults to 0644.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644.
   * @schema ThanosRulerSpecVolumesDownwardApi#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * Items is a list of downward API volume file
   *
   * @schema ThanosRulerSpecVolumesDownwardApi#items
   */
  readonly items?: ThanosRulerSpecVolumesDownwardApiItems[];

}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesDownwardApi' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesDownwardApi(obj: ThanosRulerSpecVolumesDownwardApi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_ThanosRulerSpecVolumesDownwardApiItems(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * emptyDir represents a temporary directory that shares a pod's lifetime.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
 *
 * @schema ThanosRulerSpecVolumesEmptyDir
 */
export interface ThanosRulerSpecVolumesEmptyDir {
  /**
   * medium represents what type of storage medium should back this directory.
   * The default is "" which means to use the node's default medium.
   * Must be an empty string (default) or Memory.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema ThanosRulerSpecVolumesEmptyDir#medium
   */
  readonly medium?: string;

  /**
   * sizeLimit is the total amount of local storage required for this EmptyDir volume.
   * The size limit is also applicable for memory medium.
   * The maximum usage on memory medium EmptyDir would be the minimum value between
   * the SizeLimit specified here and the sum of memory limits of all containers in a pod.
   * The default is nil which means that the limit is undefined.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema ThanosRulerSpecVolumesEmptyDir#sizeLimit
   */
  readonly sizeLimit?: ThanosRulerSpecVolumesEmptyDirSizeLimit;

}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesEmptyDir' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesEmptyDir(obj: ThanosRulerSpecVolumesEmptyDir | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'medium': obj.medium,
    'sizeLimit': obj.sizeLimit?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ephemeral represents a volume that is handled by a cluster storage driver.
 * The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts,
 * and deleted when the pod is removed.
 *
 *
 * Use this if:
 * a) the volume is only needed while the pod runs,
 * b) features of normal volumes like restoring from snapshot or capacity
 * tracking are needed,
 * c) the storage driver is specified through a storage class, and
 * d) the storage driver supports dynamic volume provisioning through
 * a PersistentVolumeClaim (see EphemeralVolumeSource for more
 * information on the connection between this volume type
 * and PersistentVolumeClaim).
 *
 *
 * Use PersistentVolumeClaim or one of the vendor-specific
 * APIs for volumes that persist for longer than the lifecycle
 * of an individual pod.
 *
 *
 * Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to
 * be used that way - see the documentation of the driver for
 * more information.
 *
 *
 * A pod can use both types of ephemeral volumes and
 * persistent volumes at the same time.
 *
 * @schema ThanosRulerSpecVolumesEphemeral
 */
export interface ThanosRulerSpecVolumesEphemeral {
  /**
   * Will be used to create a stand-alone PVC to provision the volume.
   * The pod in which this EphemeralVolumeSource is embedded will be the
   * owner of the PVC, i.e. the PVC will be deleted together with the
   * pod.  The name of the PVC will be `<pod name>-<volume name>` where
   * `<volume name>` is the name from the `PodSpec.Volumes` array
   * entry. Pod validation will reject the pod if the concatenated name
   * is not valid for a PVC (for example, too long).
   *
   *
   * An existing PVC with that name that is not owned by the pod
   * will *not* be used for the pod to avoid using an unrelated
   * volume by mistake. Starting the pod is then blocked until
   * the unrelated PVC is removed. If such a pre-created PVC is
   * meant to be used by the pod, the PVC has to updated with an
   * owner reference to the pod once the pod exists. Normally
   * this should not be necessary, but it may be useful when
   * manually reconstructing a broken cluster.
   *
   *
   * This field is read-only and no changes will be made by Kubernetes
   * to the PVC after it has been created.
   *
   *
   * Required, must not be nil.
   *
   * @schema ThanosRulerSpecVolumesEphemeral#volumeClaimTemplate
   */
  readonly volumeClaimTemplate?: ThanosRulerSpecVolumesEphemeralVolumeClaimTemplate;

}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesEphemeral' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesEphemeral(obj: ThanosRulerSpecVolumesEphemeral | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'volumeClaimTemplate': toJson_ThanosRulerSpecVolumesEphemeralVolumeClaimTemplate(obj.volumeClaimTemplate),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
 *
 * @schema ThanosRulerSpecVolumesFc
 */
export interface ThanosRulerSpecVolumesFc {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema ThanosRulerSpecVolumesFc#fsType
   */
  readonly fsType?: string;

  /**
   * lun is Optional: FC target lun number
   *
   * @schema ThanosRulerSpecVolumesFc#lun
   */
  readonly lun?: number;

  /**
   * readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force
   * @schema ThanosRulerSpecVolumesFc#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * targetWWNs is Optional: FC target worldwide names (WWNs)
   *
   * @schema ThanosRulerSpecVolumesFc#targetWWNs
   */
  readonly targetWwNs?: string[];

  /**
   * wwids Optional: FC volume world wide identifiers (wwids)
   * Either wwids or combination of targetWWNs and lun must be set, but not both simultaneously.
   *
   * @schema ThanosRulerSpecVolumesFc#wwids
   */
  readonly wwids?: string[];

}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesFc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesFc(obj: ThanosRulerSpecVolumesFc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'lun': obj.lun,
    'readOnly': obj.readOnly,
    'targetWWNs': obj.targetWwNs?.map(y => y),
    'wwids': obj.wwids?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * flexVolume represents a generic volume resource that is
 * provisioned/attached using an exec based plugin.
 *
 * @schema ThanosRulerSpecVolumesFlexVolume
 */
export interface ThanosRulerSpecVolumesFlexVolume {
  /**
   * driver is the name of the driver to use for this volume.
   *
   * @schema ThanosRulerSpecVolumesFlexVolume#driver
   */
  readonly driver: string;

  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
   *
   * @schema ThanosRulerSpecVolumesFlexVolume#fsType
   */
  readonly fsType?: string;

  /**
   * options is Optional: this field holds extra command options if any.
   *
   * @schema ThanosRulerSpecVolumesFlexVolume#options
   */
  readonly options?: { [key: string]: string };

  /**
   * readOnly is Optional: defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @schema ThanosRulerSpecVolumesFlexVolume#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is Optional: secretRef is reference to the secret object containing
   * sensitive information to pass to the plugin scripts. This may be
   * empty if no secret object is specified. If the secret object
   * contains more than one secret, all secrets are passed to the plugin
   * scripts.
   *
   * @schema ThanosRulerSpecVolumesFlexVolume#secretRef
   */
  readonly secretRef?: ThanosRulerSpecVolumesFlexVolumeSecretRef;

}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesFlexVolume' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesFlexVolume(obj: ThanosRulerSpecVolumesFlexVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'driver': obj.driver,
    'fsType': obj.fsType,
    'options': ((obj.options) === undefined) ? undefined : (Object.entries(obj.options).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'readOnly': obj.readOnly,
    'secretRef': toJson_ThanosRulerSpecVolumesFlexVolumeSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running
 *
 * @schema ThanosRulerSpecVolumesFlocker
 */
export interface ThanosRulerSpecVolumesFlocker {
  /**
   * datasetName is Name of the dataset stored as metadata -> name on the dataset for Flocker
   * should be considered as deprecated
   *
   * @schema ThanosRulerSpecVolumesFlocker#datasetName
   */
  readonly datasetName?: string;

  /**
   * datasetUUID is the UUID of the dataset. This is unique identifier of a Flocker dataset
   *
   * @schema ThanosRulerSpecVolumesFlocker#datasetUUID
   */
  readonly datasetUuid?: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesFlocker' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesFlocker(obj: ThanosRulerSpecVolumesFlocker | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'datasetName': obj.datasetName,
    'datasetUUID': obj.datasetUuid,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * gcePersistentDisk represents a GCE Disk resource that is attached to a
 * kubelet's host machine and then exposed to the pod.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
 *
 * @schema ThanosRulerSpecVolumesGcePersistentDisk
 */
export interface ThanosRulerSpecVolumesGcePersistentDisk {
  /**
   * fsType is filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   * TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema ThanosRulerSpecVolumesGcePersistentDisk#fsType
   */
  readonly fsType?: string;

  /**
   * partition is the partition in the volume that you want to mount.
   * If omitted, the default is to mount by volume name.
   * Examples: For volume /dev/sda1, you specify the partition as "1".
   * Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema ThanosRulerSpecVolumesGcePersistentDisk#partition
   */
  readonly partition?: number;

  /**
   * pdName is unique name of the PD resource in GCE. Used to identify the disk in GCE.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema ThanosRulerSpecVolumesGcePersistentDisk#pdName
   */
  readonly pdName: string;

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts.
   * Defaults to false.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @default false.
   * @schema ThanosRulerSpecVolumesGcePersistentDisk#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesGcePersistentDisk' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesGcePersistentDisk(obj: ThanosRulerSpecVolumesGcePersistentDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'partition': obj.partition,
    'pdName': obj.pdName,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * gitRepo represents a git repository at a particular revision.
 * DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an
 * EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir
 * into the Pod's container.
 *
 * @schema ThanosRulerSpecVolumesGitRepo
 */
export interface ThanosRulerSpecVolumesGitRepo {
  /**
   * directory is the target directory name.
   * Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the
   * git repository.  Otherwise, if specified, the volume will contain the git repository in
   * the subdirectory with the given name.
   *
   * @schema ThanosRulerSpecVolumesGitRepo#directory
   */
  readonly directory?: string;

  /**
   * repository is the URL
   *
   * @schema ThanosRulerSpecVolumesGitRepo#repository
   */
  readonly repository: string;

  /**
   * revision is the commit hash for the specified revision.
   *
   * @schema ThanosRulerSpecVolumesGitRepo#revision
   */
  readonly revision?: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesGitRepo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesGitRepo(obj: ThanosRulerSpecVolumesGitRepo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'directory': obj.directory,
    'repository': obj.repository,
    'revision': obj.revision,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime.
 * More info: https://examples.k8s.io/volumes/glusterfs/README.md
 *
 * @schema ThanosRulerSpecVolumesGlusterfs
 */
export interface ThanosRulerSpecVolumesGlusterfs {
  /**
   * endpoints is the endpoint name that details Glusterfs topology.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @schema ThanosRulerSpecVolumesGlusterfs#endpoints
   */
  readonly endpoints: string;

  /**
   * path is the Glusterfs volume path.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @schema ThanosRulerSpecVolumesGlusterfs#path
   */
  readonly path: string;

  /**
   * readOnly here will force the Glusterfs volume to be mounted with read-only permissions.
   * Defaults to false.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @default false.
   * @schema ThanosRulerSpecVolumesGlusterfs#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesGlusterfs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesGlusterfs(obj: ThanosRulerSpecVolumesGlusterfs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'endpoints': obj.endpoints,
    'path': obj.path,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * hostPath represents a pre-existing file or directory on the host
 * machine that is directly exposed to the container. This is generally
 * used for system agents or other privileged things that are allowed
 * to see the host machine. Most containers will NOT need this.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
 * ---
 * TODO(jonesdl) We need to restrict who can use host directory mounts and who can/can not
 * mount host directories as read/write.
 *
 * @schema ThanosRulerSpecVolumesHostPath
 */
export interface ThanosRulerSpecVolumesHostPath {
  /**
   * path of the directory on the host.
   * If the path is a symlink, it will follow the link to the real path.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @schema ThanosRulerSpecVolumesHostPath#path
   */
  readonly path: string;

  /**
   * type for HostPath Volume
   * Defaults to ""
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @default More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   * @schema ThanosRulerSpecVolumesHostPath#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesHostPath' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesHostPath(obj: ThanosRulerSpecVolumesHostPath | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * iscsi represents an ISCSI Disk resource that is attached to a
 * kubelet's host machine and then exposed to the pod.
 * More info: https://examples.k8s.io/volumes/iscsi/README.md
 *
 * @schema ThanosRulerSpecVolumesIscsi
 */
export interface ThanosRulerSpecVolumesIscsi {
  /**
   * chapAuthDiscovery defines whether support iSCSI Discovery CHAP authentication
   *
   * @schema ThanosRulerSpecVolumesIscsi#chapAuthDiscovery
   */
  readonly chapAuthDiscovery?: boolean;

  /**
   * chapAuthSession defines whether support iSCSI Session CHAP authentication
   *
   * @schema ThanosRulerSpecVolumesIscsi#chapAuthSession
   */
  readonly chapAuthSession?: boolean;

  /**
   * fsType is the filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi
   * TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema ThanosRulerSpecVolumesIscsi#fsType
   */
  readonly fsType?: string;

  /**
   * initiatorName is the custom iSCSI Initiator Name.
   * If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface
   * <target portal>:<volume name> will be created for the connection.
   *
   * @schema ThanosRulerSpecVolumesIscsi#initiatorName
   */
  readonly initiatorName?: string;

  /**
   * iqn is the target iSCSI Qualified Name.
   *
   * @schema ThanosRulerSpecVolumesIscsi#iqn
   */
  readonly iqn: string;

  /**
   * iscsiInterface is the interface Name that uses an iSCSI transport.
   * Defaults to 'default' (tcp).
   *
   * @default default' (tcp).
   * @schema ThanosRulerSpecVolumesIscsi#iscsiInterface
   */
  readonly iscsiInterface?: string;

  /**
   * lun represents iSCSI Target Lun number.
   *
   * @schema ThanosRulerSpecVolumesIscsi#lun
   */
  readonly lun: number;

  /**
   * portals is the iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port
   * is other than default (typically TCP ports 860 and 3260).
   *
   * @schema ThanosRulerSpecVolumesIscsi#portals
   */
  readonly portals?: string[];

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts.
   * Defaults to false.
   *
   * @default false.
   * @schema ThanosRulerSpecVolumesIscsi#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is the CHAP Secret for iSCSI target and initiator authentication
   *
   * @schema ThanosRulerSpecVolumesIscsi#secretRef
   */
  readonly secretRef?: ThanosRulerSpecVolumesIscsiSecretRef;

  /**
   * targetPortal is iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port
   * is other than default (typically TCP ports 860 and 3260).
   *
   * @schema ThanosRulerSpecVolumesIscsi#targetPortal
   */
  readonly targetPortal: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesIscsi' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesIscsi(obj: ThanosRulerSpecVolumesIscsi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'chapAuthDiscovery': obj.chapAuthDiscovery,
    'chapAuthSession': obj.chapAuthSession,
    'fsType': obj.fsType,
    'initiatorName': obj.initiatorName,
    'iqn': obj.iqn,
    'iscsiInterface': obj.iscsiInterface,
    'lun': obj.lun,
    'portals': obj.portals?.map(y => y),
    'readOnly': obj.readOnly,
    'secretRef': toJson_ThanosRulerSpecVolumesIscsiSecretRef(obj.secretRef),
    'targetPortal': obj.targetPortal,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * nfs represents an NFS mount on the host that shares a pod's lifetime
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
 *
 * @schema ThanosRulerSpecVolumesNfs
 */
export interface ThanosRulerSpecVolumesNfs {
  /**
   * path that is exported by the NFS server.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema ThanosRulerSpecVolumesNfs#path
   */
  readonly path: string;

  /**
   * readOnly here will force the NFS export to be mounted with read-only permissions.
   * Defaults to false.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @default false.
   * @schema ThanosRulerSpecVolumesNfs#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * server is the hostname or IP address of the NFS server.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema ThanosRulerSpecVolumesNfs#server
   */
  readonly server: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesNfs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesNfs(obj: ThanosRulerSpecVolumesNfs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'readOnly': obj.readOnly,
    'server': obj.server,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * persistentVolumeClaimVolumeSource represents a reference to a
 * PersistentVolumeClaim in the same namespace.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
 *
 * @schema ThanosRulerSpecVolumesPersistentVolumeClaim
 */
export interface ThanosRulerSpecVolumesPersistentVolumeClaim {
  /**
   * claimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema ThanosRulerSpecVolumesPersistentVolumeClaim#claimName
   */
  readonly claimName: string;

  /**
   * readOnly Will force the ReadOnly setting in VolumeMounts.
   * Default false.
   *
   * @schema ThanosRulerSpecVolumesPersistentVolumeClaim#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesPersistentVolumeClaim' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesPersistentVolumeClaim(obj: ThanosRulerSpecVolumesPersistentVolumeClaim | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claimName': obj.claimName,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
 *
 * @schema ThanosRulerSpecVolumesPhotonPersistentDisk
 */
export interface ThanosRulerSpecVolumesPhotonPersistentDisk {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema ThanosRulerSpecVolumesPhotonPersistentDisk#fsType
   */
  readonly fsType?: string;

  /**
   * pdID is the ID that identifies Photon Controller persistent disk
   *
   * @schema ThanosRulerSpecVolumesPhotonPersistentDisk#pdID
   */
  readonly pdId: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesPhotonPersistentDisk' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesPhotonPersistentDisk(obj: ThanosRulerSpecVolumesPhotonPersistentDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'pdID': obj.pdId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * portworxVolume represents a portworx volume attached and mounted on kubelets host machine
 *
 * @schema ThanosRulerSpecVolumesPortworxVolume
 */
export interface ThanosRulerSpecVolumesPortworxVolume {
  /**
   * fSType represents the filesystem type to mount
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema ThanosRulerSpecVolumesPortworxVolume#fsType
   */
  readonly fsType?: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @schema ThanosRulerSpecVolumesPortworxVolume#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * volumeID uniquely identifies a Portworx volume
   *
   * @schema ThanosRulerSpecVolumesPortworxVolume#volumeID
   */
  readonly volumeId: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesPortworxVolume' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesPortworxVolume(obj: ThanosRulerSpecVolumesPortworxVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'readOnly': obj.readOnly,
    'volumeID': obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * projected items for all in one resources secrets, configmaps, and downward API
 *
 * @schema ThanosRulerSpecVolumesProjected
 */
export interface ThanosRulerSpecVolumesProjected {
  /**
   * defaultMode are the mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema ThanosRulerSpecVolumesProjected#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * sources is the list of volume projections
   *
   * @schema ThanosRulerSpecVolumesProjected#sources
   */
  readonly sources?: ThanosRulerSpecVolumesProjectedSources[];

}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesProjected' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesProjected(obj: ThanosRulerSpecVolumesProjected | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'sources': obj.sources?.map(y => toJson_ThanosRulerSpecVolumesProjectedSources(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * quobyte represents a Quobyte mount on the host that shares a pod's lifetime
 *
 * @schema ThanosRulerSpecVolumesQuobyte
 */
export interface ThanosRulerSpecVolumesQuobyte {
  /**
   * group to map volume access to
   * Default is no group
   *
   * @default no group
   * @schema ThanosRulerSpecVolumesQuobyte#group
   */
  readonly group?: string;

  /**
   * readOnly here will force the Quobyte volume to be mounted with read-only permissions.
   * Defaults to false.
   *
   * @default false.
   * @schema ThanosRulerSpecVolumesQuobyte#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * registry represents a single or multiple Quobyte Registry services
   * specified as a string as host:port pair (multiple entries are separated with commas)
   * which acts as the central registry for volumes
   *
   * @schema ThanosRulerSpecVolumesQuobyte#registry
   */
  readonly registry: string;

  /**
   * tenant owning the given Quobyte volume in the Backend
   * Used with dynamically provisioned Quobyte volumes, value is set by the plugin
   *
   * @schema ThanosRulerSpecVolumesQuobyte#tenant
   */
  readonly tenant?: string;

  /**
   * user to map volume access to
   * Defaults to serivceaccount user
   *
   * @default serivceaccount user
   * @schema ThanosRulerSpecVolumesQuobyte#user
   */
  readonly user?: string;

  /**
   * volume is a string that references an already created Quobyte volume by name.
   *
   * @schema ThanosRulerSpecVolumesQuobyte#volume
   */
  readonly volume: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesQuobyte' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesQuobyte(obj: ThanosRulerSpecVolumesQuobyte | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'readOnly': obj.readOnly,
    'registry': obj.registry,
    'tenant': obj.tenant,
    'user': obj.user,
    'volume': obj.volume,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * rbd represents a Rados Block Device mount on the host that shares a pod's lifetime.
 * More info: https://examples.k8s.io/volumes/rbd/README.md
 *
 * @schema ThanosRulerSpecVolumesRbd
 */
export interface ThanosRulerSpecVolumesRbd {
  /**
   * fsType is the filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd
   * TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema ThanosRulerSpecVolumesRbd#fsType
   */
  readonly fsType?: string;

  /**
   * image is the rados image name.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @schema ThanosRulerSpecVolumesRbd#image
   */
  readonly image: string;

  /**
   * keyring is the path to key ring for RBDUser.
   * Default is /etc/ceph/keyring.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default etc/ceph/keyring.
   * @schema ThanosRulerSpecVolumesRbd#keyring
   */
  readonly keyring?: string;

  /**
   * monitors is a collection of Ceph monitors.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @schema ThanosRulerSpecVolumesRbd#monitors
   */
  readonly monitors: string[];

  /**
   * pool is the rados pool name.
   * Default is rbd.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default rbd.
   * @schema ThanosRulerSpecVolumesRbd#pool
   */
  readonly pool?: string;

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts.
   * Defaults to false.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default false.
   * @schema ThanosRulerSpecVolumesRbd#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is name of the authentication secret for RBDUser. If provided
   * overrides keyring.
   * Default is nil.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default nil.
   * @schema ThanosRulerSpecVolumesRbd#secretRef
   */
  readonly secretRef?: ThanosRulerSpecVolumesRbdSecretRef;

  /**
   * user is the rados user name.
   * Default is admin.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default admin.
   * @schema ThanosRulerSpecVolumesRbd#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesRbd' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesRbd(obj: ThanosRulerSpecVolumesRbd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'image': obj.image,
    'keyring': obj.keyring,
    'monitors': obj.monitors?.map(y => y),
    'pool': obj.pool,
    'readOnly': obj.readOnly,
    'secretRef': toJson_ThanosRulerSpecVolumesRbdSecretRef(obj.secretRef),
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
 *
 * @schema ThanosRulerSpecVolumesScaleIo
 */
export interface ThanosRulerSpecVolumesScaleIo {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs".
   * Default is "xfs".
   *
   * @default xfs".
   * @schema ThanosRulerSpecVolumesScaleIo#fsType
   */
  readonly fsType?: string;

  /**
   * gateway is the host address of the ScaleIO API Gateway.
   *
   * @schema ThanosRulerSpecVolumesScaleIo#gateway
   */
  readonly gateway: string;

  /**
   * protectionDomain is the name of the ScaleIO Protection Domain for the configured storage.
   *
   * @schema ThanosRulerSpecVolumesScaleIo#protectionDomain
   */
  readonly protectionDomain?: string;

  /**
   * readOnly Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force
   * @schema ThanosRulerSpecVolumesScaleIo#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef references to the secret for ScaleIO user and other
   * sensitive information. If this is not provided, Login operation will fail.
   *
   * @schema ThanosRulerSpecVolumesScaleIo#secretRef
   */
  readonly secretRef: ThanosRulerSpecVolumesScaleIoSecretRef;

  /**
   * sslEnabled Flag enable/disable SSL communication with Gateway, default false
   *
   * @schema ThanosRulerSpecVolumesScaleIo#sslEnabled
   */
  readonly sslEnabled?: boolean;

  /**
   * storageMode indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned.
   * Default is ThinProvisioned.
   *
   * @default ThinProvisioned.
   * @schema ThanosRulerSpecVolumesScaleIo#storageMode
   */
  readonly storageMode?: string;

  /**
   * storagePool is the ScaleIO Storage Pool associated with the protection domain.
   *
   * @schema ThanosRulerSpecVolumesScaleIo#storagePool
   */
  readonly storagePool?: string;

  /**
   * system is the name of the storage system as configured in ScaleIO.
   *
   * @schema ThanosRulerSpecVolumesScaleIo#system
   */
  readonly system: string;

  /**
   * volumeName is the name of a volume already created in the ScaleIO system
   * that is associated with this volume source.
   *
   * @schema ThanosRulerSpecVolumesScaleIo#volumeName
   */
  readonly volumeName?: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesScaleIo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesScaleIo(obj: ThanosRulerSpecVolumesScaleIo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'gateway': obj.gateway,
    'protectionDomain': obj.protectionDomain,
    'readOnly': obj.readOnly,
    'secretRef': toJson_ThanosRulerSpecVolumesScaleIoSecretRef(obj.secretRef),
    'sslEnabled': obj.sslEnabled,
    'storageMode': obj.storageMode,
    'storagePool': obj.storagePool,
    'system': obj.system,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * secret represents a secret that should populate this volume.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
 *
 * @schema ThanosRulerSpecVolumesSecret
 */
export interface ThanosRulerSpecVolumesSecret {
  /**
   * defaultMode is Optional: mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values
   * for mode bits. Defaults to 0644.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644.
   * @schema ThanosRulerSpecVolumesSecret#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * items If unspecified, each key-value pair in the Data field of the referenced
   * Secret will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the Secret,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   *
   * @schema ThanosRulerSpecVolumesSecret#items
   */
  readonly items?: ThanosRulerSpecVolumesSecretItems[];

  /**
   * optional field specify whether the Secret or its keys must be defined
   *
   * @schema ThanosRulerSpecVolumesSecret#optional
   */
  readonly optional?: boolean;

  /**
   * secretName is the name of the secret in the pod's namespace to use.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   *
   * @schema ThanosRulerSpecVolumesSecret#secretName
   */
  readonly secretName?: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesSecret(obj: ThanosRulerSpecVolumesSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_ThanosRulerSpecVolumesSecretItems(y)),
    'optional': obj.optional,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
 *
 * @schema ThanosRulerSpecVolumesStorageos
 */
export interface ThanosRulerSpecVolumesStorageos {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema ThanosRulerSpecVolumesStorageos#fsType
   */
  readonly fsType?: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @schema ThanosRulerSpecVolumesStorageos#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef specifies the secret to use for obtaining the StorageOS API
   * credentials.  If not specified, default values will be attempted.
   *
   * @schema ThanosRulerSpecVolumesStorageos#secretRef
   */
  readonly secretRef?: ThanosRulerSpecVolumesStorageosSecretRef;

  /**
   * volumeName is the human-readable name of the StorageOS volume.  Volume
   * names are only unique within a namespace.
   *
   * @schema ThanosRulerSpecVolumesStorageos#volumeName
   */
  readonly volumeName?: string;

  /**
   * volumeNamespace specifies the scope of the volume within StorageOS.  If no
   * namespace is specified then the Pod's namespace will be used.  This allows the
   * Kubernetes name scoping to be mirrored within StorageOS for tighter integration.
   * Set VolumeName to any name to override the default behaviour.
   * Set to "default" if you are not using namespaces within StorageOS.
   * Namespaces that do not pre-exist within StorageOS will be created.
   *
   * @schema ThanosRulerSpecVolumesStorageos#volumeNamespace
   */
  readonly volumeNamespace?: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesStorageos' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesStorageos(obj: ThanosRulerSpecVolumesStorageos | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'readOnly': obj.readOnly,
    'secretRef': toJson_ThanosRulerSpecVolumesStorageosSecretRef(obj.secretRef),
    'volumeName': obj.volumeName,
    'volumeNamespace': obj.volumeNamespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
 *
 * @schema ThanosRulerSpecVolumesVsphereVolume
 */
export interface ThanosRulerSpecVolumesVsphereVolume {
  /**
   * fsType is filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema ThanosRulerSpecVolumesVsphereVolume#fsType
   */
  readonly fsType?: string;

  /**
   * storagePolicyID is the storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.
   *
   * @schema ThanosRulerSpecVolumesVsphereVolume#storagePolicyID
   */
  readonly storagePolicyId?: string;

  /**
   * storagePolicyName is the storage Policy Based Management (SPBM) profile name.
   *
   * @schema ThanosRulerSpecVolumesVsphereVolume#storagePolicyName
   */
  readonly storagePolicyName?: string;

  /**
   * volumePath is the path that identifies vSphere volume vmdk
   *
   * @schema ThanosRulerSpecVolumesVsphereVolume#volumePath
   */
  readonly volumePath: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesVsphereVolume' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesVsphereVolume(obj: ThanosRulerSpecVolumesVsphereVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'storagePolicyID': obj.storagePolicyId,
    'storagePolicyName': obj.storagePolicyName,
    'volumePath': obj.volumePath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Defines HTTP parameters for web server.
 *
 * @schema ThanosRulerSpecWebHttpConfig
 */
export interface ThanosRulerSpecWebHttpConfig {
  /**
   * List of headers that can be added to HTTP responses.
   *
   * @schema ThanosRulerSpecWebHttpConfig#headers
   */
  readonly headers?: ThanosRulerSpecWebHttpConfigHeaders;

  /**
   * Enable HTTP/2 support. Note that HTTP/2 is only supported with TLS.
   * When TLSConfig is not configured, HTTP/2 will be disabled.
   * Whenever the value of the field changes, a rolling update will be triggered.
   *
   * @schema ThanosRulerSpecWebHttpConfig#http2
   */
  readonly http2?: boolean;

}

/**
 * Converts an object of type 'ThanosRulerSpecWebHttpConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecWebHttpConfig(obj: ThanosRulerSpecWebHttpConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'headers': toJson_ThanosRulerSpecWebHttpConfigHeaders(obj.headers),
    'http2': obj.http2,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Defines the TLS parameters for HTTPS.
 *
 * @schema ThanosRulerSpecWebTlsConfig
 */
export interface ThanosRulerSpecWebTlsConfig {
  /**
   * Contains the TLS certificate for the server.
   *
   * @schema ThanosRulerSpecWebTlsConfig#cert
   */
  readonly cert: ThanosRulerSpecWebTlsConfigCert;

  /**
   * List of supported cipher suites for TLS versions up to TLS 1.2. If empty,
   * Go default cipher suites are used. Available cipher suites are documented
   * in the go documentation: https://golang.org/pkg/crypto/tls/#pkg-constants
   *
   * @schema ThanosRulerSpecWebTlsConfig#cipherSuites
   */
  readonly cipherSuites?: string[];

  /**
   * Contains the CA certificate for client certificate authentication to the server.
   *
   * @schema ThanosRulerSpecWebTlsConfig#client_ca
   */
  readonly clientCa?: ThanosRulerSpecWebTlsConfigClientCa;

  /**
   * Server policy for client authentication. Maps to ClientAuth Policies.
   * For more detail on clientAuth options:
   * https://golang.org/pkg/crypto/tls/#ClientAuthType
   *
   * @schema ThanosRulerSpecWebTlsConfig#clientAuthType
   */
  readonly clientAuthType?: string;

  /**
   * Elliptic curves that will be used in an ECDHE handshake, in preference
   * order. Available curves are documented in the go documentation:
   * https://golang.org/pkg/crypto/tls/#CurveID
   *
   * @schema ThanosRulerSpecWebTlsConfig#curvePreferences
   */
  readonly curvePreferences?: string[];

  /**
   * Secret containing the TLS key for the server.
   *
   * @schema ThanosRulerSpecWebTlsConfig#keySecret
   */
  readonly keySecret: ThanosRulerSpecWebTlsConfigKeySecret;

  /**
   * Maximum TLS version that is acceptable. Defaults to TLS13.
   *
   * @default TLS13.
   * @schema ThanosRulerSpecWebTlsConfig#maxVersion
   */
  readonly maxVersion?: string;

  /**
   * Minimum TLS version that is acceptable. Defaults to TLS12.
   *
   * @default TLS12.
   * @schema ThanosRulerSpecWebTlsConfig#minVersion
   */
  readonly minVersion?: string;

  /**
   * Controls whether the server selects the
   * client's most preferred cipher suite, or the server's most preferred
   * cipher suite. If true then the server's preference, as expressed in
   * the order of elements in cipherSuites, is used.
   *
   * @schema ThanosRulerSpecWebTlsConfig#preferServerCipherSuites
   */
  readonly preferServerCipherSuites?: boolean;

}

/**
 * Converts an object of type 'ThanosRulerSpecWebTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecWebTlsConfig(obj: ThanosRulerSpecWebTlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cert': toJson_ThanosRulerSpecWebTlsConfigCert(obj.cert),
    'cipherSuites': obj.cipherSuites?.map(y => y),
    'client_ca': toJson_ThanosRulerSpecWebTlsConfigClientCa(obj.clientCa),
    'clientAuthType': obj.clientAuthType,
    'curvePreferences': obj.curvePreferences?.map(y => y),
    'keySecret': toJson_ThanosRulerSpecWebTlsConfigKeySecret(obj.keySecret),
    'maxVersion': obj.maxVersion,
    'minVersion': obj.minVersion,
    'preferServerCipherSuites': obj.preferServerCipherSuites,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * An empty preferred scheduling term matches all objects with implicit weight 0
 * (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
 *
 * @schema ThanosRulerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface ThanosRulerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * A node selector term, associated with the corresponding weight.
   *
   * @schema ThanosRulerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference: ThanosRulerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
   *
   * @schema ThanosRulerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;

}

/**
 * Converts an object of type 'ThanosRulerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: ThanosRulerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preference': toJson_ThanosRulerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj.preference),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * If the affinity requirements specified by this field are not met at
 * scheduling time, the pod will not be scheduled onto the node.
 * If the affinity requirements specified by this field cease to be met
 * at some point during pod execution (e.g. due to an update), the system
 * may or may not try to eventually evict the pod from its node.
 *
 * @schema ThanosRulerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface ThanosRulerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A list of node selector terms. The terms are ORed.
   *
   * @schema ThanosRulerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms: ThanosRulerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];

}

/**
 * Converts an object of type 'ThanosRulerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: ThanosRulerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeSelectorTerms': obj.nodeSelectorTerms?.map(y => toJson_ThanosRulerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm: ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm,
   * in the range 1-100.
   *
   * @schema ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;

}

/**
 * Converts an object of type 'ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podAffinityTerm': toJson_ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector
 * relative to the given namespace(s)) that this pod should be
 * co-located (affinity) or not co-located (anti-affinity) with,
 * where co-located is defined as running on a node whose value of
 * the label with key <topologyKey> matches that of any node on which
 * a pod of the set of pods is running
 *
 * @schema ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `LabelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both MatchLabelKeys and LabelSelector.
   * Also, MatchLabelKeys cannot be set when LabelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `LabelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both MismatchLabelKeys and LabelSelector.
   * Also, MismatchLabelKeys cannot be set when LabelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'mismatchLabelKeys': obj.mismatchLabelKeys?.map(y => y),
    'namespaceSelector': toJson_ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm: ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm,
   * in the range 1-100.
   *
   * @schema ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;

}

/**
 * Converts an object of type 'ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podAffinityTerm': toJson_ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector
 * relative to the given namespace(s)) that this pod should be
 * co-located (affinity) or not co-located (anti-affinity) with,
 * where co-located is defined as running on a node whose value of
 * the label with key <topologyKey> matches that of any node on which
 * a pod of the set of pods is running
 *
 * @schema ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `LabelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both MatchLabelKeys and LabelSelector.
   * Also, MatchLabelKeys cannot be set when LabelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `LabelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both MismatchLabelKeys and LabelSelector.
   * Also, MismatchLabelKeys cannot be set when LabelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'mismatchLabelKeys': obj.mismatchLabelKeys?.map(y => y),
    'namespaceSelector': toJson_ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema ThanosRulerSpecContainersEnvValueFrom
 */
export interface ThanosRulerSpecContainersEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema ThanosRulerSpecContainersEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: ThanosRulerSpecContainersEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
   * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema ThanosRulerSpecContainersEnvValueFrom#fieldRef
   */
  readonly fieldRef?: ThanosRulerSpecContainersEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema ThanosRulerSpecContainersEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: ThanosRulerSpecContainersEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema ThanosRulerSpecContainersEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: ThanosRulerSpecContainersEnvValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'ThanosRulerSpecContainersEnvValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersEnvValueFrom(obj: ThanosRulerSpecContainersEnvValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_ThanosRulerSpecContainersEnvValueFromConfigMapKeyRef(obj.configMapKeyRef),
    'fieldRef': toJson_ThanosRulerSpecContainersEnvValueFromFieldRef(obj.fieldRef),
    'resourceFieldRef': toJson_ThanosRulerSpecContainersEnvValueFromResourceFieldRef(obj.resourceFieldRef),
    'secretKeyRef': toJson_ThanosRulerSpecContainersEnvValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema ThanosRulerSpecContainersEnvFromConfigMapRef
 */
export interface ThanosRulerSpecContainersEnvFromConfigMapRef {
  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ThanosRulerSpecContainersEnvFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema ThanosRulerSpecContainersEnvFromConfigMapRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ThanosRulerSpecContainersEnvFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersEnvFromConfigMapRef(obj: ThanosRulerSpecContainersEnvFromConfigMapRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Secret to select from
 *
 * @schema ThanosRulerSpecContainersEnvFromSecretRef
 */
export interface ThanosRulerSpecContainersEnvFromSecretRef {
  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ThanosRulerSpecContainersEnvFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema ThanosRulerSpecContainersEnvFromSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ThanosRulerSpecContainersEnvFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersEnvFromSecretRef(obj: ThanosRulerSpecContainersEnvFromSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PostStart is called immediately after a container is created. If the handler fails,
 * the container is terminated and restarted according to its restart policy.
 * Other management of the container blocks until the hook completes.
 * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema ThanosRulerSpecContainersLifecyclePostStart
 */
export interface ThanosRulerSpecContainersLifecyclePostStart {
  /**
   * Exec specifies the action to take.
   *
   * @schema ThanosRulerSpecContainersLifecyclePostStart#exec
   */
  readonly exec?: ThanosRulerSpecContainersLifecyclePostStartExec;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema ThanosRulerSpecContainersLifecyclePostStart#httpGet
   */
  readonly httpGet?: ThanosRulerSpecContainersLifecyclePostStartHttpGet;

  /**
   * Sleep represents the duration that the container should sleep before being terminated.
   *
   * @schema ThanosRulerSpecContainersLifecyclePostStart#sleep
   */
  readonly sleep?: ThanosRulerSpecContainersLifecyclePostStartSleep;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
   * for the backward compatibility. There are no validation of this field and
   * lifecycle hooks will fail in runtime when tcp handler is specified.
   *
   * @schema ThanosRulerSpecContainersLifecyclePostStart#tcpSocket
   */
  readonly tcpSocket?: ThanosRulerSpecContainersLifecyclePostStartTcpSocket;

}

/**
 * Converts an object of type 'ThanosRulerSpecContainersLifecyclePostStart' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersLifecyclePostStart(obj: ThanosRulerSpecContainersLifecyclePostStart | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_ThanosRulerSpecContainersLifecyclePostStartExec(obj.exec),
    'httpGet': toJson_ThanosRulerSpecContainersLifecyclePostStartHttpGet(obj.httpGet),
    'sleep': toJson_ThanosRulerSpecContainersLifecyclePostStartSleep(obj.sleep),
    'tcpSocket': toJson_ThanosRulerSpecContainersLifecyclePostStartTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PreStop is called immediately before a container is terminated due to an
 * API request or management event such as liveness/startup probe failure,
 * preemption, resource contention, etc. The handler is not called if the
 * container crashes or exits. The Pod's termination grace period countdown begins before the
 * PreStop hook is executed. Regardless of the outcome of the handler, the
 * container will eventually terminate within the Pod's termination grace
 * period (unless delayed by finalizers). Other management of the container blocks until the hook completes
 * or until the termination grace period is reached.
 * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema ThanosRulerSpecContainersLifecyclePreStop
 */
export interface ThanosRulerSpecContainersLifecyclePreStop {
  /**
   * Exec specifies the action to take.
   *
   * @schema ThanosRulerSpecContainersLifecyclePreStop#exec
   */
  readonly exec?: ThanosRulerSpecContainersLifecyclePreStopExec;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema ThanosRulerSpecContainersLifecyclePreStop#httpGet
   */
  readonly httpGet?: ThanosRulerSpecContainersLifecyclePreStopHttpGet;

  /**
   * Sleep represents the duration that the container should sleep before being terminated.
   *
   * @schema ThanosRulerSpecContainersLifecyclePreStop#sleep
   */
  readonly sleep?: ThanosRulerSpecContainersLifecyclePreStopSleep;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
   * for the backward compatibility. There are no validation of this field and
   * lifecycle hooks will fail in runtime when tcp handler is specified.
   *
   * @schema ThanosRulerSpecContainersLifecyclePreStop#tcpSocket
   */
  readonly tcpSocket?: ThanosRulerSpecContainersLifecyclePreStopTcpSocket;

}

/**
 * Converts an object of type 'ThanosRulerSpecContainersLifecyclePreStop' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersLifecyclePreStop(obj: ThanosRulerSpecContainersLifecyclePreStop | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_ThanosRulerSpecContainersLifecyclePreStopExec(obj.exec),
    'httpGet': toJson_ThanosRulerSpecContainersLifecyclePreStopHttpGet(obj.httpGet),
    'sleep': toJson_ThanosRulerSpecContainersLifecyclePreStopSleep(obj.sleep),
    'tcpSocket': toJson_ThanosRulerSpecContainersLifecyclePreStopTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema ThanosRulerSpecContainersLivenessProbeExec
 */
export interface ThanosRulerSpecContainersLivenessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema ThanosRulerSpecContainersLivenessProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'ThanosRulerSpecContainersLivenessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersLivenessProbeExec(obj: ThanosRulerSpecContainersLivenessProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port.
 *
 * @schema ThanosRulerSpecContainersLivenessProbeGrpc
 */
export interface ThanosRulerSpecContainersLivenessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema ThanosRulerSpecContainersLivenessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest
   * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   *
   *
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema ThanosRulerSpecContainersLivenessProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecContainersLivenessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersLivenessProbeGrpc(obj: ThanosRulerSpecContainersLivenessProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema ThanosRulerSpecContainersLivenessProbeHttpGet
 */
export interface ThanosRulerSpecContainersLivenessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema ThanosRulerSpecContainersLivenessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema ThanosRulerSpecContainersLivenessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: ThanosRulerSpecContainersLivenessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema ThanosRulerSpecContainersLivenessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema ThanosRulerSpecContainersLivenessProbeHttpGet#port
   */
  readonly port: ThanosRulerSpecContainersLivenessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema ThanosRulerSpecContainersLivenessProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecContainersLivenessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersLivenessProbeHttpGet(obj: ThanosRulerSpecContainersLivenessProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_ThanosRulerSpecContainersLivenessProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema ThanosRulerSpecContainersLivenessProbeTcpSocket
 */
export interface ThanosRulerSpecContainersLivenessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema ThanosRulerSpecContainersLivenessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema ThanosRulerSpecContainersLivenessProbeTcpSocket#port
   */
  readonly port: ThanosRulerSpecContainersLivenessProbeTcpSocketPort;

}

/**
 * Converts an object of type 'ThanosRulerSpecContainersLivenessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersLivenessProbeTcpSocket(obj: ThanosRulerSpecContainersLivenessProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema ThanosRulerSpecContainersReadinessProbeExec
 */
export interface ThanosRulerSpecContainersReadinessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema ThanosRulerSpecContainersReadinessProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'ThanosRulerSpecContainersReadinessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersReadinessProbeExec(obj: ThanosRulerSpecContainersReadinessProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port.
 *
 * @schema ThanosRulerSpecContainersReadinessProbeGrpc
 */
export interface ThanosRulerSpecContainersReadinessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema ThanosRulerSpecContainersReadinessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest
   * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   *
   *
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema ThanosRulerSpecContainersReadinessProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecContainersReadinessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersReadinessProbeGrpc(obj: ThanosRulerSpecContainersReadinessProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema ThanosRulerSpecContainersReadinessProbeHttpGet
 */
export interface ThanosRulerSpecContainersReadinessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema ThanosRulerSpecContainersReadinessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema ThanosRulerSpecContainersReadinessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: ThanosRulerSpecContainersReadinessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema ThanosRulerSpecContainersReadinessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema ThanosRulerSpecContainersReadinessProbeHttpGet#port
   */
  readonly port: ThanosRulerSpecContainersReadinessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema ThanosRulerSpecContainersReadinessProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecContainersReadinessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersReadinessProbeHttpGet(obj: ThanosRulerSpecContainersReadinessProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_ThanosRulerSpecContainersReadinessProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema ThanosRulerSpecContainersReadinessProbeTcpSocket
 */
export interface ThanosRulerSpecContainersReadinessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema ThanosRulerSpecContainersReadinessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema ThanosRulerSpecContainersReadinessProbeTcpSocket#port
   */
  readonly port: ThanosRulerSpecContainersReadinessProbeTcpSocketPort;

}

/**
 * Converts an object of type 'ThanosRulerSpecContainersReadinessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersReadinessProbeTcpSocket(obj: ThanosRulerSpecContainersReadinessProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema ThanosRulerSpecContainersResourcesClaims
 */
export interface ThanosRulerSpecContainersResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema ThanosRulerSpecContainersResourcesClaims#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecContainersResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersResourcesClaims(obj: ThanosRulerSpecContainersResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ThanosRulerSpecContainersResourcesLimits
 */
export class ThanosRulerSpecContainersResourcesLimits {
  public static fromNumber(value: number): ThanosRulerSpecContainersResourcesLimits {
    return new ThanosRulerSpecContainersResourcesLimits(value);
  }
  public static fromString(value: string): ThanosRulerSpecContainersResourcesLimits {
    return new ThanosRulerSpecContainersResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema ThanosRulerSpecContainersResourcesRequests
 */
export class ThanosRulerSpecContainersResourcesRequests {
  public static fromNumber(value: number): ThanosRulerSpecContainersResourcesRequests {
    return new ThanosRulerSpecContainersResourcesRequests(value);
  }
  public static fromString(value: string): ThanosRulerSpecContainersResourcesRequests {
    return new ThanosRulerSpecContainersResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * The capabilities to add/drop when running containers.
 * Defaults to the default set of capabilities granted by the container runtime.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @default the default set of capabilities granted by the container runtime.
 * @schema ThanosRulerSpecContainersSecurityContextCapabilities
 */
export interface ThanosRulerSpecContainersSecurityContextCapabilities {
  /**
   * Added capabilities
   *
   * @schema ThanosRulerSpecContainersSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * Removed capabilities
   *
   * @schema ThanosRulerSpecContainersSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * Converts an object of type 'ThanosRulerSpecContainersSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersSecurityContextCapabilities(obj: ThanosRulerSpecContainersSecurityContextCapabilities | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': obj.add?.map(y => y),
    'drop': obj.drop?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The SELinux context to be applied to the container.
 * If unspecified, the container runtime will allocate a random SELinux context for each
 * container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
 * PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema ThanosRulerSpecContainersSecurityContextSeLinuxOptions
 */
export interface ThanosRulerSpecContainersSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema ThanosRulerSpecContainersSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema ThanosRulerSpecContainersSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema ThanosRulerSpecContainersSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema ThanosRulerSpecContainersSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecContainersSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersSecurityContextSeLinuxOptions(obj: ThanosRulerSpecContainersSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The seccomp options to use by this container. If seccomp options are
 * provided at both the pod & container level, the container options
 * override the pod options.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema ThanosRulerSpecContainersSecurityContextSeccompProfile
 */
export interface ThanosRulerSpecContainersSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used.
   * The profile must be preconfigured on the node to work.
   * Must be a descending path, relative to the kubelet's configured seccomp profile location.
   * Must be set if type is "Localhost". Must NOT be set for any other type.
   *
   * @schema ThanosRulerSpecContainersSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied.
   * Valid options are:
   *
   *
   * Localhost - a profile defined in a file on the node should be used.
   * RuntimeDefault - the container runtime default profile should be used.
   * Unconfined - no profile should be applied.
   *
   * @schema ThanosRulerSpecContainersSecurityContextSeccompProfile#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecContainersSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersSecurityContextSeccompProfile(obj: ThanosRulerSpecContainersSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Windows specific settings applied to all containers.
 * If unspecified, the options from the PodSecurityContext will be used.
 * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema ThanosRulerSpecContainersSecurityContextWindowsOptions
 */
export interface ThanosRulerSpecContainersSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook
   * (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
   * GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema ThanosRulerSpecContainersSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema ThanosRulerSpecContainersSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container.
   * All of a Pod's containers must have the same effective HostProcess value
   * (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
   * In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema ThanosRulerSpecContainersSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process.
   * Defaults to the user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext. If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified.
   * @schema ThanosRulerSpecContainersSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecContainersSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersSecurityContextWindowsOptions(obj: ThanosRulerSpecContainersSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema ThanosRulerSpecContainersStartupProbeExec
 */
export interface ThanosRulerSpecContainersStartupProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema ThanosRulerSpecContainersStartupProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'ThanosRulerSpecContainersStartupProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersStartupProbeExec(obj: ThanosRulerSpecContainersStartupProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port.
 *
 * @schema ThanosRulerSpecContainersStartupProbeGrpc
 */
export interface ThanosRulerSpecContainersStartupProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema ThanosRulerSpecContainersStartupProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest
   * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   *
   *
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema ThanosRulerSpecContainersStartupProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecContainersStartupProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersStartupProbeGrpc(obj: ThanosRulerSpecContainersStartupProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema ThanosRulerSpecContainersStartupProbeHttpGet
 */
export interface ThanosRulerSpecContainersStartupProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema ThanosRulerSpecContainersStartupProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema ThanosRulerSpecContainersStartupProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: ThanosRulerSpecContainersStartupProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema ThanosRulerSpecContainersStartupProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema ThanosRulerSpecContainersStartupProbeHttpGet#port
   */
  readonly port: ThanosRulerSpecContainersStartupProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema ThanosRulerSpecContainersStartupProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecContainersStartupProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersStartupProbeHttpGet(obj: ThanosRulerSpecContainersStartupProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_ThanosRulerSpecContainersStartupProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema ThanosRulerSpecContainersStartupProbeTcpSocket
 */
export interface ThanosRulerSpecContainersStartupProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema ThanosRulerSpecContainersStartupProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema ThanosRulerSpecContainersStartupProbeTcpSocket#port
   */
  readonly port: ThanosRulerSpecContainersStartupProbeTcpSocketPort;

}

/**
 * Converts an object of type 'ThanosRulerSpecContainersStartupProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersStartupProbeTcpSocket(obj: ThanosRulerSpecContainersStartupProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema ThanosRulerSpecGrpcServerTlsConfigCaConfigMap
 */
export interface ThanosRulerSpecGrpcServerTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema ThanosRulerSpecGrpcServerTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ThanosRulerSpecGrpcServerTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema ThanosRulerSpecGrpcServerTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ThanosRulerSpecGrpcServerTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecGrpcServerTlsConfigCaConfigMap(obj: ThanosRulerSpecGrpcServerTlsConfigCaConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema ThanosRulerSpecGrpcServerTlsConfigCaSecret
 */
export interface ThanosRulerSpecGrpcServerTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ThanosRulerSpecGrpcServerTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ThanosRulerSpecGrpcServerTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ThanosRulerSpecGrpcServerTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ThanosRulerSpecGrpcServerTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecGrpcServerTlsConfigCaSecret(obj: ThanosRulerSpecGrpcServerTlsConfigCaSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema ThanosRulerSpecGrpcServerTlsConfigCertConfigMap
 */
export interface ThanosRulerSpecGrpcServerTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema ThanosRulerSpecGrpcServerTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ThanosRulerSpecGrpcServerTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema ThanosRulerSpecGrpcServerTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ThanosRulerSpecGrpcServerTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecGrpcServerTlsConfigCertConfigMap(obj: ThanosRulerSpecGrpcServerTlsConfigCertConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema ThanosRulerSpecGrpcServerTlsConfigCertSecret
 */
export interface ThanosRulerSpecGrpcServerTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ThanosRulerSpecGrpcServerTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ThanosRulerSpecGrpcServerTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ThanosRulerSpecGrpcServerTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ThanosRulerSpecGrpcServerTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecGrpcServerTlsConfigCertSecret(obj: ThanosRulerSpecGrpcServerTlsConfigCertSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema ThanosRulerSpecInitContainersEnvValueFrom
 */
export interface ThanosRulerSpecInitContainersEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema ThanosRulerSpecInitContainersEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: ThanosRulerSpecInitContainersEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
   * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema ThanosRulerSpecInitContainersEnvValueFrom#fieldRef
   */
  readonly fieldRef?: ThanosRulerSpecInitContainersEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema ThanosRulerSpecInitContainersEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: ThanosRulerSpecInitContainersEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema ThanosRulerSpecInitContainersEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: ThanosRulerSpecInitContainersEnvValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersEnvValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersEnvValueFrom(obj: ThanosRulerSpecInitContainersEnvValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_ThanosRulerSpecInitContainersEnvValueFromConfigMapKeyRef(obj.configMapKeyRef),
    'fieldRef': toJson_ThanosRulerSpecInitContainersEnvValueFromFieldRef(obj.fieldRef),
    'resourceFieldRef': toJson_ThanosRulerSpecInitContainersEnvValueFromResourceFieldRef(obj.resourceFieldRef),
    'secretKeyRef': toJson_ThanosRulerSpecInitContainersEnvValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema ThanosRulerSpecInitContainersEnvFromConfigMapRef
 */
export interface ThanosRulerSpecInitContainersEnvFromConfigMapRef {
  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ThanosRulerSpecInitContainersEnvFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema ThanosRulerSpecInitContainersEnvFromConfigMapRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersEnvFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersEnvFromConfigMapRef(obj: ThanosRulerSpecInitContainersEnvFromConfigMapRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Secret to select from
 *
 * @schema ThanosRulerSpecInitContainersEnvFromSecretRef
 */
export interface ThanosRulerSpecInitContainersEnvFromSecretRef {
  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ThanosRulerSpecInitContainersEnvFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema ThanosRulerSpecInitContainersEnvFromSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersEnvFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersEnvFromSecretRef(obj: ThanosRulerSpecInitContainersEnvFromSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PostStart is called immediately after a container is created. If the handler fails,
 * the container is terminated and restarted according to its restart policy.
 * Other management of the container blocks until the hook completes.
 * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema ThanosRulerSpecInitContainersLifecyclePostStart
 */
export interface ThanosRulerSpecInitContainersLifecyclePostStart {
  /**
   * Exec specifies the action to take.
   *
   * @schema ThanosRulerSpecInitContainersLifecyclePostStart#exec
   */
  readonly exec?: ThanosRulerSpecInitContainersLifecyclePostStartExec;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema ThanosRulerSpecInitContainersLifecyclePostStart#httpGet
   */
  readonly httpGet?: ThanosRulerSpecInitContainersLifecyclePostStartHttpGet;

  /**
   * Sleep represents the duration that the container should sleep before being terminated.
   *
   * @schema ThanosRulerSpecInitContainersLifecyclePostStart#sleep
   */
  readonly sleep?: ThanosRulerSpecInitContainersLifecyclePostStartSleep;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
   * for the backward compatibility. There are no validation of this field and
   * lifecycle hooks will fail in runtime when tcp handler is specified.
   *
   * @schema ThanosRulerSpecInitContainersLifecyclePostStart#tcpSocket
   */
  readonly tcpSocket?: ThanosRulerSpecInitContainersLifecyclePostStartTcpSocket;

}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersLifecyclePostStart' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersLifecyclePostStart(obj: ThanosRulerSpecInitContainersLifecyclePostStart | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_ThanosRulerSpecInitContainersLifecyclePostStartExec(obj.exec),
    'httpGet': toJson_ThanosRulerSpecInitContainersLifecyclePostStartHttpGet(obj.httpGet),
    'sleep': toJson_ThanosRulerSpecInitContainersLifecyclePostStartSleep(obj.sleep),
    'tcpSocket': toJson_ThanosRulerSpecInitContainersLifecyclePostStartTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PreStop is called immediately before a container is terminated due to an
 * API request or management event such as liveness/startup probe failure,
 * preemption, resource contention, etc. The handler is not called if the
 * container crashes or exits. The Pod's termination grace period countdown begins before the
 * PreStop hook is executed. Regardless of the outcome of the handler, the
 * container will eventually terminate within the Pod's termination grace
 * period (unless delayed by finalizers). Other management of the container blocks until the hook completes
 * or until the termination grace period is reached.
 * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema ThanosRulerSpecInitContainersLifecyclePreStop
 */
export interface ThanosRulerSpecInitContainersLifecyclePreStop {
  /**
   * Exec specifies the action to take.
   *
   * @schema ThanosRulerSpecInitContainersLifecyclePreStop#exec
   */
  readonly exec?: ThanosRulerSpecInitContainersLifecyclePreStopExec;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema ThanosRulerSpecInitContainersLifecyclePreStop#httpGet
   */
  readonly httpGet?: ThanosRulerSpecInitContainersLifecyclePreStopHttpGet;

  /**
   * Sleep represents the duration that the container should sleep before being terminated.
   *
   * @schema ThanosRulerSpecInitContainersLifecyclePreStop#sleep
   */
  readonly sleep?: ThanosRulerSpecInitContainersLifecyclePreStopSleep;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
   * for the backward compatibility. There are no validation of this field and
   * lifecycle hooks will fail in runtime when tcp handler is specified.
   *
   * @schema ThanosRulerSpecInitContainersLifecyclePreStop#tcpSocket
   */
  readonly tcpSocket?: ThanosRulerSpecInitContainersLifecyclePreStopTcpSocket;

}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersLifecyclePreStop' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersLifecyclePreStop(obj: ThanosRulerSpecInitContainersLifecyclePreStop | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_ThanosRulerSpecInitContainersLifecyclePreStopExec(obj.exec),
    'httpGet': toJson_ThanosRulerSpecInitContainersLifecyclePreStopHttpGet(obj.httpGet),
    'sleep': toJson_ThanosRulerSpecInitContainersLifecyclePreStopSleep(obj.sleep),
    'tcpSocket': toJson_ThanosRulerSpecInitContainersLifecyclePreStopTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema ThanosRulerSpecInitContainersLivenessProbeExec
 */
export interface ThanosRulerSpecInitContainersLivenessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema ThanosRulerSpecInitContainersLivenessProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersLivenessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersLivenessProbeExec(obj: ThanosRulerSpecInitContainersLivenessProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port.
 *
 * @schema ThanosRulerSpecInitContainersLivenessProbeGrpc
 */
export interface ThanosRulerSpecInitContainersLivenessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema ThanosRulerSpecInitContainersLivenessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest
   * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   *
   *
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema ThanosRulerSpecInitContainersLivenessProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersLivenessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersLivenessProbeGrpc(obj: ThanosRulerSpecInitContainersLivenessProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema ThanosRulerSpecInitContainersLivenessProbeHttpGet
 */
export interface ThanosRulerSpecInitContainersLivenessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema ThanosRulerSpecInitContainersLivenessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema ThanosRulerSpecInitContainersLivenessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: ThanosRulerSpecInitContainersLivenessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema ThanosRulerSpecInitContainersLivenessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema ThanosRulerSpecInitContainersLivenessProbeHttpGet#port
   */
  readonly port: ThanosRulerSpecInitContainersLivenessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema ThanosRulerSpecInitContainersLivenessProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersLivenessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersLivenessProbeHttpGet(obj: ThanosRulerSpecInitContainersLivenessProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_ThanosRulerSpecInitContainersLivenessProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema ThanosRulerSpecInitContainersLivenessProbeTcpSocket
 */
export interface ThanosRulerSpecInitContainersLivenessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema ThanosRulerSpecInitContainersLivenessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema ThanosRulerSpecInitContainersLivenessProbeTcpSocket#port
   */
  readonly port: ThanosRulerSpecInitContainersLivenessProbeTcpSocketPort;

}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersLivenessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersLivenessProbeTcpSocket(obj: ThanosRulerSpecInitContainersLivenessProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema ThanosRulerSpecInitContainersReadinessProbeExec
 */
export interface ThanosRulerSpecInitContainersReadinessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema ThanosRulerSpecInitContainersReadinessProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersReadinessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersReadinessProbeExec(obj: ThanosRulerSpecInitContainersReadinessProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port.
 *
 * @schema ThanosRulerSpecInitContainersReadinessProbeGrpc
 */
export interface ThanosRulerSpecInitContainersReadinessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema ThanosRulerSpecInitContainersReadinessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest
   * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   *
   *
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema ThanosRulerSpecInitContainersReadinessProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersReadinessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersReadinessProbeGrpc(obj: ThanosRulerSpecInitContainersReadinessProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema ThanosRulerSpecInitContainersReadinessProbeHttpGet
 */
export interface ThanosRulerSpecInitContainersReadinessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema ThanosRulerSpecInitContainersReadinessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema ThanosRulerSpecInitContainersReadinessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: ThanosRulerSpecInitContainersReadinessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema ThanosRulerSpecInitContainersReadinessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema ThanosRulerSpecInitContainersReadinessProbeHttpGet#port
   */
  readonly port: ThanosRulerSpecInitContainersReadinessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema ThanosRulerSpecInitContainersReadinessProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersReadinessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersReadinessProbeHttpGet(obj: ThanosRulerSpecInitContainersReadinessProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_ThanosRulerSpecInitContainersReadinessProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema ThanosRulerSpecInitContainersReadinessProbeTcpSocket
 */
export interface ThanosRulerSpecInitContainersReadinessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema ThanosRulerSpecInitContainersReadinessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema ThanosRulerSpecInitContainersReadinessProbeTcpSocket#port
   */
  readonly port: ThanosRulerSpecInitContainersReadinessProbeTcpSocketPort;

}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersReadinessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersReadinessProbeTcpSocket(obj: ThanosRulerSpecInitContainersReadinessProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema ThanosRulerSpecInitContainersResourcesClaims
 */
export interface ThanosRulerSpecInitContainersResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema ThanosRulerSpecInitContainersResourcesClaims#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersResourcesClaims(obj: ThanosRulerSpecInitContainersResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ThanosRulerSpecInitContainersResourcesLimits
 */
export class ThanosRulerSpecInitContainersResourcesLimits {
  public static fromNumber(value: number): ThanosRulerSpecInitContainersResourcesLimits {
    return new ThanosRulerSpecInitContainersResourcesLimits(value);
  }
  public static fromString(value: string): ThanosRulerSpecInitContainersResourcesLimits {
    return new ThanosRulerSpecInitContainersResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema ThanosRulerSpecInitContainersResourcesRequests
 */
export class ThanosRulerSpecInitContainersResourcesRequests {
  public static fromNumber(value: number): ThanosRulerSpecInitContainersResourcesRequests {
    return new ThanosRulerSpecInitContainersResourcesRequests(value);
  }
  public static fromString(value: string): ThanosRulerSpecInitContainersResourcesRequests {
    return new ThanosRulerSpecInitContainersResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * The capabilities to add/drop when running containers.
 * Defaults to the default set of capabilities granted by the container runtime.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @default the default set of capabilities granted by the container runtime.
 * @schema ThanosRulerSpecInitContainersSecurityContextCapabilities
 */
export interface ThanosRulerSpecInitContainersSecurityContextCapabilities {
  /**
   * Added capabilities
   *
   * @schema ThanosRulerSpecInitContainersSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * Removed capabilities
   *
   * @schema ThanosRulerSpecInitContainersSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersSecurityContextCapabilities(obj: ThanosRulerSpecInitContainersSecurityContextCapabilities | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': obj.add?.map(y => y),
    'drop': obj.drop?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The SELinux context to be applied to the container.
 * If unspecified, the container runtime will allocate a random SELinux context for each
 * container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
 * PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema ThanosRulerSpecInitContainersSecurityContextSeLinuxOptions
 */
export interface ThanosRulerSpecInitContainersSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema ThanosRulerSpecInitContainersSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema ThanosRulerSpecInitContainersSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema ThanosRulerSpecInitContainersSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema ThanosRulerSpecInitContainersSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersSecurityContextSeLinuxOptions(obj: ThanosRulerSpecInitContainersSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The seccomp options to use by this container. If seccomp options are
 * provided at both the pod & container level, the container options
 * override the pod options.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema ThanosRulerSpecInitContainersSecurityContextSeccompProfile
 */
export interface ThanosRulerSpecInitContainersSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used.
   * The profile must be preconfigured on the node to work.
   * Must be a descending path, relative to the kubelet's configured seccomp profile location.
   * Must be set if type is "Localhost". Must NOT be set for any other type.
   *
   * @schema ThanosRulerSpecInitContainersSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied.
   * Valid options are:
   *
   *
   * Localhost - a profile defined in a file on the node should be used.
   * RuntimeDefault - the container runtime default profile should be used.
   * Unconfined - no profile should be applied.
   *
   * @schema ThanosRulerSpecInitContainersSecurityContextSeccompProfile#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersSecurityContextSeccompProfile(obj: ThanosRulerSpecInitContainersSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Windows specific settings applied to all containers.
 * If unspecified, the options from the PodSecurityContext will be used.
 * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema ThanosRulerSpecInitContainersSecurityContextWindowsOptions
 */
export interface ThanosRulerSpecInitContainersSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook
   * (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
   * GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema ThanosRulerSpecInitContainersSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema ThanosRulerSpecInitContainersSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container.
   * All of a Pod's containers must have the same effective HostProcess value
   * (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
   * In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema ThanosRulerSpecInitContainersSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process.
   * Defaults to the user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext. If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified.
   * @schema ThanosRulerSpecInitContainersSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersSecurityContextWindowsOptions(obj: ThanosRulerSpecInitContainersSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema ThanosRulerSpecInitContainersStartupProbeExec
 */
export interface ThanosRulerSpecInitContainersStartupProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema ThanosRulerSpecInitContainersStartupProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersStartupProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersStartupProbeExec(obj: ThanosRulerSpecInitContainersStartupProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port.
 *
 * @schema ThanosRulerSpecInitContainersStartupProbeGrpc
 */
export interface ThanosRulerSpecInitContainersStartupProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema ThanosRulerSpecInitContainersStartupProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest
   * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   *
   *
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema ThanosRulerSpecInitContainersStartupProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersStartupProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersStartupProbeGrpc(obj: ThanosRulerSpecInitContainersStartupProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema ThanosRulerSpecInitContainersStartupProbeHttpGet
 */
export interface ThanosRulerSpecInitContainersStartupProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema ThanosRulerSpecInitContainersStartupProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema ThanosRulerSpecInitContainersStartupProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: ThanosRulerSpecInitContainersStartupProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema ThanosRulerSpecInitContainersStartupProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema ThanosRulerSpecInitContainersStartupProbeHttpGet#port
   */
  readonly port: ThanosRulerSpecInitContainersStartupProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema ThanosRulerSpecInitContainersStartupProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersStartupProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersStartupProbeHttpGet(obj: ThanosRulerSpecInitContainersStartupProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_ThanosRulerSpecInitContainersStartupProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema ThanosRulerSpecInitContainersStartupProbeTcpSocket
 */
export interface ThanosRulerSpecInitContainersStartupProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema ThanosRulerSpecInitContainersStartupProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema ThanosRulerSpecInitContainersStartupProbeTcpSocket#port
   */
  readonly port: ThanosRulerSpecInitContainersStartupProbeTcpSocketPort;

}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersStartupProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersStartupProbeTcpSocket(obj: ThanosRulerSpecInitContainersStartupProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * sizeLimit is the total amount of local storage required for this EmptyDir volume.
 * The size limit is also applicable for memory medium.
 * The maximum usage on memory medium EmptyDir would be the minimum value between
 * the SizeLimit specified here and the sum of memory limits of all containers in a pod.
 * The default is nil which means that the limit is undefined.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
 *
 * @schema ThanosRulerSpecStorageEmptyDirSizeLimit
 */
export class ThanosRulerSpecStorageEmptyDirSizeLimit {
  public static fromNumber(value: number): ThanosRulerSpecStorageEmptyDirSizeLimit {
    return new ThanosRulerSpecStorageEmptyDirSizeLimit(value);
  }
  public static fromString(value: string): ThanosRulerSpecStorageEmptyDirSizeLimit {
    return new ThanosRulerSpecStorageEmptyDirSizeLimit(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Will be used to create a stand-alone PVC to provision the volume.
 * The pod in which this EphemeralVolumeSource is embedded will be the
 * owner of the PVC, i.e. the PVC will be deleted together with the
 * pod.  The name of the PVC will be `<pod name>-<volume name>` where
 * `<volume name>` is the name from the `PodSpec.Volumes` array
 * entry. Pod validation will reject the pod if the concatenated name
 * is not valid for a PVC (for example, too long).
 *
 *
 * An existing PVC with that name that is not owned by the pod
 * will *not* be used for the pod to avoid using an unrelated
 * volume by mistake. Starting the pod is then blocked until
 * the unrelated PVC is removed. If such a pre-created PVC is
 * meant to be used by the pod, the PVC has to updated with an
 * owner reference to the pod once the pod exists. Normally
 * this should not be necessary, but it may be useful when
 * manually reconstructing a broken cluster.
 *
 *
 * This field is read-only and no changes will be made by Kubernetes
 * to the PVC after it has been created.
 *
 *
 * Required, must not be nil.
 *
 * @schema ThanosRulerSpecStorageEphemeralVolumeClaimTemplate
 */
export interface ThanosRulerSpecStorageEphemeralVolumeClaimTemplate {
  /**
   * May contain labels and annotations that will be copied into the PVC
   * when creating it. No other fields are allowed and will be rejected during
   * validation.
   *
   * @schema ThanosRulerSpecStorageEphemeralVolumeClaimTemplate#metadata
   */
  readonly metadata?: any;

  /**
   * The specification for the PersistentVolumeClaim. The entire content is
   * copied unchanged into the PVC that gets created from this
   * template. The same fields as in a PersistentVolumeClaim
   * are also valid here.
   *
   * @schema ThanosRulerSpecStorageEphemeralVolumeClaimTemplate#spec
   */
  readonly spec: ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpec;

}

/**
 * Converts an object of type 'ThanosRulerSpecStorageEphemeralVolumeClaimTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecStorageEphemeralVolumeClaimTemplate(obj: ThanosRulerSpecStorageEphemeralVolumeClaimTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EmbeddedMetadata contains metadata relevant to an EmbeddedResource.
 *
 * @schema ThanosRulerSpecStorageVolumeClaimTemplateMetadata
 */
export interface ThanosRulerSpecStorageVolumeClaimTemplateMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be
   * set by external tools to store and retrieve arbitrary metadata. They are not
   * queryable and should be preserved when modifying objects.
   * More info: http://kubernetes.io/docs/user-guide/annotations
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Map of string keys and values that can be used to organize and categorize
   * (scope and select) objects. May match selectors of replication controllers
   * and services.
   * More info: http://kubernetes.io/docs/user-guide/labels
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Name must be unique within a namespace. Is required when creating resources, although
   * some resources may allow a client to request the generation of an appropriate name
   * automatically. Name is primarily intended for creation idempotence and configuration
   * definition.
   * Cannot be updated.
   * More info: http://kubernetes.io/docs/user-guide/identifiers#names
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateMetadata#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecStorageVolumeClaimTemplateMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecStorageVolumeClaimTemplateMetadata(obj: ThanosRulerSpecStorageVolumeClaimTemplateMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Defines the desired characteristics of a volume requested by a pod author.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
 *
 * @schema ThanosRulerSpecStorageVolumeClaimTemplateSpec
 */
export interface ThanosRulerSpecStorageVolumeClaimTemplateSpec {
  /**
   * accessModes contains the desired access modes the volume should have.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateSpec#accessModes
   */
  readonly accessModes?: string[];

  /**
   * dataSource field can be used to specify either:
   * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
   * * An existing PVC (PersistentVolumeClaim)
   * If the provisioner or an external controller can support the specified data source,
   * it will create a new volume based on the contents of the specified data source.
   * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
   * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
   * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateSpec#dataSource
   */
  readonly dataSource?: ThanosRulerSpecStorageVolumeClaimTemplateSpecDataSource;

  /**
   * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
   * volume is desired. This may be any object from a non-empty API group (non
   * core object) or a PersistentVolumeClaim object.
   * When this field is specified, volume binding will only succeed if the type of
   * the specified object matches some installed volume populator or dynamic
   * provisioner.
   * This field will replace the functionality of the dataSource field and as such
   * if both fields are non-empty, they must have the same value. For backwards
   * compatibility, when namespace isn't specified in dataSourceRef,
   * both fields (dataSource and dataSourceRef) will be set to the same
   * value automatically if one of them is empty and the other is non-empty.
   * When namespace is specified in dataSourceRef,
   * dataSource isn't set to the same value and must be empty.
   * There are three important differences between dataSource and dataSourceRef:
   * * While dataSource only allows two specific types of objects, dataSourceRef
   * allows any non-core object, as well as PersistentVolumeClaim objects.
   * * While dataSource ignores disallowed values (dropping them), dataSourceRef
   * preserves all values, and generates an error if a disallowed value is
   * specified.
   * * While dataSource only allows local objects, dataSourceRef allows objects
   * in any namespaces.
   * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
   * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateSpec#dataSourceRef
   */
  readonly dataSourceRef?: ThanosRulerSpecStorageVolumeClaimTemplateSpecDataSourceRef;

  /**
   * resources represents the minimum resources the volume should have.
   * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
   * that are lower than previous value but must still be higher than capacity recorded in the
   * status field of the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateSpec#resources
   */
  readonly resources?: ThanosRulerSpecStorageVolumeClaimTemplateSpecResources;

  /**
   * selector is a label query over volumes to consider for binding.
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateSpec#selector
   */
  readonly selector?: ThanosRulerSpecStorageVolumeClaimTemplateSpecSelector;

  /**
   * storageClassName is the name of the StorageClass required by the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateSpec#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
   * If specified, the CSI driver will create or update the volume with the attributes defined
   * in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
   * it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
   * will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
   * If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
   * will be set by the persistentvolume controller if it exists.
   * If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
   * set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
   * exists.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#volumeattributesclass
   * (Alpha) Using this field requires the VolumeAttributesClass feature gate to be enabled.
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateSpec#volumeAttributesClassName
   */
  readonly volumeAttributesClassName?: string;

  /**
   * volumeMode defines what type of volume is required by the claim.
   * Value of Filesystem is implied when not included in claim spec.
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateSpec#volumeMode
   */
  readonly volumeMode?: string;

  /**
   * volumeName is the binding reference to the PersistentVolume backing this claim.
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateSpec#volumeName
   */
  readonly volumeName?: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecStorageVolumeClaimTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecStorageVolumeClaimTemplateSpec(obj: ThanosRulerSpecStorageVolumeClaimTemplateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessModes': obj.accessModes?.map(y => y),
    'dataSource': toJson_ThanosRulerSpecStorageVolumeClaimTemplateSpecDataSource(obj.dataSource),
    'dataSourceRef': toJson_ThanosRulerSpecStorageVolumeClaimTemplateSpecDataSourceRef(obj.dataSourceRef),
    'resources': toJson_ThanosRulerSpecStorageVolumeClaimTemplateSpecResources(obj.resources),
    'selector': toJson_ThanosRulerSpecStorageVolumeClaimTemplateSpecSelector(obj.selector),
    'storageClassName': obj.storageClassName,
    'volumeAttributesClassName': obj.volumeAttributesClassName,
    'volumeMode': obj.volumeMode,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Deprecated: this field is never set.
 *
 * @schema ThanosRulerSpecStorageVolumeClaimTemplateStatus
 */
export interface ThanosRulerSpecStorageVolumeClaimTemplateStatus {
  /**
   * accessModes contains the actual access modes the volume backing the PVC has.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateStatus#accessModes
   */
  readonly accessModes?: string[];

  /**
   * allocatedResourceStatuses stores status of resource being resized for the given PVC.
   * Key names follow standard Kubernetes label syntax. Valid values are either:
   * * Un-prefixed keys:
   * - storage - the capacity of the volume.
   * * Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource"
   * Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered
   * reserved and hence may not be used.
   *
   *
   * ClaimResourceStatus can be in any of following states:
   * - ControllerResizeInProgress:
   * State set when resize controller starts resizing the volume in control-plane.
   * - ControllerResizeFailed:
   * State set when resize has failed in resize controller with a terminal error.
   * - NodeResizePending:
   * State set when resize controller has finished resizing the volume but further resizing of
   * volume is needed on the node.
   * - NodeResizeInProgress:
   * State set when kubelet starts resizing the volume.
   * - NodeResizeFailed:
   * State set when resizing has failed in kubelet with a terminal error. Transient errors don't set
   * NodeResizeFailed.
   * For example: if expanding a PVC for more capacity - this field can be one of the following states:
   * - pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeInProgress"
   * - pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeFailed"
   * - pvc.status.allocatedResourceStatus['storage'] = "NodeResizePending"
   * - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeInProgress"
   * - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeFailed"
   * When this field is not set, it means that no resize operation is in progress for the given PVC.
   *
   *
   * A controller that receives PVC update with previously unknown resourceName or ClaimResourceStatus
   * should ignore the update for the purpose it was designed. For example - a controller that
   * only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid
   * resources associated with PVC.
   *
   *
   * This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateStatus#allocatedResourceStatuses
   */
  readonly allocatedResourceStatuses?: { [key: string]: string };

  /**
   * allocatedResources tracks the resources allocated to a PVC including its capacity.
   * Key names follow standard Kubernetes label syntax. Valid values are either:
   * * Un-prefixed keys:
   * - storage - the capacity of the volume.
   * * Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource"
   * Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered
   * reserved and hence may not be used.
   *
   *
   * Capacity reported here may be larger than the actual capacity when a volume expansion operation
   * is requested.
   * For storage quota, the larger value from allocatedResources and PVC.spec.resources is used.
   * If allocatedResources is not set, PVC.spec.resources alone is used for quota calculation.
   * If a volume expansion capacity request is lowered, allocatedResources is only
   * lowered if there are no expansion operations in progress and if the actual volume capacity
   * is equal or lower than the requested capacity.
   *
   *
   * A controller that receives PVC update with previously unknown resourceName
   * should ignore the update for the purpose it was designed. For example - a controller that
   * only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid
   * resources associated with PVC.
   *
   *
   * This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateStatus#allocatedResources
   */
  readonly allocatedResources?: { [key: string]: ThanosRulerSpecStorageVolumeClaimTemplateStatusAllocatedResources };

  /**
   * capacity represents the actual resources of the underlying volume.
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateStatus#capacity
   */
  readonly capacity?: { [key: string]: ThanosRulerSpecStorageVolumeClaimTemplateStatusCapacity };

  /**
   * conditions is the current Condition of persistent volume claim. If underlying persistent volume is being
   * resized then the Condition will be set to 'ResizeStarted'.
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateStatus#conditions
   */
  readonly conditions?: ThanosRulerSpecStorageVolumeClaimTemplateStatusConditions[];

  /**
   * currentVolumeAttributesClassName is the current name of the VolumeAttributesClass the PVC is using.
   * When unset, there is no VolumeAttributeClass applied to this PersistentVolumeClaim
   * This is an alpha field and requires enabling VolumeAttributesClass feature.
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateStatus#currentVolumeAttributesClassName
   */
  readonly currentVolumeAttributesClassName?: string;

  /**
   * ModifyVolumeStatus represents the status object of ControllerModifyVolume operation.
   * When this is unset, there is no ModifyVolume operation being attempted.
   * This is an alpha field and requires enabling VolumeAttributesClass feature.
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateStatus#modifyVolumeStatus
   */
  readonly modifyVolumeStatus?: ThanosRulerSpecStorageVolumeClaimTemplateStatusModifyVolumeStatus;

  /**
   * phase represents the current phase of PersistentVolumeClaim.
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateStatus#phase
   */
  readonly phase?: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecStorageVolumeClaimTemplateStatus' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecStorageVolumeClaimTemplateStatus(obj: ThanosRulerSpecStorageVolumeClaimTemplateStatus | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessModes': obj.accessModes?.map(y => y),
    'allocatedResourceStatuses': ((obj.allocatedResourceStatuses) === undefined) ? undefined : (Object.entries(obj.allocatedResourceStatuses).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'allocatedResources': ((obj.allocatedResources) === undefined) ? undefined : (Object.entries(obj.allocatedResources).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'capacity': ((obj.capacity) === undefined) ? undefined : (Object.entries(obj.capacity).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'conditions': obj.conditions?.map(y => toJson_ThanosRulerSpecStorageVolumeClaimTemplateStatusConditions(y)),
    'currentVolumeAttributesClassName': obj.currentVolumeAttributesClassName,
    'modifyVolumeStatus': toJson_ThanosRulerSpecStorageVolumeClaimTemplateStatusModifyVolumeStatus(obj.modifyVolumeStatus),
    'phase': obj.phase,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ThanosRulerSpecTopologySpreadConstraintsLabelSelectorMatchExpressions
 */
export interface ThanosRulerSpecTopologySpreadConstraintsLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ThanosRulerSpecTopologySpreadConstraintsLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ThanosRulerSpecTopologySpreadConstraintsLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ThanosRulerSpecTopologySpreadConstraintsLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ThanosRulerSpecTopologySpreadConstraintsLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecTopologySpreadConstraintsLabelSelectorMatchExpressions(obj: ThanosRulerSpecTopologySpreadConstraintsLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty.
 * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
 *
 * @schema ThanosRulerSpecVolumesCephfsSecretRef
 */
export interface ThanosRulerSpecVolumesCephfsSecretRef {
  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ThanosRulerSpecVolumesCephfsSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesCephfsSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesCephfsSecretRef(obj: ThanosRulerSpecVolumesCephfsSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * secretRef is optional: points to a secret object containing parameters used to connect
 * to OpenStack.
 *
 * @schema ThanosRulerSpecVolumesCinderSecretRef
 */
export interface ThanosRulerSpecVolumesCinderSecretRef {
  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ThanosRulerSpecVolumesCinderSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesCinderSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesCinderSecretRef(obj: ThanosRulerSpecVolumesCinderSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema ThanosRulerSpecVolumesConfigMapItems
 */
export interface ThanosRulerSpecVolumesConfigMapItems {
  /**
   * key is the key to project.
   *
   * @schema ThanosRulerSpecVolumesConfigMapItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema ThanosRulerSpecVolumesConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to.
   * May not be an absolute path.
   * May not contain the path element '..'.
   * May not start with the string '..'.
   *
   * @schema ThanosRulerSpecVolumesConfigMapItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesConfigMapItems(obj: ThanosRulerSpecVolumesConfigMapItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * nodePublishSecretRef is a reference to the secret object containing
 * sensitive information to pass to the CSI driver to complete the CSI
 * NodePublishVolume and NodeUnpublishVolume calls.
 * This field is optional, and  may be empty if no secret is required. If the
 * secret object contains more than one secret, all secret references are passed.
 *
 * @schema ThanosRulerSpecVolumesCsiNodePublishSecretRef
 */
export interface ThanosRulerSpecVolumesCsiNodePublishSecretRef {
  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ThanosRulerSpecVolumesCsiNodePublishSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesCsiNodePublishSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesCsiNodePublishSecretRef(obj: ThanosRulerSpecVolumesCsiNodePublishSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DownwardAPIVolumeFile represents information to create the file containing the pod field
 *
 * @schema ThanosRulerSpecVolumesDownwardApiItems
 */
export interface ThanosRulerSpecVolumesDownwardApiItems {
  /**
   * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
   *
   * @schema ThanosRulerSpecVolumesDownwardApiItems#fieldRef
   */
  readonly fieldRef?: ThanosRulerSpecVolumesDownwardApiItemsFieldRef;

  /**
   * Optional: mode bits used to set permissions on this file, must be an octal value
   * between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema ThanosRulerSpecVolumesDownwardApiItems#mode
   */
  readonly mode?: number;

  /**
   * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
   *
   * @schema ThanosRulerSpecVolumesDownwardApiItems#path
   */
  readonly path: string;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
   *
   * @schema ThanosRulerSpecVolumesDownwardApiItems#resourceFieldRef
   */
  readonly resourceFieldRef?: ThanosRulerSpecVolumesDownwardApiItemsResourceFieldRef;

}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesDownwardApiItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesDownwardApiItems(obj: ThanosRulerSpecVolumesDownwardApiItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fieldRef': toJson_ThanosRulerSpecVolumesDownwardApiItemsFieldRef(obj.fieldRef),
    'mode': obj.mode,
    'path': obj.path,
    'resourceFieldRef': toJson_ThanosRulerSpecVolumesDownwardApiItemsResourceFieldRef(obj.resourceFieldRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * sizeLimit is the total amount of local storage required for this EmptyDir volume.
 * The size limit is also applicable for memory medium.
 * The maximum usage on memory medium EmptyDir would be the minimum value between
 * the SizeLimit specified here and the sum of memory limits of all containers in a pod.
 * The default is nil which means that the limit is undefined.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
 *
 * @schema ThanosRulerSpecVolumesEmptyDirSizeLimit
 */
export class ThanosRulerSpecVolumesEmptyDirSizeLimit {
  public static fromNumber(value: number): ThanosRulerSpecVolumesEmptyDirSizeLimit {
    return new ThanosRulerSpecVolumesEmptyDirSizeLimit(value);
  }
  public static fromString(value: string): ThanosRulerSpecVolumesEmptyDirSizeLimit {
    return new ThanosRulerSpecVolumesEmptyDirSizeLimit(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Will be used to create a stand-alone PVC to provision the volume.
 * The pod in which this EphemeralVolumeSource is embedded will be the
 * owner of the PVC, i.e. the PVC will be deleted together with the
 * pod.  The name of the PVC will be `<pod name>-<volume name>` where
 * `<volume name>` is the name from the `PodSpec.Volumes` array
 * entry. Pod validation will reject the pod if the concatenated name
 * is not valid for a PVC (for example, too long).
 *
 *
 * An existing PVC with that name that is not owned by the pod
 * will *not* be used for the pod to avoid using an unrelated
 * volume by mistake. Starting the pod is then blocked until
 * the unrelated PVC is removed. If such a pre-created PVC is
 * meant to be used by the pod, the PVC has to updated with an
 * owner reference to the pod once the pod exists. Normally
 * this should not be necessary, but it may be useful when
 * manually reconstructing a broken cluster.
 *
 *
 * This field is read-only and no changes will be made by Kubernetes
 * to the PVC after it has been created.
 *
 *
 * Required, must not be nil.
 *
 * @schema ThanosRulerSpecVolumesEphemeralVolumeClaimTemplate
 */
export interface ThanosRulerSpecVolumesEphemeralVolumeClaimTemplate {
  /**
   * May contain labels and annotations that will be copied into the PVC
   * when creating it. No other fields are allowed and will be rejected during
   * validation.
   *
   * @schema ThanosRulerSpecVolumesEphemeralVolumeClaimTemplate#metadata
   */
  readonly metadata?: any;

  /**
   * The specification for the PersistentVolumeClaim. The entire content is
   * copied unchanged into the PVC that gets created from this
   * template. The same fields as in a PersistentVolumeClaim
   * are also valid here.
   *
   * @schema ThanosRulerSpecVolumesEphemeralVolumeClaimTemplate#spec
   */
  readonly spec: ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpec;

}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesEphemeralVolumeClaimTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesEphemeralVolumeClaimTemplate(obj: ThanosRulerSpecVolumesEphemeralVolumeClaimTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * secretRef is Optional: secretRef is reference to the secret object containing
 * sensitive information to pass to the plugin scripts. This may be
 * empty if no secret object is specified. If the secret object
 * contains more than one secret, all secrets are passed to the plugin
 * scripts.
 *
 * @schema ThanosRulerSpecVolumesFlexVolumeSecretRef
 */
export interface ThanosRulerSpecVolumesFlexVolumeSecretRef {
  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ThanosRulerSpecVolumesFlexVolumeSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesFlexVolumeSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesFlexVolumeSecretRef(obj: ThanosRulerSpecVolumesFlexVolumeSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * secretRef is the CHAP Secret for iSCSI target and initiator authentication
 *
 * @schema ThanosRulerSpecVolumesIscsiSecretRef
 */
export interface ThanosRulerSpecVolumesIscsiSecretRef {
  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ThanosRulerSpecVolumesIscsiSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesIscsiSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesIscsiSecretRef(obj: ThanosRulerSpecVolumesIscsiSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Projection that may be projected along with other supported volume types
 *
 * @schema ThanosRulerSpecVolumesProjectedSources
 */
export interface ThanosRulerSpecVolumesProjectedSources {
  /**
   * ClusterTrustBundle allows a pod to access the `.spec.trustBundle` field
   * of ClusterTrustBundle objects in an auto-updating file.
   *
   *
   * Alpha, gated by the ClusterTrustBundleProjection feature gate.
   *
   *
   * ClusterTrustBundle objects can either be selected by name, or by the
   * combination of signer name and a label selector.
   *
   *
   * Kubelet performs aggressive normalization of the PEM contents written
   * into the pod filesystem.  Esoteric PEM features such as inter-block
   * comments and block headers are stripped.  Certificates are deduplicated.
   * The ordering of certificates within the file is arbitrary, and Kubelet
   * may change the order over time.
   *
   * @schema ThanosRulerSpecVolumesProjectedSources#clusterTrustBundle
   */
  readonly clusterTrustBundle?: ThanosRulerSpecVolumesProjectedSourcesClusterTrustBundle;

  /**
   * configMap information about the configMap data to project
   *
   * @schema ThanosRulerSpecVolumesProjectedSources#configMap
   */
  readonly configMap?: ThanosRulerSpecVolumesProjectedSourcesConfigMap;

  /**
   * downwardAPI information about the downwardAPI data to project
   *
   * @schema ThanosRulerSpecVolumesProjectedSources#downwardAPI
   */
  readonly downwardApi?: ThanosRulerSpecVolumesProjectedSourcesDownwardApi;

  /**
   * secret information about the secret data to project
   *
   * @schema ThanosRulerSpecVolumesProjectedSources#secret
   */
  readonly secret?: ThanosRulerSpecVolumesProjectedSourcesSecret;

  /**
   * serviceAccountToken is information about the serviceAccountToken data to project
   *
   * @schema ThanosRulerSpecVolumesProjectedSources#serviceAccountToken
   */
  readonly serviceAccountToken?: ThanosRulerSpecVolumesProjectedSourcesServiceAccountToken;

}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesProjectedSources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesProjectedSources(obj: ThanosRulerSpecVolumesProjectedSources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterTrustBundle': toJson_ThanosRulerSpecVolumesProjectedSourcesClusterTrustBundle(obj.clusterTrustBundle),
    'configMap': toJson_ThanosRulerSpecVolumesProjectedSourcesConfigMap(obj.configMap),
    'downwardAPI': toJson_ThanosRulerSpecVolumesProjectedSourcesDownwardApi(obj.downwardApi),
    'secret': toJson_ThanosRulerSpecVolumesProjectedSourcesSecret(obj.secret),
    'serviceAccountToken': toJson_ThanosRulerSpecVolumesProjectedSourcesServiceAccountToken(obj.serviceAccountToken),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * secretRef is name of the authentication secret for RBDUser. If provided
 * overrides keyring.
 * Default is nil.
 * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
 *
 * @default nil.
 * @schema ThanosRulerSpecVolumesRbdSecretRef
 */
export interface ThanosRulerSpecVolumesRbdSecretRef {
  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ThanosRulerSpecVolumesRbdSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesRbdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesRbdSecretRef(obj: ThanosRulerSpecVolumesRbdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * secretRef references to the secret for ScaleIO user and other
 * sensitive information. If this is not provided, Login operation will fail.
 *
 * @schema ThanosRulerSpecVolumesScaleIoSecretRef
 */
export interface ThanosRulerSpecVolumesScaleIoSecretRef {
  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ThanosRulerSpecVolumesScaleIoSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesScaleIoSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesScaleIoSecretRef(obj: ThanosRulerSpecVolumesScaleIoSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema ThanosRulerSpecVolumesSecretItems
 */
export interface ThanosRulerSpecVolumesSecretItems {
  /**
   * key is the key to project.
   *
   * @schema ThanosRulerSpecVolumesSecretItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema ThanosRulerSpecVolumesSecretItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to.
   * May not be an absolute path.
   * May not contain the path element '..'.
   * May not start with the string '..'.
   *
   * @schema ThanosRulerSpecVolumesSecretItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesSecretItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesSecretItems(obj: ThanosRulerSpecVolumesSecretItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * secretRef specifies the secret to use for obtaining the StorageOS API
 * credentials.  If not specified, default values will be attempted.
 *
 * @schema ThanosRulerSpecVolumesStorageosSecretRef
 */
export interface ThanosRulerSpecVolumesStorageosSecretRef {
  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ThanosRulerSpecVolumesStorageosSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesStorageosSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesStorageosSecretRef(obj: ThanosRulerSpecVolumesStorageosSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * List of headers that can be added to HTTP responses.
 *
 * @schema ThanosRulerSpecWebHttpConfigHeaders
 */
export interface ThanosRulerSpecWebHttpConfigHeaders {
  /**
   * Set the Content-Security-Policy header to HTTP responses.
   * Unset if blank.
   *
   * @schema ThanosRulerSpecWebHttpConfigHeaders#contentSecurityPolicy
   */
  readonly contentSecurityPolicy?: string;

  /**
   * Set the Strict-Transport-Security header to HTTP responses.
   * Unset if blank.
   * Please make sure that you use this with care as this header might force
   * browsers to load Prometheus and the other applications hosted on the same
   * domain and subdomains over HTTPS.
   * https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security
   *
   * @schema ThanosRulerSpecWebHttpConfigHeaders#strictTransportSecurity
   */
  readonly strictTransportSecurity?: string;

  /**
   * Set the X-Content-Type-Options header to HTTP responses.
   * Unset if blank. Accepted value is nosniff.
   * https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Content-Type-Options
   *
   * @schema ThanosRulerSpecWebHttpConfigHeaders#xContentTypeOptions
   */
  readonly xContentTypeOptions?: ThanosRulerSpecWebHttpConfigHeadersXContentTypeOptions;

  /**
   * Set the X-Frame-Options header to HTTP responses.
   * Unset if blank. Accepted values are deny and sameorigin.
   * https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options
   *
   * @schema ThanosRulerSpecWebHttpConfigHeaders#xFrameOptions
   */
  readonly xFrameOptions?: ThanosRulerSpecWebHttpConfigHeadersXFrameOptions;

  /**
   * Set the X-XSS-Protection header to all responses.
   * Unset if blank.
   * https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-XSS-Protection
   *
   * @schema ThanosRulerSpecWebHttpConfigHeaders#xXSSProtection
   */
  readonly xXssProtection?: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecWebHttpConfigHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecWebHttpConfigHeaders(obj: ThanosRulerSpecWebHttpConfigHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'contentSecurityPolicy': obj.contentSecurityPolicy,
    'strictTransportSecurity': obj.strictTransportSecurity,
    'xContentTypeOptions': obj.xContentTypeOptions,
    'xFrameOptions': obj.xFrameOptions,
    'xXSSProtection': obj.xXssProtection,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Contains the TLS certificate for the server.
 *
 * @schema ThanosRulerSpecWebTlsConfigCert
 */
export interface ThanosRulerSpecWebTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema ThanosRulerSpecWebTlsConfigCert#configMap
   */
  readonly configMap?: ThanosRulerSpecWebTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema ThanosRulerSpecWebTlsConfigCert#secret
   */
  readonly secret?: ThanosRulerSpecWebTlsConfigCertSecret;

}

/**
 * Converts an object of type 'ThanosRulerSpecWebTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecWebTlsConfigCert(obj: ThanosRulerSpecWebTlsConfigCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_ThanosRulerSpecWebTlsConfigCertConfigMap(obj.configMap),
    'secret': toJson_ThanosRulerSpecWebTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Contains the CA certificate for client certificate authentication to the server.
 *
 * @schema ThanosRulerSpecWebTlsConfigClientCa
 */
export interface ThanosRulerSpecWebTlsConfigClientCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema ThanosRulerSpecWebTlsConfigClientCa#configMap
   */
  readonly configMap?: ThanosRulerSpecWebTlsConfigClientCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema ThanosRulerSpecWebTlsConfigClientCa#secret
   */
  readonly secret?: ThanosRulerSpecWebTlsConfigClientCaSecret;

}

/**
 * Converts an object of type 'ThanosRulerSpecWebTlsConfigClientCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecWebTlsConfigClientCa(obj: ThanosRulerSpecWebTlsConfigClientCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_ThanosRulerSpecWebTlsConfigClientCaConfigMap(obj.configMap),
    'secret': toJson_ThanosRulerSpecWebTlsConfigClientCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the TLS key for the server.
 *
 * @schema ThanosRulerSpecWebTlsConfigKeySecret
 */
export interface ThanosRulerSpecWebTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ThanosRulerSpecWebTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ThanosRulerSpecWebTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ThanosRulerSpecWebTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ThanosRulerSpecWebTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecWebTlsConfigKeySecret(obj: ThanosRulerSpecWebTlsConfigKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector term, associated with the corresponding weight.
 *
 * @schema ThanosRulerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface ThanosRulerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema ThanosRulerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: ThanosRulerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema ThanosRulerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: ThanosRulerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];

}

/**
 * Converts an object of type 'ThanosRulerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj: ThanosRulerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ThanosRulerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_ThanosRulerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A null or empty node selector term matches no objects. The requirements of
 * them are ANDed.
 * The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
 *
 * @schema ThanosRulerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface ThanosRulerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema ThanosRulerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: ThanosRulerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema ThanosRulerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: ThanosRulerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];

}

/**
 * Converts an object of type 'ThanosRulerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(obj: ThanosRulerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ThanosRulerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_ThanosRulerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `LabelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both MatchLabelKeys and LabelSelector.
   * Also, MatchLabelKeys cannot be set when LabelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `LabelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both MismatchLabelKeys and LabelSelector.
   * Also, MismatchLabelKeys cannot be set when LabelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'mismatchLabelKeys': obj.mismatchLabelKeys?.map(y => y),
    'namespaceSelector': toJson_ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `LabelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both MatchLabelKeys and LabelSelector.
   * Also, MatchLabelKeys cannot be set when LabelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `LabelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both MismatchLabelKeys and LabelSelector.
   * Also, MismatchLabelKeys cannot be set when LabelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'mismatchLabelKeys': obj.mismatchLabelKeys?.map(y => y),
    'namespaceSelector': toJson_ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a ConfigMap.
 *
 * @schema ThanosRulerSpecContainersEnvValueFromConfigMapKeyRef
 */
export interface ThanosRulerSpecContainersEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema ThanosRulerSpecContainersEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ThanosRulerSpecContainersEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema ThanosRulerSpecContainersEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ThanosRulerSpecContainersEnvValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersEnvValueFromConfigMapKeyRef(obj: ThanosRulerSpecContainersEnvValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
 * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema ThanosRulerSpecContainersEnvValueFromFieldRef
 */
export interface ThanosRulerSpecContainersEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema ThanosRulerSpecContainersEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema ThanosRulerSpecContainersEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecContainersEnvValueFromFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersEnvValueFromFieldRef(obj: ThanosRulerSpecContainersEnvValueFromFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema ThanosRulerSpecContainersEnvValueFromResourceFieldRef
 */
export interface ThanosRulerSpecContainersEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema ThanosRulerSpecContainersEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema ThanosRulerSpecContainersEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: ThanosRulerSpecContainersEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema ThanosRulerSpecContainersEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecContainersEnvValueFromResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersEnvValueFromResourceFieldRef(obj: ThanosRulerSpecContainersEnvValueFromResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema ThanosRulerSpecContainersEnvValueFromSecretKeyRef
 */
export interface ThanosRulerSpecContainersEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ThanosRulerSpecContainersEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ThanosRulerSpecContainersEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ThanosRulerSpecContainersEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ThanosRulerSpecContainersEnvValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersEnvValueFromSecretKeyRef(obj: ThanosRulerSpecContainersEnvValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema ThanosRulerSpecContainersLifecyclePostStartExec
 */
export interface ThanosRulerSpecContainersLifecyclePostStartExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema ThanosRulerSpecContainersLifecyclePostStartExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'ThanosRulerSpecContainersLifecyclePostStartExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersLifecyclePostStartExec(obj: ThanosRulerSpecContainersLifecyclePostStartExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema ThanosRulerSpecContainersLifecyclePostStartHttpGet
 */
export interface ThanosRulerSpecContainersLifecyclePostStartHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema ThanosRulerSpecContainersLifecyclePostStartHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema ThanosRulerSpecContainersLifecyclePostStartHttpGet#httpHeaders
   */
  readonly httpHeaders?: ThanosRulerSpecContainersLifecyclePostStartHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema ThanosRulerSpecContainersLifecyclePostStartHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema ThanosRulerSpecContainersLifecyclePostStartHttpGet#port
   */
  readonly port: ThanosRulerSpecContainersLifecyclePostStartHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema ThanosRulerSpecContainersLifecyclePostStartHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecContainersLifecyclePostStartHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersLifecyclePostStartHttpGet(obj: ThanosRulerSpecContainersLifecyclePostStartHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_ThanosRulerSpecContainersLifecyclePostStartHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Sleep represents the duration that the container should sleep before being terminated.
 *
 * @schema ThanosRulerSpecContainersLifecyclePostStartSleep
 */
export interface ThanosRulerSpecContainersLifecyclePostStartSleep {
  /**
   * Seconds is the number of seconds to sleep.
   *
   * @schema ThanosRulerSpecContainersLifecyclePostStartSleep#seconds
   */
  readonly seconds: number;

}

/**
 * Converts an object of type 'ThanosRulerSpecContainersLifecyclePostStartSleep' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersLifecyclePostStartSleep(obj: ThanosRulerSpecContainersLifecyclePostStartSleep | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
 * for the backward compatibility. There are no validation of this field and
 * lifecycle hooks will fail in runtime when tcp handler is specified.
 *
 * @schema ThanosRulerSpecContainersLifecyclePostStartTcpSocket
 */
export interface ThanosRulerSpecContainersLifecyclePostStartTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema ThanosRulerSpecContainersLifecyclePostStartTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema ThanosRulerSpecContainersLifecyclePostStartTcpSocket#port
   */
  readonly port: ThanosRulerSpecContainersLifecyclePostStartTcpSocketPort;

}

/**
 * Converts an object of type 'ThanosRulerSpecContainersLifecyclePostStartTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersLifecyclePostStartTcpSocket(obj: ThanosRulerSpecContainersLifecyclePostStartTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema ThanosRulerSpecContainersLifecyclePreStopExec
 */
export interface ThanosRulerSpecContainersLifecyclePreStopExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema ThanosRulerSpecContainersLifecyclePreStopExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'ThanosRulerSpecContainersLifecyclePreStopExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersLifecyclePreStopExec(obj: ThanosRulerSpecContainersLifecyclePreStopExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema ThanosRulerSpecContainersLifecyclePreStopHttpGet
 */
export interface ThanosRulerSpecContainersLifecyclePreStopHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema ThanosRulerSpecContainersLifecyclePreStopHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema ThanosRulerSpecContainersLifecyclePreStopHttpGet#httpHeaders
   */
  readonly httpHeaders?: ThanosRulerSpecContainersLifecyclePreStopHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema ThanosRulerSpecContainersLifecyclePreStopHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema ThanosRulerSpecContainersLifecyclePreStopHttpGet#port
   */
  readonly port: ThanosRulerSpecContainersLifecyclePreStopHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema ThanosRulerSpecContainersLifecyclePreStopHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecContainersLifecyclePreStopHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersLifecyclePreStopHttpGet(obj: ThanosRulerSpecContainersLifecyclePreStopHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_ThanosRulerSpecContainersLifecyclePreStopHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Sleep represents the duration that the container should sleep before being terminated.
 *
 * @schema ThanosRulerSpecContainersLifecyclePreStopSleep
 */
export interface ThanosRulerSpecContainersLifecyclePreStopSleep {
  /**
   * Seconds is the number of seconds to sleep.
   *
   * @schema ThanosRulerSpecContainersLifecyclePreStopSleep#seconds
   */
  readonly seconds: number;

}

/**
 * Converts an object of type 'ThanosRulerSpecContainersLifecyclePreStopSleep' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersLifecyclePreStopSleep(obj: ThanosRulerSpecContainersLifecyclePreStopSleep | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
 * for the backward compatibility. There are no validation of this field and
 * lifecycle hooks will fail in runtime when tcp handler is specified.
 *
 * @schema ThanosRulerSpecContainersLifecyclePreStopTcpSocket
 */
export interface ThanosRulerSpecContainersLifecyclePreStopTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema ThanosRulerSpecContainersLifecyclePreStopTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema ThanosRulerSpecContainersLifecyclePreStopTcpSocket#port
   */
  readonly port: ThanosRulerSpecContainersLifecyclePreStopTcpSocketPort;

}

/**
 * Converts an object of type 'ThanosRulerSpecContainersLifecyclePreStopTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersLifecyclePreStopTcpSocket(obj: ThanosRulerSpecContainersLifecyclePreStopTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema ThanosRulerSpecContainersLivenessProbeHttpGetHttpHeaders
 */
export interface ThanosRulerSpecContainersLivenessProbeHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema ThanosRulerSpecContainersLivenessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema ThanosRulerSpecContainersLivenessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecContainersLivenessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersLivenessProbeHttpGetHttpHeaders(obj: ThanosRulerSpecContainersLivenessProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema ThanosRulerSpecContainersLivenessProbeHttpGetPort
 */
export class ThanosRulerSpecContainersLivenessProbeHttpGetPort {
  public static fromNumber(value: number): ThanosRulerSpecContainersLivenessProbeHttpGetPort {
    return new ThanosRulerSpecContainersLivenessProbeHttpGetPort(value);
  }
  public static fromString(value: string): ThanosRulerSpecContainersLivenessProbeHttpGetPort {
    return new ThanosRulerSpecContainersLivenessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema ThanosRulerSpecContainersLivenessProbeTcpSocketPort
 */
export class ThanosRulerSpecContainersLivenessProbeTcpSocketPort {
  public static fromNumber(value: number): ThanosRulerSpecContainersLivenessProbeTcpSocketPort {
    return new ThanosRulerSpecContainersLivenessProbeTcpSocketPort(value);
  }
  public static fromString(value: string): ThanosRulerSpecContainersLivenessProbeTcpSocketPort {
    return new ThanosRulerSpecContainersLivenessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema ThanosRulerSpecContainersReadinessProbeHttpGetHttpHeaders
 */
export interface ThanosRulerSpecContainersReadinessProbeHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema ThanosRulerSpecContainersReadinessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema ThanosRulerSpecContainersReadinessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecContainersReadinessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersReadinessProbeHttpGetHttpHeaders(obj: ThanosRulerSpecContainersReadinessProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema ThanosRulerSpecContainersReadinessProbeHttpGetPort
 */
export class ThanosRulerSpecContainersReadinessProbeHttpGetPort {
  public static fromNumber(value: number): ThanosRulerSpecContainersReadinessProbeHttpGetPort {
    return new ThanosRulerSpecContainersReadinessProbeHttpGetPort(value);
  }
  public static fromString(value: string): ThanosRulerSpecContainersReadinessProbeHttpGetPort {
    return new ThanosRulerSpecContainersReadinessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema ThanosRulerSpecContainersReadinessProbeTcpSocketPort
 */
export class ThanosRulerSpecContainersReadinessProbeTcpSocketPort {
  public static fromNumber(value: number): ThanosRulerSpecContainersReadinessProbeTcpSocketPort {
    return new ThanosRulerSpecContainersReadinessProbeTcpSocketPort(value);
  }
  public static fromString(value: string): ThanosRulerSpecContainersReadinessProbeTcpSocketPort {
    return new ThanosRulerSpecContainersReadinessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema ThanosRulerSpecContainersStartupProbeHttpGetHttpHeaders
 */
export interface ThanosRulerSpecContainersStartupProbeHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema ThanosRulerSpecContainersStartupProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema ThanosRulerSpecContainersStartupProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecContainersStartupProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersStartupProbeHttpGetHttpHeaders(obj: ThanosRulerSpecContainersStartupProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema ThanosRulerSpecContainersStartupProbeHttpGetPort
 */
export class ThanosRulerSpecContainersStartupProbeHttpGetPort {
  public static fromNumber(value: number): ThanosRulerSpecContainersStartupProbeHttpGetPort {
    return new ThanosRulerSpecContainersStartupProbeHttpGetPort(value);
  }
  public static fromString(value: string): ThanosRulerSpecContainersStartupProbeHttpGetPort {
    return new ThanosRulerSpecContainersStartupProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema ThanosRulerSpecContainersStartupProbeTcpSocketPort
 */
export class ThanosRulerSpecContainersStartupProbeTcpSocketPort {
  public static fromNumber(value: number): ThanosRulerSpecContainersStartupProbeTcpSocketPort {
    return new ThanosRulerSpecContainersStartupProbeTcpSocketPort(value);
  }
  public static fromString(value: string): ThanosRulerSpecContainersStartupProbeTcpSocketPort {
    return new ThanosRulerSpecContainersStartupProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Selects a key of a ConfigMap.
 *
 * @schema ThanosRulerSpecInitContainersEnvValueFromConfigMapKeyRef
 */
export interface ThanosRulerSpecInitContainersEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema ThanosRulerSpecInitContainersEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ThanosRulerSpecInitContainersEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema ThanosRulerSpecInitContainersEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersEnvValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersEnvValueFromConfigMapKeyRef(obj: ThanosRulerSpecInitContainersEnvValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
 * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema ThanosRulerSpecInitContainersEnvValueFromFieldRef
 */
export interface ThanosRulerSpecInitContainersEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema ThanosRulerSpecInitContainersEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema ThanosRulerSpecInitContainersEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersEnvValueFromFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersEnvValueFromFieldRef(obj: ThanosRulerSpecInitContainersEnvValueFromFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema ThanosRulerSpecInitContainersEnvValueFromResourceFieldRef
 */
export interface ThanosRulerSpecInitContainersEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema ThanosRulerSpecInitContainersEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema ThanosRulerSpecInitContainersEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: ThanosRulerSpecInitContainersEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema ThanosRulerSpecInitContainersEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersEnvValueFromResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersEnvValueFromResourceFieldRef(obj: ThanosRulerSpecInitContainersEnvValueFromResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema ThanosRulerSpecInitContainersEnvValueFromSecretKeyRef
 */
export interface ThanosRulerSpecInitContainersEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ThanosRulerSpecInitContainersEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ThanosRulerSpecInitContainersEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ThanosRulerSpecInitContainersEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersEnvValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersEnvValueFromSecretKeyRef(obj: ThanosRulerSpecInitContainersEnvValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema ThanosRulerSpecInitContainersLifecyclePostStartExec
 */
export interface ThanosRulerSpecInitContainersLifecyclePostStartExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema ThanosRulerSpecInitContainersLifecyclePostStartExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersLifecyclePostStartExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersLifecyclePostStartExec(obj: ThanosRulerSpecInitContainersLifecyclePostStartExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema ThanosRulerSpecInitContainersLifecyclePostStartHttpGet
 */
export interface ThanosRulerSpecInitContainersLifecyclePostStartHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema ThanosRulerSpecInitContainersLifecyclePostStartHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema ThanosRulerSpecInitContainersLifecyclePostStartHttpGet#httpHeaders
   */
  readonly httpHeaders?: ThanosRulerSpecInitContainersLifecyclePostStartHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema ThanosRulerSpecInitContainersLifecyclePostStartHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema ThanosRulerSpecInitContainersLifecyclePostStartHttpGet#port
   */
  readonly port: ThanosRulerSpecInitContainersLifecyclePostStartHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema ThanosRulerSpecInitContainersLifecyclePostStartHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersLifecyclePostStartHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersLifecyclePostStartHttpGet(obj: ThanosRulerSpecInitContainersLifecyclePostStartHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_ThanosRulerSpecInitContainersLifecyclePostStartHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Sleep represents the duration that the container should sleep before being terminated.
 *
 * @schema ThanosRulerSpecInitContainersLifecyclePostStartSleep
 */
export interface ThanosRulerSpecInitContainersLifecyclePostStartSleep {
  /**
   * Seconds is the number of seconds to sleep.
   *
   * @schema ThanosRulerSpecInitContainersLifecyclePostStartSleep#seconds
   */
  readonly seconds: number;

}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersLifecyclePostStartSleep' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersLifecyclePostStartSleep(obj: ThanosRulerSpecInitContainersLifecyclePostStartSleep | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
 * for the backward compatibility. There are no validation of this field and
 * lifecycle hooks will fail in runtime when tcp handler is specified.
 *
 * @schema ThanosRulerSpecInitContainersLifecyclePostStartTcpSocket
 */
export interface ThanosRulerSpecInitContainersLifecyclePostStartTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema ThanosRulerSpecInitContainersLifecyclePostStartTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema ThanosRulerSpecInitContainersLifecyclePostStartTcpSocket#port
   */
  readonly port: ThanosRulerSpecInitContainersLifecyclePostStartTcpSocketPort;

}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersLifecyclePostStartTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersLifecyclePostStartTcpSocket(obj: ThanosRulerSpecInitContainersLifecyclePostStartTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema ThanosRulerSpecInitContainersLifecyclePreStopExec
 */
export interface ThanosRulerSpecInitContainersLifecyclePreStopExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema ThanosRulerSpecInitContainersLifecyclePreStopExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersLifecyclePreStopExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersLifecyclePreStopExec(obj: ThanosRulerSpecInitContainersLifecyclePreStopExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema ThanosRulerSpecInitContainersLifecyclePreStopHttpGet
 */
export interface ThanosRulerSpecInitContainersLifecyclePreStopHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema ThanosRulerSpecInitContainersLifecyclePreStopHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema ThanosRulerSpecInitContainersLifecyclePreStopHttpGet#httpHeaders
   */
  readonly httpHeaders?: ThanosRulerSpecInitContainersLifecyclePreStopHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema ThanosRulerSpecInitContainersLifecyclePreStopHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema ThanosRulerSpecInitContainersLifecyclePreStopHttpGet#port
   */
  readonly port: ThanosRulerSpecInitContainersLifecyclePreStopHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema ThanosRulerSpecInitContainersLifecyclePreStopHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersLifecyclePreStopHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersLifecyclePreStopHttpGet(obj: ThanosRulerSpecInitContainersLifecyclePreStopHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_ThanosRulerSpecInitContainersLifecyclePreStopHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Sleep represents the duration that the container should sleep before being terminated.
 *
 * @schema ThanosRulerSpecInitContainersLifecyclePreStopSleep
 */
export interface ThanosRulerSpecInitContainersLifecyclePreStopSleep {
  /**
   * Seconds is the number of seconds to sleep.
   *
   * @schema ThanosRulerSpecInitContainersLifecyclePreStopSleep#seconds
   */
  readonly seconds: number;

}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersLifecyclePreStopSleep' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersLifecyclePreStopSleep(obj: ThanosRulerSpecInitContainersLifecyclePreStopSleep | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
 * for the backward compatibility. There are no validation of this field and
 * lifecycle hooks will fail in runtime when tcp handler is specified.
 *
 * @schema ThanosRulerSpecInitContainersLifecyclePreStopTcpSocket
 */
export interface ThanosRulerSpecInitContainersLifecyclePreStopTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema ThanosRulerSpecInitContainersLifecyclePreStopTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema ThanosRulerSpecInitContainersLifecyclePreStopTcpSocket#port
   */
  readonly port: ThanosRulerSpecInitContainersLifecyclePreStopTcpSocketPort;

}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersLifecyclePreStopTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersLifecyclePreStopTcpSocket(obj: ThanosRulerSpecInitContainersLifecyclePreStopTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema ThanosRulerSpecInitContainersLivenessProbeHttpGetHttpHeaders
 */
export interface ThanosRulerSpecInitContainersLivenessProbeHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema ThanosRulerSpecInitContainersLivenessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema ThanosRulerSpecInitContainersLivenessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersLivenessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersLivenessProbeHttpGetHttpHeaders(obj: ThanosRulerSpecInitContainersLivenessProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema ThanosRulerSpecInitContainersLivenessProbeHttpGetPort
 */
export class ThanosRulerSpecInitContainersLivenessProbeHttpGetPort {
  public static fromNumber(value: number): ThanosRulerSpecInitContainersLivenessProbeHttpGetPort {
    return new ThanosRulerSpecInitContainersLivenessProbeHttpGetPort(value);
  }
  public static fromString(value: string): ThanosRulerSpecInitContainersLivenessProbeHttpGetPort {
    return new ThanosRulerSpecInitContainersLivenessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema ThanosRulerSpecInitContainersLivenessProbeTcpSocketPort
 */
export class ThanosRulerSpecInitContainersLivenessProbeTcpSocketPort {
  public static fromNumber(value: number): ThanosRulerSpecInitContainersLivenessProbeTcpSocketPort {
    return new ThanosRulerSpecInitContainersLivenessProbeTcpSocketPort(value);
  }
  public static fromString(value: string): ThanosRulerSpecInitContainersLivenessProbeTcpSocketPort {
    return new ThanosRulerSpecInitContainersLivenessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema ThanosRulerSpecInitContainersReadinessProbeHttpGetHttpHeaders
 */
export interface ThanosRulerSpecInitContainersReadinessProbeHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema ThanosRulerSpecInitContainersReadinessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema ThanosRulerSpecInitContainersReadinessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersReadinessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersReadinessProbeHttpGetHttpHeaders(obj: ThanosRulerSpecInitContainersReadinessProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema ThanosRulerSpecInitContainersReadinessProbeHttpGetPort
 */
export class ThanosRulerSpecInitContainersReadinessProbeHttpGetPort {
  public static fromNumber(value: number): ThanosRulerSpecInitContainersReadinessProbeHttpGetPort {
    return new ThanosRulerSpecInitContainersReadinessProbeHttpGetPort(value);
  }
  public static fromString(value: string): ThanosRulerSpecInitContainersReadinessProbeHttpGetPort {
    return new ThanosRulerSpecInitContainersReadinessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema ThanosRulerSpecInitContainersReadinessProbeTcpSocketPort
 */
export class ThanosRulerSpecInitContainersReadinessProbeTcpSocketPort {
  public static fromNumber(value: number): ThanosRulerSpecInitContainersReadinessProbeTcpSocketPort {
    return new ThanosRulerSpecInitContainersReadinessProbeTcpSocketPort(value);
  }
  public static fromString(value: string): ThanosRulerSpecInitContainersReadinessProbeTcpSocketPort {
    return new ThanosRulerSpecInitContainersReadinessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema ThanosRulerSpecInitContainersStartupProbeHttpGetHttpHeaders
 */
export interface ThanosRulerSpecInitContainersStartupProbeHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema ThanosRulerSpecInitContainersStartupProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema ThanosRulerSpecInitContainersStartupProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersStartupProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersStartupProbeHttpGetHttpHeaders(obj: ThanosRulerSpecInitContainersStartupProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema ThanosRulerSpecInitContainersStartupProbeHttpGetPort
 */
export class ThanosRulerSpecInitContainersStartupProbeHttpGetPort {
  public static fromNumber(value: number): ThanosRulerSpecInitContainersStartupProbeHttpGetPort {
    return new ThanosRulerSpecInitContainersStartupProbeHttpGetPort(value);
  }
  public static fromString(value: string): ThanosRulerSpecInitContainersStartupProbeHttpGetPort {
    return new ThanosRulerSpecInitContainersStartupProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema ThanosRulerSpecInitContainersStartupProbeTcpSocketPort
 */
export class ThanosRulerSpecInitContainersStartupProbeTcpSocketPort {
  public static fromNumber(value: number): ThanosRulerSpecInitContainersStartupProbeTcpSocketPort {
    return new ThanosRulerSpecInitContainersStartupProbeTcpSocketPort(value);
  }
  public static fromString(value: string): ThanosRulerSpecInitContainersStartupProbeTcpSocketPort {
    return new ThanosRulerSpecInitContainersStartupProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * The specification for the PersistentVolumeClaim. The entire content is
 * copied unchanged into the PVC that gets created from this
 * template. The same fields as in a PersistentVolumeClaim
 * are also valid here.
 *
 * @schema ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpec
 */
export interface ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpec {
  /**
   * accessModes contains the desired access modes the volume should have.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpec#accessModes
   */
  readonly accessModes?: string[];

  /**
   * dataSource field can be used to specify either:
   * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
   * * An existing PVC (PersistentVolumeClaim)
   * If the provisioner or an external controller can support the specified data source,
   * it will create a new volume based on the contents of the specified data source.
   * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
   * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
   * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
   *
   * @schema ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpec#dataSource
   */
  readonly dataSource?: ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecDataSource;

  /**
   * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
   * volume is desired. This may be any object from a non-empty API group (non
   * core object) or a PersistentVolumeClaim object.
   * When this field is specified, volume binding will only succeed if the type of
   * the specified object matches some installed volume populator or dynamic
   * provisioner.
   * This field will replace the functionality of the dataSource field and as such
   * if both fields are non-empty, they must have the same value. For backwards
   * compatibility, when namespace isn't specified in dataSourceRef,
   * both fields (dataSource and dataSourceRef) will be set to the same
   * value automatically if one of them is empty and the other is non-empty.
   * When namespace is specified in dataSourceRef,
   * dataSource isn't set to the same value and must be empty.
   * There are three important differences between dataSource and dataSourceRef:
   * * While dataSource only allows two specific types of objects, dataSourceRef
   * allows any non-core object, as well as PersistentVolumeClaim objects.
   * * While dataSource ignores disallowed values (dropping them), dataSourceRef
   * preserves all values, and generates an error if a disallowed value is
   * specified.
   * * While dataSource only allows local objects, dataSourceRef allows objects
   * in any namespaces.
   * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
   * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpec#dataSourceRef
   */
  readonly dataSourceRef?: ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecDataSourceRef;

  /**
   * resources represents the minimum resources the volume should have.
   * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
   * that are lower than previous value but must still be higher than capacity recorded in the
   * status field of the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
   *
   * @schema ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpec#resources
   */
  readonly resources?: ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecResources;

  /**
   * selector is a label query over volumes to consider for binding.
   *
   * @schema ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpec#selector
   */
  readonly selector?: ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecSelector;

  /**
   * storageClassName is the name of the StorageClass required by the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   *
   * @schema ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpec#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
   * If specified, the CSI driver will create or update the volume with the attributes defined
   * in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
   * it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
   * will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
   * If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
   * will be set by the persistentvolume controller if it exists.
   * If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
   * set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
   * exists.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#volumeattributesclass
   * (Alpha) Using this field requires the VolumeAttributesClass feature gate to be enabled.
   *
   * @schema ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpec#volumeAttributesClassName
   */
  readonly volumeAttributesClassName?: string;

  /**
   * volumeMode defines what type of volume is required by the claim.
   * Value of Filesystem is implied when not included in claim spec.
   *
   * @schema ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpec#volumeMode
   */
  readonly volumeMode?: string;

  /**
   * volumeName is the binding reference to the PersistentVolume backing this claim.
   *
   * @schema ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpec#volumeName
   */
  readonly volumeName?: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpec(obj: ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessModes': obj.accessModes?.map(y => y),
    'dataSource': toJson_ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecDataSource(obj.dataSource),
    'dataSourceRef': toJson_ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecDataSourceRef(obj.dataSourceRef),
    'resources': toJson_ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecResources(obj.resources),
    'selector': toJson_ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecSelector(obj.selector),
    'storageClassName': obj.storageClassName,
    'volumeAttributesClassName': obj.volumeAttributesClassName,
    'volumeMode': obj.volumeMode,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * dataSource field can be used to specify either:
 * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
 * * An existing PVC (PersistentVolumeClaim)
 * If the provisioner or an external controller can support the specified data source,
 * it will create a new volume based on the contents of the specified data source.
 * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
 * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
 * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
 *
 * @schema ThanosRulerSpecStorageVolumeClaimTemplateSpecDataSource
 */
export interface ThanosRulerSpecStorageVolumeClaimTemplateSpecDataSource {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateSpecDataSource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateSpecDataSource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateSpecDataSource#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecStorageVolumeClaimTemplateSpecDataSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecStorageVolumeClaimTemplateSpecDataSource(obj: ThanosRulerSpecStorageVolumeClaimTemplateSpecDataSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
 * volume is desired. This may be any object from a non-empty API group (non
 * core object) or a PersistentVolumeClaim object.
 * When this field is specified, volume binding will only succeed if the type of
 * the specified object matches some installed volume populator or dynamic
 * provisioner.
 * This field will replace the functionality of the dataSource field and as such
 * if both fields are non-empty, they must have the same value. For backwards
 * compatibility, when namespace isn't specified in dataSourceRef,
 * both fields (dataSource and dataSourceRef) will be set to the same
 * value automatically if one of them is empty and the other is non-empty.
 * When namespace is specified in dataSourceRef,
 * dataSource isn't set to the same value and must be empty.
 * There are three important differences between dataSource and dataSourceRef:
 * * While dataSource only allows two specific types of objects, dataSourceRef
 * allows any non-core object, as well as PersistentVolumeClaim objects.
 * * While dataSource ignores disallowed values (dropping them), dataSourceRef
 * preserves all values, and generates an error if a disallowed value is
 * specified.
 * * While dataSource only allows local objects, dataSourceRef allows objects
 * in any namespaces.
 * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
 * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
 *
 * @schema ThanosRulerSpecStorageVolumeClaimTemplateSpecDataSourceRef
 */
export interface ThanosRulerSpecStorageVolumeClaimTemplateSpecDataSourceRef {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateSpecDataSourceRef#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateSpecDataSourceRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateSpecDataSourceRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of resource being referenced
   * Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
   * (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateSpecDataSourceRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecStorageVolumeClaimTemplateSpecDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecStorageVolumeClaimTemplateSpecDataSourceRef(obj: ThanosRulerSpecStorageVolumeClaimTemplateSpecDataSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * resources represents the minimum resources the volume should have.
 * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
 * that are lower than previous value but must still be higher than capacity recorded in the
 * status field of the claim.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
 *
 * @schema ThanosRulerSpecStorageVolumeClaimTemplateSpecResources
 */
export interface ThanosRulerSpecStorageVolumeClaimTemplateSpecResources {
  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateSpecResources#limits
   */
  readonly limits?: { [key: string]: ThanosRulerSpecStorageVolumeClaimTemplateSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateSpecResources#requests
   */
  readonly requests?: { [key: string]: ThanosRulerSpecStorageVolumeClaimTemplateSpecResourcesRequests };

}

/**
 * Converts an object of type 'ThanosRulerSpecStorageVolumeClaimTemplateSpecResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecStorageVolumeClaimTemplateSpecResources(obj: ThanosRulerSpecStorageVolumeClaimTemplateSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * selector is a label query over volumes to consider for binding.
 *
 * @schema ThanosRulerSpecStorageVolumeClaimTemplateSpecSelector
 */
export interface ThanosRulerSpecStorageVolumeClaimTemplateSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateSpecSelector#matchExpressions
   */
  readonly matchExpressions?: ThanosRulerSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ThanosRulerSpecStorageVolumeClaimTemplateSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecStorageVolumeClaimTemplateSpecSelector(obj: ThanosRulerSpecStorageVolumeClaimTemplateSpecSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ThanosRulerSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ThanosRulerSpecStorageVolumeClaimTemplateStatusAllocatedResources
 */
export class ThanosRulerSpecStorageVolumeClaimTemplateStatusAllocatedResources {
  public static fromNumber(value: number): ThanosRulerSpecStorageVolumeClaimTemplateStatusAllocatedResources {
    return new ThanosRulerSpecStorageVolumeClaimTemplateStatusAllocatedResources(value);
  }
  public static fromString(value: string): ThanosRulerSpecStorageVolumeClaimTemplateStatusAllocatedResources {
    return new ThanosRulerSpecStorageVolumeClaimTemplateStatusAllocatedResources(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema ThanosRulerSpecStorageVolumeClaimTemplateStatusCapacity
 */
export class ThanosRulerSpecStorageVolumeClaimTemplateStatusCapacity {
  public static fromNumber(value: number): ThanosRulerSpecStorageVolumeClaimTemplateStatusCapacity {
    return new ThanosRulerSpecStorageVolumeClaimTemplateStatusCapacity(value);
  }
  public static fromString(value: string): ThanosRulerSpecStorageVolumeClaimTemplateStatusCapacity {
    return new ThanosRulerSpecStorageVolumeClaimTemplateStatusCapacity(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * PersistentVolumeClaimCondition contains details about state of pvc
 *
 * @schema ThanosRulerSpecStorageVolumeClaimTemplateStatusConditions
 */
export interface ThanosRulerSpecStorageVolumeClaimTemplateStatusConditions {
  /**
   * lastProbeTime is the time we probed the condition.
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateStatusConditions#lastProbeTime
   */
  readonly lastProbeTime?: Date;

  /**
   * lastTransitionTime is the time the condition transitioned from one status to another.
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateStatusConditions#lastTransitionTime
   */
  readonly lastTransitionTime?: Date;

  /**
   * message is the human-readable message indicating details about last transition.
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateStatusConditions#message
   */
  readonly message?: string;

  /**
   * reason is a unique, this should be a short, machine understandable string that gives the reason
   * for condition's last transition. If it reports "ResizeStarted" that means the underlying
   * persistent volume is being resized.
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateStatusConditions#reason
   */
  readonly reason?: string;

  /**
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateStatusConditions#status
   */
  readonly status: string;

  /**
   * PersistentVolumeClaimConditionType is a valid value of PersistentVolumeClaimCondition.Type
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateStatusConditions#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecStorageVolumeClaimTemplateStatusConditions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecStorageVolumeClaimTemplateStatusConditions(obj: ThanosRulerSpecStorageVolumeClaimTemplateStatusConditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'lastProbeTime': obj.lastProbeTime?.toISOString(),
    'lastTransitionTime': obj.lastTransitionTime?.toISOString(),
    'message': obj.message,
    'reason': obj.reason,
    'status': obj.status,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ModifyVolumeStatus represents the status object of ControllerModifyVolume operation.
 * When this is unset, there is no ModifyVolume operation being attempted.
 * This is an alpha field and requires enabling VolumeAttributesClass feature.
 *
 * @schema ThanosRulerSpecStorageVolumeClaimTemplateStatusModifyVolumeStatus
 */
export interface ThanosRulerSpecStorageVolumeClaimTemplateStatusModifyVolumeStatus {
  /**
   * status is the status of the ControllerModifyVolume operation. It can be in any of following states:
   * - Pending
   * Pending indicates that the PersistentVolumeClaim cannot be modified due to unmet requirements, such as
   * the specified VolumeAttributesClass not existing.
   * - InProgress
   * InProgress indicates that the volume is being modified.
   * - Infeasible
   * Infeasible indicates that the request has been rejected as invalid by the CSI driver. To
   * resolve the error, a valid VolumeAttributesClass needs to be specified.
   * Note: New statuses can be added in the future. Consumers should check for unknown statuses and fail appropriately.
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateStatusModifyVolumeStatus#status
   */
  readonly status: string;

  /**
   * targetVolumeAttributesClassName is the name of the VolumeAttributesClass the PVC currently being reconciled
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateStatusModifyVolumeStatus#targetVolumeAttributesClassName
   */
  readonly targetVolumeAttributesClassName?: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecStorageVolumeClaimTemplateStatusModifyVolumeStatus' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecStorageVolumeClaimTemplateStatusModifyVolumeStatus(obj: ThanosRulerSpecStorageVolumeClaimTemplateStatusModifyVolumeStatus | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'status': obj.status,
    'targetVolumeAttributesClassName': obj.targetVolumeAttributesClassName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
 *
 * @schema ThanosRulerSpecVolumesDownwardApiItemsFieldRef
 */
export interface ThanosRulerSpecVolumesDownwardApiItemsFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema ThanosRulerSpecVolumesDownwardApiItemsFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema ThanosRulerSpecVolumesDownwardApiItemsFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesDownwardApiItemsFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesDownwardApiItemsFieldRef(obj: ThanosRulerSpecVolumesDownwardApiItemsFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
 *
 * @schema ThanosRulerSpecVolumesDownwardApiItemsResourceFieldRef
 */
export interface ThanosRulerSpecVolumesDownwardApiItemsResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema ThanosRulerSpecVolumesDownwardApiItemsResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema ThanosRulerSpecVolumesDownwardApiItemsResourceFieldRef#divisor
   */
  readonly divisor?: ThanosRulerSpecVolumesDownwardApiItemsResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema ThanosRulerSpecVolumesDownwardApiItemsResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesDownwardApiItemsResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesDownwardApiItemsResourceFieldRef(obj: ThanosRulerSpecVolumesDownwardApiItemsResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The specification for the PersistentVolumeClaim. The entire content is
 * copied unchanged into the PVC that gets created from this
 * template. The same fields as in a PersistentVolumeClaim
 * are also valid here.
 *
 * @schema ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpec
 */
export interface ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpec {
  /**
   * accessModes contains the desired access modes the volume should have.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpec#accessModes
   */
  readonly accessModes?: string[];

  /**
   * dataSource field can be used to specify either:
   * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
   * * An existing PVC (PersistentVolumeClaim)
   * If the provisioner or an external controller can support the specified data source,
   * it will create a new volume based on the contents of the specified data source.
   * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
   * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
   * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
   *
   * @schema ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpec#dataSource
   */
  readonly dataSource?: ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource;

  /**
   * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
   * volume is desired. This may be any object from a non-empty API group (non
   * core object) or a PersistentVolumeClaim object.
   * When this field is specified, volume binding will only succeed if the type of
   * the specified object matches some installed volume populator or dynamic
   * provisioner.
   * This field will replace the functionality of the dataSource field and as such
   * if both fields are non-empty, they must have the same value. For backwards
   * compatibility, when namespace isn't specified in dataSourceRef,
   * both fields (dataSource and dataSourceRef) will be set to the same
   * value automatically if one of them is empty and the other is non-empty.
   * When namespace is specified in dataSourceRef,
   * dataSource isn't set to the same value and must be empty.
   * There are three important differences between dataSource and dataSourceRef:
   * * While dataSource only allows two specific types of objects, dataSourceRef
   * allows any non-core object, as well as PersistentVolumeClaim objects.
   * * While dataSource ignores disallowed values (dropping them), dataSourceRef
   * preserves all values, and generates an error if a disallowed value is
   * specified.
   * * While dataSource only allows local objects, dataSourceRef allows objects
   * in any namespaces.
   * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
   * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpec#dataSourceRef
   */
  readonly dataSourceRef?: ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef;

  /**
   * resources represents the minimum resources the volume should have.
   * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
   * that are lower than previous value but must still be higher than capacity recorded in the
   * status field of the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
   *
   * @schema ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpec#resources
   */
  readonly resources?: ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecResources;

  /**
   * selector is a label query over volumes to consider for binding.
   *
   * @schema ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpec#selector
   */
  readonly selector?: ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecSelector;

  /**
   * storageClassName is the name of the StorageClass required by the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   *
   * @schema ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpec#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
   * If specified, the CSI driver will create or update the volume with the attributes defined
   * in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
   * it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
   * will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
   * If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
   * will be set by the persistentvolume controller if it exists.
   * If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
   * set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
   * exists.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#volumeattributesclass
   * (Alpha) Using this field requires the VolumeAttributesClass feature gate to be enabled.
   *
   * @schema ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpec#volumeAttributesClassName
   */
  readonly volumeAttributesClassName?: string;

  /**
   * volumeMode defines what type of volume is required by the claim.
   * Value of Filesystem is implied when not included in claim spec.
   *
   * @schema ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpec#volumeMode
   */
  readonly volumeMode?: string;

  /**
   * volumeName is the binding reference to the PersistentVolume backing this claim.
   *
   * @schema ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpec#volumeName
   */
  readonly volumeName?: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpec(obj: ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessModes': obj.accessModes?.map(y => y),
    'dataSource': toJson_ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource(obj.dataSource),
    'dataSourceRef': toJson_ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef(obj.dataSourceRef),
    'resources': toJson_ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecResources(obj.resources),
    'selector': toJson_ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecSelector(obj.selector),
    'storageClassName': obj.storageClassName,
    'volumeAttributesClassName': obj.volumeAttributesClassName,
    'volumeMode': obj.volumeMode,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ClusterTrustBundle allows a pod to access the `.spec.trustBundle` field
 * of ClusterTrustBundle objects in an auto-updating file.
 *
 *
 * Alpha, gated by the ClusterTrustBundleProjection feature gate.
 *
 *
 * ClusterTrustBundle objects can either be selected by name, or by the
 * combination of signer name and a label selector.
 *
 *
 * Kubelet performs aggressive normalization of the PEM contents written
 * into the pod filesystem.  Esoteric PEM features such as inter-block
 * comments and block headers are stripped.  Certificates are deduplicated.
 * The ordering of certificates within the file is arbitrary, and Kubelet
 * may change the order over time.
 *
 * @schema ThanosRulerSpecVolumesProjectedSourcesClusterTrustBundle
 */
export interface ThanosRulerSpecVolumesProjectedSourcesClusterTrustBundle {
  /**
   * Select all ClusterTrustBundles that match this label selector.  Only has
   * effect if signerName is set.  Mutually-exclusive with name.  If unset,
   * interpreted as "match nothing".  If set but empty, interpreted as "match
   * everything".
   *
   * @schema ThanosRulerSpecVolumesProjectedSourcesClusterTrustBundle#labelSelector
   */
  readonly labelSelector?: ThanosRulerSpecVolumesProjectedSourcesClusterTrustBundleLabelSelector;

  /**
   * Select a single ClusterTrustBundle by object name.  Mutually-exclusive
   * with signerName and labelSelector.
   *
   * @schema ThanosRulerSpecVolumesProjectedSourcesClusterTrustBundle#name
   */
  readonly name?: string;

  /**
   * If true, don't block pod startup if the referenced ClusterTrustBundle(s)
   * aren't available.  If using name, then the named ClusterTrustBundle is
   * allowed not to exist.  If using signerName, then the combination of
   * signerName and labelSelector is allowed to match zero
   * ClusterTrustBundles.
   *
   * @schema ThanosRulerSpecVolumesProjectedSourcesClusterTrustBundle#optional
   */
  readonly optional?: boolean;

  /**
   * Relative path from the volume root to write the bundle.
   *
   * @schema ThanosRulerSpecVolumesProjectedSourcesClusterTrustBundle#path
   */
  readonly path: string;

  /**
   * Select all ClusterTrustBundles that match this signer name.
   * Mutually-exclusive with name.  The contents of all selected
   * ClusterTrustBundles will be unified and deduplicated.
   *
   * @schema ThanosRulerSpecVolumesProjectedSourcesClusterTrustBundle#signerName
   */
  readonly signerName?: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesProjectedSourcesClusterTrustBundle' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesProjectedSourcesClusterTrustBundle(obj: ThanosRulerSpecVolumesProjectedSourcesClusterTrustBundle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_ThanosRulerSpecVolumesProjectedSourcesClusterTrustBundleLabelSelector(obj.labelSelector),
    'name': obj.name,
    'optional': obj.optional,
    'path': obj.path,
    'signerName': obj.signerName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * configMap information about the configMap data to project
 *
 * @schema ThanosRulerSpecVolumesProjectedSourcesConfigMap
 */
export interface ThanosRulerSpecVolumesProjectedSourcesConfigMap {
  /**
   * items if unspecified, each key-value pair in the Data field of the referenced
   * ConfigMap will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the ConfigMap,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   *
   * @schema ThanosRulerSpecVolumesProjectedSourcesConfigMap#items
   */
  readonly items?: ThanosRulerSpecVolumesProjectedSourcesConfigMapItems[];

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ThanosRulerSpecVolumesProjectedSourcesConfigMap#name
   */
  readonly name?: string;

  /**
   * optional specify whether the ConfigMap or its keys must be defined
   *
   * @schema ThanosRulerSpecVolumesProjectedSourcesConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesProjectedSourcesConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesProjectedSourcesConfigMap(obj: ThanosRulerSpecVolumesProjectedSourcesConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_ThanosRulerSpecVolumesProjectedSourcesConfigMapItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * downwardAPI information about the downwardAPI data to project
 *
 * @schema ThanosRulerSpecVolumesProjectedSourcesDownwardApi
 */
export interface ThanosRulerSpecVolumesProjectedSourcesDownwardApi {
  /**
   * Items is a list of DownwardAPIVolume file
   *
   * @schema ThanosRulerSpecVolumesProjectedSourcesDownwardApi#items
   */
  readonly items?: ThanosRulerSpecVolumesProjectedSourcesDownwardApiItems[];

}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesProjectedSourcesDownwardApi' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesProjectedSourcesDownwardApi(obj: ThanosRulerSpecVolumesProjectedSourcesDownwardApi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_ThanosRulerSpecVolumesProjectedSourcesDownwardApiItems(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * secret information about the secret data to project
 *
 * @schema ThanosRulerSpecVolumesProjectedSourcesSecret
 */
export interface ThanosRulerSpecVolumesProjectedSourcesSecret {
  /**
   * items if unspecified, each key-value pair in the Data field of the referenced
   * Secret will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the Secret,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   *
   * @schema ThanosRulerSpecVolumesProjectedSourcesSecret#items
   */
  readonly items?: ThanosRulerSpecVolumesProjectedSourcesSecretItems[];

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ThanosRulerSpecVolumesProjectedSourcesSecret#name
   */
  readonly name?: string;

  /**
   * optional field specify whether the Secret or its key must be defined
   *
   * @schema ThanosRulerSpecVolumesProjectedSourcesSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesProjectedSourcesSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesProjectedSourcesSecret(obj: ThanosRulerSpecVolumesProjectedSourcesSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_ThanosRulerSpecVolumesProjectedSourcesSecretItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * serviceAccountToken is information about the serviceAccountToken data to project
 *
 * @schema ThanosRulerSpecVolumesProjectedSourcesServiceAccountToken
 */
export interface ThanosRulerSpecVolumesProjectedSourcesServiceAccountToken {
  /**
   * audience is the intended audience of the token. A recipient of a token
   * must identify itself with an identifier specified in the audience of the
   * token, and otherwise should reject the token. The audience defaults to the
   * identifier of the apiserver.
   *
   * @schema ThanosRulerSpecVolumesProjectedSourcesServiceAccountToken#audience
   */
  readonly audience?: string;

  /**
   * expirationSeconds is the requested duration of validity of the service
   * account token. As the token approaches expiration, the kubelet volume
   * plugin will proactively rotate the service account token. The kubelet will
   * start trying to rotate the token if the token is older than 80 percent of
   * its time to live or if the token is older than 24 hours.Defaults to 1 hour
   * and must be at least 10 minutes.
   *
   * @default 1 hour
   * @schema ThanosRulerSpecVolumesProjectedSourcesServiceAccountToken#expirationSeconds
   */
  readonly expirationSeconds?: number;

  /**
   * path is the path relative to the mount point of the file to project the
   * token into.
   *
   * @schema ThanosRulerSpecVolumesProjectedSourcesServiceAccountToken#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesProjectedSourcesServiceAccountToken' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesProjectedSourcesServiceAccountToken(obj: ThanosRulerSpecVolumesProjectedSourcesServiceAccountToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audience': obj.audience,
    'expirationSeconds': obj.expirationSeconds,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Set the X-Content-Type-Options header to HTTP responses.
 * Unset if blank. Accepted value is nosniff.
 * https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Content-Type-Options
 *
 * @schema ThanosRulerSpecWebHttpConfigHeadersXContentTypeOptions
 */
export enum ThanosRulerSpecWebHttpConfigHeadersXContentTypeOptions {
  /** NoSniff */
  NO_SNIFF = "NoSniff",
}

/**
 * Set the X-Frame-Options header to HTTP responses.
 * Unset if blank. Accepted values are deny and sameorigin.
 * https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options
 *
 * @schema ThanosRulerSpecWebHttpConfigHeadersXFrameOptions
 */
export enum ThanosRulerSpecWebHttpConfigHeadersXFrameOptions {
  /** Deny */
  DENY = "Deny",
  /** SameOrigin */
  SAME_ORIGIN = "SameOrigin",
}

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema ThanosRulerSpecWebTlsConfigCertConfigMap
 */
export interface ThanosRulerSpecWebTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema ThanosRulerSpecWebTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ThanosRulerSpecWebTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema ThanosRulerSpecWebTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ThanosRulerSpecWebTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecWebTlsConfigCertConfigMap(obj: ThanosRulerSpecWebTlsConfigCertConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema ThanosRulerSpecWebTlsConfigCertSecret
 */
export interface ThanosRulerSpecWebTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ThanosRulerSpecWebTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ThanosRulerSpecWebTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ThanosRulerSpecWebTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ThanosRulerSpecWebTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecWebTlsConfigCertSecret(obj: ThanosRulerSpecWebTlsConfigCertSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema ThanosRulerSpecWebTlsConfigClientCaConfigMap
 */
export interface ThanosRulerSpecWebTlsConfigClientCaConfigMap {
  /**
   * The key to select.
   *
   * @schema ThanosRulerSpecWebTlsConfigClientCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ThanosRulerSpecWebTlsConfigClientCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema ThanosRulerSpecWebTlsConfigClientCaConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ThanosRulerSpecWebTlsConfigClientCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecWebTlsConfigClientCaConfigMap(obj: ThanosRulerSpecWebTlsConfigClientCaConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema ThanosRulerSpecWebTlsConfigClientCaSecret
 */
export interface ThanosRulerSpecWebTlsConfigClientCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ThanosRulerSpecWebTlsConfigClientCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ThanosRulerSpecWebTlsConfigClientCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ThanosRulerSpecWebTlsConfigClientCaSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ThanosRulerSpecWebTlsConfigClientCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecWebTlsConfigClientCaSecret(obj: ThanosRulerSpecWebTlsConfigClientCaSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema ThanosRulerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface ThanosRulerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema ThanosRulerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema ThanosRulerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema ThanosRulerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ThanosRulerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(obj: ThanosRulerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema ThanosRulerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface ThanosRulerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema ThanosRulerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema ThanosRulerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema ThanosRulerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ThanosRulerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(obj: ThanosRulerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema ThanosRulerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface ThanosRulerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema ThanosRulerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema ThanosRulerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema ThanosRulerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ThanosRulerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(obj: ThanosRulerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema ThanosRulerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface ThanosRulerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema ThanosRulerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema ThanosRulerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema ThanosRulerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ThanosRulerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(obj: ThanosRulerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema ThanosRulerSpecContainersEnvValueFromResourceFieldRefDivisor
 */
export class ThanosRulerSpecContainersEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(value: number): ThanosRulerSpecContainersEnvValueFromResourceFieldRefDivisor {
    return new ThanosRulerSpecContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): ThanosRulerSpecContainersEnvValueFromResourceFieldRefDivisor {
    return new ThanosRulerSpecContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema ThanosRulerSpecContainersLifecyclePostStartHttpGetHttpHeaders
 */
export interface ThanosRulerSpecContainersLifecyclePostStartHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema ThanosRulerSpecContainersLifecyclePostStartHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema ThanosRulerSpecContainersLifecyclePostStartHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecContainersLifecyclePostStartHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersLifecyclePostStartHttpGetHttpHeaders(obj: ThanosRulerSpecContainersLifecyclePostStartHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema ThanosRulerSpecContainersLifecyclePostStartHttpGetPort
 */
export class ThanosRulerSpecContainersLifecyclePostStartHttpGetPort {
  public static fromNumber(value: number): ThanosRulerSpecContainersLifecyclePostStartHttpGetPort {
    return new ThanosRulerSpecContainersLifecyclePostStartHttpGetPort(value);
  }
  public static fromString(value: string): ThanosRulerSpecContainersLifecyclePostStartHttpGetPort {
    return new ThanosRulerSpecContainersLifecyclePostStartHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema ThanosRulerSpecContainersLifecyclePostStartTcpSocketPort
 */
export class ThanosRulerSpecContainersLifecyclePostStartTcpSocketPort {
  public static fromNumber(value: number): ThanosRulerSpecContainersLifecyclePostStartTcpSocketPort {
    return new ThanosRulerSpecContainersLifecyclePostStartTcpSocketPort(value);
  }
  public static fromString(value: string): ThanosRulerSpecContainersLifecyclePostStartTcpSocketPort {
    return new ThanosRulerSpecContainersLifecyclePostStartTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema ThanosRulerSpecContainersLifecyclePreStopHttpGetHttpHeaders
 */
export interface ThanosRulerSpecContainersLifecyclePreStopHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema ThanosRulerSpecContainersLifecyclePreStopHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema ThanosRulerSpecContainersLifecyclePreStopHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecContainersLifecyclePreStopHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersLifecyclePreStopHttpGetHttpHeaders(obj: ThanosRulerSpecContainersLifecyclePreStopHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema ThanosRulerSpecContainersLifecyclePreStopHttpGetPort
 */
export class ThanosRulerSpecContainersLifecyclePreStopHttpGetPort {
  public static fromNumber(value: number): ThanosRulerSpecContainersLifecyclePreStopHttpGetPort {
    return new ThanosRulerSpecContainersLifecyclePreStopHttpGetPort(value);
  }
  public static fromString(value: string): ThanosRulerSpecContainersLifecyclePreStopHttpGetPort {
    return new ThanosRulerSpecContainersLifecyclePreStopHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema ThanosRulerSpecContainersLifecyclePreStopTcpSocketPort
 */
export class ThanosRulerSpecContainersLifecyclePreStopTcpSocketPort {
  public static fromNumber(value: number): ThanosRulerSpecContainersLifecyclePreStopTcpSocketPort {
    return new ThanosRulerSpecContainersLifecyclePreStopTcpSocketPort(value);
  }
  public static fromString(value: string): ThanosRulerSpecContainersLifecyclePreStopTcpSocketPort {
    return new ThanosRulerSpecContainersLifecyclePreStopTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema ThanosRulerSpecInitContainersEnvValueFromResourceFieldRefDivisor
 */
export class ThanosRulerSpecInitContainersEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(value: number): ThanosRulerSpecInitContainersEnvValueFromResourceFieldRefDivisor {
    return new ThanosRulerSpecInitContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): ThanosRulerSpecInitContainersEnvValueFromResourceFieldRefDivisor {
    return new ThanosRulerSpecInitContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema ThanosRulerSpecInitContainersLifecyclePostStartHttpGetHttpHeaders
 */
export interface ThanosRulerSpecInitContainersLifecyclePostStartHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema ThanosRulerSpecInitContainersLifecyclePostStartHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema ThanosRulerSpecInitContainersLifecyclePostStartHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersLifecyclePostStartHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersLifecyclePostStartHttpGetHttpHeaders(obj: ThanosRulerSpecInitContainersLifecyclePostStartHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema ThanosRulerSpecInitContainersLifecyclePostStartHttpGetPort
 */
export class ThanosRulerSpecInitContainersLifecyclePostStartHttpGetPort {
  public static fromNumber(value: number): ThanosRulerSpecInitContainersLifecyclePostStartHttpGetPort {
    return new ThanosRulerSpecInitContainersLifecyclePostStartHttpGetPort(value);
  }
  public static fromString(value: string): ThanosRulerSpecInitContainersLifecyclePostStartHttpGetPort {
    return new ThanosRulerSpecInitContainersLifecyclePostStartHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema ThanosRulerSpecInitContainersLifecyclePostStartTcpSocketPort
 */
export class ThanosRulerSpecInitContainersLifecyclePostStartTcpSocketPort {
  public static fromNumber(value: number): ThanosRulerSpecInitContainersLifecyclePostStartTcpSocketPort {
    return new ThanosRulerSpecInitContainersLifecyclePostStartTcpSocketPort(value);
  }
  public static fromString(value: string): ThanosRulerSpecInitContainersLifecyclePostStartTcpSocketPort {
    return new ThanosRulerSpecInitContainersLifecyclePostStartTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema ThanosRulerSpecInitContainersLifecyclePreStopHttpGetHttpHeaders
 */
export interface ThanosRulerSpecInitContainersLifecyclePreStopHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema ThanosRulerSpecInitContainersLifecyclePreStopHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema ThanosRulerSpecInitContainersLifecyclePreStopHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersLifecyclePreStopHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersLifecyclePreStopHttpGetHttpHeaders(obj: ThanosRulerSpecInitContainersLifecyclePreStopHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema ThanosRulerSpecInitContainersLifecyclePreStopHttpGetPort
 */
export class ThanosRulerSpecInitContainersLifecyclePreStopHttpGetPort {
  public static fromNumber(value: number): ThanosRulerSpecInitContainersLifecyclePreStopHttpGetPort {
    return new ThanosRulerSpecInitContainersLifecyclePreStopHttpGetPort(value);
  }
  public static fromString(value: string): ThanosRulerSpecInitContainersLifecyclePreStopHttpGetPort {
    return new ThanosRulerSpecInitContainersLifecyclePreStopHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema ThanosRulerSpecInitContainersLifecyclePreStopTcpSocketPort
 */
export class ThanosRulerSpecInitContainersLifecyclePreStopTcpSocketPort {
  public static fromNumber(value: number): ThanosRulerSpecInitContainersLifecyclePreStopTcpSocketPort {
    return new ThanosRulerSpecInitContainersLifecyclePreStopTcpSocketPort(value);
  }
  public static fromString(value: string): ThanosRulerSpecInitContainersLifecyclePreStopTcpSocketPort {
    return new ThanosRulerSpecInitContainersLifecyclePreStopTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * dataSource field can be used to specify either:
 * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
 * * An existing PVC (PersistentVolumeClaim)
 * If the provisioner or an external controller can support the specified data source,
 * it will create a new volume based on the contents of the specified data source.
 * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
 * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
 * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
 *
 * @schema ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecDataSource
 */
export interface ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecDataSource {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecDataSource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecDataSource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecDataSource#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecDataSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecDataSource(obj: ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecDataSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
 * volume is desired. This may be any object from a non-empty API group (non
 * core object) or a PersistentVolumeClaim object.
 * When this field is specified, volume binding will only succeed if the type of
 * the specified object matches some installed volume populator or dynamic
 * provisioner.
 * This field will replace the functionality of the dataSource field and as such
 * if both fields are non-empty, they must have the same value. For backwards
 * compatibility, when namespace isn't specified in dataSourceRef,
 * both fields (dataSource and dataSourceRef) will be set to the same
 * value automatically if one of them is empty and the other is non-empty.
 * When namespace is specified in dataSourceRef,
 * dataSource isn't set to the same value and must be empty.
 * There are three important differences between dataSource and dataSourceRef:
 * * While dataSource only allows two specific types of objects, dataSourceRef
 * allows any non-core object, as well as PersistentVolumeClaim objects.
 * * While dataSource ignores disallowed values (dropping them), dataSourceRef
 * preserves all values, and generates an error if a disallowed value is
 * specified.
 * * While dataSource only allows local objects, dataSourceRef allows objects
 * in any namespaces.
 * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
 * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
 *
 * @schema ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecDataSourceRef
 */
export interface ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecDataSourceRef {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecDataSourceRef#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecDataSourceRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecDataSourceRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of resource being referenced
   * Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
   * (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecDataSourceRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecDataSourceRef(obj: ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecDataSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * resources represents the minimum resources the volume should have.
 * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
 * that are lower than previous value but must still be higher than capacity recorded in the
 * status field of the claim.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
 *
 * @schema ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecResources
 */
export interface ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecResources {
  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecResources#limits
   */
  readonly limits?: { [key: string]: ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecResources#requests
   */
  readonly requests?: { [key: string]: ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecResourcesRequests };

}

/**
 * Converts an object of type 'ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecResources(obj: ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * selector is a label query over volumes to consider for binding.
 *
 * @schema ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecSelector
 */
export interface ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecSelector#matchExpressions
   */
  readonly matchExpressions?: ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecSelector(obj: ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ThanosRulerSpecStorageVolumeClaimTemplateSpecResourcesLimits
 */
export class ThanosRulerSpecStorageVolumeClaimTemplateSpecResourcesLimits {
  public static fromNumber(value: number): ThanosRulerSpecStorageVolumeClaimTemplateSpecResourcesLimits {
    return new ThanosRulerSpecStorageVolumeClaimTemplateSpecResourcesLimits(value);
  }
  public static fromString(value: string): ThanosRulerSpecStorageVolumeClaimTemplateSpecResourcesLimits {
    return new ThanosRulerSpecStorageVolumeClaimTemplateSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema ThanosRulerSpecStorageVolumeClaimTemplateSpecResourcesRequests
 */
export class ThanosRulerSpecStorageVolumeClaimTemplateSpecResourcesRequests {
  public static fromNumber(value: number): ThanosRulerSpecStorageVolumeClaimTemplateSpecResourcesRequests {
    return new ThanosRulerSpecStorageVolumeClaimTemplateSpecResourcesRequests(value);
  }
  public static fromString(value: string): ThanosRulerSpecStorageVolumeClaimTemplateSpecResourcesRequests {
    return new ThanosRulerSpecStorageVolumeClaimTemplateSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ThanosRulerSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions
 */
export interface ThanosRulerSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ThanosRulerSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions(obj: ThanosRulerSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema ThanosRulerSpecVolumesDownwardApiItemsResourceFieldRefDivisor
 */
export class ThanosRulerSpecVolumesDownwardApiItemsResourceFieldRefDivisor {
  public static fromNumber(value: number): ThanosRulerSpecVolumesDownwardApiItemsResourceFieldRefDivisor {
    return new ThanosRulerSpecVolumesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): ThanosRulerSpecVolumesDownwardApiItemsResourceFieldRefDivisor {
    return new ThanosRulerSpecVolumesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * dataSource field can be used to specify either:
 * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
 * * An existing PVC (PersistentVolumeClaim)
 * If the provisioner or an external controller can support the specified data source,
 * it will create a new volume based on the contents of the specified data source.
 * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
 * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
 * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
 *
 * @schema ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource
 */
export interface ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource(obj: ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
 * volume is desired. This may be any object from a non-empty API group (non
 * core object) or a PersistentVolumeClaim object.
 * When this field is specified, volume binding will only succeed if the type of
 * the specified object matches some installed volume populator or dynamic
 * provisioner.
 * This field will replace the functionality of the dataSource field and as such
 * if both fields are non-empty, they must have the same value. For backwards
 * compatibility, when namespace isn't specified in dataSourceRef,
 * both fields (dataSource and dataSourceRef) will be set to the same
 * value automatically if one of them is empty and the other is non-empty.
 * When namespace is specified in dataSourceRef,
 * dataSource isn't set to the same value and must be empty.
 * There are three important differences between dataSource and dataSourceRef:
 * * While dataSource only allows two specific types of objects, dataSourceRef
 * allows any non-core object, as well as PersistentVolumeClaim objects.
 * * While dataSource ignores disallowed values (dropping them), dataSourceRef
 * preserves all values, and generates an error if a disallowed value is
 * specified.
 * * While dataSource only allows local objects, dataSourceRef allows objects
 * in any namespaces.
 * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
 * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
 *
 * @schema ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef
 */
export interface ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of resource being referenced
   * Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
   * (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef(obj: ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * resources represents the minimum resources the volume should have.
 * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
 * that are lower than previous value but must still be higher than capacity recorded in the
 * status field of the claim.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
 *
 * @schema ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecResources
 */
export interface ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecResources {
  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecResources#limits
   */
  readonly limits?: { [key: string]: ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecResources#requests
   */
  readonly requests?: { [key: string]: ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests };

}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecResources(obj: ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * selector is a label query over volumes to consider for binding.
 *
 * @schema ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecSelector
 */
export interface ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecSelector#matchExpressions
   */
  readonly matchExpressions?: ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecSelector(obj: ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Select all ClusterTrustBundles that match this label selector.  Only has
 * effect if signerName is set.  Mutually-exclusive with name.  If unset,
 * interpreted as "match nothing".  If set but empty, interpreted as "match
 * everything".
 *
 * @schema ThanosRulerSpecVolumesProjectedSourcesClusterTrustBundleLabelSelector
 */
export interface ThanosRulerSpecVolumesProjectedSourcesClusterTrustBundleLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ThanosRulerSpecVolumesProjectedSourcesClusterTrustBundleLabelSelector#matchExpressions
   */
  readonly matchExpressions?: ThanosRulerSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ThanosRulerSpecVolumesProjectedSourcesClusterTrustBundleLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesProjectedSourcesClusterTrustBundleLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesProjectedSourcesClusterTrustBundleLabelSelector(obj: ThanosRulerSpecVolumesProjectedSourcesClusterTrustBundleLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ThanosRulerSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema ThanosRulerSpecVolumesProjectedSourcesConfigMapItems
 */
export interface ThanosRulerSpecVolumesProjectedSourcesConfigMapItems {
  /**
   * key is the key to project.
   *
   * @schema ThanosRulerSpecVolumesProjectedSourcesConfigMapItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema ThanosRulerSpecVolumesProjectedSourcesConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to.
   * May not be an absolute path.
   * May not contain the path element '..'.
   * May not start with the string '..'.
   *
   * @schema ThanosRulerSpecVolumesProjectedSourcesConfigMapItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesProjectedSourcesConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesProjectedSourcesConfigMapItems(obj: ThanosRulerSpecVolumesProjectedSourcesConfigMapItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DownwardAPIVolumeFile represents information to create the file containing the pod field
 *
 * @schema ThanosRulerSpecVolumesProjectedSourcesDownwardApiItems
 */
export interface ThanosRulerSpecVolumesProjectedSourcesDownwardApiItems {
  /**
   * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
   *
   * @schema ThanosRulerSpecVolumesProjectedSourcesDownwardApiItems#fieldRef
   */
  readonly fieldRef?: ThanosRulerSpecVolumesProjectedSourcesDownwardApiItemsFieldRef;

  /**
   * Optional: mode bits used to set permissions on this file, must be an octal value
   * between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema ThanosRulerSpecVolumesProjectedSourcesDownwardApiItems#mode
   */
  readonly mode?: number;

  /**
   * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
   *
   * @schema ThanosRulerSpecVolumesProjectedSourcesDownwardApiItems#path
   */
  readonly path: string;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
   *
   * @schema ThanosRulerSpecVolumesProjectedSourcesDownwardApiItems#resourceFieldRef
   */
  readonly resourceFieldRef?: ThanosRulerSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef;

}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesProjectedSourcesDownwardApiItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesProjectedSourcesDownwardApiItems(obj: ThanosRulerSpecVolumesProjectedSourcesDownwardApiItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fieldRef': toJson_ThanosRulerSpecVolumesProjectedSourcesDownwardApiItemsFieldRef(obj.fieldRef),
    'mode': obj.mode,
    'path': obj.path,
    'resourceFieldRef': toJson_ThanosRulerSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef(obj.resourceFieldRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema ThanosRulerSpecVolumesProjectedSourcesSecretItems
 */
export interface ThanosRulerSpecVolumesProjectedSourcesSecretItems {
  /**
   * key is the key to project.
   *
   * @schema ThanosRulerSpecVolumesProjectedSourcesSecretItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema ThanosRulerSpecVolumesProjectedSourcesSecretItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to.
   * May not be an absolute path.
   * May not contain the path element '..'.
   * May not start with the string '..'.
   *
   * @schema ThanosRulerSpecVolumesProjectedSourcesSecretItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesProjectedSourcesSecretItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesProjectedSourcesSecretItems(obj: ThanosRulerSpecVolumesProjectedSourcesSecretItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecResourcesLimits
 */
export class ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecResourcesLimits {
  public static fromNumber(value: number): ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecResourcesLimits(value);
  }
  public static fromString(value: string): ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecResourcesRequests
 */
export class ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecResourcesRequests {
  public static fromNumber(value: number): ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecResourcesRequests(value);
  }
  public static fromString(value: string): ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions
 */
export interface ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(obj: ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits
 */
export class ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
  public static fromNumber(value: number): ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits(value);
  }
  public static fromString(value: string): ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests
 */
export class ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
  public static fromNumber(value: number): ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests(value);
  }
  public static fromString(value: string): ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions
 */
export interface ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(obj: ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ThanosRulerSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions
 */
export interface ThanosRulerSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ThanosRulerSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ThanosRulerSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ThanosRulerSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions(obj: ThanosRulerSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
 *
 * @schema ThanosRulerSpecVolumesProjectedSourcesDownwardApiItemsFieldRef
 */
export interface ThanosRulerSpecVolumesProjectedSourcesDownwardApiItemsFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema ThanosRulerSpecVolumesProjectedSourcesDownwardApiItemsFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema ThanosRulerSpecVolumesProjectedSourcesDownwardApiItemsFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesProjectedSourcesDownwardApiItemsFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesProjectedSourcesDownwardApiItemsFieldRef(obj: ThanosRulerSpecVolumesProjectedSourcesDownwardApiItemsFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
 *
 * @schema ThanosRulerSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef
 */
export interface ThanosRulerSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema ThanosRulerSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema ThanosRulerSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#divisor
   */
  readonly divisor?: ThanosRulerSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema ThanosRulerSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef(obj: ThanosRulerSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema ThanosRulerSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor
 */
export class ThanosRulerSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
  public static fromNumber(value: number): ThanosRulerSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
    return new ThanosRulerSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): ThanosRulerSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
    return new ThanosRulerSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

