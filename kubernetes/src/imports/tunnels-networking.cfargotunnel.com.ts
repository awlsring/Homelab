// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Tunnel is the Schema for the tunnels API
 *
 * @schema Tunnel
 */
export class Tunnel extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Tunnel"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networking.cfargotunnel.com/v1alpha1',
    kind: 'Tunnel',
  }

  /**
   * Renders a Kubernetes manifest for "Tunnel".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: TunnelProps = {}): any {
    return {
      ...Tunnel.GVK,
      ...toJson_TunnelProps(props),
    };
  }

  /**
   * Defines a "Tunnel" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: TunnelProps = {}) {
    super(scope, id, {
      ...Tunnel.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Tunnel.GVK,
      ...toJson_TunnelProps(resolved),
    };
  }
}

/**
 * Tunnel is the Schema for the tunnels API
 *
 * @schema Tunnel
 */
export interface TunnelProps {
  /**
   * @schema Tunnel#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * TunnelSpec defines the desired state of Tunnel
   *
   * @schema Tunnel#spec
   */
  readonly spec?: TunnelSpec;

}

/**
 * Converts an object of type 'TunnelProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TunnelProps(obj: TunnelProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_TunnelSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TunnelSpec defines the desired state of Tunnel
 *
 * @schema TunnelSpec
 */
export interface TunnelSpec {
  /**
   * Cloudflare Credentials
   *
   * @schema TunnelSpec#cloudflare
   */
  readonly cloudflare?: TunnelSpecCloudflare;

  /**
   * Existing tunnel object. ExistingTunnel and NewTunnel cannot be both empty and are mutually exclusive.
   *
   * @schema TunnelSpec#existingTunnel
   */
  readonly existingTunnel?: TunnelSpecExistingTunnel;

  /**
   * FallbackTarget speficies the target for requests that do not match an ingress. Defaults to http_status:404
   *
   * @default http_status:404
   * @schema TunnelSpec#fallbackTarget
   */
  readonly fallbackTarget?: string;

  /**
   * Image sets the Cloudflared Image to use. Defaults to the image set during the release of the operator.
   *
   * @default the image set during the release of the operator.
   * @schema TunnelSpec#image
   */
  readonly image?: string;

  /**
   * New tunnel object. NewTunnel and ExistingTunnel cannot be both empty and are mutually exclusive.
   *
   * @schema TunnelSpec#newTunnel
   */
  readonly newTunnel?: TunnelSpecNewTunnel;

  /**
   * NoTlsVerify disables origin TLS certificate checks when the endpoint is HTTPS.
   *
   * @schema TunnelSpec#noTlsVerify
   */
  readonly noTlsVerify?: boolean;

  /**
   * OriginCaPool speficies the secret with tls.crt (and other certs as needed to be referred in the service annotation) of the Root CA to be trusted when sending traffic to HTTPS endpoints
   *
   * @schema TunnelSpec#originCaPool
   */
  readonly originCaPool?: string;

  /**
   * Size defines the number of Daemon pods to run for this tunnel
   *
   * @schema TunnelSpec#size
   */
  readonly size?: number;

}

/**
 * Converts an object of type 'TunnelSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TunnelSpec(obj: TunnelSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloudflare': toJson_TunnelSpecCloudflare(obj.cloudflare),
    'existingTunnel': toJson_TunnelSpecExistingTunnel(obj.existingTunnel),
    'fallbackTarget': obj.fallbackTarget,
    'image': obj.image,
    'newTunnel': toJson_TunnelSpecNewTunnel(obj.newTunnel),
    'noTlsVerify': obj.noTlsVerify,
    'originCaPool': obj.originCaPool,
    'size': obj.size,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Cloudflare Credentials
 *
 * @schema TunnelSpecCloudflare
 */
export interface TunnelSpecCloudflare {
  /**
   * Key in the secret to use for Cloudflare API Key, defaults to CLOUDFLARE_API_KEY. Needs Email also to be provided. For Delete operations for new tunnels only, or as an alternate to API Token
   *
   * @schema TunnelSpecCloudflare#CLOUDFLARE_API_KEY
   */
  readonly cloudflareApiKey?: string;

  /**
   * Key in the secret to use for Cloudflare API token, defaults to CLOUDFLARE_API_TOKEN
   *
   * @schema TunnelSpecCloudflare#CLOUDFLARE_API_TOKEN
   */
  readonly cloudflareApiToken?: string;

  /**
   * Key in the secret to use as credentials.json for an existing tunnel, defaults to CLOUDFLARE_TUNNEL_CREDENTIAL_FILE
   *
   * @schema TunnelSpecCloudflare#CLOUDFLARE_TUNNEL_CREDENTIAL_FILE
   */
  readonly cloudflareTunnelCredentialFile?: string;

  /**
   * Key in the secret to use as tunnel secret for an existing tunnel, defaults to CLOUDFLARE_TUNNEL_CREDENTIAL_SECRET
   *
   * @schema TunnelSpecCloudflare#CLOUDFLARE_TUNNEL_CREDENTIAL_SECRET
   */
  readonly cloudflareTunnelCredentialSecret?: string;

  /**
   * Account ID in Cloudflare. AccountId and AccountName cannot be both empty. If both are provided, Account ID is used if valid, else falls back to Account Name.
   *
   * @schema TunnelSpecCloudflare#accountId
   */
  readonly accountId?: string;

  /**
   * Account Name in Cloudflare. AccountName and AccountId cannot be both empty. If both are provided, Account ID is used if valid, else falls back to Account Name.
   *
   * @schema TunnelSpecCloudflare#accountName
   */
  readonly accountName?: string;

  /**
   * Cloudflare Domain to which this tunnel belongs to
   *
   * @schema TunnelSpecCloudflare#domain
   */
  readonly domain?: string;

  /**
   * Email to use along with API Key for Delete operations for new tunnels only, or as an alternate to API Token
   *
   * @schema TunnelSpecCloudflare#email
   */
  readonly email?: string;

  /**
   * Secret containing Cloudflare API key/token
   *
   * @schema TunnelSpecCloudflare#secret
   */
  readonly secret?: string;

}

/**
 * Converts an object of type 'TunnelSpecCloudflare' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TunnelSpecCloudflare(obj: TunnelSpecCloudflare | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'CLOUDFLARE_API_KEY': obj.cloudflareApiKey,
    'CLOUDFLARE_API_TOKEN': obj.cloudflareApiToken,
    'CLOUDFLARE_TUNNEL_CREDENTIAL_FILE': obj.cloudflareTunnelCredentialFile,
    'CLOUDFLARE_TUNNEL_CREDENTIAL_SECRET': obj.cloudflareTunnelCredentialSecret,
    'accountId': obj.accountId,
    'accountName': obj.accountName,
    'domain': obj.domain,
    'email': obj.email,
    'secret': obj.secret,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Existing tunnel object. ExistingTunnel and NewTunnel cannot be both empty and are mutually exclusive.
 *
 * @schema TunnelSpecExistingTunnel
 */
export interface TunnelSpecExistingTunnel {
  /**
   * Existing Tunnel ID to run on. Tunnel ID and Tunnel Name cannot be both empty. If both are provided, ID is used if valid, else falls back to Name.
   *
   * @schema TunnelSpecExistingTunnel#id
   */
  readonly id?: string;

  /**
   * Existing Tunnel name to run on. Tunnel Name and Tunnel ID cannot be both empty. If both are provided, ID is used if valid, else falls back to Name.
   *
   * @schema TunnelSpecExistingTunnel#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'TunnelSpecExistingTunnel' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TunnelSpecExistingTunnel(obj: TunnelSpecExistingTunnel | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'id': obj.id,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * New tunnel object. NewTunnel and ExistingTunnel cannot be both empty and are mutually exclusive.
 *
 * @schema TunnelSpecNewTunnel
 */
export interface TunnelSpecNewTunnel {
  /**
   * Tunnel name to create on Cloudflare.
   *
   * @schema TunnelSpecNewTunnel#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'TunnelSpecNewTunnel' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TunnelSpecNewTunnel(obj: TunnelSpecNewTunnel | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

