// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * ClusterPolicy declares validation, mutation, and generation behaviors for matching resources.
 *
 * @schema ClusterPolicy
 */
export class ClusterPolicy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ClusterPolicy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'kyverno.io/v1',
    kind: 'ClusterPolicy',
  }

  /**
   * Renders a Kubernetes manifest for "ClusterPolicy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ClusterPolicyProps): any {
    return {
      ...ClusterPolicy.GVK,
      ...toJson_ClusterPolicyProps(props),
    };
  }

  /**
   * Defines a "ClusterPolicy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ClusterPolicyProps) {
    super(scope, id, {
      ...ClusterPolicy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ClusterPolicy.GVK,
      ...toJson_ClusterPolicyProps(resolved),
    };
  }
}

/**
 * ClusterPolicy declares validation, mutation, and generation behaviors for matching resources.
 *
 * @schema ClusterPolicy
 */
export interface ClusterPolicyProps {
  /**
   * @schema ClusterPolicy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Spec declares policy behaviors.
   *
   * @schema ClusterPolicy#spec
   */
  readonly spec: ClusterPolicySpec;

}

/**
 * Converts an object of type 'ClusterPolicyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyProps(obj: ClusterPolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ClusterPolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Spec declares policy behaviors.
 *
 * @schema ClusterPolicySpec
 */
export interface ClusterPolicySpec {
  /**
   * Admission controls if rules are applied during admission.
   * Optional. Default value is "true".
   *
   * @schema ClusterPolicySpec#admission
   */
  readonly admission?: boolean;

  /**
   * ApplyRules controls how rules in a policy are applied. Rule are processed in
   * the order of declaration. When set to `One` processing stops after a rule has
   * been applied i.e. the rule matches and results in a pass, fail, or error. When
   * set to `All` all rules in the policy are processed. The default is `All`.
   *
   * @schema ClusterPolicySpec#applyRules
   */
  readonly applyRules?: ClusterPolicySpecApplyRules;

  /**
   * Background controls if rules are applied to existing resources during a background scan.
   * Optional. Default value is "true". The value must be set to "false" if the policy rule
   * uses variables that are only available in the admission review request (e.g. user name).
   *
   * @schema ClusterPolicySpec#background
   */
  readonly background?: boolean;

  /**
   * EmitWarning enables API response warnings for mutate policy rules or validate policy rules with validationFailureAction set to Audit.
   * Enabling this option will extend admission request processing times. The default value is "false".
   *
   * @schema ClusterPolicySpec#emitWarning
   */
  readonly emitWarning?: boolean;

  /**
   * Deprecated, use failurePolicy under the webhookConfiguration instead.
   *
   * @schema ClusterPolicySpec#failurePolicy
   */
  readonly failurePolicy?: ClusterPolicySpecFailurePolicy;

  /**
   * Deprecated, use generateExisting under the generate rule instead
   *
   * @schema ClusterPolicySpec#generateExisting
   */
  readonly generateExisting?: boolean;

  /**
   * Deprecated, use generateExisting instead
   *
   * @schema ClusterPolicySpec#generateExistingOnPolicyUpdate
   */
  readonly generateExistingOnPolicyUpdate?: boolean;

  /**
   * Deprecated, use mutateExistingOnPolicyUpdate under the mutate rule instead
   *
   * @schema ClusterPolicySpec#mutateExistingOnPolicyUpdate
   */
  readonly mutateExistingOnPolicyUpdate?: boolean;

  /**
   * Rules is a list of Rule instances. A Policy contains multiple rules and
   * each rule can validate, mutate, or generate resources.
   *
   * @schema ClusterPolicySpec#rules
   */
  readonly rules?: ClusterPolicySpecRules[];

  /**
   * Deprecated.
   *
   * @schema ClusterPolicySpec#schemaValidation
   */
  readonly schemaValidation?: boolean;

  /**
   * UseServerSideApply controls whether to use server-side apply for generate rules
   * If is set to "true" create & update for generate rules will use apply instead of create/update.
   * Defaults to "false" if not specified.
   *
   * @default false" if not specified.
   * @schema ClusterPolicySpec#useServerSideApply
   */
  readonly useServerSideApply?: boolean;

  /**
   * Deprecated, use validationFailureAction under the validate rule instead.
   *
   * @schema ClusterPolicySpec#validationFailureAction
   */
  readonly validationFailureAction?: ClusterPolicySpecValidationFailureAction;

  /**
   * Deprecated, use validationFailureActionOverrides under the validate rule instead.
   *
   * @schema ClusterPolicySpec#validationFailureActionOverrides
   */
  readonly validationFailureActionOverrides?: ClusterPolicySpecValidationFailureActionOverrides[];

  /**
   * WebhookConfiguration specifies the custom configuration for Kubernetes admission webhookconfiguration.
   *
   * @schema ClusterPolicySpec#webhookConfiguration
   */
  readonly webhookConfiguration?: ClusterPolicySpecWebhookConfiguration;

  /**
   * Deprecated, use webhookTimeoutSeconds under webhookConfiguration instead.
   *
   * @schema ClusterPolicySpec#webhookTimeoutSeconds
   */
  readonly webhookTimeoutSeconds?: number;

}

/**
 * Converts an object of type 'ClusterPolicySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpec(obj: ClusterPolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'admission': obj.admission,
    'applyRules': obj.applyRules,
    'background': obj.background,
    'emitWarning': obj.emitWarning,
    'failurePolicy': obj.failurePolicy,
    'generateExisting': obj.generateExisting,
    'generateExistingOnPolicyUpdate': obj.generateExistingOnPolicyUpdate,
    'mutateExistingOnPolicyUpdate': obj.mutateExistingOnPolicyUpdate,
    'rules': obj.rules?.map(y => toJson_ClusterPolicySpecRules(y)),
    'schemaValidation': obj.schemaValidation,
    'useServerSideApply': obj.useServerSideApply,
    'validationFailureAction': obj.validationFailureAction,
    'validationFailureActionOverrides': obj.validationFailureActionOverrides?.map(y => toJson_ClusterPolicySpecValidationFailureActionOverrides(y)),
    'webhookConfiguration': toJson_ClusterPolicySpecWebhookConfiguration(obj.webhookConfiguration),
    'webhookTimeoutSeconds': obj.webhookTimeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ApplyRules controls how rules in a policy are applied. Rule are processed in
 * the order of declaration. When set to `One` processing stops after a rule has
 * been applied i.e. the rule matches and results in a pass, fail, or error. When
 * set to `All` all rules in the policy are processed. The default is `All`.
 *
 * @schema ClusterPolicySpecApplyRules
 */
export enum ClusterPolicySpecApplyRules {
  /** All */
  ALL = "All",
  /** One */
  ONE = "One",
}

/**
 * Deprecated, use failurePolicy under the webhookConfiguration instead.
 *
 * @schema ClusterPolicySpecFailurePolicy
 */
export enum ClusterPolicySpecFailurePolicy {
  /** Ignore */
  IGNORE = "Ignore",
  /** Fail */
  FAIL = "Fail",
}

/**
 * Rule defines a validation, mutation, or generation control for matching resources.
 * Each rules contains a match declaration to select resources, and an optional exclude
 * declaration to specify which resources to exclude.
 *
 * @schema ClusterPolicySpecRules
 */
export interface ClusterPolicySpecRules {
  /**
   * CELPreconditions are used to determine if a policy rule should be applied by evaluating a
   * set of CEL conditions. It can only be used with the validate.cel subrule
   *
   * @schema ClusterPolicySpecRules#celPreconditions
   */
  readonly celPreconditions?: ClusterPolicySpecRulesCelPreconditions[];

  /**
   * Context defines variables and data sources that can be used during rule execution.
   *
   * @schema ClusterPolicySpecRules#context
   */
  readonly context?: ClusterPolicySpecRulesContext[];

  /**
   * ExcludeResources defines when this policy rule should not be applied. The exclude
   * criteria can include resource information (e.g. kind, name, namespace, labels)
   * and admission review request information like the name or role.
   *
   * @schema ClusterPolicySpecRules#exclude
   */
  readonly exclude?: ClusterPolicySpecRulesExclude;

  /**
   * Generation is used to create new resources.
   *
   * @schema ClusterPolicySpecRules#generate
   */
  readonly generate?: ClusterPolicySpecRulesGenerate;

  /**
   * ImageExtractors defines a mapping from kinds to ImageExtractorConfigs.
   * This config is only valid for verifyImages rules.
   *
   * @schema ClusterPolicySpecRules#imageExtractors
   */
  readonly imageExtractors?: { [key: string]: ClusterPolicySpecRulesImageExtractors[] };

  /**
   * MatchResources defines when this policy rule should be applied. The match
   * criteria can include resource information (e.g. kind, name, namespace, labels)
   * and admission review request information like the user name or role.
   * At least one kind is required.
   *
   * @schema ClusterPolicySpecRules#match
   */
  readonly match: ClusterPolicySpecRulesMatch;

  /**
   * Mutation is used to modify matching resources.
   *
   * @schema ClusterPolicySpecRules#mutate
   */
  readonly mutate?: ClusterPolicySpecRulesMutate;

  /**
   * Name is a label to identify the rule, It must be unique within the policy.
   *
   * @schema ClusterPolicySpecRules#name
   */
  readonly name: string;

  /**
   * Preconditions are used to determine if a policy rule should be applied by evaluating a
   * set of conditions. The declaration can contain nested `any` or `all` statements. A direct list
   * of conditions (without `any` or `all` statements is supported for backwards compatibility but
   * will be deprecated in the next major release.
   * See: https://kyverno.io/docs/writing-policies/preconditions/
   *
   * @schema ClusterPolicySpecRules#preconditions
   */
  readonly preconditions?: any;

  /**
   * ReportProperties are the additional properties from the rule that will be added to the policy report result
   *
   * @schema ClusterPolicySpecRules#reportProperties
   */
  readonly reportProperties?: { [key: string]: string };

  /**
   * SkipBackgroundRequests bypasses admission requests that are sent by the background controller.
   * The default value is set to "true", it must be set to "false" to apply
   * generate and mutateExisting rules to those requests.
   *
   * @schema ClusterPolicySpecRules#skipBackgroundRequests
   */
  readonly skipBackgroundRequests?: boolean;

  /**
   * Validation is used to validate matching resources.
   *
   * @schema ClusterPolicySpecRules#validate
   */
  readonly validate?: ClusterPolicySpecRulesValidate;

  /**
   * VerifyImages is used to verify image signatures and mutate them to add a digest
   *
   * @schema ClusterPolicySpecRules#verifyImages
   */
  readonly verifyImages?: ClusterPolicySpecRulesVerifyImages[];

}

/**
 * Converts an object of type 'ClusterPolicySpecRules' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRules(obj: ClusterPolicySpecRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'celPreconditions': obj.celPreconditions?.map(y => toJson_ClusterPolicySpecRulesCelPreconditions(y)),
    'context': obj.context?.map(y => toJson_ClusterPolicySpecRulesContext(y)),
    'exclude': toJson_ClusterPolicySpecRulesExclude(obj.exclude),
    'generate': toJson_ClusterPolicySpecRulesGenerate(obj.generate),
    'imageExtractors': ((obj.imageExtractors) === undefined) ? undefined : (Object.entries(obj.imageExtractors).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.map(y => toJson_ClusterPolicySpecRulesImageExtractors(y)) }), {})),
    'match': toJson_ClusterPolicySpecRulesMatch(obj.match),
    'mutate': toJson_ClusterPolicySpecRulesMutate(obj.mutate),
    'name': obj.name,
    'preconditions': obj.preconditions,
    'reportProperties': ((obj.reportProperties) === undefined) ? undefined : (Object.entries(obj.reportProperties).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'skipBackgroundRequests': obj.skipBackgroundRequests,
    'validate': toJson_ClusterPolicySpecRulesValidate(obj.validate),
    'verifyImages': obj.verifyImages?.map(y => toJson_ClusterPolicySpecRulesVerifyImages(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Deprecated, use validationFailureAction under the validate rule instead.
 *
 * @schema ClusterPolicySpecValidationFailureAction
 */
export enum ClusterPolicySpecValidationFailureAction {
  /** audit */
  AUDIT = "audit",
  /** enforce */
  ENFORCE = "enforce",
}

/**
 * @schema ClusterPolicySpecValidationFailureActionOverrides
 */
export interface ClusterPolicySpecValidationFailureActionOverrides {
  /**
   * ValidationFailureAction defines the policy validation failure action
   *
   * @schema ClusterPolicySpecValidationFailureActionOverrides#action
   */
  readonly action?: ClusterPolicySpecValidationFailureActionOverridesAction;

  /**
   * A label selector is a label query over a set of resources. The result of matchLabels and
   * matchExpressions are ANDed. An empty label selector matches all objects. A null
   * label selector matches no objects.
   *
   * @schema ClusterPolicySpecValidationFailureActionOverrides#namespaceSelector
   */
  readonly namespaceSelector?: ClusterPolicySpecValidationFailureActionOverridesNamespaceSelector;

  /**
   * @schema ClusterPolicySpecValidationFailureActionOverrides#namespaces
   */
  readonly namespaces?: string[];

}

/**
 * Converts an object of type 'ClusterPolicySpecValidationFailureActionOverrides' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecValidationFailureActionOverrides(obj: ClusterPolicySpecValidationFailureActionOverrides | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'namespaceSelector': toJson_ClusterPolicySpecValidationFailureActionOverridesNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WebhookConfiguration specifies the custom configuration for Kubernetes admission webhookconfiguration.
 *
 * @schema ClusterPolicySpecWebhookConfiguration
 */
export interface ClusterPolicySpecWebhookConfiguration {
  /**
   * FailurePolicy defines how unexpected policy errors and webhook response timeout errors are handled.
   * Rules within the same policy share the same failure behavior.
   * This field should not be accessed directly, instead `GetFailurePolicy()` should be used.
   * Allowed values are Ignore or Fail. Defaults to Fail.
   *
   * @default Fail.
   * @schema ClusterPolicySpecWebhookConfiguration#failurePolicy
   */
  readonly failurePolicy?: ClusterPolicySpecWebhookConfigurationFailurePolicy;

  /**
   * MatchCondition configures admission webhook matchConditions.
   * Requires Kubernetes 1.27 or later.
   *
   * @schema ClusterPolicySpecWebhookConfiguration#matchConditions
   */
  readonly matchConditions?: ClusterPolicySpecWebhookConfigurationMatchConditions[];

  /**
   * TimeoutSeconds specifies the maximum time in seconds allowed to apply this policy.
   * After the configured time expires, the admission request may fail, or may simply ignore the policy results,
   * based on the failure policy. The default timeout is 10s, the value must be between 1 and 30 seconds.
   *
   * @schema ClusterPolicySpecWebhookConfiguration#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'ClusterPolicySpecWebhookConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecWebhookConfiguration(obj: ClusterPolicySpecWebhookConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'failurePolicy': obj.failurePolicy,
    'matchConditions': obj.matchConditions?.map(y => toJson_ClusterPolicySpecWebhookConfigurationMatchConditions(y)),
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * MatchCondition represents a condition which must be fulfilled for a request to be sent to a webhook.
 *
 * @schema ClusterPolicySpecRulesCelPreconditions
 */
export interface ClusterPolicySpecRulesCelPreconditions {
  /**
   * Expression represents the expression which will be evaluated by CEL. Must evaluate to bool.
   * CEL expressions have access to the contents of the AdmissionRequest and Authorizer, organized into CEL variables:
   *
   * 'object' - The object from the incoming request. The value is null for DELETE requests.
   * 'oldObject' - The existing object. The value is null for CREATE requests.
   * 'request' - Attributes of the admission request(/pkg/apis/admission/types.go#AdmissionRequest).
   * 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
   * See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
   * 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
   * request resource.
   * Documentation on CEL: https://kubernetes.io/docs/reference/using-api/cel/
   *
   * Required.
   *
   * @schema ClusterPolicySpecRulesCelPreconditions#expression
   */
  readonly expression: string;

  /**
   * Name is an identifier for this match condition, used for strategic merging of MatchConditions,
   * as well as providing an identifier for logging purposes. A good name should be descriptive of
   * the associated expression.
   * Name must be a qualified name consisting of alphanumeric characters, '-', '_' or '.', and
   * must start and end with an alphanumeric character (e.g. 'MyName',  or 'my.name',  or
   * '123-abc', regex used for validation is '([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]') with an
   * optional DNS subdomain prefix and '/' (e.g. 'example.com/MyName')
   *
   * Required.
   *
   * @schema ClusterPolicySpecRulesCelPreconditions#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesCelPreconditions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesCelPreconditions(obj: ClusterPolicySpecRulesCelPreconditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'expression': obj.expression,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ContextEntry adds variables and data sources to a rule Context. Either a
 * ConfigMap reference or a APILookup must be provided.
 *
 * @schema ClusterPolicySpecRulesContext
 */
export interface ClusterPolicySpecRulesContext {
  /**
   * APICall is an HTTP request to the Kubernetes API server, or other JSON web service.
   * The data returned is stored in the context with the name for the context entry.
   *
   * @schema ClusterPolicySpecRulesContext#apiCall
   */
  readonly apiCall?: ClusterPolicySpecRulesContextApiCall;

  /**
   * ConfigMap is the ConfigMap reference.
   *
   * @schema ClusterPolicySpecRulesContext#configMap
   */
  readonly configMap?: ClusterPolicySpecRulesContextConfigMap;

  /**
   * GlobalContextEntryReference is a reference to a cached global context entry.
   *
   * @schema ClusterPolicySpecRulesContext#globalReference
   */
  readonly globalReference?: ClusterPolicySpecRulesContextGlobalReference;

  /**
   * ImageRegistry defines requests to an OCI/Docker V2 registry to fetch image
   * details.
   *
   * @schema ClusterPolicySpecRulesContext#imageRegistry
   */
  readonly imageRegistry?: ClusterPolicySpecRulesContextImageRegistry;

  /**
   * Name is the variable name.
   *
   * @schema ClusterPolicySpecRulesContext#name
   */
  readonly name: string;

  /**
   * Variable defines an arbitrary JMESPath context variable that can be defined inline.
   *
   * @schema ClusterPolicySpecRulesContext#variable
   */
  readonly variable?: ClusterPolicySpecRulesContextVariable;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesContext(obj: ClusterPolicySpecRulesContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiCall': toJson_ClusterPolicySpecRulesContextApiCall(obj.apiCall),
    'configMap': toJson_ClusterPolicySpecRulesContextConfigMap(obj.configMap),
    'globalReference': toJson_ClusterPolicySpecRulesContextGlobalReference(obj.globalReference),
    'imageRegistry': toJson_ClusterPolicySpecRulesContextImageRegistry(obj.imageRegistry),
    'name': obj.name,
    'variable': toJson_ClusterPolicySpecRulesContextVariable(obj.variable),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ExcludeResources defines when this policy rule should not be applied. The exclude
 * criteria can include resource information (e.g. kind, name, namespace, labels)
 * and admission review request information like the name or role.
 *
 * @schema ClusterPolicySpecRulesExclude
 */
export interface ClusterPolicySpecRulesExclude {
  /**
   * All allows specifying resources which will be ANDed
   *
   * @schema ClusterPolicySpecRulesExclude#all
   */
  readonly all?: ClusterPolicySpecRulesExcludeAll[];

  /**
   * Any allows specifying resources which will be ORed
   *
   * @schema ClusterPolicySpecRulesExclude#any
   */
  readonly any?: ClusterPolicySpecRulesExcludeAny[];

  /**
   * ClusterRoles is the list of cluster-wide role names for the user.
   *
   * @schema ClusterPolicySpecRulesExclude#clusterRoles
   */
  readonly clusterRoles?: string[];

  /**
   * ResourceDescription contains information about the resource being created or modified.
   * Requires at least one tag to be specified when under MatchResources.
   * Specifying ResourceDescription directly under match is being deprecated.
   * Please specify under "any" or "all" instead.
   *
   * @schema ClusterPolicySpecRulesExclude#resources
   */
  readonly resources?: ClusterPolicySpecRulesExcludeResources;

  /**
   * Roles is the list of namespaced role names for the user.
   *
   * @schema ClusterPolicySpecRulesExclude#roles
   */
  readonly roles?: string[];

  /**
   * Subjects is the list of subject names like users, user groups, and service accounts.
   *
   * @schema ClusterPolicySpecRulesExclude#subjects
   */
  readonly subjects?: ClusterPolicySpecRulesExcludeSubjects[];

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesExclude' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesExclude(obj: ClusterPolicySpecRulesExclude | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'all': obj.all?.map(y => toJson_ClusterPolicySpecRulesExcludeAll(y)),
    'any': obj.any?.map(y => toJson_ClusterPolicySpecRulesExcludeAny(y)),
    'clusterRoles': obj.clusterRoles?.map(y => y),
    'resources': toJson_ClusterPolicySpecRulesExcludeResources(obj.resources),
    'roles': obj.roles?.map(y => y),
    'subjects': obj.subjects?.map(y => toJson_ClusterPolicySpecRulesExcludeSubjects(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Generation is used to create new resources.
 *
 * @schema ClusterPolicySpecRulesGenerate
 */
export interface ClusterPolicySpecRulesGenerate {
  /**
   * APIVersion specifies resource apiVersion.
   *
   * @schema ClusterPolicySpecRulesGenerate#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Clone specifies the source resource used to populate each generated resource.
   * At most one of Data or Clone can be specified. If neither are provided, the generated
   * resource will be created with default data only.
   *
   * @schema ClusterPolicySpecRulesGenerate#clone
   */
  readonly clone?: ClusterPolicySpecRulesGenerateClone;

  /**
   * CloneList specifies the list of source resource used to populate each generated resource.
   *
   * @schema ClusterPolicySpecRulesGenerate#cloneList
   */
  readonly cloneList?: ClusterPolicySpecRulesGenerateCloneList;

  /**
   * Data provides the resource declaration used to populate each generated resource.
   * At most one of Data or Clone must be specified. If neither are provided, the generated
   * resource will be created with default data only.
   *
   * @schema ClusterPolicySpecRulesGenerate#data
   */
  readonly data?: any;

  /**
   * ForEach applies generate rules to a list of sub-elements by creating a context for each entry in the list and looping over it to apply the specified logic.
   *
   * @schema ClusterPolicySpecRulesGenerate#foreach
   */
  readonly foreach?: ClusterPolicySpecRulesGenerateForeach[];

  /**
   * GenerateExisting controls whether to trigger the rule in existing resources
   * If is set to "true" the rule will be triggered and applied to existing matched resources.
   *
   * @schema ClusterPolicySpecRulesGenerate#generateExisting
   */
  readonly generateExisting?: boolean;

  /**
   * Kind specifies resource kind.
   *
   * @schema ClusterPolicySpecRulesGenerate#kind
   */
  readonly kind?: string;

  /**
   * Name specifies the resource name.
   *
   * @schema ClusterPolicySpecRulesGenerate#name
   */
  readonly name?: string;

  /**
   * Namespace specifies resource namespace.
   *
   * @schema ClusterPolicySpecRulesGenerate#namespace
   */
  readonly namespace?: string;

  /**
   * OrphanDownstreamOnPolicyDelete controls whether generated resources should be deleted when the rule that generated
   * them is deleted with synchronization enabled. This option is only applicable to generate rules of the data type.
   * See https://kyverno.io/docs/writing-policies/generate/#data-examples.
   * Defaults to "false" if not specified.
   *
   * @default false" if not specified.
   * @schema ClusterPolicySpecRulesGenerate#orphanDownstreamOnPolicyDelete
   */
  readonly orphanDownstreamOnPolicyDelete?: boolean;

  /**
   * Synchronize controls if generated resources should be kept in-sync with their source resource.
   * If Synchronize is set to "true" changes to generated resources will be overwritten with resource
   * data from Data or the resource specified in the Clone declaration.
   * Optional. Defaults to "false" if not specified.
   *
   * @default false" if not specified.
   * @schema ClusterPolicySpecRulesGenerate#synchronize
   */
  readonly synchronize?: boolean;

  /**
   * UID specifies the resource uid.
   *
   * @schema ClusterPolicySpecRulesGenerate#uid
   */
  readonly uid?: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesGenerate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesGenerate(obj: ClusterPolicySpecRulesGenerate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'clone': toJson_ClusterPolicySpecRulesGenerateClone(obj.clone),
    'cloneList': toJson_ClusterPolicySpecRulesGenerateCloneList(obj.cloneList),
    'data': obj.data,
    'foreach': obj.foreach?.map(y => toJson_ClusterPolicySpecRulesGenerateForeach(y)),
    'generateExisting': obj.generateExisting,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
    'orphanDownstreamOnPolicyDelete': obj.orphanDownstreamOnPolicyDelete,
    'synchronize': obj.synchronize,
    'uid': obj.uid,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterPolicySpecRulesImageExtractors
 */
export interface ClusterPolicySpecRulesImageExtractors {
  /**
   * JMESPath is an optional JMESPath expression to apply to the image value.
   * This is useful when the extracted image begins with a prefix like 'docker://'.
   * The 'trim_prefix' function may be used to trim the prefix: trim_prefix(@, 'docker://').
   * Note - Image digest mutation may not be used when applying a JMESPAth to an image.
   *
   * @schema ClusterPolicySpecRulesImageExtractors#jmesPath
   */
  readonly jmesPath?: string;

  /**
   * Key is an optional name of the field within 'path' that will be used to uniquely identify an image.
   * Note - this field MUST be unique.
   *
   * @schema ClusterPolicySpecRulesImageExtractors#key
   */
  readonly key?: string;

  /**
   * Name is the entry the image will be available under 'images.<name>' in the context.
   * If this field is not defined, image entries will appear under 'images.custom'.
   *
   * @schema ClusterPolicySpecRulesImageExtractors#name
   */
  readonly name?: string;

  /**
   * Path is the path to the object containing the image field in a custom resource.
   * It should be slash-separated. Each slash-separated key must be a valid YAML key or a wildcard '*'.
   * Wildcard keys are expanded in case of arrays or objects.
   *
   * @schema ClusterPolicySpecRulesImageExtractors#path
   */
  readonly path: string;

  /**
   * Value is an optional name of the field within 'path' that points to the image URI.
   * This is useful when a custom 'key' is also defined.
   *
   * @schema ClusterPolicySpecRulesImageExtractors#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesImageExtractors' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesImageExtractors(obj: ClusterPolicySpecRulesImageExtractors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'jmesPath': obj.jmesPath,
    'key': obj.key,
    'name': obj.name,
    'path': obj.path,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * MatchResources defines when this policy rule should be applied. The match
 * criteria can include resource information (e.g. kind, name, namespace, labels)
 * and admission review request information like the user name or role.
 * At least one kind is required.
 *
 * @schema ClusterPolicySpecRulesMatch
 */
export interface ClusterPolicySpecRulesMatch {
  /**
   * All allows specifying resources which will be ANDed
   *
   * @schema ClusterPolicySpecRulesMatch#all
   */
  readonly all?: ClusterPolicySpecRulesMatchAll[];

  /**
   * Any allows specifying resources which will be ORed
   *
   * @schema ClusterPolicySpecRulesMatch#any
   */
  readonly any?: ClusterPolicySpecRulesMatchAny[];

  /**
   * ClusterRoles is the list of cluster-wide role names for the user.
   *
   * @schema ClusterPolicySpecRulesMatch#clusterRoles
   */
  readonly clusterRoles?: string[];

  /**
   * ResourceDescription contains information about the resource being created or modified.
   * Requires at least one tag to be specified when under MatchResources.
   * Specifying ResourceDescription directly under match is being deprecated.
   * Please specify under "any" or "all" instead.
   *
   * @schema ClusterPolicySpecRulesMatch#resources
   */
  readonly resources?: ClusterPolicySpecRulesMatchResources;

  /**
   * Roles is the list of namespaced role names for the user.
   *
   * @schema ClusterPolicySpecRulesMatch#roles
   */
  readonly roles?: string[];

  /**
   * Subjects is the list of subject names like users, user groups, and service accounts.
   *
   * @schema ClusterPolicySpecRulesMatch#subjects
   */
  readonly subjects?: ClusterPolicySpecRulesMatchSubjects[];

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMatch(obj: ClusterPolicySpecRulesMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'all': obj.all?.map(y => toJson_ClusterPolicySpecRulesMatchAll(y)),
    'any': obj.any?.map(y => toJson_ClusterPolicySpecRulesMatchAny(y)),
    'clusterRoles': obj.clusterRoles?.map(y => y),
    'resources': toJson_ClusterPolicySpecRulesMatchResources(obj.resources),
    'roles': obj.roles?.map(y => y),
    'subjects': obj.subjects?.map(y => toJson_ClusterPolicySpecRulesMatchSubjects(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Mutation is used to modify matching resources.
 *
 * @schema ClusterPolicySpecRulesMutate
 */
export interface ClusterPolicySpecRulesMutate {
  /**
   * ForEach applies mutation rules to a list of sub-elements by creating a context for each entry in the list and looping over it to apply the specified logic.
   *
   * @schema ClusterPolicySpecRulesMutate#foreach
   */
  readonly foreach?: ClusterPolicySpecRulesMutateForeach[];

  /**
   * MutateExistingOnPolicyUpdate controls if the mutateExisting rule will be applied on policy events.
   *
   * @schema ClusterPolicySpecRulesMutate#mutateExistingOnPolicyUpdate
   */
  readonly mutateExistingOnPolicyUpdate?: boolean;

  /**
   * PatchStrategicMerge is a strategic merge patch used to modify resources.
   * See https://kubernetes.io/docs/tasks/manage-kubernetes-objects/update-api-object-kubectl-patch/
   * and https://kubectl.docs.kubernetes.io/references/kustomize/kustomization/patchesstrategicmerge/.
   *
   * @schema ClusterPolicySpecRulesMutate#patchStrategicMerge
   */
  readonly patchStrategicMerge?: any;

  /**
   * PatchesJSON6902 is a list of RFC 6902 JSON Patch declarations used to modify resources.
   * See https://tools.ietf.org/html/rfc6902 and https://kubectl.docs.kubernetes.io/references/kustomize/kustomization/patchesjson6902/.
   *
   * @schema ClusterPolicySpecRulesMutate#patchesJson6902
   */
  readonly patchesJson6902?: string;

  /**
   * Targets defines the target resources to be mutated.
   *
   * @schema ClusterPolicySpecRulesMutate#targets
   */
  readonly targets?: ClusterPolicySpecRulesMutateTargets[];

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMutate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMutate(obj: ClusterPolicySpecRulesMutate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'foreach': obj.foreach?.map(y => toJson_ClusterPolicySpecRulesMutateForeach(y)),
    'mutateExistingOnPolicyUpdate': obj.mutateExistingOnPolicyUpdate,
    'patchStrategicMerge': obj.patchStrategicMerge,
    'patchesJson6902': obj.patchesJson6902,
    'targets': obj.targets?.map(y => toJson_ClusterPolicySpecRulesMutateTargets(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Validation is used to validate matching resources.
 *
 * @schema ClusterPolicySpecRulesValidate
 */
export interface ClusterPolicySpecRulesValidate {
  /**
   * AllowExistingViolations allows prexisting violating resources to continue violating a policy.
   *
   * @schema ClusterPolicySpecRulesValidate#allowExistingViolations
   */
  readonly allowExistingViolations?: boolean;

  /**
   * AnyPattern specifies list of validation patterns. At least one of the patterns
   * must be satisfied for the validation rule to succeed.
   *
   * @schema ClusterPolicySpecRulesValidate#anyPattern
   */
  readonly anyPattern?: any;

  /**
   * Assert defines a kyverno-json assertion tree.
   *
   * @schema ClusterPolicySpecRulesValidate#assert
   */
  readonly assert?: any;

  /**
   * CEL allows validation checks using the Common Expression Language (https://kubernetes.io/docs/reference/using-api/cel/).
   *
   * @schema ClusterPolicySpecRulesValidate#cel
   */
  readonly cel?: ClusterPolicySpecRulesValidateCel;

  /**
   * Deny defines conditions used to pass or fail a validation rule.
   *
   * @schema ClusterPolicySpecRulesValidate#deny
   */
  readonly deny?: ClusterPolicySpecRulesValidateDeny;

  /**
   * FailureAction defines if a validation policy rule violation should block
   * the admission review request (Enforce), or allow (Audit) the admission review request
   * and report an error in a policy report. Optional.
   * Allowed values are Audit or Enforce.
   *
   * @schema ClusterPolicySpecRulesValidate#failureAction
   */
  readonly failureAction?: ClusterPolicySpecRulesValidateFailureAction;

  /**
   * FailureActionOverrides is a Cluster Policy attribute that specifies FailureAction
   * namespace-wise. It overrides FailureAction for the specified namespaces.
   *
   * @schema ClusterPolicySpecRulesValidate#failureActionOverrides
   */
  readonly failureActionOverrides?: ClusterPolicySpecRulesValidateFailureActionOverrides[];

  /**
   * ForEach applies validate rules to a list of sub-elements by creating a context for each entry in the list and looping over it to apply the specified logic.
   *
   * @schema ClusterPolicySpecRulesValidate#foreach
   */
  readonly foreach?: ClusterPolicySpecRulesValidateForeach[];

  /**
   * Manifest specifies conditions for manifest verification
   *
   * @schema ClusterPolicySpecRulesValidate#manifests
   */
  readonly manifests?: ClusterPolicySpecRulesValidateManifests;

  /**
   * Message specifies a custom message to be displayed on failure.
   *
   * @schema ClusterPolicySpecRulesValidate#message
   */
  readonly message?: string;

  /**
   * Pattern specifies an overlay-style pattern used to check resources.
   *
   * @schema ClusterPolicySpecRulesValidate#pattern
   */
  readonly pattern?: any;

  /**
   * PodSecurity applies exemptions for Kubernetes Pod Security admission
   * by specifying exclusions for Pod Security Standards controls.
   *
   * @schema ClusterPolicySpecRulesValidate#podSecurity
   */
  readonly podSecurity?: ClusterPolicySpecRulesValidatePodSecurity;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesValidate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesValidate(obj: ClusterPolicySpecRulesValidate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowExistingViolations': obj.allowExistingViolations,
    'anyPattern': obj.anyPattern,
    'assert': obj.assert,
    'cel': toJson_ClusterPolicySpecRulesValidateCel(obj.cel),
    'deny': toJson_ClusterPolicySpecRulesValidateDeny(obj.deny),
    'failureAction': obj.failureAction,
    'failureActionOverrides': obj.failureActionOverrides?.map(y => toJson_ClusterPolicySpecRulesValidateFailureActionOverrides(y)),
    'foreach': obj.foreach?.map(y => toJson_ClusterPolicySpecRulesValidateForeach(y)),
    'manifests': toJson_ClusterPolicySpecRulesValidateManifests(obj.manifests),
    'message': obj.message,
    'pattern': obj.pattern,
    'podSecurity': toJson_ClusterPolicySpecRulesValidatePodSecurity(obj.podSecurity),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ImageVerification validates that images that match the specified pattern
 * are signed with the supplied public key. Once the image is verified it is
 * mutated to include the SHA digest retrieved during the registration.
 *
 * @schema ClusterPolicySpecRulesVerifyImages
 */
export interface ClusterPolicySpecRulesVerifyImages {
  /**
   * Deprecated.
   *
   * @schema ClusterPolicySpecRulesVerifyImages#additionalExtensions
   */
  readonly additionalExtensions?: { [key: string]: string };

  /**
   * Deprecated. Use annotations per Attestor instead.
   *
   * @schema ClusterPolicySpecRulesVerifyImages#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Attestations are optional checks for signed in-toto Statements used to verify the image.
   * See https://github.com/in-toto/attestation. Kyverno fetches signed attestations from the
   * OCI registry and decodes them into a list of Statement declarations.
   *
   * @schema ClusterPolicySpecRulesVerifyImages#attestations
   */
  readonly attestations?: ClusterPolicySpecRulesVerifyImagesAttestations[];

  /**
   * Attestors specified the required attestors (i.e. authorities)
   *
   * @schema ClusterPolicySpecRulesVerifyImages#attestors
   */
  readonly attestors?: ClusterPolicySpecRulesVerifyImagesAttestors[];

  /**
   * CosignOCI11 enables the experimental OCI 1.1 behaviour in cosign image verification.
   * Defaults to false.
   *
   * @default false.
   * @schema ClusterPolicySpecRulesVerifyImages#cosignOCI11
   */
  readonly cosignOci11?: boolean;

  /**
   * Allowed values are Audit or Enforce.
   *
   * @schema ClusterPolicySpecRulesVerifyImages#failureAction
   */
  readonly failureAction?: ClusterPolicySpecRulesVerifyImagesFailureAction;

  /**
   * Deprecated. Use ImageReferences instead.
   *
   * @schema ClusterPolicySpecRulesVerifyImages#image
   */
  readonly image?: string;

  /**
   * ImageReferences is a list of matching image reference patterns. At least one pattern in the
   * list must match the image for the rule to apply. Each image reference consists of a registry
   * address (defaults to docker.io), repository, image, and tag (defaults to latest).
   * Wildcards ('*' and '?') are allowed. See: https://kubernetes.io/docs/concepts/containers/images.
   *
   * @schema ClusterPolicySpecRulesVerifyImages#imageReferences
   */
  readonly imageReferences?: string[];

  /**
   * ImageRegistryCredentials provides credentials that will be used for authentication with registry.
   *
   * @schema ClusterPolicySpecRulesVerifyImages#imageRegistryCredentials
   */
  readonly imageRegistryCredentials?: ClusterPolicySpecRulesVerifyImagesImageRegistryCredentials;

  /**
   * Deprecated. Use KeylessAttestor instead.
   *
   * @schema ClusterPolicySpecRulesVerifyImages#issuer
   */
  readonly issuer?: string;

  /**
   * Deprecated. Use StaticKeyAttestor instead.
   *
   * @schema ClusterPolicySpecRulesVerifyImages#key
   */
  readonly key?: string;

  /**
   * MutateDigest enables replacement of image tags with digests.
   * Defaults to true.
   *
   * @default true.
   * @schema ClusterPolicySpecRulesVerifyImages#mutateDigest
   */
  readonly mutateDigest?: boolean;

  /**
   * Repository is an optional alternate OCI repository to use for image signatures and attestations that match this rule.
   * If specified Repository will override the default OCI image repository configured for the installation.
   * The repository can also be overridden per Attestor or Attestation.
   *
   * @schema ClusterPolicySpecRulesVerifyImages#repository
   */
  readonly repository?: string;

  /**
   * Required validates that images are verified i.e. have matched passed a signature or attestation check.
   *
   * @schema ClusterPolicySpecRulesVerifyImages#required
   */
  readonly required?: boolean;

  /**
   * Deprecated. Use KeylessAttestor instead.
   *
   * @schema ClusterPolicySpecRulesVerifyImages#roots
   */
  readonly roots?: string;

  /**
   * SkipImageReferences is a list of matching image reference patterns that should be skipped.
   * At least one pattern in the list must match the image for the rule to be skipped. Each image reference
   * consists of a registry address (defaults to docker.io), repository, image, and tag (defaults to latest).
   * Wildcards ('*' and '?') are allowed. See: https://kubernetes.io/docs/concepts/containers/images.
   *
   * @schema ClusterPolicySpecRulesVerifyImages#skipImageReferences
   */
  readonly skipImageReferences?: string[];

  /**
   * Deprecated. Use KeylessAttestor instead.
   *
   * @schema ClusterPolicySpecRulesVerifyImages#subject
   */
  readonly subject?: string;

  /**
   * Type specifies the method of signature validation. The allowed options
   * are Cosign, Sigstore Bundle and Notary. By default Cosign is used if a type is not specified.
   *
   * @schema ClusterPolicySpecRulesVerifyImages#type
   */
  readonly type?: ClusterPolicySpecRulesVerifyImagesType;

  /**
   * UseCache enables caching of image verify responses for this rule.
   *
   * @schema ClusterPolicySpecRulesVerifyImages#useCache
   */
  readonly useCache?: boolean;

  /**
   * Validation checks conditions across multiple image
   * verification attestations or context entries
   *
   * @schema ClusterPolicySpecRulesVerifyImages#validate
   */
  readonly validate?: ClusterPolicySpecRulesVerifyImagesValidate;

  /**
   * VerifyDigest validates that images have a digest.
   *
   * @schema ClusterPolicySpecRulesVerifyImages#verifyDigest
   */
  readonly verifyDigest?: boolean;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesVerifyImages' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesVerifyImages(obj: ClusterPolicySpecRulesVerifyImages | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalExtensions': ((obj.additionalExtensions) === undefined) ? undefined : (Object.entries(obj.additionalExtensions).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'attestations': obj.attestations?.map(y => toJson_ClusterPolicySpecRulesVerifyImagesAttestations(y)),
    'attestors': obj.attestors?.map(y => toJson_ClusterPolicySpecRulesVerifyImagesAttestors(y)),
    'cosignOCI11': obj.cosignOci11,
    'failureAction': obj.failureAction,
    'image': obj.image,
    'imageReferences': obj.imageReferences?.map(y => y),
    'imageRegistryCredentials': toJson_ClusterPolicySpecRulesVerifyImagesImageRegistryCredentials(obj.imageRegistryCredentials),
    'issuer': obj.issuer,
    'key': obj.key,
    'mutateDigest': obj.mutateDigest,
    'repository': obj.repository,
    'required': obj.required,
    'roots': obj.roots,
    'skipImageReferences': obj.skipImageReferences?.map(y => y),
    'subject': obj.subject,
    'type': obj.type,
    'useCache': obj.useCache,
    'validate': toJson_ClusterPolicySpecRulesVerifyImagesValidate(obj.validate),
    'verifyDigest': obj.verifyDigest,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ValidationFailureAction defines the policy validation failure action
 *
 * @schema ClusterPolicySpecValidationFailureActionOverridesAction
 */
export enum ClusterPolicySpecValidationFailureActionOverridesAction {
  /** audit */
  AUDIT = "audit",
  /** enforce */
  ENFORCE = "enforce",
}

/**
 * A label selector is a label query over a set of resources. The result of matchLabels and
 * matchExpressions are ANDed. An empty label selector matches all objects. A null
 * label selector matches no objects.
 *
 * @schema ClusterPolicySpecValidationFailureActionOverridesNamespaceSelector
 */
export interface ClusterPolicySpecValidationFailureActionOverridesNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterPolicySpecValidationFailureActionOverridesNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterPolicySpecValidationFailureActionOverridesNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterPolicySpecValidationFailureActionOverridesNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterPolicySpecValidationFailureActionOverridesNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecValidationFailureActionOverridesNamespaceSelector(obj: ClusterPolicySpecValidationFailureActionOverridesNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterPolicySpecValidationFailureActionOverridesNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FailurePolicy defines how unexpected policy errors and webhook response timeout errors are handled.
 * Rules within the same policy share the same failure behavior.
 * This field should not be accessed directly, instead `GetFailurePolicy()` should be used.
 * Allowed values are Ignore or Fail. Defaults to Fail.
 *
 * @default Fail.
 * @schema ClusterPolicySpecWebhookConfigurationFailurePolicy
 */
export enum ClusterPolicySpecWebhookConfigurationFailurePolicy {
  /** Ignore */
  IGNORE = "Ignore",
  /** Fail */
  FAIL = "Fail",
}

/**
 * MatchCondition represents a condition which must by fulfilled for a request to be sent to a webhook.
 *
 * @schema ClusterPolicySpecWebhookConfigurationMatchConditions
 */
export interface ClusterPolicySpecWebhookConfigurationMatchConditions {
  /**
   * Expression represents the expression which will be evaluated by CEL. Must evaluate to bool.
   * CEL expressions have access to the contents of the AdmissionRequest and Authorizer, organized into CEL variables:
   *
   * 'object' - The object from the incoming request. The value is null for DELETE requests.
   * 'oldObject' - The existing object. The value is null for CREATE requests.
   * 'request' - Attributes of the admission request(/pkg/apis/admission/types.go#AdmissionRequest).
   * 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
   * See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
   * 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
   * request resource.
   * Documentation on CEL: https://kubernetes.io/docs/reference/using-api/cel/
   *
   * Required.
   *
   * @schema ClusterPolicySpecWebhookConfigurationMatchConditions#expression
   */
  readonly expression: string;

  /**
   * Name is an identifier for this match condition, used for strategic merging of MatchConditions,
   * as well as providing an identifier for logging purposes. A good name should be descriptive of
   * the associated expression.
   * Name must be a qualified name consisting of alphanumeric characters, '-', '_' or '.', and
   * must start and end with an alphanumeric character (e.g. 'MyName',  or 'my.name',  or
   * '123-abc', regex used for validation is '([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]') with an
   * optional DNS subdomain prefix and '/' (e.g. 'example.com/MyName')
   *
   * Required.
   *
   * @schema ClusterPolicySpecWebhookConfigurationMatchConditions#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecWebhookConfigurationMatchConditions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecWebhookConfigurationMatchConditions(obj: ClusterPolicySpecWebhookConfigurationMatchConditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'expression': obj.expression,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * APICall is an HTTP request to the Kubernetes API server, or other JSON web service.
 * The data returned is stored in the context with the name for the context entry.
 *
 * @schema ClusterPolicySpecRulesContextApiCall
 */
export interface ClusterPolicySpecRulesContextApiCall {
  /**
   * The data object specifies the POST data sent to the server.
   * Only applicable when the method field is set to POST.
   *
   * @schema ClusterPolicySpecRulesContextApiCall#data
   */
  readonly data?: ClusterPolicySpecRulesContextApiCallData[];

  /**
   * Default is an optional arbitrary JSON object that the context
   * value is set to, if the apiCall returns error.
   *
   * @default an optional arbitrary JSON object that the context
   * @schema ClusterPolicySpecRulesContextApiCall#default
   */
  readonly default?: any;

  /**
   * JMESPath is an optional JSON Match Expression that can be used to
   * transform the JSON response returned from the server. For example
   * a JMESPath of "items | length(@)" applied to the API server response
   * for the URLPath "/apis/apps/v1/deployments" will return the total count
   * of deployments across all namespaces.
   *
   * @schema ClusterPolicySpecRulesContextApiCall#jmesPath
   */
  readonly jmesPath?: string;

  /**
   * Method is the HTTP request type (GET or POST). Defaults to GET.
   *
   * @default GET.
   * @schema ClusterPolicySpecRulesContextApiCall#method
   */
  readonly method?: ClusterPolicySpecRulesContextApiCallMethod;

  /**
   * Service is an API call to a JSON web service.
   * This is used for non-Kubernetes API server calls.
   * It's mutually exclusive with the URLPath field.
   *
   * @schema ClusterPolicySpecRulesContextApiCall#service
   */
  readonly service?: ClusterPolicySpecRulesContextApiCallService;

  /**
   * URLPath is the URL path to be used in the HTTP GET or POST request to the
   * Kubernetes API server (e.g. "/api/v1/namespaces" or  "/apis/apps/v1/deployments").
   * The format required is the same format used by the `kubectl get --raw` command.
   * See https://kyverno.io/docs/writing-policies/external-data-sources/#variables-from-kubernetes-api-server-calls
   * for details.
   * It's mutually exclusive with the Service field.
   *
   * @schema ClusterPolicySpecRulesContextApiCall#urlPath
   */
  readonly urlPath?: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesContextApiCall' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesContextApiCall(obj: ClusterPolicySpecRulesContextApiCall | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'data': obj.data?.map(y => toJson_ClusterPolicySpecRulesContextApiCallData(y)),
    'default': obj.default,
    'jmesPath': obj.jmesPath,
    'method': obj.method,
    'service': toJson_ClusterPolicySpecRulesContextApiCallService(obj.service),
    'urlPath': obj.urlPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap is the ConfigMap reference.
 *
 * @schema ClusterPolicySpecRulesContextConfigMap
 */
export interface ClusterPolicySpecRulesContextConfigMap {
  /**
   * Name is the ConfigMap name.
   *
   * @schema ClusterPolicySpecRulesContextConfigMap#name
   */
  readonly name: string;

  /**
   * Namespace is the ConfigMap namespace.
   *
   * @schema ClusterPolicySpecRulesContextConfigMap#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesContextConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesContextConfigMap(obj: ClusterPolicySpecRulesContextConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GlobalContextEntryReference is a reference to a cached global context entry.
 *
 * @schema ClusterPolicySpecRulesContextGlobalReference
 */
export interface ClusterPolicySpecRulesContextGlobalReference {
  /**
   * JMESPath is an optional JSON Match Expression that can be used to
   * transform the JSON response returned from the server. For example
   * a JMESPath of "items | length(@)" applied to the API server response
   * for the URLPath "/apis/apps/v1/deployments" will return the total count
   * of deployments across all namespaces.
   *
   * @schema ClusterPolicySpecRulesContextGlobalReference#jmesPath
   */
  readonly jmesPath?: string;

  /**
   * Name of the global context entry
   *
   * @schema ClusterPolicySpecRulesContextGlobalReference#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesContextGlobalReference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesContextGlobalReference(obj: ClusterPolicySpecRulesContextGlobalReference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'jmesPath': obj.jmesPath,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ImageRegistry defines requests to an OCI/Docker V2 registry to fetch image
 * details.
 *
 * @schema ClusterPolicySpecRulesContextImageRegistry
 */
export interface ClusterPolicySpecRulesContextImageRegistry {
  /**
   * ImageRegistryCredentials provides credentials that will be used for authentication with registry
   *
   * @schema ClusterPolicySpecRulesContextImageRegistry#imageRegistryCredentials
   */
  readonly imageRegistryCredentials?: ClusterPolicySpecRulesContextImageRegistryImageRegistryCredentials;

  /**
   * JMESPath is an optional JSON Match Expression that can be used to
   * transform the ImageData struct returned as a result of processing
   * the image reference.
   *
   * @schema ClusterPolicySpecRulesContextImageRegistry#jmesPath
   */
  readonly jmesPath?: string;

  /**
   * Reference is image reference to a container image in the registry.
   * Example: ghcr.io/kyverno/kyverno:latest
   *
   * @schema ClusterPolicySpecRulesContextImageRegistry#reference
   */
  readonly reference: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesContextImageRegistry' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesContextImageRegistry(obj: ClusterPolicySpecRulesContextImageRegistry | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'imageRegistryCredentials': toJson_ClusterPolicySpecRulesContextImageRegistryImageRegistryCredentials(obj.imageRegistryCredentials),
    'jmesPath': obj.jmesPath,
    'reference': obj.reference,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Variable defines an arbitrary JMESPath context variable that can be defined inline.
 *
 * @schema ClusterPolicySpecRulesContextVariable
 */
export interface ClusterPolicySpecRulesContextVariable {
  /**
   * Default is an optional arbitrary JSON object that the variable may take if the JMESPath
   * expression evaluates to nil
   *
   * @default an optional arbitrary JSON object that the variable may take if the JMESPath
   * @schema ClusterPolicySpecRulesContextVariable#default
   */
  readonly default?: any;

  /**
   * JMESPath is an optional JMESPath Expression that can be used to
   * transform the variable.
   *
   * @schema ClusterPolicySpecRulesContextVariable#jmesPath
   */
  readonly jmesPath?: string;

  /**
   * Value is any arbitrary JSON object representable in YAML or JSON form.
   *
   * @schema ClusterPolicySpecRulesContextVariable#value
   */
  readonly value?: any;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesContextVariable' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesContextVariable(obj: ClusterPolicySpecRulesContextVariable | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'default': obj.default,
    'jmesPath': obj.jmesPath,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceFilter allow users to "AND" or "OR" between resources
 *
 * @schema ClusterPolicySpecRulesExcludeAll
 */
export interface ClusterPolicySpecRulesExcludeAll {
  /**
   * ClusterRoles is the list of cluster-wide role names for the user.
   *
   * @schema ClusterPolicySpecRulesExcludeAll#clusterRoles
   */
  readonly clusterRoles?: string[];

  /**
   * ResourceDescription contains information about the resource being created or modified.
   *
   * @schema ClusterPolicySpecRulesExcludeAll#resources
   */
  readonly resources?: ClusterPolicySpecRulesExcludeAllResources;

  /**
   * Roles is the list of namespaced role names for the user.
   *
   * @schema ClusterPolicySpecRulesExcludeAll#roles
   */
  readonly roles?: string[];

  /**
   * Subjects is the list of subject names like users, user groups, and service accounts.
   *
   * @schema ClusterPolicySpecRulesExcludeAll#subjects
   */
  readonly subjects?: ClusterPolicySpecRulesExcludeAllSubjects[];

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesExcludeAll' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesExcludeAll(obj: ClusterPolicySpecRulesExcludeAll | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterRoles': obj.clusterRoles?.map(y => y),
    'resources': toJson_ClusterPolicySpecRulesExcludeAllResources(obj.resources),
    'roles': obj.roles?.map(y => y),
    'subjects': obj.subjects?.map(y => toJson_ClusterPolicySpecRulesExcludeAllSubjects(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceFilter allow users to "AND" or "OR" between resources
 *
 * @schema ClusterPolicySpecRulesExcludeAny
 */
export interface ClusterPolicySpecRulesExcludeAny {
  /**
   * ClusterRoles is the list of cluster-wide role names for the user.
   *
   * @schema ClusterPolicySpecRulesExcludeAny#clusterRoles
   */
  readonly clusterRoles?: string[];

  /**
   * ResourceDescription contains information about the resource being created or modified.
   *
   * @schema ClusterPolicySpecRulesExcludeAny#resources
   */
  readonly resources?: ClusterPolicySpecRulesExcludeAnyResources;

  /**
   * Roles is the list of namespaced role names for the user.
   *
   * @schema ClusterPolicySpecRulesExcludeAny#roles
   */
  readonly roles?: string[];

  /**
   * Subjects is the list of subject names like users, user groups, and service accounts.
   *
   * @schema ClusterPolicySpecRulesExcludeAny#subjects
   */
  readonly subjects?: ClusterPolicySpecRulesExcludeAnySubjects[];

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesExcludeAny' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesExcludeAny(obj: ClusterPolicySpecRulesExcludeAny | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterRoles': obj.clusterRoles?.map(y => y),
    'resources': toJson_ClusterPolicySpecRulesExcludeAnyResources(obj.resources),
    'roles': obj.roles?.map(y => y),
    'subjects': obj.subjects?.map(y => toJson_ClusterPolicySpecRulesExcludeAnySubjects(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceDescription contains information about the resource being created or modified.
 * Requires at least one tag to be specified when under MatchResources.
 * Specifying ResourceDescription directly under match is being deprecated.
 * Please specify under "any" or "all" instead.
 *
 * @schema ClusterPolicySpecRulesExcludeResources
 */
export interface ClusterPolicySpecRulesExcludeResources {
  /**
   * Annotations is a  map of annotations (key-value pairs of type string). Annotation keys
   * and values support the wildcard characters "*" (matches zero or many characters) and
   * "?" (matches at least one character).
   *
   * @schema ClusterPolicySpecRulesExcludeResources#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Kinds is a list of resource kinds.
   *
   * @schema ClusterPolicySpecRulesExcludeResources#kinds
   */
  readonly kinds?: string[];

  /**
   * Name is the name of the resource. The name supports wildcard characters
   * "*" (matches zero or many characters) and "?" (at least one character).
   * NOTE: "Name" is being deprecated in favor of "Names".
   *
   * @schema ClusterPolicySpecRulesExcludeResources#name
   */
  readonly name?: string;

  /**
   * Names are the names of the resources. Each name supports wildcard characters
   * "*" (matches zero or many characters) and "?" (at least one character).
   *
   * @schema ClusterPolicySpecRulesExcludeResources#names
   */
  readonly names?: string[];

  /**
   * NamespaceSelector is a label selector for the resource namespace. Label keys and values
   * in `matchLabels` support the wildcard characters `*` (matches zero or many characters)
   * and `?` (matches one character).Wildcards allows writing label selectors like
   * ["storage.k8s.io/*": "*"]. Note that using ["*" : "*"] matches any key and value but
   * does not match an empty label set.
   *
   * @schema ClusterPolicySpecRulesExcludeResources#namespaceSelector
   */
  readonly namespaceSelector?: ClusterPolicySpecRulesExcludeResourcesNamespaceSelector;

  /**
   * Namespaces is a list of namespaces names. Each name supports wildcard characters
   * "*" (matches zero or many characters) and "?" (at least one character).
   *
   * @schema ClusterPolicySpecRulesExcludeResources#namespaces
   */
  readonly namespaces?: string[];

  /**
   * Operations can contain values ["CREATE, "UPDATE", "CONNECT", "DELETE"], which are used to match a specific action.
   *
   * @schema ClusterPolicySpecRulesExcludeResources#operations
   */
  readonly operations?: ClusterPolicySpecRulesExcludeResourcesOperations[];

  /**
   * Selector is a label selector. Label keys and values in `matchLabels` support the wildcard
   * characters `*` (matches zero or many characters) and `?` (matches one character).
   * Wildcards allows writing label selectors like ["storage.k8s.io/*": "*"]. Note that
   * using ["*" : "*"] matches any key and value but does not match an empty label set.
   *
   * @schema ClusterPolicySpecRulesExcludeResources#selector
   */
  readonly selector?: ClusterPolicySpecRulesExcludeResourcesSelector;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesExcludeResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesExcludeResources(obj: ClusterPolicySpecRulesExcludeResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'kinds': obj.kinds?.map(y => y),
    'name': obj.name,
    'names': obj.names?.map(y => y),
    'namespaceSelector': toJson_ClusterPolicySpecRulesExcludeResourcesNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'operations': obj.operations?.map(y => y),
    'selector': toJson_ClusterPolicySpecRulesExcludeResourcesSelector(obj.selector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Subject contains a reference to the object or user identities a role binding applies to.  This can either hold a direct API object reference,
 * or a value for non-objects such as user and group names.
 *
 * @schema ClusterPolicySpecRulesExcludeSubjects
 */
export interface ClusterPolicySpecRulesExcludeSubjects {
  /**
   * APIGroup holds the API group of the referenced subject.
   * Defaults to "" for ServiceAccount subjects.
   * Defaults to "rbac.authorization.k8s.io" for User and Group subjects.
   *
   * @default for ServiceAccount subjects.
   * @schema ClusterPolicySpecRulesExcludeSubjects#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind of object being referenced. Values defined by this API group are "User", "Group", and "ServiceAccount".
   * If the Authorizer does not recognized the kind value, the Authorizer should report an error.
   *
   * @schema ClusterPolicySpecRulesExcludeSubjects#kind
   */
  readonly kind: string;

  /**
   * Name of the object being referenced.
   *
   * @schema ClusterPolicySpecRulesExcludeSubjects#name
   */
  readonly name: string;

  /**
   * Namespace of the referenced object.  If the object kind is non-namespace, such as "User" or "Group", and this value is not empty
   * the Authorizer should report an error.
   *
   * @schema ClusterPolicySpecRulesExcludeSubjects#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesExcludeSubjects' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesExcludeSubjects(obj: ClusterPolicySpecRulesExcludeSubjects | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Clone specifies the source resource used to populate each generated resource.
 * At most one of Data or Clone can be specified. If neither are provided, the generated
 * resource will be created with default data only.
 *
 * @schema ClusterPolicySpecRulesGenerateClone
 */
export interface ClusterPolicySpecRulesGenerateClone {
  /**
   * Name specifies name of the resource.
   *
   * @schema ClusterPolicySpecRulesGenerateClone#name
   */
  readonly name?: string;

  /**
   * Namespace specifies source resource namespace.
   *
   * @schema ClusterPolicySpecRulesGenerateClone#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesGenerateClone' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesGenerateClone(obj: ClusterPolicySpecRulesGenerateClone | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CloneList specifies the list of source resource used to populate each generated resource.
 *
 * @schema ClusterPolicySpecRulesGenerateCloneList
 */
export interface ClusterPolicySpecRulesGenerateCloneList {
  /**
   * Kinds is a list of resource kinds.
   *
   * @schema ClusterPolicySpecRulesGenerateCloneList#kinds
   */
  readonly kinds?: string[];

  /**
   * Namespace specifies source resource namespace.
   *
   * @schema ClusterPolicySpecRulesGenerateCloneList#namespace
   */
  readonly namespace?: string;

  /**
   * Selector is a label selector. Label keys and values in `matchLabels`.
   * wildcard characters are not supported.
   *
   * @schema ClusterPolicySpecRulesGenerateCloneList#selector
   */
  readonly selector?: ClusterPolicySpecRulesGenerateCloneListSelector;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesGenerateCloneList' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesGenerateCloneList(obj: ClusterPolicySpecRulesGenerateCloneList | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kinds': obj.kinds?.map(y => y),
    'namespace': obj.namespace,
    'selector': toJson_ClusterPolicySpecRulesGenerateCloneListSelector(obj.selector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterPolicySpecRulesGenerateForeach
 */
export interface ClusterPolicySpecRulesGenerateForeach {
  /**
   * APIVersion specifies resource apiVersion.
   *
   * @schema ClusterPolicySpecRulesGenerateForeach#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Clone specifies the source resource used to populate each generated resource.
   * At most one of Data or Clone can be specified. If neither are provided, the generated
   * resource will be created with default data only.
   *
   * @schema ClusterPolicySpecRulesGenerateForeach#clone
   */
  readonly clone?: ClusterPolicySpecRulesGenerateForeachClone;

  /**
   * CloneList specifies the list of source resource used to populate each generated resource.
   *
   * @schema ClusterPolicySpecRulesGenerateForeach#cloneList
   */
  readonly cloneList?: ClusterPolicySpecRulesGenerateForeachCloneList;

  /**
   * Context defines variables and data sources that can be used during rule execution.
   *
   * @schema ClusterPolicySpecRulesGenerateForeach#context
   */
  readonly context?: ClusterPolicySpecRulesGenerateForeachContext[];

  /**
   * Data provides the resource declaration used to populate each generated resource.
   * At most one of Data or Clone must be specified. If neither are provided, the generated
   * resource will be created with default data only.
   *
   * @schema ClusterPolicySpecRulesGenerateForeach#data
   */
  readonly data?: any;

  /**
   * Kind specifies resource kind.
   *
   * @schema ClusterPolicySpecRulesGenerateForeach#kind
   */
  readonly kind?: string;

  /**
   * List specifies a JMESPath expression that results in one or more elements
   * to which the validation logic is applied.
   *
   * @schema ClusterPolicySpecRulesGenerateForeach#list
   */
  readonly list?: string;

  /**
   * Name specifies the resource name.
   *
   * @schema ClusterPolicySpecRulesGenerateForeach#name
   */
  readonly name?: string;

  /**
   * Namespace specifies resource namespace.
   *
   * @schema ClusterPolicySpecRulesGenerateForeach#namespace
   */
  readonly namespace?: string;

  /**
   * AnyAllConditions are used to determine if a policy rule should be applied by evaluating a
   * set of conditions. The declaration can contain nested `any` or `all` statements.
   * See: https://kyverno.io/docs/writing-policies/preconditions/
   *
   * @schema ClusterPolicySpecRulesGenerateForeach#preconditions
   */
  readonly preconditions?: ClusterPolicySpecRulesGenerateForeachPreconditions;

  /**
   * UID specifies the resource uid.
   *
   * @schema ClusterPolicySpecRulesGenerateForeach#uid
   */
  readonly uid?: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesGenerateForeach' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesGenerateForeach(obj: ClusterPolicySpecRulesGenerateForeach | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'clone': toJson_ClusterPolicySpecRulesGenerateForeachClone(obj.clone),
    'cloneList': toJson_ClusterPolicySpecRulesGenerateForeachCloneList(obj.cloneList),
    'context': obj.context?.map(y => toJson_ClusterPolicySpecRulesGenerateForeachContext(y)),
    'data': obj.data,
    'kind': obj.kind,
    'list': obj.list,
    'name': obj.name,
    'namespace': obj.namespace,
    'preconditions': toJson_ClusterPolicySpecRulesGenerateForeachPreconditions(obj.preconditions),
    'uid': obj.uid,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceFilter allow users to "AND" or "OR" between resources
 *
 * @schema ClusterPolicySpecRulesMatchAll
 */
export interface ClusterPolicySpecRulesMatchAll {
  /**
   * ClusterRoles is the list of cluster-wide role names for the user.
   *
   * @schema ClusterPolicySpecRulesMatchAll#clusterRoles
   */
  readonly clusterRoles?: string[];

  /**
   * ResourceDescription contains information about the resource being created or modified.
   *
   * @schema ClusterPolicySpecRulesMatchAll#resources
   */
  readonly resources?: ClusterPolicySpecRulesMatchAllResources;

  /**
   * Roles is the list of namespaced role names for the user.
   *
   * @schema ClusterPolicySpecRulesMatchAll#roles
   */
  readonly roles?: string[];

  /**
   * Subjects is the list of subject names like users, user groups, and service accounts.
   *
   * @schema ClusterPolicySpecRulesMatchAll#subjects
   */
  readonly subjects?: ClusterPolicySpecRulesMatchAllSubjects[];

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMatchAll' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMatchAll(obj: ClusterPolicySpecRulesMatchAll | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterRoles': obj.clusterRoles?.map(y => y),
    'resources': toJson_ClusterPolicySpecRulesMatchAllResources(obj.resources),
    'roles': obj.roles?.map(y => y),
    'subjects': obj.subjects?.map(y => toJson_ClusterPolicySpecRulesMatchAllSubjects(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceFilter allow users to "AND" or "OR" between resources
 *
 * @schema ClusterPolicySpecRulesMatchAny
 */
export interface ClusterPolicySpecRulesMatchAny {
  /**
   * ClusterRoles is the list of cluster-wide role names for the user.
   *
   * @schema ClusterPolicySpecRulesMatchAny#clusterRoles
   */
  readonly clusterRoles?: string[];

  /**
   * ResourceDescription contains information about the resource being created or modified.
   *
   * @schema ClusterPolicySpecRulesMatchAny#resources
   */
  readonly resources?: ClusterPolicySpecRulesMatchAnyResources;

  /**
   * Roles is the list of namespaced role names for the user.
   *
   * @schema ClusterPolicySpecRulesMatchAny#roles
   */
  readonly roles?: string[];

  /**
   * Subjects is the list of subject names like users, user groups, and service accounts.
   *
   * @schema ClusterPolicySpecRulesMatchAny#subjects
   */
  readonly subjects?: ClusterPolicySpecRulesMatchAnySubjects[];

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMatchAny' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMatchAny(obj: ClusterPolicySpecRulesMatchAny | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterRoles': obj.clusterRoles?.map(y => y),
    'resources': toJson_ClusterPolicySpecRulesMatchAnyResources(obj.resources),
    'roles': obj.roles?.map(y => y),
    'subjects': obj.subjects?.map(y => toJson_ClusterPolicySpecRulesMatchAnySubjects(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceDescription contains information about the resource being created or modified.
 * Requires at least one tag to be specified when under MatchResources.
 * Specifying ResourceDescription directly under match is being deprecated.
 * Please specify under "any" or "all" instead.
 *
 * @schema ClusterPolicySpecRulesMatchResources
 */
export interface ClusterPolicySpecRulesMatchResources {
  /**
   * Annotations is a  map of annotations (key-value pairs of type string). Annotation keys
   * and values support the wildcard characters "*" (matches zero or many characters) and
   * "?" (matches at least one character).
   *
   * @schema ClusterPolicySpecRulesMatchResources#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Kinds is a list of resource kinds.
   *
   * @schema ClusterPolicySpecRulesMatchResources#kinds
   */
  readonly kinds?: string[];

  /**
   * Name is the name of the resource. The name supports wildcard characters
   * "*" (matches zero or many characters) and "?" (at least one character).
   * NOTE: "Name" is being deprecated in favor of "Names".
   *
   * @schema ClusterPolicySpecRulesMatchResources#name
   */
  readonly name?: string;

  /**
   * Names are the names of the resources. Each name supports wildcard characters
   * "*" (matches zero or many characters) and "?" (at least one character).
   *
   * @schema ClusterPolicySpecRulesMatchResources#names
   */
  readonly names?: string[];

  /**
   * NamespaceSelector is a label selector for the resource namespace. Label keys and values
   * in `matchLabels` support the wildcard characters `*` (matches zero or many characters)
   * and `?` (matches one character).Wildcards allows writing label selectors like
   * ["storage.k8s.io/*": "*"]. Note that using ["*" : "*"] matches any key and value but
   * does not match an empty label set.
   *
   * @schema ClusterPolicySpecRulesMatchResources#namespaceSelector
   */
  readonly namespaceSelector?: ClusterPolicySpecRulesMatchResourcesNamespaceSelector;

  /**
   * Namespaces is a list of namespaces names. Each name supports wildcard characters
   * "*" (matches zero or many characters) and "?" (at least one character).
   *
   * @schema ClusterPolicySpecRulesMatchResources#namespaces
   */
  readonly namespaces?: string[];

  /**
   * Operations can contain values ["CREATE, "UPDATE", "CONNECT", "DELETE"], which are used to match a specific action.
   *
   * @schema ClusterPolicySpecRulesMatchResources#operations
   */
  readonly operations?: ClusterPolicySpecRulesMatchResourcesOperations[];

  /**
   * Selector is a label selector. Label keys and values in `matchLabels` support the wildcard
   * characters `*` (matches zero or many characters) and `?` (matches one character).
   * Wildcards allows writing label selectors like ["storage.k8s.io/*": "*"]. Note that
   * using ["*" : "*"] matches any key and value but does not match an empty label set.
   *
   * @schema ClusterPolicySpecRulesMatchResources#selector
   */
  readonly selector?: ClusterPolicySpecRulesMatchResourcesSelector;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMatchResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMatchResources(obj: ClusterPolicySpecRulesMatchResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'kinds': obj.kinds?.map(y => y),
    'name': obj.name,
    'names': obj.names?.map(y => y),
    'namespaceSelector': toJson_ClusterPolicySpecRulesMatchResourcesNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'operations': obj.operations?.map(y => y),
    'selector': toJson_ClusterPolicySpecRulesMatchResourcesSelector(obj.selector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Subject contains a reference to the object or user identities a role binding applies to.  This can either hold a direct API object reference,
 * or a value for non-objects such as user and group names.
 *
 * @schema ClusterPolicySpecRulesMatchSubjects
 */
export interface ClusterPolicySpecRulesMatchSubjects {
  /**
   * APIGroup holds the API group of the referenced subject.
   * Defaults to "" for ServiceAccount subjects.
   * Defaults to "rbac.authorization.k8s.io" for User and Group subjects.
   *
   * @default for ServiceAccount subjects.
   * @schema ClusterPolicySpecRulesMatchSubjects#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind of object being referenced. Values defined by this API group are "User", "Group", and "ServiceAccount".
   * If the Authorizer does not recognized the kind value, the Authorizer should report an error.
   *
   * @schema ClusterPolicySpecRulesMatchSubjects#kind
   */
  readonly kind: string;

  /**
   * Name of the object being referenced.
   *
   * @schema ClusterPolicySpecRulesMatchSubjects#name
   */
  readonly name: string;

  /**
   * Namespace of the referenced object.  If the object kind is non-namespace, such as "User" or "Group", and this value is not empty
   * the Authorizer should report an error.
   *
   * @schema ClusterPolicySpecRulesMatchSubjects#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMatchSubjects' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMatchSubjects(obj: ClusterPolicySpecRulesMatchSubjects | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ForEachMutation applies mutation rules to a list of sub-elements by creating a context for each entry in the list and looping over it to apply the specified logic.
 *
 * @schema ClusterPolicySpecRulesMutateForeach
 */
export interface ClusterPolicySpecRulesMutateForeach {
  /**
   * Context defines variables and data sources that can be used during rule execution.
   *
   * @schema ClusterPolicySpecRulesMutateForeach#context
   */
  readonly context?: ClusterPolicySpecRulesMutateForeachContext[];

  /**
   * Foreach declares a nested foreach iterator
   *
   * @schema ClusterPolicySpecRulesMutateForeach#foreach
   */
  readonly foreach?: any;

  /**
   * List specifies a JMESPath expression that results in one or more elements
   * to which the validation logic is applied.
   *
   * @schema ClusterPolicySpecRulesMutateForeach#list
   */
  readonly list?: string;

  /**
   * Order defines the iteration order on the list.
   * Can be Ascending to iterate from first to last element or Descending to iterate in from last to first element.
   *
   * @schema ClusterPolicySpecRulesMutateForeach#order
   */
  readonly order?: ClusterPolicySpecRulesMutateForeachOrder;

  /**
   * PatchStrategicMerge is a strategic merge patch used to modify resources.
   * See https://kubernetes.io/docs/tasks/manage-kubernetes-objects/update-api-object-kubectl-patch/
   * and https://kubectl.docs.kubernetes.io/references/kustomize/kustomization/patchesstrategicmerge/.
   *
   * @schema ClusterPolicySpecRulesMutateForeach#patchStrategicMerge
   */
  readonly patchStrategicMerge?: any;

  /**
   * PatchesJSON6902 is a list of RFC 6902 JSON Patch declarations used to modify resources.
   * See https://tools.ietf.org/html/rfc6902 and https://kubectl.docs.kubernetes.io/references/kustomize/kustomization/patchesjson6902/.
   *
   * @schema ClusterPolicySpecRulesMutateForeach#patchesJson6902
   */
  readonly patchesJson6902?: string;

  /**
   * AnyAllConditions are used to determine if a policy rule should be applied by evaluating a
   * set of conditions. The declaration can contain nested `any` or `all` statements.
   * See: https://kyverno.io/docs/writing-policies/preconditions/
   *
   * @schema ClusterPolicySpecRulesMutateForeach#preconditions
   */
  readonly preconditions?: ClusterPolicySpecRulesMutateForeachPreconditions;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMutateForeach' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMutateForeach(obj: ClusterPolicySpecRulesMutateForeach | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'context': obj.context?.map(y => toJson_ClusterPolicySpecRulesMutateForeachContext(y)),
    'foreach': obj.foreach,
    'list': obj.list,
    'order': obj.order,
    'patchStrategicMerge': obj.patchStrategicMerge,
    'patchesJson6902': obj.patchesJson6902,
    'preconditions': toJson_ClusterPolicySpecRulesMutateForeachPreconditions(obj.preconditions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TargetResourceSpec defines targets for mutating existing resources.
 *
 * @schema ClusterPolicySpecRulesMutateTargets
 */
export interface ClusterPolicySpecRulesMutateTargets {
  /**
   * APIVersion specifies resource apiVersion.
   *
   * @schema ClusterPolicySpecRulesMutateTargets#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Context defines variables and data sources that can be used during rule execution.
   *
   * @schema ClusterPolicySpecRulesMutateTargets#context
   */
  readonly context?: ClusterPolicySpecRulesMutateTargetsContext[];

  /**
   * Kind specifies resource kind.
   *
   * @schema ClusterPolicySpecRulesMutateTargets#kind
   */
  readonly kind?: string;

  /**
   * Name specifies the resource name.
   *
   * @schema ClusterPolicySpecRulesMutateTargets#name
   */
  readonly name?: string;

  /**
   * Namespace specifies resource namespace.
   *
   * @schema ClusterPolicySpecRulesMutateTargets#namespace
   */
  readonly namespace?: string;

  /**
   * Preconditions are used to determine if a policy rule should be applied by evaluating a
   * set of conditions. The declaration can contain nested `any` or `all` statements. A direct list
   * of conditions (without `any` or `all` statements is supported for backwards compatibility but
   * will be deprecated in the next major release.
   * See: https://kyverno.io/docs/writing-policies/preconditions/
   *
   * @schema ClusterPolicySpecRulesMutateTargets#preconditions
   */
  readonly preconditions?: any;

  /**
   * Selector allows you to select target resources with their labels.
   *
   * @schema ClusterPolicySpecRulesMutateTargets#selector
   */
  readonly selector?: ClusterPolicySpecRulesMutateTargetsSelector;

  /**
   * UID specifies the resource uid.
   *
   * @schema ClusterPolicySpecRulesMutateTargets#uid
   */
  readonly uid?: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMutateTargets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMutateTargets(obj: ClusterPolicySpecRulesMutateTargets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'context': obj.context?.map(y => toJson_ClusterPolicySpecRulesMutateTargetsContext(y)),
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
    'preconditions': obj.preconditions,
    'selector': toJson_ClusterPolicySpecRulesMutateTargetsSelector(obj.selector),
    'uid': obj.uid,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CEL allows validation checks using the Common Expression Language (https://kubernetes.io/docs/reference/using-api/cel/).
 *
 * @schema ClusterPolicySpecRulesValidateCel
 */
export interface ClusterPolicySpecRulesValidateCel {
  /**
   * AuditAnnotations contains CEL expressions which are used to produce audit annotations for the audit event of the API request.
   *
   * @schema ClusterPolicySpecRulesValidateCel#auditAnnotations
   */
  readonly auditAnnotations?: ClusterPolicySpecRulesValidateCelAuditAnnotations[];

  /**
   * Expressions is a list of CELExpression types.
   *
   * @schema ClusterPolicySpecRulesValidateCel#expressions
   */
  readonly expressions?: ClusterPolicySpecRulesValidateCelExpressions[];

  /**
   * ParamKind is a tuple of Group Kind and Version.
   *
   * @schema ClusterPolicySpecRulesValidateCel#paramKind
   */
  readonly paramKind?: ClusterPolicySpecRulesValidateCelParamKind;

  /**
   * ParamRef references a parameter resource.
   *
   * @schema ClusterPolicySpecRulesValidateCel#paramRef
   */
  readonly paramRef?: ClusterPolicySpecRulesValidateCelParamRef;

  /**
   * Variables contain definitions of variables that can be used in composition of other expressions.
   * Each variable is defined as a named CEL expression.
   * The variables defined here will be available under `variables` in other expressions of the policy.
   *
   * @schema ClusterPolicySpecRulesValidateCel#variables
   */
  readonly variables?: ClusterPolicySpecRulesValidateCelVariables[];

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesValidateCel' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesValidateCel(obj: ClusterPolicySpecRulesValidateCel | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auditAnnotations': obj.auditAnnotations?.map(y => toJson_ClusterPolicySpecRulesValidateCelAuditAnnotations(y)),
    'expressions': obj.expressions?.map(y => toJson_ClusterPolicySpecRulesValidateCelExpressions(y)),
    'paramKind': toJson_ClusterPolicySpecRulesValidateCelParamKind(obj.paramKind),
    'paramRef': toJson_ClusterPolicySpecRulesValidateCelParamRef(obj.paramRef),
    'variables': obj.variables?.map(y => toJson_ClusterPolicySpecRulesValidateCelVariables(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Deny defines conditions used to pass or fail a validation rule.
 *
 * @schema ClusterPolicySpecRulesValidateDeny
 */
export interface ClusterPolicySpecRulesValidateDeny {
  /**
   * Multiple conditions can be declared under an `any` or `all` statement. A direct list
   * of conditions (without `any` or `all` statements) is also supported for backwards compatibility
   * but will be deprecated in the next major release.
   * See: https://kyverno.io/docs/writing-policies/validate/#deny-rules
   *
   * @schema ClusterPolicySpecRulesValidateDeny#conditions
   */
  readonly conditions?: any;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesValidateDeny' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesValidateDeny(obj: ClusterPolicySpecRulesValidateDeny | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conditions': obj.conditions,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FailureAction defines if a validation policy rule violation should block
 * the admission review request (Enforce), or allow (Audit) the admission review request
 * and report an error in a policy report. Optional.
 * Allowed values are Audit or Enforce.
 *
 * @schema ClusterPolicySpecRulesValidateFailureAction
 */
export enum ClusterPolicySpecRulesValidateFailureAction {
  /** Audit */
  AUDIT = "Audit",
  /** Enforce */
  ENFORCE = "Enforce",
}

/**
 * @schema ClusterPolicySpecRulesValidateFailureActionOverrides
 */
export interface ClusterPolicySpecRulesValidateFailureActionOverrides {
  /**
   * ValidationFailureAction defines the policy validation failure action
   *
   * @schema ClusterPolicySpecRulesValidateFailureActionOverrides#action
   */
  readonly action?: ClusterPolicySpecRulesValidateFailureActionOverridesAction;

  /**
   * A label selector is a label query over a set of resources. The result of matchLabels and
   * matchExpressions are ANDed. An empty label selector matches all objects. A null
   * label selector matches no objects.
   *
   * @schema ClusterPolicySpecRulesValidateFailureActionOverrides#namespaceSelector
   */
  readonly namespaceSelector?: ClusterPolicySpecRulesValidateFailureActionOverridesNamespaceSelector;

  /**
   * @schema ClusterPolicySpecRulesValidateFailureActionOverrides#namespaces
   */
  readonly namespaces?: string[];

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesValidateFailureActionOverrides' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesValidateFailureActionOverrides(obj: ClusterPolicySpecRulesValidateFailureActionOverrides | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'namespaceSelector': toJson_ClusterPolicySpecRulesValidateFailureActionOverridesNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ForEachValidation applies validate rules to a list of sub-elements by creating a context for each entry in the list and looping over it to apply the specified logic.
 *
 * @schema ClusterPolicySpecRulesValidateForeach
 */
export interface ClusterPolicySpecRulesValidateForeach {
  /**
   * AnyPattern specifies list of validation patterns. At least one of the patterns
   * must be satisfied for the validation rule to succeed.
   *
   * @schema ClusterPolicySpecRulesValidateForeach#anyPattern
   */
  readonly anyPattern?: any;

  /**
   * Context defines variables and data sources that can be used during rule execution.
   *
   * @schema ClusterPolicySpecRulesValidateForeach#context
   */
  readonly context?: ClusterPolicySpecRulesValidateForeachContext[];

  /**
   * Deny defines conditions used to pass or fail a validation rule.
   *
   * @schema ClusterPolicySpecRulesValidateForeach#deny
   */
  readonly deny?: ClusterPolicySpecRulesValidateForeachDeny;

  /**
   * ElementScope specifies whether to use the current list element as the scope for validation. Defaults to "true" if not specified.
   * When set to "false", "request.object" is used as the validation scope within the foreach
   * block to allow referencing other elements in the subtree.
   *
   * @default true" if not specified.
   * @schema ClusterPolicySpecRulesValidateForeach#elementScope
   */
  readonly elementScope?: boolean;

  /**
   * Foreach declares a nested foreach iterator
   *
   * @schema ClusterPolicySpecRulesValidateForeach#foreach
   */
  readonly foreach?: any;

  /**
   * List specifies a JMESPath expression that results in one or more elements
   * to which the validation logic is applied.
   *
   * @schema ClusterPolicySpecRulesValidateForeach#list
   */
  readonly list?: string;

  /**
   * Pattern specifies an overlay-style pattern used to check resources.
   *
   * @schema ClusterPolicySpecRulesValidateForeach#pattern
   */
  readonly pattern?: any;

  /**
   * AnyAllConditions are used to determine if a policy rule should be applied by evaluating a
   * set of conditions. The declaration can contain nested `any` or `all` statements.
   * See: https://kyverno.io/docs/writing-policies/preconditions/
   *
   * @schema ClusterPolicySpecRulesValidateForeach#preconditions
   */
  readonly preconditions?: ClusterPolicySpecRulesValidateForeachPreconditions;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesValidateForeach' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesValidateForeach(obj: ClusterPolicySpecRulesValidateForeach | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'anyPattern': obj.anyPattern,
    'context': obj.context?.map(y => toJson_ClusterPolicySpecRulesValidateForeachContext(y)),
    'deny': toJson_ClusterPolicySpecRulesValidateForeachDeny(obj.deny),
    'elementScope': obj.elementScope,
    'foreach': obj.foreach,
    'list': obj.list,
    'pattern': obj.pattern,
    'preconditions': toJson_ClusterPolicySpecRulesValidateForeachPreconditions(obj.preconditions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Manifest specifies conditions for manifest verification
 *
 * @schema ClusterPolicySpecRulesValidateManifests
 */
export interface ClusterPolicySpecRulesValidateManifests {
  /**
   * AnnotationDomain is custom domain of annotation for message and signature. Default is "cosign.sigstore.dev".
   *
   * @default cosign.sigstore.dev".
   * @schema ClusterPolicySpecRulesValidateManifests#annotationDomain
   */
  readonly annotationDomain?: string;

  /**
   * Attestors specified the required attestors (i.e. authorities)
   *
   * @schema ClusterPolicySpecRulesValidateManifests#attestors
   */
  readonly attestors?: ClusterPolicySpecRulesValidateManifestsAttestors[];

  /**
   * DryRun configuration
   *
   * @schema ClusterPolicySpecRulesValidateManifests#dryRun
   */
  readonly dryRun?: ClusterPolicySpecRulesValidateManifestsDryRun;

  /**
   * Fields which will be ignored while comparing manifests.
   *
   * @schema ClusterPolicySpecRulesValidateManifests#ignoreFields
   */
  readonly ignoreFields?: ClusterPolicySpecRulesValidateManifestsIgnoreFields[];

  /**
   * Repository is an optional alternate OCI repository to use for resource bundle reference.
   * The repository can be overridden per Attestor or Attestation.
   *
   * @schema ClusterPolicySpecRulesValidateManifests#repository
   */
  readonly repository?: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesValidateManifests' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesValidateManifests(obj: ClusterPolicySpecRulesValidateManifests | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotationDomain': obj.annotationDomain,
    'attestors': obj.attestors?.map(y => toJson_ClusterPolicySpecRulesValidateManifestsAttestors(y)),
    'dryRun': toJson_ClusterPolicySpecRulesValidateManifestsDryRun(obj.dryRun),
    'ignoreFields': obj.ignoreFields?.map(y => toJson_ClusterPolicySpecRulesValidateManifestsIgnoreFields(y)),
    'repository': obj.repository,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PodSecurity applies exemptions for Kubernetes Pod Security admission
 * by specifying exclusions for Pod Security Standards controls.
 *
 * @schema ClusterPolicySpecRulesValidatePodSecurity
 */
export interface ClusterPolicySpecRulesValidatePodSecurity {
  /**
   * Exclude specifies the Pod Security Standard controls to be excluded.
   *
   * @schema ClusterPolicySpecRulesValidatePodSecurity#exclude
   */
  readonly exclude?: ClusterPolicySpecRulesValidatePodSecurityExclude[];

  /**
   * Level defines the Pod Security Standard level to be applied to workloads.
   * Allowed values are privileged, baseline, and restricted.
   *
   * @schema ClusterPolicySpecRulesValidatePodSecurity#level
   */
  readonly level?: ClusterPolicySpecRulesValidatePodSecurityLevel;

  /**
   * Version defines the Pod Security Standard versions that Kubernetes supports.
   * Allowed values are v1.19, v1.20, v1.21, v1.22, v1.23, v1.24, v1.25, v1.26, v1.27, v1.28, v1.29, latest. Defaults to latest.
   *
   * @default latest.
   * @schema ClusterPolicySpecRulesValidatePodSecurity#version
   */
  readonly version?: ClusterPolicySpecRulesValidatePodSecurityVersion;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesValidatePodSecurity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesValidatePodSecurity(obj: ClusterPolicySpecRulesValidatePodSecurity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exclude': obj.exclude?.map(y => toJson_ClusterPolicySpecRulesValidatePodSecurityExclude(y)),
    'level': obj.level,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Attestation are checks for signed in-toto Statements that are used to verify the image.
 * See https://github.com/in-toto/attestation. Kyverno fetches signed attestations from the
 * OCI registry and decodes them into a list of Statements.
 *
 * @schema ClusterPolicySpecRulesVerifyImagesAttestations
 */
export interface ClusterPolicySpecRulesVerifyImagesAttestations {
  /**
   * Attestors specify the required attestors (i.e. authorities).
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestations#attestors
   */
  readonly attestors?: ClusterPolicySpecRulesVerifyImagesAttestationsAttestors[];

  /**
   * Conditions are used to verify attributes within a Predicate. If no Conditions are specified
   * the attestation check is satisfied as long there are predicates that match the predicate type.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestations#conditions
   */
  readonly conditions?: ClusterPolicySpecRulesVerifyImagesAttestationsConditions[];

  /**
   * Name is the variable name.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestations#name
   */
  readonly name?: string;

  /**
   * Deprecated in favour of 'Type', to be removed soon
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestations#predicateType
   */
  readonly predicateType?: string;

  /**
   * Type defines the type of attestation contained within the Statement.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestations#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesVerifyImagesAttestations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesVerifyImagesAttestations(obj: ClusterPolicySpecRulesVerifyImagesAttestations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'attestors': obj.attestors?.map(y => toJson_ClusterPolicySpecRulesVerifyImagesAttestationsAttestors(y)),
    'conditions': obj.conditions?.map(y => toJson_ClusterPolicySpecRulesVerifyImagesAttestationsConditions(y)),
    'name': obj.name,
    'predicateType': obj.predicateType,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterPolicySpecRulesVerifyImagesAttestors
 */
export interface ClusterPolicySpecRulesVerifyImagesAttestors {
  /**
   * Count specifies the required number of entries that must match. If the count is null, all entries must match
   * (a logical AND). If the count is 1, at least one entry must match (a logical OR). If the count contains a
   * value N, then N must be less than or equal to the size of entries, and at least N entries must match.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestors#count
   */
  readonly count?: number;

  /**
   * Entries contains the available attestors. An attestor can be a static key,
   * attributes for keyless verification, or a nested attestor declaration.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestors#entries
   */
  readonly entries?: ClusterPolicySpecRulesVerifyImagesAttestorsEntries[];

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesVerifyImagesAttestors' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesVerifyImagesAttestors(obj: ClusterPolicySpecRulesVerifyImagesAttestors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'count': obj.count,
    'entries': obj.entries?.map(y => toJson_ClusterPolicySpecRulesVerifyImagesAttestorsEntries(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Allowed values are Audit or Enforce.
 *
 * @schema ClusterPolicySpecRulesVerifyImagesFailureAction
 */
export enum ClusterPolicySpecRulesVerifyImagesFailureAction {
  /** Audit */
  AUDIT = "Audit",
  /** Enforce */
  ENFORCE = "Enforce",
}

/**
 * ImageRegistryCredentials provides credentials that will be used for authentication with registry.
 *
 * @schema ClusterPolicySpecRulesVerifyImagesImageRegistryCredentials
 */
export interface ClusterPolicySpecRulesVerifyImagesImageRegistryCredentials {
  /**
   * AllowInsecureRegistry allows insecure access to a registry.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesImageRegistryCredentials#allowInsecureRegistry
   */
  readonly allowInsecureRegistry?: boolean;

  /**
   * Providers specifies a list of OCI Registry names, whose authentication providers are provided.
   * It can be of one of these values: default,google,azure,amazon,github.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesImageRegistryCredentials#providers
   */
  readonly providers?: ClusterPolicySpecRulesVerifyImagesImageRegistryCredentialsProviders[];

  /**
   * Secrets specifies a list of secrets that are provided for credentials.
   * Secrets must live in the Kyverno namespace.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesImageRegistryCredentials#secrets
   */
  readonly secrets?: string[];

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesVerifyImagesImageRegistryCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesVerifyImagesImageRegistryCredentials(obj: ClusterPolicySpecRulesVerifyImagesImageRegistryCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowInsecureRegistry': obj.allowInsecureRegistry,
    'providers': obj.providers?.map(y => y),
    'secrets': obj.secrets?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Type specifies the method of signature validation. The allowed options
 * are Cosign, Sigstore Bundle and Notary. By default Cosign is used if a type is not specified.
 *
 * @schema ClusterPolicySpecRulesVerifyImagesType
 */
export enum ClusterPolicySpecRulesVerifyImagesType {
  /** Cosign */
  COSIGN = "Cosign",
  /** SigstoreBundle */
  SIGSTORE_BUNDLE = "SigstoreBundle",
  /** Notary */
  NOTARY = "Notary",
}

/**
 * Validation checks conditions across multiple image
 * verification attestations or context entries
 *
 * @schema ClusterPolicySpecRulesVerifyImagesValidate
 */
export interface ClusterPolicySpecRulesVerifyImagesValidate {
  /**
   * Deny defines conditions used to pass or fail a validation rule.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesValidate#deny
   */
  readonly deny?: ClusterPolicySpecRulesVerifyImagesValidateDeny;

  /**
   * Message specifies a custom message to be displayed on failure.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesValidate#message
   */
  readonly message?: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesVerifyImagesValidate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesVerifyImagesValidate(obj: ClusterPolicySpecRulesVerifyImagesValidate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deny': toJson_ClusterPolicySpecRulesVerifyImagesValidateDeny(obj.deny),
    'message': obj.message,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterPolicySpecValidationFailureActionOverridesNamespaceSelectorMatchExpressions
 */
export interface ClusterPolicySpecValidationFailureActionOverridesNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterPolicySpecValidationFailureActionOverridesNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterPolicySpecValidationFailureActionOverridesNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterPolicySpecValidationFailureActionOverridesNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterPolicySpecValidationFailureActionOverridesNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecValidationFailureActionOverridesNamespaceSelectorMatchExpressions(obj: ClusterPolicySpecValidationFailureActionOverridesNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RequestData contains the HTTP POST data
 *
 * @schema ClusterPolicySpecRulesContextApiCallData
 */
export interface ClusterPolicySpecRulesContextApiCallData {
  /**
   * Key is a unique identifier for the data value
   *
   * @schema ClusterPolicySpecRulesContextApiCallData#key
   */
  readonly key: string;

  /**
   * Value is the data value
   *
   * @schema ClusterPolicySpecRulesContextApiCallData#value
   */
  readonly value: any;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesContextApiCallData' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesContextApiCallData(obj: ClusterPolicySpecRulesContextApiCallData | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Method is the HTTP request type (GET or POST). Defaults to GET.
 *
 * @default GET.
 * @schema ClusterPolicySpecRulesContextApiCallMethod
 */
export enum ClusterPolicySpecRulesContextApiCallMethod {
  /** GET */
  GET = "GET",
  /** POST */
  POST = "POST",
}

/**
 * Service is an API call to a JSON web service.
 * This is used for non-Kubernetes API server calls.
 * It's mutually exclusive with the URLPath field.
 *
 * @schema ClusterPolicySpecRulesContextApiCallService
 */
export interface ClusterPolicySpecRulesContextApiCallService {
  /**
   * CABundle is a PEM encoded CA bundle which will be used to validate
   * the server certificate.
   *
   * @schema ClusterPolicySpecRulesContextApiCallService#caBundle
   */
  readonly caBundle?: string;

  /**
   * Headers is a list of optional HTTP headers to be included in the request.
   *
   * @schema ClusterPolicySpecRulesContextApiCallService#headers
   */
  readonly headers?: ClusterPolicySpecRulesContextApiCallServiceHeaders[];

  /**
   * URL is the JSON web service URL. A typical form is
   * `https://{service}.{namespace}:{port}/{path}`.
   *
   * @schema ClusterPolicySpecRulesContextApiCallService#url
   */
  readonly url: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesContextApiCallService' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesContextApiCallService(obj: ClusterPolicySpecRulesContextApiCallService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caBundle': obj.caBundle,
    'headers': obj.headers?.map(y => toJson_ClusterPolicySpecRulesContextApiCallServiceHeaders(y)),
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ImageRegistryCredentials provides credentials that will be used for authentication with registry
 *
 * @schema ClusterPolicySpecRulesContextImageRegistryImageRegistryCredentials
 */
export interface ClusterPolicySpecRulesContextImageRegistryImageRegistryCredentials {
  /**
   * AllowInsecureRegistry allows insecure access to a registry.
   *
   * @schema ClusterPolicySpecRulesContextImageRegistryImageRegistryCredentials#allowInsecureRegistry
   */
  readonly allowInsecureRegistry?: boolean;

  /**
   * Providers specifies a list of OCI Registry names, whose authentication providers are provided.
   * It can be of one of these values: default,google,azure,amazon,github.
   *
   * @schema ClusterPolicySpecRulesContextImageRegistryImageRegistryCredentials#providers
   */
  readonly providers?: ClusterPolicySpecRulesContextImageRegistryImageRegistryCredentialsProviders[];

  /**
   * Secrets specifies a list of secrets that are provided for credentials.
   * Secrets must live in the Kyverno namespace.
   *
   * @schema ClusterPolicySpecRulesContextImageRegistryImageRegistryCredentials#secrets
   */
  readonly secrets?: string[];

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesContextImageRegistryImageRegistryCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesContextImageRegistryImageRegistryCredentials(obj: ClusterPolicySpecRulesContextImageRegistryImageRegistryCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowInsecureRegistry': obj.allowInsecureRegistry,
    'providers': obj.providers?.map(y => y),
    'secrets': obj.secrets?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceDescription contains information about the resource being created or modified.
 *
 * @schema ClusterPolicySpecRulesExcludeAllResources
 */
export interface ClusterPolicySpecRulesExcludeAllResources {
  /**
   * Annotations is a  map of annotations (key-value pairs of type string). Annotation keys
   * and values support the wildcard characters "*" (matches zero or many characters) and
   * "?" (matches at least one character).
   *
   * @schema ClusterPolicySpecRulesExcludeAllResources#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Kinds is a list of resource kinds.
   *
   * @schema ClusterPolicySpecRulesExcludeAllResources#kinds
   */
  readonly kinds?: string[];

  /**
   * Name is the name of the resource. The name supports wildcard characters
   * "*" (matches zero or many characters) and "?" (at least one character).
   * NOTE: "Name" is being deprecated in favor of "Names".
   *
   * @schema ClusterPolicySpecRulesExcludeAllResources#name
   */
  readonly name?: string;

  /**
   * Names are the names of the resources. Each name supports wildcard characters
   * "*" (matches zero or many characters) and "?" (at least one character).
   *
   * @schema ClusterPolicySpecRulesExcludeAllResources#names
   */
  readonly names?: string[];

  /**
   * NamespaceSelector is a label selector for the resource namespace. Label keys and values
   * in `matchLabels` support the wildcard characters `*` (matches zero or many characters)
   * and `?` (matches one character).Wildcards allows writing label selectors like
   * ["storage.k8s.io/*": "*"]. Note that using ["*" : "*"] matches any key and value but
   * does not match an empty label set.
   *
   * @schema ClusterPolicySpecRulesExcludeAllResources#namespaceSelector
   */
  readonly namespaceSelector?: ClusterPolicySpecRulesExcludeAllResourcesNamespaceSelector;

  /**
   * Namespaces is a list of namespaces names. Each name supports wildcard characters
   * "*" (matches zero or many characters) and "?" (at least one character).
   *
   * @schema ClusterPolicySpecRulesExcludeAllResources#namespaces
   */
  readonly namespaces?: string[];

  /**
   * Operations can contain values ["CREATE, "UPDATE", "CONNECT", "DELETE"], which are used to match a specific action.
   *
   * @schema ClusterPolicySpecRulesExcludeAllResources#operations
   */
  readonly operations?: ClusterPolicySpecRulesExcludeAllResourcesOperations[];

  /**
   * Selector is a label selector. Label keys and values in `matchLabels` support the wildcard
   * characters `*` (matches zero or many characters) and `?` (matches one character).
   * Wildcards allows writing label selectors like ["storage.k8s.io/*": "*"]. Note that
   * using ["*" : "*"] matches any key and value but does not match an empty label set.
   *
   * @schema ClusterPolicySpecRulesExcludeAllResources#selector
   */
  readonly selector?: ClusterPolicySpecRulesExcludeAllResourcesSelector;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesExcludeAllResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesExcludeAllResources(obj: ClusterPolicySpecRulesExcludeAllResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'kinds': obj.kinds?.map(y => y),
    'name': obj.name,
    'names': obj.names?.map(y => y),
    'namespaceSelector': toJson_ClusterPolicySpecRulesExcludeAllResourcesNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'operations': obj.operations?.map(y => y),
    'selector': toJson_ClusterPolicySpecRulesExcludeAllResourcesSelector(obj.selector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Subject contains a reference to the object or user identities a role binding applies to.  This can either hold a direct API object reference,
 * or a value for non-objects such as user and group names.
 *
 * @schema ClusterPolicySpecRulesExcludeAllSubjects
 */
export interface ClusterPolicySpecRulesExcludeAllSubjects {
  /**
   * APIGroup holds the API group of the referenced subject.
   * Defaults to "" for ServiceAccount subjects.
   * Defaults to "rbac.authorization.k8s.io" for User and Group subjects.
   *
   * @default for ServiceAccount subjects.
   * @schema ClusterPolicySpecRulesExcludeAllSubjects#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind of object being referenced. Values defined by this API group are "User", "Group", and "ServiceAccount".
   * If the Authorizer does not recognized the kind value, the Authorizer should report an error.
   *
   * @schema ClusterPolicySpecRulesExcludeAllSubjects#kind
   */
  readonly kind: string;

  /**
   * Name of the object being referenced.
   *
   * @schema ClusterPolicySpecRulesExcludeAllSubjects#name
   */
  readonly name: string;

  /**
   * Namespace of the referenced object.  If the object kind is non-namespace, such as "User" or "Group", and this value is not empty
   * the Authorizer should report an error.
   *
   * @schema ClusterPolicySpecRulesExcludeAllSubjects#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesExcludeAllSubjects' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesExcludeAllSubjects(obj: ClusterPolicySpecRulesExcludeAllSubjects | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceDescription contains information about the resource being created or modified.
 *
 * @schema ClusterPolicySpecRulesExcludeAnyResources
 */
export interface ClusterPolicySpecRulesExcludeAnyResources {
  /**
   * Annotations is a  map of annotations (key-value pairs of type string). Annotation keys
   * and values support the wildcard characters "*" (matches zero or many characters) and
   * "?" (matches at least one character).
   *
   * @schema ClusterPolicySpecRulesExcludeAnyResources#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Kinds is a list of resource kinds.
   *
   * @schema ClusterPolicySpecRulesExcludeAnyResources#kinds
   */
  readonly kinds?: string[];

  /**
   * Name is the name of the resource. The name supports wildcard characters
   * "*" (matches zero or many characters) and "?" (at least one character).
   * NOTE: "Name" is being deprecated in favor of "Names".
   *
   * @schema ClusterPolicySpecRulesExcludeAnyResources#name
   */
  readonly name?: string;

  /**
   * Names are the names of the resources. Each name supports wildcard characters
   * "*" (matches zero or many characters) and "?" (at least one character).
   *
   * @schema ClusterPolicySpecRulesExcludeAnyResources#names
   */
  readonly names?: string[];

  /**
   * NamespaceSelector is a label selector for the resource namespace. Label keys and values
   * in `matchLabels` support the wildcard characters `*` (matches zero or many characters)
   * and `?` (matches one character).Wildcards allows writing label selectors like
   * ["storage.k8s.io/*": "*"]. Note that using ["*" : "*"] matches any key and value but
   * does not match an empty label set.
   *
   * @schema ClusterPolicySpecRulesExcludeAnyResources#namespaceSelector
   */
  readonly namespaceSelector?: ClusterPolicySpecRulesExcludeAnyResourcesNamespaceSelector;

  /**
   * Namespaces is a list of namespaces names. Each name supports wildcard characters
   * "*" (matches zero or many characters) and "?" (at least one character).
   *
   * @schema ClusterPolicySpecRulesExcludeAnyResources#namespaces
   */
  readonly namespaces?: string[];

  /**
   * Operations can contain values ["CREATE, "UPDATE", "CONNECT", "DELETE"], which are used to match a specific action.
   *
   * @schema ClusterPolicySpecRulesExcludeAnyResources#operations
   */
  readonly operations?: ClusterPolicySpecRulesExcludeAnyResourcesOperations[];

  /**
   * Selector is a label selector. Label keys and values in `matchLabels` support the wildcard
   * characters `*` (matches zero or many characters) and `?` (matches one character).
   * Wildcards allows writing label selectors like ["storage.k8s.io/*": "*"]. Note that
   * using ["*" : "*"] matches any key and value but does not match an empty label set.
   *
   * @schema ClusterPolicySpecRulesExcludeAnyResources#selector
   */
  readonly selector?: ClusterPolicySpecRulesExcludeAnyResourcesSelector;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesExcludeAnyResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesExcludeAnyResources(obj: ClusterPolicySpecRulesExcludeAnyResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'kinds': obj.kinds?.map(y => y),
    'name': obj.name,
    'names': obj.names?.map(y => y),
    'namespaceSelector': toJson_ClusterPolicySpecRulesExcludeAnyResourcesNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'operations': obj.operations?.map(y => y),
    'selector': toJson_ClusterPolicySpecRulesExcludeAnyResourcesSelector(obj.selector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Subject contains a reference to the object or user identities a role binding applies to.  This can either hold a direct API object reference,
 * or a value for non-objects such as user and group names.
 *
 * @schema ClusterPolicySpecRulesExcludeAnySubjects
 */
export interface ClusterPolicySpecRulesExcludeAnySubjects {
  /**
   * APIGroup holds the API group of the referenced subject.
   * Defaults to "" for ServiceAccount subjects.
   * Defaults to "rbac.authorization.k8s.io" for User and Group subjects.
   *
   * @default for ServiceAccount subjects.
   * @schema ClusterPolicySpecRulesExcludeAnySubjects#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind of object being referenced. Values defined by this API group are "User", "Group", and "ServiceAccount".
   * If the Authorizer does not recognized the kind value, the Authorizer should report an error.
   *
   * @schema ClusterPolicySpecRulesExcludeAnySubjects#kind
   */
  readonly kind: string;

  /**
   * Name of the object being referenced.
   *
   * @schema ClusterPolicySpecRulesExcludeAnySubjects#name
   */
  readonly name: string;

  /**
   * Namespace of the referenced object.  If the object kind is non-namespace, such as "User" or "Group", and this value is not empty
   * the Authorizer should report an error.
   *
   * @schema ClusterPolicySpecRulesExcludeAnySubjects#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesExcludeAnySubjects' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesExcludeAnySubjects(obj: ClusterPolicySpecRulesExcludeAnySubjects | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NamespaceSelector is a label selector for the resource namespace. Label keys and values
 * in `matchLabels` support the wildcard characters `*` (matches zero or many characters)
 * and `?` (matches one character).Wildcards allows writing label selectors like
 * ["storage.k8s.io/*": "*"]. Note that using ["*" : "*"] matches any key and value but
 * does not match an empty label set.
 *
 * @schema ClusterPolicySpecRulesExcludeResourcesNamespaceSelector
 */
export interface ClusterPolicySpecRulesExcludeResourcesNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterPolicySpecRulesExcludeResourcesNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterPolicySpecRulesExcludeResourcesNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterPolicySpecRulesExcludeResourcesNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesExcludeResourcesNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesExcludeResourcesNamespaceSelector(obj: ClusterPolicySpecRulesExcludeResourcesNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterPolicySpecRulesExcludeResourcesNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AdmissionOperation can have one of the values CREATE, UPDATE, CONNECT, DELETE, which are used to match a specific action.
 *
 * @schema ClusterPolicySpecRulesExcludeResourcesOperations
 */
export enum ClusterPolicySpecRulesExcludeResourcesOperations {
  /** CREATE */
  CREATE = "CREATE",
  /** CONNECT */
  CONNECT = "CONNECT",
  /** UPDATE */
  UPDATE = "UPDATE",
  /** DELETE */
  DELETE = "DELETE",
}

/**
 * Selector is a label selector. Label keys and values in `matchLabels` support the wildcard
 * characters `*` (matches zero or many characters) and `?` (matches one character).
 * Wildcards allows writing label selectors like ["storage.k8s.io/*": "*"]. Note that
 * using ["*" : "*"] matches any key and value but does not match an empty label set.
 *
 * @schema ClusterPolicySpecRulesExcludeResourcesSelector
 */
export interface ClusterPolicySpecRulesExcludeResourcesSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterPolicySpecRulesExcludeResourcesSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterPolicySpecRulesExcludeResourcesSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterPolicySpecRulesExcludeResourcesSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesExcludeResourcesSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesExcludeResourcesSelector(obj: ClusterPolicySpecRulesExcludeResourcesSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterPolicySpecRulesExcludeResourcesSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector is a label selector. Label keys and values in `matchLabels`.
 * wildcard characters are not supported.
 *
 * @schema ClusterPolicySpecRulesGenerateCloneListSelector
 */
export interface ClusterPolicySpecRulesGenerateCloneListSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterPolicySpecRulesGenerateCloneListSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterPolicySpecRulesGenerateCloneListSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterPolicySpecRulesGenerateCloneListSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesGenerateCloneListSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesGenerateCloneListSelector(obj: ClusterPolicySpecRulesGenerateCloneListSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterPolicySpecRulesGenerateCloneListSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Clone specifies the source resource used to populate each generated resource.
 * At most one of Data or Clone can be specified. If neither are provided, the generated
 * resource will be created with default data only.
 *
 * @schema ClusterPolicySpecRulesGenerateForeachClone
 */
export interface ClusterPolicySpecRulesGenerateForeachClone {
  /**
   * Name specifies name of the resource.
   *
   * @schema ClusterPolicySpecRulesGenerateForeachClone#name
   */
  readonly name?: string;

  /**
   * Namespace specifies source resource namespace.
   *
   * @schema ClusterPolicySpecRulesGenerateForeachClone#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesGenerateForeachClone' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesGenerateForeachClone(obj: ClusterPolicySpecRulesGenerateForeachClone | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CloneList specifies the list of source resource used to populate each generated resource.
 *
 * @schema ClusterPolicySpecRulesGenerateForeachCloneList
 */
export interface ClusterPolicySpecRulesGenerateForeachCloneList {
  /**
   * Kinds is a list of resource kinds.
   *
   * @schema ClusterPolicySpecRulesGenerateForeachCloneList#kinds
   */
  readonly kinds?: string[];

  /**
   * Namespace specifies source resource namespace.
   *
   * @schema ClusterPolicySpecRulesGenerateForeachCloneList#namespace
   */
  readonly namespace?: string;

  /**
   * Selector is a label selector. Label keys and values in `matchLabels`.
   * wildcard characters are not supported.
   *
   * @schema ClusterPolicySpecRulesGenerateForeachCloneList#selector
   */
  readonly selector?: ClusterPolicySpecRulesGenerateForeachCloneListSelector;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesGenerateForeachCloneList' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesGenerateForeachCloneList(obj: ClusterPolicySpecRulesGenerateForeachCloneList | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kinds': obj.kinds?.map(y => y),
    'namespace': obj.namespace,
    'selector': toJson_ClusterPolicySpecRulesGenerateForeachCloneListSelector(obj.selector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ContextEntry adds variables and data sources to a rule Context. Either a
 * ConfigMap reference or a APILookup must be provided.
 *
 * @schema ClusterPolicySpecRulesGenerateForeachContext
 */
export interface ClusterPolicySpecRulesGenerateForeachContext {
  /**
   * APICall is an HTTP request to the Kubernetes API server, or other JSON web service.
   * The data returned is stored in the context with the name for the context entry.
   *
   * @schema ClusterPolicySpecRulesGenerateForeachContext#apiCall
   */
  readonly apiCall?: ClusterPolicySpecRulesGenerateForeachContextApiCall;

  /**
   * ConfigMap is the ConfigMap reference.
   *
   * @schema ClusterPolicySpecRulesGenerateForeachContext#configMap
   */
  readonly configMap?: ClusterPolicySpecRulesGenerateForeachContextConfigMap;

  /**
   * GlobalContextEntryReference is a reference to a cached global context entry.
   *
   * @schema ClusterPolicySpecRulesGenerateForeachContext#globalReference
   */
  readonly globalReference?: ClusterPolicySpecRulesGenerateForeachContextGlobalReference;

  /**
   * ImageRegistry defines requests to an OCI/Docker V2 registry to fetch image
   * details.
   *
   * @schema ClusterPolicySpecRulesGenerateForeachContext#imageRegistry
   */
  readonly imageRegistry?: ClusterPolicySpecRulesGenerateForeachContextImageRegistry;

  /**
   * Name is the variable name.
   *
   * @schema ClusterPolicySpecRulesGenerateForeachContext#name
   */
  readonly name: string;

  /**
   * Variable defines an arbitrary JMESPath context variable that can be defined inline.
   *
   * @schema ClusterPolicySpecRulesGenerateForeachContext#variable
   */
  readonly variable?: ClusterPolicySpecRulesGenerateForeachContextVariable;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesGenerateForeachContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesGenerateForeachContext(obj: ClusterPolicySpecRulesGenerateForeachContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiCall': toJson_ClusterPolicySpecRulesGenerateForeachContextApiCall(obj.apiCall),
    'configMap': toJson_ClusterPolicySpecRulesGenerateForeachContextConfigMap(obj.configMap),
    'globalReference': toJson_ClusterPolicySpecRulesGenerateForeachContextGlobalReference(obj.globalReference),
    'imageRegistry': toJson_ClusterPolicySpecRulesGenerateForeachContextImageRegistry(obj.imageRegistry),
    'name': obj.name,
    'variable': toJson_ClusterPolicySpecRulesGenerateForeachContextVariable(obj.variable),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AnyAllConditions are used to determine if a policy rule should be applied by evaluating a
 * set of conditions. The declaration can contain nested `any` or `all` statements.
 * See: https://kyverno.io/docs/writing-policies/preconditions/
 *
 * @schema ClusterPolicySpecRulesGenerateForeachPreconditions
 */
export interface ClusterPolicySpecRulesGenerateForeachPreconditions {
  /**
   * AllConditions enable variable-based conditional rule execution. This is useful for
   * finer control of when an rule is applied. A condition can reference object data
   * using JMESPath notation.
   * Here, all of the conditions need to pass
   *
   * @schema ClusterPolicySpecRulesGenerateForeachPreconditions#all
   */
  readonly all?: ClusterPolicySpecRulesGenerateForeachPreconditionsAll[];

  /**
   * AnyConditions enable variable-based conditional rule execution. This is useful for
   * finer control of when an rule is applied. A condition can reference object data
   * using JMESPath notation.
   * Here, at least one of the conditions need to pass
   *
   * @schema ClusterPolicySpecRulesGenerateForeachPreconditions#any
   */
  readonly any?: ClusterPolicySpecRulesGenerateForeachPreconditionsAny[];

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesGenerateForeachPreconditions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesGenerateForeachPreconditions(obj: ClusterPolicySpecRulesGenerateForeachPreconditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'all': obj.all?.map(y => toJson_ClusterPolicySpecRulesGenerateForeachPreconditionsAll(y)),
    'any': obj.any?.map(y => toJson_ClusterPolicySpecRulesGenerateForeachPreconditionsAny(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceDescription contains information about the resource being created or modified.
 *
 * @schema ClusterPolicySpecRulesMatchAllResources
 */
export interface ClusterPolicySpecRulesMatchAllResources {
  /**
   * Annotations is a  map of annotations (key-value pairs of type string). Annotation keys
   * and values support the wildcard characters "*" (matches zero or many characters) and
   * "?" (matches at least one character).
   *
   * @schema ClusterPolicySpecRulesMatchAllResources#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Kinds is a list of resource kinds.
   *
   * @schema ClusterPolicySpecRulesMatchAllResources#kinds
   */
  readonly kinds?: string[];

  /**
   * Name is the name of the resource. The name supports wildcard characters
   * "*" (matches zero or many characters) and "?" (at least one character).
   * NOTE: "Name" is being deprecated in favor of "Names".
   *
   * @schema ClusterPolicySpecRulesMatchAllResources#name
   */
  readonly name?: string;

  /**
   * Names are the names of the resources. Each name supports wildcard characters
   * "*" (matches zero or many characters) and "?" (at least one character).
   *
   * @schema ClusterPolicySpecRulesMatchAllResources#names
   */
  readonly names?: string[];

  /**
   * NamespaceSelector is a label selector for the resource namespace. Label keys and values
   * in `matchLabels` support the wildcard characters `*` (matches zero or many characters)
   * and `?` (matches one character).Wildcards allows writing label selectors like
   * ["storage.k8s.io/*": "*"]. Note that using ["*" : "*"] matches any key and value but
   * does not match an empty label set.
   *
   * @schema ClusterPolicySpecRulesMatchAllResources#namespaceSelector
   */
  readonly namespaceSelector?: ClusterPolicySpecRulesMatchAllResourcesNamespaceSelector;

  /**
   * Namespaces is a list of namespaces names. Each name supports wildcard characters
   * "*" (matches zero or many characters) and "?" (at least one character).
   *
   * @schema ClusterPolicySpecRulesMatchAllResources#namespaces
   */
  readonly namespaces?: string[];

  /**
   * Operations can contain values ["CREATE, "UPDATE", "CONNECT", "DELETE"], which are used to match a specific action.
   *
   * @schema ClusterPolicySpecRulesMatchAllResources#operations
   */
  readonly operations?: ClusterPolicySpecRulesMatchAllResourcesOperations[];

  /**
   * Selector is a label selector. Label keys and values in `matchLabels` support the wildcard
   * characters `*` (matches zero or many characters) and `?` (matches one character).
   * Wildcards allows writing label selectors like ["storage.k8s.io/*": "*"]. Note that
   * using ["*" : "*"] matches any key and value but does not match an empty label set.
   *
   * @schema ClusterPolicySpecRulesMatchAllResources#selector
   */
  readonly selector?: ClusterPolicySpecRulesMatchAllResourcesSelector;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMatchAllResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMatchAllResources(obj: ClusterPolicySpecRulesMatchAllResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'kinds': obj.kinds?.map(y => y),
    'name': obj.name,
    'names': obj.names?.map(y => y),
    'namespaceSelector': toJson_ClusterPolicySpecRulesMatchAllResourcesNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'operations': obj.operations?.map(y => y),
    'selector': toJson_ClusterPolicySpecRulesMatchAllResourcesSelector(obj.selector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Subject contains a reference to the object or user identities a role binding applies to.  This can either hold a direct API object reference,
 * or a value for non-objects such as user and group names.
 *
 * @schema ClusterPolicySpecRulesMatchAllSubjects
 */
export interface ClusterPolicySpecRulesMatchAllSubjects {
  /**
   * APIGroup holds the API group of the referenced subject.
   * Defaults to "" for ServiceAccount subjects.
   * Defaults to "rbac.authorization.k8s.io" for User and Group subjects.
   *
   * @default for ServiceAccount subjects.
   * @schema ClusterPolicySpecRulesMatchAllSubjects#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind of object being referenced. Values defined by this API group are "User", "Group", and "ServiceAccount".
   * If the Authorizer does not recognized the kind value, the Authorizer should report an error.
   *
   * @schema ClusterPolicySpecRulesMatchAllSubjects#kind
   */
  readonly kind: string;

  /**
   * Name of the object being referenced.
   *
   * @schema ClusterPolicySpecRulesMatchAllSubjects#name
   */
  readonly name: string;

  /**
   * Namespace of the referenced object.  If the object kind is non-namespace, such as "User" or "Group", and this value is not empty
   * the Authorizer should report an error.
   *
   * @schema ClusterPolicySpecRulesMatchAllSubjects#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMatchAllSubjects' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMatchAllSubjects(obj: ClusterPolicySpecRulesMatchAllSubjects | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceDescription contains information about the resource being created or modified.
 *
 * @schema ClusterPolicySpecRulesMatchAnyResources
 */
export interface ClusterPolicySpecRulesMatchAnyResources {
  /**
   * Annotations is a  map of annotations (key-value pairs of type string). Annotation keys
   * and values support the wildcard characters "*" (matches zero or many characters) and
   * "?" (matches at least one character).
   *
   * @schema ClusterPolicySpecRulesMatchAnyResources#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Kinds is a list of resource kinds.
   *
   * @schema ClusterPolicySpecRulesMatchAnyResources#kinds
   */
  readonly kinds?: string[];

  /**
   * Name is the name of the resource. The name supports wildcard characters
   * "*" (matches zero or many characters) and "?" (at least one character).
   * NOTE: "Name" is being deprecated in favor of "Names".
   *
   * @schema ClusterPolicySpecRulesMatchAnyResources#name
   */
  readonly name?: string;

  /**
   * Names are the names of the resources. Each name supports wildcard characters
   * "*" (matches zero or many characters) and "?" (at least one character).
   *
   * @schema ClusterPolicySpecRulesMatchAnyResources#names
   */
  readonly names?: string[];

  /**
   * NamespaceSelector is a label selector for the resource namespace. Label keys and values
   * in `matchLabels` support the wildcard characters `*` (matches zero or many characters)
   * and `?` (matches one character).Wildcards allows writing label selectors like
   * ["storage.k8s.io/*": "*"]. Note that using ["*" : "*"] matches any key and value but
   * does not match an empty label set.
   *
   * @schema ClusterPolicySpecRulesMatchAnyResources#namespaceSelector
   */
  readonly namespaceSelector?: ClusterPolicySpecRulesMatchAnyResourcesNamespaceSelector;

  /**
   * Namespaces is a list of namespaces names. Each name supports wildcard characters
   * "*" (matches zero or many characters) and "?" (at least one character).
   *
   * @schema ClusterPolicySpecRulesMatchAnyResources#namespaces
   */
  readonly namespaces?: string[];

  /**
   * Operations can contain values ["CREATE, "UPDATE", "CONNECT", "DELETE"], which are used to match a specific action.
   *
   * @schema ClusterPolicySpecRulesMatchAnyResources#operations
   */
  readonly operations?: ClusterPolicySpecRulesMatchAnyResourcesOperations[];

  /**
   * Selector is a label selector. Label keys and values in `matchLabels` support the wildcard
   * characters `*` (matches zero or many characters) and `?` (matches one character).
   * Wildcards allows writing label selectors like ["storage.k8s.io/*": "*"]. Note that
   * using ["*" : "*"] matches any key and value but does not match an empty label set.
   *
   * @schema ClusterPolicySpecRulesMatchAnyResources#selector
   */
  readonly selector?: ClusterPolicySpecRulesMatchAnyResourcesSelector;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMatchAnyResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMatchAnyResources(obj: ClusterPolicySpecRulesMatchAnyResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'kinds': obj.kinds?.map(y => y),
    'name': obj.name,
    'names': obj.names?.map(y => y),
    'namespaceSelector': toJson_ClusterPolicySpecRulesMatchAnyResourcesNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'operations': obj.operations?.map(y => y),
    'selector': toJson_ClusterPolicySpecRulesMatchAnyResourcesSelector(obj.selector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Subject contains a reference to the object or user identities a role binding applies to.  This can either hold a direct API object reference,
 * or a value for non-objects such as user and group names.
 *
 * @schema ClusterPolicySpecRulesMatchAnySubjects
 */
export interface ClusterPolicySpecRulesMatchAnySubjects {
  /**
   * APIGroup holds the API group of the referenced subject.
   * Defaults to "" for ServiceAccount subjects.
   * Defaults to "rbac.authorization.k8s.io" for User and Group subjects.
   *
   * @default for ServiceAccount subjects.
   * @schema ClusterPolicySpecRulesMatchAnySubjects#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind of object being referenced. Values defined by this API group are "User", "Group", and "ServiceAccount".
   * If the Authorizer does not recognized the kind value, the Authorizer should report an error.
   *
   * @schema ClusterPolicySpecRulesMatchAnySubjects#kind
   */
  readonly kind: string;

  /**
   * Name of the object being referenced.
   *
   * @schema ClusterPolicySpecRulesMatchAnySubjects#name
   */
  readonly name: string;

  /**
   * Namespace of the referenced object.  If the object kind is non-namespace, such as "User" or "Group", and this value is not empty
   * the Authorizer should report an error.
   *
   * @schema ClusterPolicySpecRulesMatchAnySubjects#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMatchAnySubjects' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMatchAnySubjects(obj: ClusterPolicySpecRulesMatchAnySubjects | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NamespaceSelector is a label selector for the resource namespace. Label keys and values
 * in `matchLabels` support the wildcard characters `*` (matches zero or many characters)
 * and `?` (matches one character).Wildcards allows writing label selectors like
 * ["storage.k8s.io/*": "*"]. Note that using ["*" : "*"] matches any key and value but
 * does not match an empty label set.
 *
 * @schema ClusterPolicySpecRulesMatchResourcesNamespaceSelector
 */
export interface ClusterPolicySpecRulesMatchResourcesNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterPolicySpecRulesMatchResourcesNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterPolicySpecRulesMatchResourcesNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterPolicySpecRulesMatchResourcesNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMatchResourcesNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMatchResourcesNamespaceSelector(obj: ClusterPolicySpecRulesMatchResourcesNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterPolicySpecRulesMatchResourcesNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AdmissionOperation can have one of the values CREATE, UPDATE, CONNECT, DELETE, which are used to match a specific action.
 *
 * @schema ClusterPolicySpecRulesMatchResourcesOperations
 */
export enum ClusterPolicySpecRulesMatchResourcesOperations {
  /** CREATE */
  CREATE = "CREATE",
  /** CONNECT */
  CONNECT = "CONNECT",
  /** UPDATE */
  UPDATE = "UPDATE",
  /** DELETE */
  DELETE = "DELETE",
}

/**
 * Selector is a label selector. Label keys and values in `matchLabels` support the wildcard
 * characters `*` (matches zero or many characters) and `?` (matches one character).
 * Wildcards allows writing label selectors like ["storage.k8s.io/*": "*"]. Note that
 * using ["*" : "*"] matches any key and value but does not match an empty label set.
 *
 * @schema ClusterPolicySpecRulesMatchResourcesSelector
 */
export interface ClusterPolicySpecRulesMatchResourcesSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterPolicySpecRulesMatchResourcesSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterPolicySpecRulesMatchResourcesSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterPolicySpecRulesMatchResourcesSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMatchResourcesSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMatchResourcesSelector(obj: ClusterPolicySpecRulesMatchResourcesSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterPolicySpecRulesMatchResourcesSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ContextEntry adds variables and data sources to a rule Context. Either a
 * ConfigMap reference or a APILookup must be provided.
 *
 * @schema ClusterPolicySpecRulesMutateForeachContext
 */
export interface ClusterPolicySpecRulesMutateForeachContext {
  /**
   * APICall is an HTTP request to the Kubernetes API server, or other JSON web service.
   * The data returned is stored in the context with the name for the context entry.
   *
   * @schema ClusterPolicySpecRulesMutateForeachContext#apiCall
   */
  readonly apiCall?: ClusterPolicySpecRulesMutateForeachContextApiCall;

  /**
   * ConfigMap is the ConfigMap reference.
   *
   * @schema ClusterPolicySpecRulesMutateForeachContext#configMap
   */
  readonly configMap?: ClusterPolicySpecRulesMutateForeachContextConfigMap;

  /**
   * GlobalContextEntryReference is a reference to a cached global context entry.
   *
   * @schema ClusterPolicySpecRulesMutateForeachContext#globalReference
   */
  readonly globalReference?: ClusterPolicySpecRulesMutateForeachContextGlobalReference;

  /**
   * ImageRegistry defines requests to an OCI/Docker V2 registry to fetch image
   * details.
   *
   * @schema ClusterPolicySpecRulesMutateForeachContext#imageRegistry
   */
  readonly imageRegistry?: ClusterPolicySpecRulesMutateForeachContextImageRegistry;

  /**
   * Name is the variable name.
   *
   * @schema ClusterPolicySpecRulesMutateForeachContext#name
   */
  readonly name: string;

  /**
   * Variable defines an arbitrary JMESPath context variable that can be defined inline.
   *
   * @schema ClusterPolicySpecRulesMutateForeachContext#variable
   */
  readonly variable?: ClusterPolicySpecRulesMutateForeachContextVariable;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMutateForeachContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMutateForeachContext(obj: ClusterPolicySpecRulesMutateForeachContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiCall': toJson_ClusterPolicySpecRulesMutateForeachContextApiCall(obj.apiCall),
    'configMap': toJson_ClusterPolicySpecRulesMutateForeachContextConfigMap(obj.configMap),
    'globalReference': toJson_ClusterPolicySpecRulesMutateForeachContextGlobalReference(obj.globalReference),
    'imageRegistry': toJson_ClusterPolicySpecRulesMutateForeachContextImageRegistry(obj.imageRegistry),
    'name': obj.name,
    'variable': toJson_ClusterPolicySpecRulesMutateForeachContextVariable(obj.variable),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Order defines the iteration order on the list.
 * Can be Ascending to iterate from first to last element or Descending to iterate in from last to first element.
 *
 * @schema ClusterPolicySpecRulesMutateForeachOrder
 */
export enum ClusterPolicySpecRulesMutateForeachOrder {
  /** Ascending */
  ASCENDING = "Ascending",
  /** Descending */
  DESCENDING = "Descending",
}

/**
 * AnyAllConditions are used to determine if a policy rule should be applied by evaluating a
 * set of conditions. The declaration can contain nested `any` or `all` statements.
 * See: https://kyverno.io/docs/writing-policies/preconditions/
 *
 * @schema ClusterPolicySpecRulesMutateForeachPreconditions
 */
export interface ClusterPolicySpecRulesMutateForeachPreconditions {
  /**
   * AllConditions enable variable-based conditional rule execution. This is useful for
   * finer control of when an rule is applied. A condition can reference object data
   * using JMESPath notation.
   * Here, all of the conditions need to pass
   *
   * @schema ClusterPolicySpecRulesMutateForeachPreconditions#all
   */
  readonly all?: ClusterPolicySpecRulesMutateForeachPreconditionsAll[];

  /**
   * AnyConditions enable variable-based conditional rule execution. This is useful for
   * finer control of when an rule is applied. A condition can reference object data
   * using JMESPath notation.
   * Here, at least one of the conditions need to pass
   *
   * @schema ClusterPolicySpecRulesMutateForeachPreconditions#any
   */
  readonly any?: ClusterPolicySpecRulesMutateForeachPreconditionsAny[];

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMutateForeachPreconditions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMutateForeachPreconditions(obj: ClusterPolicySpecRulesMutateForeachPreconditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'all': obj.all?.map(y => toJson_ClusterPolicySpecRulesMutateForeachPreconditionsAll(y)),
    'any': obj.any?.map(y => toJson_ClusterPolicySpecRulesMutateForeachPreconditionsAny(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ContextEntry adds variables and data sources to a rule Context. Either a
 * ConfigMap reference or a APILookup must be provided.
 *
 * @schema ClusterPolicySpecRulesMutateTargetsContext
 */
export interface ClusterPolicySpecRulesMutateTargetsContext {
  /**
   * APICall is an HTTP request to the Kubernetes API server, or other JSON web service.
   * The data returned is stored in the context with the name for the context entry.
   *
   * @schema ClusterPolicySpecRulesMutateTargetsContext#apiCall
   */
  readonly apiCall?: ClusterPolicySpecRulesMutateTargetsContextApiCall;

  /**
   * ConfigMap is the ConfigMap reference.
   *
   * @schema ClusterPolicySpecRulesMutateTargetsContext#configMap
   */
  readonly configMap?: ClusterPolicySpecRulesMutateTargetsContextConfigMap;

  /**
   * GlobalContextEntryReference is a reference to a cached global context entry.
   *
   * @schema ClusterPolicySpecRulesMutateTargetsContext#globalReference
   */
  readonly globalReference?: ClusterPolicySpecRulesMutateTargetsContextGlobalReference;

  /**
   * ImageRegistry defines requests to an OCI/Docker V2 registry to fetch image
   * details.
   *
   * @schema ClusterPolicySpecRulesMutateTargetsContext#imageRegistry
   */
  readonly imageRegistry?: ClusterPolicySpecRulesMutateTargetsContextImageRegistry;

  /**
   * Name is the variable name.
   *
   * @schema ClusterPolicySpecRulesMutateTargetsContext#name
   */
  readonly name: string;

  /**
   * Variable defines an arbitrary JMESPath context variable that can be defined inline.
   *
   * @schema ClusterPolicySpecRulesMutateTargetsContext#variable
   */
  readonly variable?: ClusterPolicySpecRulesMutateTargetsContextVariable;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMutateTargetsContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMutateTargetsContext(obj: ClusterPolicySpecRulesMutateTargetsContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiCall': toJson_ClusterPolicySpecRulesMutateTargetsContextApiCall(obj.apiCall),
    'configMap': toJson_ClusterPolicySpecRulesMutateTargetsContextConfigMap(obj.configMap),
    'globalReference': toJson_ClusterPolicySpecRulesMutateTargetsContextGlobalReference(obj.globalReference),
    'imageRegistry': toJson_ClusterPolicySpecRulesMutateTargetsContextImageRegistry(obj.imageRegistry),
    'name': obj.name,
    'variable': toJson_ClusterPolicySpecRulesMutateTargetsContextVariable(obj.variable),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector allows you to select target resources with their labels.
 *
 * @schema ClusterPolicySpecRulesMutateTargetsSelector
 */
export interface ClusterPolicySpecRulesMutateTargetsSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterPolicySpecRulesMutateTargetsSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterPolicySpecRulesMutateTargetsSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterPolicySpecRulesMutateTargetsSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMutateTargetsSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMutateTargetsSelector(obj: ClusterPolicySpecRulesMutateTargetsSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterPolicySpecRulesMutateTargetsSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AuditAnnotation describes how to produce an audit annotation for an API request.
 *
 * @schema ClusterPolicySpecRulesValidateCelAuditAnnotations
 */
export interface ClusterPolicySpecRulesValidateCelAuditAnnotations {
  /**
   * key specifies the audit annotation key. The audit annotation keys of
   * a ValidatingAdmissionPolicy must be unique. The key must be a qualified
   * name ([A-Za-z0-9][-A-Za-z0-9_.]*) no more than 63 bytes in length.
   *
   * The key is combined with the resource name of the
   * ValidatingAdmissionPolicy to construct an audit annotation key:
   * "{ValidatingAdmissionPolicy name}/{key}".
   *
   * If an admission webhook uses the same resource name as this ValidatingAdmissionPolicy
   * and the same audit annotation key, the annotation key will be identical.
   * In this case, the first annotation written with the key will be included
   * in the audit event and all subsequent annotations with the same key
   * will be discarded.
   *
   * Required.
   *
   * @schema ClusterPolicySpecRulesValidateCelAuditAnnotations#key
   */
  readonly key: string;

  /**
   * valueExpression represents the expression which is evaluated by CEL to
   * produce an audit annotation value. The expression must evaluate to either
   * a string or null value. If the expression evaluates to a string, the
   * audit annotation is included with the string value. If the expression
   * evaluates to null or empty string the audit annotation will be omitted.
   * The valueExpression may be no longer than 5kb in length.
   * If the result of the valueExpression is more than 10kb in length, it
   * will be truncated to 10kb.
   *
   * If multiple ValidatingAdmissionPolicyBinding resources match an
   * API request, then the valueExpression will be evaluated for
   * each binding. All unique values produced by the valueExpressions
   * will be joined together in a comma-separated list.
   *
   * Required.
   *
   * @schema ClusterPolicySpecRulesValidateCelAuditAnnotations#valueExpression
   */
  readonly valueExpression: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesValidateCelAuditAnnotations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesValidateCelAuditAnnotations(obj: ClusterPolicySpecRulesValidateCelAuditAnnotations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'valueExpression': obj.valueExpression,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Validation specifies the CEL expression which is used to apply the validation.
 *
 * @schema ClusterPolicySpecRulesValidateCelExpressions
 */
export interface ClusterPolicySpecRulesValidateCelExpressions {
  /**
   * Expression represents the expression which will be evaluated by CEL.
   * ref: https://github.com/google/cel-spec
   * CEL expressions have access to the contents of the API request/response, organized into CEL variables as well as some other useful variables:
   *
   * - 'object' - The object from the incoming request. The value is null for DELETE requests.
   * - 'oldObject' - The existing object. The value is null for CREATE requests.
   * - 'request' - Attributes of the API request([ref](/pkg/apis/admission/types.go#AdmissionRequest)).
   * - 'params' - Parameter resource referred to by the policy binding being evaluated. Only populated if the policy has a ParamKind.
   * - 'namespaceObject' - The namespace object that the incoming object belongs to. The value is null for cluster-scoped resources.
   * - 'variables' - Map of composited variables, from its name to its lazily evaluated value.
   * For example, a variable named 'foo' can be accessed as 'variables.foo'.
   * - 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
   * See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
   * - 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
   * request resource.
   *
   * The `apiVersion`, `kind`, `metadata.name` and `metadata.generateName` are always accessible from the root of the
   * object. No other metadata properties are accessible.
   *
   * Only property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible.
   * Accessible property names are escaped according to the following rules when accessed in the expression:
   * - '__' escapes to '__underscores__'
   * - '.' escapes to '__dot__'
   * - '-' escapes to '__dash__'
   * - '/' escapes to '__slash__'
   * - Property names that exactly match a CEL RESERVED keyword escape to '__{keyword}__'. The keywords are:
   * "true", "false", "null", "in", "as", "break", "const", "continue", "else", "for", "function", "if",
   * "import", "let", "loop", "package", "namespace", "return".
   * Examples:
   * - Expression accessing a property named "namespace": {"Expression": "object.__namespace__ > 0"}
   * - Expression accessing a property named "x-prop": {"Expression": "object.x__dash__prop > 0"}
   * - Expression accessing a property named "redact__d": {"Expression": "object.redact__underscores__d > 0"}
   *
   * Equality on arrays with list type of 'set' or 'map' ignores element order, i.e. [1, 2] == [2, 1].
   * Concatenation on arrays with x-kubernetes-list-type use the semantics of the list type:
   * - 'set': `X + Y` performs a union where the array positions of all elements in `X` are preserved and
   * non-intersecting elements in `Y` are appended, retaining their partial order.
   * - 'map': `X + Y` performs a merge where the array positions of all keys in `X` are preserved but the values
   * are overwritten by values in `Y` when the key sets of `X` and `Y` intersect. Elements in `Y` with
   * non-intersecting keys are appended, retaining their partial order.
   * Required.
   *
   * @schema ClusterPolicySpecRulesValidateCelExpressions#expression
   */
  readonly expression: string;

  /**
   * Message represents the message displayed when validation fails. The message is required if the Expression contains
   * line breaks. The message must not contain line breaks.
   * If unset, the message is "failed rule: {Rule}".
   * e.g. "must be a URL with the host matching spec.host"
   * If the Expression contains line breaks. Message is required.
   * The message must not contain line breaks.
   * If unset, the message is "failed Expression: {Expression}".
   *
   * @schema ClusterPolicySpecRulesValidateCelExpressions#message
   */
  readonly message?: string;

  /**
   * messageExpression declares a CEL expression that evaluates to the validation failure message that is returned when this rule fails.
   * Since messageExpression is used as a failure message, it must evaluate to a string.
   * If both message and messageExpression are present on a validation, then messageExpression will be used if validation fails.
   * If messageExpression results in a runtime error, the runtime error is logged, and the validation failure message is produced
   * as if the messageExpression field were unset. If messageExpression evaluates to an empty string, a string with only spaces, or a string
   * that contains line breaks, then the validation failure message will also be produced as if the messageExpression field were unset, and
   * the fact that messageExpression produced an empty string/string with only spaces/string with line breaks will be logged.
   * messageExpression has access to all the same variables as the `expression` except for 'authorizer' and 'authorizer.requestResource'.
   * Example:
   * "object.x must be less than max ("+string(params.max)+")"
   *
   * @schema ClusterPolicySpecRulesValidateCelExpressions#messageExpression
   */
  readonly messageExpression?: string;

  /**
   * Reason represents a machine-readable description of why this validation failed.
   * If this is the first validation in the list to fail, this reason, as well as the
   * corresponding HTTP response code, are used in the
   * HTTP response to the client.
   * The currently supported reasons are: "Unauthorized", "Forbidden", "Invalid", "RequestEntityTooLarge".
   * If not set, StatusReasonInvalid is used in the response to the client.
   *
   * @schema ClusterPolicySpecRulesValidateCelExpressions#reason
   */
  readonly reason?: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesValidateCelExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesValidateCelExpressions(obj: ClusterPolicySpecRulesValidateCelExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'expression': obj.expression,
    'message': obj.message,
    'messageExpression': obj.messageExpression,
    'reason': obj.reason,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ParamKind is a tuple of Group Kind and Version.
 *
 * @schema ClusterPolicySpecRulesValidateCelParamKind
 */
export interface ClusterPolicySpecRulesValidateCelParamKind {
  /**
   * APIVersion is the API group version the resources belong to.
   * In format of "group/version".
   * Required.
   *
   * @schema ClusterPolicySpecRulesValidateCelParamKind#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Kind is the API kind the resources belong to.
   * Required.
   *
   * @schema ClusterPolicySpecRulesValidateCelParamKind#kind
   */
  readonly kind?: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesValidateCelParamKind' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesValidateCelParamKind(obj: ClusterPolicySpecRulesValidateCelParamKind | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'kind': obj.kind,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ParamRef references a parameter resource.
 *
 * @schema ClusterPolicySpecRulesValidateCelParamRef
 */
export interface ClusterPolicySpecRulesValidateCelParamRef {
  /**
   * name is the name of the resource being referenced.
   *
   * One of `name` or `selector` must be set, but `name` and `selector` are
   * mutually exclusive properties. If one is set, the other must be unset.
   *
   * A single parameter used for all admission requests can be configured
   * by setting the `name` field, leaving `selector` blank, and setting namespace
   * if `paramKind` is namespace-scoped.
   *
   * @schema ClusterPolicySpecRulesValidateCelParamRef#name
   */
  readonly name?: string;

  /**
   * namespace is the namespace of the referenced resource. Allows limiting
   * the search for params to a specific namespace. Applies to both `name` and
   * `selector` fields.
   *
   * A per-namespace parameter may be used by specifying a namespace-scoped
   * `paramKind` in the policy and leaving this field empty.
   *
   * - If `paramKind` is cluster-scoped, this field MUST be unset. Setting this
   * field results in a configuration error.
   *
   * - If `paramKind` is namespace-scoped, the namespace of the object being
   * evaluated for admission will be used when this field is left unset. Take
   * care that if this is left empty the binding must not match any cluster-scoped
   * resources, which will result in an error.
   *
   * @schema ClusterPolicySpecRulesValidateCelParamRef#namespace
   */
  readonly namespace?: string;

  /**
   * `parameterNotFoundAction` controls the behavior of the binding when the resource
   * exists, and name or selector is valid, but there are no parameters
   * matched by the binding. If the value is set to `Allow`, then no
   * matched parameters will be treated as successful validation by the binding.
   * If set to `Deny`, then no matched parameters will be subject to the
   * `failurePolicy` of the policy.
   *
   * Allowed values are `Allow` or `Deny`
   *
   * Required
   *
   * @schema ClusterPolicySpecRulesValidateCelParamRef#parameterNotFoundAction
   */
  readonly parameterNotFoundAction?: string;

  /**
   * selector can be used to match multiple param objects based on their labels.
   * Supply selector: {} to match all resources of the ParamKind.
   *
   * If multiple params are found, they are all evaluated with the policy expressions
   * and the results are ANDed together.
   *
   * One of `name` or `selector` must be set, but `name` and `selector` are
   * mutually exclusive properties. If one is set, the other must be unset.
   *
   * @schema ClusterPolicySpecRulesValidateCelParamRef#selector
   */
  readonly selector?: ClusterPolicySpecRulesValidateCelParamRefSelector;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesValidateCelParamRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesValidateCelParamRef(obj: ClusterPolicySpecRulesValidateCelParamRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
    'parameterNotFoundAction': obj.parameterNotFoundAction,
    'selector': toJson_ClusterPolicySpecRulesValidateCelParamRefSelector(obj.selector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Variable is the definition of a variable that is used for composition. A variable is defined as a named expression.
 *
 * @schema ClusterPolicySpecRulesValidateCelVariables
 */
export interface ClusterPolicySpecRulesValidateCelVariables {
  /**
   * Expression is the expression that will be evaluated as the value of the variable.
   * The CEL expression has access to the same identifiers as the CEL expressions in Validation.
   *
   * @schema ClusterPolicySpecRulesValidateCelVariables#expression
   */
  readonly expression: string;

  /**
   * Name is the name of the variable. The name must be a valid CEL identifier and unique among all variables.
   * The variable can be accessed in other expressions through `variables`
   * For example, if name is "foo", the variable will be available as `variables.foo`
   *
   * @schema ClusterPolicySpecRulesValidateCelVariables#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesValidateCelVariables' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesValidateCelVariables(obj: ClusterPolicySpecRulesValidateCelVariables | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'expression': obj.expression,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ValidationFailureAction defines the policy validation failure action
 *
 * @schema ClusterPolicySpecRulesValidateFailureActionOverridesAction
 */
export enum ClusterPolicySpecRulesValidateFailureActionOverridesAction {
  /** audit */
  AUDIT = "audit",
  /** enforce */
  ENFORCE = "enforce",
}

/**
 * A label selector is a label query over a set of resources. The result of matchLabels and
 * matchExpressions are ANDed. An empty label selector matches all objects. A null
 * label selector matches no objects.
 *
 * @schema ClusterPolicySpecRulesValidateFailureActionOverridesNamespaceSelector
 */
export interface ClusterPolicySpecRulesValidateFailureActionOverridesNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterPolicySpecRulesValidateFailureActionOverridesNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterPolicySpecRulesValidateFailureActionOverridesNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterPolicySpecRulesValidateFailureActionOverridesNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesValidateFailureActionOverridesNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesValidateFailureActionOverridesNamespaceSelector(obj: ClusterPolicySpecRulesValidateFailureActionOverridesNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterPolicySpecRulesValidateFailureActionOverridesNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ContextEntry adds variables and data sources to a rule Context. Either a
 * ConfigMap reference or a APILookup must be provided.
 *
 * @schema ClusterPolicySpecRulesValidateForeachContext
 */
export interface ClusterPolicySpecRulesValidateForeachContext {
  /**
   * APICall is an HTTP request to the Kubernetes API server, or other JSON web service.
   * The data returned is stored in the context with the name for the context entry.
   *
   * @schema ClusterPolicySpecRulesValidateForeachContext#apiCall
   */
  readonly apiCall?: ClusterPolicySpecRulesValidateForeachContextApiCall;

  /**
   * ConfigMap is the ConfigMap reference.
   *
   * @schema ClusterPolicySpecRulesValidateForeachContext#configMap
   */
  readonly configMap?: ClusterPolicySpecRulesValidateForeachContextConfigMap;

  /**
   * GlobalContextEntryReference is a reference to a cached global context entry.
   *
   * @schema ClusterPolicySpecRulesValidateForeachContext#globalReference
   */
  readonly globalReference?: ClusterPolicySpecRulesValidateForeachContextGlobalReference;

  /**
   * ImageRegistry defines requests to an OCI/Docker V2 registry to fetch image
   * details.
   *
   * @schema ClusterPolicySpecRulesValidateForeachContext#imageRegistry
   */
  readonly imageRegistry?: ClusterPolicySpecRulesValidateForeachContextImageRegistry;

  /**
   * Name is the variable name.
   *
   * @schema ClusterPolicySpecRulesValidateForeachContext#name
   */
  readonly name: string;

  /**
   * Variable defines an arbitrary JMESPath context variable that can be defined inline.
   *
   * @schema ClusterPolicySpecRulesValidateForeachContext#variable
   */
  readonly variable?: ClusterPolicySpecRulesValidateForeachContextVariable;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesValidateForeachContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesValidateForeachContext(obj: ClusterPolicySpecRulesValidateForeachContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiCall': toJson_ClusterPolicySpecRulesValidateForeachContextApiCall(obj.apiCall),
    'configMap': toJson_ClusterPolicySpecRulesValidateForeachContextConfigMap(obj.configMap),
    'globalReference': toJson_ClusterPolicySpecRulesValidateForeachContextGlobalReference(obj.globalReference),
    'imageRegistry': toJson_ClusterPolicySpecRulesValidateForeachContextImageRegistry(obj.imageRegistry),
    'name': obj.name,
    'variable': toJson_ClusterPolicySpecRulesValidateForeachContextVariable(obj.variable),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Deny defines conditions used to pass or fail a validation rule.
 *
 * @schema ClusterPolicySpecRulesValidateForeachDeny
 */
export interface ClusterPolicySpecRulesValidateForeachDeny {
  /**
   * Multiple conditions can be declared under an `any` or `all` statement. A direct list
   * of conditions (without `any` or `all` statements) is also supported for backwards compatibility
   * but will be deprecated in the next major release.
   * See: https://kyverno.io/docs/writing-policies/validate/#deny-rules
   *
   * @schema ClusterPolicySpecRulesValidateForeachDeny#conditions
   */
  readonly conditions?: any;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesValidateForeachDeny' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesValidateForeachDeny(obj: ClusterPolicySpecRulesValidateForeachDeny | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conditions': obj.conditions,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AnyAllConditions are used to determine if a policy rule should be applied by evaluating a
 * set of conditions. The declaration can contain nested `any` or `all` statements.
 * See: https://kyverno.io/docs/writing-policies/preconditions/
 *
 * @schema ClusterPolicySpecRulesValidateForeachPreconditions
 */
export interface ClusterPolicySpecRulesValidateForeachPreconditions {
  /**
   * AllConditions enable variable-based conditional rule execution. This is useful for
   * finer control of when an rule is applied. A condition can reference object data
   * using JMESPath notation.
   * Here, all of the conditions need to pass
   *
   * @schema ClusterPolicySpecRulesValidateForeachPreconditions#all
   */
  readonly all?: ClusterPolicySpecRulesValidateForeachPreconditionsAll[];

  /**
   * AnyConditions enable variable-based conditional rule execution. This is useful for
   * finer control of when an rule is applied. A condition can reference object data
   * using JMESPath notation.
   * Here, at least one of the conditions need to pass
   *
   * @schema ClusterPolicySpecRulesValidateForeachPreconditions#any
   */
  readonly any?: ClusterPolicySpecRulesValidateForeachPreconditionsAny[];

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesValidateForeachPreconditions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesValidateForeachPreconditions(obj: ClusterPolicySpecRulesValidateForeachPreconditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'all': obj.all?.map(y => toJson_ClusterPolicySpecRulesValidateForeachPreconditionsAll(y)),
    'any': obj.any?.map(y => toJson_ClusterPolicySpecRulesValidateForeachPreconditionsAny(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterPolicySpecRulesValidateManifestsAttestors
 */
export interface ClusterPolicySpecRulesValidateManifestsAttestors {
  /**
   * Count specifies the required number of entries that must match. If the count is null, all entries must match
   * (a logical AND). If the count is 1, at least one entry must match (a logical OR). If the count contains a
   * value N, then N must be less than or equal to the size of entries, and at least N entries must match.
   *
   * @schema ClusterPolicySpecRulesValidateManifestsAttestors#count
   */
  readonly count?: number;

  /**
   * Entries contains the available attestors. An attestor can be a static key,
   * attributes for keyless verification, or a nested attestor declaration.
   *
   * @schema ClusterPolicySpecRulesValidateManifestsAttestors#entries
   */
  readonly entries?: ClusterPolicySpecRulesValidateManifestsAttestorsEntries[];

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesValidateManifestsAttestors' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesValidateManifestsAttestors(obj: ClusterPolicySpecRulesValidateManifestsAttestors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'count': obj.count,
    'entries': obj.entries?.map(y => toJson_ClusterPolicySpecRulesValidateManifestsAttestorsEntries(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DryRun configuration
 *
 * @schema ClusterPolicySpecRulesValidateManifestsDryRun
 */
export interface ClusterPolicySpecRulesValidateManifestsDryRun {
  /**
   * @schema ClusterPolicySpecRulesValidateManifestsDryRun#enable
   */
  readonly enable?: boolean;

  /**
   * @schema ClusterPolicySpecRulesValidateManifestsDryRun#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesValidateManifestsDryRun' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesValidateManifestsDryRun(obj: ClusterPolicySpecRulesValidateManifestsDryRun | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enable': obj.enable,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterPolicySpecRulesValidateManifestsIgnoreFields
 */
export interface ClusterPolicySpecRulesValidateManifestsIgnoreFields {
  /**
   * @schema ClusterPolicySpecRulesValidateManifestsIgnoreFields#fields
   */
  readonly fields?: string[];

  /**
   * @schema ClusterPolicySpecRulesValidateManifestsIgnoreFields#objects
   */
  readonly objects?: ClusterPolicySpecRulesValidateManifestsIgnoreFieldsObjects[];

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesValidateManifestsIgnoreFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesValidateManifestsIgnoreFields(obj: ClusterPolicySpecRulesValidateManifestsIgnoreFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fields': obj.fields?.map(y => y),
    'objects': obj.objects?.map(y => toJson_ClusterPolicySpecRulesValidateManifestsIgnoreFieldsObjects(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PodSecurityStandard specifies the Pod Security Standard controls to be excluded.
 *
 * @schema ClusterPolicySpecRulesValidatePodSecurityExclude
 */
export interface ClusterPolicySpecRulesValidatePodSecurityExclude {
  /**
   * ControlName specifies the name of the Pod Security Standard control.
   * See: https://kubernetes.io/docs/concepts/security/pod-security-standards/
   *
   * @schema ClusterPolicySpecRulesValidatePodSecurityExclude#controlName
   */
  readonly controlName: ClusterPolicySpecRulesValidatePodSecurityExcludeControlName;

  /**
   * Images selects matching containers and applies the container level PSS.
   * Each image is the image name consisting of the registry address, repository, image, and tag.
   * Empty list matches no containers, PSS checks are applied at the pod level only.
   * Wildcards ('*' and '?') are allowed. See: https://kubernetes.io/docs/concepts/containers/images.
   *
   * @schema ClusterPolicySpecRulesValidatePodSecurityExclude#images
   */
  readonly images?: string[];

  /**
   * RestrictedField selects the field for the given Pod Security Standard control.
   * When not set, all restricted fields for the control are selected.
   *
   * @schema ClusterPolicySpecRulesValidatePodSecurityExclude#restrictedField
   */
  readonly restrictedField?: string;

  /**
   * Values defines the allowed values that can be excluded.
   *
   * @schema ClusterPolicySpecRulesValidatePodSecurityExclude#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesValidatePodSecurityExclude' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesValidatePodSecurityExclude(obj: ClusterPolicySpecRulesValidatePodSecurityExclude | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'controlName': obj.controlName,
    'images': obj.images?.map(y => y),
    'restrictedField': obj.restrictedField,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Level defines the Pod Security Standard level to be applied to workloads.
 * Allowed values are privileged, baseline, and restricted.
 *
 * @schema ClusterPolicySpecRulesValidatePodSecurityLevel
 */
export enum ClusterPolicySpecRulesValidatePodSecurityLevel {
  /** privileged */
  PRIVILEGED = "privileged",
  /** baseline */
  BASELINE = "baseline",
  /** restricted */
  RESTRICTED = "restricted",
}

/**
 * Version defines the Pod Security Standard versions that Kubernetes supports.
 * Allowed values are v1.19, v1.20, v1.21, v1.22, v1.23, v1.24, v1.25, v1.26, v1.27, v1.28, v1.29, latest. Defaults to latest.
 *
 * @default latest.
 * @schema ClusterPolicySpecRulesValidatePodSecurityVersion
 */
export enum ClusterPolicySpecRulesValidatePodSecurityVersion {
  /** v1.19 */
  V1_19 = "v1.19",
  /** v1.20 */
  V1_20 = "v1.20",
  /** v1.21 */
  V1_21 = "v1.21",
  /** v1.22 */
  V1_22 = "v1.22",
  /** v1.23 */
  V1_23 = "v1.23",
  /** v1.24 */
  V1_24 = "v1.24",
  /** v1.25 */
  V1_25 = "v1.25",
  /** v1.26 */
  V1_26 = "v1.26",
  /** v1.27 */
  V1_27 = "v1.27",
  /** v1.28 */
  V1_28 = "v1.28",
  /** v1.29 */
  V1_29 = "v1.29",
  /** latest */
  LATEST = "latest",
}

/**
 * @schema ClusterPolicySpecRulesVerifyImagesAttestationsAttestors
 */
export interface ClusterPolicySpecRulesVerifyImagesAttestationsAttestors {
  /**
   * Count specifies the required number of entries that must match. If the count is null, all entries must match
   * (a logical AND). If the count is 1, at least one entry must match (a logical OR). If the count contains a
   * value N, then N must be less than or equal to the size of entries, and at least N entries must match.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestationsAttestors#count
   */
  readonly count?: number;

  /**
   * Entries contains the available attestors. An attestor can be a static key,
   * attributes for keyless verification, or a nested attestor declaration.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestationsAttestors#entries
   */
  readonly entries?: ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntries[];

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesVerifyImagesAttestationsAttestors' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesVerifyImagesAttestationsAttestors(obj: ClusterPolicySpecRulesVerifyImagesAttestationsAttestors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'count': obj.count,
    'entries': obj.entries?.map(y => toJson_ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntries(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AnyAllConditions consists of conditions wrapped denoting a logical criteria to be fulfilled.
 * AnyConditions get fulfilled when at least one of its sub-conditions passes.
 * AllConditions get fulfilled only when all of its sub-conditions pass.
 *
 * @schema ClusterPolicySpecRulesVerifyImagesAttestationsConditions
 */
export interface ClusterPolicySpecRulesVerifyImagesAttestationsConditions {
  /**
   * AllConditions enable variable-based conditional rule execution. This is useful for
   * finer control of when an rule is applied. A condition can reference object data
   * using JMESPath notation.
   * Here, all of the conditions need to pass
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestationsConditions#all
   */
  readonly all?: ClusterPolicySpecRulesVerifyImagesAttestationsConditionsAll[];

  /**
   * AnyConditions enable variable-based conditional rule execution. This is useful for
   * finer control of when an rule is applied. A condition can reference object data
   * using JMESPath notation.
   * Here, at least one of the conditions need to pass
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestationsConditions#any
   */
  readonly any?: ClusterPolicySpecRulesVerifyImagesAttestationsConditionsAny[];

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesVerifyImagesAttestationsConditions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesVerifyImagesAttestationsConditions(obj: ClusterPolicySpecRulesVerifyImagesAttestationsConditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'all': obj.all?.map(y => toJson_ClusterPolicySpecRulesVerifyImagesAttestationsConditionsAll(y)),
    'any': obj.any?.map(y => toJson_ClusterPolicySpecRulesVerifyImagesAttestationsConditionsAny(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntries
 */
export interface ClusterPolicySpecRulesVerifyImagesAttestorsEntries {
  /**
   * Annotations are used for image verification.
   * Every specified key-value pair must exist and match in the verified payload.
   * The payload may contain other key-value pairs.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntries#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Attestor is a nested set of Attestor used to specify a more complex set of match authorities.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntries#attestor
   */
  readonly attestor?: any;

  /**
   * Certificates specifies one or more certificates.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntries#certificates
   */
  readonly certificates?: ClusterPolicySpecRulesVerifyImagesAttestorsEntriesCertificates;

  /**
   * Keyless is a set of attribute used to verify a Sigstore keyless attestor.
   * See https://github.com/sigstore/cosign/blob/main/KEYLESS.md.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntries#keyless
   */
  readonly keyless?: ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeyless;

  /**
   * Keys specifies one or more public keys.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntries#keys
   */
  readonly keys?: ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeys;

  /**
   * Repository is an optional alternate OCI repository to use for signatures and attestations that match this rule.
   * If specified Repository will override other OCI image repository locations for this Attestor.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntries#repository
   */
  readonly repository?: string;

  /**
   * Specify signature algorithm for public keys. Supported values are sha224, sha256, sha384 and sha512.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntries#signatureAlgorithm
   */
  readonly signatureAlgorithm?: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesVerifyImagesAttestorsEntries' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesVerifyImagesAttestorsEntries(obj: ClusterPolicySpecRulesVerifyImagesAttestorsEntries | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'attestor': obj.attestor,
    'certificates': toJson_ClusterPolicySpecRulesVerifyImagesAttestorsEntriesCertificates(obj.certificates),
    'keyless': toJson_ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeyless(obj.keyless),
    'keys': toJson_ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeys(obj.keys),
    'repository': obj.repository,
    'signatureAlgorithm': obj.signatureAlgorithm,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ImageRegistryCredentialsProvidersType provides the list of credential providers required.
 *
 * @schema ClusterPolicySpecRulesVerifyImagesImageRegistryCredentialsProviders
 */
export enum ClusterPolicySpecRulesVerifyImagesImageRegistryCredentialsProviders {
  /** default */
  DEFAULT = "default",
  /** amazon */
  AMAZON = "amazon",
  /** azure */
  AZURE = "azure",
  /** google */
  GOOGLE = "google",
  /** github */
  GITHUB = "github",
}

/**
 * Deny defines conditions used to pass or fail a validation rule.
 *
 * @schema ClusterPolicySpecRulesVerifyImagesValidateDeny
 */
export interface ClusterPolicySpecRulesVerifyImagesValidateDeny {
  /**
   * Multiple conditions can be declared under an `any` or `all` statement. A direct list
   * of conditions (without `any` or `all` statements) is also supported for backwards compatibility
   * but will be deprecated in the next major release.
   * See: https://kyverno.io/docs/writing-policies/validate/#deny-rules
   *
   * @schema ClusterPolicySpecRulesVerifyImagesValidateDeny#conditions
   */
  readonly conditions?: any;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesVerifyImagesValidateDeny' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesVerifyImagesValidateDeny(obj: ClusterPolicySpecRulesVerifyImagesValidateDeny | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conditions': obj.conditions,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterPolicySpecRulesContextApiCallServiceHeaders
 */
export interface ClusterPolicySpecRulesContextApiCallServiceHeaders {
  /**
   * Key is the header key
   *
   * @schema ClusterPolicySpecRulesContextApiCallServiceHeaders#key
   */
  readonly key: string;

  /**
   * Value is the header value
   *
   * @schema ClusterPolicySpecRulesContextApiCallServiceHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesContextApiCallServiceHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesContextApiCallServiceHeaders(obj: ClusterPolicySpecRulesContextApiCallServiceHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ImageRegistryCredentialsProvidersType provides the list of credential providers required.
 *
 * @schema ClusterPolicySpecRulesContextImageRegistryImageRegistryCredentialsProviders
 */
export enum ClusterPolicySpecRulesContextImageRegistryImageRegistryCredentialsProviders {
  /** default */
  DEFAULT = "default",
  /** amazon */
  AMAZON = "amazon",
  /** azure */
  AZURE = "azure",
  /** google */
  GOOGLE = "google",
  /** github */
  GITHUB = "github",
}

/**
 * NamespaceSelector is a label selector for the resource namespace. Label keys and values
 * in `matchLabels` support the wildcard characters `*` (matches zero or many characters)
 * and `?` (matches one character).Wildcards allows writing label selectors like
 * ["storage.k8s.io/*": "*"]. Note that using ["*" : "*"] matches any key and value but
 * does not match an empty label set.
 *
 * @schema ClusterPolicySpecRulesExcludeAllResourcesNamespaceSelector
 */
export interface ClusterPolicySpecRulesExcludeAllResourcesNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterPolicySpecRulesExcludeAllResourcesNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterPolicySpecRulesExcludeAllResourcesNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterPolicySpecRulesExcludeAllResourcesNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesExcludeAllResourcesNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesExcludeAllResourcesNamespaceSelector(obj: ClusterPolicySpecRulesExcludeAllResourcesNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterPolicySpecRulesExcludeAllResourcesNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AdmissionOperation can have one of the values CREATE, UPDATE, CONNECT, DELETE, which are used to match a specific action.
 *
 * @schema ClusterPolicySpecRulesExcludeAllResourcesOperations
 */
export enum ClusterPolicySpecRulesExcludeAllResourcesOperations {
  /** CREATE */
  CREATE = "CREATE",
  /** CONNECT */
  CONNECT = "CONNECT",
  /** UPDATE */
  UPDATE = "UPDATE",
  /** DELETE */
  DELETE = "DELETE",
}

/**
 * Selector is a label selector. Label keys and values in `matchLabels` support the wildcard
 * characters `*` (matches zero or many characters) and `?` (matches one character).
 * Wildcards allows writing label selectors like ["storage.k8s.io/*": "*"]. Note that
 * using ["*" : "*"] matches any key and value but does not match an empty label set.
 *
 * @schema ClusterPolicySpecRulesExcludeAllResourcesSelector
 */
export interface ClusterPolicySpecRulesExcludeAllResourcesSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterPolicySpecRulesExcludeAllResourcesSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterPolicySpecRulesExcludeAllResourcesSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterPolicySpecRulesExcludeAllResourcesSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesExcludeAllResourcesSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesExcludeAllResourcesSelector(obj: ClusterPolicySpecRulesExcludeAllResourcesSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterPolicySpecRulesExcludeAllResourcesSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NamespaceSelector is a label selector for the resource namespace. Label keys and values
 * in `matchLabels` support the wildcard characters `*` (matches zero or many characters)
 * and `?` (matches one character).Wildcards allows writing label selectors like
 * ["storage.k8s.io/*": "*"]. Note that using ["*" : "*"] matches any key and value but
 * does not match an empty label set.
 *
 * @schema ClusterPolicySpecRulesExcludeAnyResourcesNamespaceSelector
 */
export interface ClusterPolicySpecRulesExcludeAnyResourcesNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterPolicySpecRulesExcludeAnyResourcesNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterPolicySpecRulesExcludeAnyResourcesNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterPolicySpecRulesExcludeAnyResourcesNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesExcludeAnyResourcesNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesExcludeAnyResourcesNamespaceSelector(obj: ClusterPolicySpecRulesExcludeAnyResourcesNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterPolicySpecRulesExcludeAnyResourcesNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AdmissionOperation can have one of the values CREATE, UPDATE, CONNECT, DELETE, which are used to match a specific action.
 *
 * @schema ClusterPolicySpecRulesExcludeAnyResourcesOperations
 */
export enum ClusterPolicySpecRulesExcludeAnyResourcesOperations {
  /** CREATE */
  CREATE = "CREATE",
  /** CONNECT */
  CONNECT = "CONNECT",
  /** UPDATE */
  UPDATE = "UPDATE",
  /** DELETE */
  DELETE = "DELETE",
}

/**
 * Selector is a label selector. Label keys and values in `matchLabels` support the wildcard
 * characters `*` (matches zero or many characters) and `?` (matches one character).
 * Wildcards allows writing label selectors like ["storage.k8s.io/*": "*"]. Note that
 * using ["*" : "*"] matches any key and value but does not match an empty label set.
 *
 * @schema ClusterPolicySpecRulesExcludeAnyResourcesSelector
 */
export interface ClusterPolicySpecRulesExcludeAnyResourcesSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterPolicySpecRulesExcludeAnyResourcesSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterPolicySpecRulesExcludeAnyResourcesSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterPolicySpecRulesExcludeAnyResourcesSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesExcludeAnyResourcesSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesExcludeAnyResourcesSelector(obj: ClusterPolicySpecRulesExcludeAnyResourcesSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterPolicySpecRulesExcludeAnyResourcesSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterPolicySpecRulesExcludeResourcesNamespaceSelectorMatchExpressions
 */
export interface ClusterPolicySpecRulesExcludeResourcesNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterPolicySpecRulesExcludeResourcesNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterPolicySpecRulesExcludeResourcesNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterPolicySpecRulesExcludeResourcesNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesExcludeResourcesNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesExcludeResourcesNamespaceSelectorMatchExpressions(obj: ClusterPolicySpecRulesExcludeResourcesNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterPolicySpecRulesExcludeResourcesSelectorMatchExpressions
 */
export interface ClusterPolicySpecRulesExcludeResourcesSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterPolicySpecRulesExcludeResourcesSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterPolicySpecRulesExcludeResourcesSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterPolicySpecRulesExcludeResourcesSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesExcludeResourcesSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesExcludeResourcesSelectorMatchExpressions(obj: ClusterPolicySpecRulesExcludeResourcesSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterPolicySpecRulesGenerateCloneListSelectorMatchExpressions
 */
export interface ClusterPolicySpecRulesGenerateCloneListSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterPolicySpecRulesGenerateCloneListSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterPolicySpecRulesGenerateCloneListSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterPolicySpecRulesGenerateCloneListSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesGenerateCloneListSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesGenerateCloneListSelectorMatchExpressions(obj: ClusterPolicySpecRulesGenerateCloneListSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector is a label selector. Label keys and values in `matchLabels`.
 * wildcard characters are not supported.
 *
 * @schema ClusterPolicySpecRulesGenerateForeachCloneListSelector
 */
export interface ClusterPolicySpecRulesGenerateForeachCloneListSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterPolicySpecRulesGenerateForeachCloneListSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterPolicySpecRulesGenerateForeachCloneListSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterPolicySpecRulesGenerateForeachCloneListSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesGenerateForeachCloneListSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesGenerateForeachCloneListSelector(obj: ClusterPolicySpecRulesGenerateForeachCloneListSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterPolicySpecRulesGenerateForeachCloneListSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * APICall is an HTTP request to the Kubernetes API server, or other JSON web service.
 * The data returned is stored in the context with the name for the context entry.
 *
 * @schema ClusterPolicySpecRulesGenerateForeachContextApiCall
 */
export interface ClusterPolicySpecRulesGenerateForeachContextApiCall {
  /**
   * The data object specifies the POST data sent to the server.
   * Only applicable when the method field is set to POST.
   *
   * @schema ClusterPolicySpecRulesGenerateForeachContextApiCall#data
   */
  readonly data?: ClusterPolicySpecRulesGenerateForeachContextApiCallData[];

  /**
   * Default is an optional arbitrary JSON object that the context
   * value is set to, if the apiCall returns error.
   *
   * @default an optional arbitrary JSON object that the context
   * @schema ClusterPolicySpecRulesGenerateForeachContextApiCall#default
   */
  readonly default?: any;

  /**
   * JMESPath is an optional JSON Match Expression that can be used to
   * transform the JSON response returned from the server. For example
   * a JMESPath of "items | length(@)" applied to the API server response
   * for the URLPath "/apis/apps/v1/deployments" will return the total count
   * of deployments across all namespaces.
   *
   * @schema ClusterPolicySpecRulesGenerateForeachContextApiCall#jmesPath
   */
  readonly jmesPath?: string;

  /**
   * Method is the HTTP request type (GET or POST). Defaults to GET.
   *
   * @default GET.
   * @schema ClusterPolicySpecRulesGenerateForeachContextApiCall#method
   */
  readonly method?: ClusterPolicySpecRulesGenerateForeachContextApiCallMethod;

  /**
   * Service is an API call to a JSON web service.
   * This is used for non-Kubernetes API server calls.
   * It's mutually exclusive with the URLPath field.
   *
   * @schema ClusterPolicySpecRulesGenerateForeachContextApiCall#service
   */
  readonly service?: ClusterPolicySpecRulesGenerateForeachContextApiCallService;

  /**
   * URLPath is the URL path to be used in the HTTP GET or POST request to the
   * Kubernetes API server (e.g. "/api/v1/namespaces" or  "/apis/apps/v1/deployments").
   * The format required is the same format used by the `kubectl get --raw` command.
   * See https://kyverno.io/docs/writing-policies/external-data-sources/#variables-from-kubernetes-api-server-calls
   * for details.
   * It's mutually exclusive with the Service field.
   *
   * @schema ClusterPolicySpecRulesGenerateForeachContextApiCall#urlPath
   */
  readonly urlPath?: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesGenerateForeachContextApiCall' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesGenerateForeachContextApiCall(obj: ClusterPolicySpecRulesGenerateForeachContextApiCall | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'data': obj.data?.map(y => toJson_ClusterPolicySpecRulesGenerateForeachContextApiCallData(y)),
    'default': obj.default,
    'jmesPath': obj.jmesPath,
    'method': obj.method,
    'service': toJson_ClusterPolicySpecRulesGenerateForeachContextApiCallService(obj.service),
    'urlPath': obj.urlPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap is the ConfigMap reference.
 *
 * @schema ClusterPolicySpecRulesGenerateForeachContextConfigMap
 */
export interface ClusterPolicySpecRulesGenerateForeachContextConfigMap {
  /**
   * Name is the ConfigMap name.
   *
   * @schema ClusterPolicySpecRulesGenerateForeachContextConfigMap#name
   */
  readonly name: string;

  /**
   * Namespace is the ConfigMap namespace.
   *
   * @schema ClusterPolicySpecRulesGenerateForeachContextConfigMap#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesGenerateForeachContextConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesGenerateForeachContextConfigMap(obj: ClusterPolicySpecRulesGenerateForeachContextConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GlobalContextEntryReference is a reference to a cached global context entry.
 *
 * @schema ClusterPolicySpecRulesGenerateForeachContextGlobalReference
 */
export interface ClusterPolicySpecRulesGenerateForeachContextGlobalReference {
  /**
   * JMESPath is an optional JSON Match Expression that can be used to
   * transform the JSON response returned from the server. For example
   * a JMESPath of "items | length(@)" applied to the API server response
   * for the URLPath "/apis/apps/v1/deployments" will return the total count
   * of deployments across all namespaces.
   *
   * @schema ClusterPolicySpecRulesGenerateForeachContextGlobalReference#jmesPath
   */
  readonly jmesPath?: string;

  /**
   * Name of the global context entry
   *
   * @schema ClusterPolicySpecRulesGenerateForeachContextGlobalReference#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesGenerateForeachContextGlobalReference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesGenerateForeachContextGlobalReference(obj: ClusterPolicySpecRulesGenerateForeachContextGlobalReference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'jmesPath': obj.jmesPath,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ImageRegistry defines requests to an OCI/Docker V2 registry to fetch image
 * details.
 *
 * @schema ClusterPolicySpecRulesGenerateForeachContextImageRegistry
 */
export interface ClusterPolicySpecRulesGenerateForeachContextImageRegistry {
  /**
   * ImageRegistryCredentials provides credentials that will be used for authentication with registry
   *
   * @schema ClusterPolicySpecRulesGenerateForeachContextImageRegistry#imageRegistryCredentials
   */
  readonly imageRegistryCredentials?: ClusterPolicySpecRulesGenerateForeachContextImageRegistryImageRegistryCredentials;

  /**
   * JMESPath is an optional JSON Match Expression that can be used to
   * transform the ImageData struct returned as a result of processing
   * the image reference.
   *
   * @schema ClusterPolicySpecRulesGenerateForeachContextImageRegistry#jmesPath
   */
  readonly jmesPath?: string;

  /**
   * Reference is image reference to a container image in the registry.
   * Example: ghcr.io/kyverno/kyverno:latest
   *
   * @schema ClusterPolicySpecRulesGenerateForeachContextImageRegistry#reference
   */
  readonly reference: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesGenerateForeachContextImageRegistry' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesGenerateForeachContextImageRegistry(obj: ClusterPolicySpecRulesGenerateForeachContextImageRegistry | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'imageRegistryCredentials': toJson_ClusterPolicySpecRulesGenerateForeachContextImageRegistryImageRegistryCredentials(obj.imageRegistryCredentials),
    'jmesPath': obj.jmesPath,
    'reference': obj.reference,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Variable defines an arbitrary JMESPath context variable that can be defined inline.
 *
 * @schema ClusterPolicySpecRulesGenerateForeachContextVariable
 */
export interface ClusterPolicySpecRulesGenerateForeachContextVariable {
  /**
   * Default is an optional arbitrary JSON object that the variable may take if the JMESPath
   * expression evaluates to nil
   *
   * @default an optional arbitrary JSON object that the variable may take if the JMESPath
   * @schema ClusterPolicySpecRulesGenerateForeachContextVariable#default
   */
  readonly default?: any;

  /**
   * JMESPath is an optional JMESPath Expression that can be used to
   * transform the variable.
   *
   * @schema ClusterPolicySpecRulesGenerateForeachContextVariable#jmesPath
   */
  readonly jmesPath?: string;

  /**
   * Value is any arbitrary JSON object representable in YAML or JSON form.
   *
   * @schema ClusterPolicySpecRulesGenerateForeachContextVariable#value
   */
  readonly value?: any;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesGenerateForeachContextVariable' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesGenerateForeachContextVariable(obj: ClusterPolicySpecRulesGenerateForeachContextVariable | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'default': obj.default,
    'jmesPath': obj.jmesPath,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Condition defines variable-based conditional criteria for rule execution.
 *
 * @schema ClusterPolicySpecRulesGenerateForeachPreconditionsAll
 */
export interface ClusterPolicySpecRulesGenerateForeachPreconditionsAll {
  /**
   * Key is the context entry (using JMESPath) for conditional rule evaluation.
   *
   * @schema ClusterPolicySpecRulesGenerateForeachPreconditionsAll#key
   */
  readonly key?: any;

  /**
   * Message is an optional display message
   *
   * @schema ClusterPolicySpecRulesGenerateForeachPreconditionsAll#message
   */
  readonly message?: string;

  /**
   * Operator is the conditional operation to perform. Valid operators are:
   * Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
   * GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
   * DurationLessThanOrEquals, DurationLessThan
   *
   * @schema ClusterPolicySpecRulesGenerateForeachPreconditionsAll#operator
   */
  readonly operator?: ClusterPolicySpecRulesGenerateForeachPreconditionsAllOperator;

  /**
   * Value is the conditional value, or set of values. The values can be fixed set
   * or can be variables declared using JMESPath.
   *
   * @schema ClusterPolicySpecRulesGenerateForeachPreconditionsAll#value
   */
  readonly value?: any;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesGenerateForeachPreconditionsAll' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesGenerateForeachPreconditionsAll(obj: ClusterPolicySpecRulesGenerateForeachPreconditionsAll | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'message': obj.message,
    'operator': obj.operator,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Condition defines variable-based conditional criteria for rule execution.
 *
 * @schema ClusterPolicySpecRulesGenerateForeachPreconditionsAny
 */
export interface ClusterPolicySpecRulesGenerateForeachPreconditionsAny {
  /**
   * Key is the context entry (using JMESPath) for conditional rule evaluation.
   *
   * @schema ClusterPolicySpecRulesGenerateForeachPreconditionsAny#key
   */
  readonly key?: any;

  /**
   * Message is an optional display message
   *
   * @schema ClusterPolicySpecRulesGenerateForeachPreconditionsAny#message
   */
  readonly message?: string;

  /**
   * Operator is the conditional operation to perform. Valid operators are:
   * Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
   * GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
   * DurationLessThanOrEquals, DurationLessThan
   *
   * @schema ClusterPolicySpecRulesGenerateForeachPreconditionsAny#operator
   */
  readonly operator?: ClusterPolicySpecRulesGenerateForeachPreconditionsAnyOperator;

  /**
   * Value is the conditional value, or set of values. The values can be fixed set
   * or can be variables declared using JMESPath.
   *
   * @schema ClusterPolicySpecRulesGenerateForeachPreconditionsAny#value
   */
  readonly value?: any;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesGenerateForeachPreconditionsAny' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesGenerateForeachPreconditionsAny(obj: ClusterPolicySpecRulesGenerateForeachPreconditionsAny | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'message': obj.message,
    'operator': obj.operator,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NamespaceSelector is a label selector for the resource namespace. Label keys and values
 * in `matchLabels` support the wildcard characters `*` (matches zero or many characters)
 * and `?` (matches one character).Wildcards allows writing label selectors like
 * ["storage.k8s.io/*": "*"]. Note that using ["*" : "*"] matches any key and value but
 * does not match an empty label set.
 *
 * @schema ClusterPolicySpecRulesMatchAllResourcesNamespaceSelector
 */
export interface ClusterPolicySpecRulesMatchAllResourcesNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterPolicySpecRulesMatchAllResourcesNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterPolicySpecRulesMatchAllResourcesNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterPolicySpecRulesMatchAllResourcesNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMatchAllResourcesNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMatchAllResourcesNamespaceSelector(obj: ClusterPolicySpecRulesMatchAllResourcesNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterPolicySpecRulesMatchAllResourcesNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AdmissionOperation can have one of the values CREATE, UPDATE, CONNECT, DELETE, which are used to match a specific action.
 *
 * @schema ClusterPolicySpecRulesMatchAllResourcesOperations
 */
export enum ClusterPolicySpecRulesMatchAllResourcesOperations {
  /** CREATE */
  CREATE = "CREATE",
  /** CONNECT */
  CONNECT = "CONNECT",
  /** UPDATE */
  UPDATE = "UPDATE",
  /** DELETE */
  DELETE = "DELETE",
}

/**
 * Selector is a label selector. Label keys and values in `matchLabels` support the wildcard
 * characters `*` (matches zero or many characters) and `?` (matches one character).
 * Wildcards allows writing label selectors like ["storage.k8s.io/*": "*"]. Note that
 * using ["*" : "*"] matches any key and value but does not match an empty label set.
 *
 * @schema ClusterPolicySpecRulesMatchAllResourcesSelector
 */
export interface ClusterPolicySpecRulesMatchAllResourcesSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterPolicySpecRulesMatchAllResourcesSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterPolicySpecRulesMatchAllResourcesSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterPolicySpecRulesMatchAllResourcesSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMatchAllResourcesSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMatchAllResourcesSelector(obj: ClusterPolicySpecRulesMatchAllResourcesSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterPolicySpecRulesMatchAllResourcesSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NamespaceSelector is a label selector for the resource namespace. Label keys and values
 * in `matchLabels` support the wildcard characters `*` (matches zero or many characters)
 * and `?` (matches one character).Wildcards allows writing label selectors like
 * ["storage.k8s.io/*": "*"]. Note that using ["*" : "*"] matches any key and value but
 * does not match an empty label set.
 *
 * @schema ClusterPolicySpecRulesMatchAnyResourcesNamespaceSelector
 */
export interface ClusterPolicySpecRulesMatchAnyResourcesNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterPolicySpecRulesMatchAnyResourcesNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterPolicySpecRulesMatchAnyResourcesNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterPolicySpecRulesMatchAnyResourcesNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMatchAnyResourcesNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMatchAnyResourcesNamespaceSelector(obj: ClusterPolicySpecRulesMatchAnyResourcesNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterPolicySpecRulesMatchAnyResourcesNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AdmissionOperation can have one of the values CREATE, UPDATE, CONNECT, DELETE, which are used to match a specific action.
 *
 * @schema ClusterPolicySpecRulesMatchAnyResourcesOperations
 */
export enum ClusterPolicySpecRulesMatchAnyResourcesOperations {
  /** CREATE */
  CREATE = "CREATE",
  /** CONNECT */
  CONNECT = "CONNECT",
  /** UPDATE */
  UPDATE = "UPDATE",
  /** DELETE */
  DELETE = "DELETE",
}

/**
 * Selector is a label selector. Label keys and values in `matchLabels` support the wildcard
 * characters `*` (matches zero or many characters) and `?` (matches one character).
 * Wildcards allows writing label selectors like ["storage.k8s.io/*": "*"]. Note that
 * using ["*" : "*"] matches any key and value but does not match an empty label set.
 *
 * @schema ClusterPolicySpecRulesMatchAnyResourcesSelector
 */
export interface ClusterPolicySpecRulesMatchAnyResourcesSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterPolicySpecRulesMatchAnyResourcesSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterPolicySpecRulesMatchAnyResourcesSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterPolicySpecRulesMatchAnyResourcesSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMatchAnyResourcesSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMatchAnyResourcesSelector(obj: ClusterPolicySpecRulesMatchAnyResourcesSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterPolicySpecRulesMatchAnyResourcesSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterPolicySpecRulesMatchResourcesNamespaceSelectorMatchExpressions
 */
export interface ClusterPolicySpecRulesMatchResourcesNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterPolicySpecRulesMatchResourcesNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterPolicySpecRulesMatchResourcesNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterPolicySpecRulesMatchResourcesNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMatchResourcesNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMatchResourcesNamespaceSelectorMatchExpressions(obj: ClusterPolicySpecRulesMatchResourcesNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterPolicySpecRulesMatchResourcesSelectorMatchExpressions
 */
export interface ClusterPolicySpecRulesMatchResourcesSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterPolicySpecRulesMatchResourcesSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterPolicySpecRulesMatchResourcesSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterPolicySpecRulesMatchResourcesSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMatchResourcesSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMatchResourcesSelectorMatchExpressions(obj: ClusterPolicySpecRulesMatchResourcesSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * APICall is an HTTP request to the Kubernetes API server, or other JSON web service.
 * The data returned is stored in the context with the name for the context entry.
 *
 * @schema ClusterPolicySpecRulesMutateForeachContextApiCall
 */
export interface ClusterPolicySpecRulesMutateForeachContextApiCall {
  /**
   * The data object specifies the POST data sent to the server.
   * Only applicable when the method field is set to POST.
   *
   * @schema ClusterPolicySpecRulesMutateForeachContextApiCall#data
   */
  readonly data?: ClusterPolicySpecRulesMutateForeachContextApiCallData[];

  /**
   * Default is an optional arbitrary JSON object that the context
   * value is set to, if the apiCall returns error.
   *
   * @default an optional arbitrary JSON object that the context
   * @schema ClusterPolicySpecRulesMutateForeachContextApiCall#default
   */
  readonly default?: any;

  /**
   * JMESPath is an optional JSON Match Expression that can be used to
   * transform the JSON response returned from the server. For example
   * a JMESPath of "items | length(@)" applied to the API server response
   * for the URLPath "/apis/apps/v1/deployments" will return the total count
   * of deployments across all namespaces.
   *
   * @schema ClusterPolicySpecRulesMutateForeachContextApiCall#jmesPath
   */
  readonly jmesPath?: string;

  /**
   * Method is the HTTP request type (GET or POST). Defaults to GET.
   *
   * @default GET.
   * @schema ClusterPolicySpecRulesMutateForeachContextApiCall#method
   */
  readonly method?: ClusterPolicySpecRulesMutateForeachContextApiCallMethod;

  /**
   * Service is an API call to a JSON web service.
   * This is used for non-Kubernetes API server calls.
   * It's mutually exclusive with the URLPath field.
   *
   * @schema ClusterPolicySpecRulesMutateForeachContextApiCall#service
   */
  readonly service?: ClusterPolicySpecRulesMutateForeachContextApiCallService;

  /**
   * URLPath is the URL path to be used in the HTTP GET or POST request to the
   * Kubernetes API server (e.g. "/api/v1/namespaces" or  "/apis/apps/v1/deployments").
   * The format required is the same format used by the `kubectl get --raw` command.
   * See https://kyverno.io/docs/writing-policies/external-data-sources/#variables-from-kubernetes-api-server-calls
   * for details.
   * It's mutually exclusive with the Service field.
   *
   * @schema ClusterPolicySpecRulesMutateForeachContextApiCall#urlPath
   */
  readonly urlPath?: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMutateForeachContextApiCall' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMutateForeachContextApiCall(obj: ClusterPolicySpecRulesMutateForeachContextApiCall | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'data': obj.data?.map(y => toJson_ClusterPolicySpecRulesMutateForeachContextApiCallData(y)),
    'default': obj.default,
    'jmesPath': obj.jmesPath,
    'method': obj.method,
    'service': toJson_ClusterPolicySpecRulesMutateForeachContextApiCallService(obj.service),
    'urlPath': obj.urlPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap is the ConfigMap reference.
 *
 * @schema ClusterPolicySpecRulesMutateForeachContextConfigMap
 */
export interface ClusterPolicySpecRulesMutateForeachContextConfigMap {
  /**
   * Name is the ConfigMap name.
   *
   * @schema ClusterPolicySpecRulesMutateForeachContextConfigMap#name
   */
  readonly name: string;

  /**
   * Namespace is the ConfigMap namespace.
   *
   * @schema ClusterPolicySpecRulesMutateForeachContextConfigMap#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMutateForeachContextConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMutateForeachContextConfigMap(obj: ClusterPolicySpecRulesMutateForeachContextConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GlobalContextEntryReference is a reference to a cached global context entry.
 *
 * @schema ClusterPolicySpecRulesMutateForeachContextGlobalReference
 */
export interface ClusterPolicySpecRulesMutateForeachContextGlobalReference {
  /**
   * JMESPath is an optional JSON Match Expression that can be used to
   * transform the JSON response returned from the server. For example
   * a JMESPath of "items | length(@)" applied to the API server response
   * for the URLPath "/apis/apps/v1/deployments" will return the total count
   * of deployments across all namespaces.
   *
   * @schema ClusterPolicySpecRulesMutateForeachContextGlobalReference#jmesPath
   */
  readonly jmesPath?: string;

  /**
   * Name of the global context entry
   *
   * @schema ClusterPolicySpecRulesMutateForeachContextGlobalReference#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMutateForeachContextGlobalReference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMutateForeachContextGlobalReference(obj: ClusterPolicySpecRulesMutateForeachContextGlobalReference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'jmesPath': obj.jmesPath,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ImageRegistry defines requests to an OCI/Docker V2 registry to fetch image
 * details.
 *
 * @schema ClusterPolicySpecRulesMutateForeachContextImageRegistry
 */
export interface ClusterPolicySpecRulesMutateForeachContextImageRegistry {
  /**
   * ImageRegistryCredentials provides credentials that will be used for authentication with registry
   *
   * @schema ClusterPolicySpecRulesMutateForeachContextImageRegistry#imageRegistryCredentials
   */
  readonly imageRegistryCredentials?: ClusterPolicySpecRulesMutateForeachContextImageRegistryImageRegistryCredentials;

  /**
   * JMESPath is an optional JSON Match Expression that can be used to
   * transform the ImageData struct returned as a result of processing
   * the image reference.
   *
   * @schema ClusterPolicySpecRulesMutateForeachContextImageRegistry#jmesPath
   */
  readonly jmesPath?: string;

  /**
   * Reference is image reference to a container image in the registry.
   * Example: ghcr.io/kyverno/kyverno:latest
   *
   * @schema ClusterPolicySpecRulesMutateForeachContextImageRegistry#reference
   */
  readonly reference: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMutateForeachContextImageRegistry' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMutateForeachContextImageRegistry(obj: ClusterPolicySpecRulesMutateForeachContextImageRegistry | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'imageRegistryCredentials': toJson_ClusterPolicySpecRulesMutateForeachContextImageRegistryImageRegistryCredentials(obj.imageRegistryCredentials),
    'jmesPath': obj.jmesPath,
    'reference': obj.reference,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Variable defines an arbitrary JMESPath context variable that can be defined inline.
 *
 * @schema ClusterPolicySpecRulesMutateForeachContextVariable
 */
export interface ClusterPolicySpecRulesMutateForeachContextVariable {
  /**
   * Default is an optional arbitrary JSON object that the variable may take if the JMESPath
   * expression evaluates to nil
   *
   * @default an optional arbitrary JSON object that the variable may take if the JMESPath
   * @schema ClusterPolicySpecRulesMutateForeachContextVariable#default
   */
  readonly default?: any;

  /**
   * JMESPath is an optional JMESPath Expression that can be used to
   * transform the variable.
   *
   * @schema ClusterPolicySpecRulesMutateForeachContextVariable#jmesPath
   */
  readonly jmesPath?: string;

  /**
   * Value is any arbitrary JSON object representable in YAML or JSON form.
   *
   * @schema ClusterPolicySpecRulesMutateForeachContextVariable#value
   */
  readonly value?: any;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMutateForeachContextVariable' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMutateForeachContextVariable(obj: ClusterPolicySpecRulesMutateForeachContextVariable | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'default': obj.default,
    'jmesPath': obj.jmesPath,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Condition defines variable-based conditional criteria for rule execution.
 *
 * @schema ClusterPolicySpecRulesMutateForeachPreconditionsAll
 */
export interface ClusterPolicySpecRulesMutateForeachPreconditionsAll {
  /**
   * Key is the context entry (using JMESPath) for conditional rule evaluation.
   *
   * @schema ClusterPolicySpecRulesMutateForeachPreconditionsAll#key
   */
  readonly key?: any;

  /**
   * Message is an optional display message
   *
   * @schema ClusterPolicySpecRulesMutateForeachPreconditionsAll#message
   */
  readonly message?: string;

  /**
   * Operator is the conditional operation to perform. Valid operators are:
   * Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
   * GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
   * DurationLessThanOrEquals, DurationLessThan
   *
   * @schema ClusterPolicySpecRulesMutateForeachPreconditionsAll#operator
   */
  readonly operator?: ClusterPolicySpecRulesMutateForeachPreconditionsAllOperator;

  /**
   * Value is the conditional value, or set of values. The values can be fixed set
   * or can be variables declared using JMESPath.
   *
   * @schema ClusterPolicySpecRulesMutateForeachPreconditionsAll#value
   */
  readonly value?: any;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMutateForeachPreconditionsAll' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMutateForeachPreconditionsAll(obj: ClusterPolicySpecRulesMutateForeachPreconditionsAll | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'message': obj.message,
    'operator': obj.operator,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Condition defines variable-based conditional criteria for rule execution.
 *
 * @schema ClusterPolicySpecRulesMutateForeachPreconditionsAny
 */
export interface ClusterPolicySpecRulesMutateForeachPreconditionsAny {
  /**
   * Key is the context entry (using JMESPath) for conditional rule evaluation.
   *
   * @schema ClusterPolicySpecRulesMutateForeachPreconditionsAny#key
   */
  readonly key?: any;

  /**
   * Message is an optional display message
   *
   * @schema ClusterPolicySpecRulesMutateForeachPreconditionsAny#message
   */
  readonly message?: string;

  /**
   * Operator is the conditional operation to perform. Valid operators are:
   * Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
   * GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
   * DurationLessThanOrEquals, DurationLessThan
   *
   * @schema ClusterPolicySpecRulesMutateForeachPreconditionsAny#operator
   */
  readonly operator?: ClusterPolicySpecRulesMutateForeachPreconditionsAnyOperator;

  /**
   * Value is the conditional value, or set of values. The values can be fixed set
   * or can be variables declared using JMESPath.
   *
   * @schema ClusterPolicySpecRulesMutateForeachPreconditionsAny#value
   */
  readonly value?: any;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMutateForeachPreconditionsAny' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMutateForeachPreconditionsAny(obj: ClusterPolicySpecRulesMutateForeachPreconditionsAny | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'message': obj.message,
    'operator': obj.operator,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * APICall is an HTTP request to the Kubernetes API server, or other JSON web service.
 * The data returned is stored in the context with the name for the context entry.
 *
 * @schema ClusterPolicySpecRulesMutateTargetsContextApiCall
 */
export interface ClusterPolicySpecRulesMutateTargetsContextApiCall {
  /**
   * The data object specifies the POST data sent to the server.
   * Only applicable when the method field is set to POST.
   *
   * @schema ClusterPolicySpecRulesMutateTargetsContextApiCall#data
   */
  readonly data?: ClusterPolicySpecRulesMutateTargetsContextApiCallData[];

  /**
   * Default is an optional arbitrary JSON object that the context
   * value is set to, if the apiCall returns error.
   *
   * @default an optional arbitrary JSON object that the context
   * @schema ClusterPolicySpecRulesMutateTargetsContextApiCall#default
   */
  readonly default?: any;

  /**
   * JMESPath is an optional JSON Match Expression that can be used to
   * transform the JSON response returned from the server. For example
   * a JMESPath of "items | length(@)" applied to the API server response
   * for the URLPath "/apis/apps/v1/deployments" will return the total count
   * of deployments across all namespaces.
   *
   * @schema ClusterPolicySpecRulesMutateTargetsContextApiCall#jmesPath
   */
  readonly jmesPath?: string;

  /**
   * Method is the HTTP request type (GET or POST). Defaults to GET.
   *
   * @default GET.
   * @schema ClusterPolicySpecRulesMutateTargetsContextApiCall#method
   */
  readonly method?: ClusterPolicySpecRulesMutateTargetsContextApiCallMethod;

  /**
   * Service is an API call to a JSON web service.
   * This is used for non-Kubernetes API server calls.
   * It's mutually exclusive with the URLPath field.
   *
   * @schema ClusterPolicySpecRulesMutateTargetsContextApiCall#service
   */
  readonly service?: ClusterPolicySpecRulesMutateTargetsContextApiCallService;

  /**
   * URLPath is the URL path to be used in the HTTP GET or POST request to the
   * Kubernetes API server (e.g. "/api/v1/namespaces" or  "/apis/apps/v1/deployments").
   * The format required is the same format used by the `kubectl get --raw` command.
   * See https://kyverno.io/docs/writing-policies/external-data-sources/#variables-from-kubernetes-api-server-calls
   * for details.
   * It's mutually exclusive with the Service field.
   *
   * @schema ClusterPolicySpecRulesMutateTargetsContextApiCall#urlPath
   */
  readonly urlPath?: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMutateTargetsContextApiCall' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMutateTargetsContextApiCall(obj: ClusterPolicySpecRulesMutateTargetsContextApiCall | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'data': obj.data?.map(y => toJson_ClusterPolicySpecRulesMutateTargetsContextApiCallData(y)),
    'default': obj.default,
    'jmesPath': obj.jmesPath,
    'method': obj.method,
    'service': toJson_ClusterPolicySpecRulesMutateTargetsContextApiCallService(obj.service),
    'urlPath': obj.urlPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap is the ConfigMap reference.
 *
 * @schema ClusterPolicySpecRulesMutateTargetsContextConfigMap
 */
export interface ClusterPolicySpecRulesMutateTargetsContextConfigMap {
  /**
   * Name is the ConfigMap name.
   *
   * @schema ClusterPolicySpecRulesMutateTargetsContextConfigMap#name
   */
  readonly name: string;

  /**
   * Namespace is the ConfigMap namespace.
   *
   * @schema ClusterPolicySpecRulesMutateTargetsContextConfigMap#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMutateTargetsContextConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMutateTargetsContextConfigMap(obj: ClusterPolicySpecRulesMutateTargetsContextConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GlobalContextEntryReference is a reference to a cached global context entry.
 *
 * @schema ClusterPolicySpecRulesMutateTargetsContextGlobalReference
 */
export interface ClusterPolicySpecRulesMutateTargetsContextGlobalReference {
  /**
   * JMESPath is an optional JSON Match Expression that can be used to
   * transform the JSON response returned from the server. For example
   * a JMESPath of "items | length(@)" applied to the API server response
   * for the URLPath "/apis/apps/v1/deployments" will return the total count
   * of deployments across all namespaces.
   *
   * @schema ClusterPolicySpecRulesMutateTargetsContextGlobalReference#jmesPath
   */
  readonly jmesPath?: string;

  /**
   * Name of the global context entry
   *
   * @schema ClusterPolicySpecRulesMutateTargetsContextGlobalReference#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMutateTargetsContextGlobalReference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMutateTargetsContextGlobalReference(obj: ClusterPolicySpecRulesMutateTargetsContextGlobalReference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'jmesPath': obj.jmesPath,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ImageRegistry defines requests to an OCI/Docker V2 registry to fetch image
 * details.
 *
 * @schema ClusterPolicySpecRulesMutateTargetsContextImageRegistry
 */
export interface ClusterPolicySpecRulesMutateTargetsContextImageRegistry {
  /**
   * ImageRegistryCredentials provides credentials that will be used for authentication with registry
   *
   * @schema ClusterPolicySpecRulesMutateTargetsContextImageRegistry#imageRegistryCredentials
   */
  readonly imageRegistryCredentials?: ClusterPolicySpecRulesMutateTargetsContextImageRegistryImageRegistryCredentials;

  /**
   * JMESPath is an optional JSON Match Expression that can be used to
   * transform the ImageData struct returned as a result of processing
   * the image reference.
   *
   * @schema ClusterPolicySpecRulesMutateTargetsContextImageRegistry#jmesPath
   */
  readonly jmesPath?: string;

  /**
   * Reference is image reference to a container image in the registry.
   * Example: ghcr.io/kyverno/kyverno:latest
   *
   * @schema ClusterPolicySpecRulesMutateTargetsContextImageRegistry#reference
   */
  readonly reference: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMutateTargetsContextImageRegistry' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMutateTargetsContextImageRegistry(obj: ClusterPolicySpecRulesMutateTargetsContextImageRegistry | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'imageRegistryCredentials': toJson_ClusterPolicySpecRulesMutateTargetsContextImageRegistryImageRegistryCredentials(obj.imageRegistryCredentials),
    'jmesPath': obj.jmesPath,
    'reference': obj.reference,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Variable defines an arbitrary JMESPath context variable that can be defined inline.
 *
 * @schema ClusterPolicySpecRulesMutateTargetsContextVariable
 */
export interface ClusterPolicySpecRulesMutateTargetsContextVariable {
  /**
   * Default is an optional arbitrary JSON object that the variable may take if the JMESPath
   * expression evaluates to nil
   *
   * @default an optional arbitrary JSON object that the variable may take if the JMESPath
   * @schema ClusterPolicySpecRulesMutateTargetsContextVariable#default
   */
  readonly default?: any;

  /**
   * JMESPath is an optional JMESPath Expression that can be used to
   * transform the variable.
   *
   * @schema ClusterPolicySpecRulesMutateTargetsContextVariable#jmesPath
   */
  readonly jmesPath?: string;

  /**
   * Value is any arbitrary JSON object representable in YAML or JSON form.
   *
   * @schema ClusterPolicySpecRulesMutateTargetsContextVariable#value
   */
  readonly value?: any;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMutateTargetsContextVariable' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMutateTargetsContextVariable(obj: ClusterPolicySpecRulesMutateTargetsContextVariable | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'default': obj.default,
    'jmesPath': obj.jmesPath,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterPolicySpecRulesMutateTargetsSelectorMatchExpressions
 */
export interface ClusterPolicySpecRulesMutateTargetsSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterPolicySpecRulesMutateTargetsSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterPolicySpecRulesMutateTargetsSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterPolicySpecRulesMutateTargetsSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMutateTargetsSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMutateTargetsSelectorMatchExpressions(obj: ClusterPolicySpecRulesMutateTargetsSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * selector can be used to match multiple param objects based on their labels.
 * Supply selector: {} to match all resources of the ParamKind.
 *
 * If multiple params are found, they are all evaluated with the policy expressions
 * and the results are ANDed together.
 *
 * One of `name` or `selector` must be set, but `name` and `selector` are
 * mutually exclusive properties. If one is set, the other must be unset.
 *
 * @schema ClusterPolicySpecRulesValidateCelParamRefSelector
 */
export interface ClusterPolicySpecRulesValidateCelParamRefSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterPolicySpecRulesValidateCelParamRefSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterPolicySpecRulesValidateCelParamRefSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterPolicySpecRulesValidateCelParamRefSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesValidateCelParamRefSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesValidateCelParamRefSelector(obj: ClusterPolicySpecRulesValidateCelParamRefSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterPolicySpecRulesValidateCelParamRefSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterPolicySpecRulesValidateFailureActionOverridesNamespaceSelectorMatchExpressions
 */
export interface ClusterPolicySpecRulesValidateFailureActionOverridesNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterPolicySpecRulesValidateFailureActionOverridesNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterPolicySpecRulesValidateFailureActionOverridesNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterPolicySpecRulesValidateFailureActionOverridesNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesValidateFailureActionOverridesNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesValidateFailureActionOverridesNamespaceSelectorMatchExpressions(obj: ClusterPolicySpecRulesValidateFailureActionOverridesNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * APICall is an HTTP request to the Kubernetes API server, or other JSON web service.
 * The data returned is stored in the context with the name for the context entry.
 *
 * @schema ClusterPolicySpecRulesValidateForeachContextApiCall
 */
export interface ClusterPolicySpecRulesValidateForeachContextApiCall {
  /**
   * The data object specifies the POST data sent to the server.
   * Only applicable when the method field is set to POST.
   *
   * @schema ClusterPolicySpecRulesValidateForeachContextApiCall#data
   */
  readonly data?: ClusterPolicySpecRulesValidateForeachContextApiCallData[];

  /**
   * Default is an optional arbitrary JSON object that the context
   * value is set to, if the apiCall returns error.
   *
   * @default an optional arbitrary JSON object that the context
   * @schema ClusterPolicySpecRulesValidateForeachContextApiCall#default
   */
  readonly default?: any;

  /**
   * JMESPath is an optional JSON Match Expression that can be used to
   * transform the JSON response returned from the server. For example
   * a JMESPath of "items | length(@)" applied to the API server response
   * for the URLPath "/apis/apps/v1/deployments" will return the total count
   * of deployments across all namespaces.
   *
   * @schema ClusterPolicySpecRulesValidateForeachContextApiCall#jmesPath
   */
  readonly jmesPath?: string;

  /**
   * Method is the HTTP request type (GET or POST). Defaults to GET.
   *
   * @default GET.
   * @schema ClusterPolicySpecRulesValidateForeachContextApiCall#method
   */
  readonly method?: ClusterPolicySpecRulesValidateForeachContextApiCallMethod;

  /**
   * Service is an API call to a JSON web service.
   * This is used for non-Kubernetes API server calls.
   * It's mutually exclusive with the URLPath field.
   *
   * @schema ClusterPolicySpecRulesValidateForeachContextApiCall#service
   */
  readonly service?: ClusterPolicySpecRulesValidateForeachContextApiCallService;

  /**
   * URLPath is the URL path to be used in the HTTP GET or POST request to the
   * Kubernetes API server (e.g. "/api/v1/namespaces" or  "/apis/apps/v1/deployments").
   * The format required is the same format used by the `kubectl get --raw` command.
   * See https://kyverno.io/docs/writing-policies/external-data-sources/#variables-from-kubernetes-api-server-calls
   * for details.
   * It's mutually exclusive with the Service field.
   *
   * @schema ClusterPolicySpecRulesValidateForeachContextApiCall#urlPath
   */
  readonly urlPath?: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesValidateForeachContextApiCall' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesValidateForeachContextApiCall(obj: ClusterPolicySpecRulesValidateForeachContextApiCall | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'data': obj.data?.map(y => toJson_ClusterPolicySpecRulesValidateForeachContextApiCallData(y)),
    'default': obj.default,
    'jmesPath': obj.jmesPath,
    'method': obj.method,
    'service': toJson_ClusterPolicySpecRulesValidateForeachContextApiCallService(obj.service),
    'urlPath': obj.urlPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap is the ConfigMap reference.
 *
 * @schema ClusterPolicySpecRulesValidateForeachContextConfigMap
 */
export interface ClusterPolicySpecRulesValidateForeachContextConfigMap {
  /**
   * Name is the ConfigMap name.
   *
   * @schema ClusterPolicySpecRulesValidateForeachContextConfigMap#name
   */
  readonly name: string;

  /**
   * Namespace is the ConfigMap namespace.
   *
   * @schema ClusterPolicySpecRulesValidateForeachContextConfigMap#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesValidateForeachContextConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesValidateForeachContextConfigMap(obj: ClusterPolicySpecRulesValidateForeachContextConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GlobalContextEntryReference is a reference to a cached global context entry.
 *
 * @schema ClusterPolicySpecRulesValidateForeachContextGlobalReference
 */
export interface ClusterPolicySpecRulesValidateForeachContextGlobalReference {
  /**
   * JMESPath is an optional JSON Match Expression that can be used to
   * transform the JSON response returned from the server. For example
   * a JMESPath of "items | length(@)" applied to the API server response
   * for the URLPath "/apis/apps/v1/deployments" will return the total count
   * of deployments across all namespaces.
   *
   * @schema ClusterPolicySpecRulesValidateForeachContextGlobalReference#jmesPath
   */
  readonly jmesPath?: string;

  /**
   * Name of the global context entry
   *
   * @schema ClusterPolicySpecRulesValidateForeachContextGlobalReference#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesValidateForeachContextGlobalReference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesValidateForeachContextGlobalReference(obj: ClusterPolicySpecRulesValidateForeachContextGlobalReference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'jmesPath': obj.jmesPath,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ImageRegistry defines requests to an OCI/Docker V2 registry to fetch image
 * details.
 *
 * @schema ClusterPolicySpecRulesValidateForeachContextImageRegistry
 */
export interface ClusterPolicySpecRulesValidateForeachContextImageRegistry {
  /**
   * ImageRegistryCredentials provides credentials that will be used for authentication with registry
   *
   * @schema ClusterPolicySpecRulesValidateForeachContextImageRegistry#imageRegistryCredentials
   */
  readonly imageRegistryCredentials?: ClusterPolicySpecRulesValidateForeachContextImageRegistryImageRegistryCredentials;

  /**
   * JMESPath is an optional JSON Match Expression that can be used to
   * transform the ImageData struct returned as a result of processing
   * the image reference.
   *
   * @schema ClusterPolicySpecRulesValidateForeachContextImageRegistry#jmesPath
   */
  readonly jmesPath?: string;

  /**
   * Reference is image reference to a container image in the registry.
   * Example: ghcr.io/kyverno/kyverno:latest
   *
   * @schema ClusterPolicySpecRulesValidateForeachContextImageRegistry#reference
   */
  readonly reference: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesValidateForeachContextImageRegistry' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesValidateForeachContextImageRegistry(obj: ClusterPolicySpecRulesValidateForeachContextImageRegistry | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'imageRegistryCredentials': toJson_ClusterPolicySpecRulesValidateForeachContextImageRegistryImageRegistryCredentials(obj.imageRegistryCredentials),
    'jmesPath': obj.jmesPath,
    'reference': obj.reference,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Variable defines an arbitrary JMESPath context variable that can be defined inline.
 *
 * @schema ClusterPolicySpecRulesValidateForeachContextVariable
 */
export interface ClusterPolicySpecRulesValidateForeachContextVariable {
  /**
   * Default is an optional arbitrary JSON object that the variable may take if the JMESPath
   * expression evaluates to nil
   *
   * @default an optional arbitrary JSON object that the variable may take if the JMESPath
   * @schema ClusterPolicySpecRulesValidateForeachContextVariable#default
   */
  readonly default?: any;

  /**
   * JMESPath is an optional JMESPath Expression that can be used to
   * transform the variable.
   *
   * @schema ClusterPolicySpecRulesValidateForeachContextVariable#jmesPath
   */
  readonly jmesPath?: string;

  /**
   * Value is any arbitrary JSON object representable in YAML or JSON form.
   *
   * @schema ClusterPolicySpecRulesValidateForeachContextVariable#value
   */
  readonly value?: any;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesValidateForeachContextVariable' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesValidateForeachContextVariable(obj: ClusterPolicySpecRulesValidateForeachContextVariable | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'default': obj.default,
    'jmesPath': obj.jmesPath,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Condition defines variable-based conditional criteria for rule execution.
 *
 * @schema ClusterPolicySpecRulesValidateForeachPreconditionsAll
 */
export interface ClusterPolicySpecRulesValidateForeachPreconditionsAll {
  /**
   * Key is the context entry (using JMESPath) for conditional rule evaluation.
   *
   * @schema ClusterPolicySpecRulesValidateForeachPreconditionsAll#key
   */
  readonly key?: any;

  /**
   * Message is an optional display message
   *
   * @schema ClusterPolicySpecRulesValidateForeachPreconditionsAll#message
   */
  readonly message?: string;

  /**
   * Operator is the conditional operation to perform. Valid operators are:
   * Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
   * GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
   * DurationLessThanOrEquals, DurationLessThan
   *
   * @schema ClusterPolicySpecRulesValidateForeachPreconditionsAll#operator
   */
  readonly operator?: ClusterPolicySpecRulesValidateForeachPreconditionsAllOperator;

  /**
   * Value is the conditional value, or set of values. The values can be fixed set
   * or can be variables declared using JMESPath.
   *
   * @schema ClusterPolicySpecRulesValidateForeachPreconditionsAll#value
   */
  readonly value?: any;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesValidateForeachPreconditionsAll' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesValidateForeachPreconditionsAll(obj: ClusterPolicySpecRulesValidateForeachPreconditionsAll | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'message': obj.message,
    'operator': obj.operator,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Condition defines variable-based conditional criteria for rule execution.
 *
 * @schema ClusterPolicySpecRulesValidateForeachPreconditionsAny
 */
export interface ClusterPolicySpecRulesValidateForeachPreconditionsAny {
  /**
   * Key is the context entry (using JMESPath) for conditional rule evaluation.
   *
   * @schema ClusterPolicySpecRulesValidateForeachPreconditionsAny#key
   */
  readonly key?: any;

  /**
   * Message is an optional display message
   *
   * @schema ClusterPolicySpecRulesValidateForeachPreconditionsAny#message
   */
  readonly message?: string;

  /**
   * Operator is the conditional operation to perform. Valid operators are:
   * Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
   * GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
   * DurationLessThanOrEquals, DurationLessThan
   *
   * @schema ClusterPolicySpecRulesValidateForeachPreconditionsAny#operator
   */
  readonly operator?: ClusterPolicySpecRulesValidateForeachPreconditionsAnyOperator;

  /**
   * Value is the conditional value, or set of values. The values can be fixed set
   * or can be variables declared using JMESPath.
   *
   * @schema ClusterPolicySpecRulesValidateForeachPreconditionsAny#value
   */
  readonly value?: any;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesValidateForeachPreconditionsAny' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesValidateForeachPreconditionsAny(obj: ClusterPolicySpecRulesValidateForeachPreconditionsAny | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'message': obj.message,
    'operator': obj.operator,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterPolicySpecRulesValidateManifestsAttestorsEntries
 */
export interface ClusterPolicySpecRulesValidateManifestsAttestorsEntries {
  /**
   * Annotations are used for image verification.
   * Every specified key-value pair must exist and match in the verified payload.
   * The payload may contain other key-value pairs.
   *
   * @schema ClusterPolicySpecRulesValidateManifestsAttestorsEntries#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Attestor is a nested set of Attestor used to specify a more complex set of match authorities.
   *
   * @schema ClusterPolicySpecRulesValidateManifestsAttestorsEntries#attestor
   */
  readonly attestor?: any;

  /**
   * Certificates specifies one or more certificates.
   *
   * @schema ClusterPolicySpecRulesValidateManifestsAttestorsEntries#certificates
   */
  readonly certificates?: ClusterPolicySpecRulesValidateManifestsAttestorsEntriesCertificates;

  /**
   * Keyless is a set of attribute used to verify a Sigstore keyless attestor.
   * See https://github.com/sigstore/cosign/blob/main/KEYLESS.md.
   *
   * @schema ClusterPolicySpecRulesValidateManifestsAttestorsEntries#keyless
   */
  readonly keyless?: ClusterPolicySpecRulesValidateManifestsAttestorsEntriesKeyless;

  /**
   * Keys specifies one or more public keys.
   *
   * @schema ClusterPolicySpecRulesValidateManifestsAttestorsEntries#keys
   */
  readonly keys?: ClusterPolicySpecRulesValidateManifestsAttestorsEntriesKeys;

  /**
   * Repository is an optional alternate OCI repository to use for signatures and attestations that match this rule.
   * If specified Repository will override other OCI image repository locations for this Attestor.
   *
   * @schema ClusterPolicySpecRulesValidateManifestsAttestorsEntries#repository
   */
  readonly repository?: string;

  /**
   * Specify signature algorithm for public keys. Supported values are sha224, sha256, sha384 and sha512.
   *
   * @schema ClusterPolicySpecRulesValidateManifestsAttestorsEntries#signatureAlgorithm
   */
  readonly signatureAlgorithm?: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesValidateManifestsAttestorsEntries' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesValidateManifestsAttestorsEntries(obj: ClusterPolicySpecRulesValidateManifestsAttestorsEntries | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'attestor': obj.attestor,
    'certificates': toJson_ClusterPolicySpecRulesValidateManifestsAttestorsEntriesCertificates(obj.certificates),
    'keyless': toJson_ClusterPolicySpecRulesValidateManifestsAttestorsEntriesKeyless(obj.keyless),
    'keys': toJson_ClusterPolicySpecRulesValidateManifestsAttestorsEntriesKeys(obj.keys),
    'repository': obj.repository,
    'signatureAlgorithm': obj.signatureAlgorithm,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterPolicySpecRulesValidateManifestsIgnoreFieldsObjects
 */
export interface ClusterPolicySpecRulesValidateManifestsIgnoreFieldsObjects {
  /**
   * @schema ClusterPolicySpecRulesValidateManifestsIgnoreFieldsObjects#group
   */
  readonly group?: string;

  /**
   * @schema ClusterPolicySpecRulesValidateManifestsIgnoreFieldsObjects#kind
   */
  readonly kind?: string;

  /**
   * @schema ClusterPolicySpecRulesValidateManifestsIgnoreFieldsObjects#name
   */
  readonly name?: string;

  /**
   * @schema ClusterPolicySpecRulesValidateManifestsIgnoreFieldsObjects#namespace
   */
  readonly namespace?: string;

  /**
   * @schema ClusterPolicySpecRulesValidateManifestsIgnoreFieldsObjects#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesValidateManifestsIgnoreFieldsObjects' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesValidateManifestsIgnoreFieldsObjects(obj: ClusterPolicySpecRulesValidateManifestsIgnoreFieldsObjects | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ControlName specifies the name of the Pod Security Standard control.
 * See: https://kubernetes.io/docs/concepts/security/pod-security-standards/
 *
 * @schema ClusterPolicySpecRulesValidatePodSecurityExcludeControlName
 */
export enum ClusterPolicySpecRulesValidatePodSecurityExcludeControlName {
  /** HostProcess */
  HOST_PROCESS = "HostProcess",
  /** Host Namespaces */
  HOST_NAMESPACES = "Host Namespaces",
  /** Privileged Containers */
  PRIVILEGED_CONTAINERS = "Privileged Containers",
  /** Capabilities */
  CAPABILITIES = "Capabilities",
  /** HostPath Volumes */
  HOST_PATH_VOLUMES = "HostPath Volumes",
  /** Host Ports */
  HOST_PORTS = "Host Ports",
  /** AppArmor */
  APP_ARMOR = "AppArmor",
  /** SELinux */
  SE_LINUX = "SELinux",
  /** /proc Mount Type */
  VALUE_FORWARD_SLASH_PROC_MOUNT_TYPE = "/proc Mount Type",
  /** Seccomp */
  SECCOMP = "Seccomp",
  /** Sysctls */
  SYSCTLS = "Sysctls",
  /** Volume Types */
  VOLUME_TYPES = "Volume Types",
  /** Privilege Escalation */
  PRIVILEGE_ESCALATION = "Privilege Escalation",
  /** Running as Non-root */
  RUNNING_AS_NON_HYPHEN_ROOT = "Running as Non-root",
  /** Running as Non-root user */
  RUNNING_AS_NON_HYPHEN_ROOT_USER = "Running as Non-root user",
}

/**
 * @schema ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntries
 */
export interface ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntries {
  /**
   * Annotations are used for image verification.
   * Every specified key-value pair must exist and match in the verified payload.
   * The payload may contain other key-value pairs.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntries#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Attestor is a nested set of Attestor used to specify a more complex set of match authorities.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntries#attestor
   */
  readonly attestor?: any;

  /**
   * Certificates specifies one or more certificates.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntries#certificates
   */
  readonly certificates?: ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesCertificates;

  /**
   * Keyless is a set of attribute used to verify a Sigstore keyless attestor.
   * See https://github.com/sigstore/cosign/blob/main/KEYLESS.md.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntries#keyless
   */
  readonly keyless?: ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesKeyless;

  /**
   * Keys specifies one or more public keys.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntries#keys
   */
  readonly keys?: ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesKeys;

  /**
   * Repository is an optional alternate OCI repository to use for signatures and attestations that match this rule.
   * If specified Repository will override other OCI image repository locations for this Attestor.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntries#repository
   */
  readonly repository?: string;

  /**
   * Specify signature algorithm for public keys. Supported values are sha224, sha256, sha384 and sha512.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntries#signatureAlgorithm
   */
  readonly signatureAlgorithm?: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntries' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntries(obj: ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntries | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'attestor': obj.attestor,
    'certificates': toJson_ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesCertificates(obj.certificates),
    'keyless': toJson_ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesKeyless(obj.keyless),
    'keys': toJson_ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesKeys(obj.keys),
    'repository': obj.repository,
    'signatureAlgorithm': obj.signatureAlgorithm,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Condition defines variable-based conditional criteria for rule execution.
 *
 * @schema ClusterPolicySpecRulesVerifyImagesAttestationsConditionsAll
 */
export interface ClusterPolicySpecRulesVerifyImagesAttestationsConditionsAll {
  /**
   * Key is the context entry (using JMESPath) for conditional rule evaluation.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestationsConditionsAll#key
   */
  readonly key?: any;

  /**
   * Message is an optional display message
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestationsConditionsAll#message
   */
  readonly message?: string;

  /**
   * Operator is the conditional operation to perform. Valid operators are:
   * Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
   * GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
   * DurationLessThanOrEquals, DurationLessThan
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestationsConditionsAll#operator
   */
  readonly operator?: ClusterPolicySpecRulesVerifyImagesAttestationsConditionsAllOperator;

  /**
   * Value is the conditional value, or set of values. The values can be fixed set
   * or can be variables declared using JMESPath.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestationsConditionsAll#value
   */
  readonly value?: any;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesVerifyImagesAttestationsConditionsAll' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesVerifyImagesAttestationsConditionsAll(obj: ClusterPolicySpecRulesVerifyImagesAttestationsConditionsAll | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'message': obj.message,
    'operator': obj.operator,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Condition defines variable-based conditional criteria for rule execution.
 *
 * @schema ClusterPolicySpecRulesVerifyImagesAttestationsConditionsAny
 */
export interface ClusterPolicySpecRulesVerifyImagesAttestationsConditionsAny {
  /**
   * Key is the context entry (using JMESPath) for conditional rule evaluation.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestationsConditionsAny#key
   */
  readonly key?: any;

  /**
   * Message is an optional display message
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestationsConditionsAny#message
   */
  readonly message?: string;

  /**
   * Operator is the conditional operation to perform. Valid operators are:
   * Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
   * GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
   * DurationLessThanOrEquals, DurationLessThan
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestationsConditionsAny#operator
   */
  readonly operator?: ClusterPolicySpecRulesVerifyImagesAttestationsConditionsAnyOperator;

  /**
   * Value is the conditional value, or set of values. The values can be fixed set
   * or can be variables declared using JMESPath.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestationsConditionsAny#value
   */
  readonly value?: any;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesVerifyImagesAttestationsConditionsAny' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesVerifyImagesAttestationsConditionsAny(obj: ClusterPolicySpecRulesVerifyImagesAttestationsConditionsAny | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'message': obj.message,
    'operator': obj.operator,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Certificates specifies one or more certificates.
 *
 * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntriesCertificates
 */
export interface ClusterPolicySpecRulesVerifyImagesAttestorsEntriesCertificates {
  /**
   * Cert is an optional PEM-encoded public certificate.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntriesCertificates#cert
   */
  readonly cert?: string;

  /**
   * CertChain is an optional PEM encoded set of certificates used to verify.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntriesCertificates#certChain
   */
  readonly certChain?: string;

  /**
   * CTLog (certificate timestamp log) provides a configuration for validation of Signed Certificate
   * Timestamps (SCTs). If the value is unset, the default behavior by Cosign is used.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntriesCertificates#ctlog
   */
  readonly ctlog?: ClusterPolicySpecRulesVerifyImagesAttestorsEntriesCertificatesCtlog;

  /**
   * Rekor provides configuration for the Rekor transparency log service. If an empty object
   * is provided the public instance of Rekor (https://rekor.sigstore.dev) is used.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntriesCertificates#rekor
   */
  readonly rekor?: ClusterPolicySpecRulesVerifyImagesAttestorsEntriesCertificatesRekor;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesVerifyImagesAttestorsEntriesCertificates' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesVerifyImagesAttestorsEntriesCertificates(obj: ClusterPolicySpecRulesVerifyImagesAttestorsEntriesCertificates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cert': obj.cert,
    'certChain': obj.certChain,
    'ctlog': toJson_ClusterPolicySpecRulesVerifyImagesAttestorsEntriesCertificatesCtlog(obj.ctlog),
    'rekor': toJson_ClusterPolicySpecRulesVerifyImagesAttestorsEntriesCertificatesRekor(obj.rekor),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Keyless is a set of attribute used to verify a Sigstore keyless attestor.
 * See https://github.com/sigstore/cosign/blob/main/KEYLESS.md.
 *
 * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeyless
 */
export interface ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeyless {
  /**
   * AdditionalExtensions are certificate-extensions used for keyless signing.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeyless#additionalExtensions
   */
  readonly additionalExtensions?: { [key: string]: string };

  /**
   * CTLog (certificate timestamp log) provides a configuration for validation of Signed Certificate
   * Timestamps (SCTs). If the value is unset, the default behavior by Cosign is used.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeyless#ctlog
   */
  readonly ctlog?: ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeylessCtlog;

  /**
   * Issuer is the certificate issuer used for keyless signing.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeyless#issuer
   */
  readonly issuer?: string;

  /**
   * IssuerRegExp is the regular expression to match certificate issuer used for keyless signing.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeyless#issuerRegExp
   */
  readonly issuerRegExp?: string;

  /**
   * Rekor provides configuration for the Rekor transparency log service. If an empty object
   * is provided the public instance of Rekor (https://rekor.sigstore.dev) is used.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeyless#rekor
   */
  readonly rekor?: ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeylessRekor;

  /**
   * Roots is an optional set of PEM encoded trusted root certificates.
   * If not provided, the system roots are used.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeyless#roots
   */
  readonly roots?: string;

  /**
   * Subject is the verified identity used for keyless signing, for example the email address.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeyless#subject
   */
  readonly subject?: string;

  /**
   * SubjectRegExp is the regular expression to match identity used for keyless signing, for example the email address.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeyless#subjectRegExp
   */
  readonly subjectRegExp?: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeyless' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeyless(obj: ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeyless | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalExtensions': ((obj.additionalExtensions) === undefined) ? undefined : (Object.entries(obj.additionalExtensions).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'ctlog': toJson_ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeylessCtlog(obj.ctlog),
    'issuer': obj.issuer,
    'issuerRegExp': obj.issuerRegExp,
    'rekor': toJson_ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeylessRekor(obj.rekor),
    'roots': obj.roots,
    'subject': obj.subject,
    'subjectRegExp': obj.subjectRegExp,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Keys specifies one or more public keys.
 *
 * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeys
 */
export interface ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeys {
  /**
   * CTLog (certificate timestamp log) provides a configuration for validation of Signed Certificate
   * Timestamps (SCTs). If the value is unset, the default behavior by Cosign is used.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeys#ctlog
   */
  readonly ctlog?: ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeysCtlog;

  /**
   * KMS provides the URI to the public key stored in a Key Management System. See:
   * https://github.com/sigstore/cosign/blob/main/KMS.md
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeys#kms
   */
  readonly kms?: string;

  /**
   * Keys is a set of X.509 public keys used to verify image signatures. The keys can be directly
   * specified or can be a variable reference to a key specified in a ConfigMap (see
   * https://kyverno.io/docs/writing-policies/variables/), or reference a standard Kubernetes Secret
   * elsewhere in the cluster by specifying it in the format "k8s://<namespace>/<secret_name>".
   * The named Secret must specify a key `cosign.pub` containing the public key used for
   * verification, (see https://github.com/sigstore/cosign/blob/main/KMS.md#kubernetes-secret).
   * When multiple keys are specified each key is processed as a separate staticKey entry
   * (.attestors[*].entries.keys) within the set of attestors and the count is applied across the keys.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeys#publicKeys
   */
  readonly publicKeys?: string;

  /**
   * Rekor provides configuration for the Rekor transparency log service. If an empty object
   * is provided the public instance of Rekor (https://rekor.sigstore.dev) is used.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeys#rekor
   */
  readonly rekor?: ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeysRekor;

  /**
   * Reference to a Secret resource that contains a public key
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeys#secret
   */
  readonly secret?: ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeysSecret;

  /**
   * Deprecated. Use attestor.signatureAlgorithm instead.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeys#signatureAlgorithm
   */
  readonly signatureAlgorithm?: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeys' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeys(obj: ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeys | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ctlog': toJson_ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeysCtlog(obj.ctlog),
    'kms': obj.kms,
    'publicKeys': obj.publicKeys,
    'rekor': toJson_ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeysRekor(obj.rekor),
    'secret': toJson_ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeysSecret(obj.secret),
    'signatureAlgorithm': obj.signatureAlgorithm,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterPolicySpecRulesExcludeAllResourcesNamespaceSelectorMatchExpressions
 */
export interface ClusterPolicySpecRulesExcludeAllResourcesNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterPolicySpecRulesExcludeAllResourcesNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterPolicySpecRulesExcludeAllResourcesNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterPolicySpecRulesExcludeAllResourcesNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesExcludeAllResourcesNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesExcludeAllResourcesNamespaceSelectorMatchExpressions(obj: ClusterPolicySpecRulesExcludeAllResourcesNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterPolicySpecRulesExcludeAllResourcesSelectorMatchExpressions
 */
export interface ClusterPolicySpecRulesExcludeAllResourcesSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterPolicySpecRulesExcludeAllResourcesSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterPolicySpecRulesExcludeAllResourcesSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterPolicySpecRulesExcludeAllResourcesSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesExcludeAllResourcesSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesExcludeAllResourcesSelectorMatchExpressions(obj: ClusterPolicySpecRulesExcludeAllResourcesSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterPolicySpecRulesExcludeAnyResourcesNamespaceSelectorMatchExpressions
 */
export interface ClusterPolicySpecRulesExcludeAnyResourcesNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterPolicySpecRulesExcludeAnyResourcesNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterPolicySpecRulesExcludeAnyResourcesNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterPolicySpecRulesExcludeAnyResourcesNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesExcludeAnyResourcesNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesExcludeAnyResourcesNamespaceSelectorMatchExpressions(obj: ClusterPolicySpecRulesExcludeAnyResourcesNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterPolicySpecRulesExcludeAnyResourcesSelectorMatchExpressions
 */
export interface ClusterPolicySpecRulesExcludeAnyResourcesSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterPolicySpecRulesExcludeAnyResourcesSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterPolicySpecRulesExcludeAnyResourcesSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterPolicySpecRulesExcludeAnyResourcesSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesExcludeAnyResourcesSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesExcludeAnyResourcesSelectorMatchExpressions(obj: ClusterPolicySpecRulesExcludeAnyResourcesSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterPolicySpecRulesGenerateForeachCloneListSelectorMatchExpressions
 */
export interface ClusterPolicySpecRulesGenerateForeachCloneListSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterPolicySpecRulesGenerateForeachCloneListSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterPolicySpecRulesGenerateForeachCloneListSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterPolicySpecRulesGenerateForeachCloneListSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesGenerateForeachCloneListSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesGenerateForeachCloneListSelectorMatchExpressions(obj: ClusterPolicySpecRulesGenerateForeachCloneListSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RequestData contains the HTTP POST data
 *
 * @schema ClusterPolicySpecRulesGenerateForeachContextApiCallData
 */
export interface ClusterPolicySpecRulesGenerateForeachContextApiCallData {
  /**
   * Key is a unique identifier for the data value
   *
   * @schema ClusterPolicySpecRulesGenerateForeachContextApiCallData#key
   */
  readonly key: string;

  /**
   * Value is the data value
   *
   * @schema ClusterPolicySpecRulesGenerateForeachContextApiCallData#value
   */
  readonly value: any;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesGenerateForeachContextApiCallData' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesGenerateForeachContextApiCallData(obj: ClusterPolicySpecRulesGenerateForeachContextApiCallData | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Method is the HTTP request type (GET or POST). Defaults to GET.
 *
 * @default GET.
 * @schema ClusterPolicySpecRulesGenerateForeachContextApiCallMethod
 */
export enum ClusterPolicySpecRulesGenerateForeachContextApiCallMethod {
  /** GET */
  GET = "GET",
  /** POST */
  POST = "POST",
}

/**
 * Service is an API call to a JSON web service.
 * This is used for non-Kubernetes API server calls.
 * It's mutually exclusive with the URLPath field.
 *
 * @schema ClusterPolicySpecRulesGenerateForeachContextApiCallService
 */
export interface ClusterPolicySpecRulesGenerateForeachContextApiCallService {
  /**
   * CABundle is a PEM encoded CA bundle which will be used to validate
   * the server certificate.
   *
   * @schema ClusterPolicySpecRulesGenerateForeachContextApiCallService#caBundle
   */
  readonly caBundle?: string;

  /**
   * Headers is a list of optional HTTP headers to be included in the request.
   *
   * @schema ClusterPolicySpecRulesGenerateForeachContextApiCallService#headers
   */
  readonly headers?: ClusterPolicySpecRulesGenerateForeachContextApiCallServiceHeaders[];

  /**
   * URL is the JSON web service URL. A typical form is
   * `https://{service}.{namespace}:{port}/{path}`.
   *
   * @schema ClusterPolicySpecRulesGenerateForeachContextApiCallService#url
   */
  readonly url: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesGenerateForeachContextApiCallService' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesGenerateForeachContextApiCallService(obj: ClusterPolicySpecRulesGenerateForeachContextApiCallService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caBundle': obj.caBundle,
    'headers': obj.headers?.map(y => toJson_ClusterPolicySpecRulesGenerateForeachContextApiCallServiceHeaders(y)),
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ImageRegistryCredentials provides credentials that will be used for authentication with registry
 *
 * @schema ClusterPolicySpecRulesGenerateForeachContextImageRegistryImageRegistryCredentials
 */
export interface ClusterPolicySpecRulesGenerateForeachContextImageRegistryImageRegistryCredentials {
  /**
   * AllowInsecureRegistry allows insecure access to a registry.
   *
   * @schema ClusterPolicySpecRulesGenerateForeachContextImageRegistryImageRegistryCredentials#allowInsecureRegistry
   */
  readonly allowInsecureRegistry?: boolean;

  /**
   * Providers specifies a list of OCI Registry names, whose authentication providers are provided.
   * It can be of one of these values: default,google,azure,amazon,github.
   *
   * @schema ClusterPolicySpecRulesGenerateForeachContextImageRegistryImageRegistryCredentials#providers
   */
  readonly providers?: ClusterPolicySpecRulesGenerateForeachContextImageRegistryImageRegistryCredentialsProviders[];

  /**
   * Secrets specifies a list of secrets that are provided for credentials.
   * Secrets must live in the Kyverno namespace.
   *
   * @schema ClusterPolicySpecRulesGenerateForeachContextImageRegistryImageRegistryCredentials#secrets
   */
  readonly secrets?: string[];

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesGenerateForeachContextImageRegistryImageRegistryCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesGenerateForeachContextImageRegistryImageRegistryCredentials(obj: ClusterPolicySpecRulesGenerateForeachContextImageRegistryImageRegistryCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowInsecureRegistry': obj.allowInsecureRegistry,
    'providers': obj.providers?.map(y => y),
    'secrets': obj.secrets?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Operator is the conditional operation to perform. Valid operators are:
 * Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
 * GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
 * DurationLessThanOrEquals, DurationLessThan
 *
 * @schema ClusterPolicySpecRulesGenerateForeachPreconditionsAllOperator
 */
export enum ClusterPolicySpecRulesGenerateForeachPreconditionsAllOperator {
  /** Equals */
  EQUALS = "Equals",
  /** NotEquals */
  NOT_EQUALS = "NotEquals",
  /** In */
  IN = "In",
  /** AnyIn */
  ANY_IN = "AnyIn",
  /** AllIn */
  ALL_IN = "AllIn",
  /** NotIn */
  NOT_IN = "NotIn",
  /** AnyNotIn */
  ANY_NOT_IN = "AnyNotIn",
  /** AllNotIn */
  ALL_NOT_IN = "AllNotIn",
  /** GreaterThanOrEquals */
  GREATER_THAN_OR_EQUALS = "GreaterThanOrEquals",
  /** GreaterThan */
  GREATER_THAN = "GreaterThan",
  /** LessThanOrEquals */
  LESS_THAN_OR_EQUALS = "LessThanOrEquals",
  /** LessThan */
  LESS_THAN = "LessThan",
  /** DurationGreaterThanOrEquals */
  DURATION_GREATER_THAN_OR_EQUALS = "DurationGreaterThanOrEquals",
  /** DurationGreaterThan */
  DURATION_GREATER_THAN = "DurationGreaterThan",
  /** DurationLessThanOrEquals */
  DURATION_LESS_THAN_OR_EQUALS = "DurationLessThanOrEquals",
  /** DurationLessThan */
  DURATION_LESS_THAN = "DurationLessThan",
}

/**
 * Operator is the conditional operation to perform. Valid operators are:
 * Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
 * GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
 * DurationLessThanOrEquals, DurationLessThan
 *
 * @schema ClusterPolicySpecRulesGenerateForeachPreconditionsAnyOperator
 */
export enum ClusterPolicySpecRulesGenerateForeachPreconditionsAnyOperator {
  /** Equals */
  EQUALS = "Equals",
  /** NotEquals */
  NOT_EQUALS = "NotEquals",
  /** In */
  IN = "In",
  /** AnyIn */
  ANY_IN = "AnyIn",
  /** AllIn */
  ALL_IN = "AllIn",
  /** NotIn */
  NOT_IN = "NotIn",
  /** AnyNotIn */
  ANY_NOT_IN = "AnyNotIn",
  /** AllNotIn */
  ALL_NOT_IN = "AllNotIn",
  /** GreaterThanOrEquals */
  GREATER_THAN_OR_EQUALS = "GreaterThanOrEquals",
  /** GreaterThan */
  GREATER_THAN = "GreaterThan",
  /** LessThanOrEquals */
  LESS_THAN_OR_EQUALS = "LessThanOrEquals",
  /** LessThan */
  LESS_THAN = "LessThan",
  /** DurationGreaterThanOrEquals */
  DURATION_GREATER_THAN_OR_EQUALS = "DurationGreaterThanOrEquals",
  /** DurationGreaterThan */
  DURATION_GREATER_THAN = "DurationGreaterThan",
  /** DurationLessThanOrEquals */
  DURATION_LESS_THAN_OR_EQUALS = "DurationLessThanOrEquals",
  /** DurationLessThan */
  DURATION_LESS_THAN = "DurationLessThan",
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterPolicySpecRulesMatchAllResourcesNamespaceSelectorMatchExpressions
 */
export interface ClusterPolicySpecRulesMatchAllResourcesNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterPolicySpecRulesMatchAllResourcesNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterPolicySpecRulesMatchAllResourcesNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterPolicySpecRulesMatchAllResourcesNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMatchAllResourcesNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMatchAllResourcesNamespaceSelectorMatchExpressions(obj: ClusterPolicySpecRulesMatchAllResourcesNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterPolicySpecRulesMatchAllResourcesSelectorMatchExpressions
 */
export interface ClusterPolicySpecRulesMatchAllResourcesSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterPolicySpecRulesMatchAllResourcesSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterPolicySpecRulesMatchAllResourcesSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterPolicySpecRulesMatchAllResourcesSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMatchAllResourcesSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMatchAllResourcesSelectorMatchExpressions(obj: ClusterPolicySpecRulesMatchAllResourcesSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterPolicySpecRulesMatchAnyResourcesNamespaceSelectorMatchExpressions
 */
export interface ClusterPolicySpecRulesMatchAnyResourcesNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterPolicySpecRulesMatchAnyResourcesNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterPolicySpecRulesMatchAnyResourcesNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterPolicySpecRulesMatchAnyResourcesNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMatchAnyResourcesNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMatchAnyResourcesNamespaceSelectorMatchExpressions(obj: ClusterPolicySpecRulesMatchAnyResourcesNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterPolicySpecRulesMatchAnyResourcesSelectorMatchExpressions
 */
export interface ClusterPolicySpecRulesMatchAnyResourcesSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterPolicySpecRulesMatchAnyResourcesSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterPolicySpecRulesMatchAnyResourcesSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterPolicySpecRulesMatchAnyResourcesSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMatchAnyResourcesSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMatchAnyResourcesSelectorMatchExpressions(obj: ClusterPolicySpecRulesMatchAnyResourcesSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RequestData contains the HTTP POST data
 *
 * @schema ClusterPolicySpecRulesMutateForeachContextApiCallData
 */
export interface ClusterPolicySpecRulesMutateForeachContextApiCallData {
  /**
   * Key is a unique identifier for the data value
   *
   * @schema ClusterPolicySpecRulesMutateForeachContextApiCallData#key
   */
  readonly key: string;

  /**
   * Value is the data value
   *
   * @schema ClusterPolicySpecRulesMutateForeachContextApiCallData#value
   */
  readonly value: any;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMutateForeachContextApiCallData' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMutateForeachContextApiCallData(obj: ClusterPolicySpecRulesMutateForeachContextApiCallData | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Method is the HTTP request type (GET or POST). Defaults to GET.
 *
 * @default GET.
 * @schema ClusterPolicySpecRulesMutateForeachContextApiCallMethod
 */
export enum ClusterPolicySpecRulesMutateForeachContextApiCallMethod {
  /** GET */
  GET = "GET",
  /** POST */
  POST = "POST",
}

/**
 * Service is an API call to a JSON web service.
 * This is used for non-Kubernetes API server calls.
 * It's mutually exclusive with the URLPath field.
 *
 * @schema ClusterPolicySpecRulesMutateForeachContextApiCallService
 */
export interface ClusterPolicySpecRulesMutateForeachContextApiCallService {
  /**
   * CABundle is a PEM encoded CA bundle which will be used to validate
   * the server certificate.
   *
   * @schema ClusterPolicySpecRulesMutateForeachContextApiCallService#caBundle
   */
  readonly caBundle?: string;

  /**
   * Headers is a list of optional HTTP headers to be included in the request.
   *
   * @schema ClusterPolicySpecRulesMutateForeachContextApiCallService#headers
   */
  readonly headers?: ClusterPolicySpecRulesMutateForeachContextApiCallServiceHeaders[];

  /**
   * URL is the JSON web service URL. A typical form is
   * `https://{service}.{namespace}:{port}/{path}`.
   *
   * @schema ClusterPolicySpecRulesMutateForeachContextApiCallService#url
   */
  readonly url: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMutateForeachContextApiCallService' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMutateForeachContextApiCallService(obj: ClusterPolicySpecRulesMutateForeachContextApiCallService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caBundle': obj.caBundle,
    'headers': obj.headers?.map(y => toJson_ClusterPolicySpecRulesMutateForeachContextApiCallServiceHeaders(y)),
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ImageRegistryCredentials provides credentials that will be used for authentication with registry
 *
 * @schema ClusterPolicySpecRulesMutateForeachContextImageRegistryImageRegistryCredentials
 */
export interface ClusterPolicySpecRulesMutateForeachContextImageRegistryImageRegistryCredentials {
  /**
   * AllowInsecureRegistry allows insecure access to a registry.
   *
   * @schema ClusterPolicySpecRulesMutateForeachContextImageRegistryImageRegistryCredentials#allowInsecureRegistry
   */
  readonly allowInsecureRegistry?: boolean;

  /**
   * Providers specifies a list of OCI Registry names, whose authentication providers are provided.
   * It can be of one of these values: default,google,azure,amazon,github.
   *
   * @schema ClusterPolicySpecRulesMutateForeachContextImageRegistryImageRegistryCredentials#providers
   */
  readonly providers?: ClusterPolicySpecRulesMutateForeachContextImageRegistryImageRegistryCredentialsProviders[];

  /**
   * Secrets specifies a list of secrets that are provided for credentials.
   * Secrets must live in the Kyverno namespace.
   *
   * @schema ClusterPolicySpecRulesMutateForeachContextImageRegistryImageRegistryCredentials#secrets
   */
  readonly secrets?: string[];

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMutateForeachContextImageRegistryImageRegistryCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMutateForeachContextImageRegistryImageRegistryCredentials(obj: ClusterPolicySpecRulesMutateForeachContextImageRegistryImageRegistryCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowInsecureRegistry': obj.allowInsecureRegistry,
    'providers': obj.providers?.map(y => y),
    'secrets': obj.secrets?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Operator is the conditional operation to perform. Valid operators are:
 * Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
 * GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
 * DurationLessThanOrEquals, DurationLessThan
 *
 * @schema ClusterPolicySpecRulesMutateForeachPreconditionsAllOperator
 */
export enum ClusterPolicySpecRulesMutateForeachPreconditionsAllOperator {
  /** Equals */
  EQUALS = "Equals",
  /** NotEquals */
  NOT_EQUALS = "NotEquals",
  /** In */
  IN = "In",
  /** AnyIn */
  ANY_IN = "AnyIn",
  /** AllIn */
  ALL_IN = "AllIn",
  /** NotIn */
  NOT_IN = "NotIn",
  /** AnyNotIn */
  ANY_NOT_IN = "AnyNotIn",
  /** AllNotIn */
  ALL_NOT_IN = "AllNotIn",
  /** GreaterThanOrEquals */
  GREATER_THAN_OR_EQUALS = "GreaterThanOrEquals",
  /** GreaterThan */
  GREATER_THAN = "GreaterThan",
  /** LessThanOrEquals */
  LESS_THAN_OR_EQUALS = "LessThanOrEquals",
  /** LessThan */
  LESS_THAN = "LessThan",
  /** DurationGreaterThanOrEquals */
  DURATION_GREATER_THAN_OR_EQUALS = "DurationGreaterThanOrEquals",
  /** DurationGreaterThan */
  DURATION_GREATER_THAN = "DurationGreaterThan",
  /** DurationLessThanOrEquals */
  DURATION_LESS_THAN_OR_EQUALS = "DurationLessThanOrEquals",
  /** DurationLessThan */
  DURATION_LESS_THAN = "DurationLessThan",
}

/**
 * Operator is the conditional operation to perform. Valid operators are:
 * Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
 * GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
 * DurationLessThanOrEquals, DurationLessThan
 *
 * @schema ClusterPolicySpecRulesMutateForeachPreconditionsAnyOperator
 */
export enum ClusterPolicySpecRulesMutateForeachPreconditionsAnyOperator {
  /** Equals */
  EQUALS = "Equals",
  /** NotEquals */
  NOT_EQUALS = "NotEquals",
  /** In */
  IN = "In",
  /** AnyIn */
  ANY_IN = "AnyIn",
  /** AllIn */
  ALL_IN = "AllIn",
  /** NotIn */
  NOT_IN = "NotIn",
  /** AnyNotIn */
  ANY_NOT_IN = "AnyNotIn",
  /** AllNotIn */
  ALL_NOT_IN = "AllNotIn",
  /** GreaterThanOrEquals */
  GREATER_THAN_OR_EQUALS = "GreaterThanOrEquals",
  /** GreaterThan */
  GREATER_THAN = "GreaterThan",
  /** LessThanOrEquals */
  LESS_THAN_OR_EQUALS = "LessThanOrEquals",
  /** LessThan */
  LESS_THAN = "LessThan",
  /** DurationGreaterThanOrEquals */
  DURATION_GREATER_THAN_OR_EQUALS = "DurationGreaterThanOrEquals",
  /** DurationGreaterThan */
  DURATION_GREATER_THAN = "DurationGreaterThan",
  /** DurationLessThanOrEquals */
  DURATION_LESS_THAN_OR_EQUALS = "DurationLessThanOrEquals",
  /** DurationLessThan */
  DURATION_LESS_THAN = "DurationLessThan",
}

/**
 * RequestData contains the HTTP POST data
 *
 * @schema ClusterPolicySpecRulesMutateTargetsContextApiCallData
 */
export interface ClusterPolicySpecRulesMutateTargetsContextApiCallData {
  /**
   * Key is a unique identifier for the data value
   *
   * @schema ClusterPolicySpecRulesMutateTargetsContextApiCallData#key
   */
  readonly key: string;

  /**
   * Value is the data value
   *
   * @schema ClusterPolicySpecRulesMutateTargetsContextApiCallData#value
   */
  readonly value: any;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMutateTargetsContextApiCallData' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMutateTargetsContextApiCallData(obj: ClusterPolicySpecRulesMutateTargetsContextApiCallData | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Method is the HTTP request type (GET or POST). Defaults to GET.
 *
 * @default GET.
 * @schema ClusterPolicySpecRulesMutateTargetsContextApiCallMethod
 */
export enum ClusterPolicySpecRulesMutateTargetsContextApiCallMethod {
  /** GET */
  GET = "GET",
  /** POST */
  POST = "POST",
}

/**
 * Service is an API call to a JSON web service.
 * This is used for non-Kubernetes API server calls.
 * It's mutually exclusive with the URLPath field.
 *
 * @schema ClusterPolicySpecRulesMutateTargetsContextApiCallService
 */
export interface ClusterPolicySpecRulesMutateTargetsContextApiCallService {
  /**
   * CABundle is a PEM encoded CA bundle which will be used to validate
   * the server certificate.
   *
   * @schema ClusterPolicySpecRulesMutateTargetsContextApiCallService#caBundle
   */
  readonly caBundle?: string;

  /**
   * Headers is a list of optional HTTP headers to be included in the request.
   *
   * @schema ClusterPolicySpecRulesMutateTargetsContextApiCallService#headers
   */
  readonly headers?: ClusterPolicySpecRulesMutateTargetsContextApiCallServiceHeaders[];

  /**
   * URL is the JSON web service URL. A typical form is
   * `https://{service}.{namespace}:{port}/{path}`.
   *
   * @schema ClusterPolicySpecRulesMutateTargetsContextApiCallService#url
   */
  readonly url: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMutateTargetsContextApiCallService' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMutateTargetsContextApiCallService(obj: ClusterPolicySpecRulesMutateTargetsContextApiCallService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caBundle': obj.caBundle,
    'headers': obj.headers?.map(y => toJson_ClusterPolicySpecRulesMutateTargetsContextApiCallServiceHeaders(y)),
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ImageRegistryCredentials provides credentials that will be used for authentication with registry
 *
 * @schema ClusterPolicySpecRulesMutateTargetsContextImageRegistryImageRegistryCredentials
 */
export interface ClusterPolicySpecRulesMutateTargetsContextImageRegistryImageRegistryCredentials {
  /**
   * AllowInsecureRegistry allows insecure access to a registry.
   *
   * @schema ClusterPolicySpecRulesMutateTargetsContextImageRegistryImageRegistryCredentials#allowInsecureRegistry
   */
  readonly allowInsecureRegistry?: boolean;

  /**
   * Providers specifies a list of OCI Registry names, whose authentication providers are provided.
   * It can be of one of these values: default,google,azure,amazon,github.
   *
   * @schema ClusterPolicySpecRulesMutateTargetsContextImageRegistryImageRegistryCredentials#providers
   */
  readonly providers?: ClusterPolicySpecRulesMutateTargetsContextImageRegistryImageRegistryCredentialsProviders[];

  /**
   * Secrets specifies a list of secrets that are provided for credentials.
   * Secrets must live in the Kyverno namespace.
   *
   * @schema ClusterPolicySpecRulesMutateTargetsContextImageRegistryImageRegistryCredentials#secrets
   */
  readonly secrets?: string[];

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMutateTargetsContextImageRegistryImageRegistryCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMutateTargetsContextImageRegistryImageRegistryCredentials(obj: ClusterPolicySpecRulesMutateTargetsContextImageRegistryImageRegistryCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowInsecureRegistry': obj.allowInsecureRegistry,
    'providers': obj.providers?.map(y => y),
    'secrets': obj.secrets?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterPolicySpecRulesValidateCelParamRefSelectorMatchExpressions
 */
export interface ClusterPolicySpecRulesValidateCelParamRefSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterPolicySpecRulesValidateCelParamRefSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterPolicySpecRulesValidateCelParamRefSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterPolicySpecRulesValidateCelParamRefSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesValidateCelParamRefSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesValidateCelParamRefSelectorMatchExpressions(obj: ClusterPolicySpecRulesValidateCelParamRefSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RequestData contains the HTTP POST data
 *
 * @schema ClusterPolicySpecRulesValidateForeachContextApiCallData
 */
export interface ClusterPolicySpecRulesValidateForeachContextApiCallData {
  /**
   * Key is a unique identifier for the data value
   *
   * @schema ClusterPolicySpecRulesValidateForeachContextApiCallData#key
   */
  readonly key: string;

  /**
   * Value is the data value
   *
   * @schema ClusterPolicySpecRulesValidateForeachContextApiCallData#value
   */
  readonly value: any;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesValidateForeachContextApiCallData' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesValidateForeachContextApiCallData(obj: ClusterPolicySpecRulesValidateForeachContextApiCallData | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Method is the HTTP request type (GET or POST). Defaults to GET.
 *
 * @default GET.
 * @schema ClusterPolicySpecRulesValidateForeachContextApiCallMethod
 */
export enum ClusterPolicySpecRulesValidateForeachContextApiCallMethod {
  /** GET */
  GET = "GET",
  /** POST */
  POST = "POST",
}

/**
 * Service is an API call to a JSON web service.
 * This is used for non-Kubernetes API server calls.
 * It's mutually exclusive with the URLPath field.
 *
 * @schema ClusterPolicySpecRulesValidateForeachContextApiCallService
 */
export interface ClusterPolicySpecRulesValidateForeachContextApiCallService {
  /**
   * CABundle is a PEM encoded CA bundle which will be used to validate
   * the server certificate.
   *
   * @schema ClusterPolicySpecRulesValidateForeachContextApiCallService#caBundle
   */
  readonly caBundle?: string;

  /**
   * Headers is a list of optional HTTP headers to be included in the request.
   *
   * @schema ClusterPolicySpecRulesValidateForeachContextApiCallService#headers
   */
  readonly headers?: ClusterPolicySpecRulesValidateForeachContextApiCallServiceHeaders[];

  /**
   * URL is the JSON web service URL. A typical form is
   * `https://{service}.{namespace}:{port}/{path}`.
   *
   * @schema ClusterPolicySpecRulesValidateForeachContextApiCallService#url
   */
  readonly url: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesValidateForeachContextApiCallService' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesValidateForeachContextApiCallService(obj: ClusterPolicySpecRulesValidateForeachContextApiCallService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caBundle': obj.caBundle,
    'headers': obj.headers?.map(y => toJson_ClusterPolicySpecRulesValidateForeachContextApiCallServiceHeaders(y)),
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ImageRegistryCredentials provides credentials that will be used for authentication with registry
 *
 * @schema ClusterPolicySpecRulesValidateForeachContextImageRegistryImageRegistryCredentials
 */
export interface ClusterPolicySpecRulesValidateForeachContextImageRegistryImageRegistryCredentials {
  /**
   * AllowInsecureRegistry allows insecure access to a registry.
   *
   * @schema ClusterPolicySpecRulesValidateForeachContextImageRegistryImageRegistryCredentials#allowInsecureRegistry
   */
  readonly allowInsecureRegistry?: boolean;

  /**
   * Providers specifies a list of OCI Registry names, whose authentication providers are provided.
   * It can be of one of these values: default,google,azure,amazon,github.
   *
   * @schema ClusterPolicySpecRulesValidateForeachContextImageRegistryImageRegistryCredentials#providers
   */
  readonly providers?: ClusterPolicySpecRulesValidateForeachContextImageRegistryImageRegistryCredentialsProviders[];

  /**
   * Secrets specifies a list of secrets that are provided for credentials.
   * Secrets must live in the Kyverno namespace.
   *
   * @schema ClusterPolicySpecRulesValidateForeachContextImageRegistryImageRegistryCredentials#secrets
   */
  readonly secrets?: string[];

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesValidateForeachContextImageRegistryImageRegistryCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesValidateForeachContextImageRegistryImageRegistryCredentials(obj: ClusterPolicySpecRulesValidateForeachContextImageRegistryImageRegistryCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowInsecureRegistry': obj.allowInsecureRegistry,
    'providers': obj.providers?.map(y => y),
    'secrets': obj.secrets?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Operator is the conditional operation to perform. Valid operators are:
 * Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
 * GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
 * DurationLessThanOrEquals, DurationLessThan
 *
 * @schema ClusterPolicySpecRulesValidateForeachPreconditionsAllOperator
 */
export enum ClusterPolicySpecRulesValidateForeachPreconditionsAllOperator {
  /** Equals */
  EQUALS = "Equals",
  /** NotEquals */
  NOT_EQUALS = "NotEquals",
  /** In */
  IN = "In",
  /** AnyIn */
  ANY_IN = "AnyIn",
  /** AllIn */
  ALL_IN = "AllIn",
  /** NotIn */
  NOT_IN = "NotIn",
  /** AnyNotIn */
  ANY_NOT_IN = "AnyNotIn",
  /** AllNotIn */
  ALL_NOT_IN = "AllNotIn",
  /** GreaterThanOrEquals */
  GREATER_THAN_OR_EQUALS = "GreaterThanOrEquals",
  /** GreaterThan */
  GREATER_THAN = "GreaterThan",
  /** LessThanOrEquals */
  LESS_THAN_OR_EQUALS = "LessThanOrEquals",
  /** LessThan */
  LESS_THAN = "LessThan",
  /** DurationGreaterThanOrEquals */
  DURATION_GREATER_THAN_OR_EQUALS = "DurationGreaterThanOrEquals",
  /** DurationGreaterThan */
  DURATION_GREATER_THAN = "DurationGreaterThan",
  /** DurationLessThanOrEquals */
  DURATION_LESS_THAN_OR_EQUALS = "DurationLessThanOrEquals",
  /** DurationLessThan */
  DURATION_LESS_THAN = "DurationLessThan",
}

/**
 * Operator is the conditional operation to perform. Valid operators are:
 * Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
 * GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
 * DurationLessThanOrEquals, DurationLessThan
 *
 * @schema ClusterPolicySpecRulesValidateForeachPreconditionsAnyOperator
 */
export enum ClusterPolicySpecRulesValidateForeachPreconditionsAnyOperator {
  /** Equals */
  EQUALS = "Equals",
  /** NotEquals */
  NOT_EQUALS = "NotEquals",
  /** In */
  IN = "In",
  /** AnyIn */
  ANY_IN = "AnyIn",
  /** AllIn */
  ALL_IN = "AllIn",
  /** NotIn */
  NOT_IN = "NotIn",
  /** AnyNotIn */
  ANY_NOT_IN = "AnyNotIn",
  /** AllNotIn */
  ALL_NOT_IN = "AllNotIn",
  /** GreaterThanOrEquals */
  GREATER_THAN_OR_EQUALS = "GreaterThanOrEquals",
  /** GreaterThan */
  GREATER_THAN = "GreaterThan",
  /** LessThanOrEquals */
  LESS_THAN_OR_EQUALS = "LessThanOrEquals",
  /** LessThan */
  LESS_THAN = "LessThan",
  /** DurationGreaterThanOrEquals */
  DURATION_GREATER_THAN_OR_EQUALS = "DurationGreaterThanOrEquals",
  /** DurationGreaterThan */
  DURATION_GREATER_THAN = "DurationGreaterThan",
  /** DurationLessThanOrEquals */
  DURATION_LESS_THAN_OR_EQUALS = "DurationLessThanOrEquals",
  /** DurationLessThan */
  DURATION_LESS_THAN = "DurationLessThan",
}

/**
 * Certificates specifies one or more certificates.
 *
 * @schema ClusterPolicySpecRulesValidateManifestsAttestorsEntriesCertificates
 */
export interface ClusterPolicySpecRulesValidateManifestsAttestorsEntriesCertificates {
  /**
   * Cert is an optional PEM-encoded public certificate.
   *
   * @schema ClusterPolicySpecRulesValidateManifestsAttestorsEntriesCertificates#cert
   */
  readonly cert?: string;

  /**
   * CertChain is an optional PEM encoded set of certificates used to verify.
   *
   * @schema ClusterPolicySpecRulesValidateManifestsAttestorsEntriesCertificates#certChain
   */
  readonly certChain?: string;

  /**
   * CTLog (certificate timestamp log) provides a configuration for validation of Signed Certificate
   * Timestamps (SCTs). If the value is unset, the default behavior by Cosign is used.
   *
   * @schema ClusterPolicySpecRulesValidateManifestsAttestorsEntriesCertificates#ctlog
   */
  readonly ctlog?: ClusterPolicySpecRulesValidateManifestsAttestorsEntriesCertificatesCtlog;

  /**
   * Rekor provides configuration for the Rekor transparency log service. If an empty object
   * is provided the public instance of Rekor (https://rekor.sigstore.dev) is used.
   *
   * @schema ClusterPolicySpecRulesValidateManifestsAttestorsEntriesCertificates#rekor
   */
  readonly rekor?: ClusterPolicySpecRulesValidateManifestsAttestorsEntriesCertificatesRekor;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesValidateManifestsAttestorsEntriesCertificates' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesValidateManifestsAttestorsEntriesCertificates(obj: ClusterPolicySpecRulesValidateManifestsAttestorsEntriesCertificates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cert': obj.cert,
    'certChain': obj.certChain,
    'ctlog': toJson_ClusterPolicySpecRulesValidateManifestsAttestorsEntriesCertificatesCtlog(obj.ctlog),
    'rekor': toJson_ClusterPolicySpecRulesValidateManifestsAttestorsEntriesCertificatesRekor(obj.rekor),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Keyless is a set of attribute used to verify a Sigstore keyless attestor.
 * See https://github.com/sigstore/cosign/blob/main/KEYLESS.md.
 *
 * @schema ClusterPolicySpecRulesValidateManifestsAttestorsEntriesKeyless
 */
export interface ClusterPolicySpecRulesValidateManifestsAttestorsEntriesKeyless {
  /**
   * AdditionalExtensions are certificate-extensions used for keyless signing.
   *
   * @schema ClusterPolicySpecRulesValidateManifestsAttestorsEntriesKeyless#additionalExtensions
   */
  readonly additionalExtensions?: { [key: string]: string };

  /**
   * CTLog (certificate timestamp log) provides a configuration for validation of Signed Certificate
   * Timestamps (SCTs). If the value is unset, the default behavior by Cosign is used.
   *
   * @schema ClusterPolicySpecRulesValidateManifestsAttestorsEntriesKeyless#ctlog
   */
  readonly ctlog?: ClusterPolicySpecRulesValidateManifestsAttestorsEntriesKeylessCtlog;

  /**
   * Issuer is the certificate issuer used for keyless signing.
   *
   * @schema ClusterPolicySpecRulesValidateManifestsAttestorsEntriesKeyless#issuer
   */
  readonly issuer?: string;

  /**
   * IssuerRegExp is the regular expression to match certificate issuer used for keyless signing.
   *
   * @schema ClusterPolicySpecRulesValidateManifestsAttestorsEntriesKeyless#issuerRegExp
   */
  readonly issuerRegExp?: string;

  /**
   * Rekor provides configuration for the Rekor transparency log service. If an empty object
   * is provided the public instance of Rekor (https://rekor.sigstore.dev) is used.
   *
   * @schema ClusterPolicySpecRulesValidateManifestsAttestorsEntriesKeyless#rekor
   */
  readonly rekor?: ClusterPolicySpecRulesValidateManifestsAttestorsEntriesKeylessRekor;

  /**
   * Roots is an optional set of PEM encoded trusted root certificates.
   * If not provided, the system roots are used.
   *
   * @schema ClusterPolicySpecRulesValidateManifestsAttestorsEntriesKeyless#roots
   */
  readonly roots?: string;

  /**
   * Subject is the verified identity used for keyless signing, for example the email address.
   *
   * @schema ClusterPolicySpecRulesValidateManifestsAttestorsEntriesKeyless#subject
   */
  readonly subject?: string;

  /**
   * SubjectRegExp is the regular expression to match identity used for keyless signing, for example the email address.
   *
   * @schema ClusterPolicySpecRulesValidateManifestsAttestorsEntriesKeyless#subjectRegExp
   */
  readonly subjectRegExp?: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesValidateManifestsAttestorsEntriesKeyless' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesValidateManifestsAttestorsEntriesKeyless(obj: ClusterPolicySpecRulesValidateManifestsAttestorsEntriesKeyless | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalExtensions': ((obj.additionalExtensions) === undefined) ? undefined : (Object.entries(obj.additionalExtensions).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'ctlog': toJson_ClusterPolicySpecRulesValidateManifestsAttestorsEntriesKeylessCtlog(obj.ctlog),
    'issuer': obj.issuer,
    'issuerRegExp': obj.issuerRegExp,
    'rekor': toJson_ClusterPolicySpecRulesValidateManifestsAttestorsEntriesKeylessRekor(obj.rekor),
    'roots': obj.roots,
    'subject': obj.subject,
    'subjectRegExp': obj.subjectRegExp,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Keys specifies one or more public keys.
 *
 * @schema ClusterPolicySpecRulesValidateManifestsAttestorsEntriesKeys
 */
export interface ClusterPolicySpecRulesValidateManifestsAttestorsEntriesKeys {
  /**
   * CTLog (certificate timestamp log) provides a configuration for validation of Signed Certificate
   * Timestamps (SCTs). If the value is unset, the default behavior by Cosign is used.
   *
   * @schema ClusterPolicySpecRulesValidateManifestsAttestorsEntriesKeys#ctlog
   */
  readonly ctlog?: ClusterPolicySpecRulesValidateManifestsAttestorsEntriesKeysCtlog;

  /**
   * KMS provides the URI to the public key stored in a Key Management System. See:
   * https://github.com/sigstore/cosign/blob/main/KMS.md
   *
   * @schema ClusterPolicySpecRulesValidateManifestsAttestorsEntriesKeys#kms
   */
  readonly kms?: string;

  /**
   * Keys is a set of X.509 public keys used to verify image signatures. The keys can be directly
   * specified or can be a variable reference to a key specified in a ConfigMap (see
   * https://kyverno.io/docs/writing-policies/variables/), or reference a standard Kubernetes Secret
   * elsewhere in the cluster by specifying it in the format "k8s://<namespace>/<secret_name>".
   * The named Secret must specify a key `cosign.pub` containing the public key used for
   * verification, (see https://github.com/sigstore/cosign/blob/main/KMS.md#kubernetes-secret).
   * When multiple keys are specified each key is processed as a separate staticKey entry
   * (.attestors[*].entries.keys) within the set of attestors and the count is applied across the keys.
   *
   * @schema ClusterPolicySpecRulesValidateManifestsAttestorsEntriesKeys#publicKeys
   */
  readonly publicKeys?: string;

  /**
   * Rekor provides configuration for the Rekor transparency log service. If an empty object
   * is provided the public instance of Rekor (https://rekor.sigstore.dev) is used.
   *
   * @schema ClusterPolicySpecRulesValidateManifestsAttestorsEntriesKeys#rekor
   */
  readonly rekor?: ClusterPolicySpecRulesValidateManifestsAttestorsEntriesKeysRekor;

  /**
   * Reference to a Secret resource that contains a public key
   *
   * @schema ClusterPolicySpecRulesValidateManifestsAttestorsEntriesKeys#secret
   */
  readonly secret?: ClusterPolicySpecRulesValidateManifestsAttestorsEntriesKeysSecret;

  /**
   * Deprecated. Use attestor.signatureAlgorithm instead.
   *
   * @schema ClusterPolicySpecRulesValidateManifestsAttestorsEntriesKeys#signatureAlgorithm
   */
  readonly signatureAlgorithm?: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesValidateManifestsAttestorsEntriesKeys' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesValidateManifestsAttestorsEntriesKeys(obj: ClusterPolicySpecRulesValidateManifestsAttestorsEntriesKeys | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ctlog': toJson_ClusterPolicySpecRulesValidateManifestsAttestorsEntriesKeysCtlog(obj.ctlog),
    'kms': obj.kms,
    'publicKeys': obj.publicKeys,
    'rekor': toJson_ClusterPolicySpecRulesValidateManifestsAttestorsEntriesKeysRekor(obj.rekor),
    'secret': toJson_ClusterPolicySpecRulesValidateManifestsAttestorsEntriesKeysSecret(obj.secret),
    'signatureAlgorithm': obj.signatureAlgorithm,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Certificates specifies one or more certificates.
 *
 * @schema ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesCertificates
 */
export interface ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesCertificates {
  /**
   * Cert is an optional PEM-encoded public certificate.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesCertificates#cert
   */
  readonly cert?: string;

  /**
   * CertChain is an optional PEM encoded set of certificates used to verify.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesCertificates#certChain
   */
  readonly certChain?: string;

  /**
   * CTLog (certificate timestamp log) provides a configuration for validation of Signed Certificate
   * Timestamps (SCTs). If the value is unset, the default behavior by Cosign is used.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesCertificates#ctlog
   */
  readonly ctlog?: ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesCertificatesCtlog;

  /**
   * Rekor provides configuration for the Rekor transparency log service. If an empty object
   * is provided the public instance of Rekor (https://rekor.sigstore.dev) is used.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesCertificates#rekor
   */
  readonly rekor?: ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesCertificatesRekor;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesCertificates' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesCertificates(obj: ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesCertificates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cert': obj.cert,
    'certChain': obj.certChain,
    'ctlog': toJson_ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesCertificatesCtlog(obj.ctlog),
    'rekor': toJson_ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesCertificatesRekor(obj.rekor),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Keyless is a set of attribute used to verify a Sigstore keyless attestor.
 * See https://github.com/sigstore/cosign/blob/main/KEYLESS.md.
 *
 * @schema ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesKeyless
 */
export interface ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesKeyless {
  /**
   * AdditionalExtensions are certificate-extensions used for keyless signing.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesKeyless#additionalExtensions
   */
  readonly additionalExtensions?: { [key: string]: string };

  /**
   * CTLog (certificate timestamp log) provides a configuration for validation of Signed Certificate
   * Timestamps (SCTs). If the value is unset, the default behavior by Cosign is used.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesKeyless#ctlog
   */
  readonly ctlog?: ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesKeylessCtlog;

  /**
   * Issuer is the certificate issuer used for keyless signing.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesKeyless#issuer
   */
  readonly issuer?: string;

  /**
   * IssuerRegExp is the regular expression to match certificate issuer used for keyless signing.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesKeyless#issuerRegExp
   */
  readonly issuerRegExp?: string;

  /**
   * Rekor provides configuration for the Rekor transparency log service. If an empty object
   * is provided the public instance of Rekor (https://rekor.sigstore.dev) is used.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesKeyless#rekor
   */
  readonly rekor?: ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesKeylessRekor;

  /**
   * Roots is an optional set of PEM encoded trusted root certificates.
   * If not provided, the system roots are used.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesKeyless#roots
   */
  readonly roots?: string;

  /**
   * Subject is the verified identity used for keyless signing, for example the email address.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesKeyless#subject
   */
  readonly subject?: string;

  /**
   * SubjectRegExp is the regular expression to match identity used for keyless signing, for example the email address.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesKeyless#subjectRegExp
   */
  readonly subjectRegExp?: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesKeyless' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesKeyless(obj: ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesKeyless | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalExtensions': ((obj.additionalExtensions) === undefined) ? undefined : (Object.entries(obj.additionalExtensions).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'ctlog': toJson_ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesKeylessCtlog(obj.ctlog),
    'issuer': obj.issuer,
    'issuerRegExp': obj.issuerRegExp,
    'rekor': toJson_ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesKeylessRekor(obj.rekor),
    'roots': obj.roots,
    'subject': obj.subject,
    'subjectRegExp': obj.subjectRegExp,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Keys specifies one or more public keys.
 *
 * @schema ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesKeys
 */
export interface ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesKeys {
  /**
   * CTLog (certificate timestamp log) provides a configuration for validation of Signed Certificate
   * Timestamps (SCTs). If the value is unset, the default behavior by Cosign is used.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesKeys#ctlog
   */
  readonly ctlog?: ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesKeysCtlog;

  /**
   * KMS provides the URI to the public key stored in a Key Management System. See:
   * https://github.com/sigstore/cosign/blob/main/KMS.md
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesKeys#kms
   */
  readonly kms?: string;

  /**
   * Keys is a set of X.509 public keys used to verify image signatures. The keys can be directly
   * specified or can be a variable reference to a key specified in a ConfigMap (see
   * https://kyverno.io/docs/writing-policies/variables/), or reference a standard Kubernetes Secret
   * elsewhere in the cluster by specifying it in the format "k8s://<namespace>/<secret_name>".
   * The named Secret must specify a key `cosign.pub` containing the public key used for
   * verification, (see https://github.com/sigstore/cosign/blob/main/KMS.md#kubernetes-secret).
   * When multiple keys are specified each key is processed as a separate staticKey entry
   * (.attestors[*].entries.keys) within the set of attestors and the count is applied across the keys.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesKeys#publicKeys
   */
  readonly publicKeys?: string;

  /**
   * Rekor provides configuration for the Rekor transparency log service. If an empty object
   * is provided the public instance of Rekor (https://rekor.sigstore.dev) is used.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesKeys#rekor
   */
  readonly rekor?: ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesKeysRekor;

  /**
   * Reference to a Secret resource that contains a public key
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesKeys#secret
   */
  readonly secret?: ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesKeysSecret;

  /**
   * Deprecated. Use attestor.signatureAlgorithm instead.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesKeys#signatureAlgorithm
   */
  readonly signatureAlgorithm?: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesKeys' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesKeys(obj: ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesKeys | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ctlog': toJson_ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesKeysCtlog(obj.ctlog),
    'kms': obj.kms,
    'publicKeys': obj.publicKeys,
    'rekor': toJson_ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesKeysRekor(obj.rekor),
    'secret': toJson_ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesKeysSecret(obj.secret),
    'signatureAlgorithm': obj.signatureAlgorithm,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Operator is the conditional operation to perform. Valid operators are:
 * Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
 * GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
 * DurationLessThanOrEquals, DurationLessThan
 *
 * @schema ClusterPolicySpecRulesVerifyImagesAttestationsConditionsAllOperator
 */
export enum ClusterPolicySpecRulesVerifyImagesAttestationsConditionsAllOperator {
  /** Equals */
  EQUALS = "Equals",
  /** NotEquals */
  NOT_EQUALS = "NotEquals",
  /** In */
  IN = "In",
  /** AnyIn */
  ANY_IN = "AnyIn",
  /** AllIn */
  ALL_IN = "AllIn",
  /** NotIn */
  NOT_IN = "NotIn",
  /** AnyNotIn */
  ANY_NOT_IN = "AnyNotIn",
  /** AllNotIn */
  ALL_NOT_IN = "AllNotIn",
  /** GreaterThanOrEquals */
  GREATER_THAN_OR_EQUALS = "GreaterThanOrEquals",
  /** GreaterThan */
  GREATER_THAN = "GreaterThan",
  /** LessThanOrEquals */
  LESS_THAN_OR_EQUALS = "LessThanOrEquals",
  /** LessThan */
  LESS_THAN = "LessThan",
  /** DurationGreaterThanOrEquals */
  DURATION_GREATER_THAN_OR_EQUALS = "DurationGreaterThanOrEquals",
  /** DurationGreaterThan */
  DURATION_GREATER_THAN = "DurationGreaterThan",
  /** DurationLessThanOrEquals */
  DURATION_LESS_THAN_OR_EQUALS = "DurationLessThanOrEquals",
  /** DurationLessThan */
  DURATION_LESS_THAN = "DurationLessThan",
}

/**
 * Operator is the conditional operation to perform. Valid operators are:
 * Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
 * GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
 * DurationLessThanOrEquals, DurationLessThan
 *
 * @schema ClusterPolicySpecRulesVerifyImagesAttestationsConditionsAnyOperator
 */
export enum ClusterPolicySpecRulesVerifyImagesAttestationsConditionsAnyOperator {
  /** Equals */
  EQUALS = "Equals",
  /** NotEquals */
  NOT_EQUALS = "NotEquals",
  /** In */
  IN = "In",
  /** AnyIn */
  ANY_IN = "AnyIn",
  /** AllIn */
  ALL_IN = "AllIn",
  /** NotIn */
  NOT_IN = "NotIn",
  /** AnyNotIn */
  ANY_NOT_IN = "AnyNotIn",
  /** AllNotIn */
  ALL_NOT_IN = "AllNotIn",
  /** GreaterThanOrEquals */
  GREATER_THAN_OR_EQUALS = "GreaterThanOrEquals",
  /** GreaterThan */
  GREATER_THAN = "GreaterThan",
  /** LessThanOrEquals */
  LESS_THAN_OR_EQUALS = "LessThanOrEquals",
  /** LessThan */
  LESS_THAN = "LessThan",
  /** DurationGreaterThanOrEquals */
  DURATION_GREATER_THAN_OR_EQUALS = "DurationGreaterThanOrEquals",
  /** DurationGreaterThan */
  DURATION_GREATER_THAN = "DurationGreaterThan",
  /** DurationLessThanOrEquals */
  DURATION_LESS_THAN_OR_EQUALS = "DurationLessThanOrEquals",
  /** DurationLessThan */
  DURATION_LESS_THAN = "DurationLessThan",
}

/**
 * CTLog (certificate timestamp log) provides a configuration for validation of Signed Certificate
 * Timestamps (SCTs). If the value is unset, the default behavior by Cosign is used.
 *
 * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntriesCertificatesCtlog
 */
export interface ClusterPolicySpecRulesVerifyImagesAttestorsEntriesCertificatesCtlog {
  /**
   * IgnoreSCT defines whether to use the Signed Certificate Timestamp (SCT) log to check for a certificate
   * timestamp. Default is false. Set to true if this was opted out during signing.
   *
   * @default false. Set to true if this was opted out during signing.
   * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntriesCertificatesCtlog#ignoreSCT
   */
  readonly ignoreSct?: boolean;

  /**
   * PubKey, if set, is used to validate SCTs against a custom source.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntriesCertificatesCtlog#pubkey
   */
  readonly pubkey?: string;

  /**
   * TSACertChain, if set, is the PEM-encoded certificate chain file for the RFC3161 timestamp authority. Must
   * contain the root CA certificate. Optionally may contain intermediate CA certificates, and
   * may contain the leaf TSA certificate if not present in the timestamurce.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntriesCertificatesCtlog#tsaCertChain
   */
  readonly tsaCertChain?: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesVerifyImagesAttestorsEntriesCertificatesCtlog' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesVerifyImagesAttestorsEntriesCertificatesCtlog(obj: ClusterPolicySpecRulesVerifyImagesAttestorsEntriesCertificatesCtlog | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ignoreSCT': obj.ignoreSct,
    'pubkey': obj.pubkey,
    'tsaCertChain': obj.tsaCertChain,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Rekor provides configuration for the Rekor transparency log service. If an empty object
 * is provided the public instance of Rekor (https://rekor.sigstore.dev) is used.
 *
 * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntriesCertificatesRekor
 */
export interface ClusterPolicySpecRulesVerifyImagesAttestorsEntriesCertificatesRekor {
  /**
   * IgnoreTlog skips transparency log verification.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntriesCertificatesRekor#ignoreTlog
   */
  readonly ignoreTlog?: boolean;

  /**
   * RekorPubKey is an optional PEM-encoded public key to use for a custom Rekor.
   * If set, this will be used to validate transparency log signatures from a custom Rekor.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntriesCertificatesRekor#pubkey
   */
  readonly pubkey?: string;

  /**
   * URL is the address of the transparency log. Defaults to the public Rekor log instance https://rekor.sigstore.dev.
   *
   * @default the public Rekor log instance https://rekor.sigstore.dev.
   * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntriesCertificatesRekor#url
   */
  readonly url?: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesVerifyImagesAttestorsEntriesCertificatesRekor' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesVerifyImagesAttestorsEntriesCertificatesRekor(obj: ClusterPolicySpecRulesVerifyImagesAttestorsEntriesCertificatesRekor | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ignoreTlog': obj.ignoreTlog,
    'pubkey': obj.pubkey,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CTLog (certificate timestamp log) provides a configuration for validation of Signed Certificate
 * Timestamps (SCTs). If the value is unset, the default behavior by Cosign is used.
 *
 * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeylessCtlog
 */
export interface ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeylessCtlog {
  /**
   * IgnoreSCT defines whether to use the Signed Certificate Timestamp (SCT) log to check for a certificate
   * timestamp. Default is false. Set to true if this was opted out during signing.
   *
   * @default false. Set to true if this was opted out during signing.
   * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeylessCtlog#ignoreSCT
   */
  readonly ignoreSct?: boolean;

  /**
   * PubKey, if set, is used to validate SCTs against a custom source.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeylessCtlog#pubkey
   */
  readonly pubkey?: string;

  /**
   * TSACertChain, if set, is the PEM-encoded certificate chain file for the RFC3161 timestamp authority. Must
   * contain the root CA certificate. Optionally may contain intermediate CA certificates, and
   * may contain the leaf TSA certificate if not present in the timestamurce.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeylessCtlog#tsaCertChain
   */
  readonly tsaCertChain?: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeylessCtlog' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeylessCtlog(obj: ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeylessCtlog | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ignoreSCT': obj.ignoreSct,
    'pubkey': obj.pubkey,
    'tsaCertChain': obj.tsaCertChain,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Rekor provides configuration for the Rekor transparency log service. If an empty object
 * is provided the public instance of Rekor (https://rekor.sigstore.dev) is used.
 *
 * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeylessRekor
 */
export interface ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeylessRekor {
  /**
   * IgnoreTlog skips transparency log verification.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeylessRekor#ignoreTlog
   */
  readonly ignoreTlog?: boolean;

  /**
   * RekorPubKey is an optional PEM-encoded public key to use for a custom Rekor.
   * If set, this will be used to validate transparency log signatures from a custom Rekor.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeylessRekor#pubkey
   */
  readonly pubkey?: string;

  /**
   * URL is the address of the transparency log. Defaults to the public Rekor log instance https://rekor.sigstore.dev.
   *
   * @default the public Rekor log instance https://rekor.sigstore.dev.
   * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeylessRekor#url
   */
  readonly url?: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeylessRekor' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeylessRekor(obj: ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeylessRekor | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ignoreTlog': obj.ignoreTlog,
    'pubkey': obj.pubkey,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CTLog (certificate timestamp log) provides a configuration for validation of Signed Certificate
 * Timestamps (SCTs). If the value is unset, the default behavior by Cosign is used.
 *
 * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeysCtlog
 */
export interface ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeysCtlog {
  /**
   * IgnoreSCT defines whether to use the Signed Certificate Timestamp (SCT) log to check for a certificate
   * timestamp. Default is false. Set to true if this was opted out during signing.
   *
   * @default false. Set to true if this was opted out during signing.
   * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeysCtlog#ignoreSCT
   */
  readonly ignoreSct?: boolean;

  /**
   * PubKey, if set, is used to validate SCTs against a custom source.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeysCtlog#pubkey
   */
  readonly pubkey?: string;

  /**
   * TSACertChain, if set, is the PEM-encoded certificate chain file for the RFC3161 timestamp authority. Must
   * contain the root CA certificate. Optionally may contain intermediate CA certificates, and
   * may contain the leaf TSA certificate if not present in the timestamurce.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeysCtlog#tsaCertChain
   */
  readonly tsaCertChain?: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeysCtlog' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeysCtlog(obj: ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeysCtlog | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ignoreSCT': obj.ignoreSct,
    'pubkey': obj.pubkey,
    'tsaCertChain': obj.tsaCertChain,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Rekor provides configuration for the Rekor transparency log service. If an empty object
 * is provided the public instance of Rekor (https://rekor.sigstore.dev) is used.
 *
 * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeysRekor
 */
export interface ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeysRekor {
  /**
   * IgnoreTlog skips transparency log verification.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeysRekor#ignoreTlog
   */
  readonly ignoreTlog?: boolean;

  /**
   * RekorPubKey is an optional PEM-encoded public key to use for a custom Rekor.
   * If set, this will be used to validate transparency log signatures from a custom Rekor.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeysRekor#pubkey
   */
  readonly pubkey?: string;

  /**
   * URL is the address of the transparency log. Defaults to the public Rekor log instance https://rekor.sigstore.dev.
   *
   * @default the public Rekor log instance https://rekor.sigstore.dev.
   * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeysRekor#url
   */
  readonly url?: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeysRekor' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeysRekor(obj: ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeysRekor | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ignoreTlog': obj.ignoreTlog,
    'pubkey': obj.pubkey,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Secret resource that contains a public key
 *
 * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeysSecret
 */
export interface ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeysSecret {
  /**
   * Name of the secret. The provided secret must contain a key named cosign.pub.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeysSecret#name
   */
  readonly name: string;

  /**
   * Namespace name where the Secret exists.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeysSecret#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeysSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeysSecret(obj: ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeysSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterPolicySpecRulesGenerateForeachContextApiCallServiceHeaders
 */
export interface ClusterPolicySpecRulesGenerateForeachContextApiCallServiceHeaders {
  /**
   * Key is the header key
   *
   * @schema ClusterPolicySpecRulesGenerateForeachContextApiCallServiceHeaders#key
   */
  readonly key: string;

  /**
   * Value is the header value
   *
   * @schema ClusterPolicySpecRulesGenerateForeachContextApiCallServiceHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesGenerateForeachContextApiCallServiceHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesGenerateForeachContextApiCallServiceHeaders(obj: ClusterPolicySpecRulesGenerateForeachContextApiCallServiceHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ImageRegistryCredentialsProvidersType provides the list of credential providers required.
 *
 * @schema ClusterPolicySpecRulesGenerateForeachContextImageRegistryImageRegistryCredentialsProviders
 */
export enum ClusterPolicySpecRulesGenerateForeachContextImageRegistryImageRegistryCredentialsProviders {
  /** default */
  DEFAULT = "default",
  /** amazon */
  AMAZON = "amazon",
  /** azure */
  AZURE = "azure",
  /** google */
  GOOGLE = "google",
  /** github */
  GITHUB = "github",
}

/**
 * @schema ClusterPolicySpecRulesMutateForeachContextApiCallServiceHeaders
 */
export interface ClusterPolicySpecRulesMutateForeachContextApiCallServiceHeaders {
  /**
   * Key is the header key
   *
   * @schema ClusterPolicySpecRulesMutateForeachContextApiCallServiceHeaders#key
   */
  readonly key: string;

  /**
   * Value is the header value
   *
   * @schema ClusterPolicySpecRulesMutateForeachContextApiCallServiceHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMutateForeachContextApiCallServiceHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMutateForeachContextApiCallServiceHeaders(obj: ClusterPolicySpecRulesMutateForeachContextApiCallServiceHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ImageRegistryCredentialsProvidersType provides the list of credential providers required.
 *
 * @schema ClusterPolicySpecRulesMutateForeachContextImageRegistryImageRegistryCredentialsProviders
 */
export enum ClusterPolicySpecRulesMutateForeachContextImageRegistryImageRegistryCredentialsProviders {
  /** default */
  DEFAULT = "default",
  /** amazon */
  AMAZON = "amazon",
  /** azure */
  AZURE = "azure",
  /** google */
  GOOGLE = "google",
  /** github */
  GITHUB = "github",
}

/**
 * @schema ClusterPolicySpecRulesMutateTargetsContextApiCallServiceHeaders
 */
export interface ClusterPolicySpecRulesMutateTargetsContextApiCallServiceHeaders {
  /**
   * Key is the header key
   *
   * @schema ClusterPolicySpecRulesMutateTargetsContextApiCallServiceHeaders#key
   */
  readonly key: string;

  /**
   * Value is the header value
   *
   * @schema ClusterPolicySpecRulesMutateTargetsContextApiCallServiceHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMutateTargetsContextApiCallServiceHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMutateTargetsContextApiCallServiceHeaders(obj: ClusterPolicySpecRulesMutateTargetsContextApiCallServiceHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ImageRegistryCredentialsProvidersType provides the list of credential providers required.
 *
 * @schema ClusterPolicySpecRulesMutateTargetsContextImageRegistryImageRegistryCredentialsProviders
 */
export enum ClusterPolicySpecRulesMutateTargetsContextImageRegistryImageRegistryCredentialsProviders {
  /** default */
  DEFAULT = "default",
  /** amazon */
  AMAZON = "amazon",
  /** azure */
  AZURE = "azure",
  /** google */
  GOOGLE = "google",
  /** github */
  GITHUB = "github",
}

/**
 * @schema ClusterPolicySpecRulesValidateForeachContextApiCallServiceHeaders
 */
export interface ClusterPolicySpecRulesValidateForeachContextApiCallServiceHeaders {
  /**
   * Key is the header key
   *
   * @schema ClusterPolicySpecRulesValidateForeachContextApiCallServiceHeaders#key
   */
  readonly key: string;

  /**
   * Value is the header value
   *
   * @schema ClusterPolicySpecRulesValidateForeachContextApiCallServiceHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesValidateForeachContextApiCallServiceHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesValidateForeachContextApiCallServiceHeaders(obj: ClusterPolicySpecRulesValidateForeachContextApiCallServiceHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ImageRegistryCredentialsProvidersType provides the list of credential providers required.
 *
 * @schema ClusterPolicySpecRulesValidateForeachContextImageRegistryImageRegistryCredentialsProviders
 */
export enum ClusterPolicySpecRulesValidateForeachContextImageRegistryImageRegistryCredentialsProviders {
  /** default */
  DEFAULT = "default",
  /** amazon */
  AMAZON = "amazon",
  /** azure */
  AZURE = "azure",
  /** google */
  GOOGLE = "google",
  /** github */
  GITHUB = "github",
}

/**
 * CTLog (certificate timestamp log) provides a configuration for validation of Signed Certificate
 * Timestamps (SCTs). If the value is unset, the default behavior by Cosign is used.
 *
 * @schema ClusterPolicySpecRulesValidateManifestsAttestorsEntriesCertificatesCtlog
 */
export interface ClusterPolicySpecRulesValidateManifestsAttestorsEntriesCertificatesCtlog {
  /**
   * IgnoreSCT defines whether to use the Signed Certificate Timestamp (SCT) log to check for a certificate
   * timestamp. Default is false. Set to true if this was opted out during signing.
   *
   * @default false. Set to true if this was opted out during signing.
   * @schema ClusterPolicySpecRulesValidateManifestsAttestorsEntriesCertificatesCtlog#ignoreSCT
   */
  readonly ignoreSct?: boolean;

  /**
   * PubKey, if set, is used to validate SCTs against a custom source.
   *
   * @schema ClusterPolicySpecRulesValidateManifestsAttestorsEntriesCertificatesCtlog#pubkey
   */
  readonly pubkey?: string;

  /**
   * TSACertChain, if set, is the PEM-encoded certificate chain file for the RFC3161 timestamp authority. Must
   * contain the root CA certificate. Optionally may contain intermediate CA certificates, and
   * may contain the leaf TSA certificate if not present in the timestamurce.
   *
   * @schema ClusterPolicySpecRulesValidateManifestsAttestorsEntriesCertificatesCtlog#tsaCertChain
   */
  readonly tsaCertChain?: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesValidateManifestsAttestorsEntriesCertificatesCtlog' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesValidateManifestsAttestorsEntriesCertificatesCtlog(obj: ClusterPolicySpecRulesValidateManifestsAttestorsEntriesCertificatesCtlog | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ignoreSCT': obj.ignoreSct,
    'pubkey': obj.pubkey,
    'tsaCertChain': obj.tsaCertChain,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Rekor provides configuration for the Rekor transparency log service. If an empty object
 * is provided the public instance of Rekor (https://rekor.sigstore.dev) is used.
 *
 * @schema ClusterPolicySpecRulesValidateManifestsAttestorsEntriesCertificatesRekor
 */
export interface ClusterPolicySpecRulesValidateManifestsAttestorsEntriesCertificatesRekor {
  /**
   * IgnoreTlog skips transparency log verification.
   *
   * @schema ClusterPolicySpecRulesValidateManifestsAttestorsEntriesCertificatesRekor#ignoreTlog
   */
  readonly ignoreTlog?: boolean;

  /**
   * RekorPubKey is an optional PEM-encoded public key to use for a custom Rekor.
   * If set, this will be used to validate transparency log signatures from a custom Rekor.
   *
   * @schema ClusterPolicySpecRulesValidateManifestsAttestorsEntriesCertificatesRekor#pubkey
   */
  readonly pubkey?: string;

  /**
   * URL is the address of the transparency log. Defaults to the public Rekor log instance https://rekor.sigstore.dev.
   *
   * @default the public Rekor log instance https://rekor.sigstore.dev.
   * @schema ClusterPolicySpecRulesValidateManifestsAttestorsEntriesCertificatesRekor#url
   */
  readonly url?: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesValidateManifestsAttestorsEntriesCertificatesRekor' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesValidateManifestsAttestorsEntriesCertificatesRekor(obj: ClusterPolicySpecRulesValidateManifestsAttestorsEntriesCertificatesRekor | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ignoreTlog': obj.ignoreTlog,
    'pubkey': obj.pubkey,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CTLog (certificate timestamp log) provides a configuration for validation of Signed Certificate
 * Timestamps (SCTs). If the value is unset, the default behavior by Cosign is used.
 *
 * @schema ClusterPolicySpecRulesValidateManifestsAttestorsEntriesKeylessCtlog
 */
export interface ClusterPolicySpecRulesValidateManifestsAttestorsEntriesKeylessCtlog {
  /**
   * IgnoreSCT defines whether to use the Signed Certificate Timestamp (SCT) log to check for a certificate
   * timestamp. Default is false. Set to true if this was opted out during signing.
   *
   * @default false. Set to true if this was opted out during signing.
   * @schema ClusterPolicySpecRulesValidateManifestsAttestorsEntriesKeylessCtlog#ignoreSCT
   */
  readonly ignoreSct?: boolean;

  /**
   * PubKey, if set, is used to validate SCTs against a custom source.
   *
   * @schema ClusterPolicySpecRulesValidateManifestsAttestorsEntriesKeylessCtlog#pubkey
   */
  readonly pubkey?: string;

  /**
   * TSACertChain, if set, is the PEM-encoded certificate chain file for the RFC3161 timestamp authority. Must
   * contain the root CA certificate. Optionally may contain intermediate CA certificates, and
   * may contain the leaf TSA certificate if not present in the timestamurce.
   *
   * @schema ClusterPolicySpecRulesValidateManifestsAttestorsEntriesKeylessCtlog#tsaCertChain
   */
  readonly tsaCertChain?: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesValidateManifestsAttestorsEntriesKeylessCtlog' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesValidateManifestsAttestorsEntriesKeylessCtlog(obj: ClusterPolicySpecRulesValidateManifestsAttestorsEntriesKeylessCtlog | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ignoreSCT': obj.ignoreSct,
    'pubkey': obj.pubkey,
    'tsaCertChain': obj.tsaCertChain,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Rekor provides configuration for the Rekor transparency log service. If an empty object
 * is provided the public instance of Rekor (https://rekor.sigstore.dev) is used.
 *
 * @schema ClusterPolicySpecRulesValidateManifestsAttestorsEntriesKeylessRekor
 */
export interface ClusterPolicySpecRulesValidateManifestsAttestorsEntriesKeylessRekor {
  /**
   * IgnoreTlog skips transparency log verification.
   *
   * @schema ClusterPolicySpecRulesValidateManifestsAttestorsEntriesKeylessRekor#ignoreTlog
   */
  readonly ignoreTlog?: boolean;

  /**
   * RekorPubKey is an optional PEM-encoded public key to use for a custom Rekor.
   * If set, this will be used to validate transparency log signatures from a custom Rekor.
   *
   * @schema ClusterPolicySpecRulesValidateManifestsAttestorsEntriesKeylessRekor#pubkey
   */
  readonly pubkey?: string;

  /**
   * URL is the address of the transparency log. Defaults to the public Rekor log instance https://rekor.sigstore.dev.
   *
   * @default the public Rekor log instance https://rekor.sigstore.dev.
   * @schema ClusterPolicySpecRulesValidateManifestsAttestorsEntriesKeylessRekor#url
   */
  readonly url?: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesValidateManifestsAttestorsEntriesKeylessRekor' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesValidateManifestsAttestorsEntriesKeylessRekor(obj: ClusterPolicySpecRulesValidateManifestsAttestorsEntriesKeylessRekor | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ignoreTlog': obj.ignoreTlog,
    'pubkey': obj.pubkey,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CTLog (certificate timestamp log) provides a configuration for validation of Signed Certificate
 * Timestamps (SCTs). If the value is unset, the default behavior by Cosign is used.
 *
 * @schema ClusterPolicySpecRulesValidateManifestsAttestorsEntriesKeysCtlog
 */
export interface ClusterPolicySpecRulesValidateManifestsAttestorsEntriesKeysCtlog {
  /**
   * IgnoreSCT defines whether to use the Signed Certificate Timestamp (SCT) log to check for a certificate
   * timestamp. Default is false. Set to true if this was opted out during signing.
   *
   * @default false. Set to true if this was opted out during signing.
   * @schema ClusterPolicySpecRulesValidateManifestsAttestorsEntriesKeysCtlog#ignoreSCT
   */
  readonly ignoreSct?: boolean;

  /**
   * PubKey, if set, is used to validate SCTs against a custom source.
   *
   * @schema ClusterPolicySpecRulesValidateManifestsAttestorsEntriesKeysCtlog#pubkey
   */
  readonly pubkey?: string;

  /**
   * TSACertChain, if set, is the PEM-encoded certificate chain file for the RFC3161 timestamp authority. Must
   * contain the root CA certificate. Optionally may contain intermediate CA certificates, and
   * may contain the leaf TSA certificate if not present in the timestamurce.
   *
   * @schema ClusterPolicySpecRulesValidateManifestsAttestorsEntriesKeysCtlog#tsaCertChain
   */
  readonly tsaCertChain?: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesValidateManifestsAttestorsEntriesKeysCtlog' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesValidateManifestsAttestorsEntriesKeysCtlog(obj: ClusterPolicySpecRulesValidateManifestsAttestorsEntriesKeysCtlog | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ignoreSCT': obj.ignoreSct,
    'pubkey': obj.pubkey,
    'tsaCertChain': obj.tsaCertChain,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Rekor provides configuration for the Rekor transparency log service. If an empty object
 * is provided the public instance of Rekor (https://rekor.sigstore.dev) is used.
 *
 * @schema ClusterPolicySpecRulesValidateManifestsAttestorsEntriesKeysRekor
 */
export interface ClusterPolicySpecRulesValidateManifestsAttestorsEntriesKeysRekor {
  /**
   * IgnoreTlog skips transparency log verification.
   *
   * @schema ClusterPolicySpecRulesValidateManifestsAttestorsEntriesKeysRekor#ignoreTlog
   */
  readonly ignoreTlog?: boolean;

  /**
   * RekorPubKey is an optional PEM-encoded public key to use for a custom Rekor.
   * If set, this will be used to validate transparency log signatures from a custom Rekor.
   *
   * @schema ClusterPolicySpecRulesValidateManifestsAttestorsEntriesKeysRekor#pubkey
   */
  readonly pubkey?: string;

  /**
   * URL is the address of the transparency log. Defaults to the public Rekor log instance https://rekor.sigstore.dev.
   *
   * @default the public Rekor log instance https://rekor.sigstore.dev.
   * @schema ClusterPolicySpecRulesValidateManifestsAttestorsEntriesKeysRekor#url
   */
  readonly url?: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesValidateManifestsAttestorsEntriesKeysRekor' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesValidateManifestsAttestorsEntriesKeysRekor(obj: ClusterPolicySpecRulesValidateManifestsAttestorsEntriesKeysRekor | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ignoreTlog': obj.ignoreTlog,
    'pubkey': obj.pubkey,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Secret resource that contains a public key
 *
 * @schema ClusterPolicySpecRulesValidateManifestsAttestorsEntriesKeysSecret
 */
export interface ClusterPolicySpecRulesValidateManifestsAttestorsEntriesKeysSecret {
  /**
   * Name of the secret. The provided secret must contain a key named cosign.pub.
   *
   * @schema ClusterPolicySpecRulesValidateManifestsAttestorsEntriesKeysSecret#name
   */
  readonly name: string;

  /**
   * Namespace name where the Secret exists.
   *
   * @schema ClusterPolicySpecRulesValidateManifestsAttestorsEntriesKeysSecret#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesValidateManifestsAttestorsEntriesKeysSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesValidateManifestsAttestorsEntriesKeysSecret(obj: ClusterPolicySpecRulesValidateManifestsAttestorsEntriesKeysSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CTLog (certificate timestamp log) provides a configuration for validation of Signed Certificate
 * Timestamps (SCTs). If the value is unset, the default behavior by Cosign is used.
 *
 * @schema ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesCertificatesCtlog
 */
export interface ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesCertificatesCtlog {
  /**
   * IgnoreSCT defines whether to use the Signed Certificate Timestamp (SCT) log to check for a certificate
   * timestamp. Default is false. Set to true if this was opted out during signing.
   *
   * @default false. Set to true if this was opted out during signing.
   * @schema ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesCertificatesCtlog#ignoreSCT
   */
  readonly ignoreSct?: boolean;

  /**
   * PubKey, if set, is used to validate SCTs against a custom source.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesCertificatesCtlog#pubkey
   */
  readonly pubkey?: string;

  /**
   * TSACertChain, if set, is the PEM-encoded certificate chain file for the RFC3161 timestamp authority. Must
   * contain the root CA certificate. Optionally may contain intermediate CA certificates, and
   * may contain the leaf TSA certificate if not present in the timestamurce.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesCertificatesCtlog#tsaCertChain
   */
  readonly tsaCertChain?: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesCertificatesCtlog' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesCertificatesCtlog(obj: ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesCertificatesCtlog | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ignoreSCT': obj.ignoreSct,
    'pubkey': obj.pubkey,
    'tsaCertChain': obj.tsaCertChain,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Rekor provides configuration for the Rekor transparency log service. If an empty object
 * is provided the public instance of Rekor (https://rekor.sigstore.dev) is used.
 *
 * @schema ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesCertificatesRekor
 */
export interface ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesCertificatesRekor {
  /**
   * IgnoreTlog skips transparency log verification.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesCertificatesRekor#ignoreTlog
   */
  readonly ignoreTlog?: boolean;

  /**
   * RekorPubKey is an optional PEM-encoded public key to use for a custom Rekor.
   * If set, this will be used to validate transparency log signatures from a custom Rekor.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesCertificatesRekor#pubkey
   */
  readonly pubkey?: string;

  /**
   * URL is the address of the transparency log. Defaults to the public Rekor log instance https://rekor.sigstore.dev.
   *
   * @default the public Rekor log instance https://rekor.sigstore.dev.
   * @schema ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesCertificatesRekor#url
   */
  readonly url?: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesCertificatesRekor' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesCertificatesRekor(obj: ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesCertificatesRekor | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ignoreTlog': obj.ignoreTlog,
    'pubkey': obj.pubkey,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CTLog (certificate timestamp log) provides a configuration for validation of Signed Certificate
 * Timestamps (SCTs). If the value is unset, the default behavior by Cosign is used.
 *
 * @schema ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesKeylessCtlog
 */
export interface ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesKeylessCtlog {
  /**
   * IgnoreSCT defines whether to use the Signed Certificate Timestamp (SCT) log to check for a certificate
   * timestamp. Default is false. Set to true if this was opted out during signing.
   *
   * @default false. Set to true if this was opted out during signing.
   * @schema ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesKeylessCtlog#ignoreSCT
   */
  readonly ignoreSct?: boolean;

  /**
   * PubKey, if set, is used to validate SCTs against a custom source.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesKeylessCtlog#pubkey
   */
  readonly pubkey?: string;

  /**
   * TSACertChain, if set, is the PEM-encoded certificate chain file for the RFC3161 timestamp authority. Must
   * contain the root CA certificate. Optionally may contain intermediate CA certificates, and
   * may contain the leaf TSA certificate if not present in the timestamurce.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesKeylessCtlog#tsaCertChain
   */
  readonly tsaCertChain?: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesKeylessCtlog' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesKeylessCtlog(obj: ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesKeylessCtlog | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ignoreSCT': obj.ignoreSct,
    'pubkey': obj.pubkey,
    'tsaCertChain': obj.tsaCertChain,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Rekor provides configuration for the Rekor transparency log service. If an empty object
 * is provided the public instance of Rekor (https://rekor.sigstore.dev) is used.
 *
 * @schema ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesKeylessRekor
 */
export interface ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesKeylessRekor {
  /**
   * IgnoreTlog skips transparency log verification.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesKeylessRekor#ignoreTlog
   */
  readonly ignoreTlog?: boolean;

  /**
   * RekorPubKey is an optional PEM-encoded public key to use for a custom Rekor.
   * If set, this will be used to validate transparency log signatures from a custom Rekor.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesKeylessRekor#pubkey
   */
  readonly pubkey?: string;

  /**
   * URL is the address of the transparency log. Defaults to the public Rekor log instance https://rekor.sigstore.dev.
   *
   * @default the public Rekor log instance https://rekor.sigstore.dev.
   * @schema ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesKeylessRekor#url
   */
  readonly url?: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesKeylessRekor' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesKeylessRekor(obj: ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesKeylessRekor | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ignoreTlog': obj.ignoreTlog,
    'pubkey': obj.pubkey,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CTLog (certificate timestamp log) provides a configuration for validation of Signed Certificate
 * Timestamps (SCTs). If the value is unset, the default behavior by Cosign is used.
 *
 * @schema ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesKeysCtlog
 */
export interface ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesKeysCtlog {
  /**
   * IgnoreSCT defines whether to use the Signed Certificate Timestamp (SCT) log to check for a certificate
   * timestamp. Default is false. Set to true if this was opted out during signing.
   *
   * @default false. Set to true if this was opted out during signing.
   * @schema ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesKeysCtlog#ignoreSCT
   */
  readonly ignoreSct?: boolean;

  /**
   * PubKey, if set, is used to validate SCTs against a custom source.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesKeysCtlog#pubkey
   */
  readonly pubkey?: string;

  /**
   * TSACertChain, if set, is the PEM-encoded certificate chain file for the RFC3161 timestamp authority. Must
   * contain the root CA certificate. Optionally may contain intermediate CA certificates, and
   * may contain the leaf TSA certificate if not present in the timestamurce.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesKeysCtlog#tsaCertChain
   */
  readonly tsaCertChain?: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesKeysCtlog' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesKeysCtlog(obj: ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesKeysCtlog | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ignoreSCT': obj.ignoreSct,
    'pubkey': obj.pubkey,
    'tsaCertChain': obj.tsaCertChain,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Rekor provides configuration for the Rekor transparency log service. If an empty object
 * is provided the public instance of Rekor (https://rekor.sigstore.dev) is used.
 *
 * @schema ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesKeysRekor
 */
export interface ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesKeysRekor {
  /**
   * IgnoreTlog skips transparency log verification.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesKeysRekor#ignoreTlog
   */
  readonly ignoreTlog?: boolean;

  /**
   * RekorPubKey is an optional PEM-encoded public key to use for a custom Rekor.
   * If set, this will be used to validate transparency log signatures from a custom Rekor.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesKeysRekor#pubkey
   */
  readonly pubkey?: string;

  /**
   * URL is the address of the transparency log. Defaults to the public Rekor log instance https://rekor.sigstore.dev.
   *
   * @default the public Rekor log instance https://rekor.sigstore.dev.
   * @schema ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesKeysRekor#url
   */
  readonly url?: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesKeysRekor' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesKeysRekor(obj: ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesKeysRekor | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ignoreTlog': obj.ignoreTlog,
    'pubkey': obj.pubkey,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Secret resource that contains a public key
 *
 * @schema ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesKeysSecret
 */
export interface ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesKeysSecret {
  /**
   * Name of the secret. The provided secret must contain a key named cosign.pub.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesKeysSecret#name
   */
  readonly name: string;

  /**
   * Namespace name where the Secret exists.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesKeysSecret#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesKeysSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesKeysSecret(obj: ClusterPolicySpecRulesVerifyImagesAttestationsAttestorsEntriesKeysSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * ClusterPolicy declares validation, mutation, and generation behaviors for matching resources.
 *
 * @schema ClusterPolicyV2Beta1
 */
export class ClusterPolicyV2Beta1 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ClusterPolicyV2Beta1"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'kyverno.io/v2beta1',
    kind: 'ClusterPolicy',
  }

  /**
   * Renders a Kubernetes manifest for "ClusterPolicyV2Beta1".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ClusterPolicyV2Beta1Props): any {
    return {
      ...ClusterPolicyV2Beta1.GVK,
      ...toJson_ClusterPolicyV2Beta1Props(props),
    };
  }

  /**
   * Defines a "ClusterPolicyV2Beta1" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ClusterPolicyV2Beta1Props) {
    super(scope, id, {
      ...ClusterPolicyV2Beta1.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ClusterPolicyV2Beta1.GVK,
      ...toJson_ClusterPolicyV2Beta1Props(resolved),
    };
  }
}

/**
 * ClusterPolicy declares validation, mutation, and generation behaviors for matching resources.
 *
 * @schema ClusterPolicyV2Beta1
 */
export interface ClusterPolicyV2Beta1Props {
  /**
   * @schema ClusterPolicyV2Beta1#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Spec declares policy behaviors.
   *
   * @schema ClusterPolicyV2Beta1#spec
   */
  readonly spec: ClusterPolicyV2Beta1Spec;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1Props(obj: ClusterPolicyV2Beta1Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ClusterPolicyV2Beta1Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Spec declares policy behaviors.
 *
 * @schema ClusterPolicyV2Beta1Spec
 */
export interface ClusterPolicyV2Beta1Spec {
  /**
   * Admission controls if rules are applied during admission.
   * Optional. Default value is "true".
   *
   * @schema ClusterPolicyV2Beta1Spec#admission
   */
  readonly admission?: boolean;

  /**
   * ApplyRules controls how rules in a policy are applied. Rule are processed in
   * the order of declaration. When set to `One` processing stops after a rule has
   * been applied i.e. the rule matches and results in a pass, fail, or error. When
   * set to `All` all rules in the policy are processed. The default is `All`.
   *
   * @schema ClusterPolicyV2Beta1Spec#applyRules
   */
  readonly applyRules?: ClusterPolicyV2Beta1SpecApplyRules;

  /**
   * Background controls if rules are applied to existing resources during a background scan.
   * Optional. Default value is "true". The value must be set to "false" if the policy rule
   * uses variables that are only available in the admission review request (e.g. user name).
   *
   * @schema ClusterPolicyV2Beta1Spec#background
   */
  readonly background?: boolean;

  /**
   * EmitWarning enables API response warnings for mutate policy rules or validate policy rules with validationFailureAction set to Audit.
   * Enabling this option will extend admission request processing times. The default value is "false".
   *
   * @schema ClusterPolicyV2Beta1Spec#emitWarning
   */
  readonly emitWarning?: boolean;

  /**
   * Deprecated, use failurePolicy under the webhookConfiguration instead.
   *
   * @schema ClusterPolicyV2Beta1Spec#failurePolicy
   */
  readonly failurePolicy?: ClusterPolicyV2Beta1SpecFailurePolicy;

  /**
   * Deprecated, use generateExisting under the generate rule instead
   *
   * @schema ClusterPolicyV2Beta1Spec#generateExisting
   */
  readonly generateExisting?: boolean;

  /**
   * Deprecated, use generateExisting instead
   *
   * @schema ClusterPolicyV2Beta1Spec#generateExistingOnPolicyUpdate
   */
  readonly generateExistingOnPolicyUpdate?: boolean;

  /**
   * Deprecated, use mutateExistingOnPolicyUpdate under the mutate rule instead
   *
   * @schema ClusterPolicyV2Beta1Spec#mutateExistingOnPolicyUpdate
   */
  readonly mutateExistingOnPolicyUpdate?: boolean;

  /**
   * Rules is a list of Rule instances. A Policy contains multiple rules and
   * each rule can validate, mutate, or generate resources.
   *
   * @schema ClusterPolicyV2Beta1Spec#rules
   */
  readonly rules?: ClusterPolicyV2Beta1SpecRules[];

  /**
   * Deprecated.
   *
   * @schema ClusterPolicyV2Beta1Spec#schemaValidation
   */
  readonly schemaValidation?: boolean;

  /**
   * UseServerSideApply controls whether to use server-side apply for generate rules
   * If is set to "true" create & update for generate rules will use apply instead of create/update.
   * Defaults to "false" if not specified.
   *
   * @default false" if not specified.
   * @schema ClusterPolicyV2Beta1Spec#useServerSideApply
   */
  readonly useServerSideApply?: boolean;

  /**
   * Deprecated, use validationFailureAction under the validate rule instead.
   *
   * @schema ClusterPolicyV2Beta1Spec#validationFailureAction
   */
  readonly validationFailureAction?: ClusterPolicyV2Beta1SpecValidationFailureAction;

  /**
   * Deprecated, use validationFailureActionOverrides under the validate rule instead.
   *
   * @schema ClusterPolicyV2Beta1Spec#validationFailureActionOverrides
   */
  readonly validationFailureActionOverrides?: ClusterPolicyV2Beta1SpecValidationFailureActionOverrides[];

  /**
   * WebhookConfiguration specifies the custom configuration for Kubernetes admission webhookconfiguration.
   *
   * @schema ClusterPolicyV2Beta1Spec#webhookConfiguration
   */
  readonly webhookConfiguration?: ClusterPolicyV2Beta1SpecWebhookConfiguration;

  /**
   * Deprecated, use webhookTimeoutSeconds under webhookConfiguration instead.
   *
   * @schema ClusterPolicyV2Beta1Spec#webhookTimeoutSeconds
   */
  readonly webhookTimeoutSeconds?: number;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1Spec(obj: ClusterPolicyV2Beta1Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'admission': obj.admission,
    'applyRules': obj.applyRules,
    'background': obj.background,
    'emitWarning': obj.emitWarning,
    'failurePolicy': obj.failurePolicy,
    'generateExisting': obj.generateExisting,
    'generateExistingOnPolicyUpdate': obj.generateExistingOnPolicyUpdate,
    'mutateExistingOnPolicyUpdate': obj.mutateExistingOnPolicyUpdate,
    'rules': obj.rules?.map(y => toJson_ClusterPolicyV2Beta1SpecRules(y)),
    'schemaValidation': obj.schemaValidation,
    'useServerSideApply': obj.useServerSideApply,
    'validationFailureAction': obj.validationFailureAction,
    'validationFailureActionOverrides': obj.validationFailureActionOverrides?.map(y => toJson_ClusterPolicyV2Beta1SpecValidationFailureActionOverrides(y)),
    'webhookConfiguration': toJson_ClusterPolicyV2Beta1SpecWebhookConfiguration(obj.webhookConfiguration),
    'webhookTimeoutSeconds': obj.webhookTimeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ApplyRules controls how rules in a policy are applied. Rule are processed in
 * the order of declaration. When set to `One` processing stops after a rule has
 * been applied i.e. the rule matches and results in a pass, fail, or error. When
 * set to `All` all rules in the policy are processed. The default is `All`.
 *
 * @schema ClusterPolicyV2Beta1SpecApplyRules
 */
export enum ClusterPolicyV2Beta1SpecApplyRules {
  /** All */
  ALL = "All",
  /** One */
  ONE = "One",
}

/**
 * Deprecated, use failurePolicy under the webhookConfiguration instead.
 *
 * @schema ClusterPolicyV2Beta1SpecFailurePolicy
 */
export enum ClusterPolicyV2Beta1SpecFailurePolicy {
  /** Ignore */
  IGNORE = "Ignore",
  /** Fail */
  FAIL = "Fail",
}

/**
 * Rule defines a validation, mutation, or generation control for matching resources.
 * Each rules contains a match declaration to select resources, and an optional exclude
 * declaration to specify which resources to exclude.
 *
 * @schema ClusterPolicyV2Beta1SpecRules
 */
export interface ClusterPolicyV2Beta1SpecRules {
  /**
   * CELPreconditions are used to determine if a policy rule should be applied by evaluating a
   * set of CEL conditions. It can only be used with the validate.cel subrule
   *
   * @schema ClusterPolicyV2Beta1SpecRules#celPreconditions
   */
  readonly celPreconditions?: ClusterPolicyV2Beta1SpecRulesCelPreconditions[];

  /**
   * Context defines variables and data sources that can be used during rule execution.
   *
   * @schema ClusterPolicyV2Beta1SpecRules#context
   */
  readonly context?: ClusterPolicyV2Beta1SpecRulesContext[];

  /**
   * ExcludeResources defines when this policy rule should not be applied. The exclude
   * criteria can include resource information (e.g. kind, name, namespace, labels)
   * and admission review request information like the name or role.
   *
   * @schema ClusterPolicyV2Beta1SpecRules#exclude
   */
  readonly exclude?: ClusterPolicyV2Beta1SpecRulesExclude;

  /**
   * Generation is used to create new resources.
   *
   * @schema ClusterPolicyV2Beta1SpecRules#generate
   */
  readonly generate?: ClusterPolicyV2Beta1SpecRulesGenerate;

  /**
   * ImageExtractors defines a mapping from kinds to ImageExtractorConfigs.
   * This config is only valid for verifyImages rules.
   *
   * @schema ClusterPolicyV2Beta1SpecRules#imageExtractors
   */
  readonly imageExtractors?: { [key: string]: ClusterPolicyV2Beta1SpecRulesImageExtractors[] };

  /**
   * MatchResources defines when this policy rule should be applied. The match
   * criteria can include resource information (e.g. kind, name, namespace, labels)
   * and admission review request information like the user name or role.
   * At least one kind is required.
   *
   * @schema ClusterPolicyV2Beta1SpecRules#match
   */
  readonly match: ClusterPolicyV2Beta1SpecRulesMatch;

  /**
   * Mutation is used to modify matching resources.
   *
   * @schema ClusterPolicyV2Beta1SpecRules#mutate
   */
  readonly mutate?: ClusterPolicyV2Beta1SpecRulesMutate;

  /**
   * Name is a label to identify the rule, It must be unique within the policy.
   *
   * @schema ClusterPolicyV2Beta1SpecRules#name
   */
  readonly name: string;

  /**
   * Preconditions are used to determine if a policy rule should be applied by evaluating a
   * set of conditions. The declaration can contain nested `any` or `all` statements.
   * See: https://kyverno.io/docs/writing-policies/preconditions/
   *
   * @schema ClusterPolicyV2Beta1SpecRules#preconditions
   */
  readonly preconditions?: ClusterPolicyV2Beta1SpecRulesPreconditions;

  /**
   * SkipBackgroundRequests bypasses admission requests that are sent by the background controller.
   * The default value is set to "true", it must be set to "false" to apply
   * generate and mutateExisting rules to those requests.
   *
   * @schema ClusterPolicyV2Beta1SpecRules#skipBackgroundRequests
   */
  readonly skipBackgroundRequests?: boolean;

  /**
   * Validation is used to validate matching resources.
   *
   * @schema ClusterPolicyV2Beta1SpecRules#validate
   */
  readonly validate?: ClusterPolicyV2Beta1SpecRulesValidate;

  /**
   * VerifyImages is used to verify image signatures and mutate them to add a digest
   *
   * @schema ClusterPolicyV2Beta1SpecRules#verifyImages
   */
  readonly verifyImages?: ClusterPolicyV2Beta1SpecRulesVerifyImages[];

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRules' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRules(obj: ClusterPolicyV2Beta1SpecRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'celPreconditions': obj.celPreconditions?.map(y => toJson_ClusterPolicyV2Beta1SpecRulesCelPreconditions(y)),
    'context': obj.context?.map(y => toJson_ClusterPolicyV2Beta1SpecRulesContext(y)),
    'exclude': toJson_ClusterPolicyV2Beta1SpecRulesExclude(obj.exclude),
    'generate': toJson_ClusterPolicyV2Beta1SpecRulesGenerate(obj.generate),
    'imageExtractors': ((obj.imageExtractors) === undefined) ? undefined : (Object.entries(obj.imageExtractors).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.map(y => toJson_ClusterPolicyV2Beta1SpecRulesImageExtractors(y)) }), {})),
    'match': toJson_ClusterPolicyV2Beta1SpecRulesMatch(obj.match),
    'mutate': toJson_ClusterPolicyV2Beta1SpecRulesMutate(obj.mutate),
    'name': obj.name,
    'preconditions': toJson_ClusterPolicyV2Beta1SpecRulesPreconditions(obj.preconditions),
    'skipBackgroundRequests': obj.skipBackgroundRequests,
    'validate': toJson_ClusterPolicyV2Beta1SpecRulesValidate(obj.validate),
    'verifyImages': obj.verifyImages?.map(y => toJson_ClusterPolicyV2Beta1SpecRulesVerifyImages(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Deprecated, use validationFailureAction under the validate rule instead.
 *
 * @schema ClusterPolicyV2Beta1SpecValidationFailureAction
 */
export enum ClusterPolicyV2Beta1SpecValidationFailureAction {
  /** audit */
  AUDIT = "audit",
  /** enforce */
  ENFORCE = "enforce",
}

/**
 * @schema ClusterPolicyV2Beta1SpecValidationFailureActionOverrides
 */
export interface ClusterPolicyV2Beta1SpecValidationFailureActionOverrides {
  /**
   * ValidationFailureAction defines the policy validation failure action
   *
   * @schema ClusterPolicyV2Beta1SpecValidationFailureActionOverrides#action
   */
  readonly action?: ClusterPolicyV2Beta1SpecValidationFailureActionOverridesAction;

  /**
   * A label selector is a label query over a set of resources. The result of matchLabels and
   * matchExpressions are ANDed. An empty label selector matches all objects. A null
   * label selector matches no objects.
   *
   * @schema ClusterPolicyV2Beta1SpecValidationFailureActionOverrides#namespaceSelector
   */
  readonly namespaceSelector?: ClusterPolicyV2Beta1SpecValidationFailureActionOverridesNamespaceSelector;

  /**
   * @schema ClusterPolicyV2Beta1SpecValidationFailureActionOverrides#namespaces
   */
  readonly namespaces?: string[];

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecValidationFailureActionOverrides' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecValidationFailureActionOverrides(obj: ClusterPolicyV2Beta1SpecValidationFailureActionOverrides | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'namespaceSelector': toJson_ClusterPolicyV2Beta1SpecValidationFailureActionOverridesNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WebhookConfiguration specifies the custom configuration for Kubernetes admission webhookconfiguration.
 *
 * @schema ClusterPolicyV2Beta1SpecWebhookConfiguration
 */
export interface ClusterPolicyV2Beta1SpecWebhookConfiguration {
  /**
   * FailurePolicy defines how unexpected policy errors and webhook response timeout errors are handled.
   * Rules within the same policy share the same failure behavior.
   * This field should not be accessed directly, instead `GetFailurePolicy()` should be used.
   * Allowed values are Ignore or Fail. Defaults to Fail.
   *
   * @default Fail.
   * @schema ClusterPolicyV2Beta1SpecWebhookConfiguration#failurePolicy
   */
  readonly failurePolicy?: ClusterPolicyV2Beta1SpecWebhookConfigurationFailurePolicy;

  /**
   * MatchCondition configures admission webhook matchConditions.
   * Requires Kubernetes 1.27 or later.
   *
   * @schema ClusterPolicyV2Beta1SpecWebhookConfiguration#matchConditions
   */
  readonly matchConditions?: ClusterPolicyV2Beta1SpecWebhookConfigurationMatchConditions[];

  /**
   * TimeoutSeconds specifies the maximum time in seconds allowed to apply this policy.
   * After the configured time expires, the admission request may fail, or may simply ignore the policy results,
   * based on the failure policy. The default timeout is 10s, the value must be between 1 and 30 seconds.
   *
   * @schema ClusterPolicyV2Beta1SpecWebhookConfiguration#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecWebhookConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecWebhookConfiguration(obj: ClusterPolicyV2Beta1SpecWebhookConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'failurePolicy': obj.failurePolicy,
    'matchConditions': obj.matchConditions?.map(y => toJson_ClusterPolicyV2Beta1SpecWebhookConfigurationMatchConditions(y)),
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * MatchCondition represents a condition which must by fulfilled for a request to be sent to a webhook.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesCelPreconditions
 */
export interface ClusterPolicyV2Beta1SpecRulesCelPreconditions {
  /**
   * Expression represents the expression which will be evaluated by CEL. Must evaluate to bool.
   * CEL expressions have access to the contents of the AdmissionRequest and Authorizer, organized into CEL variables:
   *
   * 'object' - The object from the incoming request. The value is null for DELETE requests.
   * 'oldObject' - The existing object. The value is null for CREATE requests.
   * 'request' - Attributes of the admission request(/pkg/apis/admission/types.go#AdmissionRequest).
   * 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
   * See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
   * 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
   * request resource.
   * Documentation on CEL: https://kubernetes.io/docs/reference/using-api/cel/
   *
   * Required.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesCelPreconditions#expression
   */
  readonly expression: string;

  /**
   * Name is an identifier for this match condition, used for strategic merging of MatchConditions,
   * as well as providing an identifier for logging purposes. A good name should be descriptive of
   * the associated expression.
   * Name must be a qualified name consisting of alphanumeric characters, '-', '_' or '.', and
   * must start and end with an alphanumeric character (e.g. 'MyName',  or 'my.name',  or
   * '123-abc', regex used for validation is '([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]') with an
   * optional DNS subdomain prefix and '/' (e.g. 'example.com/MyName')
   *
   * Required.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesCelPreconditions#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesCelPreconditions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesCelPreconditions(obj: ClusterPolicyV2Beta1SpecRulesCelPreconditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'expression': obj.expression,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ContextEntry adds variables and data sources to a rule Context. Either a
 * ConfigMap reference or a APILookup must be provided.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesContext
 */
export interface ClusterPolicyV2Beta1SpecRulesContext {
  /**
   * APICall is an HTTP request to the Kubernetes API server, or other JSON web service.
   * The data returned is stored in the context with the name for the context entry.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesContext#apiCall
   */
  readonly apiCall?: ClusterPolicyV2Beta1SpecRulesContextApiCall;

  /**
   * ConfigMap is the ConfigMap reference.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesContext#configMap
   */
  readonly configMap?: ClusterPolicyV2Beta1SpecRulesContextConfigMap;

  /**
   * GlobalContextEntryReference is a reference to a cached global context entry.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesContext#globalReference
   */
  readonly globalReference?: ClusterPolicyV2Beta1SpecRulesContextGlobalReference;

  /**
   * ImageRegistry defines requests to an OCI/Docker V2 registry to fetch image
   * details.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesContext#imageRegistry
   */
  readonly imageRegistry?: ClusterPolicyV2Beta1SpecRulesContextImageRegistry;

  /**
   * Name is the variable name.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesContext#name
   */
  readonly name: string;

  /**
   * Variable defines an arbitrary JMESPath context variable that can be defined inline.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesContext#variable
   */
  readonly variable?: ClusterPolicyV2Beta1SpecRulesContextVariable;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesContext(obj: ClusterPolicyV2Beta1SpecRulesContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiCall': toJson_ClusterPolicyV2Beta1SpecRulesContextApiCall(obj.apiCall),
    'configMap': toJson_ClusterPolicyV2Beta1SpecRulesContextConfigMap(obj.configMap),
    'globalReference': toJson_ClusterPolicyV2Beta1SpecRulesContextGlobalReference(obj.globalReference),
    'imageRegistry': toJson_ClusterPolicyV2Beta1SpecRulesContextImageRegistry(obj.imageRegistry),
    'name': obj.name,
    'variable': toJson_ClusterPolicyV2Beta1SpecRulesContextVariable(obj.variable),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ExcludeResources defines when this policy rule should not be applied. The exclude
 * criteria can include resource information (e.g. kind, name, namespace, labels)
 * and admission review request information like the name or role.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesExclude
 */
export interface ClusterPolicyV2Beta1SpecRulesExclude {
  /**
   * All allows specifying resources which will be ANDed
   *
   * @schema ClusterPolicyV2Beta1SpecRulesExclude#all
   */
  readonly all?: ClusterPolicyV2Beta1SpecRulesExcludeAll[];

  /**
   * Any allows specifying resources which will be ORed
   *
   * @schema ClusterPolicyV2Beta1SpecRulesExclude#any
   */
  readonly any?: ClusterPolicyV2Beta1SpecRulesExcludeAny[];

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesExclude' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesExclude(obj: ClusterPolicyV2Beta1SpecRulesExclude | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'all': obj.all?.map(y => toJson_ClusterPolicyV2Beta1SpecRulesExcludeAll(y)),
    'any': obj.any?.map(y => toJson_ClusterPolicyV2Beta1SpecRulesExcludeAny(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Generation is used to create new resources.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesGenerate
 */
export interface ClusterPolicyV2Beta1SpecRulesGenerate {
  /**
   * APIVersion specifies resource apiVersion.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerate#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Clone specifies the source resource used to populate each generated resource.
   * At most one of Data or Clone can be specified. If neither are provided, the generated
   * resource will be created with default data only.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerate#clone
   */
  readonly clone?: ClusterPolicyV2Beta1SpecRulesGenerateClone;

  /**
   * CloneList specifies the list of source resource used to populate each generated resource.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerate#cloneList
   */
  readonly cloneList?: ClusterPolicyV2Beta1SpecRulesGenerateCloneList;

  /**
   * Data provides the resource declaration used to populate each generated resource.
   * At most one of Data or Clone must be specified. If neither are provided, the generated
   * resource will be created with default data only.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerate#data
   */
  readonly data?: any;

  /**
   * ForEach applies generate rules to a list of sub-elements by creating a context for each entry in the list and looping over it to apply the specified logic.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerate#foreach
   */
  readonly foreach?: ClusterPolicyV2Beta1SpecRulesGenerateForeach[];

  /**
   * GenerateExisting controls whether to trigger the rule in existing resources
   * If is set to "true" the rule will be triggered and applied to existing matched resources.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerate#generateExisting
   */
  readonly generateExisting?: boolean;

  /**
   * Kind specifies resource kind.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerate#kind
   */
  readonly kind?: string;

  /**
   * Name specifies the resource name.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerate#name
   */
  readonly name?: string;

  /**
   * Namespace specifies resource namespace.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerate#namespace
   */
  readonly namespace?: string;

  /**
   * OrphanDownstreamOnPolicyDelete controls whether generated resources should be deleted when the rule that generated
   * them is deleted with synchronization enabled. This option is only applicable to generate rules of the data type.
   * See https://kyverno.io/docs/writing-policies/generate/#data-examples.
   * Defaults to "false" if not specified.
   *
   * @default false" if not specified.
   * @schema ClusterPolicyV2Beta1SpecRulesGenerate#orphanDownstreamOnPolicyDelete
   */
  readonly orphanDownstreamOnPolicyDelete?: boolean;

  /**
   * Synchronize controls if generated resources should be kept in-sync with their source resource.
   * If Synchronize is set to "true" changes to generated resources will be overwritten with resource
   * data from Data or the resource specified in the Clone declaration.
   * Optional. Defaults to "false" if not specified.
   *
   * @default false" if not specified.
   * @schema ClusterPolicyV2Beta1SpecRulesGenerate#synchronize
   */
  readonly synchronize?: boolean;

  /**
   * UID specifies the resource uid.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerate#uid
   */
  readonly uid?: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesGenerate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesGenerate(obj: ClusterPolicyV2Beta1SpecRulesGenerate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'clone': toJson_ClusterPolicyV2Beta1SpecRulesGenerateClone(obj.clone),
    'cloneList': toJson_ClusterPolicyV2Beta1SpecRulesGenerateCloneList(obj.cloneList),
    'data': obj.data,
    'foreach': obj.foreach?.map(y => toJson_ClusterPolicyV2Beta1SpecRulesGenerateForeach(y)),
    'generateExisting': obj.generateExisting,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
    'orphanDownstreamOnPolicyDelete': obj.orphanDownstreamOnPolicyDelete,
    'synchronize': obj.synchronize,
    'uid': obj.uid,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterPolicyV2Beta1SpecRulesImageExtractors
 */
export interface ClusterPolicyV2Beta1SpecRulesImageExtractors {
  /**
   * JMESPath is an optional JMESPath expression to apply to the image value.
   * This is useful when the extracted image begins with a prefix like 'docker://'.
   * The 'trim_prefix' function may be used to trim the prefix: trim_prefix(@, 'docker://').
   * Note - Image digest mutation may not be used when applying a JMESPAth to an image.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesImageExtractors#jmesPath
   */
  readonly jmesPath?: string;

  /**
   * Key is an optional name of the field within 'path' that will be used to uniquely identify an image.
   * Note - this field MUST be unique.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesImageExtractors#key
   */
  readonly key?: string;

  /**
   * Name is the entry the image will be available under 'images.<name>' in the context.
   * If this field is not defined, image entries will appear under 'images.custom'.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesImageExtractors#name
   */
  readonly name?: string;

  /**
   * Path is the path to the object containing the image field in a custom resource.
   * It should be slash-separated. Each slash-separated key must be a valid YAML key or a wildcard '*'.
   * Wildcard keys are expanded in case of arrays or objects.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesImageExtractors#path
   */
  readonly path: string;

  /**
   * Value is an optional name of the field within 'path' that points to the image URI.
   * This is useful when a custom 'key' is also defined.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesImageExtractors#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesImageExtractors' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesImageExtractors(obj: ClusterPolicyV2Beta1SpecRulesImageExtractors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'jmesPath': obj.jmesPath,
    'key': obj.key,
    'name': obj.name,
    'path': obj.path,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * MatchResources defines when this policy rule should be applied. The match
 * criteria can include resource information (e.g. kind, name, namespace, labels)
 * and admission review request information like the user name or role.
 * At least one kind is required.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesMatch
 */
export interface ClusterPolicyV2Beta1SpecRulesMatch {
  /**
   * All allows specifying resources which will be ANDed
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMatch#all
   */
  readonly all?: ClusterPolicyV2Beta1SpecRulesMatchAll[];

  /**
   * Any allows specifying resources which will be ORed
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMatch#any
   */
  readonly any?: ClusterPolicyV2Beta1SpecRulesMatchAny[];

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesMatch(obj: ClusterPolicyV2Beta1SpecRulesMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'all': obj.all?.map(y => toJson_ClusterPolicyV2Beta1SpecRulesMatchAll(y)),
    'any': obj.any?.map(y => toJson_ClusterPolicyV2Beta1SpecRulesMatchAny(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Mutation is used to modify matching resources.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesMutate
 */
export interface ClusterPolicyV2Beta1SpecRulesMutate {
  /**
   * ForEach applies mutation rules to a list of sub-elements by creating a context for each entry in the list and looping over it to apply the specified logic.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutate#foreach
   */
  readonly foreach?: ClusterPolicyV2Beta1SpecRulesMutateForeach[];

  /**
   * MutateExistingOnPolicyUpdate controls if the mutateExisting rule will be applied on policy events.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutate#mutateExistingOnPolicyUpdate
   */
  readonly mutateExistingOnPolicyUpdate?: boolean;

  /**
   * PatchStrategicMerge is a strategic merge patch used to modify resources.
   * See https://kubernetes.io/docs/tasks/manage-kubernetes-objects/update-api-object-kubectl-patch/
   * and https://kubectl.docs.kubernetes.io/references/kustomize/kustomization/patchesstrategicmerge/.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutate#patchStrategicMerge
   */
  readonly patchStrategicMerge?: any;

  /**
   * PatchesJSON6902 is a list of RFC 6902 JSON Patch declarations used to modify resources.
   * See https://tools.ietf.org/html/rfc6902 and https://kubectl.docs.kubernetes.io/references/kustomize/kustomization/patchesjson6902/.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutate#patchesJson6902
   */
  readonly patchesJson6902?: string;

  /**
   * Targets defines the target resources to be mutated.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutate#targets
   */
  readonly targets?: ClusterPolicyV2Beta1SpecRulesMutateTargets[];

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesMutate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesMutate(obj: ClusterPolicyV2Beta1SpecRulesMutate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'foreach': obj.foreach?.map(y => toJson_ClusterPolicyV2Beta1SpecRulesMutateForeach(y)),
    'mutateExistingOnPolicyUpdate': obj.mutateExistingOnPolicyUpdate,
    'patchStrategicMerge': obj.patchStrategicMerge,
    'patchesJson6902': obj.patchesJson6902,
    'targets': obj.targets?.map(y => toJson_ClusterPolicyV2Beta1SpecRulesMutateTargets(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Preconditions are used to determine if a policy rule should be applied by evaluating a
 * set of conditions. The declaration can contain nested `any` or `all` statements.
 * See: https://kyverno.io/docs/writing-policies/preconditions/
 *
 * @schema ClusterPolicyV2Beta1SpecRulesPreconditions
 */
export interface ClusterPolicyV2Beta1SpecRulesPreconditions {
  /**
   * AllConditions enable variable-based conditional rule execution. This is useful for
   * finer control of when an rule is applied. A condition can reference object data
   * using JMESPath notation.
   * Here, all of the conditions need to pass.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesPreconditions#all
   */
  readonly all?: ClusterPolicyV2Beta1SpecRulesPreconditionsAll[];

  /**
   * AnyConditions enable variable-based conditional rule execution. This is useful for
   * finer control of when an rule is applied. A condition can reference object data
   * using JMESPath notation.
   * Here, at least one of the conditions need to pass.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesPreconditions#any
   */
  readonly any?: ClusterPolicyV2Beta1SpecRulesPreconditionsAny[];

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesPreconditions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesPreconditions(obj: ClusterPolicyV2Beta1SpecRulesPreconditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'all': obj.all?.map(y => toJson_ClusterPolicyV2Beta1SpecRulesPreconditionsAll(y)),
    'any': obj.any?.map(y => toJson_ClusterPolicyV2Beta1SpecRulesPreconditionsAny(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Validation is used to validate matching resources.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesValidate
 */
export interface ClusterPolicyV2Beta1SpecRulesValidate {
  /**
   * AnyPattern specifies list of validation patterns. At least one of the patterns
   * must be satisfied for the validation rule to succeed.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidate#anyPattern
   */
  readonly anyPattern?: any;

  /**
   * Assert defines a kyverno-json assertion tree.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidate#assert
   */
  readonly assert?: any;

  /**
   * CEL allows validation checks using the Common Expression Language (https://kubernetes.io/docs/reference/using-api/cel/).
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidate#cel
   */
  readonly cel?: ClusterPolicyV2Beta1SpecRulesValidateCel;

  /**
   * Deny defines conditions used to pass or fail a validation rule.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidate#deny
   */
  readonly deny?: ClusterPolicyV2Beta1SpecRulesValidateDeny;

  /**
   * FailureAction defines if a validation policy rule violation should block
   * the admission review request (Enforce), or allow (Audit) the admission review request
   * and report an error in a policy report. Optional.
   * Allowed values are Audit or Enforce.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidate#failureAction
   */
  readonly failureAction?: ClusterPolicyV2Beta1SpecRulesValidateFailureAction;

  /**
   * FailureActionOverrides is a Cluster Policy attribute that specifies FailureAction
   * namespace-wise. It overrides FailureAction for the specified namespaces.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidate#failureActionOverrides
   */
  readonly failureActionOverrides?: ClusterPolicyV2Beta1SpecRulesValidateFailureActionOverrides[];

  /**
   * ForEach applies validate rules to a list of sub-elements by creating a context for each entry in the list and looping over it to apply the specified logic.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidate#foreach
   */
  readonly foreach?: ClusterPolicyV2Beta1SpecRulesValidateForeach[];

  /**
   * Manifest specifies conditions for manifest verification
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidate#manifests
   */
  readonly manifests?: ClusterPolicyV2Beta1SpecRulesValidateManifests;

  /**
   * Message specifies a custom message to be displayed on failure.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidate#message
   */
  readonly message?: string;

  /**
   * Pattern specifies an overlay-style pattern used to check resources.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidate#pattern
   */
  readonly pattern?: any;

  /**
   * PodSecurity applies exemptions for Kubernetes Pod Security admission
   * by specifying exclusions for Pod Security Standards controls.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidate#podSecurity
   */
  readonly podSecurity?: ClusterPolicyV2Beta1SpecRulesValidatePodSecurity;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesValidate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesValidate(obj: ClusterPolicyV2Beta1SpecRulesValidate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'anyPattern': obj.anyPattern,
    'assert': obj.assert,
    'cel': toJson_ClusterPolicyV2Beta1SpecRulesValidateCel(obj.cel),
    'deny': toJson_ClusterPolicyV2Beta1SpecRulesValidateDeny(obj.deny),
    'failureAction': obj.failureAction,
    'failureActionOverrides': obj.failureActionOverrides?.map(y => toJson_ClusterPolicyV2Beta1SpecRulesValidateFailureActionOverrides(y)),
    'foreach': obj.foreach?.map(y => toJson_ClusterPolicyV2Beta1SpecRulesValidateForeach(y)),
    'manifests': toJson_ClusterPolicyV2Beta1SpecRulesValidateManifests(obj.manifests),
    'message': obj.message,
    'pattern': obj.pattern,
    'podSecurity': toJson_ClusterPolicyV2Beta1SpecRulesValidatePodSecurity(obj.podSecurity),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ImageVerification validates that images that match the specified pattern
 * are signed with the supplied public key. Once the image is verified it is
 * mutated to include the SHA digest retrieved during the registration.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesVerifyImages
 */
export interface ClusterPolicyV2Beta1SpecRulesVerifyImages {
  /**
   * Attestations are optional checks for signed in-toto Statements used to verify the image.
   * See https://github.com/in-toto/attestation. Kyverno fetches signed attestations from the
   * OCI registry and decodes them into a list of Statement declarations.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImages#attestations
   */
  readonly attestations?: ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestations[];

  /**
   * Attestors specified the required attestors (i.e. authorities)
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImages#attestors
   */
  readonly attestors?: ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestors[];

  /**
   * Allowed values are Audit or Enforce.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImages#failureAction
   */
  readonly failureAction?: ClusterPolicyV2Beta1SpecRulesVerifyImagesFailureAction;

  /**
   * ImageReferences is a list of matching image reference patterns. At least one pattern in the
   * list must match the image for the rule to apply. Each image reference consists of a registry
   * address (defaults to docker.io), repository, image, and tag (defaults to latest).
   * Wildcards ('*' and '?') are allowed. See: https://kubernetes.io/docs/concepts/containers/images.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImages#imageReferences
   */
  readonly imageReferences?: string[];

  /**
   * ImageRegistryCredentials provides credentials that will be used for authentication with registry
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImages#imageRegistryCredentials
   */
  readonly imageRegistryCredentials?: ClusterPolicyV2Beta1SpecRulesVerifyImagesImageRegistryCredentials;

  /**
   * MutateDigest enables replacement of image tags with digests.
   * Defaults to true.
   *
   * @default true.
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImages#mutateDigest
   */
  readonly mutateDigest?: boolean;

  /**
   * Repository is an optional alternate OCI repository to use for image signatures and attestations that match this rule.
   * If specified Repository will override the default OCI image repository configured for the installation.
   * The repository can also be overridden per Attestor or Attestation.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImages#repository
   */
  readonly repository?: string;

  /**
   * Required validates that images are verified i.e. have matched passed a signature or attestation check.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImages#required
   */
  readonly required?: boolean;

  /**
   * SkipImageReferences is a list of matching image reference patterns that should be skipped.
   * At least one pattern in the list must match the image for the rule to be skipped. Each image reference
   * consists of a registry address (defaults to docker.io), repository, image, and tag (defaults to latest).
   * Wildcards ('*' and '?') are allowed. See: https://kubernetes.io/docs/concepts/containers/images.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImages#skipImageReferences
   */
  readonly skipImageReferences?: string[];

  /**
   * Type specifies the method of signature validation. The allowed options
   * are Cosign and Notary. By default Cosign is used if a type is not specified.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImages#type
   */
  readonly type?: ClusterPolicyV2Beta1SpecRulesVerifyImagesType;

  /**
   * UseCache enables caching of image verify responses for this rule
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImages#useCache
   */
  readonly useCache?: boolean;

  /**
   * Validation checks conditions across multiple image
   * verification attestations or context entries
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImages#validate
   */
  readonly validate?: ClusterPolicyV2Beta1SpecRulesVerifyImagesValidate;

  /**
   * VerifyDigest validates that images have a digest.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImages#verifyDigest
   */
  readonly verifyDigest?: boolean;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesVerifyImages' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesVerifyImages(obj: ClusterPolicyV2Beta1SpecRulesVerifyImages | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'attestations': obj.attestations?.map(y => toJson_ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestations(y)),
    'attestors': obj.attestors?.map(y => toJson_ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestors(y)),
    'failureAction': obj.failureAction,
    'imageReferences': obj.imageReferences?.map(y => y),
    'imageRegistryCredentials': toJson_ClusterPolicyV2Beta1SpecRulesVerifyImagesImageRegistryCredentials(obj.imageRegistryCredentials),
    'mutateDigest': obj.mutateDigest,
    'repository': obj.repository,
    'required': obj.required,
    'skipImageReferences': obj.skipImageReferences?.map(y => y),
    'type': obj.type,
    'useCache': obj.useCache,
    'validate': toJson_ClusterPolicyV2Beta1SpecRulesVerifyImagesValidate(obj.validate),
    'verifyDigest': obj.verifyDigest,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ValidationFailureAction defines the policy validation failure action
 *
 * @schema ClusterPolicyV2Beta1SpecValidationFailureActionOverridesAction
 */
export enum ClusterPolicyV2Beta1SpecValidationFailureActionOverridesAction {
  /** audit */
  AUDIT = "audit",
  /** enforce */
  ENFORCE = "enforce",
}

/**
 * A label selector is a label query over a set of resources. The result of matchLabels and
 * matchExpressions are ANDed. An empty label selector matches all objects. A null
 * label selector matches no objects.
 *
 * @schema ClusterPolicyV2Beta1SpecValidationFailureActionOverridesNamespaceSelector
 */
export interface ClusterPolicyV2Beta1SpecValidationFailureActionOverridesNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterPolicyV2Beta1SpecValidationFailureActionOverridesNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterPolicyV2Beta1SpecValidationFailureActionOverridesNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterPolicyV2Beta1SpecValidationFailureActionOverridesNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecValidationFailureActionOverridesNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecValidationFailureActionOverridesNamespaceSelector(obj: ClusterPolicyV2Beta1SpecValidationFailureActionOverridesNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterPolicyV2Beta1SpecValidationFailureActionOverridesNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FailurePolicy defines how unexpected policy errors and webhook response timeout errors are handled.
 * Rules within the same policy share the same failure behavior.
 * This field should not be accessed directly, instead `GetFailurePolicy()` should be used.
 * Allowed values are Ignore or Fail. Defaults to Fail.
 *
 * @default Fail.
 * @schema ClusterPolicyV2Beta1SpecWebhookConfigurationFailurePolicy
 */
export enum ClusterPolicyV2Beta1SpecWebhookConfigurationFailurePolicy {
  /** Ignore */
  IGNORE = "Ignore",
  /** Fail */
  FAIL = "Fail",
}

/**
 * MatchCondition represents a condition which must by fulfilled for a request to be sent to a webhook.
 *
 * @schema ClusterPolicyV2Beta1SpecWebhookConfigurationMatchConditions
 */
export interface ClusterPolicyV2Beta1SpecWebhookConfigurationMatchConditions {
  /**
   * Expression represents the expression which will be evaluated by CEL. Must evaluate to bool.
   * CEL expressions have access to the contents of the AdmissionRequest and Authorizer, organized into CEL variables:
   *
   * 'object' - The object from the incoming request. The value is null for DELETE requests.
   * 'oldObject' - The existing object. The value is null for CREATE requests.
   * 'request' - Attributes of the admission request(/pkg/apis/admission/types.go#AdmissionRequest).
   * 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
   * See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
   * 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
   * request resource.
   * Documentation on CEL: https://kubernetes.io/docs/reference/using-api/cel/
   *
   * Required.
   *
   * @schema ClusterPolicyV2Beta1SpecWebhookConfigurationMatchConditions#expression
   */
  readonly expression: string;

  /**
   * Name is an identifier for this match condition, used for strategic merging of MatchConditions,
   * as well as providing an identifier for logging purposes. A good name should be descriptive of
   * the associated expression.
   * Name must be a qualified name consisting of alphanumeric characters, '-', '_' or '.', and
   * must start and end with an alphanumeric character (e.g. 'MyName',  or 'my.name',  or
   * '123-abc', regex used for validation is '([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]') with an
   * optional DNS subdomain prefix and '/' (e.g. 'example.com/MyName')
   *
   * Required.
   *
   * @schema ClusterPolicyV2Beta1SpecWebhookConfigurationMatchConditions#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecWebhookConfigurationMatchConditions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecWebhookConfigurationMatchConditions(obj: ClusterPolicyV2Beta1SpecWebhookConfigurationMatchConditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'expression': obj.expression,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * APICall is an HTTP request to the Kubernetes API server, or other JSON web service.
 * The data returned is stored in the context with the name for the context entry.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesContextApiCall
 */
export interface ClusterPolicyV2Beta1SpecRulesContextApiCall {
  /**
   * The data object specifies the POST data sent to the server.
   * Only applicable when the method field is set to POST.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesContextApiCall#data
   */
  readonly data?: ClusterPolicyV2Beta1SpecRulesContextApiCallData[];

  /**
   * Default is an optional arbitrary JSON object that the context
   * value is set to, if the apiCall returns error.
   *
   * @default an optional arbitrary JSON object that the context
   * @schema ClusterPolicyV2Beta1SpecRulesContextApiCall#default
   */
  readonly default?: any;

  /**
   * JMESPath is an optional JSON Match Expression that can be used to
   * transform the JSON response returned from the server. For example
   * a JMESPath of "items | length(@)" applied to the API server response
   * for the URLPath "/apis/apps/v1/deployments" will return the total count
   * of deployments across all namespaces.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesContextApiCall#jmesPath
   */
  readonly jmesPath?: string;

  /**
   * Method is the HTTP request type (GET or POST). Defaults to GET.
   *
   * @default GET.
   * @schema ClusterPolicyV2Beta1SpecRulesContextApiCall#method
   */
  readonly method?: ClusterPolicyV2Beta1SpecRulesContextApiCallMethod;

  /**
   * Service is an API call to a JSON web service.
   * This is used for non-Kubernetes API server calls.
   * It's mutually exclusive with the URLPath field.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesContextApiCall#service
   */
  readonly service?: ClusterPolicyV2Beta1SpecRulesContextApiCallService;

  /**
   * URLPath is the URL path to be used in the HTTP GET or POST request to the
   * Kubernetes API server (e.g. "/api/v1/namespaces" or  "/apis/apps/v1/deployments").
   * The format required is the same format used by the `kubectl get --raw` command.
   * See https://kyverno.io/docs/writing-policies/external-data-sources/#variables-from-kubernetes-api-server-calls
   * for details.
   * It's mutually exclusive with the Service field.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesContextApiCall#urlPath
   */
  readonly urlPath?: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesContextApiCall' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesContextApiCall(obj: ClusterPolicyV2Beta1SpecRulesContextApiCall | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'data': obj.data?.map(y => toJson_ClusterPolicyV2Beta1SpecRulesContextApiCallData(y)),
    'default': obj.default,
    'jmesPath': obj.jmesPath,
    'method': obj.method,
    'service': toJson_ClusterPolicyV2Beta1SpecRulesContextApiCallService(obj.service),
    'urlPath': obj.urlPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap is the ConfigMap reference.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesContextConfigMap
 */
export interface ClusterPolicyV2Beta1SpecRulesContextConfigMap {
  /**
   * Name is the ConfigMap name.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesContextConfigMap#name
   */
  readonly name: string;

  /**
   * Namespace is the ConfigMap namespace.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesContextConfigMap#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesContextConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesContextConfigMap(obj: ClusterPolicyV2Beta1SpecRulesContextConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GlobalContextEntryReference is a reference to a cached global context entry.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesContextGlobalReference
 */
export interface ClusterPolicyV2Beta1SpecRulesContextGlobalReference {
  /**
   * JMESPath is an optional JSON Match Expression that can be used to
   * transform the JSON response returned from the server. For example
   * a JMESPath of "items | length(@)" applied to the API server response
   * for the URLPath "/apis/apps/v1/deployments" will return the total count
   * of deployments across all namespaces.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesContextGlobalReference#jmesPath
   */
  readonly jmesPath?: string;

  /**
   * Name of the global context entry
   *
   * @schema ClusterPolicyV2Beta1SpecRulesContextGlobalReference#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesContextGlobalReference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesContextGlobalReference(obj: ClusterPolicyV2Beta1SpecRulesContextGlobalReference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'jmesPath': obj.jmesPath,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ImageRegistry defines requests to an OCI/Docker V2 registry to fetch image
 * details.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesContextImageRegistry
 */
export interface ClusterPolicyV2Beta1SpecRulesContextImageRegistry {
  /**
   * ImageRegistryCredentials provides credentials that will be used for authentication with registry
   *
   * @schema ClusterPolicyV2Beta1SpecRulesContextImageRegistry#imageRegistryCredentials
   */
  readonly imageRegistryCredentials?: ClusterPolicyV2Beta1SpecRulesContextImageRegistryImageRegistryCredentials;

  /**
   * JMESPath is an optional JSON Match Expression that can be used to
   * transform the ImageData struct returned as a result of processing
   * the image reference.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesContextImageRegistry#jmesPath
   */
  readonly jmesPath?: string;

  /**
   * Reference is image reference to a container image in the registry.
   * Example: ghcr.io/kyverno/kyverno:latest
   *
   * @schema ClusterPolicyV2Beta1SpecRulesContextImageRegistry#reference
   */
  readonly reference: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesContextImageRegistry' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesContextImageRegistry(obj: ClusterPolicyV2Beta1SpecRulesContextImageRegistry | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'imageRegistryCredentials': toJson_ClusterPolicyV2Beta1SpecRulesContextImageRegistryImageRegistryCredentials(obj.imageRegistryCredentials),
    'jmesPath': obj.jmesPath,
    'reference': obj.reference,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Variable defines an arbitrary JMESPath context variable that can be defined inline.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesContextVariable
 */
export interface ClusterPolicyV2Beta1SpecRulesContextVariable {
  /**
   * Default is an optional arbitrary JSON object that the variable may take if the JMESPath
   * expression evaluates to nil
   *
   * @default an optional arbitrary JSON object that the variable may take if the JMESPath
   * @schema ClusterPolicyV2Beta1SpecRulesContextVariable#default
   */
  readonly default?: any;

  /**
   * JMESPath is an optional JMESPath Expression that can be used to
   * transform the variable.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesContextVariable#jmesPath
   */
  readonly jmesPath?: string;

  /**
   * Value is any arbitrary JSON object representable in YAML or JSON form.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesContextVariable#value
   */
  readonly value?: any;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesContextVariable' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesContextVariable(obj: ClusterPolicyV2Beta1SpecRulesContextVariable | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'default': obj.default,
    'jmesPath': obj.jmesPath,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceFilter allow users to "AND" or "OR" between resources
 *
 * @schema ClusterPolicyV2Beta1SpecRulesExcludeAll
 */
export interface ClusterPolicyV2Beta1SpecRulesExcludeAll {
  /**
   * ClusterRoles is the list of cluster-wide role names for the user.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesExcludeAll#clusterRoles
   */
  readonly clusterRoles?: string[];

  /**
   * ResourceDescription contains information about the resource being created or modified.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesExcludeAll#resources
   */
  readonly resources?: ClusterPolicyV2Beta1SpecRulesExcludeAllResources;

  /**
   * Roles is the list of namespaced role names for the user.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesExcludeAll#roles
   */
  readonly roles?: string[];

  /**
   * Subjects is the list of subject names like users, user groups, and service accounts.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesExcludeAll#subjects
   */
  readonly subjects?: ClusterPolicyV2Beta1SpecRulesExcludeAllSubjects[];

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesExcludeAll' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesExcludeAll(obj: ClusterPolicyV2Beta1SpecRulesExcludeAll | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterRoles': obj.clusterRoles?.map(y => y),
    'resources': toJson_ClusterPolicyV2Beta1SpecRulesExcludeAllResources(obj.resources),
    'roles': obj.roles?.map(y => y),
    'subjects': obj.subjects?.map(y => toJson_ClusterPolicyV2Beta1SpecRulesExcludeAllSubjects(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceFilter allow users to "AND" or "OR" between resources
 *
 * @schema ClusterPolicyV2Beta1SpecRulesExcludeAny
 */
export interface ClusterPolicyV2Beta1SpecRulesExcludeAny {
  /**
   * ClusterRoles is the list of cluster-wide role names for the user.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesExcludeAny#clusterRoles
   */
  readonly clusterRoles?: string[];

  /**
   * ResourceDescription contains information about the resource being created or modified.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesExcludeAny#resources
   */
  readonly resources?: ClusterPolicyV2Beta1SpecRulesExcludeAnyResources;

  /**
   * Roles is the list of namespaced role names for the user.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesExcludeAny#roles
   */
  readonly roles?: string[];

  /**
   * Subjects is the list of subject names like users, user groups, and service accounts.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesExcludeAny#subjects
   */
  readonly subjects?: ClusterPolicyV2Beta1SpecRulesExcludeAnySubjects[];

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesExcludeAny' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesExcludeAny(obj: ClusterPolicyV2Beta1SpecRulesExcludeAny | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterRoles': obj.clusterRoles?.map(y => y),
    'resources': toJson_ClusterPolicyV2Beta1SpecRulesExcludeAnyResources(obj.resources),
    'roles': obj.roles?.map(y => y),
    'subjects': obj.subjects?.map(y => toJson_ClusterPolicyV2Beta1SpecRulesExcludeAnySubjects(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Clone specifies the source resource used to populate each generated resource.
 * At most one of Data or Clone can be specified. If neither are provided, the generated
 * resource will be created with default data only.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesGenerateClone
 */
export interface ClusterPolicyV2Beta1SpecRulesGenerateClone {
  /**
   * Name specifies name of the resource.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerateClone#name
   */
  readonly name?: string;

  /**
   * Namespace specifies source resource namespace.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerateClone#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesGenerateClone' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesGenerateClone(obj: ClusterPolicyV2Beta1SpecRulesGenerateClone | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CloneList specifies the list of source resource used to populate each generated resource.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesGenerateCloneList
 */
export interface ClusterPolicyV2Beta1SpecRulesGenerateCloneList {
  /**
   * Kinds is a list of resource kinds.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerateCloneList#kinds
   */
  readonly kinds?: string[];

  /**
   * Namespace specifies source resource namespace.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerateCloneList#namespace
   */
  readonly namespace?: string;

  /**
   * Selector is a label selector. Label keys and values in `matchLabels`.
   * wildcard characters are not supported.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerateCloneList#selector
   */
  readonly selector?: ClusterPolicyV2Beta1SpecRulesGenerateCloneListSelector;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesGenerateCloneList' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesGenerateCloneList(obj: ClusterPolicyV2Beta1SpecRulesGenerateCloneList | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kinds': obj.kinds?.map(y => y),
    'namespace': obj.namespace,
    'selector': toJson_ClusterPolicyV2Beta1SpecRulesGenerateCloneListSelector(obj.selector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeach
 */
export interface ClusterPolicyV2Beta1SpecRulesGenerateForeach {
  /**
   * APIVersion specifies resource apiVersion.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeach#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Clone specifies the source resource used to populate each generated resource.
   * At most one of Data or Clone can be specified. If neither are provided, the generated
   * resource will be created with default data only.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeach#clone
   */
  readonly clone?: ClusterPolicyV2Beta1SpecRulesGenerateForeachClone;

  /**
   * CloneList specifies the list of source resource used to populate each generated resource.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeach#cloneList
   */
  readonly cloneList?: ClusterPolicyV2Beta1SpecRulesGenerateForeachCloneList;

  /**
   * Context defines variables and data sources that can be used during rule execution.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeach#context
   */
  readonly context?: ClusterPolicyV2Beta1SpecRulesGenerateForeachContext[];

  /**
   * Data provides the resource declaration used to populate each generated resource.
   * At most one of Data or Clone must be specified. If neither are provided, the generated
   * resource will be created with default data only.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeach#data
   */
  readonly data?: any;

  /**
   * Kind specifies resource kind.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeach#kind
   */
  readonly kind?: string;

  /**
   * List specifies a JMESPath expression that results in one or more elements
   * to which the validation logic is applied.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeach#list
   */
  readonly list?: string;

  /**
   * Name specifies the resource name.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeach#name
   */
  readonly name?: string;

  /**
   * Namespace specifies resource namespace.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeach#namespace
   */
  readonly namespace?: string;

  /**
   * AnyAllConditions are used to determine if a policy rule should be applied by evaluating a
   * set of conditions. The declaration can contain nested `any` or `all` statements.
   * See: https://kyverno.io/docs/writing-policies/preconditions/
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeach#preconditions
   */
  readonly preconditions?: ClusterPolicyV2Beta1SpecRulesGenerateForeachPreconditions;

  /**
   * UID specifies the resource uid.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeach#uid
   */
  readonly uid?: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesGenerateForeach' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesGenerateForeach(obj: ClusterPolicyV2Beta1SpecRulesGenerateForeach | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'clone': toJson_ClusterPolicyV2Beta1SpecRulesGenerateForeachClone(obj.clone),
    'cloneList': toJson_ClusterPolicyV2Beta1SpecRulesGenerateForeachCloneList(obj.cloneList),
    'context': obj.context?.map(y => toJson_ClusterPolicyV2Beta1SpecRulesGenerateForeachContext(y)),
    'data': obj.data,
    'kind': obj.kind,
    'list': obj.list,
    'name': obj.name,
    'namespace': obj.namespace,
    'preconditions': toJson_ClusterPolicyV2Beta1SpecRulesGenerateForeachPreconditions(obj.preconditions),
    'uid': obj.uid,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceFilter allow users to "AND" or "OR" between resources
 *
 * @schema ClusterPolicyV2Beta1SpecRulesMatchAll
 */
export interface ClusterPolicyV2Beta1SpecRulesMatchAll {
  /**
   * ClusterRoles is the list of cluster-wide role names for the user.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMatchAll#clusterRoles
   */
  readonly clusterRoles?: string[];

  /**
   * ResourceDescription contains information about the resource being created or modified.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMatchAll#resources
   */
  readonly resources?: ClusterPolicyV2Beta1SpecRulesMatchAllResources;

  /**
   * Roles is the list of namespaced role names for the user.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMatchAll#roles
   */
  readonly roles?: string[];

  /**
   * Subjects is the list of subject names like users, user groups, and service accounts.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMatchAll#subjects
   */
  readonly subjects?: ClusterPolicyV2Beta1SpecRulesMatchAllSubjects[];

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesMatchAll' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesMatchAll(obj: ClusterPolicyV2Beta1SpecRulesMatchAll | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterRoles': obj.clusterRoles?.map(y => y),
    'resources': toJson_ClusterPolicyV2Beta1SpecRulesMatchAllResources(obj.resources),
    'roles': obj.roles?.map(y => y),
    'subjects': obj.subjects?.map(y => toJson_ClusterPolicyV2Beta1SpecRulesMatchAllSubjects(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceFilter allow users to "AND" or "OR" between resources
 *
 * @schema ClusterPolicyV2Beta1SpecRulesMatchAny
 */
export interface ClusterPolicyV2Beta1SpecRulesMatchAny {
  /**
   * ClusterRoles is the list of cluster-wide role names for the user.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMatchAny#clusterRoles
   */
  readonly clusterRoles?: string[];

  /**
   * ResourceDescription contains information about the resource being created or modified.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMatchAny#resources
   */
  readonly resources?: ClusterPolicyV2Beta1SpecRulesMatchAnyResources;

  /**
   * Roles is the list of namespaced role names for the user.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMatchAny#roles
   */
  readonly roles?: string[];

  /**
   * Subjects is the list of subject names like users, user groups, and service accounts.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMatchAny#subjects
   */
  readonly subjects?: ClusterPolicyV2Beta1SpecRulesMatchAnySubjects[];

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesMatchAny' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesMatchAny(obj: ClusterPolicyV2Beta1SpecRulesMatchAny | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterRoles': obj.clusterRoles?.map(y => y),
    'resources': toJson_ClusterPolicyV2Beta1SpecRulesMatchAnyResources(obj.resources),
    'roles': obj.roles?.map(y => y),
    'subjects': obj.subjects?.map(y => toJson_ClusterPolicyV2Beta1SpecRulesMatchAnySubjects(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ForEachMutation applies mutation rules to a list of sub-elements by creating a context for each entry in the list and looping over it to apply the specified logic.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesMutateForeach
 */
export interface ClusterPolicyV2Beta1SpecRulesMutateForeach {
  /**
   * Context defines variables and data sources that can be used during rule execution.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateForeach#context
   */
  readonly context?: ClusterPolicyV2Beta1SpecRulesMutateForeachContext[];

  /**
   * Foreach declares a nested foreach iterator
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateForeach#foreach
   */
  readonly foreach?: any;

  /**
   * List specifies a JMESPath expression that results in one or more elements
   * to which the validation logic is applied.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateForeach#list
   */
  readonly list?: string;

  /**
   * Order defines the iteration order on the list.
   * Can be Ascending to iterate from first to last element or Descending to iterate in from last to first element.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateForeach#order
   */
  readonly order?: ClusterPolicyV2Beta1SpecRulesMutateForeachOrder;

  /**
   * PatchStrategicMerge is a strategic merge patch used to modify resources.
   * See https://kubernetes.io/docs/tasks/manage-kubernetes-objects/update-api-object-kubectl-patch/
   * and https://kubectl.docs.kubernetes.io/references/kustomize/kustomization/patchesstrategicmerge/.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateForeach#patchStrategicMerge
   */
  readonly patchStrategicMerge?: any;

  /**
   * PatchesJSON6902 is a list of RFC 6902 JSON Patch declarations used to modify resources.
   * See https://tools.ietf.org/html/rfc6902 and https://kubectl.docs.kubernetes.io/references/kustomize/kustomization/patchesjson6902/.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateForeach#patchesJson6902
   */
  readonly patchesJson6902?: string;

  /**
   * AnyAllConditions are used to determine if a policy rule should be applied by evaluating a
   * set of conditions. The declaration can contain nested `any` or `all` statements.
   * See: https://kyverno.io/docs/writing-policies/preconditions/
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateForeach#preconditions
   */
  readonly preconditions?: ClusterPolicyV2Beta1SpecRulesMutateForeachPreconditions;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesMutateForeach' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesMutateForeach(obj: ClusterPolicyV2Beta1SpecRulesMutateForeach | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'context': obj.context?.map(y => toJson_ClusterPolicyV2Beta1SpecRulesMutateForeachContext(y)),
    'foreach': obj.foreach,
    'list': obj.list,
    'order': obj.order,
    'patchStrategicMerge': obj.patchStrategicMerge,
    'patchesJson6902': obj.patchesJson6902,
    'preconditions': toJson_ClusterPolicyV2Beta1SpecRulesMutateForeachPreconditions(obj.preconditions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TargetResourceSpec defines targets for mutating existing resources.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesMutateTargets
 */
export interface ClusterPolicyV2Beta1SpecRulesMutateTargets {
  /**
   * APIVersion specifies resource apiVersion.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateTargets#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Context defines variables and data sources that can be used during rule execution.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateTargets#context
   */
  readonly context?: ClusterPolicyV2Beta1SpecRulesMutateTargetsContext[];

  /**
   * Kind specifies resource kind.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateTargets#kind
   */
  readonly kind?: string;

  /**
   * Name specifies the resource name.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateTargets#name
   */
  readonly name?: string;

  /**
   * Namespace specifies resource namespace.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateTargets#namespace
   */
  readonly namespace?: string;

  /**
   * Preconditions are used to determine if a policy rule should be applied by evaluating a
   * set of conditions. The declaration can contain nested `any` or `all` statements. A direct list
   * of conditions (without `any` or `all` statements is supported for backwards compatibility but
   * will be deprecated in the next major release.
   * See: https://kyverno.io/docs/writing-policies/preconditions/
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateTargets#preconditions
   */
  readonly preconditions?: any;

  /**
   * Selector allows you to select target resources with their labels.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateTargets#selector
   */
  readonly selector?: ClusterPolicyV2Beta1SpecRulesMutateTargetsSelector;

  /**
   * UID specifies the resource uid.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateTargets#uid
   */
  readonly uid?: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesMutateTargets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesMutateTargets(obj: ClusterPolicyV2Beta1SpecRulesMutateTargets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'context': obj.context?.map(y => toJson_ClusterPolicyV2Beta1SpecRulesMutateTargetsContext(y)),
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
    'preconditions': obj.preconditions,
    'selector': toJson_ClusterPolicyV2Beta1SpecRulesMutateTargetsSelector(obj.selector),
    'uid': obj.uid,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterPolicyV2Beta1SpecRulesPreconditionsAll
 */
export interface ClusterPolicyV2Beta1SpecRulesPreconditionsAll {
  /**
   * Key is the context entry (using JMESPath) for conditional rule evaluation.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesPreconditionsAll#key
   */
  readonly key?: any;

  /**
   * Message is an optional display message
   *
   * @schema ClusterPolicyV2Beta1SpecRulesPreconditionsAll#message
   */
  readonly message?: string;

  /**
   * Operator is the conditional operation to perform. Valid operators are:
   * Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
   * GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
   * DurationLessThanOrEquals, DurationLessThan
   *
   * @schema ClusterPolicyV2Beta1SpecRulesPreconditionsAll#operator
   */
  readonly operator?: ClusterPolicyV2Beta1SpecRulesPreconditionsAllOperator;

  /**
   * Value is the conditional value, or set of values. The values can be fixed set
   * or can be variables declared using JMESPath.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesPreconditionsAll#value
   */
  readonly value?: any;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesPreconditionsAll' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesPreconditionsAll(obj: ClusterPolicyV2Beta1SpecRulesPreconditionsAll | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'message': obj.message,
    'operator': obj.operator,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterPolicyV2Beta1SpecRulesPreconditionsAny
 */
export interface ClusterPolicyV2Beta1SpecRulesPreconditionsAny {
  /**
   * Key is the context entry (using JMESPath) for conditional rule evaluation.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesPreconditionsAny#key
   */
  readonly key?: any;

  /**
   * Message is an optional display message
   *
   * @schema ClusterPolicyV2Beta1SpecRulesPreconditionsAny#message
   */
  readonly message?: string;

  /**
   * Operator is the conditional operation to perform. Valid operators are:
   * Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
   * GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
   * DurationLessThanOrEquals, DurationLessThan
   *
   * @schema ClusterPolicyV2Beta1SpecRulesPreconditionsAny#operator
   */
  readonly operator?: ClusterPolicyV2Beta1SpecRulesPreconditionsAnyOperator;

  /**
   * Value is the conditional value, or set of values. The values can be fixed set
   * or can be variables declared using JMESPath.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesPreconditionsAny#value
   */
  readonly value?: any;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesPreconditionsAny' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesPreconditionsAny(obj: ClusterPolicyV2Beta1SpecRulesPreconditionsAny | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'message': obj.message,
    'operator': obj.operator,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CEL allows validation checks using the Common Expression Language (https://kubernetes.io/docs/reference/using-api/cel/).
 *
 * @schema ClusterPolicyV2Beta1SpecRulesValidateCel
 */
export interface ClusterPolicyV2Beta1SpecRulesValidateCel {
  /**
   * AuditAnnotations contains CEL expressions which are used to produce audit annotations for the audit event of the API request.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateCel#auditAnnotations
   */
  readonly auditAnnotations?: ClusterPolicyV2Beta1SpecRulesValidateCelAuditAnnotations[];

  /**
   * Expressions is a list of CELExpression types.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateCel#expressions
   */
  readonly expressions?: ClusterPolicyV2Beta1SpecRulesValidateCelExpressions[];

  /**
   * ParamKind is a tuple of Group Kind and Version.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateCel#paramKind
   */
  readonly paramKind?: ClusterPolicyV2Beta1SpecRulesValidateCelParamKind;

  /**
   * ParamRef references a parameter resource.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateCel#paramRef
   */
  readonly paramRef?: ClusterPolicyV2Beta1SpecRulesValidateCelParamRef;

  /**
   * Variables contain definitions of variables that can be used in composition of other expressions.
   * Each variable is defined as a named CEL expression.
   * The variables defined here will be available under `variables` in other expressions of the policy.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateCel#variables
   */
  readonly variables?: ClusterPolicyV2Beta1SpecRulesValidateCelVariables[];

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesValidateCel' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesValidateCel(obj: ClusterPolicyV2Beta1SpecRulesValidateCel | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auditAnnotations': obj.auditAnnotations?.map(y => toJson_ClusterPolicyV2Beta1SpecRulesValidateCelAuditAnnotations(y)),
    'expressions': obj.expressions?.map(y => toJson_ClusterPolicyV2Beta1SpecRulesValidateCelExpressions(y)),
    'paramKind': toJson_ClusterPolicyV2Beta1SpecRulesValidateCelParamKind(obj.paramKind),
    'paramRef': toJson_ClusterPolicyV2Beta1SpecRulesValidateCelParamRef(obj.paramRef),
    'variables': obj.variables?.map(y => toJson_ClusterPolicyV2Beta1SpecRulesValidateCelVariables(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Deny defines conditions used to pass or fail a validation rule.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesValidateDeny
 */
export interface ClusterPolicyV2Beta1SpecRulesValidateDeny {
  /**
   * Multiple conditions can be declared under an `any` or `all` statement.
   * See: https://kyverno.io/docs/writing-policies/validate/#deny-rules
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateDeny#conditions
   */
  readonly conditions?: ClusterPolicyV2Beta1SpecRulesValidateDenyConditions;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesValidateDeny' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesValidateDeny(obj: ClusterPolicyV2Beta1SpecRulesValidateDeny | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conditions': toJson_ClusterPolicyV2Beta1SpecRulesValidateDenyConditions(obj.conditions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FailureAction defines if a validation policy rule violation should block
 * the admission review request (Enforce), or allow (Audit) the admission review request
 * and report an error in a policy report. Optional.
 * Allowed values are Audit or Enforce.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesValidateFailureAction
 */
export enum ClusterPolicyV2Beta1SpecRulesValidateFailureAction {
  /** Audit */
  AUDIT = "Audit",
  /** Enforce */
  ENFORCE = "Enforce",
}

/**
 * @schema ClusterPolicyV2Beta1SpecRulesValidateFailureActionOverrides
 */
export interface ClusterPolicyV2Beta1SpecRulesValidateFailureActionOverrides {
  /**
   * ValidationFailureAction defines the policy validation failure action
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateFailureActionOverrides#action
   */
  readonly action?: ClusterPolicyV2Beta1SpecRulesValidateFailureActionOverridesAction;

  /**
   * A label selector is a label query over a set of resources. The result of matchLabels and
   * matchExpressions are ANDed. An empty label selector matches all objects. A null
   * label selector matches no objects.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateFailureActionOverrides#namespaceSelector
   */
  readonly namespaceSelector?: ClusterPolicyV2Beta1SpecRulesValidateFailureActionOverridesNamespaceSelector;

  /**
   * @schema ClusterPolicyV2Beta1SpecRulesValidateFailureActionOverrides#namespaces
   */
  readonly namespaces?: string[];

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesValidateFailureActionOverrides' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesValidateFailureActionOverrides(obj: ClusterPolicyV2Beta1SpecRulesValidateFailureActionOverrides | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'namespaceSelector': toJson_ClusterPolicyV2Beta1SpecRulesValidateFailureActionOverridesNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ForEachValidation applies validate rules to a list of sub-elements by creating a context for each entry in the list and looping over it to apply the specified logic.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesValidateForeach
 */
export interface ClusterPolicyV2Beta1SpecRulesValidateForeach {
  /**
   * AnyPattern specifies list of validation patterns. At least one of the patterns
   * must be satisfied for the validation rule to succeed.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateForeach#anyPattern
   */
  readonly anyPattern?: any;

  /**
   * Context defines variables and data sources that can be used during rule execution.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateForeach#context
   */
  readonly context?: ClusterPolicyV2Beta1SpecRulesValidateForeachContext[];

  /**
   * Deny defines conditions used to pass or fail a validation rule.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateForeach#deny
   */
  readonly deny?: ClusterPolicyV2Beta1SpecRulesValidateForeachDeny;

  /**
   * ElementScope specifies whether to use the current list element as the scope for validation. Defaults to "true" if not specified.
   * When set to "false", "request.object" is used as the validation scope within the foreach
   * block to allow referencing other elements in the subtree.
   *
   * @default true" if not specified.
   * @schema ClusterPolicyV2Beta1SpecRulesValidateForeach#elementScope
   */
  readonly elementScope?: boolean;

  /**
   * Foreach declares a nested foreach iterator
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateForeach#foreach
   */
  readonly foreach?: any;

  /**
   * List specifies a JMESPath expression that results in one or more elements
   * to which the validation logic is applied.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateForeach#list
   */
  readonly list?: string;

  /**
   * Pattern specifies an overlay-style pattern used to check resources.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateForeach#pattern
   */
  readonly pattern?: any;

  /**
   * AnyAllConditions are used to determine if a policy rule should be applied by evaluating a
   * set of conditions. The declaration can contain nested `any` or `all` statements.
   * See: https://kyverno.io/docs/writing-policies/preconditions/
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateForeach#preconditions
   */
  readonly preconditions?: ClusterPolicyV2Beta1SpecRulesValidateForeachPreconditions;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesValidateForeach' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesValidateForeach(obj: ClusterPolicyV2Beta1SpecRulesValidateForeach | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'anyPattern': obj.anyPattern,
    'context': obj.context?.map(y => toJson_ClusterPolicyV2Beta1SpecRulesValidateForeachContext(y)),
    'deny': toJson_ClusterPolicyV2Beta1SpecRulesValidateForeachDeny(obj.deny),
    'elementScope': obj.elementScope,
    'foreach': obj.foreach,
    'list': obj.list,
    'pattern': obj.pattern,
    'preconditions': toJson_ClusterPolicyV2Beta1SpecRulesValidateForeachPreconditions(obj.preconditions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Manifest specifies conditions for manifest verification
 *
 * @schema ClusterPolicyV2Beta1SpecRulesValidateManifests
 */
export interface ClusterPolicyV2Beta1SpecRulesValidateManifests {
  /**
   * AnnotationDomain is custom domain of annotation for message and signature. Default is "cosign.sigstore.dev".
   *
   * @default cosign.sigstore.dev".
   * @schema ClusterPolicyV2Beta1SpecRulesValidateManifests#annotationDomain
   */
  readonly annotationDomain?: string;

  /**
   * Attestors specified the required attestors (i.e. authorities)
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateManifests#attestors
   */
  readonly attestors?: ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestors[];

  /**
   * DryRun configuration
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateManifests#dryRun
   */
  readonly dryRun?: ClusterPolicyV2Beta1SpecRulesValidateManifestsDryRun;

  /**
   * Fields which will be ignored while comparing manifests.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateManifests#ignoreFields
   */
  readonly ignoreFields?: ClusterPolicyV2Beta1SpecRulesValidateManifestsIgnoreFields[];

  /**
   * Repository is an optional alternate OCI repository to use for resource bundle reference.
   * The repository can be overridden per Attestor or Attestation.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateManifests#repository
   */
  readonly repository?: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesValidateManifests' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesValidateManifests(obj: ClusterPolicyV2Beta1SpecRulesValidateManifests | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotationDomain': obj.annotationDomain,
    'attestors': obj.attestors?.map(y => toJson_ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestors(y)),
    'dryRun': toJson_ClusterPolicyV2Beta1SpecRulesValidateManifestsDryRun(obj.dryRun),
    'ignoreFields': obj.ignoreFields?.map(y => toJson_ClusterPolicyV2Beta1SpecRulesValidateManifestsIgnoreFields(y)),
    'repository': obj.repository,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PodSecurity applies exemptions for Kubernetes Pod Security admission
 * by specifying exclusions for Pod Security Standards controls.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesValidatePodSecurity
 */
export interface ClusterPolicyV2Beta1SpecRulesValidatePodSecurity {
  /**
   * Exclude specifies the Pod Security Standard controls to be excluded.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidatePodSecurity#exclude
   */
  readonly exclude?: ClusterPolicyV2Beta1SpecRulesValidatePodSecurityExclude[];

  /**
   * Level defines the Pod Security Standard level to be applied to workloads.
   * Allowed values are privileged, baseline, and restricted.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidatePodSecurity#level
   */
  readonly level?: ClusterPolicyV2Beta1SpecRulesValidatePodSecurityLevel;

  /**
   * Version defines the Pod Security Standard versions that Kubernetes supports.
   * Allowed values are v1.19, v1.20, v1.21, v1.22, v1.23, v1.24, v1.25, v1.26, v1.27, v1.28, v1.29, latest. Defaults to latest.
   *
   * @default latest.
   * @schema ClusterPolicyV2Beta1SpecRulesValidatePodSecurity#version
   */
  readonly version?: ClusterPolicyV2Beta1SpecRulesValidatePodSecurityVersion;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesValidatePodSecurity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesValidatePodSecurity(obj: ClusterPolicyV2Beta1SpecRulesValidatePodSecurity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exclude': obj.exclude?.map(y => toJson_ClusterPolicyV2Beta1SpecRulesValidatePodSecurityExclude(y)),
    'level': obj.level,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Attestation are checks for signed in-toto Statements that are used to verify the image.
 * See https://github.com/in-toto/attestation. Kyverno fetches signed attestations from the
 * OCI registry and decodes them into a list of Statements.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestations
 */
export interface ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestations {
  /**
   * Attestors specify the required attestors (i.e. authorities).
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestations#attestors
   */
  readonly attestors?: ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestors[];

  /**
   * Conditions are used to verify attributes within a Predicate. If no Conditions are specified
   * the attestation check is satisfied as long there are predicates that match the predicate type.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestations#conditions
   */
  readonly conditions?: ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsConditions[];

  /**
   * Name is the variable name.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestations#name
   */
  readonly name?: string;

  /**
   * Deprecated in favour of 'Type', to be removed soon
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestations#predicateType
   */
  readonly predicateType?: string;

  /**
   * Type defines the type of attestation contained within the Statement.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestations#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestations(obj: ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'attestors': obj.attestors?.map(y => toJson_ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestors(y)),
    'conditions': obj.conditions?.map(y => toJson_ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsConditions(y)),
    'name': obj.name,
    'predicateType': obj.predicateType,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestors
 */
export interface ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestors {
  /**
   * Count specifies the required number of entries that must match. If the count is null, all entries must match
   * (a logical AND). If the count is 1, at least one entry must match (a logical OR). If the count contains a
   * value N, then N must be less than or equal to the size of entries, and at least N entries must match.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestors#count
   */
  readonly count?: number;

  /**
   * Entries contains the available attestors. An attestor can be a static key,
   * attributes for keyless verification, or a nested attestor declaration.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestors#entries
   */
  readonly entries?: ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntries[];

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestors' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestors(obj: ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'count': obj.count,
    'entries': obj.entries?.map(y => toJson_ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntries(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Allowed values are Audit or Enforce.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesFailureAction
 */
export enum ClusterPolicyV2Beta1SpecRulesVerifyImagesFailureAction {
  /** Audit */
  AUDIT = "Audit",
  /** Enforce */
  ENFORCE = "Enforce",
}

/**
 * ImageRegistryCredentials provides credentials that will be used for authentication with registry
 *
 * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesImageRegistryCredentials
 */
export interface ClusterPolicyV2Beta1SpecRulesVerifyImagesImageRegistryCredentials {
  /**
   * AllowInsecureRegistry allows insecure access to a registry.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesImageRegistryCredentials#allowInsecureRegistry
   */
  readonly allowInsecureRegistry?: boolean;

  /**
   * Providers specifies a list of OCI Registry names, whose authentication providers are provided.
   * It can be of one of these values: default,google,azure,amazon,github.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesImageRegistryCredentials#providers
   */
  readonly providers?: ClusterPolicyV2Beta1SpecRulesVerifyImagesImageRegistryCredentialsProviders[];

  /**
   * Secrets specifies a list of secrets that are provided for credentials.
   * Secrets must live in the Kyverno namespace.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesImageRegistryCredentials#secrets
   */
  readonly secrets?: string[];

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesVerifyImagesImageRegistryCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesVerifyImagesImageRegistryCredentials(obj: ClusterPolicyV2Beta1SpecRulesVerifyImagesImageRegistryCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowInsecureRegistry': obj.allowInsecureRegistry,
    'providers': obj.providers?.map(y => y),
    'secrets': obj.secrets?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Type specifies the method of signature validation. The allowed options
 * are Cosign and Notary. By default Cosign is used if a type is not specified.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesType
 */
export enum ClusterPolicyV2Beta1SpecRulesVerifyImagesType {
  /** Cosign */
  COSIGN = "Cosign",
  /** SigstoreBundle */
  SIGSTORE_BUNDLE = "SigstoreBundle",
  /** Notary */
  NOTARY = "Notary",
}

/**
 * Validation checks conditions across multiple image
 * verification attestations or context entries
 *
 * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesValidate
 */
export interface ClusterPolicyV2Beta1SpecRulesVerifyImagesValidate {
  /**
   * Deny defines conditions used to pass or fail a validation rule.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesValidate#deny
   */
  readonly deny?: ClusterPolicyV2Beta1SpecRulesVerifyImagesValidateDeny;

  /**
   * Message specifies a custom message to be displayed on failure.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesValidate#message
   */
  readonly message?: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesVerifyImagesValidate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesVerifyImagesValidate(obj: ClusterPolicyV2Beta1SpecRulesVerifyImagesValidate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deny': toJson_ClusterPolicyV2Beta1SpecRulesVerifyImagesValidateDeny(obj.deny),
    'message': obj.message,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterPolicyV2Beta1SpecValidationFailureActionOverridesNamespaceSelectorMatchExpressions
 */
export interface ClusterPolicyV2Beta1SpecValidationFailureActionOverridesNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterPolicyV2Beta1SpecValidationFailureActionOverridesNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterPolicyV2Beta1SpecValidationFailureActionOverridesNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterPolicyV2Beta1SpecValidationFailureActionOverridesNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecValidationFailureActionOverridesNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecValidationFailureActionOverridesNamespaceSelectorMatchExpressions(obj: ClusterPolicyV2Beta1SpecValidationFailureActionOverridesNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RequestData contains the HTTP POST data
 *
 * @schema ClusterPolicyV2Beta1SpecRulesContextApiCallData
 */
export interface ClusterPolicyV2Beta1SpecRulesContextApiCallData {
  /**
   * Key is a unique identifier for the data value
   *
   * @schema ClusterPolicyV2Beta1SpecRulesContextApiCallData#key
   */
  readonly key: string;

  /**
   * Value is the data value
   *
   * @schema ClusterPolicyV2Beta1SpecRulesContextApiCallData#value
   */
  readonly value: any;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesContextApiCallData' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesContextApiCallData(obj: ClusterPolicyV2Beta1SpecRulesContextApiCallData | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Method is the HTTP request type (GET or POST). Defaults to GET.
 *
 * @default GET.
 * @schema ClusterPolicyV2Beta1SpecRulesContextApiCallMethod
 */
export enum ClusterPolicyV2Beta1SpecRulesContextApiCallMethod {
  /** GET */
  GET = "GET",
  /** POST */
  POST = "POST",
}

/**
 * Service is an API call to a JSON web service.
 * This is used for non-Kubernetes API server calls.
 * It's mutually exclusive with the URLPath field.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesContextApiCallService
 */
export interface ClusterPolicyV2Beta1SpecRulesContextApiCallService {
  /**
   * CABundle is a PEM encoded CA bundle which will be used to validate
   * the server certificate.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesContextApiCallService#caBundle
   */
  readonly caBundle?: string;

  /**
   * Headers is a list of optional HTTP headers to be included in the request.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesContextApiCallService#headers
   */
  readonly headers?: ClusterPolicyV2Beta1SpecRulesContextApiCallServiceHeaders[];

  /**
   * URL is the JSON web service URL. A typical form is
   * `https://{service}.{namespace}:{port}/{path}`.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesContextApiCallService#url
   */
  readonly url: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesContextApiCallService' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesContextApiCallService(obj: ClusterPolicyV2Beta1SpecRulesContextApiCallService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caBundle': obj.caBundle,
    'headers': obj.headers?.map(y => toJson_ClusterPolicyV2Beta1SpecRulesContextApiCallServiceHeaders(y)),
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ImageRegistryCredentials provides credentials that will be used for authentication with registry
 *
 * @schema ClusterPolicyV2Beta1SpecRulesContextImageRegistryImageRegistryCredentials
 */
export interface ClusterPolicyV2Beta1SpecRulesContextImageRegistryImageRegistryCredentials {
  /**
   * AllowInsecureRegistry allows insecure access to a registry.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesContextImageRegistryImageRegistryCredentials#allowInsecureRegistry
   */
  readonly allowInsecureRegistry?: boolean;

  /**
   * Providers specifies a list of OCI Registry names, whose authentication providers are provided.
   * It can be of one of these values: default,google,azure,amazon,github.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesContextImageRegistryImageRegistryCredentials#providers
   */
  readonly providers?: ClusterPolicyV2Beta1SpecRulesContextImageRegistryImageRegistryCredentialsProviders[];

  /**
   * Secrets specifies a list of secrets that are provided for credentials.
   * Secrets must live in the Kyverno namespace.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesContextImageRegistryImageRegistryCredentials#secrets
   */
  readonly secrets?: string[];

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesContextImageRegistryImageRegistryCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesContextImageRegistryImageRegistryCredentials(obj: ClusterPolicyV2Beta1SpecRulesContextImageRegistryImageRegistryCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowInsecureRegistry': obj.allowInsecureRegistry,
    'providers': obj.providers?.map(y => y),
    'secrets': obj.secrets?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceDescription contains information about the resource being created or modified.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesExcludeAllResources
 */
export interface ClusterPolicyV2Beta1SpecRulesExcludeAllResources {
  /**
   * Annotations is a  map of annotations (key-value pairs of type string). Annotation keys
   * and values support the wildcard characters "*" (matches zero or many characters) and
   * "?" (matches at least one character).
   *
   * @schema ClusterPolicyV2Beta1SpecRulesExcludeAllResources#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Kinds is a list of resource kinds.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesExcludeAllResources#kinds
   */
  readonly kinds?: string[];

  /**
   * Name is the name of the resource. The name supports wildcard characters
   * "*" (matches zero or many characters) and "?" (at least one character).
   * NOTE: "Name" is being deprecated in favor of "Names".
   *
   * @schema ClusterPolicyV2Beta1SpecRulesExcludeAllResources#name
   */
  readonly name?: string;

  /**
   * Names are the names of the resources. Each name supports wildcard characters
   * "*" (matches zero or many characters) and "?" (at least one character).
   *
   * @schema ClusterPolicyV2Beta1SpecRulesExcludeAllResources#names
   */
  readonly names?: string[];

  /**
   * NamespaceSelector is a label selector for the resource namespace. Label keys and values
   * in `matchLabels` support the wildcard characters `*` (matches zero or many characters)
   * and `?` (matches one character).Wildcards allows writing label selectors like
   * ["storage.k8s.io/*": "*"]. Note that using ["*" : "*"] matches any key and value but
   * does not match an empty label set.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesExcludeAllResources#namespaceSelector
   */
  readonly namespaceSelector?: ClusterPolicyV2Beta1SpecRulesExcludeAllResourcesNamespaceSelector;

  /**
   * Namespaces is a list of namespaces names. Each name supports wildcard characters
   * "*" (matches zero or many characters) and "?" (at least one character).
   *
   * @schema ClusterPolicyV2Beta1SpecRulesExcludeAllResources#namespaces
   */
  readonly namespaces?: string[];

  /**
   * Operations can contain values ["CREATE, "UPDATE", "CONNECT", "DELETE"], which are used to match a specific action.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesExcludeAllResources#operations
   */
  readonly operations?: ClusterPolicyV2Beta1SpecRulesExcludeAllResourcesOperations[];

  /**
   * Selector is a label selector. Label keys and values in `matchLabels` support the wildcard
   * characters `*` (matches zero or many characters) and `?` (matches one character).
   * Wildcards allows writing label selectors like ["storage.k8s.io/*": "*"]. Note that
   * using ["*" : "*"] matches any key and value but does not match an empty label set.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesExcludeAllResources#selector
   */
  readonly selector?: ClusterPolicyV2Beta1SpecRulesExcludeAllResourcesSelector;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesExcludeAllResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesExcludeAllResources(obj: ClusterPolicyV2Beta1SpecRulesExcludeAllResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'kinds': obj.kinds?.map(y => y),
    'name': obj.name,
    'names': obj.names?.map(y => y),
    'namespaceSelector': toJson_ClusterPolicyV2Beta1SpecRulesExcludeAllResourcesNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'operations': obj.operations?.map(y => y),
    'selector': toJson_ClusterPolicyV2Beta1SpecRulesExcludeAllResourcesSelector(obj.selector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Subject contains a reference to the object or user identities a role binding applies to.  This can either hold a direct API object reference,
 * or a value for non-objects such as user and group names.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesExcludeAllSubjects
 */
export interface ClusterPolicyV2Beta1SpecRulesExcludeAllSubjects {
  /**
   * APIGroup holds the API group of the referenced subject.
   * Defaults to "" for ServiceAccount subjects.
   * Defaults to "rbac.authorization.k8s.io" for User and Group subjects.
   *
   * @default for ServiceAccount subjects.
   * @schema ClusterPolicyV2Beta1SpecRulesExcludeAllSubjects#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind of object being referenced. Values defined by this API group are "User", "Group", and "ServiceAccount".
   * If the Authorizer does not recognized the kind value, the Authorizer should report an error.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesExcludeAllSubjects#kind
   */
  readonly kind: string;

  /**
   * Name of the object being referenced.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesExcludeAllSubjects#name
   */
  readonly name: string;

  /**
   * Namespace of the referenced object.  If the object kind is non-namespace, such as "User" or "Group", and this value is not empty
   * the Authorizer should report an error.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesExcludeAllSubjects#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesExcludeAllSubjects' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesExcludeAllSubjects(obj: ClusterPolicyV2Beta1SpecRulesExcludeAllSubjects | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceDescription contains information about the resource being created or modified.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesExcludeAnyResources
 */
export interface ClusterPolicyV2Beta1SpecRulesExcludeAnyResources {
  /**
   * Annotations is a  map of annotations (key-value pairs of type string). Annotation keys
   * and values support the wildcard characters "*" (matches zero or many characters) and
   * "?" (matches at least one character).
   *
   * @schema ClusterPolicyV2Beta1SpecRulesExcludeAnyResources#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Kinds is a list of resource kinds.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesExcludeAnyResources#kinds
   */
  readonly kinds?: string[];

  /**
   * Name is the name of the resource. The name supports wildcard characters
   * "*" (matches zero or many characters) and "?" (at least one character).
   * NOTE: "Name" is being deprecated in favor of "Names".
   *
   * @schema ClusterPolicyV2Beta1SpecRulesExcludeAnyResources#name
   */
  readonly name?: string;

  /**
   * Names are the names of the resources. Each name supports wildcard characters
   * "*" (matches zero or many characters) and "?" (at least one character).
   *
   * @schema ClusterPolicyV2Beta1SpecRulesExcludeAnyResources#names
   */
  readonly names?: string[];

  /**
   * NamespaceSelector is a label selector for the resource namespace. Label keys and values
   * in `matchLabels` support the wildcard characters `*` (matches zero or many characters)
   * and `?` (matches one character).Wildcards allows writing label selectors like
   * ["storage.k8s.io/*": "*"]. Note that using ["*" : "*"] matches any key and value but
   * does not match an empty label set.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesExcludeAnyResources#namespaceSelector
   */
  readonly namespaceSelector?: ClusterPolicyV2Beta1SpecRulesExcludeAnyResourcesNamespaceSelector;

  /**
   * Namespaces is a list of namespaces names. Each name supports wildcard characters
   * "*" (matches zero or many characters) and "?" (at least one character).
   *
   * @schema ClusterPolicyV2Beta1SpecRulesExcludeAnyResources#namespaces
   */
  readonly namespaces?: string[];

  /**
   * Operations can contain values ["CREATE, "UPDATE", "CONNECT", "DELETE"], which are used to match a specific action.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesExcludeAnyResources#operations
   */
  readonly operations?: ClusterPolicyV2Beta1SpecRulesExcludeAnyResourcesOperations[];

  /**
   * Selector is a label selector. Label keys and values in `matchLabels` support the wildcard
   * characters `*` (matches zero or many characters) and `?` (matches one character).
   * Wildcards allows writing label selectors like ["storage.k8s.io/*": "*"]. Note that
   * using ["*" : "*"] matches any key and value but does not match an empty label set.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesExcludeAnyResources#selector
   */
  readonly selector?: ClusterPolicyV2Beta1SpecRulesExcludeAnyResourcesSelector;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesExcludeAnyResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesExcludeAnyResources(obj: ClusterPolicyV2Beta1SpecRulesExcludeAnyResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'kinds': obj.kinds?.map(y => y),
    'name': obj.name,
    'names': obj.names?.map(y => y),
    'namespaceSelector': toJson_ClusterPolicyV2Beta1SpecRulesExcludeAnyResourcesNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'operations': obj.operations?.map(y => y),
    'selector': toJson_ClusterPolicyV2Beta1SpecRulesExcludeAnyResourcesSelector(obj.selector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Subject contains a reference to the object or user identities a role binding applies to.  This can either hold a direct API object reference,
 * or a value for non-objects such as user and group names.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesExcludeAnySubjects
 */
export interface ClusterPolicyV2Beta1SpecRulesExcludeAnySubjects {
  /**
   * APIGroup holds the API group of the referenced subject.
   * Defaults to "" for ServiceAccount subjects.
   * Defaults to "rbac.authorization.k8s.io" for User and Group subjects.
   *
   * @default for ServiceAccount subjects.
   * @schema ClusterPolicyV2Beta1SpecRulesExcludeAnySubjects#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind of object being referenced. Values defined by this API group are "User", "Group", and "ServiceAccount".
   * If the Authorizer does not recognized the kind value, the Authorizer should report an error.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesExcludeAnySubjects#kind
   */
  readonly kind: string;

  /**
   * Name of the object being referenced.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesExcludeAnySubjects#name
   */
  readonly name: string;

  /**
   * Namespace of the referenced object.  If the object kind is non-namespace, such as "User" or "Group", and this value is not empty
   * the Authorizer should report an error.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesExcludeAnySubjects#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesExcludeAnySubjects' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesExcludeAnySubjects(obj: ClusterPolicyV2Beta1SpecRulesExcludeAnySubjects | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector is a label selector. Label keys and values in `matchLabels`.
 * wildcard characters are not supported.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesGenerateCloneListSelector
 */
export interface ClusterPolicyV2Beta1SpecRulesGenerateCloneListSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerateCloneListSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterPolicyV2Beta1SpecRulesGenerateCloneListSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerateCloneListSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesGenerateCloneListSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesGenerateCloneListSelector(obj: ClusterPolicyV2Beta1SpecRulesGenerateCloneListSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterPolicyV2Beta1SpecRulesGenerateCloneListSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Clone specifies the source resource used to populate each generated resource.
 * At most one of Data or Clone can be specified. If neither are provided, the generated
 * resource will be created with default data only.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeachClone
 */
export interface ClusterPolicyV2Beta1SpecRulesGenerateForeachClone {
  /**
   * Name specifies name of the resource.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeachClone#name
   */
  readonly name?: string;

  /**
   * Namespace specifies source resource namespace.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeachClone#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesGenerateForeachClone' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesGenerateForeachClone(obj: ClusterPolicyV2Beta1SpecRulesGenerateForeachClone | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CloneList specifies the list of source resource used to populate each generated resource.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeachCloneList
 */
export interface ClusterPolicyV2Beta1SpecRulesGenerateForeachCloneList {
  /**
   * Kinds is a list of resource kinds.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeachCloneList#kinds
   */
  readonly kinds?: string[];

  /**
   * Namespace specifies source resource namespace.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeachCloneList#namespace
   */
  readonly namespace?: string;

  /**
   * Selector is a label selector. Label keys and values in `matchLabels`.
   * wildcard characters are not supported.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeachCloneList#selector
   */
  readonly selector?: ClusterPolicyV2Beta1SpecRulesGenerateForeachCloneListSelector;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesGenerateForeachCloneList' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesGenerateForeachCloneList(obj: ClusterPolicyV2Beta1SpecRulesGenerateForeachCloneList | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kinds': obj.kinds?.map(y => y),
    'namespace': obj.namespace,
    'selector': toJson_ClusterPolicyV2Beta1SpecRulesGenerateForeachCloneListSelector(obj.selector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ContextEntry adds variables and data sources to a rule Context. Either a
 * ConfigMap reference or a APILookup must be provided.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeachContext
 */
export interface ClusterPolicyV2Beta1SpecRulesGenerateForeachContext {
  /**
   * APICall is an HTTP request to the Kubernetes API server, or other JSON web service.
   * The data returned is stored in the context with the name for the context entry.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeachContext#apiCall
   */
  readonly apiCall?: ClusterPolicyV2Beta1SpecRulesGenerateForeachContextApiCall;

  /**
   * ConfigMap is the ConfigMap reference.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeachContext#configMap
   */
  readonly configMap?: ClusterPolicyV2Beta1SpecRulesGenerateForeachContextConfigMap;

  /**
   * GlobalContextEntryReference is a reference to a cached global context entry.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeachContext#globalReference
   */
  readonly globalReference?: ClusterPolicyV2Beta1SpecRulesGenerateForeachContextGlobalReference;

  /**
   * ImageRegistry defines requests to an OCI/Docker V2 registry to fetch image
   * details.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeachContext#imageRegistry
   */
  readonly imageRegistry?: ClusterPolicyV2Beta1SpecRulesGenerateForeachContextImageRegistry;

  /**
   * Name is the variable name.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeachContext#name
   */
  readonly name: string;

  /**
   * Variable defines an arbitrary JMESPath context variable that can be defined inline.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeachContext#variable
   */
  readonly variable?: ClusterPolicyV2Beta1SpecRulesGenerateForeachContextVariable;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesGenerateForeachContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesGenerateForeachContext(obj: ClusterPolicyV2Beta1SpecRulesGenerateForeachContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiCall': toJson_ClusterPolicyV2Beta1SpecRulesGenerateForeachContextApiCall(obj.apiCall),
    'configMap': toJson_ClusterPolicyV2Beta1SpecRulesGenerateForeachContextConfigMap(obj.configMap),
    'globalReference': toJson_ClusterPolicyV2Beta1SpecRulesGenerateForeachContextGlobalReference(obj.globalReference),
    'imageRegistry': toJson_ClusterPolicyV2Beta1SpecRulesGenerateForeachContextImageRegistry(obj.imageRegistry),
    'name': obj.name,
    'variable': toJson_ClusterPolicyV2Beta1SpecRulesGenerateForeachContextVariable(obj.variable),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AnyAllConditions are used to determine if a policy rule should be applied by evaluating a
 * set of conditions. The declaration can contain nested `any` or `all` statements.
 * See: https://kyverno.io/docs/writing-policies/preconditions/
 *
 * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeachPreconditions
 */
export interface ClusterPolicyV2Beta1SpecRulesGenerateForeachPreconditions {
  /**
   * AllConditions enable variable-based conditional rule execution. This is useful for
   * finer control of when an rule is applied. A condition can reference object data
   * using JMESPath notation.
   * Here, all of the conditions need to pass
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeachPreconditions#all
   */
  readonly all?: ClusterPolicyV2Beta1SpecRulesGenerateForeachPreconditionsAll[];

  /**
   * AnyConditions enable variable-based conditional rule execution. This is useful for
   * finer control of when an rule is applied. A condition can reference object data
   * using JMESPath notation.
   * Here, at least one of the conditions need to pass
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeachPreconditions#any
   */
  readonly any?: ClusterPolicyV2Beta1SpecRulesGenerateForeachPreconditionsAny[];

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesGenerateForeachPreconditions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesGenerateForeachPreconditions(obj: ClusterPolicyV2Beta1SpecRulesGenerateForeachPreconditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'all': obj.all?.map(y => toJson_ClusterPolicyV2Beta1SpecRulesGenerateForeachPreconditionsAll(y)),
    'any': obj.any?.map(y => toJson_ClusterPolicyV2Beta1SpecRulesGenerateForeachPreconditionsAny(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceDescription contains information about the resource being created or modified.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesMatchAllResources
 */
export interface ClusterPolicyV2Beta1SpecRulesMatchAllResources {
  /**
   * Annotations is a  map of annotations (key-value pairs of type string). Annotation keys
   * and values support the wildcard characters "*" (matches zero or many characters) and
   * "?" (matches at least one character).
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMatchAllResources#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Kinds is a list of resource kinds.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMatchAllResources#kinds
   */
  readonly kinds?: string[];

  /**
   * Name is the name of the resource. The name supports wildcard characters
   * "*" (matches zero or many characters) and "?" (at least one character).
   * NOTE: "Name" is being deprecated in favor of "Names".
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMatchAllResources#name
   */
  readonly name?: string;

  /**
   * Names are the names of the resources. Each name supports wildcard characters
   * "*" (matches zero or many characters) and "?" (at least one character).
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMatchAllResources#names
   */
  readonly names?: string[];

  /**
   * NamespaceSelector is a label selector for the resource namespace. Label keys and values
   * in `matchLabels` support the wildcard characters `*` (matches zero or many characters)
   * and `?` (matches one character).Wildcards allows writing label selectors like
   * ["storage.k8s.io/*": "*"]. Note that using ["*" : "*"] matches any key and value but
   * does not match an empty label set.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMatchAllResources#namespaceSelector
   */
  readonly namespaceSelector?: ClusterPolicyV2Beta1SpecRulesMatchAllResourcesNamespaceSelector;

  /**
   * Namespaces is a list of namespaces names. Each name supports wildcard characters
   * "*" (matches zero or many characters) and "?" (at least one character).
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMatchAllResources#namespaces
   */
  readonly namespaces?: string[];

  /**
   * Operations can contain values ["CREATE, "UPDATE", "CONNECT", "DELETE"], which are used to match a specific action.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMatchAllResources#operations
   */
  readonly operations?: ClusterPolicyV2Beta1SpecRulesMatchAllResourcesOperations[];

  /**
   * Selector is a label selector. Label keys and values in `matchLabels` support the wildcard
   * characters `*` (matches zero or many characters) and `?` (matches one character).
   * Wildcards allows writing label selectors like ["storage.k8s.io/*": "*"]. Note that
   * using ["*" : "*"] matches any key and value but does not match an empty label set.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMatchAllResources#selector
   */
  readonly selector?: ClusterPolicyV2Beta1SpecRulesMatchAllResourcesSelector;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesMatchAllResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesMatchAllResources(obj: ClusterPolicyV2Beta1SpecRulesMatchAllResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'kinds': obj.kinds?.map(y => y),
    'name': obj.name,
    'names': obj.names?.map(y => y),
    'namespaceSelector': toJson_ClusterPolicyV2Beta1SpecRulesMatchAllResourcesNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'operations': obj.operations?.map(y => y),
    'selector': toJson_ClusterPolicyV2Beta1SpecRulesMatchAllResourcesSelector(obj.selector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Subject contains a reference to the object or user identities a role binding applies to.  This can either hold a direct API object reference,
 * or a value for non-objects such as user and group names.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesMatchAllSubjects
 */
export interface ClusterPolicyV2Beta1SpecRulesMatchAllSubjects {
  /**
   * APIGroup holds the API group of the referenced subject.
   * Defaults to "" for ServiceAccount subjects.
   * Defaults to "rbac.authorization.k8s.io" for User and Group subjects.
   *
   * @default for ServiceAccount subjects.
   * @schema ClusterPolicyV2Beta1SpecRulesMatchAllSubjects#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind of object being referenced. Values defined by this API group are "User", "Group", and "ServiceAccount".
   * If the Authorizer does not recognized the kind value, the Authorizer should report an error.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMatchAllSubjects#kind
   */
  readonly kind: string;

  /**
   * Name of the object being referenced.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMatchAllSubjects#name
   */
  readonly name: string;

  /**
   * Namespace of the referenced object.  If the object kind is non-namespace, such as "User" or "Group", and this value is not empty
   * the Authorizer should report an error.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMatchAllSubjects#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesMatchAllSubjects' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesMatchAllSubjects(obj: ClusterPolicyV2Beta1SpecRulesMatchAllSubjects | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceDescription contains information about the resource being created or modified.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesMatchAnyResources
 */
export interface ClusterPolicyV2Beta1SpecRulesMatchAnyResources {
  /**
   * Annotations is a  map of annotations (key-value pairs of type string). Annotation keys
   * and values support the wildcard characters "*" (matches zero or many characters) and
   * "?" (matches at least one character).
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMatchAnyResources#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Kinds is a list of resource kinds.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMatchAnyResources#kinds
   */
  readonly kinds?: string[];

  /**
   * Name is the name of the resource. The name supports wildcard characters
   * "*" (matches zero or many characters) and "?" (at least one character).
   * NOTE: "Name" is being deprecated in favor of "Names".
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMatchAnyResources#name
   */
  readonly name?: string;

  /**
   * Names are the names of the resources. Each name supports wildcard characters
   * "*" (matches zero or many characters) and "?" (at least one character).
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMatchAnyResources#names
   */
  readonly names?: string[];

  /**
   * NamespaceSelector is a label selector for the resource namespace. Label keys and values
   * in `matchLabels` support the wildcard characters `*` (matches zero or many characters)
   * and `?` (matches one character).Wildcards allows writing label selectors like
   * ["storage.k8s.io/*": "*"]. Note that using ["*" : "*"] matches any key and value but
   * does not match an empty label set.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMatchAnyResources#namespaceSelector
   */
  readonly namespaceSelector?: ClusterPolicyV2Beta1SpecRulesMatchAnyResourcesNamespaceSelector;

  /**
   * Namespaces is a list of namespaces names. Each name supports wildcard characters
   * "*" (matches zero or many characters) and "?" (at least one character).
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMatchAnyResources#namespaces
   */
  readonly namespaces?: string[];

  /**
   * Operations can contain values ["CREATE, "UPDATE", "CONNECT", "DELETE"], which are used to match a specific action.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMatchAnyResources#operations
   */
  readonly operations?: ClusterPolicyV2Beta1SpecRulesMatchAnyResourcesOperations[];

  /**
   * Selector is a label selector. Label keys and values in `matchLabels` support the wildcard
   * characters `*` (matches zero or many characters) and `?` (matches one character).
   * Wildcards allows writing label selectors like ["storage.k8s.io/*": "*"]. Note that
   * using ["*" : "*"] matches any key and value but does not match an empty label set.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMatchAnyResources#selector
   */
  readonly selector?: ClusterPolicyV2Beta1SpecRulesMatchAnyResourcesSelector;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesMatchAnyResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesMatchAnyResources(obj: ClusterPolicyV2Beta1SpecRulesMatchAnyResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'kinds': obj.kinds?.map(y => y),
    'name': obj.name,
    'names': obj.names?.map(y => y),
    'namespaceSelector': toJson_ClusterPolicyV2Beta1SpecRulesMatchAnyResourcesNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'operations': obj.operations?.map(y => y),
    'selector': toJson_ClusterPolicyV2Beta1SpecRulesMatchAnyResourcesSelector(obj.selector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Subject contains a reference to the object or user identities a role binding applies to.  This can either hold a direct API object reference,
 * or a value for non-objects such as user and group names.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesMatchAnySubjects
 */
export interface ClusterPolicyV2Beta1SpecRulesMatchAnySubjects {
  /**
   * APIGroup holds the API group of the referenced subject.
   * Defaults to "" for ServiceAccount subjects.
   * Defaults to "rbac.authorization.k8s.io" for User and Group subjects.
   *
   * @default for ServiceAccount subjects.
   * @schema ClusterPolicyV2Beta1SpecRulesMatchAnySubjects#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind of object being referenced. Values defined by this API group are "User", "Group", and "ServiceAccount".
   * If the Authorizer does not recognized the kind value, the Authorizer should report an error.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMatchAnySubjects#kind
   */
  readonly kind: string;

  /**
   * Name of the object being referenced.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMatchAnySubjects#name
   */
  readonly name: string;

  /**
   * Namespace of the referenced object.  If the object kind is non-namespace, such as "User" or "Group", and this value is not empty
   * the Authorizer should report an error.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMatchAnySubjects#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesMatchAnySubjects' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesMatchAnySubjects(obj: ClusterPolicyV2Beta1SpecRulesMatchAnySubjects | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ContextEntry adds variables and data sources to a rule Context. Either a
 * ConfigMap reference or a APILookup must be provided.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesMutateForeachContext
 */
export interface ClusterPolicyV2Beta1SpecRulesMutateForeachContext {
  /**
   * APICall is an HTTP request to the Kubernetes API server, or other JSON web service.
   * The data returned is stored in the context with the name for the context entry.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateForeachContext#apiCall
   */
  readonly apiCall?: ClusterPolicyV2Beta1SpecRulesMutateForeachContextApiCall;

  /**
   * ConfigMap is the ConfigMap reference.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateForeachContext#configMap
   */
  readonly configMap?: ClusterPolicyV2Beta1SpecRulesMutateForeachContextConfigMap;

  /**
   * GlobalContextEntryReference is a reference to a cached global context entry.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateForeachContext#globalReference
   */
  readonly globalReference?: ClusterPolicyV2Beta1SpecRulesMutateForeachContextGlobalReference;

  /**
   * ImageRegistry defines requests to an OCI/Docker V2 registry to fetch image
   * details.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateForeachContext#imageRegistry
   */
  readonly imageRegistry?: ClusterPolicyV2Beta1SpecRulesMutateForeachContextImageRegistry;

  /**
   * Name is the variable name.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateForeachContext#name
   */
  readonly name: string;

  /**
   * Variable defines an arbitrary JMESPath context variable that can be defined inline.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateForeachContext#variable
   */
  readonly variable?: ClusterPolicyV2Beta1SpecRulesMutateForeachContextVariable;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesMutateForeachContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesMutateForeachContext(obj: ClusterPolicyV2Beta1SpecRulesMutateForeachContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiCall': toJson_ClusterPolicyV2Beta1SpecRulesMutateForeachContextApiCall(obj.apiCall),
    'configMap': toJson_ClusterPolicyV2Beta1SpecRulesMutateForeachContextConfigMap(obj.configMap),
    'globalReference': toJson_ClusterPolicyV2Beta1SpecRulesMutateForeachContextGlobalReference(obj.globalReference),
    'imageRegistry': toJson_ClusterPolicyV2Beta1SpecRulesMutateForeachContextImageRegistry(obj.imageRegistry),
    'name': obj.name,
    'variable': toJson_ClusterPolicyV2Beta1SpecRulesMutateForeachContextVariable(obj.variable),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Order defines the iteration order on the list.
 * Can be Ascending to iterate from first to last element or Descending to iterate in from last to first element.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesMutateForeachOrder
 */
export enum ClusterPolicyV2Beta1SpecRulesMutateForeachOrder {
  /** Ascending */
  ASCENDING = "Ascending",
  /** Descending */
  DESCENDING = "Descending",
}

/**
 * AnyAllConditions are used to determine if a policy rule should be applied by evaluating a
 * set of conditions. The declaration can contain nested `any` or `all` statements.
 * See: https://kyverno.io/docs/writing-policies/preconditions/
 *
 * @schema ClusterPolicyV2Beta1SpecRulesMutateForeachPreconditions
 */
export interface ClusterPolicyV2Beta1SpecRulesMutateForeachPreconditions {
  /**
   * AllConditions enable variable-based conditional rule execution. This is useful for
   * finer control of when an rule is applied. A condition can reference object data
   * using JMESPath notation.
   * Here, all of the conditions need to pass
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateForeachPreconditions#all
   */
  readonly all?: ClusterPolicyV2Beta1SpecRulesMutateForeachPreconditionsAll[];

  /**
   * AnyConditions enable variable-based conditional rule execution. This is useful for
   * finer control of when an rule is applied. A condition can reference object data
   * using JMESPath notation.
   * Here, at least one of the conditions need to pass
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateForeachPreconditions#any
   */
  readonly any?: ClusterPolicyV2Beta1SpecRulesMutateForeachPreconditionsAny[];

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesMutateForeachPreconditions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesMutateForeachPreconditions(obj: ClusterPolicyV2Beta1SpecRulesMutateForeachPreconditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'all': obj.all?.map(y => toJson_ClusterPolicyV2Beta1SpecRulesMutateForeachPreconditionsAll(y)),
    'any': obj.any?.map(y => toJson_ClusterPolicyV2Beta1SpecRulesMutateForeachPreconditionsAny(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ContextEntry adds variables and data sources to a rule Context. Either a
 * ConfigMap reference or a APILookup must be provided.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesMutateTargetsContext
 */
export interface ClusterPolicyV2Beta1SpecRulesMutateTargetsContext {
  /**
   * APICall is an HTTP request to the Kubernetes API server, or other JSON web service.
   * The data returned is stored in the context with the name for the context entry.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateTargetsContext#apiCall
   */
  readonly apiCall?: ClusterPolicyV2Beta1SpecRulesMutateTargetsContextApiCall;

  /**
   * ConfigMap is the ConfigMap reference.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateTargetsContext#configMap
   */
  readonly configMap?: ClusterPolicyV2Beta1SpecRulesMutateTargetsContextConfigMap;

  /**
   * GlobalContextEntryReference is a reference to a cached global context entry.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateTargetsContext#globalReference
   */
  readonly globalReference?: ClusterPolicyV2Beta1SpecRulesMutateTargetsContextGlobalReference;

  /**
   * ImageRegistry defines requests to an OCI/Docker V2 registry to fetch image
   * details.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateTargetsContext#imageRegistry
   */
  readonly imageRegistry?: ClusterPolicyV2Beta1SpecRulesMutateTargetsContextImageRegistry;

  /**
   * Name is the variable name.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateTargetsContext#name
   */
  readonly name: string;

  /**
   * Variable defines an arbitrary JMESPath context variable that can be defined inline.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateTargetsContext#variable
   */
  readonly variable?: ClusterPolicyV2Beta1SpecRulesMutateTargetsContextVariable;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesMutateTargetsContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesMutateTargetsContext(obj: ClusterPolicyV2Beta1SpecRulesMutateTargetsContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiCall': toJson_ClusterPolicyV2Beta1SpecRulesMutateTargetsContextApiCall(obj.apiCall),
    'configMap': toJson_ClusterPolicyV2Beta1SpecRulesMutateTargetsContextConfigMap(obj.configMap),
    'globalReference': toJson_ClusterPolicyV2Beta1SpecRulesMutateTargetsContextGlobalReference(obj.globalReference),
    'imageRegistry': toJson_ClusterPolicyV2Beta1SpecRulesMutateTargetsContextImageRegistry(obj.imageRegistry),
    'name': obj.name,
    'variable': toJson_ClusterPolicyV2Beta1SpecRulesMutateTargetsContextVariable(obj.variable),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector allows you to select target resources with their labels.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesMutateTargetsSelector
 */
export interface ClusterPolicyV2Beta1SpecRulesMutateTargetsSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateTargetsSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterPolicyV2Beta1SpecRulesMutateTargetsSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateTargetsSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesMutateTargetsSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesMutateTargetsSelector(obj: ClusterPolicyV2Beta1SpecRulesMutateTargetsSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterPolicyV2Beta1SpecRulesMutateTargetsSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Operator is the conditional operation to perform. Valid operators are:
 * Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
 * GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
 * DurationLessThanOrEquals, DurationLessThan
 *
 * @schema ClusterPolicyV2Beta1SpecRulesPreconditionsAllOperator
 */
export enum ClusterPolicyV2Beta1SpecRulesPreconditionsAllOperator {
  /** Equals */
  EQUALS = "Equals",
  /** NotEquals */
  NOT_EQUALS = "NotEquals",
  /** AnyIn */
  ANY_IN = "AnyIn",
  /** AllIn */
  ALL_IN = "AllIn",
  /** AnyNotIn */
  ANY_NOT_IN = "AnyNotIn",
  /** AllNotIn */
  ALL_NOT_IN = "AllNotIn",
  /** GreaterThanOrEquals */
  GREATER_THAN_OR_EQUALS = "GreaterThanOrEquals",
  /** GreaterThan */
  GREATER_THAN = "GreaterThan",
  /** LessThanOrEquals */
  LESS_THAN_OR_EQUALS = "LessThanOrEquals",
  /** LessThan */
  LESS_THAN = "LessThan",
  /** DurationGreaterThanOrEquals */
  DURATION_GREATER_THAN_OR_EQUALS = "DurationGreaterThanOrEquals",
  /** DurationGreaterThan */
  DURATION_GREATER_THAN = "DurationGreaterThan",
  /** DurationLessThanOrEquals */
  DURATION_LESS_THAN_OR_EQUALS = "DurationLessThanOrEquals",
  /** DurationLessThan */
  DURATION_LESS_THAN = "DurationLessThan",
}

/**
 * Operator is the conditional operation to perform. Valid operators are:
 * Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
 * GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
 * DurationLessThanOrEquals, DurationLessThan
 *
 * @schema ClusterPolicyV2Beta1SpecRulesPreconditionsAnyOperator
 */
export enum ClusterPolicyV2Beta1SpecRulesPreconditionsAnyOperator {
  /** Equals */
  EQUALS = "Equals",
  /** NotEquals */
  NOT_EQUALS = "NotEquals",
  /** AnyIn */
  ANY_IN = "AnyIn",
  /** AllIn */
  ALL_IN = "AllIn",
  /** AnyNotIn */
  ANY_NOT_IN = "AnyNotIn",
  /** AllNotIn */
  ALL_NOT_IN = "AllNotIn",
  /** GreaterThanOrEquals */
  GREATER_THAN_OR_EQUALS = "GreaterThanOrEquals",
  /** GreaterThan */
  GREATER_THAN = "GreaterThan",
  /** LessThanOrEquals */
  LESS_THAN_OR_EQUALS = "LessThanOrEquals",
  /** LessThan */
  LESS_THAN = "LessThan",
  /** DurationGreaterThanOrEquals */
  DURATION_GREATER_THAN_OR_EQUALS = "DurationGreaterThanOrEquals",
  /** DurationGreaterThan */
  DURATION_GREATER_THAN = "DurationGreaterThan",
  /** DurationLessThanOrEquals */
  DURATION_LESS_THAN_OR_EQUALS = "DurationLessThanOrEquals",
  /** DurationLessThan */
  DURATION_LESS_THAN = "DurationLessThan",
}

/**
 * AuditAnnotation describes how to produce an audit annotation for an API request.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesValidateCelAuditAnnotations
 */
export interface ClusterPolicyV2Beta1SpecRulesValidateCelAuditAnnotations {
  /**
   * key specifies the audit annotation key. The audit annotation keys of
   * a ValidatingAdmissionPolicy must be unique. The key must be a qualified
   * name ([A-Za-z0-9][-A-Za-z0-9_.]*) no more than 63 bytes in length.
   *
   * The key is combined with the resource name of the
   * ValidatingAdmissionPolicy to construct an audit annotation key:
   * "{ValidatingAdmissionPolicy name}/{key}".
   *
   * If an admission webhook uses the same resource name as this ValidatingAdmissionPolicy
   * and the same audit annotation key, the annotation key will be identical.
   * In this case, the first annotation written with the key will be included
   * in the audit event and all subsequent annotations with the same key
   * will be discarded.
   *
   * Required.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateCelAuditAnnotations#key
   */
  readonly key: string;

  /**
   * valueExpression represents the expression which is evaluated by CEL to
   * produce an audit annotation value. The expression must evaluate to either
   * a string or null value. If the expression evaluates to a string, the
   * audit annotation is included with the string value. If the expression
   * evaluates to null or empty string the audit annotation will be omitted.
   * The valueExpression may be no longer than 5kb in length.
   * If the result of the valueExpression is more than 10kb in length, it
   * will be truncated to 10kb.
   *
   * If multiple ValidatingAdmissionPolicyBinding resources match an
   * API request, then the valueExpression will be evaluated for
   * each binding. All unique values produced by the valueExpressions
   * will be joined together in a comma-separated list.
   *
   * Required.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateCelAuditAnnotations#valueExpression
   */
  readonly valueExpression: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesValidateCelAuditAnnotations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesValidateCelAuditAnnotations(obj: ClusterPolicyV2Beta1SpecRulesValidateCelAuditAnnotations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'valueExpression': obj.valueExpression,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Validation specifies the CEL expression which is used to apply the validation.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesValidateCelExpressions
 */
export interface ClusterPolicyV2Beta1SpecRulesValidateCelExpressions {
  /**
   * Expression represents the expression which will be evaluated by CEL.
   * ref: https://github.com/google/cel-spec
   * CEL expressions have access to the contents of the API request/response, organized into CEL variables as well as some other useful variables:
   *
   * - 'object' - The object from the incoming request. The value is null for DELETE requests.
   * - 'oldObject' - The existing object. The value is null for CREATE requests.
   * - 'request' - Attributes of the API request([ref](/pkg/apis/admission/types.go#AdmissionRequest)).
   * - 'params' - Parameter resource referred to by the policy binding being evaluated. Only populated if the policy has a ParamKind.
   * - 'namespaceObject' - The namespace object that the incoming object belongs to. The value is null for cluster-scoped resources.
   * - 'variables' - Map of composited variables, from its name to its lazily evaluated value.
   * For example, a variable named 'foo' can be accessed as 'variables.foo'.
   * - 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
   * See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
   * - 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
   * request resource.
   *
   * The `apiVersion`, `kind`, `metadata.name` and `metadata.generateName` are always accessible from the root of the
   * object. No other metadata properties are accessible.
   *
   * Only property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible.
   * Accessible property names are escaped according to the following rules when accessed in the expression:
   * - '__' escapes to '__underscores__'
   * - '.' escapes to '__dot__'
   * - '-' escapes to '__dash__'
   * - '/' escapes to '__slash__'
   * - Property names that exactly match a CEL RESERVED keyword escape to '__{keyword}__'. The keywords are:
   * "true", "false", "null", "in", "as", "break", "const", "continue", "else", "for", "function", "if",
   * "import", "let", "loop", "package", "namespace", "return".
   * Examples:
   * - Expression accessing a property named "namespace": {"Expression": "object.__namespace__ > 0"}
   * - Expression accessing a property named "x-prop": {"Expression": "object.x__dash__prop > 0"}
   * - Expression accessing a property named "redact__d": {"Expression": "object.redact__underscores__d > 0"}
   *
   * Equality on arrays with list type of 'set' or 'map' ignores element order, i.e. [1, 2] == [2, 1].
   * Concatenation on arrays with x-kubernetes-list-type use the semantics of the list type:
   * - 'set': `X + Y` performs a union where the array positions of all elements in `X` are preserved and
   * non-intersecting elements in `Y` are appended, retaining their partial order.
   * - 'map': `X + Y` performs a merge where the array positions of all keys in `X` are preserved but the values
   * are overwritten by values in `Y` when the key sets of `X` and `Y` intersect. Elements in `Y` with
   * non-intersecting keys are appended, retaining their partial order.
   * Required.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateCelExpressions#expression
   */
  readonly expression: string;

  /**
   * Message represents the message displayed when validation fails. The message is required if the Expression contains
   * line breaks. The message must not contain line breaks.
   * If unset, the message is "failed rule: {Rule}".
   * e.g. "must be a URL with the host matching spec.host"
   * If the Expression contains line breaks. Message is required.
   * The message must not contain line breaks.
   * If unset, the message is "failed Expression: {Expression}".
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateCelExpressions#message
   */
  readonly message?: string;

  /**
   * messageExpression declares a CEL expression that evaluates to the validation failure message that is returned when this rule fails.
   * Since messageExpression is used as a failure message, it must evaluate to a string.
   * If both message and messageExpression are present on a validation, then messageExpression will be used if validation fails.
   * If messageExpression results in a runtime error, the runtime error is logged, and the validation failure message is produced
   * as if the messageExpression field were unset. If messageExpression evaluates to an empty string, a string with only spaces, or a string
   * that contains line breaks, then the validation failure message will also be produced as if the messageExpression field were unset, and
   * the fact that messageExpression produced an empty string/string with only spaces/string with line breaks will be logged.
   * messageExpression has access to all the same variables as the `expression` except for 'authorizer' and 'authorizer.requestResource'.
   * Example:
   * "object.x must be less than max ("+string(params.max)+")"
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateCelExpressions#messageExpression
   */
  readonly messageExpression?: string;

  /**
   * Reason represents a machine-readable description of why this validation failed.
   * If this is the first validation in the list to fail, this reason, as well as the
   * corresponding HTTP response code, are used in the
   * HTTP response to the client.
   * The currently supported reasons are: "Unauthorized", "Forbidden", "Invalid", "RequestEntityTooLarge".
   * If not set, StatusReasonInvalid is used in the response to the client.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateCelExpressions#reason
   */
  readonly reason?: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesValidateCelExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesValidateCelExpressions(obj: ClusterPolicyV2Beta1SpecRulesValidateCelExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'expression': obj.expression,
    'message': obj.message,
    'messageExpression': obj.messageExpression,
    'reason': obj.reason,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ParamKind is a tuple of Group Kind and Version.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesValidateCelParamKind
 */
export interface ClusterPolicyV2Beta1SpecRulesValidateCelParamKind {
  /**
   * APIVersion is the API group version the resources belong to.
   * In format of "group/version".
   * Required.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateCelParamKind#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Kind is the API kind the resources belong to.
   * Required.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateCelParamKind#kind
   */
  readonly kind?: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesValidateCelParamKind' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesValidateCelParamKind(obj: ClusterPolicyV2Beta1SpecRulesValidateCelParamKind | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'kind': obj.kind,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ParamRef references a parameter resource.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesValidateCelParamRef
 */
export interface ClusterPolicyV2Beta1SpecRulesValidateCelParamRef {
  /**
   * name is the name of the resource being referenced.
   *
   * One of `name` or `selector` must be set, but `name` and `selector` are
   * mutually exclusive properties. If one is set, the other must be unset.
   *
   * A single parameter used for all admission requests can be configured
   * by setting the `name` field, leaving `selector` blank, and setting namespace
   * if `paramKind` is namespace-scoped.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateCelParamRef#name
   */
  readonly name?: string;

  /**
   * namespace is the namespace of the referenced resource. Allows limiting
   * the search for params to a specific namespace. Applies to both `name` and
   * `selector` fields.
   *
   * A per-namespace parameter may be used by specifying a namespace-scoped
   * `paramKind` in the policy and leaving this field empty.
   *
   * - If `paramKind` is cluster-scoped, this field MUST be unset. Setting this
   * field results in a configuration error.
   *
   * - If `paramKind` is namespace-scoped, the namespace of the object being
   * evaluated for admission will be used when this field is left unset. Take
   * care that if this is left empty the binding must not match any cluster-scoped
   * resources, which will result in an error.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateCelParamRef#namespace
   */
  readonly namespace?: string;

  /**
   * `parameterNotFoundAction` controls the behavior of the binding when the resource
   * exists, and name or selector is valid, but there are no parameters
   * matched by the binding. If the value is set to `Allow`, then no
   * matched parameters will be treated as successful validation by the binding.
   * If set to `Deny`, then no matched parameters will be subject to the
   * `failurePolicy` of the policy.
   *
   * Allowed values are `Allow` or `Deny`
   *
   * Required
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateCelParamRef#parameterNotFoundAction
   */
  readonly parameterNotFoundAction?: string;

  /**
   * selector can be used to match multiple param objects based on their labels.
   * Supply selector: {} to match all resources of the ParamKind.
   *
   * If multiple params are found, they are all evaluated with the policy expressions
   * and the results are ANDed together.
   *
   * One of `name` or `selector` must be set, but `name` and `selector` are
   * mutually exclusive properties. If one is set, the other must be unset.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateCelParamRef#selector
   */
  readonly selector?: ClusterPolicyV2Beta1SpecRulesValidateCelParamRefSelector;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesValidateCelParamRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesValidateCelParamRef(obj: ClusterPolicyV2Beta1SpecRulesValidateCelParamRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
    'parameterNotFoundAction': obj.parameterNotFoundAction,
    'selector': toJson_ClusterPolicyV2Beta1SpecRulesValidateCelParamRefSelector(obj.selector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Variable is the definition of a variable that is used for composition. A variable is defined as a named expression.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesValidateCelVariables
 */
export interface ClusterPolicyV2Beta1SpecRulesValidateCelVariables {
  /**
   * Expression is the expression that will be evaluated as the value of the variable.
   * The CEL expression has access to the same identifiers as the CEL expressions in Validation.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateCelVariables#expression
   */
  readonly expression: string;

  /**
   * Name is the name of the variable. The name must be a valid CEL identifier and unique among all variables.
   * The variable can be accessed in other expressions through `variables`
   * For example, if name is "foo", the variable will be available as `variables.foo`
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateCelVariables#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesValidateCelVariables' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesValidateCelVariables(obj: ClusterPolicyV2Beta1SpecRulesValidateCelVariables | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'expression': obj.expression,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Multiple conditions can be declared under an `any` or `all` statement.
 * See: https://kyverno.io/docs/writing-policies/validate/#deny-rules
 *
 * @schema ClusterPolicyV2Beta1SpecRulesValidateDenyConditions
 */
export interface ClusterPolicyV2Beta1SpecRulesValidateDenyConditions {
  /**
   * AllConditions enable variable-based conditional rule execution. This is useful for
   * finer control of when an rule is applied. A condition can reference object data
   * using JMESPath notation.
   * Here, all of the conditions need to pass.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateDenyConditions#all
   */
  readonly all?: ClusterPolicyV2Beta1SpecRulesValidateDenyConditionsAll[];

  /**
   * AnyConditions enable variable-based conditional rule execution. This is useful for
   * finer control of when an rule is applied. A condition can reference object data
   * using JMESPath notation.
   * Here, at least one of the conditions need to pass.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateDenyConditions#any
   */
  readonly any?: ClusterPolicyV2Beta1SpecRulesValidateDenyConditionsAny[];

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesValidateDenyConditions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesValidateDenyConditions(obj: ClusterPolicyV2Beta1SpecRulesValidateDenyConditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'all': obj.all?.map(y => toJson_ClusterPolicyV2Beta1SpecRulesValidateDenyConditionsAll(y)),
    'any': obj.any?.map(y => toJson_ClusterPolicyV2Beta1SpecRulesValidateDenyConditionsAny(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ValidationFailureAction defines the policy validation failure action
 *
 * @schema ClusterPolicyV2Beta1SpecRulesValidateFailureActionOverridesAction
 */
export enum ClusterPolicyV2Beta1SpecRulesValidateFailureActionOverridesAction {
  /** audit */
  AUDIT = "audit",
  /** enforce */
  ENFORCE = "enforce",
}

/**
 * A label selector is a label query over a set of resources. The result of matchLabels and
 * matchExpressions are ANDed. An empty label selector matches all objects. A null
 * label selector matches no objects.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesValidateFailureActionOverridesNamespaceSelector
 */
export interface ClusterPolicyV2Beta1SpecRulesValidateFailureActionOverridesNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateFailureActionOverridesNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterPolicyV2Beta1SpecRulesValidateFailureActionOverridesNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateFailureActionOverridesNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesValidateFailureActionOverridesNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesValidateFailureActionOverridesNamespaceSelector(obj: ClusterPolicyV2Beta1SpecRulesValidateFailureActionOverridesNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterPolicyV2Beta1SpecRulesValidateFailureActionOverridesNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ContextEntry adds variables and data sources to a rule Context. Either a
 * ConfigMap reference or a APILookup must be provided.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesValidateForeachContext
 */
export interface ClusterPolicyV2Beta1SpecRulesValidateForeachContext {
  /**
   * APICall is an HTTP request to the Kubernetes API server, or other JSON web service.
   * The data returned is stored in the context with the name for the context entry.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateForeachContext#apiCall
   */
  readonly apiCall?: ClusterPolicyV2Beta1SpecRulesValidateForeachContextApiCall;

  /**
   * ConfigMap is the ConfigMap reference.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateForeachContext#configMap
   */
  readonly configMap?: ClusterPolicyV2Beta1SpecRulesValidateForeachContextConfigMap;

  /**
   * GlobalContextEntryReference is a reference to a cached global context entry.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateForeachContext#globalReference
   */
  readonly globalReference?: ClusterPolicyV2Beta1SpecRulesValidateForeachContextGlobalReference;

  /**
   * ImageRegistry defines requests to an OCI/Docker V2 registry to fetch image
   * details.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateForeachContext#imageRegistry
   */
  readonly imageRegistry?: ClusterPolicyV2Beta1SpecRulesValidateForeachContextImageRegistry;

  /**
   * Name is the variable name.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateForeachContext#name
   */
  readonly name: string;

  /**
   * Variable defines an arbitrary JMESPath context variable that can be defined inline.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateForeachContext#variable
   */
  readonly variable?: ClusterPolicyV2Beta1SpecRulesValidateForeachContextVariable;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesValidateForeachContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesValidateForeachContext(obj: ClusterPolicyV2Beta1SpecRulesValidateForeachContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiCall': toJson_ClusterPolicyV2Beta1SpecRulesValidateForeachContextApiCall(obj.apiCall),
    'configMap': toJson_ClusterPolicyV2Beta1SpecRulesValidateForeachContextConfigMap(obj.configMap),
    'globalReference': toJson_ClusterPolicyV2Beta1SpecRulesValidateForeachContextGlobalReference(obj.globalReference),
    'imageRegistry': toJson_ClusterPolicyV2Beta1SpecRulesValidateForeachContextImageRegistry(obj.imageRegistry),
    'name': obj.name,
    'variable': toJson_ClusterPolicyV2Beta1SpecRulesValidateForeachContextVariable(obj.variable),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Deny defines conditions used to pass or fail a validation rule.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesValidateForeachDeny
 */
export interface ClusterPolicyV2Beta1SpecRulesValidateForeachDeny {
  /**
   * Multiple conditions can be declared under an `any` or `all` statement. A direct list
   * of conditions (without `any` or `all` statements) is also supported for backwards compatibility
   * but will be deprecated in the next major release.
   * See: https://kyverno.io/docs/writing-policies/validate/#deny-rules
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateForeachDeny#conditions
   */
  readonly conditions?: any;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesValidateForeachDeny' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesValidateForeachDeny(obj: ClusterPolicyV2Beta1SpecRulesValidateForeachDeny | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conditions': obj.conditions,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AnyAllConditions are used to determine if a policy rule should be applied by evaluating a
 * set of conditions. The declaration can contain nested `any` or `all` statements.
 * See: https://kyverno.io/docs/writing-policies/preconditions/
 *
 * @schema ClusterPolicyV2Beta1SpecRulesValidateForeachPreconditions
 */
export interface ClusterPolicyV2Beta1SpecRulesValidateForeachPreconditions {
  /**
   * AllConditions enable variable-based conditional rule execution. This is useful for
   * finer control of when an rule is applied. A condition can reference object data
   * using JMESPath notation.
   * Here, all of the conditions need to pass
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateForeachPreconditions#all
   */
  readonly all?: ClusterPolicyV2Beta1SpecRulesValidateForeachPreconditionsAll[];

  /**
   * AnyConditions enable variable-based conditional rule execution. This is useful for
   * finer control of when an rule is applied. A condition can reference object data
   * using JMESPath notation.
   * Here, at least one of the conditions need to pass
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateForeachPreconditions#any
   */
  readonly any?: ClusterPolicyV2Beta1SpecRulesValidateForeachPreconditionsAny[];

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesValidateForeachPreconditions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesValidateForeachPreconditions(obj: ClusterPolicyV2Beta1SpecRulesValidateForeachPreconditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'all': obj.all?.map(y => toJson_ClusterPolicyV2Beta1SpecRulesValidateForeachPreconditionsAll(y)),
    'any': obj.any?.map(y => toJson_ClusterPolicyV2Beta1SpecRulesValidateForeachPreconditionsAny(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestors
 */
export interface ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestors {
  /**
   * Count specifies the required number of entries that must match. If the count is null, all entries must match
   * (a logical AND). If the count is 1, at least one entry must match (a logical OR). If the count contains a
   * value N, then N must be less than or equal to the size of entries, and at least N entries must match.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestors#count
   */
  readonly count?: number;

  /**
   * Entries contains the available attestors. An attestor can be a static key,
   * attributes for keyless verification, or a nested attestor declaration.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestors#entries
   */
  readonly entries?: ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntries[];

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestors' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestors(obj: ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'count': obj.count,
    'entries': obj.entries?.map(y => toJson_ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntries(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DryRun configuration
 *
 * @schema ClusterPolicyV2Beta1SpecRulesValidateManifestsDryRun
 */
export interface ClusterPolicyV2Beta1SpecRulesValidateManifestsDryRun {
  /**
   * @schema ClusterPolicyV2Beta1SpecRulesValidateManifestsDryRun#enable
   */
  readonly enable?: boolean;

  /**
   * @schema ClusterPolicyV2Beta1SpecRulesValidateManifestsDryRun#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesValidateManifestsDryRun' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesValidateManifestsDryRun(obj: ClusterPolicyV2Beta1SpecRulesValidateManifestsDryRun | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enable': obj.enable,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterPolicyV2Beta1SpecRulesValidateManifestsIgnoreFields
 */
export interface ClusterPolicyV2Beta1SpecRulesValidateManifestsIgnoreFields {
  /**
   * @schema ClusterPolicyV2Beta1SpecRulesValidateManifestsIgnoreFields#fields
   */
  readonly fields?: string[];

  /**
   * @schema ClusterPolicyV2Beta1SpecRulesValidateManifestsIgnoreFields#objects
   */
  readonly objects?: ClusterPolicyV2Beta1SpecRulesValidateManifestsIgnoreFieldsObjects[];

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesValidateManifestsIgnoreFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesValidateManifestsIgnoreFields(obj: ClusterPolicyV2Beta1SpecRulesValidateManifestsIgnoreFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fields': obj.fields?.map(y => y),
    'objects': obj.objects?.map(y => toJson_ClusterPolicyV2Beta1SpecRulesValidateManifestsIgnoreFieldsObjects(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PodSecurityStandard specifies the Pod Security Standard controls to be excluded.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesValidatePodSecurityExclude
 */
export interface ClusterPolicyV2Beta1SpecRulesValidatePodSecurityExclude {
  /**
   * ControlName specifies the name of the Pod Security Standard control.
   * See: https://kubernetes.io/docs/concepts/security/pod-security-standards/
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidatePodSecurityExclude#controlName
   */
  readonly controlName: ClusterPolicyV2Beta1SpecRulesValidatePodSecurityExcludeControlName;

  /**
   * Images selects matching containers and applies the container level PSS.
   * Each image is the image name consisting of the registry address, repository, image, and tag.
   * Empty list matches no containers, PSS checks are applied at the pod level only.
   * Wildcards ('*' and '?') are allowed. See: https://kubernetes.io/docs/concepts/containers/images.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidatePodSecurityExclude#images
   */
  readonly images?: string[];

  /**
   * RestrictedField selects the field for the given Pod Security Standard control.
   * When not set, all restricted fields for the control are selected.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidatePodSecurityExclude#restrictedField
   */
  readonly restrictedField?: string;

  /**
   * Values defines the allowed values that can be excluded.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidatePodSecurityExclude#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesValidatePodSecurityExclude' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesValidatePodSecurityExclude(obj: ClusterPolicyV2Beta1SpecRulesValidatePodSecurityExclude | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'controlName': obj.controlName,
    'images': obj.images?.map(y => y),
    'restrictedField': obj.restrictedField,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Level defines the Pod Security Standard level to be applied to workloads.
 * Allowed values are privileged, baseline, and restricted.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesValidatePodSecurityLevel
 */
export enum ClusterPolicyV2Beta1SpecRulesValidatePodSecurityLevel {
  /** privileged */
  PRIVILEGED = "privileged",
  /** baseline */
  BASELINE = "baseline",
  /** restricted */
  RESTRICTED = "restricted",
}

/**
 * Version defines the Pod Security Standard versions that Kubernetes supports.
 * Allowed values are v1.19, v1.20, v1.21, v1.22, v1.23, v1.24, v1.25, v1.26, v1.27, v1.28, v1.29, latest. Defaults to latest.
 *
 * @default latest.
 * @schema ClusterPolicyV2Beta1SpecRulesValidatePodSecurityVersion
 */
export enum ClusterPolicyV2Beta1SpecRulesValidatePodSecurityVersion {
  /** v1.19 */
  V1_19 = "v1.19",
  /** v1.20 */
  V1_20 = "v1.20",
  /** v1.21 */
  V1_21 = "v1.21",
  /** v1.22 */
  V1_22 = "v1.22",
  /** v1.23 */
  V1_23 = "v1.23",
  /** v1.24 */
  V1_24 = "v1.24",
  /** v1.25 */
  V1_25 = "v1.25",
  /** v1.26 */
  V1_26 = "v1.26",
  /** v1.27 */
  V1_27 = "v1.27",
  /** v1.28 */
  V1_28 = "v1.28",
  /** v1.29 */
  V1_29 = "v1.29",
  /** latest */
  LATEST = "latest",
}

/**
 * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestors
 */
export interface ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestors {
  /**
   * Count specifies the required number of entries that must match. If the count is null, all entries must match
   * (a logical AND). If the count is 1, at least one entry must match (a logical OR). If the count contains a
   * value N, then N must be less than or equal to the size of entries, and at least N entries must match.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestors#count
   */
  readonly count?: number;

  /**
   * Entries contains the available attestors. An attestor can be a static key,
   * attributes for keyless verification, or a nested attestor declaration.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestors#entries
   */
  readonly entries?: ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntries[];

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestors' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestors(obj: ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'count': obj.count,
    'entries': obj.entries?.map(y => toJson_ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntries(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AnyAllConditions consists of conditions wrapped denoting a logical criteria to be fulfilled.
 * AnyConditions get fulfilled when at least one of its sub-conditions passes.
 * AllConditions get fulfilled only when all of its sub-conditions pass.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsConditions
 */
export interface ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsConditions {
  /**
   * AllConditions enable variable-based conditional rule execution. This is useful for
   * finer control of when an rule is applied. A condition can reference object data
   * using JMESPath notation.
   * Here, all of the conditions need to pass
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsConditions#all
   */
  readonly all?: ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsConditionsAll[];

  /**
   * AnyConditions enable variable-based conditional rule execution. This is useful for
   * finer control of when an rule is applied. A condition can reference object data
   * using JMESPath notation.
   * Here, at least one of the conditions need to pass
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsConditions#any
   */
  readonly any?: ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsConditionsAny[];

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsConditions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsConditions(obj: ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsConditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'all': obj.all?.map(y => toJson_ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsConditionsAll(y)),
    'any': obj.any?.map(y => toJson_ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsConditionsAny(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntries
 */
export interface ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntries {
  /**
   * Annotations are used for image verification.
   * Every specified key-value pair must exist and match in the verified payload.
   * The payload may contain other key-value pairs.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntries#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Attestor is a nested set of Attestor used to specify a more complex set of match authorities.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntries#attestor
   */
  readonly attestor?: any;

  /**
   * Certificates specifies one or more certificates.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntries#certificates
   */
  readonly certificates?: ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesCertificates;

  /**
   * Keyless is a set of attribute used to verify a Sigstore keyless attestor.
   * See https://github.com/sigstore/cosign/blob/main/KEYLESS.md.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntries#keyless
   */
  readonly keyless?: ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesKeyless;

  /**
   * Keys specifies one or more public keys.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntries#keys
   */
  readonly keys?: ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesKeys;

  /**
   * Repository is an optional alternate OCI repository to use for signatures and attestations that match this rule.
   * If specified Repository will override other OCI image repository locations for this Attestor.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntries#repository
   */
  readonly repository?: string;

  /**
   * Specify signature algorithm for public keys. Supported values are sha224, sha256, sha384 and sha512.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntries#signatureAlgorithm
   */
  readonly signatureAlgorithm?: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntries' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntries(obj: ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntries | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'attestor': obj.attestor,
    'certificates': toJson_ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesCertificates(obj.certificates),
    'keyless': toJson_ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesKeyless(obj.keyless),
    'keys': toJson_ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesKeys(obj.keys),
    'repository': obj.repository,
    'signatureAlgorithm': obj.signatureAlgorithm,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ImageRegistryCredentialsProvidersType provides the list of credential providers required.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesImageRegistryCredentialsProviders
 */
export enum ClusterPolicyV2Beta1SpecRulesVerifyImagesImageRegistryCredentialsProviders {
  /** default */
  DEFAULT = "default",
  /** amazon */
  AMAZON = "amazon",
  /** azure */
  AZURE = "azure",
  /** google */
  GOOGLE = "google",
  /** github */
  GITHUB = "github",
}

/**
 * Deny defines conditions used to pass or fail a validation rule.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesValidateDeny
 */
export interface ClusterPolicyV2Beta1SpecRulesVerifyImagesValidateDeny {
  /**
   * Multiple conditions can be declared under an `any` or `all` statement. A direct list
   * of conditions (without `any` or `all` statements) is also supported for backwards compatibility
   * but will be deprecated in the next major release.
   * See: https://kyverno.io/docs/writing-policies/validate/#deny-rules
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesValidateDeny#conditions
   */
  readonly conditions?: any;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesVerifyImagesValidateDeny' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesVerifyImagesValidateDeny(obj: ClusterPolicyV2Beta1SpecRulesVerifyImagesValidateDeny | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conditions': obj.conditions,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterPolicyV2Beta1SpecRulesContextApiCallServiceHeaders
 */
export interface ClusterPolicyV2Beta1SpecRulesContextApiCallServiceHeaders {
  /**
   * Key is the header key
   *
   * @schema ClusterPolicyV2Beta1SpecRulesContextApiCallServiceHeaders#key
   */
  readonly key: string;

  /**
   * Value is the header value
   *
   * @schema ClusterPolicyV2Beta1SpecRulesContextApiCallServiceHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesContextApiCallServiceHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesContextApiCallServiceHeaders(obj: ClusterPolicyV2Beta1SpecRulesContextApiCallServiceHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ImageRegistryCredentialsProvidersType provides the list of credential providers required.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesContextImageRegistryImageRegistryCredentialsProviders
 */
export enum ClusterPolicyV2Beta1SpecRulesContextImageRegistryImageRegistryCredentialsProviders {
  /** default */
  DEFAULT = "default",
  /** amazon */
  AMAZON = "amazon",
  /** azure */
  AZURE = "azure",
  /** google */
  GOOGLE = "google",
  /** github */
  GITHUB = "github",
}

/**
 * NamespaceSelector is a label selector for the resource namespace. Label keys and values
 * in `matchLabels` support the wildcard characters `*` (matches zero or many characters)
 * and `?` (matches one character).Wildcards allows writing label selectors like
 * ["storage.k8s.io/*": "*"]. Note that using ["*" : "*"] matches any key and value but
 * does not match an empty label set.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesExcludeAllResourcesNamespaceSelector
 */
export interface ClusterPolicyV2Beta1SpecRulesExcludeAllResourcesNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesExcludeAllResourcesNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterPolicyV2Beta1SpecRulesExcludeAllResourcesNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesExcludeAllResourcesNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesExcludeAllResourcesNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesExcludeAllResourcesNamespaceSelector(obj: ClusterPolicyV2Beta1SpecRulesExcludeAllResourcesNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterPolicyV2Beta1SpecRulesExcludeAllResourcesNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AdmissionOperation can have one of the values CREATE, UPDATE, CONNECT, DELETE, which are used to match a specific action.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesExcludeAllResourcesOperations
 */
export enum ClusterPolicyV2Beta1SpecRulesExcludeAllResourcesOperations {
  /** CREATE */
  CREATE = "CREATE",
  /** CONNECT */
  CONNECT = "CONNECT",
  /** UPDATE */
  UPDATE = "UPDATE",
  /** DELETE */
  DELETE = "DELETE",
}

/**
 * Selector is a label selector. Label keys and values in `matchLabels` support the wildcard
 * characters `*` (matches zero or many characters) and `?` (matches one character).
 * Wildcards allows writing label selectors like ["storage.k8s.io/*": "*"]. Note that
 * using ["*" : "*"] matches any key and value but does not match an empty label set.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesExcludeAllResourcesSelector
 */
export interface ClusterPolicyV2Beta1SpecRulesExcludeAllResourcesSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesExcludeAllResourcesSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterPolicyV2Beta1SpecRulesExcludeAllResourcesSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesExcludeAllResourcesSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesExcludeAllResourcesSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesExcludeAllResourcesSelector(obj: ClusterPolicyV2Beta1SpecRulesExcludeAllResourcesSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterPolicyV2Beta1SpecRulesExcludeAllResourcesSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NamespaceSelector is a label selector for the resource namespace. Label keys and values
 * in `matchLabels` support the wildcard characters `*` (matches zero or many characters)
 * and `?` (matches one character).Wildcards allows writing label selectors like
 * ["storage.k8s.io/*": "*"]. Note that using ["*" : "*"] matches any key and value but
 * does not match an empty label set.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesExcludeAnyResourcesNamespaceSelector
 */
export interface ClusterPolicyV2Beta1SpecRulesExcludeAnyResourcesNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesExcludeAnyResourcesNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterPolicyV2Beta1SpecRulesExcludeAnyResourcesNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesExcludeAnyResourcesNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesExcludeAnyResourcesNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesExcludeAnyResourcesNamespaceSelector(obj: ClusterPolicyV2Beta1SpecRulesExcludeAnyResourcesNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterPolicyV2Beta1SpecRulesExcludeAnyResourcesNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AdmissionOperation can have one of the values CREATE, UPDATE, CONNECT, DELETE, which are used to match a specific action.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesExcludeAnyResourcesOperations
 */
export enum ClusterPolicyV2Beta1SpecRulesExcludeAnyResourcesOperations {
  /** CREATE */
  CREATE = "CREATE",
  /** CONNECT */
  CONNECT = "CONNECT",
  /** UPDATE */
  UPDATE = "UPDATE",
  /** DELETE */
  DELETE = "DELETE",
}

/**
 * Selector is a label selector. Label keys and values in `matchLabels` support the wildcard
 * characters `*` (matches zero or many characters) and `?` (matches one character).
 * Wildcards allows writing label selectors like ["storage.k8s.io/*": "*"]. Note that
 * using ["*" : "*"] matches any key and value but does not match an empty label set.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesExcludeAnyResourcesSelector
 */
export interface ClusterPolicyV2Beta1SpecRulesExcludeAnyResourcesSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesExcludeAnyResourcesSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterPolicyV2Beta1SpecRulesExcludeAnyResourcesSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesExcludeAnyResourcesSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesExcludeAnyResourcesSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesExcludeAnyResourcesSelector(obj: ClusterPolicyV2Beta1SpecRulesExcludeAnyResourcesSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterPolicyV2Beta1SpecRulesExcludeAnyResourcesSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesGenerateCloneListSelectorMatchExpressions
 */
export interface ClusterPolicyV2Beta1SpecRulesGenerateCloneListSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerateCloneListSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerateCloneListSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerateCloneListSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesGenerateCloneListSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesGenerateCloneListSelectorMatchExpressions(obj: ClusterPolicyV2Beta1SpecRulesGenerateCloneListSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector is a label selector. Label keys and values in `matchLabels`.
 * wildcard characters are not supported.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeachCloneListSelector
 */
export interface ClusterPolicyV2Beta1SpecRulesGenerateForeachCloneListSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeachCloneListSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterPolicyV2Beta1SpecRulesGenerateForeachCloneListSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeachCloneListSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesGenerateForeachCloneListSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesGenerateForeachCloneListSelector(obj: ClusterPolicyV2Beta1SpecRulesGenerateForeachCloneListSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterPolicyV2Beta1SpecRulesGenerateForeachCloneListSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * APICall is an HTTP request to the Kubernetes API server, or other JSON web service.
 * The data returned is stored in the context with the name for the context entry.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeachContextApiCall
 */
export interface ClusterPolicyV2Beta1SpecRulesGenerateForeachContextApiCall {
  /**
   * The data object specifies the POST data sent to the server.
   * Only applicable when the method field is set to POST.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeachContextApiCall#data
   */
  readonly data?: ClusterPolicyV2Beta1SpecRulesGenerateForeachContextApiCallData[];

  /**
   * Default is an optional arbitrary JSON object that the context
   * value is set to, if the apiCall returns error.
   *
   * @default an optional arbitrary JSON object that the context
   * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeachContextApiCall#default
   */
  readonly default?: any;

  /**
   * JMESPath is an optional JSON Match Expression that can be used to
   * transform the JSON response returned from the server. For example
   * a JMESPath of "items | length(@)" applied to the API server response
   * for the URLPath "/apis/apps/v1/deployments" will return the total count
   * of deployments across all namespaces.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeachContextApiCall#jmesPath
   */
  readonly jmesPath?: string;

  /**
   * Method is the HTTP request type (GET or POST). Defaults to GET.
   *
   * @default GET.
   * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeachContextApiCall#method
   */
  readonly method?: ClusterPolicyV2Beta1SpecRulesGenerateForeachContextApiCallMethod;

  /**
   * Service is an API call to a JSON web service.
   * This is used for non-Kubernetes API server calls.
   * It's mutually exclusive with the URLPath field.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeachContextApiCall#service
   */
  readonly service?: ClusterPolicyV2Beta1SpecRulesGenerateForeachContextApiCallService;

  /**
   * URLPath is the URL path to be used in the HTTP GET or POST request to the
   * Kubernetes API server (e.g. "/api/v1/namespaces" or  "/apis/apps/v1/deployments").
   * The format required is the same format used by the `kubectl get --raw` command.
   * See https://kyverno.io/docs/writing-policies/external-data-sources/#variables-from-kubernetes-api-server-calls
   * for details.
   * It's mutually exclusive with the Service field.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeachContextApiCall#urlPath
   */
  readonly urlPath?: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesGenerateForeachContextApiCall' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesGenerateForeachContextApiCall(obj: ClusterPolicyV2Beta1SpecRulesGenerateForeachContextApiCall | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'data': obj.data?.map(y => toJson_ClusterPolicyV2Beta1SpecRulesGenerateForeachContextApiCallData(y)),
    'default': obj.default,
    'jmesPath': obj.jmesPath,
    'method': obj.method,
    'service': toJson_ClusterPolicyV2Beta1SpecRulesGenerateForeachContextApiCallService(obj.service),
    'urlPath': obj.urlPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap is the ConfigMap reference.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeachContextConfigMap
 */
export interface ClusterPolicyV2Beta1SpecRulesGenerateForeachContextConfigMap {
  /**
   * Name is the ConfigMap name.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeachContextConfigMap#name
   */
  readonly name: string;

  /**
   * Namespace is the ConfigMap namespace.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeachContextConfigMap#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesGenerateForeachContextConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesGenerateForeachContextConfigMap(obj: ClusterPolicyV2Beta1SpecRulesGenerateForeachContextConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GlobalContextEntryReference is a reference to a cached global context entry.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeachContextGlobalReference
 */
export interface ClusterPolicyV2Beta1SpecRulesGenerateForeachContextGlobalReference {
  /**
   * JMESPath is an optional JSON Match Expression that can be used to
   * transform the JSON response returned from the server. For example
   * a JMESPath of "items | length(@)" applied to the API server response
   * for the URLPath "/apis/apps/v1/deployments" will return the total count
   * of deployments across all namespaces.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeachContextGlobalReference#jmesPath
   */
  readonly jmesPath?: string;

  /**
   * Name of the global context entry
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeachContextGlobalReference#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesGenerateForeachContextGlobalReference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesGenerateForeachContextGlobalReference(obj: ClusterPolicyV2Beta1SpecRulesGenerateForeachContextGlobalReference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'jmesPath': obj.jmesPath,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ImageRegistry defines requests to an OCI/Docker V2 registry to fetch image
 * details.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeachContextImageRegistry
 */
export interface ClusterPolicyV2Beta1SpecRulesGenerateForeachContextImageRegistry {
  /**
   * ImageRegistryCredentials provides credentials that will be used for authentication with registry
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeachContextImageRegistry#imageRegistryCredentials
   */
  readonly imageRegistryCredentials?: ClusterPolicyV2Beta1SpecRulesGenerateForeachContextImageRegistryImageRegistryCredentials;

  /**
   * JMESPath is an optional JSON Match Expression that can be used to
   * transform the ImageData struct returned as a result of processing
   * the image reference.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeachContextImageRegistry#jmesPath
   */
  readonly jmesPath?: string;

  /**
   * Reference is image reference to a container image in the registry.
   * Example: ghcr.io/kyverno/kyverno:latest
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeachContextImageRegistry#reference
   */
  readonly reference: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesGenerateForeachContextImageRegistry' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesGenerateForeachContextImageRegistry(obj: ClusterPolicyV2Beta1SpecRulesGenerateForeachContextImageRegistry | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'imageRegistryCredentials': toJson_ClusterPolicyV2Beta1SpecRulesGenerateForeachContextImageRegistryImageRegistryCredentials(obj.imageRegistryCredentials),
    'jmesPath': obj.jmesPath,
    'reference': obj.reference,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Variable defines an arbitrary JMESPath context variable that can be defined inline.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeachContextVariable
 */
export interface ClusterPolicyV2Beta1SpecRulesGenerateForeachContextVariable {
  /**
   * Default is an optional arbitrary JSON object that the variable may take if the JMESPath
   * expression evaluates to nil
   *
   * @default an optional arbitrary JSON object that the variable may take if the JMESPath
   * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeachContextVariable#default
   */
  readonly default?: any;

  /**
   * JMESPath is an optional JMESPath Expression that can be used to
   * transform the variable.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeachContextVariable#jmesPath
   */
  readonly jmesPath?: string;

  /**
   * Value is any arbitrary JSON object representable in YAML or JSON form.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeachContextVariable#value
   */
  readonly value?: any;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesGenerateForeachContextVariable' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesGenerateForeachContextVariable(obj: ClusterPolicyV2Beta1SpecRulesGenerateForeachContextVariable | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'default': obj.default,
    'jmesPath': obj.jmesPath,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Condition defines variable-based conditional criteria for rule execution.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeachPreconditionsAll
 */
export interface ClusterPolicyV2Beta1SpecRulesGenerateForeachPreconditionsAll {
  /**
   * Key is the context entry (using JMESPath) for conditional rule evaluation.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeachPreconditionsAll#key
   */
  readonly key?: any;

  /**
   * Message is an optional display message
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeachPreconditionsAll#message
   */
  readonly message?: string;

  /**
   * Operator is the conditional operation to perform. Valid operators are:
   * Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
   * GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
   * DurationLessThanOrEquals, DurationLessThan
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeachPreconditionsAll#operator
   */
  readonly operator?: ClusterPolicyV2Beta1SpecRulesGenerateForeachPreconditionsAllOperator;

  /**
   * Value is the conditional value, or set of values. The values can be fixed set
   * or can be variables declared using JMESPath.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeachPreconditionsAll#value
   */
  readonly value?: any;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesGenerateForeachPreconditionsAll' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesGenerateForeachPreconditionsAll(obj: ClusterPolicyV2Beta1SpecRulesGenerateForeachPreconditionsAll | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'message': obj.message,
    'operator': obj.operator,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Condition defines variable-based conditional criteria for rule execution.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeachPreconditionsAny
 */
export interface ClusterPolicyV2Beta1SpecRulesGenerateForeachPreconditionsAny {
  /**
   * Key is the context entry (using JMESPath) for conditional rule evaluation.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeachPreconditionsAny#key
   */
  readonly key?: any;

  /**
   * Message is an optional display message
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeachPreconditionsAny#message
   */
  readonly message?: string;

  /**
   * Operator is the conditional operation to perform. Valid operators are:
   * Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
   * GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
   * DurationLessThanOrEquals, DurationLessThan
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeachPreconditionsAny#operator
   */
  readonly operator?: ClusterPolicyV2Beta1SpecRulesGenerateForeachPreconditionsAnyOperator;

  /**
   * Value is the conditional value, or set of values. The values can be fixed set
   * or can be variables declared using JMESPath.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeachPreconditionsAny#value
   */
  readonly value?: any;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesGenerateForeachPreconditionsAny' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesGenerateForeachPreconditionsAny(obj: ClusterPolicyV2Beta1SpecRulesGenerateForeachPreconditionsAny | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'message': obj.message,
    'operator': obj.operator,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NamespaceSelector is a label selector for the resource namespace. Label keys and values
 * in `matchLabels` support the wildcard characters `*` (matches zero or many characters)
 * and `?` (matches one character).Wildcards allows writing label selectors like
 * ["storage.k8s.io/*": "*"]. Note that using ["*" : "*"] matches any key and value but
 * does not match an empty label set.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesMatchAllResourcesNamespaceSelector
 */
export interface ClusterPolicyV2Beta1SpecRulesMatchAllResourcesNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMatchAllResourcesNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterPolicyV2Beta1SpecRulesMatchAllResourcesNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMatchAllResourcesNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesMatchAllResourcesNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesMatchAllResourcesNamespaceSelector(obj: ClusterPolicyV2Beta1SpecRulesMatchAllResourcesNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterPolicyV2Beta1SpecRulesMatchAllResourcesNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AdmissionOperation can have one of the values CREATE, UPDATE, CONNECT, DELETE, which are used to match a specific action.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesMatchAllResourcesOperations
 */
export enum ClusterPolicyV2Beta1SpecRulesMatchAllResourcesOperations {
  /** CREATE */
  CREATE = "CREATE",
  /** CONNECT */
  CONNECT = "CONNECT",
  /** UPDATE */
  UPDATE = "UPDATE",
  /** DELETE */
  DELETE = "DELETE",
}

/**
 * Selector is a label selector. Label keys and values in `matchLabels` support the wildcard
 * characters `*` (matches zero or many characters) and `?` (matches one character).
 * Wildcards allows writing label selectors like ["storage.k8s.io/*": "*"]. Note that
 * using ["*" : "*"] matches any key and value but does not match an empty label set.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesMatchAllResourcesSelector
 */
export interface ClusterPolicyV2Beta1SpecRulesMatchAllResourcesSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMatchAllResourcesSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterPolicyV2Beta1SpecRulesMatchAllResourcesSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMatchAllResourcesSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesMatchAllResourcesSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesMatchAllResourcesSelector(obj: ClusterPolicyV2Beta1SpecRulesMatchAllResourcesSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterPolicyV2Beta1SpecRulesMatchAllResourcesSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NamespaceSelector is a label selector for the resource namespace. Label keys and values
 * in `matchLabels` support the wildcard characters `*` (matches zero or many characters)
 * and `?` (matches one character).Wildcards allows writing label selectors like
 * ["storage.k8s.io/*": "*"]. Note that using ["*" : "*"] matches any key and value but
 * does not match an empty label set.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesMatchAnyResourcesNamespaceSelector
 */
export interface ClusterPolicyV2Beta1SpecRulesMatchAnyResourcesNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMatchAnyResourcesNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterPolicyV2Beta1SpecRulesMatchAnyResourcesNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMatchAnyResourcesNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesMatchAnyResourcesNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesMatchAnyResourcesNamespaceSelector(obj: ClusterPolicyV2Beta1SpecRulesMatchAnyResourcesNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterPolicyV2Beta1SpecRulesMatchAnyResourcesNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AdmissionOperation can have one of the values CREATE, UPDATE, CONNECT, DELETE, which are used to match a specific action.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesMatchAnyResourcesOperations
 */
export enum ClusterPolicyV2Beta1SpecRulesMatchAnyResourcesOperations {
  /** CREATE */
  CREATE = "CREATE",
  /** CONNECT */
  CONNECT = "CONNECT",
  /** UPDATE */
  UPDATE = "UPDATE",
  /** DELETE */
  DELETE = "DELETE",
}

/**
 * Selector is a label selector. Label keys and values in `matchLabels` support the wildcard
 * characters `*` (matches zero or many characters) and `?` (matches one character).
 * Wildcards allows writing label selectors like ["storage.k8s.io/*": "*"]. Note that
 * using ["*" : "*"] matches any key and value but does not match an empty label set.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesMatchAnyResourcesSelector
 */
export interface ClusterPolicyV2Beta1SpecRulesMatchAnyResourcesSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMatchAnyResourcesSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterPolicyV2Beta1SpecRulesMatchAnyResourcesSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMatchAnyResourcesSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesMatchAnyResourcesSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesMatchAnyResourcesSelector(obj: ClusterPolicyV2Beta1SpecRulesMatchAnyResourcesSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterPolicyV2Beta1SpecRulesMatchAnyResourcesSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * APICall is an HTTP request to the Kubernetes API server, or other JSON web service.
 * The data returned is stored in the context with the name for the context entry.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesMutateForeachContextApiCall
 */
export interface ClusterPolicyV2Beta1SpecRulesMutateForeachContextApiCall {
  /**
   * The data object specifies the POST data sent to the server.
   * Only applicable when the method field is set to POST.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateForeachContextApiCall#data
   */
  readonly data?: ClusterPolicyV2Beta1SpecRulesMutateForeachContextApiCallData[];

  /**
   * Default is an optional arbitrary JSON object that the context
   * value is set to, if the apiCall returns error.
   *
   * @default an optional arbitrary JSON object that the context
   * @schema ClusterPolicyV2Beta1SpecRulesMutateForeachContextApiCall#default
   */
  readonly default?: any;

  /**
   * JMESPath is an optional JSON Match Expression that can be used to
   * transform the JSON response returned from the server. For example
   * a JMESPath of "items | length(@)" applied to the API server response
   * for the URLPath "/apis/apps/v1/deployments" will return the total count
   * of deployments across all namespaces.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateForeachContextApiCall#jmesPath
   */
  readonly jmesPath?: string;

  /**
   * Method is the HTTP request type (GET or POST). Defaults to GET.
   *
   * @default GET.
   * @schema ClusterPolicyV2Beta1SpecRulesMutateForeachContextApiCall#method
   */
  readonly method?: ClusterPolicyV2Beta1SpecRulesMutateForeachContextApiCallMethod;

  /**
   * Service is an API call to a JSON web service.
   * This is used for non-Kubernetes API server calls.
   * It's mutually exclusive with the URLPath field.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateForeachContextApiCall#service
   */
  readonly service?: ClusterPolicyV2Beta1SpecRulesMutateForeachContextApiCallService;

  /**
   * URLPath is the URL path to be used in the HTTP GET or POST request to the
   * Kubernetes API server (e.g. "/api/v1/namespaces" or  "/apis/apps/v1/deployments").
   * The format required is the same format used by the `kubectl get --raw` command.
   * See https://kyverno.io/docs/writing-policies/external-data-sources/#variables-from-kubernetes-api-server-calls
   * for details.
   * It's mutually exclusive with the Service field.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateForeachContextApiCall#urlPath
   */
  readonly urlPath?: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesMutateForeachContextApiCall' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesMutateForeachContextApiCall(obj: ClusterPolicyV2Beta1SpecRulesMutateForeachContextApiCall | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'data': obj.data?.map(y => toJson_ClusterPolicyV2Beta1SpecRulesMutateForeachContextApiCallData(y)),
    'default': obj.default,
    'jmesPath': obj.jmesPath,
    'method': obj.method,
    'service': toJson_ClusterPolicyV2Beta1SpecRulesMutateForeachContextApiCallService(obj.service),
    'urlPath': obj.urlPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap is the ConfigMap reference.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesMutateForeachContextConfigMap
 */
export interface ClusterPolicyV2Beta1SpecRulesMutateForeachContextConfigMap {
  /**
   * Name is the ConfigMap name.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateForeachContextConfigMap#name
   */
  readonly name: string;

  /**
   * Namespace is the ConfigMap namespace.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateForeachContextConfigMap#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesMutateForeachContextConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesMutateForeachContextConfigMap(obj: ClusterPolicyV2Beta1SpecRulesMutateForeachContextConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GlobalContextEntryReference is a reference to a cached global context entry.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesMutateForeachContextGlobalReference
 */
export interface ClusterPolicyV2Beta1SpecRulesMutateForeachContextGlobalReference {
  /**
   * JMESPath is an optional JSON Match Expression that can be used to
   * transform the JSON response returned from the server. For example
   * a JMESPath of "items | length(@)" applied to the API server response
   * for the URLPath "/apis/apps/v1/deployments" will return the total count
   * of deployments across all namespaces.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateForeachContextGlobalReference#jmesPath
   */
  readonly jmesPath?: string;

  /**
   * Name of the global context entry
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateForeachContextGlobalReference#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesMutateForeachContextGlobalReference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesMutateForeachContextGlobalReference(obj: ClusterPolicyV2Beta1SpecRulesMutateForeachContextGlobalReference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'jmesPath': obj.jmesPath,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ImageRegistry defines requests to an OCI/Docker V2 registry to fetch image
 * details.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesMutateForeachContextImageRegistry
 */
export interface ClusterPolicyV2Beta1SpecRulesMutateForeachContextImageRegistry {
  /**
   * ImageRegistryCredentials provides credentials that will be used for authentication with registry
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateForeachContextImageRegistry#imageRegistryCredentials
   */
  readonly imageRegistryCredentials?: ClusterPolicyV2Beta1SpecRulesMutateForeachContextImageRegistryImageRegistryCredentials;

  /**
   * JMESPath is an optional JSON Match Expression that can be used to
   * transform the ImageData struct returned as a result of processing
   * the image reference.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateForeachContextImageRegistry#jmesPath
   */
  readonly jmesPath?: string;

  /**
   * Reference is image reference to a container image in the registry.
   * Example: ghcr.io/kyverno/kyverno:latest
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateForeachContextImageRegistry#reference
   */
  readonly reference: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesMutateForeachContextImageRegistry' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesMutateForeachContextImageRegistry(obj: ClusterPolicyV2Beta1SpecRulesMutateForeachContextImageRegistry | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'imageRegistryCredentials': toJson_ClusterPolicyV2Beta1SpecRulesMutateForeachContextImageRegistryImageRegistryCredentials(obj.imageRegistryCredentials),
    'jmesPath': obj.jmesPath,
    'reference': obj.reference,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Variable defines an arbitrary JMESPath context variable that can be defined inline.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesMutateForeachContextVariable
 */
export interface ClusterPolicyV2Beta1SpecRulesMutateForeachContextVariable {
  /**
   * Default is an optional arbitrary JSON object that the variable may take if the JMESPath
   * expression evaluates to nil
   *
   * @default an optional arbitrary JSON object that the variable may take if the JMESPath
   * @schema ClusterPolicyV2Beta1SpecRulesMutateForeachContextVariable#default
   */
  readonly default?: any;

  /**
   * JMESPath is an optional JMESPath Expression that can be used to
   * transform the variable.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateForeachContextVariable#jmesPath
   */
  readonly jmesPath?: string;

  /**
   * Value is any arbitrary JSON object representable in YAML or JSON form.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateForeachContextVariable#value
   */
  readonly value?: any;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesMutateForeachContextVariable' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesMutateForeachContextVariable(obj: ClusterPolicyV2Beta1SpecRulesMutateForeachContextVariable | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'default': obj.default,
    'jmesPath': obj.jmesPath,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Condition defines variable-based conditional criteria for rule execution.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesMutateForeachPreconditionsAll
 */
export interface ClusterPolicyV2Beta1SpecRulesMutateForeachPreconditionsAll {
  /**
   * Key is the context entry (using JMESPath) for conditional rule evaluation.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateForeachPreconditionsAll#key
   */
  readonly key?: any;

  /**
   * Message is an optional display message
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateForeachPreconditionsAll#message
   */
  readonly message?: string;

  /**
   * Operator is the conditional operation to perform. Valid operators are:
   * Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
   * GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
   * DurationLessThanOrEquals, DurationLessThan
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateForeachPreconditionsAll#operator
   */
  readonly operator?: ClusterPolicyV2Beta1SpecRulesMutateForeachPreconditionsAllOperator;

  /**
   * Value is the conditional value, or set of values. The values can be fixed set
   * or can be variables declared using JMESPath.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateForeachPreconditionsAll#value
   */
  readonly value?: any;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesMutateForeachPreconditionsAll' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesMutateForeachPreconditionsAll(obj: ClusterPolicyV2Beta1SpecRulesMutateForeachPreconditionsAll | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'message': obj.message,
    'operator': obj.operator,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Condition defines variable-based conditional criteria for rule execution.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesMutateForeachPreconditionsAny
 */
export interface ClusterPolicyV2Beta1SpecRulesMutateForeachPreconditionsAny {
  /**
   * Key is the context entry (using JMESPath) for conditional rule evaluation.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateForeachPreconditionsAny#key
   */
  readonly key?: any;

  /**
   * Message is an optional display message
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateForeachPreconditionsAny#message
   */
  readonly message?: string;

  /**
   * Operator is the conditional operation to perform. Valid operators are:
   * Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
   * GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
   * DurationLessThanOrEquals, DurationLessThan
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateForeachPreconditionsAny#operator
   */
  readonly operator?: ClusterPolicyV2Beta1SpecRulesMutateForeachPreconditionsAnyOperator;

  /**
   * Value is the conditional value, or set of values. The values can be fixed set
   * or can be variables declared using JMESPath.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateForeachPreconditionsAny#value
   */
  readonly value?: any;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesMutateForeachPreconditionsAny' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesMutateForeachPreconditionsAny(obj: ClusterPolicyV2Beta1SpecRulesMutateForeachPreconditionsAny | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'message': obj.message,
    'operator': obj.operator,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * APICall is an HTTP request to the Kubernetes API server, or other JSON web service.
 * The data returned is stored in the context with the name for the context entry.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesMutateTargetsContextApiCall
 */
export interface ClusterPolicyV2Beta1SpecRulesMutateTargetsContextApiCall {
  /**
   * The data object specifies the POST data sent to the server.
   * Only applicable when the method field is set to POST.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateTargetsContextApiCall#data
   */
  readonly data?: ClusterPolicyV2Beta1SpecRulesMutateTargetsContextApiCallData[];

  /**
   * Default is an optional arbitrary JSON object that the context
   * value is set to, if the apiCall returns error.
   *
   * @default an optional arbitrary JSON object that the context
   * @schema ClusterPolicyV2Beta1SpecRulesMutateTargetsContextApiCall#default
   */
  readonly default?: any;

  /**
   * JMESPath is an optional JSON Match Expression that can be used to
   * transform the JSON response returned from the server. For example
   * a JMESPath of "items | length(@)" applied to the API server response
   * for the URLPath "/apis/apps/v1/deployments" will return the total count
   * of deployments across all namespaces.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateTargetsContextApiCall#jmesPath
   */
  readonly jmesPath?: string;

  /**
   * Method is the HTTP request type (GET or POST). Defaults to GET.
   *
   * @default GET.
   * @schema ClusterPolicyV2Beta1SpecRulesMutateTargetsContextApiCall#method
   */
  readonly method?: ClusterPolicyV2Beta1SpecRulesMutateTargetsContextApiCallMethod;

  /**
   * Service is an API call to a JSON web service.
   * This is used for non-Kubernetes API server calls.
   * It's mutually exclusive with the URLPath field.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateTargetsContextApiCall#service
   */
  readonly service?: ClusterPolicyV2Beta1SpecRulesMutateTargetsContextApiCallService;

  /**
   * URLPath is the URL path to be used in the HTTP GET or POST request to the
   * Kubernetes API server (e.g. "/api/v1/namespaces" or  "/apis/apps/v1/deployments").
   * The format required is the same format used by the `kubectl get --raw` command.
   * See https://kyverno.io/docs/writing-policies/external-data-sources/#variables-from-kubernetes-api-server-calls
   * for details.
   * It's mutually exclusive with the Service field.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateTargetsContextApiCall#urlPath
   */
  readonly urlPath?: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesMutateTargetsContextApiCall' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesMutateTargetsContextApiCall(obj: ClusterPolicyV2Beta1SpecRulesMutateTargetsContextApiCall | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'data': obj.data?.map(y => toJson_ClusterPolicyV2Beta1SpecRulesMutateTargetsContextApiCallData(y)),
    'default': obj.default,
    'jmesPath': obj.jmesPath,
    'method': obj.method,
    'service': toJson_ClusterPolicyV2Beta1SpecRulesMutateTargetsContextApiCallService(obj.service),
    'urlPath': obj.urlPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap is the ConfigMap reference.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesMutateTargetsContextConfigMap
 */
export interface ClusterPolicyV2Beta1SpecRulesMutateTargetsContextConfigMap {
  /**
   * Name is the ConfigMap name.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateTargetsContextConfigMap#name
   */
  readonly name: string;

  /**
   * Namespace is the ConfigMap namespace.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateTargetsContextConfigMap#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesMutateTargetsContextConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesMutateTargetsContextConfigMap(obj: ClusterPolicyV2Beta1SpecRulesMutateTargetsContextConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GlobalContextEntryReference is a reference to a cached global context entry.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesMutateTargetsContextGlobalReference
 */
export interface ClusterPolicyV2Beta1SpecRulesMutateTargetsContextGlobalReference {
  /**
   * JMESPath is an optional JSON Match Expression that can be used to
   * transform the JSON response returned from the server. For example
   * a JMESPath of "items | length(@)" applied to the API server response
   * for the URLPath "/apis/apps/v1/deployments" will return the total count
   * of deployments across all namespaces.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateTargetsContextGlobalReference#jmesPath
   */
  readonly jmesPath?: string;

  /**
   * Name of the global context entry
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateTargetsContextGlobalReference#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesMutateTargetsContextGlobalReference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesMutateTargetsContextGlobalReference(obj: ClusterPolicyV2Beta1SpecRulesMutateTargetsContextGlobalReference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'jmesPath': obj.jmesPath,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ImageRegistry defines requests to an OCI/Docker V2 registry to fetch image
 * details.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesMutateTargetsContextImageRegistry
 */
export interface ClusterPolicyV2Beta1SpecRulesMutateTargetsContextImageRegistry {
  /**
   * ImageRegistryCredentials provides credentials that will be used for authentication with registry
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateTargetsContextImageRegistry#imageRegistryCredentials
   */
  readonly imageRegistryCredentials?: ClusterPolicyV2Beta1SpecRulesMutateTargetsContextImageRegistryImageRegistryCredentials;

  /**
   * JMESPath is an optional JSON Match Expression that can be used to
   * transform the ImageData struct returned as a result of processing
   * the image reference.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateTargetsContextImageRegistry#jmesPath
   */
  readonly jmesPath?: string;

  /**
   * Reference is image reference to a container image in the registry.
   * Example: ghcr.io/kyverno/kyverno:latest
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateTargetsContextImageRegistry#reference
   */
  readonly reference: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesMutateTargetsContextImageRegistry' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesMutateTargetsContextImageRegistry(obj: ClusterPolicyV2Beta1SpecRulesMutateTargetsContextImageRegistry | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'imageRegistryCredentials': toJson_ClusterPolicyV2Beta1SpecRulesMutateTargetsContextImageRegistryImageRegistryCredentials(obj.imageRegistryCredentials),
    'jmesPath': obj.jmesPath,
    'reference': obj.reference,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Variable defines an arbitrary JMESPath context variable that can be defined inline.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesMutateTargetsContextVariable
 */
export interface ClusterPolicyV2Beta1SpecRulesMutateTargetsContextVariable {
  /**
   * Default is an optional arbitrary JSON object that the variable may take if the JMESPath
   * expression evaluates to nil
   *
   * @default an optional arbitrary JSON object that the variable may take if the JMESPath
   * @schema ClusterPolicyV2Beta1SpecRulesMutateTargetsContextVariable#default
   */
  readonly default?: any;

  /**
   * JMESPath is an optional JMESPath Expression that can be used to
   * transform the variable.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateTargetsContextVariable#jmesPath
   */
  readonly jmesPath?: string;

  /**
   * Value is any arbitrary JSON object representable in YAML or JSON form.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateTargetsContextVariable#value
   */
  readonly value?: any;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesMutateTargetsContextVariable' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesMutateTargetsContextVariable(obj: ClusterPolicyV2Beta1SpecRulesMutateTargetsContextVariable | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'default': obj.default,
    'jmesPath': obj.jmesPath,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesMutateTargetsSelectorMatchExpressions
 */
export interface ClusterPolicyV2Beta1SpecRulesMutateTargetsSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateTargetsSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateTargetsSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateTargetsSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesMutateTargetsSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesMutateTargetsSelectorMatchExpressions(obj: ClusterPolicyV2Beta1SpecRulesMutateTargetsSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * selector can be used to match multiple param objects based on their labels.
 * Supply selector: {} to match all resources of the ParamKind.
 *
 * If multiple params are found, they are all evaluated with the policy expressions
 * and the results are ANDed together.
 *
 * One of `name` or `selector` must be set, but `name` and `selector` are
 * mutually exclusive properties. If one is set, the other must be unset.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesValidateCelParamRefSelector
 */
export interface ClusterPolicyV2Beta1SpecRulesValidateCelParamRefSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateCelParamRefSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterPolicyV2Beta1SpecRulesValidateCelParamRefSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateCelParamRefSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesValidateCelParamRefSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesValidateCelParamRefSelector(obj: ClusterPolicyV2Beta1SpecRulesValidateCelParamRefSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterPolicyV2Beta1SpecRulesValidateCelParamRefSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterPolicyV2Beta1SpecRulesValidateDenyConditionsAll
 */
export interface ClusterPolicyV2Beta1SpecRulesValidateDenyConditionsAll {
  /**
   * Key is the context entry (using JMESPath) for conditional rule evaluation.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateDenyConditionsAll#key
   */
  readonly key?: any;

  /**
   * Message is an optional display message
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateDenyConditionsAll#message
   */
  readonly message?: string;

  /**
   * Operator is the conditional operation to perform. Valid operators are:
   * Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
   * GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
   * DurationLessThanOrEquals, DurationLessThan
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateDenyConditionsAll#operator
   */
  readonly operator?: ClusterPolicyV2Beta1SpecRulesValidateDenyConditionsAllOperator;

  /**
   * Value is the conditional value, or set of values. The values can be fixed set
   * or can be variables declared using JMESPath.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateDenyConditionsAll#value
   */
  readonly value?: any;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesValidateDenyConditionsAll' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesValidateDenyConditionsAll(obj: ClusterPolicyV2Beta1SpecRulesValidateDenyConditionsAll | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'message': obj.message,
    'operator': obj.operator,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterPolicyV2Beta1SpecRulesValidateDenyConditionsAny
 */
export interface ClusterPolicyV2Beta1SpecRulesValidateDenyConditionsAny {
  /**
   * Key is the context entry (using JMESPath) for conditional rule evaluation.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateDenyConditionsAny#key
   */
  readonly key?: any;

  /**
   * Message is an optional display message
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateDenyConditionsAny#message
   */
  readonly message?: string;

  /**
   * Operator is the conditional operation to perform. Valid operators are:
   * Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
   * GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
   * DurationLessThanOrEquals, DurationLessThan
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateDenyConditionsAny#operator
   */
  readonly operator?: ClusterPolicyV2Beta1SpecRulesValidateDenyConditionsAnyOperator;

  /**
   * Value is the conditional value, or set of values. The values can be fixed set
   * or can be variables declared using JMESPath.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateDenyConditionsAny#value
   */
  readonly value?: any;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesValidateDenyConditionsAny' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesValidateDenyConditionsAny(obj: ClusterPolicyV2Beta1SpecRulesValidateDenyConditionsAny | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'message': obj.message,
    'operator': obj.operator,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesValidateFailureActionOverridesNamespaceSelectorMatchExpressions
 */
export interface ClusterPolicyV2Beta1SpecRulesValidateFailureActionOverridesNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateFailureActionOverridesNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateFailureActionOverridesNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateFailureActionOverridesNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesValidateFailureActionOverridesNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesValidateFailureActionOverridesNamespaceSelectorMatchExpressions(obj: ClusterPolicyV2Beta1SpecRulesValidateFailureActionOverridesNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * APICall is an HTTP request to the Kubernetes API server, or other JSON web service.
 * The data returned is stored in the context with the name for the context entry.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesValidateForeachContextApiCall
 */
export interface ClusterPolicyV2Beta1SpecRulesValidateForeachContextApiCall {
  /**
   * The data object specifies the POST data sent to the server.
   * Only applicable when the method field is set to POST.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateForeachContextApiCall#data
   */
  readonly data?: ClusterPolicyV2Beta1SpecRulesValidateForeachContextApiCallData[];

  /**
   * Default is an optional arbitrary JSON object that the context
   * value is set to, if the apiCall returns error.
   *
   * @default an optional arbitrary JSON object that the context
   * @schema ClusterPolicyV2Beta1SpecRulesValidateForeachContextApiCall#default
   */
  readonly default?: any;

  /**
   * JMESPath is an optional JSON Match Expression that can be used to
   * transform the JSON response returned from the server. For example
   * a JMESPath of "items | length(@)" applied to the API server response
   * for the URLPath "/apis/apps/v1/deployments" will return the total count
   * of deployments across all namespaces.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateForeachContextApiCall#jmesPath
   */
  readonly jmesPath?: string;

  /**
   * Method is the HTTP request type (GET or POST). Defaults to GET.
   *
   * @default GET.
   * @schema ClusterPolicyV2Beta1SpecRulesValidateForeachContextApiCall#method
   */
  readonly method?: ClusterPolicyV2Beta1SpecRulesValidateForeachContextApiCallMethod;

  /**
   * Service is an API call to a JSON web service.
   * This is used for non-Kubernetes API server calls.
   * It's mutually exclusive with the URLPath field.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateForeachContextApiCall#service
   */
  readonly service?: ClusterPolicyV2Beta1SpecRulesValidateForeachContextApiCallService;

  /**
   * URLPath is the URL path to be used in the HTTP GET or POST request to the
   * Kubernetes API server (e.g. "/api/v1/namespaces" or  "/apis/apps/v1/deployments").
   * The format required is the same format used by the `kubectl get --raw` command.
   * See https://kyverno.io/docs/writing-policies/external-data-sources/#variables-from-kubernetes-api-server-calls
   * for details.
   * It's mutually exclusive with the Service field.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateForeachContextApiCall#urlPath
   */
  readonly urlPath?: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesValidateForeachContextApiCall' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesValidateForeachContextApiCall(obj: ClusterPolicyV2Beta1SpecRulesValidateForeachContextApiCall | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'data': obj.data?.map(y => toJson_ClusterPolicyV2Beta1SpecRulesValidateForeachContextApiCallData(y)),
    'default': obj.default,
    'jmesPath': obj.jmesPath,
    'method': obj.method,
    'service': toJson_ClusterPolicyV2Beta1SpecRulesValidateForeachContextApiCallService(obj.service),
    'urlPath': obj.urlPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap is the ConfigMap reference.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesValidateForeachContextConfigMap
 */
export interface ClusterPolicyV2Beta1SpecRulesValidateForeachContextConfigMap {
  /**
   * Name is the ConfigMap name.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateForeachContextConfigMap#name
   */
  readonly name: string;

  /**
   * Namespace is the ConfigMap namespace.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateForeachContextConfigMap#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesValidateForeachContextConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesValidateForeachContextConfigMap(obj: ClusterPolicyV2Beta1SpecRulesValidateForeachContextConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GlobalContextEntryReference is a reference to a cached global context entry.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesValidateForeachContextGlobalReference
 */
export interface ClusterPolicyV2Beta1SpecRulesValidateForeachContextGlobalReference {
  /**
   * JMESPath is an optional JSON Match Expression that can be used to
   * transform the JSON response returned from the server. For example
   * a JMESPath of "items | length(@)" applied to the API server response
   * for the URLPath "/apis/apps/v1/deployments" will return the total count
   * of deployments across all namespaces.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateForeachContextGlobalReference#jmesPath
   */
  readonly jmesPath?: string;

  /**
   * Name of the global context entry
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateForeachContextGlobalReference#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesValidateForeachContextGlobalReference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesValidateForeachContextGlobalReference(obj: ClusterPolicyV2Beta1SpecRulesValidateForeachContextGlobalReference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'jmesPath': obj.jmesPath,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ImageRegistry defines requests to an OCI/Docker V2 registry to fetch image
 * details.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesValidateForeachContextImageRegistry
 */
export interface ClusterPolicyV2Beta1SpecRulesValidateForeachContextImageRegistry {
  /**
   * ImageRegistryCredentials provides credentials that will be used for authentication with registry
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateForeachContextImageRegistry#imageRegistryCredentials
   */
  readonly imageRegistryCredentials?: ClusterPolicyV2Beta1SpecRulesValidateForeachContextImageRegistryImageRegistryCredentials;

  /**
   * JMESPath is an optional JSON Match Expression that can be used to
   * transform the ImageData struct returned as a result of processing
   * the image reference.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateForeachContextImageRegistry#jmesPath
   */
  readonly jmesPath?: string;

  /**
   * Reference is image reference to a container image in the registry.
   * Example: ghcr.io/kyverno/kyverno:latest
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateForeachContextImageRegistry#reference
   */
  readonly reference: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesValidateForeachContextImageRegistry' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesValidateForeachContextImageRegistry(obj: ClusterPolicyV2Beta1SpecRulesValidateForeachContextImageRegistry | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'imageRegistryCredentials': toJson_ClusterPolicyV2Beta1SpecRulesValidateForeachContextImageRegistryImageRegistryCredentials(obj.imageRegistryCredentials),
    'jmesPath': obj.jmesPath,
    'reference': obj.reference,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Variable defines an arbitrary JMESPath context variable that can be defined inline.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesValidateForeachContextVariable
 */
export interface ClusterPolicyV2Beta1SpecRulesValidateForeachContextVariable {
  /**
   * Default is an optional arbitrary JSON object that the variable may take if the JMESPath
   * expression evaluates to nil
   *
   * @default an optional arbitrary JSON object that the variable may take if the JMESPath
   * @schema ClusterPolicyV2Beta1SpecRulesValidateForeachContextVariable#default
   */
  readonly default?: any;

  /**
   * JMESPath is an optional JMESPath Expression that can be used to
   * transform the variable.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateForeachContextVariable#jmesPath
   */
  readonly jmesPath?: string;

  /**
   * Value is any arbitrary JSON object representable in YAML or JSON form.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateForeachContextVariable#value
   */
  readonly value?: any;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesValidateForeachContextVariable' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesValidateForeachContextVariable(obj: ClusterPolicyV2Beta1SpecRulesValidateForeachContextVariable | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'default': obj.default,
    'jmesPath': obj.jmesPath,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Condition defines variable-based conditional criteria for rule execution.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesValidateForeachPreconditionsAll
 */
export interface ClusterPolicyV2Beta1SpecRulesValidateForeachPreconditionsAll {
  /**
   * Key is the context entry (using JMESPath) for conditional rule evaluation.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateForeachPreconditionsAll#key
   */
  readonly key?: any;

  /**
   * Message is an optional display message
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateForeachPreconditionsAll#message
   */
  readonly message?: string;

  /**
   * Operator is the conditional operation to perform. Valid operators are:
   * Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
   * GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
   * DurationLessThanOrEquals, DurationLessThan
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateForeachPreconditionsAll#operator
   */
  readonly operator?: ClusterPolicyV2Beta1SpecRulesValidateForeachPreconditionsAllOperator;

  /**
   * Value is the conditional value, or set of values. The values can be fixed set
   * or can be variables declared using JMESPath.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateForeachPreconditionsAll#value
   */
  readonly value?: any;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesValidateForeachPreconditionsAll' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesValidateForeachPreconditionsAll(obj: ClusterPolicyV2Beta1SpecRulesValidateForeachPreconditionsAll | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'message': obj.message,
    'operator': obj.operator,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Condition defines variable-based conditional criteria for rule execution.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesValidateForeachPreconditionsAny
 */
export interface ClusterPolicyV2Beta1SpecRulesValidateForeachPreconditionsAny {
  /**
   * Key is the context entry (using JMESPath) for conditional rule evaluation.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateForeachPreconditionsAny#key
   */
  readonly key?: any;

  /**
   * Message is an optional display message
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateForeachPreconditionsAny#message
   */
  readonly message?: string;

  /**
   * Operator is the conditional operation to perform. Valid operators are:
   * Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
   * GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
   * DurationLessThanOrEquals, DurationLessThan
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateForeachPreconditionsAny#operator
   */
  readonly operator?: ClusterPolicyV2Beta1SpecRulesValidateForeachPreconditionsAnyOperator;

  /**
   * Value is the conditional value, or set of values. The values can be fixed set
   * or can be variables declared using JMESPath.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateForeachPreconditionsAny#value
   */
  readonly value?: any;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesValidateForeachPreconditionsAny' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesValidateForeachPreconditionsAny(obj: ClusterPolicyV2Beta1SpecRulesValidateForeachPreconditionsAny | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'message': obj.message,
    'operator': obj.operator,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntries
 */
export interface ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntries {
  /**
   * Annotations are used for image verification.
   * Every specified key-value pair must exist and match in the verified payload.
   * The payload may contain other key-value pairs.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntries#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Attestor is a nested set of Attestor used to specify a more complex set of match authorities.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntries#attestor
   */
  readonly attestor?: any;

  /**
   * Certificates specifies one or more certificates.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntries#certificates
   */
  readonly certificates?: ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesCertificates;

  /**
   * Keyless is a set of attribute used to verify a Sigstore keyless attestor.
   * See https://github.com/sigstore/cosign/blob/main/KEYLESS.md.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntries#keyless
   */
  readonly keyless?: ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesKeyless;

  /**
   * Keys specifies one or more public keys.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntries#keys
   */
  readonly keys?: ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesKeys;

  /**
   * Repository is an optional alternate OCI repository to use for signatures and attestations that match this rule.
   * If specified Repository will override other OCI image repository locations for this Attestor.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntries#repository
   */
  readonly repository?: string;

  /**
   * Specify signature algorithm for public keys. Supported values are sha224, sha256, sha384 and sha512.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntries#signatureAlgorithm
   */
  readonly signatureAlgorithm?: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntries' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntries(obj: ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntries | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'attestor': obj.attestor,
    'certificates': toJson_ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesCertificates(obj.certificates),
    'keyless': toJson_ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesKeyless(obj.keyless),
    'keys': toJson_ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesKeys(obj.keys),
    'repository': obj.repository,
    'signatureAlgorithm': obj.signatureAlgorithm,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterPolicyV2Beta1SpecRulesValidateManifestsIgnoreFieldsObjects
 */
export interface ClusterPolicyV2Beta1SpecRulesValidateManifestsIgnoreFieldsObjects {
  /**
   * @schema ClusterPolicyV2Beta1SpecRulesValidateManifestsIgnoreFieldsObjects#group
   */
  readonly group?: string;

  /**
   * @schema ClusterPolicyV2Beta1SpecRulesValidateManifestsIgnoreFieldsObjects#kind
   */
  readonly kind?: string;

  /**
   * @schema ClusterPolicyV2Beta1SpecRulesValidateManifestsIgnoreFieldsObjects#name
   */
  readonly name?: string;

  /**
   * @schema ClusterPolicyV2Beta1SpecRulesValidateManifestsIgnoreFieldsObjects#namespace
   */
  readonly namespace?: string;

  /**
   * @schema ClusterPolicyV2Beta1SpecRulesValidateManifestsIgnoreFieldsObjects#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesValidateManifestsIgnoreFieldsObjects' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesValidateManifestsIgnoreFieldsObjects(obj: ClusterPolicyV2Beta1SpecRulesValidateManifestsIgnoreFieldsObjects | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ControlName specifies the name of the Pod Security Standard control.
 * See: https://kubernetes.io/docs/concepts/security/pod-security-standards/
 *
 * @schema ClusterPolicyV2Beta1SpecRulesValidatePodSecurityExcludeControlName
 */
export enum ClusterPolicyV2Beta1SpecRulesValidatePodSecurityExcludeControlName {
  /** HostProcess */
  HOST_PROCESS = "HostProcess",
  /** Host Namespaces */
  HOST_NAMESPACES = "Host Namespaces",
  /** Privileged Containers */
  PRIVILEGED_CONTAINERS = "Privileged Containers",
  /** Capabilities */
  CAPABILITIES = "Capabilities",
  /** HostPath Volumes */
  HOST_PATH_VOLUMES = "HostPath Volumes",
  /** Host Ports */
  HOST_PORTS = "Host Ports",
  /** AppArmor */
  APP_ARMOR = "AppArmor",
  /** SELinux */
  SE_LINUX = "SELinux",
  /** /proc Mount Type */
  VALUE_FORWARD_SLASH_PROC_MOUNT_TYPE = "/proc Mount Type",
  /** Seccomp */
  SECCOMP = "Seccomp",
  /** Sysctls */
  SYSCTLS = "Sysctls",
  /** Volume Types */
  VOLUME_TYPES = "Volume Types",
  /** Privilege Escalation */
  PRIVILEGE_ESCALATION = "Privilege Escalation",
  /** Running as Non-root */
  RUNNING_AS_NON_HYPHEN_ROOT = "Running as Non-root",
  /** Running as Non-root user */
  RUNNING_AS_NON_HYPHEN_ROOT_USER = "Running as Non-root user",
}

/**
 * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntries
 */
export interface ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntries {
  /**
   * Annotations are used for image verification.
   * Every specified key-value pair must exist and match in the verified payload.
   * The payload may contain other key-value pairs.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntries#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Attestor is a nested set of Attestor used to specify a more complex set of match authorities.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntries#attestor
   */
  readonly attestor?: any;

  /**
   * Certificates specifies one or more certificates.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntries#certificates
   */
  readonly certificates?: ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesCertificates;

  /**
   * Keyless is a set of attribute used to verify a Sigstore keyless attestor.
   * See https://github.com/sigstore/cosign/blob/main/KEYLESS.md.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntries#keyless
   */
  readonly keyless?: ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesKeyless;

  /**
   * Keys specifies one or more public keys.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntries#keys
   */
  readonly keys?: ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesKeys;

  /**
   * Repository is an optional alternate OCI repository to use for signatures and attestations that match this rule.
   * If specified Repository will override other OCI image repository locations for this Attestor.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntries#repository
   */
  readonly repository?: string;

  /**
   * Specify signature algorithm for public keys. Supported values are sha224, sha256, sha384 and sha512.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntries#signatureAlgorithm
   */
  readonly signatureAlgorithm?: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntries' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntries(obj: ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntries | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'attestor': obj.attestor,
    'certificates': toJson_ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesCertificates(obj.certificates),
    'keyless': toJson_ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesKeyless(obj.keyless),
    'keys': toJson_ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesKeys(obj.keys),
    'repository': obj.repository,
    'signatureAlgorithm': obj.signatureAlgorithm,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Condition defines variable-based conditional criteria for rule execution.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsConditionsAll
 */
export interface ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsConditionsAll {
  /**
   * Key is the context entry (using JMESPath) for conditional rule evaluation.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsConditionsAll#key
   */
  readonly key?: any;

  /**
   * Message is an optional display message
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsConditionsAll#message
   */
  readonly message?: string;

  /**
   * Operator is the conditional operation to perform. Valid operators are:
   * Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
   * GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
   * DurationLessThanOrEquals, DurationLessThan
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsConditionsAll#operator
   */
  readonly operator?: ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsConditionsAllOperator;

  /**
   * Value is the conditional value, or set of values. The values can be fixed set
   * or can be variables declared using JMESPath.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsConditionsAll#value
   */
  readonly value?: any;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsConditionsAll' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsConditionsAll(obj: ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsConditionsAll | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'message': obj.message,
    'operator': obj.operator,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Condition defines variable-based conditional criteria for rule execution.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsConditionsAny
 */
export interface ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsConditionsAny {
  /**
   * Key is the context entry (using JMESPath) for conditional rule evaluation.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsConditionsAny#key
   */
  readonly key?: any;

  /**
   * Message is an optional display message
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsConditionsAny#message
   */
  readonly message?: string;

  /**
   * Operator is the conditional operation to perform. Valid operators are:
   * Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
   * GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
   * DurationLessThanOrEquals, DurationLessThan
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsConditionsAny#operator
   */
  readonly operator?: ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsConditionsAnyOperator;

  /**
   * Value is the conditional value, or set of values. The values can be fixed set
   * or can be variables declared using JMESPath.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsConditionsAny#value
   */
  readonly value?: any;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsConditionsAny' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsConditionsAny(obj: ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsConditionsAny | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'message': obj.message,
    'operator': obj.operator,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Certificates specifies one or more certificates.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesCertificates
 */
export interface ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesCertificates {
  /**
   * Cert is an optional PEM-encoded public certificate.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesCertificates#cert
   */
  readonly cert?: string;

  /**
   * CertChain is an optional PEM encoded set of certificates used to verify.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesCertificates#certChain
   */
  readonly certChain?: string;

  /**
   * CTLog (certificate timestamp log) provides a configuration for validation of Signed Certificate
   * Timestamps (SCTs). If the value is unset, the default behavior by Cosign is used.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesCertificates#ctlog
   */
  readonly ctlog?: ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesCertificatesCtlog;

  /**
   * Rekor provides configuration for the Rekor transparency log service. If an empty object
   * is provided the public instance of Rekor (https://rekor.sigstore.dev) is used.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesCertificates#rekor
   */
  readonly rekor?: ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesCertificatesRekor;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesCertificates' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesCertificates(obj: ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesCertificates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cert': obj.cert,
    'certChain': obj.certChain,
    'ctlog': toJson_ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesCertificatesCtlog(obj.ctlog),
    'rekor': toJson_ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesCertificatesRekor(obj.rekor),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Keyless is a set of attribute used to verify a Sigstore keyless attestor.
 * See https://github.com/sigstore/cosign/blob/main/KEYLESS.md.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesKeyless
 */
export interface ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesKeyless {
  /**
   * AdditionalExtensions are certificate-extensions used for keyless signing.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesKeyless#additionalExtensions
   */
  readonly additionalExtensions?: { [key: string]: string };

  /**
   * CTLog (certificate timestamp log) provides a configuration for validation of Signed Certificate
   * Timestamps (SCTs). If the value is unset, the default behavior by Cosign is used.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesKeyless#ctlog
   */
  readonly ctlog?: ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesKeylessCtlog;

  /**
   * Issuer is the certificate issuer used for keyless signing.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesKeyless#issuer
   */
  readonly issuer?: string;

  /**
   * IssuerRegExp is the regular expression to match certificate issuer used for keyless signing.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesKeyless#issuerRegExp
   */
  readonly issuerRegExp?: string;

  /**
   * Rekor provides configuration for the Rekor transparency log service. If an empty object
   * is provided the public instance of Rekor (https://rekor.sigstore.dev) is used.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesKeyless#rekor
   */
  readonly rekor?: ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesKeylessRekor;

  /**
   * Roots is an optional set of PEM encoded trusted root certificates.
   * If not provided, the system roots are used.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesKeyless#roots
   */
  readonly roots?: string;

  /**
   * Subject is the verified identity used for keyless signing, for example the email address.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesKeyless#subject
   */
  readonly subject?: string;

  /**
   * SubjectRegExp is the regular expression to match identity used for keyless signing, for example the email address.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesKeyless#subjectRegExp
   */
  readonly subjectRegExp?: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesKeyless' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesKeyless(obj: ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesKeyless | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalExtensions': ((obj.additionalExtensions) === undefined) ? undefined : (Object.entries(obj.additionalExtensions).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'ctlog': toJson_ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesKeylessCtlog(obj.ctlog),
    'issuer': obj.issuer,
    'issuerRegExp': obj.issuerRegExp,
    'rekor': toJson_ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesKeylessRekor(obj.rekor),
    'roots': obj.roots,
    'subject': obj.subject,
    'subjectRegExp': obj.subjectRegExp,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Keys specifies one or more public keys.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesKeys
 */
export interface ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesKeys {
  /**
   * CTLog (certificate timestamp log) provides a configuration for validation of Signed Certificate
   * Timestamps (SCTs). If the value is unset, the default behavior by Cosign is used.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesKeys#ctlog
   */
  readonly ctlog?: ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesKeysCtlog;

  /**
   * KMS provides the URI to the public key stored in a Key Management System. See:
   * https://github.com/sigstore/cosign/blob/main/KMS.md
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesKeys#kms
   */
  readonly kms?: string;

  /**
   * Keys is a set of X.509 public keys used to verify image signatures. The keys can be directly
   * specified or can be a variable reference to a key specified in a ConfigMap (see
   * https://kyverno.io/docs/writing-policies/variables/), or reference a standard Kubernetes Secret
   * elsewhere in the cluster by specifying it in the format "k8s://<namespace>/<secret_name>".
   * The named Secret must specify a key `cosign.pub` containing the public key used for
   * verification, (see https://github.com/sigstore/cosign/blob/main/KMS.md#kubernetes-secret).
   * When multiple keys are specified each key is processed as a separate staticKey entry
   * (.attestors[*].entries.keys) within the set of attestors and the count is applied across the keys.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesKeys#publicKeys
   */
  readonly publicKeys?: string;

  /**
   * Rekor provides configuration for the Rekor transparency log service. If an empty object
   * is provided the public instance of Rekor (https://rekor.sigstore.dev) is used.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesKeys#rekor
   */
  readonly rekor?: ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesKeysRekor;

  /**
   * Reference to a Secret resource that contains a public key
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesKeys#secret
   */
  readonly secret?: ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesKeysSecret;

  /**
   * Deprecated. Use attestor.signatureAlgorithm instead.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesKeys#signatureAlgorithm
   */
  readonly signatureAlgorithm?: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesKeys' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesKeys(obj: ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesKeys | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ctlog': toJson_ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesKeysCtlog(obj.ctlog),
    'kms': obj.kms,
    'publicKeys': obj.publicKeys,
    'rekor': toJson_ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesKeysRekor(obj.rekor),
    'secret': toJson_ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesKeysSecret(obj.secret),
    'signatureAlgorithm': obj.signatureAlgorithm,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesExcludeAllResourcesNamespaceSelectorMatchExpressions
 */
export interface ClusterPolicyV2Beta1SpecRulesExcludeAllResourcesNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesExcludeAllResourcesNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesExcludeAllResourcesNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesExcludeAllResourcesNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesExcludeAllResourcesNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesExcludeAllResourcesNamespaceSelectorMatchExpressions(obj: ClusterPolicyV2Beta1SpecRulesExcludeAllResourcesNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesExcludeAllResourcesSelectorMatchExpressions
 */
export interface ClusterPolicyV2Beta1SpecRulesExcludeAllResourcesSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesExcludeAllResourcesSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesExcludeAllResourcesSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesExcludeAllResourcesSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesExcludeAllResourcesSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesExcludeAllResourcesSelectorMatchExpressions(obj: ClusterPolicyV2Beta1SpecRulesExcludeAllResourcesSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesExcludeAnyResourcesNamespaceSelectorMatchExpressions
 */
export interface ClusterPolicyV2Beta1SpecRulesExcludeAnyResourcesNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesExcludeAnyResourcesNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesExcludeAnyResourcesNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesExcludeAnyResourcesNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesExcludeAnyResourcesNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesExcludeAnyResourcesNamespaceSelectorMatchExpressions(obj: ClusterPolicyV2Beta1SpecRulesExcludeAnyResourcesNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesExcludeAnyResourcesSelectorMatchExpressions
 */
export interface ClusterPolicyV2Beta1SpecRulesExcludeAnyResourcesSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesExcludeAnyResourcesSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesExcludeAnyResourcesSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesExcludeAnyResourcesSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesExcludeAnyResourcesSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesExcludeAnyResourcesSelectorMatchExpressions(obj: ClusterPolicyV2Beta1SpecRulesExcludeAnyResourcesSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeachCloneListSelectorMatchExpressions
 */
export interface ClusterPolicyV2Beta1SpecRulesGenerateForeachCloneListSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeachCloneListSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeachCloneListSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeachCloneListSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesGenerateForeachCloneListSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesGenerateForeachCloneListSelectorMatchExpressions(obj: ClusterPolicyV2Beta1SpecRulesGenerateForeachCloneListSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RequestData contains the HTTP POST data
 *
 * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeachContextApiCallData
 */
export interface ClusterPolicyV2Beta1SpecRulesGenerateForeachContextApiCallData {
  /**
   * Key is a unique identifier for the data value
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeachContextApiCallData#key
   */
  readonly key: string;

  /**
   * Value is the data value
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeachContextApiCallData#value
   */
  readonly value: any;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesGenerateForeachContextApiCallData' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesGenerateForeachContextApiCallData(obj: ClusterPolicyV2Beta1SpecRulesGenerateForeachContextApiCallData | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Method is the HTTP request type (GET or POST). Defaults to GET.
 *
 * @default GET.
 * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeachContextApiCallMethod
 */
export enum ClusterPolicyV2Beta1SpecRulesGenerateForeachContextApiCallMethod {
  /** GET */
  GET = "GET",
  /** POST */
  POST = "POST",
}

/**
 * Service is an API call to a JSON web service.
 * This is used for non-Kubernetes API server calls.
 * It's mutually exclusive with the URLPath field.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeachContextApiCallService
 */
export interface ClusterPolicyV2Beta1SpecRulesGenerateForeachContextApiCallService {
  /**
   * CABundle is a PEM encoded CA bundle which will be used to validate
   * the server certificate.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeachContextApiCallService#caBundle
   */
  readonly caBundle?: string;

  /**
   * Headers is a list of optional HTTP headers to be included in the request.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeachContextApiCallService#headers
   */
  readonly headers?: ClusterPolicyV2Beta1SpecRulesGenerateForeachContextApiCallServiceHeaders[];

  /**
   * URL is the JSON web service URL. A typical form is
   * `https://{service}.{namespace}:{port}/{path}`.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeachContextApiCallService#url
   */
  readonly url: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesGenerateForeachContextApiCallService' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesGenerateForeachContextApiCallService(obj: ClusterPolicyV2Beta1SpecRulesGenerateForeachContextApiCallService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caBundle': obj.caBundle,
    'headers': obj.headers?.map(y => toJson_ClusterPolicyV2Beta1SpecRulesGenerateForeachContextApiCallServiceHeaders(y)),
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ImageRegistryCredentials provides credentials that will be used for authentication with registry
 *
 * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeachContextImageRegistryImageRegistryCredentials
 */
export interface ClusterPolicyV2Beta1SpecRulesGenerateForeachContextImageRegistryImageRegistryCredentials {
  /**
   * AllowInsecureRegistry allows insecure access to a registry.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeachContextImageRegistryImageRegistryCredentials#allowInsecureRegistry
   */
  readonly allowInsecureRegistry?: boolean;

  /**
   * Providers specifies a list of OCI Registry names, whose authentication providers are provided.
   * It can be of one of these values: default,google,azure,amazon,github.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeachContextImageRegistryImageRegistryCredentials#providers
   */
  readonly providers?: ClusterPolicyV2Beta1SpecRulesGenerateForeachContextImageRegistryImageRegistryCredentialsProviders[];

  /**
   * Secrets specifies a list of secrets that are provided for credentials.
   * Secrets must live in the Kyverno namespace.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeachContextImageRegistryImageRegistryCredentials#secrets
   */
  readonly secrets?: string[];

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesGenerateForeachContextImageRegistryImageRegistryCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesGenerateForeachContextImageRegistryImageRegistryCredentials(obj: ClusterPolicyV2Beta1SpecRulesGenerateForeachContextImageRegistryImageRegistryCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowInsecureRegistry': obj.allowInsecureRegistry,
    'providers': obj.providers?.map(y => y),
    'secrets': obj.secrets?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Operator is the conditional operation to perform. Valid operators are:
 * Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
 * GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
 * DurationLessThanOrEquals, DurationLessThan
 *
 * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeachPreconditionsAllOperator
 */
export enum ClusterPolicyV2Beta1SpecRulesGenerateForeachPreconditionsAllOperator {
  /** Equals */
  EQUALS = "Equals",
  /** NotEquals */
  NOT_EQUALS = "NotEquals",
  /** In */
  IN = "In",
  /** AnyIn */
  ANY_IN = "AnyIn",
  /** AllIn */
  ALL_IN = "AllIn",
  /** NotIn */
  NOT_IN = "NotIn",
  /** AnyNotIn */
  ANY_NOT_IN = "AnyNotIn",
  /** AllNotIn */
  ALL_NOT_IN = "AllNotIn",
  /** GreaterThanOrEquals */
  GREATER_THAN_OR_EQUALS = "GreaterThanOrEquals",
  /** GreaterThan */
  GREATER_THAN = "GreaterThan",
  /** LessThanOrEquals */
  LESS_THAN_OR_EQUALS = "LessThanOrEquals",
  /** LessThan */
  LESS_THAN = "LessThan",
  /** DurationGreaterThanOrEquals */
  DURATION_GREATER_THAN_OR_EQUALS = "DurationGreaterThanOrEquals",
  /** DurationGreaterThan */
  DURATION_GREATER_THAN = "DurationGreaterThan",
  /** DurationLessThanOrEquals */
  DURATION_LESS_THAN_OR_EQUALS = "DurationLessThanOrEquals",
  /** DurationLessThan */
  DURATION_LESS_THAN = "DurationLessThan",
}

/**
 * Operator is the conditional operation to perform. Valid operators are:
 * Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
 * GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
 * DurationLessThanOrEquals, DurationLessThan
 *
 * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeachPreconditionsAnyOperator
 */
export enum ClusterPolicyV2Beta1SpecRulesGenerateForeachPreconditionsAnyOperator {
  /** Equals */
  EQUALS = "Equals",
  /** NotEquals */
  NOT_EQUALS = "NotEquals",
  /** In */
  IN = "In",
  /** AnyIn */
  ANY_IN = "AnyIn",
  /** AllIn */
  ALL_IN = "AllIn",
  /** NotIn */
  NOT_IN = "NotIn",
  /** AnyNotIn */
  ANY_NOT_IN = "AnyNotIn",
  /** AllNotIn */
  ALL_NOT_IN = "AllNotIn",
  /** GreaterThanOrEquals */
  GREATER_THAN_OR_EQUALS = "GreaterThanOrEquals",
  /** GreaterThan */
  GREATER_THAN = "GreaterThan",
  /** LessThanOrEquals */
  LESS_THAN_OR_EQUALS = "LessThanOrEquals",
  /** LessThan */
  LESS_THAN = "LessThan",
  /** DurationGreaterThanOrEquals */
  DURATION_GREATER_THAN_OR_EQUALS = "DurationGreaterThanOrEquals",
  /** DurationGreaterThan */
  DURATION_GREATER_THAN = "DurationGreaterThan",
  /** DurationLessThanOrEquals */
  DURATION_LESS_THAN_OR_EQUALS = "DurationLessThanOrEquals",
  /** DurationLessThan */
  DURATION_LESS_THAN = "DurationLessThan",
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesMatchAllResourcesNamespaceSelectorMatchExpressions
 */
export interface ClusterPolicyV2Beta1SpecRulesMatchAllResourcesNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMatchAllResourcesNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMatchAllResourcesNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMatchAllResourcesNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesMatchAllResourcesNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesMatchAllResourcesNamespaceSelectorMatchExpressions(obj: ClusterPolicyV2Beta1SpecRulesMatchAllResourcesNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesMatchAllResourcesSelectorMatchExpressions
 */
export interface ClusterPolicyV2Beta1SpecRulesMatchAllResourcesSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMatchAllResourcesSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMatchAllResourcesSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMatchAllResourcesSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesMatchAllResourcesSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesMatchAllResourcesSelectorMatchExpressions(obj: ClusterPolicyV2Beta1SpecRulesMatchAllResourcesSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesMatchAnyResourcesNamespaceSelectorMatchExpressions
 */
export interface ClusterPolicyV2Beta1SpecRulesMatchAnyResourcesNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMatchAnyResourcesNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMatchAnyResourcesNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMatchAnyResourcesNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesMatchAnyResourcesNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesMatchAnyResourcesNamespaceSelectorMatchExpressions(obj: ClusterPolicyV2Beta1SpecRulesMatchAnyResourcesNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesMatchAnyResourcesSelectorMatchExpressions
 */
export interface ClusterPolicyV2Beta1SpecRulesMatchAnyResourcesSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMatchAnyResourcesSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMatchAnyResourcesSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMatchAnyResourcesSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesMatchAnyResourcesSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesMatchAnyResourcesSelectorMatchExpressions(obj: ClusterPolicyV2Beta1SpecRulesMatchAnyResourcesSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RequestData contains the HTTP POST data
 *
 * @schema ClusterPolicyV2Beta1SpecRulesMutateForeachContextApiCallData
 */
export interface ClusterPolicyV2Beta1SpecRulesMutateForeachContextApiCallData {
  /**
   * Key is a unique identifier for the data value
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateForeachContextApiCallData#key
   */
  readonly key: string;

  /**
   * Value is the data value
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateForeachContextApiCallData#value
   */
  readonly value: any;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesMutateForeachContextApiCallData' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesMutateForeachContextApiCallData(obj: ClusterPolicyV2Beta1SpecRulesMutateForeachContextApiCallData | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Method is the HTTP request type (GET or POST). Defaults to GET.
 *
 * @default GET.
 * @schema ClusterPolicyV2Beta1SpecRulesMutateForeachContextApiCallMethod
 */
export enum ClusterPolicyV2Beta1SpecRulesMutateForeachContextApiCallMethod {
  /** GET */
  GET = "GET",
  /** POST */
  POST = "POST",
}

/**
 * Service is an API call to a JSON web service.
 * This is used for non-Kubernetes API server calls.
 * It's mutually exclusive with the URLPath field.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesMutateForeachContextApiCallService
 */
export interface ClusterPolicyV2Beta1SpecRulesMutateForeachContextApiCallService {
  /**
   * CABundle is a PEM encoded CA bundle which will be used to validate
   * the server certificate.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateForeachContextApiCallService#caBundle
   */
  readonly caBundle?: string;

  /**
   * Headers is a list of optional HTTP headers to be included in the request.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateForeachContextApiCallService#headers
   */
  readonly headers?: ClusterPolicyV2Beta1SpecRulesMutateForeachContextApiCallServiceHeaders[];

  /**
   * URL is the JSON web service URL. A typical form is
   * `https://{service}.{namespace}:{port}/{path}`.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateForeachContextApiCallService#url
   */
  readonly url: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesMutateForeachContextApiCallService' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesMutateForeachContextApiCallService(obj: ClusterPolicyV2Beta1SpecRulesMutateForeachContextApiCallService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caBundle': obj.caBundle,
    'headers': obj.headers?.map(y => toJson_ClusterPolicyV2Beta1SpecRulesMutateForeachContextApiCallServiceHeaders(y)),
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ImageRegistryCredentials provides credentials that will be used for authentication with registry
 *
 * @schema ClusterPolicyV2Beta1SpecRulesMutateForeachContextImageRegistryImageRegistryCredentials
 */
export interface ClusterPolicyV2Beta1SpecRulesMutateForeachContextImageRegistryImageRegistryCredentials {
  /**
   * AllowInsecureRegistry allows insecure access to a registry.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateForeachContextImageRegistryImageRegistryCredentials#allowInsecureRegistry
   */
  readonly allowInsecureRegistry?: boolean;

  /**
   * Providers specifies a list of OCI Registry names, whose authentication providers are provided.
   * It can be of one of these values: default,google,azure,amazon,github.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateForeachContextImageRegistryImageRegistryCredentials#providers
   */
  readonly providers?: ClusterPolicyV2Beta1SpecRulesMutateForeachContextImageRegistryImageRegistryCredentialsProviders[];

  /**
   * Secrets specifies a list of secrets that are provided for credentials.
   * Secrets must live in the Kyverno namespace.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateForeachContextImageRegistryImageRegistryCredentials#secrets
   */
  readonly secrets?: string[];

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesMutateForeachContextImageRegistryImageRegistryCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesMutateForeachContextImageRegistryImageRegistryCredentials(obj: ClusterPolicyV2Beta1SpecRulesMutateForeachContextImageRegistryImageRegistryCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowInsecureRegistry': obj.allowInsecureRegistry,
    'providers': obj.providers?.map(y => y),
    'secrets': obj.secrets?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Operator is the conditional operation to perform. Valid operators are:
 * Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
 * GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
 * DurationLessThanOrEquals, DurationLessThan
 *
 * @schema ClusterPolicyV2Beta1SpecRulesMutateForeachPreconditionsAllOperator
 */
export enum ClusterPolicyV2Beta1SpecRulesMutateForeachPreconditionsAllOperator {
  /** Equals */
  EQUALS = "Equals",
  /** NotEquals */
  NOT_EQUALS = "NotEquals",
  /** In */
  IN = "In",
  /** AnyIn */
  ANY_IN = "AnyIn",
  /** AllIn */
  ALL_IN = "AllIn",
  /** NotIn */
  NOT_IN = "NotIn",
  /** AnyNotIn */
  ANY_NOT_IN = "AnyNotIn",
  /** AllNotIn */
  ALL_NOT_IN = "AllNotIn",
  /** GreaterThanOrEquals */
  GREATER_THAN_OR_EQUALS = "GreaterThanOrEquals",
  /** GreaterThan */
  GREATER_THAN = "GreaterThan",
  /** LessThanOrEquals */
  LESS_THAN_OR_EQUALS = "LessThanOrEquals",
  /** LessThan */
  LESS_THAN = "LessThan",
  /** DurationGreaterThanOrEquals */
  DURATION_GREATER_THAN_OR_EQUALS = "DurationGreaterThanOrEquals",
  /** DurationGreaterThan */
  DURATION_GREATER_THAN = "DurationGreaterThan",
  /** DurationLessThanOrEquals */
  DURATION_LESS_THAN_OR_EQUALS = "DurationLessThanOrEquals",
  /** DurationLessThan */
  DURATION_LESS_THAN = "DurationLessThan",
}

/**
 * Operator is the conditional operation to perform. Valid operators are:
 * Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
 * GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
 * DurationLessThanOrEquals, DurationLessThan
 *
 * @schema ClusterPolicyV2Beta1SpecRulesMutateForeachPreconditionsAnyOperator
 */
export enum ClusterPolicyV2Beta1SpecRulesMutateForeachPreconditionsAnyOperator {
  /** Equals */
  EQUALS = "Equals",
  /** NotEquals */
  NOT_EQUALS = "NotEquals",
  /** In */
  IN = "In",
  /** AnyIn */
  ANY_IN = "AnyIn",
  /** AllIn */
  ALL_IN = "AllIn",
  /** NotIn */
  NOT_IN = "NotIn",
  /** AnyNotIn */
  ANY_NOT_IN = "AnyNotIn",
  /** AllNotIn */
  ALL_NOT_IN = "AllNotIn",
  /** GreaterThanOrEquals */
  GREATER_THAN_OR_EQUALS = "GreaterThanOrEquals",
  /** GreaterThan */
  GREATER_THAN = "GreaterThan",
  /** LessThanOrEquals */
  LESS_THAN_OR_EQUALS = "LessThanOrEquals",
  /** LessThan */
  LESS_THAN = "LessThan",
  /** DurationGreaterThanOrEquals */
  DURATION_GREATER_THAN_OR_EQUALS = "DurationGreaterThanOrEquals",
  /** DurationGreaterThan */
  DURATION_GREATER_THAN = "DurationGreaterThan",
  /** DurationLessThanOrEquals */
  DURATION_LESS_THAN_OR_EQUALS = "DurationLessThanOrEquals",
  /** DurationLessThan */
  DURATION_LESS_THAN = "DurationLessThan",
}

/**
 * RequestData contains the HTTP POST data
 *
 * @schema ClusterPolicyV2Beta1SpecRulesMutateTargetsContextApiCallData
 */
export interface ClusterPolicyV2Beta1SpecRulesMutateTargetsContextApiCallData {
  /**
   * Key is a unique identifier for the data value
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateTargetsContextApiCallData#key
   */
  readonly key: string;

  /**
   * Value is the data value
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateTargetsContextApiCallData#value
   */
  readonly value: any;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesMutateTargetsContextApiCallData' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesMutateTargetsContextApiCallData(obj: ClusterPolicyV2Beta1SpecRulesMutateTargetsContextApiCallData | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Method is the HTTP request type (GET or POST). Defaults to GET.
 *
 * @default GET.
 * @schema ClusterPolicyV2Beta1SpecRulesMutateTargetsContextApiCallMethod
 */
export enum ClusterPolicyV2Beta1SpecRulesMutateTargetsContextApiCallMethod {
  /** GET */
  GET = "GET",
  /** POST */
  POST = "POST",
}

/**
 * Service is an API call to a JSON web service.
 * This is used for non-Kubernetes API server calls.
 * It's mutually exclusive with the URLPath field.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesMutateTargetsContextApiCallService
 */
export interface ClusterPolicyV2Beta1SpecRulesMutateTargetsContextApiCallService {
  /**
   * CABundle is a PEM encoded CA bundle which will be used to validate
   * the server certificate.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateTargetsContextApiCallService#caBundle
   */
  readonly caBundle?: string;

  /**
   * Headers is a list of optional HTTP headers to be included in the request.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateTargetsContextApiCallService#headers
   */
  readonly headers?: ClusterPolicyV2Beta1SpecRulesMutateTargetsContextApiCallServiceHeaders[];

  /**
   * URL is the JSON web service URL. A typical form is
   * `https://{service}.{namespace}:{port}/{path}`.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateTargetsContextApiCallService#url
   */
  readonly url: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesMutateTargetsContextApiCallService' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesMutateTargetsContextApiCallService(obj: ClusterPolicyV2Beta1SpecRulesMutateTargetsContextApiCallService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caBundle': obj.caBundle,
    'headers': obj.headers?.map(y => toJson_ClusterPolicyV2Beta1SpecRulesMutateTargetsContextApiCallServiceHeaders(y)),
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ImageRegistryCredentials provides credentials that will be used for authentication with registry
 *
 * @schema ClusterPolicyV2Beta1SpecRulesMutateTargetsContextImageRegistryImageRegistryCredentials
 */
export interface ClusterPolicyV2Beta1SpecRulesMutateTargetsContextImageRegistryImageRegistryCredentials {
  /**
   * AllowInsecureRegistry allows insecure access to a registry.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateTargetsContextImageRegistryImageRegistryCredentials#allowInsecureRegistry
   */
  readonly allowInsecureRegistry?: boolean;

  /**
   * Providers specifies a list of OCI Registry names, whose authentication providers are provided.
   * It can be of one of these values: default,google,azure,amazon,github.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateTargetsContextImageRegistryImageRegistryCredentials#providers
   */
  readonly providers?: ClusterPolicyV2Beta1SpecRulesMutateTargetsContextImageRegistryImageRegistryCredentialsProviders[];

  /**
   * Secrets specifies a list of secrets that are provided for credentials.
   * Secrets must live in the Kyverno namespace.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateTargetsContextImageRegistryImageRegistryCredentials#secrets
   */
  readonly secrets?: string[];

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesMutateTargetsContextImageRegistryImageRegistryCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesMutateTargetsContextImageRegistryImageRegistryCredentials(obj: ClusterPolicyV2Beta1SpecRulesMutateTargetsContextImageRegistryImageRegistryCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowInsecureRegistry': obj.allowInsecureRegistry,
    'providers': obj.providers?.map(y => y),
    'secrets': obj.secrets?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesValidateCelParamRefSelectorMatchExpressions
 */
export interface ClusterPolicyV2Beta1SpecRulesValidateCelParamRefSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateCelParamRefSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateCelParamRefSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateCelParamRefSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesValidateCelParamRefSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesValidateCelParamRefSelectorMatchExpressions(obj: ClusterPolicyV2Beta1SpecRulesValidateCelParamRefSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Operator is the conditional operation to perform. Valid operators are:
 * Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
 * GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
 * DurationLessThanOrEquals, DurationLessThan
 *
 * @schema ClusterPolicyV2Beta1SpecRulesValidateDenyConditionsAllOperator
 */
export enum ClusterPolicyV2Beta1SpecRulesValidateDenyConditionsAllOperator {
  /** Equals */
  EQUALS = "Equals",
  /** NotEquals */
  NOT_EQUALS = "NotEquals",
  /** AnyIn */
  ANY_IN = "AnyIn",
  /** AllIn */
  ALL_IN = "AllIn",
  /** AnyNotIn */
  ANY_NOT_IN = "AnyNotIn",
  /** AllNotIn */
  ALL_NOT_IN = "AllNotIn",
  /** GreaterThanOrEquals */
  GREATER_THAN_OR_EQUALS = "GreaterThanOrEquals",
  /** GreaterThan */
  GREATER_THAN = "GreaterThan",
  /** LessThanOrEquals */
  LESS_THAN_OR_EQUALS = "LessThanOrEquals",
  /** LessThan */
  LESS_THAN = "LessThan",
  /** DurationGreaterThanOrEquals */
  DURATION_GREATER_THAN_OR_EQUALS = "DurationGreaterThanOrEquals",
  /** DurationGreaterThan */
  DURATION_GREATER_THAN = "DurationGreaterThan",
  /** DurationLessThanOrEquals */
  DURATION_LESS_THAN_OR_EQUALS = "DurationLessThanOrEquals",
  /** DurationLessThan */
  DURATION_LESS_THAN = "DurationLessThan",
}

/**
 * Operator is the conditional operation to perform. Valid operators are:
 * Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
 * GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
 * DurationLessThanOrEquals, DurationLessThan
 *
 * @schema ClusterPolicyV2Beta1SpecRulesValidateDenyConditionsAnyOperator
 */
export enum ClusterPolicyV2Beta1SpecRulesValidateDenyConditionsAnyOperator {
  /** Equals */
  EQUALS = "Equals",
  /** NotEquals */
  NOT_EQUALS = "NotEquals",
  /** AnyIn */
  ANY_IN = "AnyIn",
  /** AllIn */
  ALL_IN = "AllIn",
  /** AnyNotIn */
  ANY_NOT_IN = "AnyNotIn",
  /** AllNotIn */
  ALL_NOT_IN = "AllNotIn",
  /** GreaterThanOrEquals */
  GREATER_THAN_OR_EQUALS = "GreaterThanOrEquals",
  /** GreaterThan */
  GREATER_THAN = "GreaterThan",
  /** LessThanOrEquals */
  LESS_THAN_OR_EQUALS = "LessThanOrEquals",
  /** LessThan */
  LESS_THAN = "LessThan",
  /** DurationGreaterThanOrEquals */
  DURATION_GREATER_THAN_OR_EQUALS = "DurationGreaterThanOrEquals",
  /** DurationGreaterThan */
  DURATION_GREATER_THAN = "DurationGreaterThan",
  /** DurationLessThanOrEquals */
  DURATION_LESS_THAN_OR_EQUALS = "DurationLessThanOrEquals",
  /** DurationLessThan */
  DURATION_LESS_THAN = "DurationLessThan",
}

/**
 * RequestData contains the HTTP POST data
 *
 * @schema ClusterPolicyV2Beta1SpecRulesValidateForeachContextApiCallData
 */
export interface ClusterPolicyV2Beta1SpecRulesValidateForeachContextApiCallData {
  /**
   * Key is a unique identifier for the data value
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateForeachContextApiCallData#key
   */
  readonly key: string;

  /**
   * Value is the data value
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateForeachContextApiCallData#value
   */
  readonly value: any;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesValidateForeachContextApiCallData' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesValidateForeachContextApiCallData(obj: ClusterPolicyV2Beta1SpecRulesValidateForeachContextApiCallData | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Method is the HTTP request type (GET or POST). Defaults to GET.
 *
 * @default GET.
 * @schema ClusterPolicyV2Beta1SpecRulesValidateForeachContextApiCallMethod
 */
export enum ClusterPolicyV2Beta1SpecRulesValidateForeachContextApiCallMethod {
  /** GET */
  GET = "GET",
  /** POST */
  POST = "POST",
}

/**
 * Service is an API call to a JSON web service.
 * This is used for non-Kubernetes API server calls.
 * It's mutually exclusive with the URLPath field.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesValidateForeachContextApiCallService
 */
export interface ClusterPolicyV2Beta1SpecRulesValidateForeachContextApiCallService {
  /**
   * CABundle is a PEM encoded CA bundle which will be used to validate
   * the server certificate.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateForeachContextApiCallService#caBundle
   */
  readonly caBundle?: string;

  /**
   * Headers is a list of optional HTTP headers to be included in the request.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateForeachContextApiCallService#headers
   */
  readonly headers?: ClusterPolicyV2Beta1SpecRulesValidateForeachContextApiCallServiceHeaders[];

  /**
   * URL is the JSON web service URL. A typical form is
   * `https://{service}.{namespace}:{port}/{path}`.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateForeachContextApiCallService#url
   */
  readonly url: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesValidateForeachContextApiCallService' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesValidateForeachContextApiCallService(obj: ClusterPolicyV2Beta1SpecRulesValidateForeachContextApiCallService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caBundle': obj.caBundle,
    'headers': obj.headers?.map(y => toJson_ClusterPolicyV2Beta1SpecRulesValidateForeachContextApiCallServiceHeaders(y)),
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ImageRegistryCredentials provides credentials that will be used for authentication with registry
 *
 * @schema ClusterPolicyV2Beta1SpecRulesValidateForeachContextImageRegistryImageRegistryCredentials
 */
export interface ClusterPolicyV2Beta1SpecRulesValidateForeachContextImageRegistryImageRegistryCredentials {
  /**
   * AllowInsecureRegistry allows insecure access to a registry.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateForeachContextImageRegistryImageRegistryCredentials#allowInsecureRegistry
   */
  readonly allowInsecureRegistry?: boolean;

  /**
   * Providers specifies a list of OCI Registry names, whose authentication providers are provided.
   * It can be of one of these values: default,google,azure,amazon,github.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateForeachContextImageRegistryImageRegistryCredentials#providers
   */
  readonly providers?: ClusterPolicyV2Beta1SpecRulesValidateForeachContextImageRegistryImageRegistryCredentialsProviders[];

  /**
   * Secrets specifies a list of secrets that are provided for credentials.
   * Secrets must live in the Kyverno namespace.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateForeachContextImageRegistryImageRegistryCredentials#secrets
   */
  readonly secrets?: string[];

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesValidateForeachContextImageRegistryImageRegistryCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesValidateForeachContextImageRegistryImageRegistryCredentials(obj: ClusterPolicyV2Beta1SpecRulesValidateForeachContextImageRegistryImageRegistryCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowInsecureRegistry': obj.allowInsecureRegistry,
    'providers': obj.providers?.map(y => y),
    'secrets': obj.secrets?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Operator is the conditional operation to perform. Valid operators are:
 * Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
 * GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
 * DurationLessThanOrEquals, DurationLessThan
 *
 * @schema ClusterPolicyV2Beta1SpecRulesValidateForeachPreconditionsAllOperator
 */
export enum ClusterPolicyV2Beta1SpecRulesValidateForeachPreconditionsAllOperator {
  /** Equals */
  EQUALS = "Equals",
  /** NotEquals */
  NOT_EQUALS = "NotEquals",
  /** In */
  IN = "In",
  /** AnyIn */
  ANY_IN = "AnyIn",
  /** AllIn */
  ALL_IN = "AllIn",
  /** NotIn */
  NOT_IN = "NotIn",
  /** AnyNotIn */
  ANY_NOT_IN = "AnyNotIn",
  /** AllNotIn */
  ALL_NOT_IN = "AllNotIn",
  /** GreaterThanOrEquals */
  GREATER_THAN_OR_EQUALS = "GreaterThanOrEquals",
  /** GreaterThan */
  GREATER_THAN = "GreaterThan",
  /** LessThanOrEquals */
  LESS_THAN_OR_EQUALS = "LessThanOrEquals",
  /** LessThan */
  LESS_THAN = "LessThan",
  /** DurationGreaterThanOrEquals */
  DURATION_GREATER_THAN_OR_EQUALS = "DurationGreaterThanOrEquals",
  /** DurationGreaterThan */
  DURATION_GREATER_THAN = "DurationGreaterThan",
  /** DurationLessThanOrEquals */
  DURATION_LESS_THAN_OR_EQUALS = "DurationLessThanOrEquals",
  /** DurationLessThan */
  DURATION_LESS_THAN = "DurationLessThan",
}

/**
 * Operator is the conditional operation to perform. Valid operators are:
 * Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
 * GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
 * DurationLessThanOrEquals, DurationLessThan
 *
 * @schema ClusterPolicyV2Beta1SpecRulesValidateForeachPreconditionsAnyOperator
 */
export enum ClusterPolicyV2Beta1SpecRulesValidateForeachPreconditionsAnyOperator {
  /** Equals */
  EQUALS = "Equals",
  /** NotEquals */
  NOT_EQUALS = "NotEquals",
  /** In */
  IN = "In",
  /** AnyIn */
  ANY_IN = "AnyIn",
  /** AllIn */
  ALL_IN = "AllIn",
  /** NotIn */
  NOT_IN = "NotIn",
  /** AnyNotIn */
  ANY_NOT_IN = "AnyNotIn",
  /** AllNotIn */
  ALL_NOT_IN = "AllNotIn",
  /** GreaterThanOrEquals */
  GREATER_THAN_OR_EQUALS = "GreaterThanOrEquals",
  /** GreaterThan */
  GREATER_THAN = "GreaterThan",
  /** LessThanOrEquals */
  LESS_THAN_OR_EQUALS = "LessThanOrEquals",
  /** LessThan */
  LESS_THAN = "LessThan",
  /** DurationGreaterThanOrEquals */
  DURATION_GREATER_THAN_OR_EQUALS = "DurationGreaterThanOrEquals",
  /** DurationGreaterThan */
  DURATION_GREATER_THAN = "DurationGreaterThan",
  /** DurationLessThanOrEquals */
  DURATION_LESS_THAN_OR_EQUALS = "DurationLessThanOrEquals",
  /** DurationLessThan */
  DURATION_LESS_THAN = "DurationLessThan",
}

/**
 * Certificates specifies one or more certificates.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesCertificates
 */
export interface ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesCertificates {
  /**
   * Cert is an optional PEM-encoded public certificate.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesCertificates#cert
   */
  readonly cert?: string;

  /**
   * CertChain is an optional PEM encoded set of certificates used to verify.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesCertificates#certChain
   */
  readonly certChain?: string;

  /**
   * CTLog (certificate timestamp log) provides a configuration for validation of Signed Certificate
   * Timestamps (SCTs). If the value is unset, the default behavior by Cosign is used.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesCertificates#ctlog
   */
  readonly ctlog?: ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesCertificatesCtlog;

  /**
   * Rekor provides configuration for the Rekor transparency log service. If an empty object
   * is provided the public instance of Rekor (https://rekor.sigstore.dev) is used.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesCertificates#rekor
   */
  readonly rekor?: ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesCertificatesRekor;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesCertificates' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesCertificates(obj: ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesCertificates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cert': obj.cert,
    'certChain': obj.certChain,
    'ctlog': toJson_ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesCertificatesCtlog(obj.ctlog),
    'rekor': toJson_ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesCertificatesRekor(obj.rekor),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Keyless is a set of attribute used to verify a Sigstore keyless attestor.
 * See https://github.com/sigstore/cosign/blob/main/KEYLESS.md.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesKeyless
 */
export interface ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesKeyless {
  /**
   * AdditionalExtensions are certificate-extensions used for keyless signing.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesKeyless#additionalExtensions
   */
  readonly additionalExtensions?: { [key: string]: string };

  /**
   * CTLog (certificate timestamp log) provides a configuration for validation of Signed Certificate
   * Timestamps (SCTs). If the value is unset, the default behavior by Cosign is used.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesKeyless#ctlog
   */
  readonly ctlog?: ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesKeylessCtlog;

  /**
   * Issuer is the certificate issuer used for keyless signing.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesKeyless#issuer
   */
  readonly issuer?: string;

  /**
   * IssuerRegExp is the regular expression to match certificate issuer used for keyless signing.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesKeyless#issuerRegExp
   */
  readonly issuerRegExp?: string;

  /**
   * Rekor provides configuration for the Rekor transparency log service. If an empty object
   * is provided the public instance of Rekor (https://rekor.sigstore.dev) is used.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesKeyless#rekor
   */
  readonly rekor?: ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesKeylessRekor;

  /**
   * Roots is an optional set of PEM encoded trusted root certificates.
   * If not provided, the system roots are used.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesKeyless#roots
   */
  readonly roots?: string;

  /**
   * Subject is the verified identity used for keyless signing, for example the email address.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesKeyless#subject
   */
  readonly subject?: string;

  /**
   * SubjectRegExp is the regular expression to match identity used for keyless signing, for example the email address.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesKeyless#subjectRegExp
   */
  readonly subjectRegExp?: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesKeyless' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesKeyless(obj: ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesKeyless | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalExtensions': ((obj.additionalExtensions) === undefined) ? undefined : (Object.entries(obj.additionalExtensions).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'ctlog': toJson_ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesKeylessCtlog(obj.ctlog),
    'issuer': obj.issuer,
    'issuerRegExp': obj.issuerRegExp,
    'rekor': toJson_ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesKeylessRekor(obj.rekor),
    'roots': obj.roots,
    'subject': obj.subject,
    'subjectRegExp': obj.subjectRegExp,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Keys specifies one or more public keys.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesKeys
 */
export interface ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesKeys {
  /**
   * CTLog (certificate timestamp log) provides a configuration for validation of Signed Certificate
   * Timestamps (SCTs). If the value is unset, the default behavior by Cosign is used.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesKeys#ctlog
   */
  readonly ctlog?: ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesKeysCtlog;

  /**
   * KMS provides the URI to the public key stored in a Key Management System. See:
   * https://github.com/sigstore/cosign/blob/main/KMS.md
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesKeys#kms
   */
  readonly kms?: string;

  /**
   * Keys is a set of X.509 public keys used to verify image signatures. The keys can be directly
   * specified or can be a variable reference to a key specified in a ConfigMap (see
   * https://kyverno.io/docs/writing-policies/variables/), or reference a standard Kubernetes Secret
   * elsewhere in the cluster by specifying it in the format "k8s://<namespace>/<secret_name>".
   * The named Secret must specify a key `cosign.pub` containing the public key used for
   * verification, (see https://github.com/sigstore/cosign/blob/main/KMS.md#kubernetes-secret).
   * When multiple keys are specified each key is processed as a separate staticKey entry
   * (.attestors[*].entries.keys) within the set of attestors and the count is applied across the keys.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesKeys#publicKeys
   */
  readonly publicKeys?: string;

  /**
   * Rekor provides configuration for the Rekor transparency log service. If an empty object
   * is provided the public instance of Rekor (https://rekor.sigstore.dev) is used.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesKeys#rekor
   */
  readonly rekor?: ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesKeysRekor;

  /**
   * Reference to a Secret resource that contains a public key
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesKeys#secret
   */
  readonly secret?: ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesKeysSecret;

  /**
   * Deprecated. Use attestor.signatureAlgorithm instead.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesKeys#signatureAlgorithm
   */
  readonly signatureAlgorithm?: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesKeys' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesKeys(obj: ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesKeys | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ctlog': toJson_ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesKeysCtlog(obj.ctlog),
    'kms': obj.kms,
    'publicKeys': obj.publicKeys,
    'rekor': toJson_ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesKeysRekor(obj.rekor),
    'secret': toJson_ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesKeysSecret(obj.secret),
    'signatureAlgorithm': obj.signatureAlgorithm,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Certificates specifies one or more certificates.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesCertificates
 */
export interface ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesCertificates {
  /**
   * Cert is an optional PEM-encoded public certificate.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesCertificates#cert
   */
  readonly cert?: string;

  /**
   * CertChain is an optional PEM encoded set of certificates used to verify.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesCertificates#certChain
   */
  readonly certChain?: string;

  /**
   * CTLog (certificate timestamp log) provides a configuration for validation of Signed Certificate
   * Timestamps (SCTs). If the value is unset, the default behavior by Cosign is used.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesCertificates#ctlog
   */
  readonly ctlog?: ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesCertificatesCtlog;

  /**
   * Rekor provides configuration for the Rekor transparency log service. If an empty object
   * is provided the public instance of Rekor (https://rekor.sigstore.dev) is used.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesCertificates#rekor
   */
  readonly rekor?: ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesCertificatesRekor;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesCertificates' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesCertificates(obj: ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesCertificates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cert': obj.cert,
    'certChain': obj.certChain,
    'ctlog': toJson_ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesCertificatesCtlog(obj.ctlog),
    'rekor': toJson_ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesCertificatesRekor(obj.rekor),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Keyless is a set of attribute used to verify a Sigstore keyless attestor.
 * See https://github.com/sigstore/cosign/blob/main/KEYLESS.md.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesKeyless
 */
export interface ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesKeyless {
  /**
   * AdditionalExtensions are certificate-extensions used for keyless signing.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesKeyless#additionalExtensions
   */
  readonly additionalExtensions?: { [key: string]: string };

  /**
   * CTLog (certificate timestamp log) provides a configuration for validation of Signed Certificate
   * Timestamps (SCTs). If the value is unset, the default behavior by Cosign is used.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesKeyless#ctlog
   */
  readonly ctlog?: ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesKeylessCtlog;

  /**
   * Issuer is the certificate issuer used for keyless signing.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesKeyless#issuer
   */
  readonly issuer?: string;

  /**
   * IssuerRegExp is the regular expression to match certificate issuer used for keyless signing.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesKeyless#issuerRegExp
   */
  readonly issuerRegExp?: string;

  /**
   * Rekor provides configuration for the Rekor transparency log service. If an empty object
   * is provided the public instance of Rekor (https://rekor.sigstore.dev) is used.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesKeyless#rekor
   */
  readonly rekor?: ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesKeylessRekor;

  /**
   * Roots is an optional set of PEM encoded trusted root certificates.
   * If not provided, the system roots are used.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesKeyless#roots
   */
  readonly roots?: string;

  /**
   * Subject is the verified identity used for keyless signing, for example the email address.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesKeyless#subject
   */
  readonly subject?: string;

  /**
   * SubjectRegExp is the regular expression to match identity used for keyless signing, for example the email address.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesKeyless#subjectRegExp
   */
  readonly subjectRegExp?: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesKeyless' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesKeyless(obj: ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesKeyless | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalExtensions': ((obj.additionalExtensions) === undefined) ? undefined : (Object.entries(obj.additionalExtensions).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'ctlog': toJson_ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesKeylessCtlog(obj.ctlog),
    'issuer': obj.issuer,
    'issuerRegExp': obj.issuerRegExp,
    'rekor': toJson_ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesKeylessRekor(obj.rekor),
    'roots': obj.roots,
    'subject': obj.subject,
    'subjectRegExp': obj.subjectRegExp,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Keys specifies one or more public keys.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesKeys
 */
export interface ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesKeys {
  /**
   * CTLog (certificate timestamp log) provides a configuration for validation of Signed Certificate
   * Timestamps (SCTs). If the value is unset, the default behavior by Cosign is used.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesKeys#ctlog
   */
  readonly ctlog?: ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesKeysCtlog;

  /**
   * KMS provides the URI to the public key stored in a Key Management System. See:
   * https://github.com/sigstore/cosign/blob/main/KMS.md
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesKeys#kms
   */
  readonly kms?: string;

  /**
   * Keys is a set of X.509 public keys used to verify image signatures. The keys can be directly
   * specified or can be a variable reference to a key specified in a ConfigMap (see
   * https://kyverno.io/docs/writing-policies/variables/), or reference a standard Kubernetes Secret
   * elsewhere in the cluster by specifying it in the format "k8s://<namespace>/<secret_name>".
   * The named Secret must specify a key `cosign.pub` containing the public key used for
   * verification, (see https://github.com/sigstore/cosign/blob/main/KMS.md#kubernetes-secret).
   * When multiple keys are specified each key is processed as a separate staticKey entry
   * (.attestors[*].entries.keys) within the set of attestors and the count is applied across the keys.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesKeys#publicKeys
   */
  readonly publicKeys?: string;

  /**
   * Rekor provides configuration for the Rekor transparency log service. If an empty object
   * is provided the public instance of Rekor (https://rekor.sigstore.dev) is used.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesKeys#rekor
   */
  readonly rekor?: ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesKeysRekor;

  /**
   * Reference to a Secret resource that contains a public key
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesKeys#secret
   */
  readonly secret?: ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesKeysSecret;

  /**
   * Deprecated. Use attestor.signatureAlgorithm instead.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesKeys#signatureAlgorithm
   */
  readonly signatureAlgorithm?: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesKeys' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesKeys(obj: ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesKeys | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ctlog': toJson_ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesKeysCtlog(obj.ctlog),
    'kms': obj.kms,
    'publicKeys': obj.publicKeys,
    'rekor': toJson_ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesKeysRekor(obj.rekor),
    'secret': toJson_ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesKeysSecret(obj.secret),
    'signatureAlgorithm': obj.signatureAlgorithm,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Operator is the conditional operation to perform. Valid operators are:
 * Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
 * GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
 * DurationLessThanOrEquals, DurationLessThan
 *
 * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsConditionsAllOperator
 */
export enum ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsConditionsAllOperator {
  /** Equals */
  EQUALS = "Equals",
  /** NotEquals */
  NOT_EQUALS = "NotEquals",
  /** In */
  IN = "In",
  /** AnyIn */
  ANY_IN = "AnyIn",
  /** AllIn */
  ALL_IN = "AllIn",
  /** NotIn */
  NOT_IN = "NotIn",
  /** AnyNotIn */
  ANY_NOT_IN = "AnyNotIn",
  /** AllNotIn */
  ALL_NOT_IN = "AllNotIn",
  /** GreaterThanOrEquals */
  GREATER_THAN_OR_EQUALS = "GreaterThanOrEquals",
  /** GreaterThan */
  GREATER_THAN = "GreaterThan",
  /** LessThanOrEquals */
  LESS_THAN_OR_EQUALS = "LessThanOrEquals",
  /** LessThan */
  LESS_THAN = "LessThan",
  /** DurationGreaterThanOrEquals */
  DURATION_GREATER_THAN_OR_EQUALS = "DurationGreaterThanOrEquals",
  /** DurationGreaterThan */
  DURATION_GREATER_THAN = "DurationGreaterThan",
  /** DurationLessThanOrEquals */
  DURATION_LESS_THAN_OR_EQUALS = "DurationLessThanOrEquals",
  /** DurationLessThan */
  DURATION_LESS_THAN = "DurationLessThan",
}

/**
 * Operator is the conditional operation to perform. Valid operators are:
 * Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
 * GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
 * DurationLessThanOrEquals, DurationLessThan
 *
 * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsConditionsAnyOperator
 */
export enum ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsConditionsAnyOperator {
  /** Equals */
  EQUALS = "Equals",
  /** NotEquals */
  NOT_EQUALS = "NotEquals",
  /** In */
  IN = "In",
  /** AnyIn */
  ANY_IN = "AnyIn",
  /** AllIn */
  ALL_IN = "AllIn",
  /** NotIn */
  NOT_IN = "NotIn",
  /** AnyNotIn */
  ANY_NOT_IN = "AnyNotIn",
  /** AllNotIn */
  ALL_NOT_IN = "AllNotIn",
  /** GreaterThanOrEquals */
  GREATER_THAN_OR_EQUALS = "GreaterThanOrEquals",
  /** GreaterThan */
  GREATER_THAN = "GreaterThan",
  /** LessThanOrEquals */
  LESS_THAN_OR_EQUALS = "LessThanOrEquals",
  /** LessThan */
  LESS_THAN = "LessThan",
  /** DurationGreaterThanOrEquals */
  DURATION_GREATER_THAN_OR_EQUALS = "DurationGreaterThanOrEquals",
  /** DurationGreaterThan */
  DURATION_GREATER_THAN = "DurationGreaterThan",
  /** DurationLessThanOrEquals */
  DURATION_LESS_THAN_OR_EQUALS = "DurationLessThanOrEquals",
  /** DurationLessThan */
  DURATION_LESS_THAN = "DurationLessThan",
}

/**
 * CTLog (certificate timestamp log) provides a configuration for validation of Signed Certificate
 * Timestamps (SCTs). If the value is unset, the default behavior by Cosign is used.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesCertificatesCtlog
 */
export interface ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesCertificatesCtlog {
  /**
   * IgnoreSCT defines whether to use the Signed Certificate Timestamp (SCT) log to check for a certificate
   * timestamp. Default is false. Set to true if this was opted out during signing.
   *
   * @default false. Set to true if this was opted out during signing.
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesCertificatesCtlog#ignoreSCT
   */
  readonly ignoreSct?: boolean;

  /**
   * PubKey, if set, is used to validate SCTs against a custom source.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesCertificatesCtlog#pubkey
   */
  readonly pubkey?: string;

  /**
   * TSACertChain, if set, is the PEM-encoded certificate chain file for the RFC3161 timestamp authority. Must
   * contain the root CA certificate. Optionally may contain intermediate CA certificates, and
   * may contain the leaf TSA certificate if not present in the timestamurce.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesCertificatesCtlog#tsaCertChain
   */
  readonly tsaCertChain?: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesCertificatesCtlog' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesCertificatesCtlog(obj: ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesCertificatesCtlog | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ignoreSCT': obj.ignoreSct,
    'pubkey': obj.pubkey,
    'tsaCertChain': obj.tsaCertChain,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Rekor provides configuration for the Rekor transparency log service. If an empty object
 * is provided the public instance of Rekor (https://rekor.sigstore.dev) is used.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesCertificatesRekor
 */
export interface ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesCertificatesRekor {
  /**
   * IgnoreTlog skips transparency log verification.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesCertificatesRekor#ignoreTlog
   */
  readonly ignoreTlog?: boolean;

  /**
   * RekorPubKey is an optional PEM-encoded public key to use for a custom Rekor.
   * If set, this will be used to validate transparency log signatures from a custom Rekor.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesCertificatesRekor#pubkey
   */
  readonly pubkey?: string;

  /**
   * URL is the address of the transparency log. Defaults to the public Rekor log instance https://rekor.sigstore.dev.
   *
   * @default the public Rekor log instance https://rekor.sigstore.dev.
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesCertificatesRekor#url
   */
  readonly url?: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesCertificatesRekor' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesCertificatesRekor(obj: ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesCertificatesRekor | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ignoreTlog': obj.ignoreTlog,
    'pubkey': obj.pubkey,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CTLog (certificate timestamp log) provides a configuration for validation of Signed Certificate
 * Timestamps (SCTs). If the value is unset, the default behavior by Cosign is used.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesKeylessCtlog
 */
export interface ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesKeylessCtlog {
  /**
   * IgnoreSCT defines whether to use the Signed Certificate Timestamp (SCT) log to check for a certificate
   * timestamp. Default is false. Set to true if this was opted out during signing.
   *
   * @default false. Set to true if this was opted out during signing.
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesKeylessCtlog#ignoreSCT
   */
  readonly ignoreSct?: boolean;

  /**
   * PubKey, if set, is used to validate SCTs against a custom source.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesKeylessCtlog#pubkey
   */
  readonly pubkey?: string;

  /**
   * TSACertChain, if set, is the PEM-encoded certificate chain file for the RFC3161 timestamp authority. Must
   * contain the root CA certificate. Optionally may contain intermediate CA certificates, and
   * may contain the leaf TSA certificate if not present in the timestamurce.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesKeylessCtlog#tsaCertChain
   */
  readonly tsaCertChain?: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesKeylessCtlog' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesKeylessCtlog(obj: ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesKeylessCtlog | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ignoreSCT': obj.ignoreSct,
    'pubkey': obj.pubkey,
    'tsaCertChain': obj.tsaCertChain,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Rekor provides configuration for the Rekor transparency log service. If an empty object
 * is provided the public instance of Rekor (https://rekor.sigstore.dev) is used.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesKeylessRekor
 */
export interface ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesKeylessRekor {
  /**
   * IgnoreTlog skips transparency log verification.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesKeylessRekor#ignoreTlog
   */
  readonly ignoreTlog?: boolean;

  /**
   * RekorPubKey is an optional PEM-encoded public key to use for a custom Rekor.
   * If set, this will be used to validate transparency log signatures from a custom Rekor.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesKeylessRekor#pubkey
   */
  readonly pubkey?: string;

  /**
   * URL is the address of the transparency log. Defaults to the public Rekor log instance https://rekor.sigstore.dev.
   *
   * @default the public Rekor log instance https://rekor.sigstore.dev.
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesKeylessRekor#url
   */
  readonly url?: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesKeylessRekor' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesKeylessRekor(obj: ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesKeylessRekor | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ignoreTlog': obj.ignoreTlog,
    'pubkey': obj.pubkey,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CTLog (certificate timestamp log) provides a configuration for validation of Signed Certificate
 * Timestamps (SCTs). If the value is unset, the default behavior by Cosign is used.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesKeysCtlog
 */
export interface ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesKeysCtlog {
  /**
   * IgnoreSCT defines whether to use the Signed Certificate Timestamp (SCT) log to check for a certificate
   * timestamp. Default is false. Set to true if this was opted out during signing.
   *
   * @default false. Set to true if this was opted out during signing.
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesKeysCtlog#ignoreSCT
   */
  readonly ignoreSct?: boolean;

  /**
   * PubKey, if set, is used to validate SCTs against a custom source.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesKeysCtlog#pubkey
   */
  readonly pubkey?: string;

  /**
   * TSACertChain, if set, is the PEM-encoded certificate chain file for the RFC3161 timestamp authority. Must
   * contain the root CA certificate. Optionally may contain intermediate CA certificates, and
   * may contain the leaf TSA certificate if not present in the timestamurce.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesKeysCtlog#tsaCertChain
   */
  readonly tsaCertChain?: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesKeysCtlog' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesKeysCtlog(obj: ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesKeysCtlog | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ignoreSCT': obj.ignoreSct,
    'pubkey': obj.pubkey,
    'tsaCertChain': obj.tsaCertChain,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Rekor provides configuration for the Rekor transparency log service. If an empty object
 * is provided the public instance of Rekor (https://rekor.sigstore.dev) is used.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesKeysRekor
 */
export interface ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesKeysRekor {
  /**
   * IgnoreTlog skips transparency log verification.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesKeysRekor#ignoreTlog
   */
  readonly ignoreTlog?: boolean;

  /**
   * RekorPubKey is an optional PEM-encoded public key to use for a custom Rekor.
   * If set, this will be used to validate transparency log signatures from a custom Rekor.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesKeysRekor#pubkey
   */
  readonly pubkey?: string;

  /**
   * URL is the address of the transparency log. Defaults to the public Rekor log instance https://rekor.sigstore.dev.
   *
   * @default the public Rekor log instance https://rekor.sigstore.dev.
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesKeysRekor#url
   */
  readonly url?: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesKeysRekor' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesKeysRekor(obj: ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesKeysRekor | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ignoreTlog': obj.ignoreTlog,
    'pubkey': obj.pubkey,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Secret resource that contains a public key
 *
 * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesKeysSecret
 */
export interface ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesKeysSecret {
  /**
   * Name of the secret. The provided secret must contain a key named cosign.pub.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesKeysSecret#name
   */
  readonly name: string;

  /**
   * Namespace name where the Secret exists.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesKeysSecret#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesKeysSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesKeysSecret(obj: ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestorsEntriesKeysSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeachContextApiCallServiceHeaders
 */
export interface ClusterPolicyV2Beta1SpecRulesGenerateForeachContextApiCallServiceHeaders {
  /**
   * Key is the header key
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeachContextApiCallServiceHeaders#key
   */
  readonly key: string;

  /**
   * Value is the header value
   *
   * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeachContextApiCallServiceHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesGenerateForeachContextApiCallServiceHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesGenerateForeachContextApiCallServiceHeaders(obj: ClusterPolicyV2Beta1SpecRulesGenerateForeachContextApiCallServiceHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ImageRegistryCredentialsProvidersType provides the list of credential providers required.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesGenerateForeachContextImageRegistryImageRegistryCredentialsProviders
 */
export enum ClusterPolicyV2Beta1SpecRulesGenerateForeachContextImageRegistryImageRegistryCredentialsProviders {
  /** default */
  DEFAULT = "default",
  /** amazon */
  AMAZON = "amazon",
  /** azure */
  AZURE = "azure",
  /** google */
  GOOGLE = "google",
  /** github */
  GITHUB = "github",
}

/**
 * @schema ClusterPolicyV2Beta1SpecRulesMutateForeachContextApiCallServiceHeaders
 */
export interface ClusterPolicyV2Beta1SpecRulesMutateForeachContextApiCallServiceHeaders {
  /**
   * Key is the header key
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateForeachContextApiCallServiceHeaders#key
   */
  readonly key: string;

  /**
   * Value is the header value
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateForeachContextApiCallServiceHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesMutateForeachContextApiCallServiceHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesMutateForeachContextApiCallServiceHeaders(obj: ClusterPolicyV2Beta1SpecRulesMutateForeachContextApiCallServiceHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ImageRegistryCredentialsProvidersType provides the list of credential providers required.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesMutateForeachContextImageRegistryImageRegistryCredentialsProviders
 */
export enum ClusterPolicyV2Beta1SpecRulesMutateForeachContextImageRegistryImageRegistryCredentialsProviders {
  /** default */
  DEFAULT = "default",
  /** amazon */
  AMAZON = "amazon",
  /** azure */
  AZURE = "azure",
  /** google */
  GOOGLE = "google",
  /** github */
  GITHUB = "github",
}

/**
 * @schema ClusterPolicyV2Beta1SpecRulesMutateTargetsContextApiCallServiceHeaders
 */
export interface ClusterPolicyV2Beta1SpecRulesMutateTargetsContextApiCallServiceHeaders {
  /**
   * Key is the header key
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateTargetsContextApiCallServiceHeaders#key
   */
  readonly key: string;

  /**
   * Value is the header value
   *
   * @schema ClusterPolicyV2Beta1SpecRulesMutateTargetsContextApiCallServiceHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesMutateTargetsContextApiCallServiceHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesMutateTargetsContextApiCallServiceHeaders(obj: ClusterPolicyV2Beta1SpecRulesMutateTargetsContextApiCallServiceHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ImageRegistryCredentialsProvidersType provides the list of credential providers required.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesMutateTargetsContextImageRegistryImageRegistryCredentialsProviders
 */
export enum ClusterPolicyV2Beta1SpecRulesMutateTargetsContextImageRegistryImageRegistryCredentialsProviders {
  /** default */
  DEFAULT = "default",
  /** amazon */
  AMAZON = "amazon",
  /** azure */
  AZURE = "azure",
  /** google */
  GOOGLE = "google",
  /** github */
  GITHUB = "github",
}

/**
 * @schema ClusterPolicyV2Beta1SpecRulesValidateForeachContextApiCallServiceHeaders
 */
export interface ClusterPolicyV2Beta1SpecRulesValidateForeachContextApiCallServiceHeaders {
  /**
   * Key is the header key
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateForeachContextApiCallServiceHeaders#key
   */
  readonly key: string;

  /**
   * Value is the header value
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateForeachContextApiCallServiceHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesValidateForeachContextApiCallServiceHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesValidateForeachContextApiCallServiceHeaders(obj: ClusterPolicyV2Beta1SpecRulesValidateForeachContextApiCallServiceHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ImageRegistryCredentialsProvidersType provides the list of credential providers required.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesValidateForeachContextImageRegistryImageRegistryCredentialsProviders
 */
export enum ClusterPolicyV2Beta1SpecRulesValidateForeachContextImageRegistryImageRegistryCredentialsProviders {
  /** default */
  DEFAULT = "default",
  /** amazon */
  AMAZON = "amazon",
  /** azure */
  AZURE = "azure",
  /** google */
  GOOGLE = "google",
  /** github */
  GITHUB = "github",
}

/**
 * CTLog (certificate timestamp log) provides a configuration for validation of Signed Certificate
 * Timestamps (SCTs). If the value is unset, the default behavior by Cosign is used.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesCertificatesCtlog
 */
export interface ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesCertificatesCtlog {
  /**
   * IgnoreSCT defines whether to use the Signed Certificate Timestamp (SCT) log to check for a certificate
   * timestamp. Default is false. Set to true if this was opted out during signing.
   *
   * @default false. Set to true if this was opted out during signing.
   * @schema ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesCertificatesCtlog#ignoreSCT
   */
  readonly ignoreSct?: boolean;

  /**
   * PubKey, if set, is used to validate SCTs against a custom source.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesCertificatesCtlog#pubkey
   */
  readonly pubkey?: string;

  /**
   * TSACertChain, if set, is the PEM-encoded certificate chain file for the RFC3161 timestamp authority. Must
   * contain the root CA certificate. Optionally may contain intermediate CA certificates, and
   * may contain the leaf TSA certificate if not present in the timestamurce.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesCertificatesCtlog#tsaCertChain
   */
  readonly tsaCertChain?: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesCertificatesCtlog' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesCertificatesCtlog(obj: ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesCertificatesCtlog | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ignoreSCT': obj.ignoreSct,
    'pubkey': obj.pubkey,
    'tsaCertChain': obj.tsaCertChain,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Rekor provides configuration for the Rekor transparency log service. If an empty object
 * is provided the public instance of Rekor (https://rekor.sigstore.dev) is used.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesCertificatesRekor
 */
export interface ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesCertificatesRekor {
  /**
   * IgnoreTlog skips transparency log verification.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesCertificatesRekor#ignoreTlog
   */
  readonly ignoreTlog?: boolean;

  /**
   * RekorPubKey is an optional PEM-encoded public key to use for a custom Rekor.
   * If set, this will be used to validate transparency log signatures from a custom Rekor.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesCertificatesRekor#pubkey
   */
  readonly pubkey?: string;

  /**
   * URL is the address of the transparency log. Defaults to the public Rekor log instance https://rekor.sigstore.dev.
   *
   * @default the public Rekor log instance https://rekor.sigstore.dev.
   * @schema ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesCertificatesRekor#url
   */
  readonly url?: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesCertificatesRekor' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesCertificatesRekor(obj: ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesCertificatesRekor | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ignoreTlog': obj.ignoreTlog,
    'pubkey': obj.pubkey,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CTLog (certificate timestamp log) provides a configuration for validation of Signed Certificate
 * Timestamps (SCTs). If the value is unset, the default behavior by Cosign is used.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesKeylessCtlog
 */
export interface ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesKeylessCtlog {
  /**
   * IgnoreSCT defines whether to use the Signed Certificate Timestamp (SCT) log to check for a certificate
   * timestamp. Default is false. Set to true if this was opted out during signing.
   *
   * @default false. Set to true if this was opted out during signing.
   * @schema ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesKeylessCtlog#ignoreSCT
   */
  readonly ignoreSct?: boolean;

  /**
   * PubKey, if set, is used to validate SCTs against a custom source.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesKeylessCtlog#pubkey
   */
  readonly pubkey?: string;

  /**
   * TSACertChain, if set, is the PEM-encoded certificate chain file for the RFC3161 timestamp authority. Must
   * contain the root CA certificate. Optionally may contain intermediate CA certificates, and
   * may contain the leaf TSA certificate if not present in the timestamurce.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesKeylessCtlog#tsaCertChain
   */
  readonly tsaCertChain?: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesKeylessCtlog' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesKeylessCtlog(obj: ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesKeylessCtlog | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ignoreSCT': obj.ignoreSct,
    'pubkey': obj.pubkey,
    'tsaCertChain': obj.tsaCertChain,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Rekor provides configuration for the Rekor transparency log service. If an empty object
 * is provided the public instance of Rekor (https://rekor.sigstore.dev) is used.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesKeylessRekor
 */
export interface ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesKeylessRekor {
  /**
   * IgnoreTlog skips transparency log verification.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesKeylessRekor#ignoreTlog
   */
  readonly ignoreTlog?: boolean;

  /**
   * RekorPubKey is an optional PEM-encoded public key to use for a custom Rekor.
   * If set, this will be used to validate transparency log signatures from a custom Rekor.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesKeylessRekor#pubkey
   */
  readonly pubkey?: string;

  /**
   * URL is the address of the transparency log. Defaults to the public Rekor log instance https://rekor.sigstore.dev.
   *
   * @default the public Rekor log instance https://rekor.sigstore.dev.
   * @schema ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesKeylessRekor#url
   */
  readonly url?: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesKeylessRekor' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesKeylessRekor(obj: ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesKeylessRekor | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ignoreTlog': obj.ignoreTlog,
    'pubkey': obj.pubkey,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CTLog (certificate timestamp log) provides a configuration for validation of Signed Certificate
 * Timestamps (SCTs). If the value is unset, the default behavior by Cosign is used.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesKeysCtlog
 */
export interface ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesKeysCtlog {
  /**
   * IgnoreSCT defines whether to use the Signed Certificate Timestamp (SCT) log to check for a certificate
   * timestamp. Default is false. Set to true if this was opted out during signing.
   *
   * @default false. Set to true if this was opted out during signing.
   * @schema ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesKeysCtlog#ignoreSCT
   */
  readonly ignoreSct?: boolean;

  /**
   * PubKey, if set, is used to validate SCTs against a custom source.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesKeysCtlog#pubkey
   */
  readonly pubkey?: string;

  /**
   * TSACertChain, if set, is the PEM-encoded certificate chain file for the RFC3161 timestamp authority. Must
   * contain the root CA certificate. Optionally may contain intermediate CA certificates, and
   * may contain the leaf TSA certificate if not present in the timestamurce.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesKeysCtlog#tsaCertChain
   */
  readonly tsaCertChain?: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesKeysCtlog' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesKeysCtlog(obj: ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesKeysCtlog | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ignoreSCT': obj.ignoreSct,
    'pubkey': obj.pubkey,
    'tsaCertChain': obj.tsaCertChain,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Rekor provides configuration for the Rekor transparency log service. If an empty object
 * is provided the public instance of Rekor (https://rekor.sigstore.dev) is used.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesKeysRekor
 */
export interface ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesKeysRekor {
  /**
   * IgnoreTlog skips transparency log verification.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesKeysRekor#ignoreTlog
   */
  readonly ignoreTlog?: boolean;

  /**
   * RekorPubKey is an optional PEM-encoded public key to use for a custom Rekor.
   * If set, this will be used to validate transparency log signatures from a custom Rekor.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesKeysRekor#pubkey
   */
  readonly pubkey?: string;

  /**
   * URL is the address of the transparency log. Defaults to the public Rekor log instance https://rekor.sigstore.dev.
   *
   * @default the public Rekor log instance https://rekor.sigstore.dev.
   * @schema ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesKeysRekor#url
   */
  readonly url?: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesKeysRekor' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesKeysRekor(obj: ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesKeysRekor | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ignoreTlog': obj.ignoreTlog,
    'pubkey': obj.pubkey,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Secret resource that contains a public key
 *
 * @schema ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesKeysSecret
 */
export interface ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesKeysSecret {
  /**
   * Name of the secret. The provided secret must contain a key named cosign.pub.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesKeysSecret#name
   */
  readonly name: string;

  /**
   * Namespace name where the Secret exists.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesKeysSecret#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesKeysSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesKeysSecret(obj: ClusterPolicyV2Beta1SpecRulesValidateManifestsAttestorsEntriesKeysSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CTLog (certificate timestamp log) provides a configuration for validation of Signed Certificate
 * Timestamps (SCTs). If the value is unset, the default behavior by Cosign is used.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesCertificatesCtlog
 */
export interface ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesCertificatesCtlog {
  /**
   * IgnoreSCT defines whether to use the Signed Certificate Timestamp (SCT) log to check for a certificate
   * timestamp. Default is false. Set to true if this was opted out during signing.
   *
   * @default false. Set to true if this was opted out during signing.
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesCertificatesCtlog#ignoreSCT
   */
  readonly ignoreSct?: boolean;

  /**
   * PubKey, if set, is used to validate SCTs against a custom source.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesCertificatesCtlog#pubkey
   */
  readonly pubkey?: string;

  /**
   * TSACertChain, if set, is the PEM-encoded certificate chain file for the RFC3161 timestamp authority. Must
   * contain the root CA certificate. Optionally may contain intermediate CA certificates, and
   * may contain the leaf TSA certificate if not present in the timestamurce.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesCertificatesCtlog#tsaCertChain
   */
  readonly tsaCertChain?: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesCertificatesCtlog' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesCertificatesCtlog(obj: ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesCertificatesCtlog | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ignoreSCT': obj.ignoreSct,
    'pubkey': obj.pubkey,
    'tsaCertChain': obj.tsaCertChain,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Rekor provides configuration for the Rekor transparency log service. If an empty object
 * is provided the public instance of Rekor (https://rekor.sigstore.dev) is used.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesCertificatesRekor
 */
export interface ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesCertificatesRekor {
  /**
   * IgnoreTlog skips transparency log verification.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesCertificatesRekor#ignoreTlog
   */
  readonly ignoreTlog?: boolean;

  /**
   * RekorPubKey is an optional PEM-encoded public key to use for a custom Rekor.
   * If set, this will be used to validate transparency log signatures from a custom Rekor.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesCertificatesRekor#pubkey
   */
  readonly pubkey?: string;

  /**
   * URL is the address of the transparency log. Defaults to the public Rekor log instance https://rekor.sigstore.dev.
   *
   * @default the public Rekor log instance https://rekor.sigstore.dev.
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesCertificatesRekor#url
   */
  readonly url?: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesCertificatesRekor' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesCertificatesRekor(obj: ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesCertificatesRekor | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ignoreTlog': obj.ignoreTlog,
    'pubkey': obj.pubkey,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CTLog (certificate timestamp log) provides a configuration for validation of Signed Certificate
 * Timestamps (SCTs). If the value is unset, the default behavior by Cosign is used.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesKeylessCtlog
 */
export interface ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesKeylessCtlog {
  /**
   * IgnoreSCT defines whether to use the Signed Certificate Timestamp (SCT) log to check for a certificate
   * timestamp. Default is false. Set to true if this was opted out during signing.
   *
   * @default false. Set to true if this was opted out during signing.
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesKeylessCtlog#ignoreSCT
   */
  readonly ignoreSct?: boolean;

  /**
   * PubKey, if set, is used to validate SCTs against a custom source.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesKeylessCtlog#pubkey
   */
  readonly pubkey?: string;

  /**
   * TSACertChain, if set, is the PEM-encoded certificate chain file for the RFC3161 timestamp authority. Must
   * contain the root CA certificate. Optionally may contain intermediate CA certificates, and
   * may contain the leaf TSA certificate if not present in the timestamurce.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesKeylessCtlog#tsaCertChain
   */
  readonly tsaCertChain?: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesKeylessCtlog' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesKeylessCtlog(obj: ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesKeylessCtlog | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ignoreSCT': obj.ignoreSct,
    'pubkey': obj.pubkey,
    'tsaCertChain': obj.tsaCertChain,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Rekor provides configuration for the Rekor transparency log service. If an empty object
 * is provided the public instance of Rekor (https://rekor.sigstore.dev) is used.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesKeylessRekor
 */
export interface ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesKeylessRekor {
  /**
   * IgnoreTlog skips transparency log verification.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesKeylessRekor#ignoreTlog
   */
  readonly ignoreTlog?: boolean;

  /**
   * RekorPubKey is an optional PEM-encoded public key to use for a custom Rekor.
   * If set, this will be used to validate transparency log signatures from a custom Rekor.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesKeylessRekor#pubkey
   */
  readonly pubkey?: string;

  /**
   * URL is the address of the transparency log. Defaults to the public Rekor log instance https://rekor.sigstore.dev.
   *
   * @default the public Rekor log instance https://rekor.sigstore.dev.
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesKeylessRekor#url
   */
  readonly url?: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesKeylessRekor' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesKeylessRekor(obj: ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesKeylessRekor | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ignoreTlog': obj.ignoreTlog,
    'pubkey': obj.pubkey,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CTLog (certificate timestamp log) provides a configuration for validation of Signed Certificate
 * Timestamps (SCTs). If the value is unset, the default behavior by Cosign is used.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesKeysCtlog
 */
export interface ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesKeysCtlog {
  /**
   * IgnoreSCT defines whether to use the Signed Certificate Timestamp (SCT) log to check for a certificate
   * timestamp. Default is false. Set to true if this was opted out during signing.
   *
   * @default false. Set to true if this was opted out during signing.
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesKeysCtlog#ignoreSCT
   */
  readonly ignoreSct?: boolean;

  /**
   * PubKey, if set, is used to validate SCTs against a custom source.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesKeysCtlog#pubkey
   */
  readonly pubkey?: string;

  /**
   * TSACertChain, if set, is the PEM-encoded certificate chain file for the RFC3161 timestamp authority. Must
   * contain the root CA certificate. Optionally may contain intermediate CA certificates, and
   * may contain the leaf TSA certificate if not present in the timestamurce.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesKeysCtlog#tsaCertChain
   */
  readonly tsaCertChain?: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesKeysCtlog' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesKeysCtlog(obj: ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesKeysCtlog | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ignoreSCT': obj.ignoreSct,
    'pubkey': obj.pubkey,
    'tsaCertChain': obj.tsaCertChain,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Rekor provides configuration for the Rekor transparency log service. If an empty object
 * is provided the public instance of Rekor (https://rekor.sigstore.dev) is used.
 *
 * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesKeysRekor
 */
export interface ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesKeysRekor {
  /**
   * IgnoreTlog skips transparency log verification.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesKeysRekor#ignoreTlog
   */
  readonly ignoreTlog?: boolean;

  /**
   * RekorPubKey is an optional PEM-encoded public key to use for a custom Rekor.
   * If set, this will be used to validate transparency log signatures from a custom Rekor.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesKeysRekor#pubkey
   */
  readonly pubkey?: string;

  /**
   * URL is the address of the transparency log. Defaults to the public Rekor log instance https://rekor.sigstore.dev.
   *
   * @default the public Rekor log instance https://rekor.sigstore.dev.
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesKeysRekor#url
   */
  readonly url?: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesKeysRekor' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesKeysRekor(obj: ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesKeysRekor | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ignoreTlog': obj.ignoreTlog,
    'pubkey': obj.pubkey,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Secret resource that contains a public key
 *
 * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesKeysSecret
 */
export interface ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesKeysSecret {
  /**
   * Name of the secret. The provided secret must contain a key named cosign.pub.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesKeysSecret#name
   */
  readonly name: string;

  /**
   * Namespace name where the Secret exists.
   *
   * @schema ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesKeysSecret#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesKeysSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesKeysSecret(obj: ClusterPolicyV2Beta1SpecRulesVerifyImagesAttestationsAttestorsEntriesKeysSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

