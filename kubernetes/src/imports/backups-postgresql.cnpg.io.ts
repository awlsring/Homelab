// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Backup is the Schema for the backups API
 *
 * @schema Backup
 */
export class Backup extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Backup"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'postgresql.cnpg.io/v1',
    kind: 'Backup',
  }

  /**
   * Renders a Kubernetes manifest for "Backup".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BackupProps): any {
    return {
      ...Backup.GVK,
      ...toJson_BackupProps(props),
    };
  }

  /**
   * Defines a "Backup" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BackupProps) {
    super(scope, id, {
      ...Backup.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Backup.GVK,
      ...toJson_BackupProps(resolved),
    };
  }
}

/**
 * Backup is the Schema for the backups API
 *
 * @schema Backup
 */
export interface BackupProps {
  /**
   * @schema Backup#metadata
   */
  readonly metadata: ApiObjectMetadata;

  /**
   * Specification of the desired behavior of the backup.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
   *
   * @schema Backup#spec
   */
  readonly spec: BackupSpec;

}

/**
 * Converts an object of type 'BackupProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupProps(obj: BackupProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BackupSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specification of the desired behavior of the backup.
 * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
 *
 * @schema BackupSpec
 */
export interface BackupSpec {
  /**
   * The cluster to backup
   *
   * @schema BackupSpec#cluster
   */
  readonly cluster: BackupSpecCluster;

  /**
   * The backup method to be used, possible options are `barmanObjectStore`,
   * `volumeSnapshot` or `plugin`. Defaults to: `barmanObjectStore`.
   *
   * @default barmanObjectStore`.
   * @schema BackupSpec#method
   */
  readonly method?: BackupSpecMethod;

  /**
   * Whether the default type of backup with volume snapshots is
   * online/hot (`true`, default) or offline/cold (`false`)
   * Overrides the default setting specified in the cluster field '.spec.backup.volumeSnapshot.online'
   *
   * @schema BackupSpec#online
   */
  readonly online?: boolean;

  /**
   * Configuration parameters to control the online/hot backup with volume snapshots
   * Overrides the default settings specified in the cluster '.backup.volumeSnapshot.onlineConfiguration' stanza
   *
   * @schema BackupSpec#onlineConfiguration
   */
  readonly onlineConfiguration?: BackupSpecOnlineConfiguration;

  /**
   * Configuration parameters passed to the plugin managing this backup
   *
   * @schema BackupSpec#pluginConfiguration
   */
  readonly pluginConfiguration?: BackupSpecPluginConfiguration;

  /**
   * The policy to decide which instance should perform this backup. If empty,
   * it defaults to `cluster.spec.backup.target`.
   * Available options are empty string, `primary` and `prefer-standby`.
   * `primary` to have backups run always on primary instances,
   * `prefer-standby` to have backups run preferably on the most updated
   * standby, if available.
   *
   * @schema BackupSpec#target
   */
  readonly target?: BackupSpecTarget;

}

/**
 * Converts an object of type 'BackupSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupSpec(obj: BackupSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cluster': toJson_BackupSpecCluster(obj.cluster),
    'method': obj.method,
    'online': obj.online,
    'onlineConfiguration': toJson_BackupSpecOnlineConfiguration(obj.onlineConfiguration),
    'pluginConfiguration': toJson_BackupSpecPluginConfiguration(obj.pluginConfiguration),
    'target': obj.target,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The cluster to backup
 *
 * @schema BackupSpecCluster
 */
export interface BackupSpecCluster {
  /**
   * Name of the referent.
   *
   * @schema BackupSpecCluster#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'BackupSpecCluster' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupSpecCluster(obj: BackupSpecCluster | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The backup method to be used, possible options are `barmanObjectStore`,
 * `volumeSnapshot` or `plugin`. Defaults to: `barmanObjectStore`.
 *
 * @default barmanObjectStore`.
 * @schema BackupSpecMethod
 */
export enum BackupSpecMethod {
  /** barmanObjectStore */
  BARMAN_OBJECT_STORE = "barmanObjectStore",
  /** volumeSnapshot */
  VOLUME_SNAPSHOT = "volumeSnapshot",
  /** plugin */
  PLUGIN = "plugin",
}

/**
 * Configuration parameters to control the online/hot backup with volume snapshots
 * Overrides the default settings specified in the cluster '.backup.volumeSnapshot.onlineConfiguration' stanza
 *
 * @schema BackupSpecOnlineConfiguration
 */
export interface BackupSpecOnlineConfiguration {
  /**
   * Control whether the I/O workload for the backup initial checkpoint will
   * be limited, according to the `checkpoint_completion_target` setting on
   * the PostgreSQL server. If set to true, an immediate checkpoint will be
   * used, meaning PostgreSQL will complete the checkpoint as soon as
   * possible. `false` by default.
   *
   * @schema BackupSpecOnlineConfiguration#immediateCheckpoint
   */
  readonly immediateCheckpoint?: boolean;

  /**
   * If false, the function will return immediately after the backup is completed,
   * without waiting for WAL to be archived.
   * This behavior is only useful with backup software that independently monitors WAL archiving.
   * Otherwise, WAL required to make the backup consistent might be missing and make the backup useless.
   * By default, or when this parameter is true, pg_backup_stop will wait for WAL to be archived when archiving is
   * enabled.
   * On a standby, this means that it will wait only when archive_mode = always.
   * If write activity on the primary is low, it may be useful to run pg_switch_wal on the primary in order to trigger
   * an immediate segment switch.
   *
   * @schema BackupSpecOnlineConfiguration#waitForArchive
   */
  readonly waitForArchive?: boolean;

}

/**
 * Converts an object of type 'BackupSpecOnlineConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupSpecOnlineConfiguration(obj: BackupSpecOnlineConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'immediateCheckpoint': obj.immediateCheckpoint,
    'waitForArchive': obj.waitForArchive,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configuration parameters passed to the plugin managing this backup
 *
 * @schema BackupSpecPluginConfiguration
 */
export interface BackupSpecPluginConfiguration {
  /**
   * Name is the name of the plugin managing this backup
   *
   * @schema BackupSpecPluginConfiguration#name
   */
  readonly name: string;

  /**
   * Parameters are the configuration parameters passed to the backup
   * plugin for this backup
   *
   * @schema BackupSpecPluginConfiguration#parameters
   */
  readonly parameters?: { [key: string]: string };

}

/**
 * Converts an object of type 'BackupSpecPluginConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupSpecPluginConfiguration(obj: BackupSpecPluginConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'parameters': ((obj.parameters) === undefined) ? undefined : (Object.entries(obj.parameters).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The policy to decide which instance should perform this backup. If empty,
 * it defaults to `cluster.spec.backup.target`.
 * Available options are empty string, `primary` and `prefer-standby`.
 * `primary` to have backups run always on primary instances,
 * `prefer-standby` to have backups run preferably on the most updated
 * standby, if available.
 *
 * @schema BackupSpecTarget
 */
export enum BackupSpecTarget {
  /** primary */
  PRIMARY = "primary",
  /** prefer-standby */
  PREFER_HYPHEN_STANDBY = "prefer-standby",
}

