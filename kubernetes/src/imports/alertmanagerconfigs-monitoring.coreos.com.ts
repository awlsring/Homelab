// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * AlertmanagerConfig configures the Prometheus Alertmanager,
specifying how alerts should be grouped, inhibited and notified to external systems.
 *
 * @schema AlertmanagerConfig
 */
export class AlertmanagerConfig extends ApiObject {
  /**
   * Returns the apiVersion and kind for "AlertmanagerConfig"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'monitoring.coreos.com/v1alpha1',
    kind: 'AlertmanagerConfig',
  }

  /**
   * Renders a Kubernetes manifest for "AlertmanagerConfig".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AlertmanagerConfigProps): any {
    return {
      ...AlertmanagerConfig.GVK,
      ...toJson_AlertmanagerConfigProps(props),
    };
  }

  /**
   * Defines a "AlertmanagerConfig" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AlertmanagerConfigProps) {
    super(scope, id, {
      ...AlertmanagerConfig.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...AlertmanagerConfig.GVK,
      ...toJson_AlertmanagerConfigProps(resolved),
    };
  }
}

/**
 * AlertmanagerConfig configures the Prometheus Alertmanager,
 * specifying how alerts should be grouped, inhibited and notified to external systems.
 *
 * @schema AlertmanagerConfig
 */
export interface AlertmanagerConfigProps {
  /**
   * @schema AlertmanagerConfig#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AlertmanagerConfigSpec is a specification of the desired behavior of the Alertmanager configuration.
   * By definition, the Alertmanager configuration only applies to alerts for which
   * the `namespace` label is equal to the namespace of the AlertmanagerConfig resource.
   *
   * @schema AlertmanagerConfig#spec
   */
  readonly spec: AlertmanagerConfigSpec;

}

/**
 * Converts an object of type 'AlertmanagerConfigProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigProps(obj: AlertmanagerConfigProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AlertmanagerConfigSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AlertmanagerConfigSpec is a specification of the desired behavior of the Alertmanager configuration.
 * By definition, the Alertmanager configuration only applies to alerts for which
 * the `namespace` label is equal to the namespace of the AlertmanagerConfig resource.
 *
 * @schema AlertmanagerConfigSpec
 */
export interface AlertmanagerConfigSpec {
  /**
   * List of inhibition rules. The rules will only apply to alerts matching
   * the resource's namespace.
   *
   * @schema AlertmanagerConfigSpec#inhibitRules
   */
  readonly inhibitRules?: AlertmanagerConfigSpecInhibitRules[];

  /**
   * List of MuteTimeInterval specifying when the routes should be muted.
   *
   * @schema AlertmanagerConfigSpec#muteTimeIntervals
   */
  readonly muteTimeIntervals?: AlertmanagerConfigSpecMuteTimeIntervals[];

  /**
   * List of receivers.
   *
   * @schema AlertmanagerConfigSpec#receivers
   */
  readonly receivers?: AlertmanagerConfigSpecReceivers[];

  /**
   * The Alertmanager route definition for alerts matching the resource's
   * namespace. If present, it will be added to the generated Alertmanager
   * configuration as a first-level route.
   *
   * @schema AlertmanagerConfigSpec#route
   */
  readonly route?: AlertmanagerConfigSpecRoute;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpec(obj: AlertmanagerConfigSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'inhibitRules': obj.inhibitRules?.map(y => toJson_AlertmanagerConfigSpecInhibitRules(y)),
    'muteTimeIntervals': obj.muteTimeIntervals?.map(y => toJson_AlertmanagerConfigSpecMuteTimeIntervals(y)),
    'receivers': obj.receivers?.map(y => toJson_AlertmanagerConfigSpecReceivers(y)),
    'route': toJson_AlertmanagerConfigSpecRoute(obj.route),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * InhibitRule defines an inhibition rule that allows to mute alerts when other
 * alerts are already firing.
 * See https://prometheus.io/docs/alerting/latest/configuration/#inhibit_rule
 *
 * @schema AlertmanagerConfigSpecInhibitRules
 */
export interface AlertmanagerConfigSpecInhibitRules {
  /**
   * Labels that must have an equal value in the source and target alert for
   * the inhibition to take effect.
   *
   * @schema AlertmanagerConfigSpecInhibitRules#equal
   */
  readonly equal?: string[];

  /**
   * Matchers for which one or more alerts have to exist for the inhibition
   * to take effect. The operator enforces that the alert matches the
   * resource's namespace.
   *
   * @schema AlertmanagerConfigSpecInhibitRules#sourceMatch
   */
  readonly sourceMatch?: AlertmanagerConfigSpecInhibitRulesSourceMatch[];

  /**
   * Matchers that have to be fulfilled in the alerts to be muted. The
   * operator enforces that the alert matches the resource's namespace.
   *
   * @schema AlertmanagerConfigSpecInhibitRules#targetMatch
   */
  readonly targetMatch?: AlertmanagerConfigSpecInhibitRulesTargetMatch[];

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecInhibitRules' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecInhibitRules(obj: AlertmanagerConfigSpecInhibitRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'equal': obj.equal?.map(y => y),
    'sourceMatch': obj.sourceMatch?.map(y => toJson_AlertmanagerConfigSpecInhibitRulesSourceMatch(y)),
    'targetMatch': obj.targetMatch?.map(y => toJson_AlertmanagerConfigSpecInhibitRulesTargetMatch(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * MuteTimeInterval specifies the periods in time when notifications will be muted
 *
 * @schema AlertmanagerConfigSpecMuteTimeIntervals
 */
export interface AlertmanagerConfigSpecMuteTimeIntervals {
  /**
   * Name of the time interval
   *
   * @schema AlertmanagerConfigSpecMuteTimeIntervals#name
   */
  readonly name?: string;

  /**
   * TimeIntervals is a list of TimeInterval
   *
   * @schema AlertmanagerConfigSpecMuteTimeIntervals#timeIntervals
   */
  readonly timeIntervals?: AlertmanagerConfigSpecMuteTimeIntervalsTimeIntervals[];

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecMuteTimeIntervals' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecMuteTimeIntervals(obj: AlertmanagerConfigSpecMuteTimeIntervals | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'timeIntervals': obj.timeIntervals?.map(y => toJson_AlertmanagerConfigSpecMuteTimeIntervalsTimeIntervals(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Receiver defines one or more notification integrations.
 *
 * @schema AlertmanagerConfigSpecReceivers
 */
export interface AlertmanagerConfigSpecReceivers {
  /**
   * List of Discord configurations.
   *
   * @schema AlertmanagerConfigSpecReceivers#discordConfigs
   */
  readonly discordConfigs?: AlertmanagerConfigSpecReceiversDiscordConfigs[];

  /**
   * List of Email configurations.
   *
   * @schema AlertmanagerConfigSpecReceivers#emailConfigs
   */
  readonly emailConfigs?: AlertmanagerConfigSpecReceiversEmailConfigs[];

  /**
   * List of MSTeams configurations.
   * It requires Alertmanager >= 0.26.0.
   *
   * @schema AlertmanagerConfigSpecReceivers#msteamsConfigs
   */
  readonly msteamsConfigs?: AlertmanagerConfigSpecReceiversMsteamsConfigs[];

  /**
   * Name of the receiver. Must be unique across all items from the list.
   *
   * @schema AlertmanagerConfigSpecReceivers#name
   */
  readonly name: string;

  /**
   * List of OpsGenie configurations.
   *
   * @schema AlertmanagerConfigSpecReceivers#opsgenieConfigs
   */
  readonly opsgenieConfigs?: AlertmanagerConfigSpecReceiversOpsgenieConfigs[];

  /**
   * List of PagerDuty configurations.
   *
   * @schema AlertmanagerConfigSpecReceivers#pagerdutyConfigs
   */
  readonly pagerdutyConfigs?: AlertmanagerConfigSpecReceiversPagerdutyConfigs[];

  /**
   * List of Pushover configurations.
   *
   * @schema AlertmanagerConfigSpecReceivers#pushoverConfigs
   */
  readonly pushoverConfigs?: AlertmanagerConfigSpecReceiversPushoverConfigs[];

  /**
   * List of Slack configurations.
   *
   * @schema AlertmanagerConfigSpecReceivers#slackConfigs
   */
  readonly slackConfigs?: AlertmanagerConfigSpecReceiversSlackConfigs[];

  /**
   * List of SNS configurations
   *
   * @schema AlertmanagerConfigSpecReceivers#snsConfigs
   */
  readonly snsConfigs?: AlertmanagerConfigSpecReceiversSnsConfigs[];

  /**
   * List of Telegram configurations.
   *
   * @schema AlertmanagerConfigSpecReceivers#telegramConfigs
   */
  readonly telegramConfigs?: AlertmanagerConfigSpecReceiversTelegramConfigs[];

  /**
   * List of VictorOps configurations.
   *
   * @schema AlertmanagerConfigSpecReceivers#victoropsConfigs
   */
  readonly victoropsConfigs?: AlertmanagerConfigSpecReceiversVictoropsConfigs[];

  /**
   * List of Webex configurations.
   *
   * @schema AlertmanagerConfigSpecReceivers#webexConfigs
   */
  readonly webexConfigs?: AlertmanagerConfigSpecReceiversWebexConfigs[];

  /**
   * List of webhook configurations.
   *
   * @schema AlertmanagerConfigSpecReceivers#webhookConfigs
   */
  readonly webhookConfigs?: AlertmanagerConfigSpecReceiversWebhookConfigs[];

  /**
   * List of WeChat configurations.
   *
   * @schema AlertmanagerConfigSpecReceivers#wechatConfigs
   */
  readonly wechatConfigs?: AlertmanagerConfigSpecReceiversWechatConfigs[];

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceivers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceivers(obj: AlertmanagerConfigSpecReceivers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'discordConfigs': obj.discordConfigs?.map(y => toJson_AlertmanagerConfigSpecReceiversDiscordConfigs(y)),
    'emailConfigs': obj.emailConfigs?.map(y => toJson_AlertmanagerConfigSpecReceiversEmailConfigs(y)),
    'msteamsConfigs': obj.msteamsConfigs?.map(y => toJson_AlertmanagerConfigSpecReceiversMsteamsConfigs(y)),
    'name': obj.name,
    'opsgenieConfigs': obj.opsgenieConfigs?.map(y => toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigs(y)),
    'pagerdutyConfigs': obj.pagerdutyConfigs?.map(y => toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigs(y)),
    'pushoverConfigs': obj.pushoverConfigs?.map(y => toJson_AlertmanagerConfigSpecReceiversPushoverConfigs(y)),
    'slackConfigs': obj.slackConfigs?.map(y => toJson_AlertmanagerConfigSpecReceiversSlackConfigs(y)),
    'snsConfigs': obj.snsConfigs?.map(y => toJson_AlertmanagerConfigSpecReceiversSnsConfigs(y)),
    'telegramConfigs': obj.telegramConfigs?.map(y => toJson_AlertmanagerConfigSpecReceiversTelegramConfigs(y)),
    'victoropsConfigs': obj.victoropsConfigs?.map(y => toJson_AlertmanagerConfigSpecReceiversVictoropsConfigs(y)),
    'webexConfigs': obj.webexConfigs?.map(y => toJson_AlertmanagerConfigSpecReceiversWebexConfigs(y)),
    'webhookConfigs': obj.webhookConfigs?.map(y => toJson_AlertmanagerConfigSpecReceiversWebhookConfigs(y)),
    'wechatConfigs': obj.wechatConfigs?.map(y => toJson_AlertmanagerConfigSpecReceiversWechatConfigs(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Alertmanager route definition for alerts matching the resource's
 * namespace. If present, it will be added to the generated Alertmanager
 * configuration as a first-level route.
 *
 * @schema AlertmanagerConfigSpecRoute
 */
export interface AlertmanagerConfigSpecRoute {
  /**
   * ActiveTimeIntervals is a list of MuteTimeInterval names when this route should be active.
   *
   * @schema AlertmanagerConfigSpecRoute#activeTimeIntervals
   */
  readonly activeTimeIntervals?: string[];

  /**
   * Boolean indicating whether an alert should continue matching subsequent
   * sibling nodes. It will always be overridden to true for the first-level
   * route by the Prometheus operator.
   *
   * @schema AlertmanagerConfigSpecRoute#continue
   */
  readonly continue?: boolean;

  /**
   * List of labels to group by.
   * Labels must not be repeated (unique list).
   * Special label "..." (aggregate by all possible labels), if provided, must be the only element in the list.
   *
   * @schema AlertmanagerConfigSpecRoute#groupBy
   */
  readonly groupBy?: string[];

  /**
   * How long to wait before sending an updated notification.
   * Must match the regular expression`^(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?$`
   * Example: "5m"
   *
   * @schema AlertmanagerConfigSpecRoute#groupInterval
   */
  readonly groupInterval?: string;

  /**
   * How long to wait before sending the initial notification.
   * Must match the regular expression`^(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?$`
   * Example: "30s"
   *
   * @schema AlertmanagerConfigSpecRoute#groupWait
   */
  readonly groupWait?: string;

  /**
   * List of matchers that the alert's labels should match. For the first
   * level route, the operator removes any existing equality and regexp
   * matcher on the `namespace` label and adds a `namespace: <object
   * namespace>` matcher.
   *
   * @schema AlertmanagerConfigSpecRoute#matchers
   */
  readonly matchers?: AlertmanagerConfigSpecRouteMatchers[];

  /**
   * Note: this comment applies to the field definition above but appears
   * below otherwise it gets included in the generated manifest.
   * CRD schema doesn't support self-referential types for now (see
   * https://github.com/kubernetes/kubernetes/issues/62872). We have to use
   * an alternative type to circumvent the limitation. The downside is that
   * the Kube API can't validate the data beyond the fact that it is a valid
   * JSON representation.
   * MuteTimeIntervals is a list of MuteTimeInterval names that will mute this route when matched,
   *
   * @schema AlertmanagerConfigSpecRoute#muteTimeIntervals
   */
  readonly muteTimeIntervals?: string[];

  /**
   * Name of the receiver for this route. If not empty, it should be listed in
   * the `receivers` field.
   *
   * @schema AlertmanagerConfigSpecRoute#receiver
   */
  readonly receiver?: string;

  /**
   * How long to wait before repeating the last notification.
   * Must match the regular expression`^(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?$`
   * Example: "4h"
   *
   * @schema AlertmanagerConfigSpecRoute#repeatInterval
   */
  readonly repeatInterval?: string;

  /**
   * Child routes.
   *
   * @schema AlertmanagerConfigSpecRoute#routes
   */
  readonly routes?: any[];

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecRoute' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecRoute(obj: AlertmanagerConfigSpecRoute | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'activeTimeIntervals': obj.activeTimeIntervals?.map(y => y),
    'continue': obj.continue,
    'groupBy': obj.groupBy?.map(y => y),
    'groupInterval': obj.groupInterval,
    'groupWait': obj.groupWait,
    'matchers': obj.matchers?.map(y => toJson_AlertmanagerConfigSpecRouteMatchers(y)),
    'muteTimeIntervals': obj.muteTimeIntervals?.map(y => y),
    'receiver': obj.receiver,
    'repeatInterval': obj.repeatInterval,
    'routes': obj.routes?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Matcher defines how to match on alert's labels.
 *
 * @schema AlertmanagerConfigSpecInhibitRulesSourceMatch
 */
export interface AlertmanagerConfigSpecInhibitRulesSourceMatch {
  /**
   * Match operation available with AlertManager >= v0.22.0 and
   * takes precedence over Regex (deprecated) if non-empty.
   *
   * @schema AlertmanagerConfigSpecInhibitRulesSourceMatch#matchType
   */
  readonly matchType?: AlertmanagerConfigSpecInhibitRulesSourceMatchMatchType;

  /**
   * Label to match.
   *
   * @schema AlertmanagerConfigSpecInhibitRulesSourceMatch#name
   */
  readonly name: string;

  /**
   * Whether to match on equality (false) or regular-expression (true).
   * Deprecated: for AlertManager >= v0.22.0, `matchType` should be used instead.
   *
   * @schema AlertmanagerConfigSpecInhibitRulesSourceMatch#regex
   */
  readonly regex?: boolean;

  /**
   * Label value to match.
   *
   * @schema AlertmanagerConfigSpecInhibitRulesSourceMatch#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecInhibitRulesSourceMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecInhibitRulesSourceMatch(obj: AlertmanagerConfigSpecInhibitRulesSourceMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchType': obj.matchType,
    'name': obj.name,
    'regex': obj.regex,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Matcher defines how to match on alert's labels.
 *
 * @schema AlertmanagerConfigSpecInhibitRulesTargetMatch
 */
export interface AlertmanagerConfigSpecInhibitRulesTargetMatch {
  /**
   * Match operation available with AlertManager >= v0.22.0 and
   * takes precedence over Regex (deprecated) if non-empty.
   *
   * @schema AlertmanagerConfigSpecInhibitRulesTargetMatch#matchType
   */
  readonly matchType?: AlertmanagerConfigSpecInhibitRulesTargetMatchMatchType;

  /**
   * Label to match.
   *
   * @schema AlertmanagerConfigSpecInhibitRulesTargetMatch#name
   */
  readonly name: string;

  /**
   * Whether to match on equality (false) or regular-expression (true).
   * Deprecated: for AlertManager >= v0.22.0, `matchType` should be used instead.
   *
   * @schema AlertmanagerConfigSpecInhibitRulesTargetMatch#regex
   */
  readonly regex?: boolean;

  /**
   * Label value to match.
   *
   * @schema AlertmanagerConfigSpecInhibitRulesTargetMatch#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecInhibitRulesTargetMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecInhibitRulesTargetMatch(obj: AlertmanagerConfigSpecInhibitRulesTargetMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchType': obj.matchType,
    'name': obj.name,
    'regex': obj.regex,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TimeInterval describes intervals of time
 *
 * @schema AlertmanagerConfigSpecMuteTimeIntervalsTimeIntervals
 */
export interface AlertmanagerConfigSpecMuteTimeIntervalsTimeIntervals {
  /**
   * DaysOfMonth is a list of DayOfMonthRange
   *
   * @schema AlertmanagerConfigSpecMuteTimeIntervalsTimeIntervals#daysOfMonth
   */
  readonly daysOfMonth?: AlertmanagerConfigSpecMuteTimeIntervalsTimeIntervalsDaysOfMonth[];

  /**
   * Months is a list of MonthRange
   *
   * @schema AlertmanagerConfigSpecMuteTimeIntervalsTimeIntervals#months
   */
  readonly months?: string[];

  /**
   * Times is a list of TimeRange
   *
   * @schema AlertmanagerConfigSpecMuteTimeIntervalsTimeIntervals#times
   */
  readonly times?: AlertmanagerConfigSpecMuteTimeIntervalsTimeIntervalsTimes[];

  /**
   * Weekdays is a list of WeekdayRange
   *
   * @schema AlertmanagerConfigSpecMuteTimeIntervalsTimeIntervals#weekdays
   */
  readonly weekdays?: string[];

  /**
   * Years is a list of YearRange
   *
   * @schema AlertmanagerConfigSpecMuteTimeIntervalsTimeIntervals#years
   */
  readonly years?: string[];

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecMuteTimeIntervalsTimeIntervals' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecMuteTimeIntervalsTimeIntervals(obj: AlertmanagerConfigSpecMuteTimeIntervalsTimeIntervals | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'daysOfMonth': obj.daysOfMonth?.map(y => toJson_AlertmanagerConfigSpecMuteTimeIntervalsTimeIntervalsDaysOfMonth(y)),
    'months': obj.months?.map(y => y),
    'times': obj.times?.map(y => toJson_AlertmanagerConfigSpecMuteTimeIntervalsTimeIntervalsTimes(y)),
    'weekdays': obj.weekdays?.map(y => y),
    'years': obj.years?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DiscordConfig configures notifications via Discord.
 * See https://prometheus.io/docs/alerting/latest/configuration/#discord_config
 *
 * @schema AlertmanagerConfigSpecReceiversDiscordConfigs
 */
export interface AlertmanagerConfigSpecReceiversDiscordConfigs {
  /**
   * The secret's key that contains the Discord webhook URL.
   * The secret needs to be in the same namespace as the AlertmanagerConfig
   * object and accessible by the Prometheus Operator.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigs#apiURL
   */
  readonly apiUrl: AlertmanagerConfigSpecReceiversDiscordConfigsApiUrl;

  /**
   * HTTP client configuration.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigs#httpConfig
   */
  readonly httpConfig?: AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfig;

  /**
   * The template of the message's body.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigs#message
   */
  readonly message?: string;

  /**
   * Whether or not to notify about resolved alerts.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigs#sendResolved
   */
  readonly sendResolved?: boolean;

  /**
   * The template of the message's title.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigs#title
   */
  readonly title?: string;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversDiscordConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversDiscordConfigs(obj: AlertmanagerConfigSpecReceiversDiscordConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiURL': toJson_AlertmanagerConfigSpecReceiversDiscordConfigsApiUrl(obj.apiUrl),
    'httpConfig': toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfig(obj.httpConfig),
    'message': obj.message,
    'sendResolved': obj.sendResolved,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EmailConfig configures notifications via Email.
 *
 * @schema AlertmanagerConfigSpecReceiversEmailConfigs
 */
export interface AlertmanagerConfigSpecReceiversEmailConfigs {
  /**
   * The identity to use for authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigs#authIdentity
   */
  readonly authIdentity?: string;

  /**
   * The secret's key that contains the password to use for authentication.
   * The secret needs to be in the same namespace as the AlertmanagerConfig
   * object and accessible by the Prometheus Operator.
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigs#authPassword
   */
  readonly authPassword?: AlertmanagerConfigSpecReceiversEmailConfigsAuthPassword;

  /**
   * The secret's key that contains the CRAM-MD5 secret.
   * The secret needs to be in the same namespace as the AlertmanagerConfig
   * object and accessible by the Prometheus Operator.
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigs#authSecret
   */
  readonly authSecret?: AlertmanagerConfigSpecReceiversEmailConfigsAuthSecret;

  /**
   * The username to use for authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigs#authUsername
   */
  readonly authUsername?: string;

  /**
   * The sender address.
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigs#from
   */
  readonly from?: string;

  /**
   * Further headers email header key/value pairs. Overrides any headers
   * previously set by the notification implementation.
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigs#headers
   */
  readonly headers?: AlertmanagerConfigSpecReceiversEmailConfigsHeaders[];

  /**
   * The hostname to identify to the SMTP server.
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigs#hello
   */
  readonly hello?: string;

  /**
   * The HTML body of the email notification.
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigs#html
   */
  readonly html?: string;

  /**
   * The SMTP TLS requirement.
   * Note that Go does not support unencrypted connections to remote SMTP endpoints.
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigs#requireTLS
   */
  readonly requireTls?: boolean;

  /**
   * Whether or not to notify about resolved alerts.
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigs#sendResolved
   */
  readonly sendResolved?: boolean;

  /**
   * The SMTP host and port through which emails are sent. E.g. example.com:25
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigs#smarthost
   */
  readonly smarthost?: string;

  /**
   * The text body of the email notification.
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigs#text
   */
  readonly text?: string;

  /**
   * TLS configuration
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigs#tlsConfig
   */
  readonly tlsConfig?: AlertmanagerConfigSpecReceiversEmailConfigsTlsConfig;

  /**
   * The email address to send notifications to.
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigs#to
   */
  readonly to?: string;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversEmailConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversEmailConfigs(obj: AlertmanagerConfigSpecReceiversEmailConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authIdentity': obj.authIdentity,
    'authPassword': toJson_AlertmanagerConfigSpecReceiversEmailConfigsAuthPassword(obj.authPassword),
    'authSecret': toJson_AlertmanagerConfigSpecReceiversEmailConfigsAuthSecret(obj.authSecret),
    'authUsername': obj.authUsername,
    'from': obj.from,
    'headers': obj.headers?.map(y => toJson_AlertmanagerConfigSpecReceiversEmailConfigsHeaders(y)),
    'hello': obj.hello,
    'html': obj.html,
    'requireTLS': obj.requireTls,
    'sendResolved': obj.sendResolved,
    'smarthost': obj.smarthost,
    'text': obj.text,
    'tlsConfig': toJson_AlertmanagerConfigSpecReceiversEmailConfigsTlsConfig(obj.tlsConfig),
    'to': obj.to,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * MSTeamsConfig configures notifications via Microsoft Teams.
 * It requires Alertmanager >= 0.26.0.
 *
 * @schema AlertmanagerConfigSpecReceiversMsteamsConfigs
 */
export interface AlertmanagerConfigSpecReceiversMsteamsConfigs {
  /**
   * HTTP client configuration.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigs#httpConfig
   */
  readonly httpConfig?: AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfig;

  /**
   * Whether to notify about resolved alerts.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigs#sendResolved
   */
  readonly sendResolved?: boolean;

  /**
   * Message summary template.
   * It requires Alertmanager >= 0.27.0.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigs#summary
   */
  readonly summary?: string;

  /**
   * Message body template.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigs#text
   */
  readonly text?: string;

  /**
   * Message title template.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigs#title
   */
  readonly title?: string;

  /**
   * MSTeams webhook URL.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigs#webhookUrl
   */
  readonly webhookUrl: AlertmanagerConfigSpecReceiversMsteamsConfigsWebhookUrl;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversMsteamsConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversMsteamsConfigs(obj: AlertmanagerConfigSpecReceiversMsteamsConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpConfig': toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfig(obj.httpConfig),
    'sendResolved': obj.sendResolved,
    'summary': obj.summary,
    'text': obj.text,
    'title': obj.title,
    'webhookUrl': toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsWebhookUrl(obj.webhookUrl),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * OpsGenieConfig configures notifications via OpsGenie.
 * See https://prometheus.io/docs/alerting/latest/configuration/#opsgenie_config
 *
 * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigs
 */
export interface AlertmanagerConfigSpecReceiversOpsgenieConfigs {
  /**
   * Comma separated list of actions that will be available for the alert.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigs#actions
   */
  readonly actions?: string;

  /**
   * The secret's key that contains the OpsGenie API key.
   * The secret needs to be in the same namespace as the AlertmanagerConfig
   * object and accessible by the Prometheus Operator.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigs#apiKey
   */
  readonly apiKey?: AlertmanagerConfigSpecReceiversOpsgenieConfigsApiKey;

  /**
   * The URL to send OpsGenie API requests to.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigs#apiURL
   */
  readonly apiUrl?: string;

  /**
   * Description of the incident.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigs#description
   */
  readonly description?: string;

  /**
   * A set of arbitrary key/value pairs that provide further detail about the incident.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigs#details
   */
  readonly details?: AlertmanagerConfigSpecReceiversOpsgenieConfigsDetails[];

  /**
   * Optional field that can be used to specify which domain alert is related to.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigs#entity
   */
  readonly entity?: string;

  /**
   * HTTP client configuration.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigs#httpConfig
   */
  readonly httpConfig?: AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfig;

  /**
   * Alert text limited to 130 characters.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigs#message
   */
  readonly message?: string;

  /**
   * Additional alert note.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigs#note
   */
  readonly note?: string;

  /**
   * Priority level of alert. Possible values are P1, P2, P3, P4, and P5.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigs#priority
   */
  readonly priority?: string;

  /**
   * List of responders responsible for notifications.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigs#responders
   */
  readonly responders?: AlertmanagerConfigSpecReceiversOpsgenieConfigsResponders[];

  /**
   * Whether or not to notify about resolved alerts.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigs#sendResolved
   */
  readonly sendResolved?: boolean;

  /**
   * Backlink to the sender of the notification.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigs#source
   */
  readonly source?: string;

  /**
   * Comma separated list of tags attached to the notifications.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigs#tags
   */
  readonly tags?: string;

  /**
   * Whether to update message and description of the alert in OpsGenie if it already exists
   * By default, the alert is never updated in OpsGenie, the new message only appears in activity log.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigs#updateAlerts
   */
  readonly updateAlerts?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversOpsgenieConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigs(obj: AlertmanagerConfigSpecReceiversOpsgenieConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'actions': obj.actions,
    'apiKey': toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsApiKey(obj.apiKey),
    'apiURL': obj.apiUrl,
    'description': obj.description,
    'details': obj.details?.map(y => toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsDetails(y)),
    'entity': obj.entity,
    'httpConfig': toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfig(obj.httpConfig),
    'message': obj.message,
    'note': obj.note,
    'priority': obj.priority,
    'responders': obj.responders?.map(y => toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsResponders(y)),
    'sendResolved': obj.sendResolved,
    'source': obj.source,
    'tags': obj.tags,
    'updateAlerts': obj.updateAlerts,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PagerDutyConfig configures notifications via PagerDuty.
 * See https://prometheus.io/docs/alerting/latest/configuration/#pagerduty_config
 *
 * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigs
 */
export interface AlertmanagerConfigSpecReceiversPagerdutyConfigs {
  /**
   * The class/type of the event.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigs#class
   */
  readonly class?: string;

  /**
   * Client identification.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigs#client
   */
  readonly client?: string;

  /**
   * Backlink to the sender of notification.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigs#clientURL
   */
  readonly clientUrl?: string;

  /**
   * The part or component of the affected system that is broken.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigs#component
   */
  readonly component?: string;

  /**
   * Description of the incident.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigs#description
   */
  readonly description?: string;

  /**
   * Arbitrary key/value pairs that provide further detail about the incident.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigs#details
   */
  readonly details?: AlertmanagerConfigSpecReceiversPagerdutyConfigsDetails[];

  /**
   * A cluster or grouping of sources.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigs#group
   */
  readonly group?: string;

  /**
   * HTTP client configuration.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigs#httpConfig
   */
  readonly httpConfig?: AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfig;

  /**
   * A list of image details to attach that provide further detail about an incident.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigs#pagerDutyImageConfigs
   */
  readonly pagerDutyImageConfigs?: AlertmanagerConfigSpecReceiversPagerdutyConfigsPagerDutyImageConfigs[];

  /**
   * A list of link details to attach that provide further detail about an incident.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigs#pagerDutyLinkConfigs
   */
  readonly pagerDutyLinkConfigs?: AlertmanagerConfigSpecReceiversPagerdutyConfigsPagerDutyLinkConfigs[];

  /**
   * The secret's key that contains the PagerDuty integration key (when using
   * Events API v2). Either this field or `serviceKey` needs to be defined.
   * The secret needs to be in the same namespace as the AlertmanagerConfig
   * object and accessible by the Prometheus Operator.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigs#routingKey
   */
  readonly routingKey?: AlertmanagerConfigSpecReceiversPagerdutyConfigsRoutingKey;

  /**
   * Whether or not to notify about resolved alerts.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigs#sendResolved
   */
  readonly sendResolved?: boolean;

  /**
   * The secret's key that contains the PagerDuty service key (when using
   * integration type "Prometheus"). Either this field or `routingKey` needs to
   * be defined.
   * The secret needs to be in the same namespace as the AlertmanagerConfig
   * object and accessible by the Prometheus Operator.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigs#serviceKey
   */
  readonly serviceKey?: AlertmanagerConfigSpecReceiversPagerdutyConfigsServiceKey;

  /**
   * Severity of the incident.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigs#severity
   */
  readonly severity?: string;

  /**
   * The URL to send requests to.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigs#url
   */
  readonly url?: string;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPagerdutyConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigs(obj: AlertmanagerConfigSpecReceiversPagerdutyConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'class': obj.class,
    'client': obj.client,
    'clientURL': obj.clientUrl,
    'component': obj.component,
    'description': obj.description,
    'details': obj.details?.map(y => toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsDetails(y)),
    'group': obj.group,
    'httpConfig': toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfig(obj.httpConfig),
    'pagerDutyImageConfigs': obj.pagerDutyImageConfigs?.map(y => toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsPagerDutyImageConfigs(y)),
    'pagerDutyLinkConfigs': obj.pagerDutyLinkConfigs?.map(y => toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsPagerDutyLinkConfigs(y)),
    'routingKey': toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsRoutingKey(obj.routingKey),
    'sendResolved': obj.sendResolved,
    'serviceKey': toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsServiceKey(obj.serviceKey),
    'severity': obj.severity,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PushoverConfig configures notifications via Pushover.
 * See https://prometheus.io/docs/alerting/latest/configuration/#pushover_config
 *
 * @schema AlertmanagerConfigSpecReceiversPushoverConfigs
 */
export interface AlertmanagerConfigSpecReceiversPushoverConfigs {
  /**
   * The name of a device to send the notification to
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigs#device
   */
  readonly device?: string;

  /**
   * How long your notification will continue to be retried for, unless the user
   * acknowledges the notification.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigs#expire
   */
  readonly expire?: string;

  /**
   * Whether notification message is HTML or plain text.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigs#html
   */
  readonly html?: boolean;

  /**
   * HTTP client configuration.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigs#httpConfig
   */
  readonly httpConfig?: AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfig;

  /**
   * Notification message.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigs#message
   */
  readonly message?: string;

  /**
   * Priority, see https://pushover.net/api#priority
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigs#priority
   */
  readonly priority?: string;

  /**
   * How often the Pushover servers will send the same notification to the user.
   * Must be at least 30 seconds.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigs#retry
   */
  readonly retry?: string;

  /**
   * Whether or not to notify about resolved alerts.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigs#sendResolved
   */
  readonly sendResolved?: boolean;

  /**
   * The name of one of the sounds supported by device clients to override the user's default sound choice
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigs#sound
   */
  readonly sound?: string;

  /**
   * Notification title.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigs#title
   */
  readonly title?: string;

  /**
   * The secret's key that contains the registered application's API token, see https://pushover.net/apps.
   * The secret needs to be in the same namespace as the AlertmanagerConfig
   * object and accessible by the Prometheus Operator.
   * Either `token` or `tokenFile` is required.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigs#token
   */
  readonly token?: AlertmanagerConfigSpecReceiversPushoverConfigsToken;

  /**
   * The token file that contains the registered application's API token, see https://pushover.net/apps.
   * Either `token` or `tokenFile` is required.
   * It requires Alertmanager >= v0.26.0.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigs#tokenFile
   */
  readonly tokenFile?: string;

  /**
   * A supplementary URL shown alongside the message.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigs#url
   */
  readonly url?: string;

  /**
   * A title for supplementary URL, otherwise just the URL is shown
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigs#urlTitle
   */
  readonly urlTitle?: string;

  /**
   * The secret's key that contains the recipient user's user key.
   * The secret needs to be in the same namespace as the AlertmanagerConfig
   * object and accessible by the Prometheus Operator.
   * Either `userKey` or `userKeyFile` is required.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigs#userKey
   */
  readonly userKey?: AlertmanagerConfigSpecReceiversPushoverConfigsUserKey;

  /**
   * The user key file that contains the recipient user's user key.
   * Either `userKey` or `userKeyFile` is required.
   * It requires Alertmanager >= v0.26.0.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigs#userKeyFile
   */
  readonly userKeyFile?: string;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPushoverConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPushoverConfigs(obj: AlertmanagerConfigSpecReceiversPushoverConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'device': obj.device,
    'expire': obj.expire,
    'html': obj.html,
    'httpConfig': toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfig(obj.httpConfig),
    'message': obj.message,
    'priority': obj.priority,
    'retry': obj.retry,
    'sendResolved': obj.sendResolved,
    'sound': obj.sound,
    'title': obj.title,
    'token': toJson_AlertmanagerConfigSpecReceiversPushoverConfigsToken(obj.token),
    'tokenFile': obj.tokenFile,
    'url': obj.url,
    'urlTitle': obj.urlTitle,
    'userKey': toJson_AlertmanagerConfigSpecReceiversPushoverConfigsUserKey(obj.userKey),
    'userKeyFile': obj.userKeyFile,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SlackConfig configures notifications via Slack.
 * See https://prometheus.io/docs/alerting/latest/configuration/#slack_config
 *
 * @schema AlertmanagerConfigSpecReceiversSlackConfigs
 */
export interface AlertmanagerConfigSpecReceiversSlackConfigs {
  /**
   * A list of Slack actions that are sent with each notification.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigs#actions
   */
  readonly actions?: AlertmanagerConfigSpecReceiversSlackConfigsActions[];

  /**
   * The secret's key that contains the Slack webhook URL.
   * The secret needs to be in the same namespace as the AlertmanagerConfig
   * object and accessible by the Prometheus Operator.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigs#apiURL
   */
  readonly apiUrl?: AlertmanagerConfigSpecReceiversSlackConfigsApiUrl;

  /**
   * @schema AlertmanagerConfigSpecReceiversSlackConfigs#callbackId
   */
  readonly callbackId?: string;

  /**
   * The channel or user to send notifications to.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigs#channel
   */
  readonly channel?: string;

  /**
   * @schema AlertmanagerConfigSpecReceiversSlackConfigs#color
   */
  readonly color?: string;

  /**
   * @schema AlertmanagerConfigSpecReceiversSlackConfigs#fallback
   */
  readonly fallback?: string;

  /**
   * A list of Slack fields that are sent with each notification.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigs#fields
   */
  readonly fields?: AlertmanagerConfigSpecReceiversSlackConfigsFields[];

  /**
   * @schema AlertmanagerConfigSpecReceiversSlackConfigs#footer
   */
  readonly footer?: string;

  /**
   * HTTP client configuration.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigs#httpConfig
   */
  readonly httpConfig?: AlertmanagerConfigSpecReceiversSlackConfigsHttpConfig;

  /**
   * @schema AlertmanagerConfigSpecReceiversSlackConfigs#iconEmoji
   */
  readonly iconEmoji?: string;

  /**
   * @schema AlertmanagerConfigSpecReceiversSlackConfigs#iconURL
   */
  readonly iconUrl?: string;

  /**
   * @schema AlertmanagerConfigSpecReceiversSlackConfigs#imageURL
   */
  readonly imageUrl?: string;

  /**
   * @schema AlertmanagerConfigSpecReceiversSlackConfigs#linkNames
   */
  readonly linkNames?: boolean;

  /**
   * @schema AlertmanagerConfigSpecReceiversSlackConfigs#mrkdwnIn
   */
  readonly mrkdwnIn?: string[];

  /**
   * @schema AlertmanagerConfigSpecReceiversSlackConfigs#pretext
   */
  readonly pretext?: string;

  /**
   * Whether or not to notify about resolved alerts.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigs#sendResolved
   */
  readonly sendResolved?: boolean;

  /**
   * @schema AlertmanagerConfigSpecReceiversSlackConfigs#shortFields
   */
  readonly shortFields?: boolean;

  /**
   * @schema AlertmanagerConfigSpecReceiversSlackConfigs#text
   */
  readonly text?: string;

  /**
   * @schema AlertmanagerConfigSpecReceiversSlackConfigs#thumbURL
   */
  readonly thumbUrl?: string;

  /**
   * @schema AlertmanagerConfigSpecReceiversSlackConfigs#title
   */
  readonly title?: string;

  /**
   * @schema AlertmanagerConfigSpecReceiversSlackConfigs#titleLink
   */
  readonly titleLink?: string;

  /**
   * @schema AlertmanagerConfigSpecReceiversSlackConfigs#username
   */
  readonly username?: string;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSlackConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSlackConfigs(obj: AlertmanagerConfigSpecReceiversSlackConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'actions': obj.actions?.map(y => toJson_AlertmanagerConfigSpecReceiversSlackConfigsActions(y)),
    'apiURL': toJson_AlertmanagerConfigSpecReceiversSlackConfigsApiUrl(obj.apiUrl),
    'callbackId': obj.callbackId,
    'channel': obj.channel,
    'color': obj.color,
    'fallback': obj.fallback,
    'fields': obj.fields?.map(y => toJson_AlertmanagerConfigSpecReceiversSlackConfigsFields(y)),
    'footer': obj.footer,
    'httpConfig': toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfig(obj.httpConfig),
    'iconEmoji': obj.iconEmoji,
    'iconURL': obj.iconUrl,
    'imageURL': obj.imageUrl,
    'linkNames': obj.linkNames,
    'mrkdwnIn': obj.mrkdwnIn?.map(y => y),
    'pretext': obj.pretext,
    'sendResolved': obj.sendResolved,
    'shortFields': obj.shortFields,
    'text': obj.text,
    'thumbURL': obj.thumbUrl,
    'title': obj.title,
    'titleLink': obj.titleLink,
    'username': obj.username,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SNSConfig configures notifications via AWS SNS.
 * See https://prometheus.io/docs/alerting/latest/configuration/#sns_configs
 *
 * @schema AlertmanagerConfigSpecReceiversSnsConfigs
 */
export interface AlertmanagerConfigSpecReceiversSnsConfigs {
  /**
   * The SNS API URL i.e. https://sns.us-east-2.amazonaws.com.
   * If not specified, the SNS API URL from the SNS SDK will be used.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigs#apiURL
   */
  readonly apiUrl?: string;

  /**
   * SNS message attributes.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigs#attributes
   */
  readonly attributes?: { [key: string]: string };

  /**
   * HTTP client configuration.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigs#httpConfig
   */
  readonly httpConfig?: AlertmanagerConfigSpecReceiversSnsConfigsHttpConfig;

  /**
   * The message content of the SNS notification.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigs#message
   */
  readonly message?: string;

  /**
   * Phone number if message is delivered via SMS in E.164 format.
   * If you don't specify this value, you must specify a value for the TopicARN or TargetARN.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigs#phoneNumber
   */
  readonly phoneNumber?: string;

  /**
   * Whether or not to notify about resolved alerts.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigs#sendResolved
   */
  readonly sendResolved?: boolean;

  /**
   * Configures AWS's Signature Verification 4 signing process to sign requests.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigs#sigv4
   */
  readonly sigv4?: AlertmanagerConfigSpecReceiversSnsConfigsSigv4;

  /**
   * Subject line when the message is delivered to email endpoints.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigs#subject
   */
  readonly subject?: string;

  /**
   * The  mobile platform endpoint ARN if message is delivered via mobile notifications.
   * If you don't specify this value, you must specify a value for the topic_arn or PhoneNumber.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigs#targetARN
   */
  readonly targetArn?: string;

  /**
   * SNS topic ARN, i.e. arn:aws:sns:us-east-2:698519295917:My-Topic
   * If you don't specify this value, you must specify a value for the PhoneNumber or TargetARN.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigs#topicARN
   */
  readonly topicArn?: string;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSnsConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSnsConfigs(obj: AlertmanagerConfigSpecReceiversSnsConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiURL': obj.apiUrl,
    'attributes': ((obj.attributes) === undefined) ? undefined : (Object.entries(obj.attributes).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'httpConfig': toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfig(obj.httpConfig),
    'message': obj.message,
    'phoneNumber': obj.phoneNumber,
    'sendResolved': obj.sendResolved,
    'sigv4': toJson_AlertmanagerConfigSpecReceiversSnsConfigsSigv4(obj.sigv4),
    'subject': obj.subject,
    'targetARN': obj.targetArn,
    'topicARN': obj.topicArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TelegramConfig configures notifications via Telegram.
 * See https://prometheus.io/docs/alerting/latest/configuration/#telegram_config
 *
 * @schema AlertmanagerConfigSpecReceiversTelegramConfigs
 */
export interface AlertmanagerConfigSpecReceiversTelegramConfigs {
  /**
   * The Telegram API URL i.e. https://api.telegram.org.
   * If not specified, default API URL will be used.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigs#apiURL
   */
  readonly apiUrl?: string;

  /**
   * Telegram bot token. It is mutually exclusive with `botTokenFile`.
   * The secret needs to be in the same namespace as the AlertmanagerConfig
   * object and accessible by the Prometheus Operator.
   *
   *
   * Either `botToken` or `botTokenFile` is required.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigs#botToken
   */
  readonly botToken?: AlertmanagerConfigSpecReceiversTelegramConfigsBotToken;

  /**
   * File to read the Telegram bot token from. It is mutually exclusive with `botToken`.
   * Either `botToken` or `botTokenFile` is required.
   *
   *
   * It requires Alertmanager >= v0.26.0.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigs#botTokenFile
   */
  readonly botTokenFile?: string;

  /**
   * The Telegram chat ID.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigs#chatID
   */
  readonly chatId?: number;

  /**
   * Disable telegram notifications
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigs#disableNotifications
   */
  readonly disableNotifications?: boolean;

  /**
   * HTTP client configuration.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigs#httpConfig
   */
  readonly httpConfig?: AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfig;

  /**
   * Message template
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigs#message
   */
  readonly message?: string;

  /**
   * Parse mode for telegram message
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigs#parseMode
   */
  readonly parseMode?: AlertmanagerConfigSpecReceiversTelegramConfigsParseMode;

  /**
   * Whether to notify about resolved alerts.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigs#sendResolved
   */
  readonly sendResolved?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversTelegramConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversTelegramConfigs(obj: AlertmanagerConfigSpecReceiversTelegramConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiURL': obj.apiUrl,
    'botToken': toJson_AlertmanagerConfigSpecReceiversTelegramConfigsBotToken(obj.botToken),
    'botTokenFile': obj.botTokenFile,
    'chatID': obj.chatId,
    'disableNotifications': obj.disableNotifications,
    'httpConfig': toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfig(obj.httpConfig),
    'message': obj.message,
    'parseMode': obj.parseMode,
    'sendResolved': obj.sendResolved,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VictorOpsConfig configures notifications via VictorOps.
 * See https://prometheus.io/docs/alerting/latest/configuration/#victorops_config
 *
 * @schema AlertmanagerConfigSpecReceiversVictoropsConfigs
 */
export interface AlertmanagerConfigSpecReceiversVictoropsConfigs {
  /**
   * The secret's key that contains the API key to use when talking to the VictorOps API.
   * The secret needs to be in the same namespace as the AlertmanagerConfig
   * object and accessible by the Prometheus Operator.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigs#apiKey
   */
  readonly apiKey?: AlertmanagerConfigSpecReceiversVictoropsConfigsApiKey;

  /**
   * The VictorOps API URL.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigs#apiUrl
   */
  readonly apiUrl?: string;

  /**
   * Additional custom fields for notification.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigs#customFields
   */
  readonly customFields?: AlertmanagerConfigSpecReceiversVictoropsConfigsCustomFields[];

  /**
   * Contains summary of the alerted problem.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigs#entityDisplayName
   */
  readonly entityDisplayName?: string;

  /**
   * The HTTP client's configuration.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigs#httpConfig
   */
  readonly httpConfig?: AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfig;

  /**
   * Describes the behavior of the alert (CRITICAL, WARNING, INFO).
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigs#messageType
   */
  readonly messageType?: string;

  /**
   * The monitoring tool the state message is from.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigs#monitoringTool
   */
  readonly monitoringTool?: string;

  /**
   * A key used to map the alert to a team.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigs#routingKey
   */
  readonly routingKey?: string;

  /**
   * Whether or not to notify about resolved alerts.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigs#sendResolved
   */
  readonly sendResolved?: boolean;

  /**
   * Contains long explanation of the alerted problem.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigs#stateMessage
   */
  readonly stateMessage?: string;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversVictoropsConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversVictoropsConfigs(obj: AlertmanagerConfigSpecReceiversVictoropsConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiKey': toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsApiKey(obj.apiKey),
    'apiUrl': obj.apiUrl,
    'customFields': obj.customFields?.map(y => toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsCustomFields(y)),
    'entityDisplayName': obj.entityDisplayName,
    'httpConfig': toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfig(obj.httpConfig),
    'messageType': obj.messageType,
    'monitoringTool': obj.monitoringTool,
    'routingKey': obj.routingKey,
    'sendResolved': obj.sendResolved,
    'stateMessage': obj.stateMessage,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WebexConfig configures notification via Cisco Webex
 * See https://prometheus.io/docs/alerting/latest/configuration/#webex_config
 *
 * @schema AlertmanagerConfigSpecReceiversWebexConfigs
 */
export interface AlertmanagerConfigSpecReceiversWebexConfigs {
  /**
   * The Webex Teams API URL i.e. https://webexapis.com/v1/messages
   * Provide if different from the default API URL.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigs#apiURL
   */
  readonly apiUrl?: string;

  /**
   * The HTTP client's configuration.
   * You must supply the bot token via the `httpConfig.authorization` field.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigs#httpConfig
   */
  readonly httpConfig?: AlertmanagerConfigSpecReceiversWebexConfigsHttpConfig;

  /**
   * Message template
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigs#message
   */
  readonly message?: string;

  /**
   * ID of the Webex Teams room where to send the messages.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigs#roomID
   */
  readonly roomId: string;

  /**
   * Whether to notify about resolved alerts.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigs#sendResolved
   */
  readonly sendResolved?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebexConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebexConfigs(obj: AlertmanagerConfigSpecReceiversWebexConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiURL': obj.apiUrl,
    'httpConfig': toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfig(obj.httpConfig),
    'message': obj.message,
    'roomID': obj.roomId,
    'sendResolved': obj.sendResolved,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WebhookConfig configures notifications via a generic receiver supporting the webhook payload.
 * See https://prometheus.io/docs/alerting/latest/configuration/#webhook_config
 *
 * @schema AlertmanagerConfigSpecReceiversWebhookConfigs
 */
export interface AlertmanagerConfigSpecReceiversWebhookConfigs {
  /**
   * HTTP client configuration.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigs#httpConfig
   */
  readonly httpConfig?: AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfig;

  /**
   * Maximum number of alerts to be sent per webhook message. When 0, all alerts are included.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigs#maxAlerts
   */
  readonly maxAlerts?: number;

  /**
   * Whether or not to notify about resolved alerts.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigs#sendResolved
   */
  readonly sendResolved?: boolean;

  /**
   * The URL to send HTTP POST requests to. `urlSecret` takes precedence over
   * `url`. One of `urlSecret` and `url` should be defined.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigs#url
   */
  readonly url?: string;

  /**
   * The secret's key that contains the webhook URL to send HTTP requests to.
   * `urlSecret` takes precedence over `url`. One of `urlSecret` and `url`
   * should be defined.
   * The secret needs to be in the same namespace as the AlertmanagerConfig
   * object and accessible by the Prometheus Operator.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigs#urlSecret
   */
  readonly urlSecret?: AlertmanagerConfigSpecReceiversWebhookConfigsUrlSecret;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebhookConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebhookConfigs(obj: AlertmanagerConfigSpecReceiversWebhookConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpConfig': toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfig(obj.httpConfig),
    'maxAlerts': obj.maxAlerts,
    'sendResolved': obj.sendResolved,
    'url': obj.url,
    'urlSecret': toJson_AlertmanagerConfigSpecReceiversWebhookConfigsUrlSecret(obj.urlSecret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WeChatConfig configures notifications via WeChat.
 * See https://prometheus.io/docs/alerting/latest/configuration/#wechat_config
 *
 * @schema AlertmanagerConfigSpecReceiversWechatConfigs
 */
export interface AlertmanagerConfigSpecReceiversWechatConfigs {
  /**
   * @schema AlertmanagerConfigSpecReceiversWechatConfigs#agentID
   */
  readonly agentId?: string;

  /**
   * The secret's key that contains the WeChat API key.
   * The secret needs to be in the same namespace as the AlertmanagerConfig
   * object and accessible by the Prometheus Operator.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigs#apiSecret
   */
  readonly apiSecret?: AlertmanagerConfigSpecReceiversWechatConfigsApiSecret;

  /**
   * The WeChat API URL.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigs#apiURL
   */
  readonly apiUrl?: string;

  /**
   * The corp id for authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigs#corpID
   */
  readonly corpId?: string;

  /**
   * HTTP client configuration.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigs#httpConfig
   */
  readonly httpConfig?: AlertmanagerConfigSpecReceiversWechatConfigsHttpConfig;

  /**
   * API request data as defined by the WeChat API.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigs#message
   */
  readonly message?: string;

  /**
   * @schema AlertmanagerConfigSpecReceiversWechatConfigs#messageType
   */
  readonly messageType?: string;

  /**
   * Whether or not to notify about resolved alerts.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigs#sendResolved
   */
  readonly sendResolved?: boolean;

  /**
   * @schema AlertmanagerConfigSpecReceiversWechatConfigs#toParty
   */
  readonly toParty?: string;

  /**
   * @schema AlertmanagerConfigSpecReceiversWechatConfigs#toTag
   */
  readonly toTag?: string;

  /**
   * @schema AlertmanagerConfigSpecReceiversWechatConfigs#toUser
   */
  readonly toUser?: string;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWechatConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWechatConfigs(obj: AlertmanagerConfigSpecReceiversWechatConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'agentID': obj.agentId,
    'apiSecret': toJson_AlertmanagerConfigSpecReceiversWechatConfigsApiSecret(obj.apiSecret),
    'apiURL': obj.apiUrl,
    'corpID': obj.corpId,
    'httpConfig': toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfig(obj.httpConfig),
    'message': obj.message,
    'messageType': obj.messageType,
    'sendResolved': obj.sendResolved,
    'toParty': obj.toParty,
    'toTag': obj.toTag,
    'toUser': obj.toUser,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Matcher defines how to match on alert's labels.
 *
 * @schema AlertmanagerConfigSpecRouteMatchers
 */
export interface AlertmanagerConfigSpecRouteMatchers {
  /**
   * Match operation available with AlertManager >= v0.22.0 and
   * takes precedence over Regex (deprecated) if non-empty.
   *
   * @schema AlertmanagerConfigSpecRouteMatchers#matchType
   */
  readonly matchType?: AlertmanagerConfigSpecRouteMatchersMatchType;

  /**
   * Label to match.
   *
   * @schema AlertmanagerConfigSpecRouteMatchers#name
   */
  readonly name: string;

  /**
   * Whether to match on equality (false) or regular-expression (true).
   * Deprecated: for AlertManager >= v0.22.0, `matchType` should be used instead.
   *
   * @schema AlertmanagerConfigSpecRouteMatchers#regex
   */
  readonly regex?: boolean;

  /**
   * Label value to match.
   *
   * @schema AlertmanagerConfigSpecRouteMatchers#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecRouteMatchers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecRouteMatchers(obj: AlertmanagerConfigSpecRouteMatchers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchType': obj.matchType,
    'name': obj.name,
    'regex': obj.regex,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Match operation available with AlertManager >= v0.22.0 and
 * takes precedence over Regex (deprecated) if non-empty.
 *
 * @schema AlertmanagerConfigSpecInhibitRulesSourceMatchMatchType
 */
export enum AlertmanagerConfigSpecInhibitRulesSourceMatchMatchType {
  /** != */
  VALUE_NOT_EQUALS_TO = "!=",
  /** = */
  VALUE_EQUALS = "=",
  /** =~ */
  VALUE_EQUAL_TILDE = "=~",
  /** !~ */
  VALUE_NEGATION_TILDE = "!~",
}

/**
 * Match operation available with AlertManager >= v0.22.0 and
 * takes precedence over Regex (deprecated) if non-empty.
 *
 * @schema AlertmanagerConfigSpecInhibitRulesTargetMatchMatchType
 */
export enum AlertmanagerConfigSpecInhibitRulesTargetMatchMatchType {
  /** != */
  VALUE_NOT_EQUALS_TO = "!=",
  /** = */
  VALUE_EQUALS = "=",
  /** =~ */
  VALUE_EQUAL_TILDE = "=~",
  /** !~ */
  VALUE_NEGATION_TILDE = "!~",
}

/**
 * DayOfMonthRange is an inclusive range of days of the month beginning at 1
 *
 * @schema AlertmanagerConfigSpecMuteTimeIntervalsTimeIntervalsDaysOfMonth
 */
export interface AlertmanagerConfigSpecMuteTimeIntervalsTimeIntervalsDaysOfMonth {
  /**
   * End of the inclusive range
   *
   * @schema AlertmanagerConfigSpecMuteTimeIntervalsTimeIntervalsDaysOfMonth#end
   */
  readonly end?: number;

  /**
   * Start of the inclusive range
   *
   * @schema AlertmanagerConfigSpecMuteTimeIntervalsTimeIntervalsDaysOfMonth#start
   */
  readonly start?: number;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecMuteTimeIntervalsTimeIntervalsDaysOfMonth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecMuteTimeIntervalsTimeIntervalsDaysOfMonth(obj: AlertmanagerConfigSpecMuteTimeIntervalsTimeIntervalsDaysOfMonth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'end': obj.end,
    'start': obj.start,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TimeRange defines a start and end time in 24hr format
 *
 * @schema AlertmanagerConfigSpecMuteTimeIntervalsTimeIntervalsTimes
 */
export interface AlertmanagerConfigSpecMuteTimeIntervalsTimeIntervalsTimes {
  /**
   * EndTime is the end time in 24hr format.
   *
   * @schema AlertmanagerConfigSpecMuteTimeIntervalsTimeIntervalsTimes#endTime
   */
  readonly endTime?: string;

  /**
   * StartTime is the start time in 24hr format.
   *
   * @schema AlertmanagerConfigSpecMuteTimeIntervalsTimeIntervalsTimes#startTime
   */
  readonly startTime?: string;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecMuteTimeIntervalsTimeIntervalsTimes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecMuteTimeIntervalsTimeIntervalsTimes(obj: AlertmanagerConfigSpecMuteTimeIntervalsTimeIntervalsTimes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'endTime': obj.endTime,
    'startTime': obj.startTime,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The secret's key that contains the Discord webhook URL.
 * The secret needs to be in the same namespace as the AlertmanagerConfig
 * object and accessible by the Prometheus Operator.
 *
 * @schema AlertmanagerConfigSpecReceiversDiscordConfigsApiUrl
 */
export interface AlertmanagerConfigSpecReceiversDiscordConfigsApiUrl {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsApiUrl#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsApiUrl#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsApiUrl#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversDiscordConfigsApiUrl' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversDiscordConfigsApiUrl(obj: AlertmanagerConfigSpecReceiversDiscordConfigsApiUrl | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTP client configuration.
 *
 * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfig
 */
export interface AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfig {
  /**
   * Authorization header configuration for the client.
   * This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfig#authorization
   */
  readonly authorization?: AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigAuthorization;

  /**
   * BasicAuth for the client.
   * This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfig#basicAuth
   */
  readonly basicAuth?: AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuth;

  /**
   * The secret's key that contains the bearer token to be used by the client
   * for authentication.
   * The secret needs to be in the same namespace as the AlertmanagerConfig
   * object and accessible by the Prometheus Operator.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfig#bearerTokenSecret
   */
  readonly bearerTokenSecret?: AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBearerTokenSecret;

  /**
   * FollowRedirects specifies whether the client should follow HTTP 3xx redirects.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfig#followRedirects
   */
  readonly followRedirects?: boolean;

  /**
   * OAuth2 client credentials used to fetch a token for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfig#oauth2
   */
  readonly oauth2?: AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2;

  /**
   * Optional proxy URL.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfig#proxyURL
   */
  readonly proxyUrl?: string;

  /**
   * TLS configuration for the client.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfig#tlsConfig
   */
  readonly tlsConfig?: AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfig;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfig(obj: AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authorization': toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigAuthorization(obj.authorization),
    'basicAuth': toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuth(obj.basicAuth),
    'bearerTokenSecret': toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBearerTokenSecret(obj.bearerTokenSecret),
    'followRedirects': obj.followRedirects,
    'oauth2': toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2(obj.oauth2),
    'proxyURL': obj.proxyUrl,
    'tlsConfig': toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfig(obj.tlsConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The secret's key that contains the password to use for authentication.
 * The secret needs to be in the same namespace as the AlertmanagerConfig
 * object and accessible by the Prometheus Operator.
 *
 * @schema AlertmanagerConfigSpecReceiversEmailConfigsAuthPassword
 */
export interface AlertmanagerConfigSpecReceiversEmailConfigsAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigsAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigsAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigsAuthPassword#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversEmailConfigsAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversEmailConfigsAuthPassword(obj: AlertmanagerConfigSpecReceiversEmailConfigsAuthPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The secret's key that contains the CRAM-MD5 secret.
 * The secret needs to be in the same namespace as the AlertmanagerConfig
 * object and accessible by the Prometheus Operator.
 *
 * @schema AlertmanagerConfigSpecReceiversEmailConfigsAuthSecret
 */
export interface AlertmanagerConfigSpecReceiversEmailConfigsAuthSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigsAuthSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigsAuthSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigsAuthSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversEmailConfigsAuthSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversEmailConfigsAuthSecret(obj: AlertmanagerConfigSpecReceiversEmailConfigsAuthSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * KeyValue defines a (key, value) tuple.
 *
 * @schema AlertmanagerConfigSpecReceiversEmailConfigsHeaders
 */
export interface AlertmanagerConfigSpecReceiversEmailConfigsHeaders {
  /**
   * Key of the tuple.
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigsHeaders#key
   */
  readonly key: string;

  /**
   * Value of the tuple.
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigsHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversEmailConfigsHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversEmailConfigsHeaders(obj: AlertmanagerConfigSpecReceiversEmailConfigsHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLS configuration
 *
 * @schema AlertmanagerConfigSpecReceiversEmailConfigsTlsConfig
 */
export interface AlertmanagerConfigSpecReceiversEmailConfigsTlsConfig {
  /**
   * Certificate authority used when verifying server certificates.
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigsTlsConfig#ca
   */
  readonly ca?: AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCa;

  /**
   * Client certificate to present when doing client-authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigsTlsConfig#cert
   */
  readonly cert?: AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCert;

  /**
   * Disable target certificate validation.
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigsTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigsTlsConfig#keySecret
   */
  readonly keySecret?: AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigsTlsConfig#serverName
   */
  readonly serverName?: string;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversEmailConfigsTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversEmailConfigsTlsConfig(obj: AlertmanagerConfigSpecReceiversEmailConfigsTlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ca': toJson_AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCa(obj.ca),
    'cert': toJson_AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCert(obj.cert),
    'insecureSkipVerify': obj.insecureSkipVerify,
    'keySecret': toJson_AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigKeySecret(obj.keySecret),
    'serverName': obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTP client configuration.
 *
 * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfig
 */
export interface AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfig {
  /**
   * Authorization header configuration for the client.
   * This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfig#authorization
   */
  readonly authorization?: AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigAuthorization;

  /**
   * BasicAuth for the client.
   * This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfig#basicAuth
   */
  readonly basicAuth?: AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuth;

  /**
   * The secret's key that contains the bearer token to be used by the client
   * for authentication.
   * The secret needs to be in the same namespace as the AlertmanagerConfig
   * object and accessible by the Prometheus Operator.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfig#bearerTokenSecret
   */
  readonly bearerTokenSecret?: AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBearerTokenSecret;

  /**
   * FollowRedirects specifies whether the client should follow HTTP 3xx redirects.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfig#followRedirects
   */
  readonly followRedirects?: boolean;

  /**
   * OAuth2 client credentials used to fetch a token for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfig#oauth2
   */
  readonly oauth2?: AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2;

  /**
   * Optional proxy URL.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfig#proxyURL
   */
  readonly proxyUrl?: string;

  /**
   * TLS configuration for the client.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfig#tlsConfig
   */
  readonly tlsConfig?: AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfig;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfig(obj: AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authorization': toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigAuthorization(obj.authorization),
    'basicAuth': toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuth(obj.basicAuth),
    'bearerTokenSecret': toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBearerTokenSecret(obj.bearerTokenSecret),
    'followRedirects': obj.followRedirects,
    'oauth2': toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2(obj.oauth2),
    'proxyURL': obj.proxyUrl,
    'tlsConfig': toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfig(obj.tlsConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * MSTeams webhook URL.
 *
 * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsWebhookUrl
 */
export interface AlertmanagerConfigSpecReceiversMsteamsConfigsWebhookUrl {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsWebhookUrl#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsWebhookUrl#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsWebhookUrl#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversMsteamsConfigsWebhookUrl' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsWebhookUrl(obj: AlertmanagerConfigSpecReceiversMsteamsConfigsWebhookUrl | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The secret's key that contains the OpsGenie API key.
 * The secret needs to be in the same namespace as the AlertmanagerConfig
 * object and accessible by the Prometheus Operator.
 *
 * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsApiKey
 */
export interface AlertmanagerConfigSpecReceiversOpsgenieConfigsApiKey {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsApiKey#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsApiKey#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsApiKey#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversOpsgenieConfigsApiKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsApiKey(obj: AlertmanagerConfigSpecReceiversOpsgenieConfigsApiKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * KeyValue defines a (key, value) tuple.
 *
 * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsDetails
 */
export interface AlertmanagerConfigSpecReceiversOpsgenieConfigsDetails {
  /**
   * Key of the tuple.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsDetails#key
   */
  readonly key: string;

  /**
   * Value of the tuple.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsDetails#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversOpsgenieConfigsDetails' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsDetails(obj: AlertmanagerConfigSpecReceiversOpsgenieConfigsDetails | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTP client configuration.
 *
 * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfig
 */
export interface AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfig {
  /**
   * Authorization header configuration for the client.
   * This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfig#authorization
   */
  readonly authorization?: AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigAuthorization;

  /**
   * BasicAuth for the client.
   * This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfig#basicAuth
   */
  readonly basicAuth?: AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBasicAuth;

  /**
   * The secret's key that contains the bearer token to be used by the client
   * for authentication.
   * The secret needs to be in the same namespace as the AlertmanagerConfig
   * object and accessible by the Prometheus Operator.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfig#bearerTokenSecret
   */
  readonly bearerTokenSecret?: AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBearerTokenSecret;

  /**
   * FollowRedirects specifies whether the client should follow HTTP 3xx redirects.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfig#followRedirects
   */
  readonly followRedirects?: boolean;

  /**
   * OAuth2 client credentials used to fetch a token for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfig#oauth2
   */
  readonly oauth2?: AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2;

  /**
   * Optional proxy URL.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfig#proxyURL
   */
  readonly proxyUrl?: string;

  /**
   * TLS configuration for the client.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfig#tlsConfig
   */
  readonly tlsConfig?: AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfig;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfig(obj: AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authorization': toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigAuthorization(obj.authorization),
    'basicAuth': toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBasicAuth(obj.basicAuth),
    'bearerTokenSecret': toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBearerTokenSecret(obj.bearerTokenSecret),
    'followRedirects': obj.followRedirects,
    'oauth2': toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2(obj.oauth2),
    'proxyURL': obj.proxyUrl,
    'tlsConfig': toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfig(obj.tlsConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * OpsGenieConfigResponder defines a responder to an incident.
 * One of `id`, `name` or `username` has to be defined.
 *
 * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsResponders
 */
export interface AlertmanagerConfigSpecReceiversOpsgenieConfigsResponders {
  /**
   * ID of the responder.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsResponders#id
   */
  readonly id?: string;

  /**
   * Name of the responder.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsResponders#name
   */
  readonly name?: string;

  /**
   * Type of responder.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsResponders#type
   */
  readonly type: string;

  /**
   * Username of the responder.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsResponders#username
   */
  readonly username?: string;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversOpsgenieConfigsResponders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsResponders(obj: AlertmanagerConfigSpecReceiversOpsgenieConfigsResponders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'id': obj.id,
    'name': obj.name,
    'type': obj.type,
    'username': obj.username,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * KeyValue defines a (key, value) tuple.
 *
 * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsDetails
 */
export interface AlertmanagerConfigSpecReceiversPagerdutyConfigsDetails {
  /**
   * Key of the tuple.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsDetails#key
   */
  readonly key: string;

  /**
   * Value of the tuple.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsDetails#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPagerdutyConfigsDetails' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsDetails(obj: AlertmanagerConfigSpecReceiversPagerdutyConfigsDetails | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTP client configuration.
 *
 * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfig
 */
export interface AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfig {
  /**
   * Authorization header configuration for the client.
   * This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfig#authorization
   */
  readonly authorization?: AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigAuthorization;

  /**
   * BasicAuth for the client.
   * This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfig#basicAuth
   */
  readonly basicAuth?: AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBasicAuth;

  /**
   * The secret's key that contains the bearer token to be used by the client
   * for authentication.
   * The secret needs to be in the same namespace as the AlertmanagerConfig
   * object and accessible by the Prometheus Operator.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfig#bearerTokenSecret
   */
  readonly bearerTokenSecret?: AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBearerTokenSecret;

  /**
   * FollowRedirects specifies whether the client should follow HTTP 3xx redirects.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfig#followRedirects
   */
  readonly followRedirects?: boolean;

  /**
   * OAuth2 client credentials used to fetch a token for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfig#oauth2
   */
  readonly oauth2?: AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2;

  /**
   * Optional proxy URL.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfig#proxyURL
   */
  readonly proxyUrl?: string;

  /**
   * TLS configuration for the client.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfig#tlsConfig
   */
  readonly tlsConfig?: AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfig;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfig(obj: AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authorization': toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigAuthorization(obj.authorization),
    'basicAuth': toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBasicAuth(obj.basicAuth),
    'bearerTokenSecret': toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBearerTokenSecret(obj.bearerTokenSecret),
    'followRedirects': obj.followRedirects,
    'oauth2': toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2(obj.oauth2),
    'proxyURL': obj.proxyUrl,
    'tlsConfig': toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfig(obj.tlsConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PagerDutyImageConfig attaches images to an incident
 *
 * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsPagerDutyImageConfigs
 */
export interface AlertmanagerConfigSpecReceiversPagerdutyConfigsPagerDutyImageConfigs {
  /**
   * Alt is the optional alternative text for the image.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsPagerDutyImageConfigs#alt
   */
  readonly alt?: string;

  /**
   * Optional URL; makes the image a clickable link.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsPagerDutyImageConfigs#href
   */
  readonly href?: string;

  /**
   * Src of the image being attached to the incident
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsPagerDutyImageConfigs#src
   */
  readonly src?: string;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPagerdutyConfigsPagerDutyImageConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsPagerDutyImageConfigs(obj: AlertmanagerConfigSpecReceiversPagerdutyConfigsPagerDutyImageConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alt': obj.alt,
    'href': obj.href,
    'src': obj.src,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PagerDutyLinkConfig attaches text links to an incident
 *
 * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsPagerDutyLinkConfigs
 */
export interface AlertmanagerConfigSpecReceiversPagerdutyConfigsPagerDutyLinkConfigs {
  /**
   * Text that describes the purpose of the link, and can be used as the link's text.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsPagerDutyLinkConfigs#alt
   */
  readonly alt?: string;

  /**
   * Href is the URL of the link to be attached
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsPagerDutyLinkConfigs#href
   */
  readonly href?: string;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPagerdutyConfigsPagerDutyLinkConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsPagerDutyLinkConfigs(obj: AlertmanagerConfigSpecReceiversPagerdutyConfigsPagerDutyLinkConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alt': obj.alt,
    'href': obj.href,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The secret's key that contains the PagerDuty integration key (when using
 * Events API v2). Either this field or `serviceKey` needs to be defined.
 * The secret needs to be in the same namespace as the AlertmanagerConfig
 * object and accessible by the Prometheus Operator.
 *
 * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsRoutingKey
 */
export interface AlertmanagerConfigSpecReceiversPagerdutyConfigsRoutingKey {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsRoutingKey#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsRoutingKey#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsRoutingKey#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPagerdutyConfigsRoutingKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsRoutingKey(obj: AlertmanagerConfigSpecReceiversPagerdutyConfigsRoutingKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The secret's key that contains the PagerDuty service key (when using
 * integration type "Prometheus"). Either this field or `routingKey` needs to
 * be defined.
 * The secret needs to be in the same namespace as the AlertmanagerConfig
 * object and accessible by the Prometheus Operator.
 *
 * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsServiceKey
 */
export interface AlertmanagerConfigSpecReceiversPagerdutyConfigsServiceKey {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsServiceKey#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsServiceKey#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsServiceKey#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPagerdutyConfigsServiceKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsServiceKey(obj: AlertmanagerConfigSpecReceiversPagerdutyConfigsServiceKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTP client configuration.
 *
 * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfig
 */
export interface AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfig {
  /**
   * Authorization header configuration for the client.
   * This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfig#authorization
   */
  readonly authorization?: AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigAuthorization;

  /**
   * BasicAuth for the client.
   * This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfig#basicAuth
   */
  readonly basicAuth?: AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBasicAuth;

  /**
   * The secret's key that contains the bearer token to be used by the client
   * for authentication.
   * The secret needs to be in the same namespace as the AlertmanagerConfig
   * object and accessible by the Prometheus Operator.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfig#bearerTokenSecret
   */
  readonly bearerTokenSecret?: AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBearerTokenSecret;

  /**
   * FollowRedirects specifies whether the client should follow HTTP 3xx redirects.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfig#followRedirects
   */
  readonly followRedirects?: boolean;

  /**
   * OAuth2 client credentials used to fetch a token for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfig#oauth2
   */
  readonly oauth2?: AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2;

  /**
   * Optional proxy URL.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfig#proxyURL
   */
  readonly proxyUrl?: string;

  /**
   * TLS configuration for the client.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfig#tlsConfig
   */
  readonly tlsConfig?: AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfig;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfig(obj: AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authorization': toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigAuthorization(obj.authorization),
    'basicAuth': toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBasicAuth(obj.basicAuth),
    'bearerTokenSecret': toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBearerTokenSecret(obj.bearerTokenSecret),
    'followRedirects': obj.followRedirects,
    'oauth2': toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2(obj.oauth2),
    'proxyURL': obj.proxyUrl,
    'tlsConfig': toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfig(obj.tlsConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The secret's key that contains the registered application's API token, see https://pushover.net/apps.
 * The secret needs to be in the same namespace as the AlertmanagerConfig
 * object and accessible by the Prometheus Operator.
 * Either `token` or `tokenFile` is required.
 *
 * @schema AlertmanagerConfigSpecReceiversPushoverConfigsToken
 */
export interface AlertmanagerConfigSpecReceiversPushoverConfigsToken {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsToken#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsToken#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsToken#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPushoverConfigsToken' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPushoverConfigsToken(obj: AlertmanagerConfigSpecReceiversPushoverConfigsToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The secret's key that contains the recipient user's user key.
 * The secret needs to be in the same namespace as the AlertmanagerConfig
 * object and accessible by the Prometheus Operator.
 * Either `userKey` or `userKeyFile` is required.
 *
 * @schema AlertmanagerConfigSpecReceiversPushoverConfigsUserKey
 */
export interface AlertmanagerConfigSpecReceiversPushoverConfigsUserKey {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsUserKey#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsUserKey#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsUserKey#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPushoverConfigsUserKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPushoverConfigsUserKey(obj: AlertmanagerConfigSpecReceiversPushoverConfigsUserKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SlackAction configures a single Slack action that is sent with each
 * notification.
 * See https://api.slack.com/docs/message-attachments#action_fields and
 * https://api.slack.com/docs/message-buttons for more information.
 *
 * @schema AlertmanagerConfigSpecReceiversSlackConfigsActions
 */
export interface AlertmanagerConfigSpecReceiversSlackConfigsActions {
  /**
   * SlackConfirmationField protect users from destructive actions or
   * particularly distinguished decisions by asking them to confirm their button
   * click one more time.
   * See https://api.slack.com/docs/interactive-message-field-guide#confirmation_fields
   * for more information.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsActions#confirm
   */
  readonly confirm?: AlertmanagerConfigSpecReceiversSlackConfigsActionsConfirm;

  /**
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsActions#name
   */
  readonly name?: string;

  /**
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsActions#style
   */
  readonly style?: string;

  /**
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsActions#text
   */
  readonly text: string;

  /**
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsActions#type
   */
  readonly type: string;

  /**
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsActions#url
   */
  readonly url?: string;

  /**
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsActions#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSlackConfigsActions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSlackConfigsActions(obj: AlertmanagerConfigSpecReceiversSlackConfigsActions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'confirm': toJson_AlertmanagerConfigSpecReceiversSlackConfigsActionsConfirm(obj.confirm),
    'name': obj.name,
    'style': obj.style,
    'text': obj.text,
    'type': obj.type,
    'url': obj.url,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The secret's key that contains the Slack webhook URL.
 * The secret needs to be in the same namespace as the AlertmanagerConfig
 * object and accessible by the Prometheus Operator.
 *
 * @schema AlertmanagerConfigSpecReceiversSlackConfigsApiUrl
 */
export interface AlertmanagerConfigSpecReceiversSlackConfigsApiUrl {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsApiUrl#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsApiUrl#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsApiUrl#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSlackConfigsApiUrl' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSlackConfigsApiUrl(obj: AlertmanagerConfigSpecReceiversSlackConfigsApiUrl | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SlackField configures a single Slack field that is sent with each notification.
 * Each field must contain a title, value, and optionally, a boolean value to indicate if the field
 * is short enough to be displayed next to other fields designated as short.
 * See https://api.slack.com/docs/message-attachments#fields for more information.
 *
 * @schema AlertmanagerConfigSpecReceiversSlackConfigsFields
 */
export interface AlertmanagerConfigSpecReceiversSlackConfigsFields {
  /**
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsFields#short
   */
  readonly short?: boolean;

  /**
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsFields#title
   */
  readonly title: string;

  /**
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsFields#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSlackConfigsFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSlackConfigsFields(obj: AlertmanagerConfigSpecReceiversSlackConfigsFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'short': obj.short,
    'title': obj.title,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTP client configuration.
 *
 * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfig
 */
export interface AlertmanagerConfigSpecReceiversSlackConfigsHttpConfig {
  /**
   * Authorization header configuration for the client.
   * This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfig#authorization
   */
  readonly authorization?: AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigAuthorization;

  /**
   * BasicAuth for the client.
   * This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfig#basicAuth
   */
  readonly basicAuth?: AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBasicAuth;

  /**
   * The secret's key that contains the bearer token to be used by the client
   * for authentication.
   * The secret needs to be in the same namespace as the AlertmanagerConfig
   * object and accessible by the Prometheus Operator.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfig#bearerTokenSecret
   */
  readonly bearerTokenSecret?: AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBearerTokenSecret;

  /**
   * FollowRedirects specifies whether the client should follow HTTP 3xx redirects.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfig#followRedirects
   */
  readonly followRedirects?: boolean;

  /**
   * OAuth2 client credentials used to fetch a token for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfig#oauth2
   */
  readonly oauth2?: AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2;

  /**
   * Optional proxy URL.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfig#proxyURL
   */
  readonly proxyUrl?: string;

  /**
   * TLS configuration for the client.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfig#tlsConfig
   */
  readonly tlsConfig?: AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfig;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSlackConfigsHttpConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfig(obj: AlertmanagerConfigSpecReceiversSlackConfigsHttpConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authorization': toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigAuthorization(obj.authorization),
    'basicAuth': toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBasicAuth(obj.basicAuth),
    'bearerTokenSecret': toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBearerTokenSecret(obj.bearerTokenSecret),
    'followRedirects': obj.followRedirects,
    'oauth2': toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2(obj.oauth2),
    'proxyURL': obj.proxyUrl,
    'tlsConfig': toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfig(obj.tlsConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTP client configuration.
 *
 * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfig
 */
export interface AlertmanagerConfigSpecReceiversSnsConfigsHttpConfig {
  /**
   * Authorization header configuration for the client.
   * This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfig#authorization
   */
  readonly authorization?: AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigAuthorization;

  /**
   * BasicAuth for the client.
   * This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfig#basicAuth
   */
  readonly basicAuth?: AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuth;

  /**
   * The secret's key that contains the bearer token to be used by the client
   * for authentication.
   * The secret needs to be in the same namespace as the AlertmanagerConfig
   * object and accessible by the Prometheus Operator.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfig#bearerTokenSecret
   */
  readonly bearerTokenSecret?: AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBearerTokenSecret;

  /**
   * FollowRedirects specifies whether the client should follow HTTP 3xx redirects.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfig#followRedirects
   */
  readonly followRedirects?: boolean;

  /**
   * OAuth2 client credentials used to fetch a token for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfig#oauth2
   */
  readonly oauth2?: AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2;

  /**
   * Optional proxy URL.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfig#proxyURL
   */
  readonly proxyUrl?: string;

  /**
   * TLS configuration for the client.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfig#tlsConfig
   */
  readonly tlsConfig?: AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfig;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSnsConfigsHttpConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfig(obj: AlertmanagerConfigSpecReceiversSnsConfigsHttpConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authorization': toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigAuthorization(obj.authorization),
    'basicAuth': toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuth(obj.basicAuth),
    'bearerTokenSecret': toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBearerTokenSecret(obj.bearerTokenSecret),
    'followRedirects': obj.followRedirects,
    'oauth2': toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2(obj.oauth2),
    'proxyURL': obj.proxyUrl,
    'tlsConfig': toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfig(obj.tlsConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configures AWS's Signature Verification 4 signing process to sign requests.
 *
 * @schema AlertmanagerConfigSpecReceiversSnsConfigsSigv4
 */
export interface AlertmanagerConfigSpecReceiversSnsConfigsSigv4 {
  /**
   * AccessKey is the AWS API key. If not specified, the environment variable
   * `AWS_ACCESS_KEY_ID` is used.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsSigv4#accessKey
   */
  readonly accessKey?: AlertmanagerConfigSpecReceiversSnsConfigsSigv4AccessKey;

  /**
   * Profile is the named AWS profile used to authenticate.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsSigv4#profile
   */
  readonly profile?: string;

  /**
   * Region is the AWS region. If blank, the region from the default credentials chain used.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsSigv4#region
   */
  readonly region?: string;

  /**
   * RoleArn is the named AWS profile used to authenticate.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsSigv4#roleArn
   */
  readonly roleArn?: string;

  /**
   * SecretKey is the AWS API secret. If not specified, the environment
   * variable `AWS_SECRET_ACCESS_KEY` is used.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsSigv4#secretKey
   */
  readonly secretKey?: AlertmanagerConfigSpecReceiversSnsConfigsSigv4SecretKey;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSnsConfigsSigv4' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSnsConfigsSigv4(obj: AlertmanagerConfigSpecReceiversSnsConfigsSigv4 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessKey': toJson_AlertmanagerConfigSpecReceiversSnsConfigsSigv4AccessKey(obj.accessKey),
    'profile': obj.profile,
    'region': obj.region,
    'roleArn': obj.roleArn,
    'secretKey': toJson_AlertmanagerConfigSpecReceiversSnsConfigsSigv4SecretKey(obj.secretKey),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Telegram bot token. It is mutually exclusive with `botTokenFile`.
 * The secret needs to be in the same namespace as the AlertmanagerConfig
 * object and accessible by the Prometheus Operator.
 *
 *
 * Either `botToken` or `botTokenFile` is required.
 *
 * @schema AlertmanagerConfigSpecReceiversTelegramConfigsBotToken
 */
export interface AlertmanagerConfigSpecReceiversTelegramConfigsBotToken {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsBotToken#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsBotToken#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsBotToken#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversTelegramConfigsBotToken' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversTelegramConfigsBotToken(obj: AlertmanagerConfigSpecReceiversTelegramConfigsBotToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTP client configuration.
 *
 * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfig
 */
export interface AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfig {
  /**
   * Authorization header configuration for the client.
   * This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfig#authorization
   */
  readonly authorization?: AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigAuthorization;

  /**
   * BasicAuth for the client.
   * This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfig#basicAuth
   */
  readonly basicAuth?: AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBasicAuth;

  /**
   * The secret's key that contains the bearer token to be used by the client
   * for authentication.
   * The secret needs to be in the same namespace as the AlertmanagerConfig
   * object and accessible by the Prometheus Operator.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfig#bearerTokenSecret
   */
  readonly bearerTokenSecret?: AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBearerTokenSecret;

  /**
   * FollowRedirects specifies whether the client should follow HTTP 3xx redirects.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfig#followRedirects
   */
  readonly followRedirects?: boolean;

  /**
   * OAuth2 client credentials used to fetch a token for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfig#oauth2
   */
  readonly oauth2?: AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2;

  /**
   * Optional proxy URL.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfig#proxyURL
   */
  readonly proxyUrl?: string;

  /**
   * TLS configuration for the client.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfig#tlsConfig
   */
  readonly tlsConfig?: AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfig;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfig(obj: AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authorization': toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigAuthorization(obj.authorization),
    'basicAuth': toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBasicAuth(obj.basicAuth),
    'bearerTokenSecret': toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBearerTokenSecret(obj.bearerTokenSecret),
    'followRedirects': obj.followRedirects,
    'oauth2': toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2(obj.oauth2),
    'proxyURL': obj.proxyUrl,
    'tlsConfig': toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfig(obj.tlsConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Parse mode for telegram message
 *
 * @schema AlertmanagerConfigSpecReceiversTelegramConfigsParseMode
 */
export enum AlertmanagerConfigSpecReceiversTelegramConfigsParseMode {
  /** MarkdownV2 */
  MARKDOWN_V2 = "MarkdownV2",
  /** Markdown */
  MARKDOWN = "Markdown",
  /** HTML */
  HTML = "HTML",
}

/**
 * The secret's key that contains the API key to use when talking to the VictorOps API.
 * The secret needs to be in the same namespace as the AlertmanagerConfig
 * object and accessible by the Prometheus Operator.
 *
 * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsApiKey
 */
export interface AlertmanagerConfigSpecReceiversVictoropsConfigsApiKey {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsApiKey#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsApiKey#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsApiKey#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversVictoropsConfigsApiKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsApiKey(obj: AlertmanagerConfigSpecReceiversVictoropsConfigsApiKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * KeyValue defines a (key, value) tuple.
 *
 * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsCustomFields
 */
export interface AlertmanagerConfigSpecReceiversVictoropsConfigsCustomFields {
  /**
   * Key of the tuple.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsCustomFields#key
   */
  readonly key: string;

  /**
   * Value of the tuple.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsCustomFields#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversVictoropsConfigsCustomFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsCustomFields(obj: AlertmanagerConfigSpecReceiversVictoropsConfigsCustomFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The HTTP client's configuration.
 *
 * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfig
 */
export interface AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfig {
  /**
   * Authorization header configuration for the client.
   * This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfig#authorization
   */
  readonly authorization?: AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigAuthorization;

  /**
   * BasicAuth for the client.
   * This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfig#basicAuth
   */
  readonly basicAuth?: AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuth;

  /**
   * The secret's key that contains the bearer token to be used by the client
   * for authentication.
   * The secret needs to be in the same namespace as the AlertmanagerConfig
   * object and accessible by the Prometheus Operator.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfig#bearerTokenSecret
   */
  readonly bearerTokenSecret?: AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBearerTokenSecret;

  /**
   * FollowRedirects specifies whether the client should follow HTTP 3xx redirects.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfig#followRedirects
   */
  readonly followRedirects?: boolean;

  /**
   * OAuth2 client credentials used to fetch a token for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfig#oauth2
   */
  readonly oauth2?: AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2;

  /**
   * Optional proxy URL.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfig#proxyURL
   */
  readonly proxyUrl?: string;

  /**
   * TLS configuration for the client.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfig#tlsConfig
   */
  readonly tlsConfig?: AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfig;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfig(obj: AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authorization': toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigAuthorization(obj.authorization),
    'basicAuth': toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuth(obj.basicAuth),
    'bearerTokenSecret': toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBearerTokenSecret(obj.bearerTokenSecret),
    'followRedirects': obj.followRedirects,
    'oauth2': toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2(obj.oauth2),
    'proxyURL': obj.proxyUrl,
    'tlsConfig': toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfig(obj.tlsConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The HTTP client's configuration.
 * You must supply the bot token via the `httpConfig.authorization` field.
 *
 * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfig
 */
export interface AlertmanagerConfigSpecReceiversWebexConfigsHttpConfig {
  /**
   * Authorization header configuration for the client.
   * This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfig#authorization
   */
  readonly authorization?: AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigAuthorization;

  /**
   * BasicAuth for the client.
   * This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfig#basicAuth
   */
  readonly basicAuth?: AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuth;

  /**
   * The secret's key that contains the bearer token to be used by the client
   * for authentication.
   * The secret needs to be in the same namespace as the AlertmanagerConfig
   * object and accessible by the Prometheus Operator.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfig#bearerTokenSecret
   */
  readonly bearerTokenSecret?: AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBearerTokenSecret;

  /**
   * FollowRedirects specifies whether the client should follow HTTP 3xx redirects.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfig#followRedirects
   */
  readonly followRedirects?: boolean;

  /**
   * OAuth2 client credentials used to fetch a token for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfig#oauth2
   */
  readonly oauth2?: AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2;

  /**
   * Optional proxy URL.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfig#proxyURL
   */
  readonly proxyUrl?: string;

  /**
   * TLS configuration for the client.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfig#tlsConfig
   */
  readonly tlsConfig?: AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfig;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebexConfigsHttpConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfig(obj: AlertmanagerConfigSpecReceiversWebexConfigsHttpConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authorization': toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigAuthorization(obj.authorization),
    'basicAuth': toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuth(obj.basicAuth),
    'bearerTokenSecret': toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBearerTokenSecret(obj.bearerTokenSecret),
    'followRedirects': obj.followRedirects,
    'oauth2': toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2(obj.oauth2),
    'proxyURL': obj.proxyUrl,
    'tlsConfig': toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfig(obj.tlsConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTP client configuration.
 *
 * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfig
 */
export interface AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfig {
  /**
   * Authorization header configuration for the client.
   * This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfig#authorization
   */
  readonly authorization?: AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigAuthorization;

  /**
   * BasicAuth for the client.
   * This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfig#basicAuth
   */
  readonly basicAuth?: AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBasicAuth;

  /**
   * The secret's key that contains the bearer token to be used by the client
   * for authentication.
   * The secret needs to be in the same namespace as the AlertmanagerConfig
   * object and accessible by the Prometheus Operator.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfig#bearerTokenSecret
   */
  readonly bearerTokenSecret?: AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBearerTokenSecret;

  /**
   * FollowRedirects specifies whether the client should follow HTTP 3xx redirects.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfig#followRedirects
   */
  readonly followRedirects?: boolean;

  /**
   * OAuth2 client credentials used to fetch a token for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfig#oauth2
   */
  readonly oauth2?: AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2;

  /**
   * Optional proxy URL.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfig#proxyURL
   */
  readonly proxyUrl?: string;

  /**
   * TLS configuration for the client.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfig#tlsConfig
   */
  readonly tlsConfig?: AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfig;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfig(obj: AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authorization': toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigAuthorization(obj.authorization),
    'basicAuth': toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBasicAuth(obj.basicAuth),
    'bearerTokenSecret': toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBearerTokenSecret(obj.bearerTokenSecret),
    'followRedirects': obj.followRedirects,
    'oauth2': toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2(obj.oauth2),
    'proxyURL': obj.proxyUrl,
    'tlsConfig': toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfig(obj.tlsConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The secret's key that contains the webhook URL to send HTTP requests to.
 * `urlSecret` takes precedence over `url`. One of `urlSecret` and `url`
 * should be defined.
 * The secret needs to be in the same namespace as the AlertmanagerConfig
 * object and accessible by the Prometheus Operator.
 *
 * @schema AlertmanagerConfigSpecReceiversWebhookConfigsUrlSecret
 */
export interface AlertmanagerConfigSpecReceiversWebhookConfigsUrlSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsUrlSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsUrlSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsUrlSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebhookConfigsUrlSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebhookConfigsUrlSecret(obj: AlertmanagerConfigSpecReceiversWebhookConfigsUrlSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The secret's key that contains the WeChat API key.
 * The secret needs to be in the same namespace as the AlertmanagerConfig
 * object and accessible by the Prometheus Operator.
 *
 * @schema AlertmanagerConfigSpecReceiversWechatConfigsApiSecret
 */
export interface AlertmanagerConfigSpecReceiversWechatConfigsApiSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsApiSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsApiSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsApiSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWechatConfigsApiSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWechatConfigsApiSecret(obj: AlertmanagerConfigSpecReceiversWechatConfigsApiSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTP client configuration.
 *
 * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfig
 */
export interface AlertmanagerConfigSpecReceiversWechatConfigsHttpConfig {
  /**
   * Authorization header configuration for the client.
   * This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfig#authorization
   */
  readonly authorization?: AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigAuthorization;

  /**
   * BasicAuth for the client.
   * This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfig#basicAuth
   */
  readonly basicAuth?: AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuth;

  /**
   * The secret's key that contains the bearer token to be used by the client
   * for authentication.
   * The secret needs to be in the same namespace as the AlertmanagerConfig
   * object and accessible by the Prometheus Operator.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfig#bearerTokenSecret
   */
  readonly bearerTokenSecret?: AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBearerTokenSecret;

  /**
   * FollowRedirects specifies whether the client should follow HTTP 3xx redirects.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfig#followRedirects
   */
  readonly followRedirects?: boolean;

  /**
   * OAuth2 client credentials used to fetch a token for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfig#oauth2
   */
  readonly oauth2?: AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2;

  /**
   * Optional proxy URL.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfig#proxyURL
   */
  readonly proxyUrl?: string;

  /**
   * TLS configuration for the client.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfig#tlsConfig
   */
  readonly tlsConfig?: AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfig;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWechatConfigsHttpConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfig(obj: AlertmanagerConfigSpecReceiversWechatConfigsHttpConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authorization': toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigAuthorization(obj.authorization),
    'basicAuth': toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuth(obj.basicAuth),
    'bearerTokenSecret': toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBearerTokenSecret(obj.bearerTokenSecret),
    'followRedirects': obj.followRedirects,
    'oauth2': toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2(obj.oauth2),
    'proxyURL': obj.proxyUrl,
    'tlsConfig': toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfig(obj.tlsConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Match operation available with AlertManager >= v0.22.0 and
 * takes precedence over Regex (deprecated) if non-empty.
 *
 * @schema AlertmanagerConfigSpecRouteMatchersMatchType
 */
export enum AlertmanagerConfigSpecRouteMatchersMatchType {
  /** != */
  VALUE_NOT_EQUALS_TO = "!=",
  /** = */
  VALUE_EQUALS = "=",
  /** =~ */
  VALUE_EQUAL_TILDE = "=~",
  /** !~ */
  VALUE_NEGATION_TILDE = "!~",
}

/**
 * Authorization header configuration for the client.
 * This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
 *
 * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigAuthorization
 */
export interface AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigAuthorization {
  /**
   * Selects a key of a Secret in the namespace that contains the credentials for authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigAuthorization#credentials
   */
  readonly credentials?: AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigAuthorizationCredentials;

  /**
   * Defines the authentication type. The value is case-insensitive.
   *
   *
   * "Basic" is not a supported value.
   *
   *
   * Default: "Bearer"
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigAuthorization#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigAuthorization' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigAuthorization(obj: AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigAuthorization | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentials': toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigAuthorizationCredentials(obj.credentials),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BasicAuth for the client.
 * This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
 *
 * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuth
 */
export interface AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuth {
  /**
   * `password` specifies a key of a Secret containing the password for
   * authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuth#password
   */
  readonly password?: AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuthPassword;

  /**
   * `username` specifies a key of a Secret containing the username for
   * authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuth#username
   */
  readonly username?: AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuthUsername;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuth(obj: AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuthPassword(obj.password),
    'username': toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuthUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The secret's key that contains the bearer token to be used by the client
 * for authentication.
 * The secret needs to be in the same namespace as the AlertmanagerConfig
 * object and accessible by the Prometheus Operator.
 *
 * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBearerTokenSecret
 */
export interface AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBearerTokenSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBearerTokenSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBearerTokenSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBearerTokenSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBearerTokenSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBearerTokenSecret(obj: AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBearerTokenSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * OAuth2 client credentials used to fetch a token for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2
 */
export interface AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2 {
  /**
   * `clientId` specifies a key of a Secret or ConfigMap containing the
   * OAuth2 client's ID.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2#clientId
   */
  readonly clientId: AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientId;

  /**
   * `clientSecret` specifies a key of a Secret containing the OAuth2
   * client's secret.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2#clientSecret
   */
  readonly clientSecret: AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientSecret;

  /**
   * `endpointParams` configures the HTTP parameters to append to the token
   * URL.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2#endpointParams
   */
  readonly endpointParams?: { [key: string]: string };

  /**
   * `scopes` defines the OAuth2 scopes used for the token request.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2#scopes
   */
  readonly scopes?: string[];

  /**
   * `tokenURL` configures the URL to fetch the token from.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2#tokenUrl
   */
  readonly tokenUrl: string;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2(obj: AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientId': toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientId(obj.clientId),
    'clientSecret': toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientSecret(obj.clientSecret),
    'endpointParams': ((obj.endpointParams) === undefined) ? undefined : (Object.entries(obj.endpointParams).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'scopes': obj.scopes?.map(y => y),
    'tokenUrl': obj.tokenUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLS configuration for the client.
 *
 * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfig
 */
export interface AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfig {
  /**
   * Certificate authority used when verifying server certificates.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfig#ca
   */
  readonly ca?: AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCa;

  /**
   * Client certificate to present when doing client-authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfig#cert
   */
  readonly cert?: AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCert;

  /**
   * Disable target certificate validation.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfig#keySecret
   */
  readonly keySecret?: AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfig#serverName
   */
  readonly serverName?: string;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfig(obj: AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ca': toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCa(obj.ca),
    'cert': toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCert(obj.cert),
    'insecureSkipVerify': obj.insecureSkipVerify,
    'keySecret': toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigKeySecret(obj.keySecret),
    'serverName': obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Certificate authority used when verifying server certificates.
 *
 * @schema AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCa
 */
export interface AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCa#configMap
   */
  readonly configMap?: AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCa#secret
   */
  readonly secret?: AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCaSecret;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCa(obj: AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCaConfigMap(obj.configMap),
    'secret': toJson_AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Client certificate to present when doing client-authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCert
 */
export interface AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCert#configMap
   */
  readonly configMap?: AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCert#secret
   */
  readonly secret?: AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCertSecret;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCert(obj: AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCertConfigMap(obj.configMap),
    'secret': toJson_AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigKeySecret
 */
export interface AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigKeySecret(obj: AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Authorization header configuration for the client.
 * This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
 *
 * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigAuthorization
 */
export interface AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigAuthorization {
  /**
   * Selects a key of a Secret in the namespace that contains the credentials for authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigAuthorization#credentials
   */
  readonly credentials?: AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigAuthorizationCredentials;

  /**
   * Defines the authentication type. The value is case-insensitive.
   *
   *
   * "Basic" is not a supported value.
   *
   *
   * Default: "Bearer"
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigAuthorization#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigAuthorization' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigAuthorization(obj: AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigAuthorization | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentials': toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigAuthorizationCredentials(obj.credentials),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BasicAuth for the client.
 * This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
 *
 * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuth
 */
export interface AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuth {
  /**
   * `password` specifies a key of a Secret containing the password for
   * authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuth#password
   */
  readonly password?: AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuthPassword;

  /**
   * `username` specifies a key of a Secret containing the username for
   * authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuth#username
   */
  readonly username?: AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuthUsername;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuth(obj: AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuthPassword(obj.password),
    'username': toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuthUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The secret's key that contains the bearer token to be used by the client
 * for authentication.
 * The secret needs to be in the same namespace as the AlertmanagerConfig
 * object and accessible by the Prometheus Operator.
 *
 * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBearerTokenSecret
 */
export interface AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBearerTokenSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBearerTokenSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBearerTokenSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBearerTokenSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBearerTokenSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBearerTokenSecret(obj: AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBearerTokenSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * OAuth2 client credentials used to fetch a token for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2
 */
export interface AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2 {
  /**
   * `clientId` specifies a key of a Secret or ConfigMap containing the
   * OAuth2 client's ID.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2#clientId
   */
  readonly clientId: AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientId;

  /**
   * `clientSecret` specifies a key of a Secret containing the OAuth2
   * client's secret.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2#clientSecret
   */
  readonly clientSecret: AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientSecret;

  /**
   * `endpointParams` configures the HTTP parameters to append to the token
   * URL.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2#endpointParams
   */
  readonly endpointParams?: { [key: string]: string };

  /**
   * `scopes` defines the OAuth2 scopes used for the token request.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2#scopes
   */
  readonly scopes?: string[];

  /**
   * `tokenURL` configures the URL to fetch the token from.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2#tokenUrl
   */
  readonly tokenUrl: string;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2(obj: AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientId': toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientId(obj.clientId),
    'clientSecret': toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientSecret(obj.clientSecret),
    'endpointParams': ((obj.endpointParams) === undefined) ? undefined : (Object.entries(obj.endpointParams).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'scopes': obj.scopes?.map(y => y),
    'tokenUrl': obj.tokenUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLS configuration for the client.
 *
 * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfig
 */
export interface AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfig {
  /**
   * Certificate authority used when verifying server certificates.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfig#ca
   */
  readonly ca?: AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCa;

  /**
   * Client certificate to present when doing client-authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfig#cert
   */
  readonly cert?: AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCert;

  /**
   * Disable target certificate validation.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfig#keySecret
   */
  readonly keySecret?: AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfig#serverName
   */
  readonly serverName?: string;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfig(obj: AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ca': toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCa(obj.ca),
    'cert': toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCert(obj.cert),
    'insecureSkipVerify': obj.insecureSkipVerify,
    'keySecret': toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigKeySecret(obj.keySecret),
    'serverName': obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Authorization header configuration for the client.
 * This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
 *
 * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigAuthorization
 */
export interface AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigAuthorization {
  /**
   * Selects a key of a Secret in the namespace that contains the credentials for authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigAuthorization#credentials
   */
  readonly credentials?: AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigAuthorizationCredentials;

  /**
   * Defines the authentication type. The value is case-insensitive.
   *
   *
   * "Basic" is not a supported value.
   *
   *
   * Default: "Bearer"
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigAuthorization#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigAuthorization' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigAuthorization(obj: AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigAuthorization | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentials': toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigAuthorizationCredentials(obj.credentials),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BasicAuth for the client.
 * This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
 *
 * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBasicAuth
 */
export interface AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBasicAuth {
  /**
   * `password` specifies a key of a Secret containing the password for
   * authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBasicAuth#password
   */
  readonly password?: AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBasicAuthPassword;

  /**
   * `username` specifies a key of a Secret containing the username for
   * authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBasicAuth#username
   */
  readonly username?: AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBasicAuthUsername;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBasicAuth(obj: AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBasicAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBasicAuthPassword(obj.password),
    'username': toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBasicAuthUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The secret's key that contains the bearer token to be used by the client
 * for authentication.
 * The secret needs to be in the same namespace as the AlertmanagerConfig
 * object and accessible by the Prometheus Operator.
 *
 * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBearerTokenSecret
 */
export interface AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBearerTokenSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBearerTokenSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBearerTokenSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBearerTokenSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBearerTokenSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBearerTokenSecret(obj: AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBearerTokenSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * OAuth2 client credentials used to fetch a token for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2
 */
export interface AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2 {
  /**
   * `clientId` specifies a key of a Secret or ConfigMap containing the
   * OAuth2 client's ID.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2#clientId
   */
  readonly clientId: AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientId;

  /**
   * `clientSecret` specifies a key of a Secret containing the OAuth2
   * client's secret.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2#clientSecret
   */
  readonly clientSecret: AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientSecret;

  /**
   * `endpointParams` configures the HTTP parameters to append to the token
   * URL.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2#endpointParams
   */
  readonly endpointParams?: { [key: string]: string };

  /**
   * `scopes` defines the OAuth2 scopes used for the token request.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2#scopes
   */
  readonly scopes?: string[];

  /**
   * `tokenURL` configures the URL to fetch the token from.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2#tokenUrl
   */
  readonly tokenUrl: string;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2(obj: AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientId': toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientId(obj.clientId),
    'clientSecret': toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientSecret(obj.clientSecret),
    'endpointParams': ((obj.endpointParams) === undefined) ? undefined : (Object.entries(obj.endpointParams).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'scopes': obj.scopes?.map(y => y),
    'tokenUrl': obj.tokenUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLS configuration for the client.
 *
 * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfig
 */
export interface AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfig {
  /**
   * Certificate authority used when verifying server certificates.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfig#ca
   */
  readonly ca?: AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCa;

  /**
   * Client certificate to present when doing client-authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfig#cert
   */
  readonly cert?: AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCert;

  /**
   * Disable target certificate validation.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfig#keySecret
   */
  readonly keySecret?: AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfig#serverName
   */
  readonly serverName?: string;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfig(obj: AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ca': toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCa(obj.ca),
    'cert': toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCert(obj.cert),
    'insecureSkipVerify': obj.insecureSkipVerify,
    'keySecret': toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigKeySecret(obj.keySecret),
    'serverName': obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Authorization header configuration for the client.
 * This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
 *
 * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigAuthorization
 */
export interface AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigAuthorization {
  /**
   * Selects a key of a Secret in the namespace that contains the credentials for authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigAuthorization#credentials
   */
  readonly credentials?: AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigAuthorizationCredentials;

  /**
   * Defines the authentication type. The value is case-insensitive.
   *
   *
   * "Basic" is not a supported value.
   *
   *
   * Default: "Bearer"
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigAuthorization#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigAuthorization' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigAuthorization(obj: AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigAuthorization | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentials': toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigAuthorizationCredentials(obj.credentials),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BasicAuth for the client.
 * This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
 *
 * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBasicAuth
 */
export interface AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBasicAuth {
  /**
   * `password` specifies a key of a Secret containing the password for
   * authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBasicAuth#password
   */
  readonly password?: AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBasicAuthPassword;

  /**
   * `username` specifies a key of a Secret containing the username for
   * authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBasicAuth#username
   */
  readonly username?: AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBasicAuthUsername;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBasicAuth(obj: AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBasicAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBasicAuthPassword(obj.password),
    'username': toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBasicAuthUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The secret's key that contains the bearer token to be used by the client
 * for authentication.
 * The secret needs to be in the same namespace as the AlertmanagerConfig
 * object and accessible by the Prometheus Operator.
 *
 * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBearerTokenSecret
 */
export interface AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBearerTokenSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBearerTokenSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBearerTokenSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBearerTokenSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBearerTokenSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBearerTokenSecret(obj: AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBearerTokenSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * OAuth2 client credentials used to fetch a token for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2
 */
export interface AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2 {
  /**
   * `clientId` specifies a key of a Secret or ConfigMap containing the
   * OAuth2 client's ID.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2#clientId
   */
  readonly clientId: AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientId;

  /**
   * `clientSecret` specifies a key of a Secret containing the OAuth2
   * client's secret.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2#clientSecret
   */
  readonly clientSecret: AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientSecret;

  /**
   * `endpointParams` configures the HTTP parameters to append to the token
   * URL.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2#endpointParams
   */
  readonly endpointParams?: { [key: string]: string };

  /**
   * `scopes` defines the OAuth2 scopes used for the token request.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2#scopes
   */
  readonly scopes?: string[];

  /**
   * `tokenURL` configures the URL to fetch the token from.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2#tokenUrl
   */
  readonly tokenUrl: string;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2(obj: AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientId': toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientId(obj.clientId),
    'clientSecret': toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientSecret(obj.clientSecret),
    'endpointParams': ((obj.endpointParams) === undefined) ? undefined : (Object.entries(obj.endpointParams).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'scopes': obj.scopes?.map(y => y),
    'tokenUrl': obj.tokenUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLS configuration for the client.
 *
 * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfig
 */
export interface AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfig {
  /**
   * Certificate authority used when verifying server certificates.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfig#ca
   */
  readonly ca?: AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCa;

  /**
   * Client certificate to present when doing client-authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfig#cert
   */
  readonly cert?: AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCert;

  /**
   * Disable target certificate validation.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfig#keySecret
   */
  readonly keySecret?: AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfig#serverName
   */
  readonly serverName?: string;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfig(obj: AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ca': toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCa(obj.ca),
    'cert': toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCert(obj.cert),
    'insecureSkipVerify': obj.insecureSkipVerify,
    'keySecret': toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigKeySecret(obj.keySecret),
    'serverName': obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Authorization header configuration for the client.
 * This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
 *
 * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigAuthorization
 */
export interface AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigAuthorization {
  /**
   * Selects a key of a Secret in the namespace that contains the credentials for authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigAuthorization#credentials
   */
  readonly credentials?: AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigAuthorizationCredentials;

  /**
   * Defines the authentication type. The value is case-insensitive.
   *
   *
   * "Basic" is not a supported value.
   *
   *
   * Default: "Bearer"
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigAuthorization#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigAuthorization' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigAuthorization(obj: AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigAuthorization | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentials': toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigAuthorizationCredentials(obj.credentials),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BasicAuth for the client.
 * This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
 *
 * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBasicAuth
 */
export interface AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBasicAuth {
  /**
   * `password` specifies a key of a Secret containing the password for
   * authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBasicAuth#password
   */
  readonly password?: AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBasicAuthPassword;

  /**
   * `username` specifies a key of a Secret containing the username for
   * authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBasicAuth#username
   */
  readonly username?: AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBasicAuthUsername;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBasicAuth(obj: AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBasicAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBasicAuthPassword(obj.password),
    'username': toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBasicAuthUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The secret's key that contains the bearer token to be used by the client
 * for authentication.
 * The secret needs to be in the same namespace as the AlertmanagerConfig
 * object and accessible by the Prometheus Operator.
 *
 * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBearerTokenSecret
 */
export interface AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBearerTokenSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBearerTokenSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBearerTokenSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBearerTokenSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBearerTokenSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBearerTokenSecret(obj: AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBearerTokenSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * OAuth2 client credentials used to fetch a token for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2
 */
export interface AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2 {
  /**
   * `clientId` specifies a key of a Secret or ConfigMap containing the
   * OAuth2 client's ID.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2#clientId
   */
  readonly clientId: AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientId;

  /**
   * `clientSecret` specifies a key of a Secret containing the OAuth2
   * client's secret.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2#clientSecret
   */
  readonly clientSecret: AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientSecret;

  /**
   * `endpointParams` configures the HTTP parameters to append to the token
   * URL.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2#endpointParams
   */
  readonly endpointParams?: { [key: string]: string };

  /**
   * `scopes` defines the OAuth2 scopes used for the token request.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2#scopes
   */
  readonly scopes?: string[];

  /**
   * `tokenURL` configures the URL to fetch the token from.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2#tokenUrl
   */
  readonly tokenUrl: string;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2(obj: AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientId': toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientId(obj.clientId),
    'clientSecret': toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientSecret(obj.clientSecret),
    'endpointParams': ((obj.endpointParams) === undefined) ? undefined : (Object.entries(obj.endpointParams).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'scopes': obj.scopes?.map(y => y),
    'tokenUrl': obj.tokenUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLS configuration for the client.
 *
 * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfig
 */
export interface AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfig {
  /**
   * Certificate authority used when verifying server certificates.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfig#ca
   */
  readonly ca?: AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCa;

  /**
   * Client certificate to present when doing client-authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfig#cert
   */
  readonly cert?: AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCert;

  /**
   * Disable target certificate validation.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfig#keySecret
   */
  readonly keySecret?: AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfig#serverName
   */
  readonly serverName?: string;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfig(obj: AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ca': toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCa(obj.ca),
    'cert': toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCert(obj.cert),
    'insecureSkipVerify': obj.insecureSkipVerify,
    'keySecret': toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigKeySecret(obj.keySecret),
    'serverName': obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SlackConfirmationField protect users from destructive actions or
 * particularly distinguished decisions by asking them to confirm their button
 * click one more time.
 * See https://api.slack.com/docs/interactive-message-field-guide#confirmation_fields
 * for more information.
 *
 * @schema AlertmanagerConfigSpecReceiversSlackConfigsActionsConfirm
 */
export interface AlertmanagerConfigSpecReceiversSlackConfigsActionsConfirm {
  /**
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsActionsConfirm#dismissText
   */
  readonly dismissText?: string;

  /**
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsActionsConfirm#okText
   */
  readonly okText?: string;

  /**
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsActionsConfirm#text
   */
  readonly text: string;

  /**
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsActionsConfirm#title
   */
  readonly title?: string;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSlackConfigsActionsConfirm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSlackConfigsActionsConfirm(obj: AlertmanagerConfigSpecReceiversSlackConfigsActionsConfirm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dismissText': obj.dismissText,
    'okText': obj.okText,
    'text': obj.text,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Authorization header configuration for the client.
 * This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
 *
 * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigAuthorization
 */
export interface AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigAuthorization {
  /**
   * Selects a key of a Secret in the namespace that contains the credentials for authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigAuthorization#credentials
   */
  readonly credentials?: AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigAuthorizationCredentials;

  /**
   * Defines the authentication type. The value is case-insensitive.
   *
   *
   * "Basic" is not a supported value.
   *
   *
   * Default: "Bearer"
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigAuthorization#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigAuthorization' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigAuthorization(obj: AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigAuthorization | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentials': toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigAuthorizationCredentials(obj.credentials),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BasicAuth for the client.
 * This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
 *
 * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBasicAuth
 */
export interface AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBasicAuth {
  /**
   * `password` specifies a key of a Secret containing the password for
   * authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBasicAuth#password
   */
  readonly password?: AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBasicAuthPassword;

  /**
   * `username` specifies a key of a Secret containing the username for
   * authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBasicAuth#username
   */
  readonly username?: AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBasicAuthUsername;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBasicAuth(obj: AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBasicAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBasicAuthPassword(obj.password),
    'username': toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBasicAuthUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The secret's key that contains the bearer token to be used by the client
 * for authentication.
 * The secret needs to be in the same namespace as the AlertmanagerConfig
 * object and accessible by the Prometheus Operator.
 *
 * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBearerTokenSecret
 */
export interface AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBearerTokenSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBearerTokenSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBearerTokenSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBearerTokenSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBearerTokenSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBearerTokenSecret(obj: AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBearerTokenSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * OAuth2 client credentials used to fetch a token for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2
 */
export interface AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2 {
  /**
   * `clientId` specifies a key of a Secret or ConfigMap containing the
   * OAuth2 client's ID.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2#clientId
   */
  readonly clientId: AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientId;

  /**
   * `clientSecret` specifies a key of a Secret containing the OAuth2
   * client's secret.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2#clientSecret
   */
  readonly clientSecret: AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientSecret;

  /**
   * `endpointParams` configures the HTTP parameters to append to the token
   * URL.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2#endpointParams
   */
  readonly endpointParams?: { [key: string]: string };

  /**
   * `scopes` defines the OAuth2 scopes used for the token request.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2#scopes
   */
  readonly scopes?: string[];

  /**
   * `tokenURL` configures the URL to fetch the token from.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2#tokenUrl
   */
  readonly tokenUrl: string;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2(obj: AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientId': toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientId(obj.clientId),
    'clientSecret': toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientSecret(obj.clientSecret),
    'endpointParams': ((obj.endpointParams) === undefined) ? undefined : (Object.entries(obj.endpointParams).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'scopes': obj.scopes?.map(y => y),
    'tokenUrl': obj.tokenUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLS configuration for the client.
 *
 * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfig
 */
export interface AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfig {
  /**
   * Certificate authority used when verifying server certificates.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfig#ca
   */
  readonly ca?: AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCa;

  /**
   * Client certificate to present when doing client-authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfig#cert
   */
  readonly cert?: AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCert;

  /**
   * Disable target certificate validation.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfig#keySecret
   */
  readonly keySecret?: AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfig#serverName
   */
  readonly serverName?: string;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfig(obj: AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ca': toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCa(obj.ca),
    'cert': toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCert(obj.cert),
    'insecureSkipVerify': obj.insecureSkipVerify,
    'keySecret': toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigKeySecret(obj.keySecret),
    'serverName': obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Authorization header configuration for the client.
 * This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
 *
 * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigAuthorization
 */
export interface AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigAuthorization {
  /**
   * Selects a key of a Secret in the namespace that contains the credentials for authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigAuthorization#credentials
   */
  readonly credentials?: AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigAuthorizationCredentials;

  /**
   * Defines the authentication type. The value is case-insensitive.
   *
   *
   * "Basic" is not a supported value.
   *
   *
   * Default: "Bearer"
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigAuthorization#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigAuthorization' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigAuthorization(obj: AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigAuthorization | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentials': toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigAuthorizationCredentials(obj.credentials),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BasicAuth for the client.
 * This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
 *
 * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuth
 */
export interface AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuth {
  /**
   * `password` specifies a key of a Secret containing the password for
   * authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuth#password
   */
  readonly password?: AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuthPassword;

  /**
   * `username` specifies a key of a Secret containing the username for
   * authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuth#username
   */
  readonly username?: AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuthUsername;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuth(obj: AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuthPassword(obj.password),
    'username': toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuthUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The secret's key that contains the bearer token to be used by the client
 * for authentication.
 * The secret needs to be in the same namespace as the AlertmanagerConfig
 * object and accessible by the Prometheus Operator.
 *
 * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBearerTokenSecret
 */
export interface AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBearerTokenSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBearerTokenSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBearerTokenSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBearerTokenSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBearerTokenSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBearerTokenSecret(obj: AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBearerTokenSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * OAuth2 client credentials used to fetch a token for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2
 */
export interface AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2 {
  /**
   * `clientId` specifies a key of a Secret or ConfigMap containing the
   * OAuth2 client's ID.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2#clientId
   */
  readonly clientId: AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientId;

  /**
   * `clientSecret` specifies a key of a Secret containing the OAuth2
   * client's secret.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2#clientSecret
   */
  readonly clientSecret: AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientSecret;

  /**
   * `endpointParams` configures the HTTP parameters to append to the token
   * URL.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2#endpointParams
   */
  readonly endpointParams?: { [key: string]: string };

  /**
   * `scopes` defines the OAuth2 scopes used for the token request.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2#scopes
   */
  readonly scopes?: string[];

  /**
   * `tokenURL` configures the URL to fetch the token from.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2#tokenUrl
   */
  readonly tokenUrl: string;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2(obj: AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientId': toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientId(obj.clientId),
    'clientSecret': toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientSecret(obj.clientSecret),
    'endpointParams': ((obj.endpointParams) === undefined) ? undefined : (Object.entries(obj.endpointParams).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'scopes': obj.scopes?.map(y => y),
    'tokenUrl': obj.tokenUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLS configuration for the client.
 *
 * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfig
 */
export interface AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfig {
  /**
   * Certificate authority used when verifying server certificates.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfig#ca
   */
  readonly ca?: AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCa;

  /**
   * Client certificate to present when doing client-authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfig#cert
   */
  readonly cert?: AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCert;

  /**
   * Disable target certificate validation.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfig#keySecret
   */
  readonly keySecret?: AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfig#serverName
   */
  readonly serverName?: string;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfig(obj: AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ca': toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCa(obj.ca),
    'cert': toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCert(obj.cert),
    'insecureSkipVerify': obj.insecureSkipVerify,
    'keySecret': toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigKeySecret(obj.keySecret),
    'serverName': obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AccessKey is the AWS API key. If not specified, the environment variable
 * `AWS_ACCESS_KEY_ID` is used.
 *
 * @schema AlertmanagerConfigSpecReceiversSnsConfigsSigv4AccessKey
 */
export interface AlertmanagerConfigSpecReceiversSnsConfigsSigv4AccessKey {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsSigv4AccessKey#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsSigv4AccessKey#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsSigv4AccessKey#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSnsConfigsSigv4AccessKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSnsConfigsSigv4AccessKey(obj: AlertmanagerConfigSpecReceiversSnsConfigsSigv4AccessKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKey is the AWS API secret. If not specified, the environment
 * variable `AWS_SECRET_ACCESS_KEY` is used.
 *
 * @schema AlertmanagerConfigSpecReceiversSnsConfigsSigv4SecretKey
 */
export interface AlertmanagerConfigSpecReceiversSnsConfigsSigv4SecretKey {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsSigv4SecretKey#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsSigv4SecretKey#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsSigv4SecretKey#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSnsConfigsSigv4SecretKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSnsConfigsSigv4SecretKey(obj: AlertmanagerConfigSpecReceiversSnsConfigsSigv4SecretKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Authorization header configuration for the client.
 * This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
 *
 * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigAuthorization
 */
export interface AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigAuthorization {
  /**
   * Selects a key of a Secret in the namespace that contains the credentials for authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigAuthorization#credentials
   */
  readonly credentials?: AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigAuthorizationCredentials;

  /**
   * Defines the authentication type. The value is case-insensitive.
   *
   *
   * "Basic" is not a supported value.
   *
   *
   * Default: "Bearer"
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigAuthorization#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigAuthorization' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigAuthorization(obj: AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigAuthorization | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentials': toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigAuthorizationCredentials(obj.credentials),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BasicAuth for the client.
 * This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
 *
 * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBasicAuth
 */
export interface AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBasicAuth {
  /**
   * `password` specifies a key of a Secret containing the password for
   * authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBasicAuth#password
   */
  readonly password?: AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBasicAuthPassword;

  /**
   * `username` specifies a key of a Secret containing the username for
   * authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBasicAuth#username
   */
  readonly username?: AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBasicAuthUsername;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBasicAuth(obj: AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBasicAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBasicAuthPassword(obj.password),
    'username': toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBasicAuthUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The secret's key that contains the bearer token to be used by the client
 * for authentication.
 * The secret needs to be in the same namespace as the AlertmanagerConfig
 * object and accessible by the Prometheus Operator.
 *
 * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBearerTokenSecret
 */
export interface AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBearerTokenSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBearerTokenSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBearerTokenSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBearerTokenSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBearerTokenSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBearerTokenSecret(obj: AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBearerTokenSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * OAuth2 client credentials used to fetch a token for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2
 */
export interface AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2 {
  /**
   * `clientId` specifies a key of a Secret or ConfigMap containing the
   * OAuth2 client's ID.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2#clientId
   */
  readonly clientId: AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientId;

  /**
   * `clientSecret` specifies a key of a Secret containing the OAuth2
   * client's secret.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2#clientSecret
   */
  readonly clientSecret: AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientSecret;

  /**
   * `endpointParams` configures the HTTP parameters to append to the token
   * URL.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2#endpointParams
   */
  readonly endpointParams?: { [key: string]: string };

  /**
   * `scopes` defines the OAuth2 scopes used for the token request.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2#scopes
   */
  readonly scopes?: string[];

  /**
   * `tokenURL` configures the URL to fetch the token from.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2#tokenUrl
   */
  readonly tokenUrl: string;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2(obj: AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientId': toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientId(obj.clientId),
    'clientSecret': toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientSecret(obj.clientSecret),
    'endpointParams': ((obj.endpointParams) === undefined) ? undefined : (Object.entries(obj.endpointParams).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'scopes': obj.scopes?.map(y => y),
    'tokenUrl': obj.tokenUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLS configuration for the client.
 *
 * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfig
 */
export interface AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfig {
  /**
   * Certificate authority used when verifying server certificates.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfig#ca
   */
  readonly ca?: AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCa;

  /**
   * Client certificate to present when doing client-authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfig#cert
   */
  readonly cert?: AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCert;

  /**
   * Disable target certificate validation.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfig#keySecret
   */
  readonly keySecret?: AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfig#serverName
   */
  readonly serverName?: string;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfig(obj: AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ca': toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCa(obj.ca),
    'cert': toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCert(obj.cert),
    'insecureSkipVerify': obj.insecureSkipVerify,
    'keySecret': toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigKeySecret(obj.keySecret),
    'serverName': obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Authorization header configuration for the client.
 * This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
 *
 * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigAuthorization
 */
export interface AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigAuthorization {
  /**
   * Selects a key of a Secret in the namespace that contains the credentials for authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigAuthorization#credentials
   */
  readonly credentials?: AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigAuthorizationCredentials;

  /**
   * Defines the authentication type. The value is case-insensitive.
   *
   *
   * "Basic" is not a supported value.
   *
   *
   * Default: "Bearer"
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigAuthorization#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigAuthorization' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigAuthorization(obj: AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigAuthorization | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentials': toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigAuthorizationCredentials(obj.credentials),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BasicAuth for the client.
 * This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
 *
 * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuth
 */
export interface AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuth {
  /**
   * `password` specifies a key of a Secret containing the password for
   * authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuth#password
   */
  readonly password?: AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuthPassword;

  /**
   * `username` specifies a key of a Secret containing the username for
   * authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuth#username
   */
  readonly username?: AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuthUsername;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuth(obj: AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuthPassword(obj.password),
    'username': toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuthUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The secret's key that contains the bearer token to be used by the client
 * for authentication.
 * The secret needs to be in the same namespace as the AlertmanagerConfig
 * object and accessible by the Prometheus Operator.
 *
 * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBearerTokenSecret
 */
export interface AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBearerTokenSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBearerTokenSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBearerTokenSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBearerTokenSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBearerTokenSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBearerTokenSecret(obj: AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBearerTokenSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * OAuth2 client credentials used to fetch a token for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2
 */
export interface AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2 {
  /**
   * `clientId` specifies a key of a Secret or ConfigMap containing the
   * OAuth2 client's ID.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2#clientId
   */
  readonly clientId: AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientId;

  /**
   * `clientSecret` specifies a key of a Secret containing the OAuth2
   * client's secret.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2#clientSecret
   */
  readonly clientSecret: AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientSecret;

  /**
   * `endpointParams` configures the HTTP parameters to append to the token
   * URL.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2#endpointParams
   */
  readonly endpointParams?: { [key: string]: string };

  /**
   * `scopes` defines the OAuth2 scopes used for the token request.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2#scopes
   */
  readonly scopes?: string[];

  /**
   * `tokenURL` configures the URL to fetch the token from.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2#tokenUrl
   */
  readonly tokenUrl: string;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2(obj: AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientId': toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientId(obj.clientId),
    'clientSecret': toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientSecret(obj.clientSecret),
    'endpointParams': ((obj.endpointParams) === undefined) ? undefined : (Object.entries(obj.endpointParams).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'scopes': obj.scopes?.map(y => y),
    'tokenUrl': obj.tokenUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLS configuration for the client.
 *
 * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfig
 */
export interface AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfig {
  /**
   * Certificate authority used when verifying server certificates.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfig#ca
   */
  readonly ca?: AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCa;

  /**
   * Client certificate to present when doing client-authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfig#cert
   */
  readonly cert?: AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCert;

  /**
   * Disable target certificate validation.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfig#keySecret
   */
  readonly keySecret?: AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfig#serverName
   */
  readonly serverName?: string;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfig(obj: AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ca': toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCa(obj.ca),
    'cert': toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCert(obj.cert),
    'insecureSkipVerify': obj.insecureSkipVerify,
    'keySecret': toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigKeySecret(obj.keySecret),
    'serverName': obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Authorization header configuration for the client.
 * This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
 *
 * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigAuthorization
 */
export interface AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigAuthorization {
  /**
   * Selects a key of a Secret in the namespace that contains the credentials for authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigAuthorization#credentials
   */
  readonly credentials?: AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigAuthorizationCredentials;

  /**
   * Defines the authentication type. The value is case-insensitive.
   *
   *
   * "Basic" is not a supported value.
   *
   *
   * Default: "Bearer"
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigAuthorization#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigAuthorization' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigAuthorization(obj: AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigAuthorization | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentials': toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigAuthorizationCredentials(obj.credentials),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BasicAuth for the client.
 * This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
 *
 * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuth
 */
export interface AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuth {
  /**
   * `password` specifies a key of a Secret containing the password for
   * authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuth#password
   */
  readonly password?: AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuthPassword;

  /**
   * `username` specifies a key of a Secret containing the username for
   * authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuth#username
   */
  readonly username?: AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuthUsername;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuth(obj: AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuthPassword(obj.password),
    'username': toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuthUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The secret's key that contains the bearer token to be used by the client
 * for authentication.
 * The secret needs to be in the same namespace as the AlertmanagerConfig
 * object and accessible by the Prometheus Operator.
 *
 * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBearerTokenSecret
 */
export interface AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBearerTokenSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBearerTokenSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBearerTokenSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBearerTokenSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBearerTokenSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBearerTokenSecret(obj: AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBearerTokenSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * OAuth2 client credentials used to fetch a token for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2
 */
export interface AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2 {
  /**
   * `clientId` specifies a key of a Secret or ConfigMap containing the
   * OAuth2 client's ID.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2#clientId
   */
  readonly clientId: AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientId;

  /**
   * `clientSecret` specifies a key of a Secret containing the OAuth2
   * client's secret.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2#clientSecret
   */
  readonly clientSecret: AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientSecret;

  /**
   * `endpointParams` configures the HTTP parameters to append to the token
   * URL.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2#endpointParams
   */
  readonly endpointParams?: { [key: string]: string };

  /**
   * `scopes` defines the OAuth2 scopes used for the token request.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2#scopes
   */
  readonly scopes?: string[];

  /**
   * `tokenURL` configures the URL to fetch the token from.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2#tokenUrl
   */
  readonly tokenUrl: string;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2(obj: AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientId': toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientId(obj.clientId),
    'clientSecret': toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientSecret(obj.clientSecret),
    'endpointParams': ((obj.endpointParams) === undefined) ? undefined : (Object.entries(obj.endpointParams).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'scopes': obj.scopes?.map(y => y),
    'tokenUrl': obj.tokenUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLS configuration for the client.
 *
 * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfig
 */
export interface AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfig {
  /**
   * Certificate authority used when verifying server certificates.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfig#ca
   */
  readonly ca?: AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCa;

  /**
   * Client certificate to present when doing client-authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfig#cert
   */
  readonly cert?: AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCert;

  /**
   * Disable target certificate validation.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfig#keySecret
   */
  readonly keySecret?: AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfig#serverName
   */
  readonly serverName?: string;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfig(obj: AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ca': toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCa(obj.ca),
    'cert': toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCert(obj.cert),
    'insecureSkipVerify': obj.insecureSkipVerify,
    'keySecret': toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigKeySecret(obj.keySecret),
    'serverName': obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Authorization header configuration for the client.
 * This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
 *
 * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigAuthorization
 */
export interface AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigAuthorization {
  /**
   * Selects a key of a Secret in the namespace that contains the credentials for authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigAuthorization#credentials
   */
  readonly credentials?: AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigAuthorizationCredentials;

  /**
   * Defines the authentication type. The value is case-insensitive.
   *
   *
   * "Basic" is not a supported value.
   *
   *
   * Default: "Bearer"
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigAuthorization#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigAuthorization' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigAuthorization(obj: AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigAuthorization | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentials': toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigAuthorizationCredentials(obj.credentials),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BasicAuth for the client.
 * This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
 *
 * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBasicAuth
 */
export interface AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBasicAuth {
  /**
   * `password` specifies a key of a Secret containing the password for
   * authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBasicAuth#password
   */
  readonly password?: AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBasicAuthPassword;

  /**
   * `username` specifies a key of a Secret containing the username for
   * authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBasicAuth#username
   */
  readonly username?: AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBasicAuthUsername;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBasicAuth(obj: AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBasicAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBasicAuthPassword(obj.password),
    'username': toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBasicAuthUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The secret's key that contains the bearer token to be used by the client
 * for authentication.
 * The secret needs to be in the same namespace as the AlertmanagerConfig
 * object and accessible by the Prometheus Operator.
 *
 * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBearerTokenSecret
 */
export interface AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBearerTokenSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBearerTokenSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBearerTokenSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBearerTokenSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBearerTokenSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBearerTokenSecret(obj: AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBearerTokenSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * OAuth2 client credentials used to fetch a token for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2
 */
export interface AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2 {
  /**
   * `clientId` specifies a key of a Secret or ConfigMap containing the
   * OAuth2 client's ID.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2#clientId
   */
  readonly clientId: AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientId;

  /**
   * `clientSecret` specifies a key of a Secret containing the OAuth2
   * client's secret.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2#clientSecret
   */
  readonly clientSecret: AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientSecret;

  /**
   * `endpointParams` configures the HTTP parameters to append to the token
   * URL.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2#endpointParams
   */
  readonly endpointParams?: { [key: string]: string };

  /**
   * `scopes` defines the OAuth2 scopes used for the token request.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2#scopes
   */
  readonly scopes?: string[];

  /**
   * `tokenURL` configures the URL to fetch the token from.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2#tokenUrl
   */
  readonly tokenUrl: string;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2(obj: AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientId': toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientId(obj.clientId),
    'clientSecret': toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientSecret(obj.clientSecret),
    'endpointParams': ((obj.endpointParams) === undefined) ? undefined : (Object.entries(obj.endpointParams).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'scopes': obj.scopes?.map(y => y),
    'tokenUrl': obj.tokenUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLS configuration for the client.
 *
 * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfig
 */
export interface AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfig {
  /**
   * Certificate authority used when verifying server certificates.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfig#ca
   */
  readonly ca?: AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCa;

  /**
   * Client certificate to present when doing client-authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfig#cert
   */
  readonly cert?: AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCert;

  /**
   * Disable target certificate validation.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfig#keySecret
   */
  readonly keySecret?: AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfig#serverName
   */
  readonly serverName?: string;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfig(obj: AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ca': toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCa(obj.ca),
    'cert': toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCert(obj.cert),
    'insecureSkipVerify': obj.insecureSkipVerify,
    'keySecret': toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigKeySecret(obj.keySecret),
    'serverName': obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Authorization header configuration for the client.
 * This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
 *
 * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigAuthorization
 */
export interface AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigAuthorization {
  /**
   * Selects a key of a Secret in the namespace that contains the credentials for authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigAuthorization#credentials
   */
  readonly credentials?: AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigAuthorizationCredentials;

  /**
   * Defines the authentication type. The value is case-insensitive.
   *
   *
   * "Basic" is not a supported value.
   *
   *
   * Default: "Bearer"
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigAuthorization#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigAuthorization' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigAuthorization(obj: AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigAuthorization | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentials': toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigAuthorizationCredentials(obj.credentials),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BasicAuth for the client.
 * This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
 *
 * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuth
 */
export interface AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuth {
  /**
   * `password` specifies a key of a Secret containing the password for
   * authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuth#password
   */
  readonly password?: AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuthPassword;

  /**
   * `username` specifies a key of a Secret containing the username for
   * authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuth#username
   */
  readonly username?: AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuthUsername;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuth(obj: AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuthPassword(obj.password),
    'username': toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuthUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The secret's key that contains the bearer token to be used by the client
 * for authentication.
 * The secret needs to be in the same namespace as the AlertmanagerConfig
 * object and accessible by the Prometheus Operator.
 *
 * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBearerTokenSecret
 */
export interface AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBearerTokenSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBearerTokenSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBearerTokenSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBearerTokenSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBearerTokenSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBearerTokenSecret(obj: AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBearerTokenSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * OAuth2 client credentials used to fetch a token for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2
 */
export interface AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2 {
  /**
   * `clientId` specifies a key of a Secret or ConfigMap containing the
   * OAuth2 client's ID.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2#clientId
   */
  readonly clientId: AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientId;

  /**
   * `clientSecret` specifies a key of a Secret containing the OAuth2
   * client's secret.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2#clientSecret
   */
  readonly clientSecret: AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientSecret;

  /**
   * `endpointParams` configures the HTTP parameters to append to the token
   * URL.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2#endpointParams
   */
  readonly endpointParams?: { [key: string]: string };

  /**
   * `scopes` defines the OAuth2 scopes used for the token request.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2#scopes
   */
  readonly scopes?: string[];

  /**
   * `tokenURL` configures the URL to fetch the token from.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2#tokenUrl
   */
  readonly tokenUrl: string;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2(obj: AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientId': toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientId(obj.clientId),
    'clientSecret': toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientSecret(obj.clientSecret),
    'endpointParams': ((obj.endpointParams) === undefined) ? undefined : (Object.entries(obj.endpointParams).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'scopes': obj.scopes?.map(y => y),
    'tokenUrl': obj.tokenUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLS configuration for the client.
 *
 * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfig
 */
export interface AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfig {
  /**
   * Certificate authority used when verifying server certificates.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfig#ca
   */
  readonly ca?: AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCa;

  /**
   * Client certificate to present when doing client-authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfig#cert
   */
  readonly cert?: AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCert;

  /**
   * Disable target certificate validation.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfig#keySecret
   */
  readonly keySecret?: AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfig#serverName
   */
  readonly serverName?: string;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfig(obj: AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ca': toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCa(obj.ca),
    'cert': toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCert(obj.cert),
    'insecureSkipVerify': obj.insecureSkipVerify,
    'keySecret': toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigKeySecret(obj.keySecret),
    'serverName': obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a Secret in the namespace that contains the credentials for authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigAuthorizationCredentials
 */
export interface AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigAuthorizationCredentials {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigAuthorizationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigAuthorizationCredentials#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigAuthorizationCredentials#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigAuthorizationCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigAuthorizationCredentials(obj: AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigAuthorizationCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `password` specifies a key of a Secret containing the password for
 * authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuthPassword
 */
export interface AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuthPassword#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuthPassword(obj: AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuthPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `username` specifies a key of a Secret containing the username for
 * authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuthUsername
 */
export interface AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuthUsername#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuthUsername(obj: AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuthUsername | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `clientId` specifies a key of a Secret or ConfigMap containing the
 * OAuth2 client's ID.
 *
 * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientId
 */
export interface AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientId {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientId#configMap
   */
  readonly configMap?: AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientIdConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientId#secret
   */
  readonly secret?: AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientIdSecret;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientId(obj: AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientIdConfigMap(obj.configMap),
    'secret': toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientIdSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `clientSecret` specifies a key of a Secret containing the OAuth2
 * client's secret.
 *
 * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientSecret
 */
export interface AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientSecret(obj: AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Certificate authority used when verifying server certificates.
 *
 * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCa
 */
export interface AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCa#configMap
   */
  readonly configMap?: AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCa#secret
   */
  readonly secret?: AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCaSecret;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCa(obj: AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCaConfigMap(obj.configMap),
    'secret': toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Client certificate to present when doing client-authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCert
 */
export interface AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCert#configMap
   */
  readonly configMap?: AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCert#secret
   */
  readonly secret?: AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCertSecret;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCert(obj: AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCertConfigMap(obj.configMap),
    'secret': toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigKeySecret
 */
export interface AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigKeySecret(obj: AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCaConfigMap
 */
export interface AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCaConfigMap(obj: AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCaConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCaSecret
 */
export interface AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCaSecret(obj: AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCaSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCertConfigMap
 */
export interface AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCertConfigMap(obj: AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCertConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCertSecret
 */
export interface AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCertSecret(obj: AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCertSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a Secret in the namespace that contains the credentials for authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigAuthorizationCredentials
 */
export interface AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigAuthorizationCredentials {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigAuthorizationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigAuthorizationCredentials#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigAuthorizationCredentials#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigAuthorizationCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigAuthorizationCredentials(obj: AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigAuthorizationCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `password` specifies a key of a Secret containing the password for
 * authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuthPassword
 */
export interface AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuthPassword#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuthPassword(obj: AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuthPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `username` specifies a key of a Secret containing the username for
 * authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuthUsername
 */
export interface AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuthUsername#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuthUsername(obj: AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuthUsername | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `clientId` specifies a key of a Secret or ConfigMap containing the
 * OAuth2 client's ID.
 *
 * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientId
 */
export interface AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientId {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientId#configMap
   */
  readonly configMap?: AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientIdConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientId#secret
   */
  readonly secret?: AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientIdSecret;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientId(obj: AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientIdConfigMap(obj.configMap),
    'secret': toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientIdSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `clientSecret` specifies a key of a Secret containing the OAuth2
 * client's secret.
 *
 * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientSecret
 */
export interface AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientSecret(obj: AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Certificate authority used when verifying server certificates.
 *
 * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCa
 */
export interface AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCa#configMap
   */
  readonly configMap?: AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCa#secret
   */
  readonly secret?: AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCaSecret;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCa(obj: AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCaConfigMap(obj.configMap),
    'secret': toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Client certificate to present when doing client-authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCert
 */
export interface AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCert#configMap
   */
  readonly configMap?: AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCert#secret
   */
  readonly secret?: AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCertSecret;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCert(obj: AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCertConfigMap(obj.configMap),
    'secret': toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigKeySecret
 */
export interface AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigKeySecret(obj: AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a Secret in the namespace that contains the credentials for authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigAuthorizationCredentials
 */
export interface AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigAuthorizationCredentials {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigAuthorizationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigAuthorizationCredentials#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigAuthorizationCredentials#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigAuthorizationCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigAuthorizationCredentials(obj: AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigAuthorizationCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `password` specifies a key of a Secret containing the password for
 * authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBasicAuthPassword
 */
export interface AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBasicAuthPassword#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBasicAuthPassword(obj: AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBasicAuthPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `username` specifies a key of a Secret containing the username for
 * authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBasicAuthUsername
 */
export interface AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBasicAuthUsername#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBasicAuthUsername(obj: AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBasicAuthUsername | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `clientId` specifies a key of a Secret or ConfigMap containing the
 * OAuth2 client's ID.
 *
 * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientId
 */
export interface AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientId {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientId#configMap
   */
  readonly configMap?: AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientIdConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientId#secret
   */
  readonly secret?: AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientIdSecret;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientId(obj: AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientIdConfigMap(obj.configMap),
    'secret': toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientIdSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `clientSecret` specifies a key of a Secret containing the OAuth2
 * client's secret.
 *
 * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientSecret
 */
export interface AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientSecret(obj: AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Certificate authority used when verifying server certificates.
 *
 * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCa
 */
export interface AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCa#configMap
   */
  readonly configMap?: AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCa#secret
   */
  readonly secret?: AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCaSecret;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCa(obj: AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCaConfigMap(obj.configMap),
    'secret': toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Client certificate to present when doing client-authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCert
 */
export interface AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCert#configMap
   */
  readonly configMap?: AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCert#secret
   */
  readonly secret?: AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCertSecret;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCert(obj: AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCertConfigMap(obj.configMap),
    'secret': toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigKeySecret
 */
export interface AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigKeySecret(obj: AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a Secret in the namespace that contains the credentials for authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigAuthorizationCredentials
 */
export interface AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigAuthorizationCredentials {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigAuthorizationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigAuthorizationCredentials#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigAuthorizationCredentials#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigAuthorizationCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigAuthorizationCredentials(obj: AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigAuthorizationCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `password` specifies a key of a Secret containing the password for
 * authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBasicAuthPassword
 */
export interface AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBasicAuthPassword#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBasicAuthPassword(obj: AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBasicAuthPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `username` specifies a key of a Secret containing the username for
 * authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBasicAuthUsername
 */
export interface AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBasicAuthUsername#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBasicAuthUsername(obj: AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBasicAuthUsername | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `clientId` specifies a key of a Secret or ConfigMap containing the
 * OAuth2 client's ID.
 *
 * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientId
 */
export interface AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientId {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientId#configMap
   */
  readonly configMap?: AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientIdConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientId#secret
   */
  readonly secret?: AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientIdSecret;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientId(obj: AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientIdConfigMap(obj.configMap),
    'secret': toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientIdSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `clientSecret` specifies a key of a Secret containing the OAuth2
 * client's secret.
 *
 * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientSecret
 */
export interface AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientSecret(obj: AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Certificate authority used when verifying server certificates.
 *
 * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCa
 */
export interface AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCa#configMap
   */
  readonly configMap?: AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCa#secret
   */
  readonly secret?: AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCaSecret;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCa(obj: AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCaConfigMap(obj.configMap),
    'secret': toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Client certificate to present when doing client-authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCert
 */
export interface AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCert#configMap
   */
  readonly configMap?: AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCert#secret
   */
  readonly secret?: AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCertSecret;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCert(obj: AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCertConfigMap(obj.configMap),
    'secret': toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigKeySecret
 */
export interface AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigKeySecret(obj: AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a Secret in the namespace that contains the credentials for authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigAuthorizationCredentials
 */
export interface AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigAuthorizationCredentials {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigAuthorizationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigAuthorizationCredentials#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigAuthorizationCredentials#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigAuthorizationCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigAuthorizationCredentials(obj: AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigAuthorizationCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `password` specifies a key of a Secret containing the password for
 * authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBasicAuthPassword
 */
export interface AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBasicAuthPassword#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBasicAuthPassword(obj: AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBasicAuthPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `username` specifies a key of a Secret containing the username for
 * authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBasicAuthUsername
 */
export interface AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBasicAuthUsername#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBasicAuthUsername(obj: AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBasicAuthUsername | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `clientId` specifies a key of a Secret or ConfigMap containing the
 * OAuth2 client's ID.
 *
 * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientId
 */
export interface AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientId {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientId#configMap
   */
  readonly configMap?: AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientIdConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientId#secret
   */
  readonly secret?: AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientIdSecret;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientId(obj: AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientIdConfigMap(obj.configMap),
    'secret': toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientIdSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `clientSecret` specifies a key of a Secret containing the OAuth2
 * client's secret.
 *
 * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientSecret
 */
export interface AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientSecret(obj: AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Certificate authority used when verifying server certificates.
 *
 * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCa
 */
export interface AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCa#configMap
   */
  readonly configMap?: AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCa#secret
   */
  readonly secret?: AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCaSecret;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCa(obj: AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCaConfigMap(obj.configMap),
    'secret': toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Client certificate to present when doing client-authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCert
 */
export interface AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCert#configMap
   */
  readonly configMap?: AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCert#secret
   */
  readonly secret?: AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCertSecret;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCert(obj: AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCertConfigMap(obj.configMap),
    'secret': toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigKeySecret
 */
export interface AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigKeySecret(obj: AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a Secret in the namespace that contains the credentials for authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigAuthorizationCredentials
 */
export interface AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigAuthorizationCredentials {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigAuthorizationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigAuthorizationCredentials#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigAuthorizationCredentials#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigAuthorizationCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigAuthorizationCredentials(obj: AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigAuthorizationCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `password` specifies a key of a Secret containing the password for
 * authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBasicAuthPassword
 */
export interface AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBasicAuthPassword#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBasicAuthPassword(obj: AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBasicAuthPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `username` specifies a key of a Secret containing the username for
 * authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBasicAuthUsername
 */
export interface AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBasicAuthUsername#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBasicAuthUsername(obj: AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBasicAuthUsername | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `clientId` specifies a key of a Secret or ConfigMap containing the
 * OAuth2 client's ID.
 *
 * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientId
 */
export interface AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientId {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientId#configMap
   */
  readonly configMap?: AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientIdConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientId#secret
   */
  readonly secret?: AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientIdSecret;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientId(obj: AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientIdConfigMap(obj.configMap),
    'secret': toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientIdSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `clientSecret` specifies a key of a Secret containing the OAuth2
 * client's secret.
 *
 * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientSecret
 */
export interface AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientSecret(obj: AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Certificate authority used when verifying server certificates.
 *
 * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCa
 */
export interface AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCa#configMap
   */
  readonly configMap?: AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCa#secret
   */
  readonly secret?: AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCaSecret;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCa(obj: AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCaConfigMap(obj.configMap),
    'secret': toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Client certificate to present when doing client-authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCert
 */
export interface AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCert#configMap
   */
  readonly configMap?: AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCert#secret
   */
  readonly secret?: AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCertSecret;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCert(obj: AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCertConfigMap(obj.configMap),
    'secret': toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigKeySecret
 */
export interface AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigKeySecret(obj: AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a Secret in the namespace that contains the credentials for authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigAuthorizationCredentials
 */
export interface AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigAuthorizationCredentials {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigAuthorizationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigAuthorizationCredentials#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigAuthorizationCredentials#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigAuthorizationCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigAuthorizationCredentials(obj: AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigAuthorizationCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `password` specifies a key of a Secret containing the password for
 * authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuthPassword
 */
export interface AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuthPassword#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuthPassword(obj: AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuthPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `username` specifies a key of a Secret containing the username for
 * authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuthUsername
 */
export interface AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuthUsername#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuthUsername(obj: AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuthUsername | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `clientId` specifies a key of a Secret or ConfigMap containing the
 * OAuth2 client's ID.
 *
 * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientId
 */
export interface AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientId {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientId#configMap
   */
  readonly configMap?: AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientIdConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientId#secret
   */
  readonly secret?: AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientIdSecret;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientId(obj: AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientIdConfigMap(obj.configMap),
    'secret': toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientIdSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `clientSecret` specifies a key of a Secret containing the OAuth2
 * client's secret.
 *
 * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientSecret
 */
export interface AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientSecret(obj: AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Certificate authority used when verifying server certificates.
 *
 * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCa
 */
export interface AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCa#configMap
   */
  readonly configMap?: AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCa#secret
   */
  readonly secret?: AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCaSecret;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCa(obj: AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCaConfigMap(obj.configMap),
    'secret': toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Client certificate to present when doing client-authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCert
 */
export interface AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCert#configMap
   */
  readonly configMap?: AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCert#secret
   */
  readonly secret?: AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCertSecret;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCert(obj: AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCertConfigMap(obj.configMap),
    'secret': toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigKeySecret
 */
export interface AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigKeySecret(obj: AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a Secret in the namespace that contains the credentials for authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigAuthorizationCredentials
 */
export interface AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigAuthorizationCredentials {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigAuthorizationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigAuthorizationCredentials#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigAuthorizationCredentials#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigAuthorizationCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigAuthorizationCredentials(obj: AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigAuthorizationCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `password` specifies a key of a Secret containing the password for
 * authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBasicAuthPassword
 */
export interface AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBasicAuthPassword#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBasicAuthPassword(obj: AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBasicAuthPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `username` specifies a key of a Secret containing the username for
 * authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBasicAuthUsername
 */
export interface AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBasicAuthUsername#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBasicAuthUsername(obj: AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBasicAuthUsername | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `clientId` specifies a key of a Secret or ConfigMap containing the
 * OAuth2 client's ID.
 *
 * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientId
 */
export interface AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientId {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientId#configMap
   */
  readonly configMap?: AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientIdConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientId#secret
   */
  readonly secret?: AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientIdSecret;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientId(obj: AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientIdConfigMap(obj.configMap),
    'secret': toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientIdSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `clientSecret` specifies a key of a Secret containing the OAuth2
 * client's secret.
 *
 * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientSecret
 */
export interface AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientSecret(obj: AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Certificate authority used when verifying server certificates.
 *
 * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCa
 */
export interface AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCa#configMap
   */
  readonly configMap?: AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCa#secret
   */
  readonly secret?: AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCaSecret;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCa(obj: AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCaConfigMap(obj.configMap),
    'secret': toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Client certificate to present when doing client-authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCert
 */
export interface AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCert#configMap
   */
  readonly configMap?: AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCert#secret
   */
  readonly secret?: AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCertSecret;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCert(obj: AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCertConfigMap(obj.configMap),
    'secret': toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigKeySecret
 */
export interface AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigKeySecret(obj: AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a Secret in the namespace that contains the credentials for authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigAuthorizationCredentials
 */
export interface AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigAuthorizationCredentials {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigAuthorizationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigAuthorizationCredentials#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigAuthorizationCredentials#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigAuthorizationCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigAuthorizationCredentials(obj: AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigAuthorizationCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `password` specifies a key of a Secret containing the password for
 * authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuthPassword
 */
export interface AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuthPassword#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuthPassword(obj: AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuthPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `username` specifies a key of a Secret containing the username for
 * authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuthUsername
 */
export interface AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuthUsername#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuthUsername(obj: AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuthUsername | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `clientId` specifies a key of a Secret or ConfigMap containing the
 * OAuth2 client's ID.
 *
 * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientId
 */
export interface AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientId {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientId#configMap
   */
  readonly configMap?: AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientIdConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientId#secret
   */
  readonly secret?: AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientIdSecret;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientId(obj: AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientIdConfigMap(obj.configMap),
    'secret': toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientIdSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `clientSecret` specifies a key of a Secret containing the OAuth2
 * client's secret.
 *
 * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientSecret
 */
export interface AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientSecret(obj: AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Certificate authority used when verifying server certificates.
 *
 * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCa
 */
export interface AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCa#configMap
   */
  readonly configMap?: AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCa#secret
   */
  readonly secret?: AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCaSecret;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCa(obj: AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCaConfigMap(obj.configMap),
    'secret': toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Client certificate to present when doing client-authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCert
 */
export interface AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCert#configMap
   */
  readonly configMap?: AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCert#secret
   */
  readonly secret?: AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCertSecret;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCert(obj: AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCertConfigMap(obj.configMap),
    'secret': toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigKeySecret
 */
export interface AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigKeySecret(obj: AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a Secret in the namespace that contains the credentials for authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigAuthorizationCredentials
 */
export interface AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigAuthorizationCredentials {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigAuthorizationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigAuthorizationCredentials#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigAuthorizationCredentials#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigAuthorizationCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigAuthorizationCredentials(obj: AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigAuthorizationCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `password` specifies a key of a Secret containing the password for
 * authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuthPassword
 */
export interface AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuthPassword#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuthPassword(obj: AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuthPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `username` specifies a key of a Secret containing the username for
 * authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuthUsername
 */
export interface AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuthUsername#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuthUsername(obj: AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuthUsername | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `clientId` specifies a key of a Secret or ConfigMap containing the
 * OAuth2 client's ID.
 *
 * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientId
 */
export interface AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientId {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientId#configMap
   */
  readonly configMap?: AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientIdConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientId#secret
   */
  readonly secret?: AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientIdSecret;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientId(obj: AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientIdConfigMap(obj.configMap),
    'secret': toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientIdSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `clientSecret` specifies a key of a Secret containing the OAuth2
 * client's secret.
 *
 * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientSecret
 */
export interface AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientSecret(obj: AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Certificate authority used when verifying server certificates.
 *
 * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCa
 */
export interface AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCa#configMap
   */
  readonly configMap?: AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCa#secret
   */
  readonly secret?: AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCaSecret;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCa(obj: AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCaConfigMap(obj.configMap),
    'secret': toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Client certificate to present when doing client-authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCert
 */
export interface AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCert#configMap
   */
  readonly configMap?: AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCert#secret
   */
  readonly secret?: AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCertSecret;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCert(obj: AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCertConfigMap(obj.configMap),
    'secret': toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigKeySecret
 */
export interface AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigKeySecret(obj: AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a Secret in the namespace that contains the credentials for authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigAuthorizationCredentials
 */
export interface AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigAuthorizationCredentials {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigAuthorizationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigAuthorizationCredentials#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigAuthorizationCredentials#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigAuthorizationCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigAuthorizationCredentials(obj: AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigAuthorizationCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `password` specifies a key of a Secret containing the password for
 * authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBasicAuthPassword
 */
export interface AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBasicAuthPassword#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBasicAuthPassword(obj: AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBasicAuthPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `username` specifies a key of a Secret containing the username for
 * authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBasicAuthUsername
 */
export interface AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBasicAuthUsername#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBasicAuthUsername(obj: AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBasicAuthUsername | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `clientId` specifies a key of a Secret or ConfigMap containing the
 * OAuth2 client's ID.
 *
 * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientId
 */
export interface AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientId {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientId#configMap
   */
  readonly configMap?: AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientIdConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientId#secret
   */
  readonly secret?: AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientIdSecret;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientId(obj: AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientIdConfigMap(obj.configMap),
    'secret': toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientIdSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `clientSecret` specifies a key of a Secret containing the OAuth2
 * client's secret.
 *
 * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientSecret
 */
export interface AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientSecret(obj: AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Certificate authority used when verifying server certificates.
 *
 * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCa
 */
export interface AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCa#configMap
   */
  readonly configMap?: AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCa#secret
   */
  readonly secret?: AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCaSecret;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCa(obj: AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCaConfigMap(obj.configMap),
    'secret': toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Client certificate to present when doing client-authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCert
 */
export interface AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCert#configMap
   */
  readonly configMap?: AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCert#secret
   */
  readonly secret?: AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCertSecret;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCert(obj: AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCertConfigMap(obj.configMap),
    'secret': toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigKeySecret
 */
export interface AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigKeySecret(obj: AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a Secret in the namespace that contains the credentials for authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigAuthorizationCredentials
 */
export interface AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigAuthorizationCredentials {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigAuthorizationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigAuthorizationCredentials#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigAuthorizationCredentials#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigAuthorizationCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigAuthorizationCredentials(obj: AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigAuthorizationCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `password` specifies a key of a Secret containing the password for
 * authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuthPassword
 */
export interface AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuthPassword#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuthPassword(obj: AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuthPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `username` specifies a key of a Secret containing the username for
 * authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuthUsername
 */
export interface AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuthUsername#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuthUsername(obj: AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuthUsername | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `clientId` specifies a key of a Secret or ConfigMap containing the
 * OAuth2 client's ID.
 *
 * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientId
 */
export interface AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientId {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientId#configMap
   */
  readonly configMap?: AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientIdConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientId#secret
   */
  readonly secret?: AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientIdSecret;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientId(obj: AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientIdConfigMap(obj.configMap),
    'secret': toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientIdSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `clientSecret` specifies a key of a Secret containing the OAuth2
 * client's secret.
 *
 * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientSecret
 */
export interface AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientSecret(obj: AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Certificate authority used when verifying server certificates.
 *
 * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCa
 */
export interface AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCa#configMap
   */
  readonly configMap?: AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCa#secret
   */
  readonly secret?: AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCaSecret;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCa(obj: AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCaConfigMap(obj.configMap),
    'secret': toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Client certificate to present when doing client-authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCert
 */
export interface AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCert#configMap
   */
  readonly configMap?: AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCert#secret
   */
  readonly secret?: AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCertSecret;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCert(obj: AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCertConfigMap(obj.configMap),
    'secret': toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigKeySecret
 */
export interface AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigKeySecret(obj: AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientIdConfigMap
 */
export interface AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientIdConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientIdConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientIdConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientIdConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientIdConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientIdConfigMap(obj: AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientIdConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientIdSecret
 */
export interface AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientIdSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientIdSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientIdSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientIdSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientIdSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientIdSecret(obj: AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientIdSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCaConfigMap
 */
export interface AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCaConfigMap(obj: AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCaConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCaSecret
 */
export interface AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCaSecret(obj: AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCaSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCertConfigMap
 */
export interface AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCertConfigMap(obj: AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCertConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCertSecret
 */
export interface AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCertSecret(obj: AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCertSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientIdConfigMap
 */
export interface AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientIdConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientIdConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientIdConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientIdConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientIdConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientIdConfigMap(obj: AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientIdConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientIdSecret
 */
export interface AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientIdSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientIdSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientIdSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientIdSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientIdSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientIdSecret(obj: AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientIdSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCaConfigMap
 */
export interface AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCaConfigMap(obj: AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCaConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCaSecret
 */
export interface AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCaSecret(obj: AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCaSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCertConfigMap
 */
export interface AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCertConfigMap(obj: AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCertConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCertSecret
 */
export interface AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCertSecret(obj: AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCertSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientIdConfigMap
 */
export interface AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientIdConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientIdConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientIdConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientIdConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientIdConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientIdConfigMap(obj: AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientIdConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientIdSecret
 */
export interface AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientIdSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientIdSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientIdSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientIdSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientIdSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientIdSecret(obj: AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientIdSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCaConfigMap
 */
export interface AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCaConfigMap(obj: AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCaConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCaSecret
 */
export interface AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCaSecret(obj: AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCaSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCertConfigMap
 */
export interface AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCertConfigMap(obj: AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCertConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCertSecret
 */
export interface AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCertSecret(obj: AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCertSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientIdConfigMap
 */
export interface AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientIdConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientIdConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientIdConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientIdConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientIdConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientIdConfigMap(obj: AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientIdConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientIdSecret
 */
export interface AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientIdSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientIdSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientIdSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientIdSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientIdSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientIdSecret(obj: AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientIdSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCaConfigMap
 */
export interface AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCaConfigMap(obj: AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCaConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCaSecret
 */
export interface AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCaSecret(obj: AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCaSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCertConfigMap
 */
export interface AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCertConfigMap(obj: AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCertConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCertSecret
 */
export interface AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCertSecret(obj: AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCertSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientIdConfigMap
 */
export interface AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientIdConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientIdConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientIdConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientIdConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientIdConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientIdConfigMap(obj: AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientIdConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientIdSecret
 */
export interface AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientIdSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientIdSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientIdSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientIdSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientIdSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientIdSecret(obj: AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientIdSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCaConfigMap
 */
export interface AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCaConfigMap(obj: AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCaConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCaSecret
 */
export interface AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCaSecret(obj: AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCaSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCertConfigMap
 */
export interface AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCertConfigMap(obj: AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCertConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCertSecret
 */
export interface AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCertSecret(obj: AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCertSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientIdConfigMap
 */
export interface AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientIdConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientIdConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientIdConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientIdConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientIdConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientIdConfigMap(obj: AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientIdConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientIdSecret
 */
export interface AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientIdSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientIdSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientIdSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientIdSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientIdSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientIdSecret(obj: AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientIdSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCaConfigMap
 */
export interface AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCaConfigMap(obj: AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCaConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCaSecret
 */
export interface AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCaSecret(obj: AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCaSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCertConfigMap
 */
export interface AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCertConfigMap(obj: AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCertConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCertSecret
 */
export interface AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCertSecret(obj: AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCertSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientIdConfigMap
 */
export interface AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientIdConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientIdConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientIdConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientIdConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientIdConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientIdConfigMap(obj: AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientIdConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientIdSecret
 */
export interface AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientIdSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientIdSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientIdSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientIdSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientIdSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientIdSecret(obj: AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientIdSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCaConfigMap
 */
export interface AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCaConfigMap(obj: AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCaConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCaSecret
 */
export interface AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCaSecret(obj: AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCaSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCertConfigMap
 */
export interface AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCertConfigMap(obj: AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCertConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCertSecret
 */
export interface AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCertSecret(obj: AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCertSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientIdConfigMap
 */
export interface AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientIdConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientIdConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientIdConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientIdConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientIdConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientIdConfigMap(obj: AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientIdConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientIdSecret
 */
export interface AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientIdSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientIdSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientIdSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientIdSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientIdSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientIdSecret(obj: AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientIdSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCaConfigMap
 */
export interface AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCaConfigMap(obj: AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCaConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCaSecret
 */
export interface AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCaSecret(obj: AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCaSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCertConfigMap
 */
export interface AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCertConfigMap(obj: AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCertConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCertSecret
 */
export interface AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCertSecret(obj: AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCertSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientIdConfigMap
 */
export interface AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientIdConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientIdConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientIdConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientIdConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientIdConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientIdConfigMap(obj: AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientIdConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientIdSecret
 */
export interface AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientIdSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientIdSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientIdSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientIdSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientIdSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientIdSecret(obj: AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientIdSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCaConfigMap
 */
export interface AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCaConfigMap(obj: AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCaConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCaSecret
 */
export interface AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCaSecret(obj: AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCaSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCertConfigMap
 */
export interface AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCertConfigMap(obj: AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCertConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCertSecret
 */
export interface AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCertSecret(obj: AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCertSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientIdConfigMap
 */
export interface AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientIdConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientIdConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientIdConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientIdConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientIdConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientIdConfigMap(obj: AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientIdConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientIdSecret
 */
export interface AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientIdSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientIdSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientIdSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientIdSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientIdSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientIdSecret(obj: AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientIdSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCaConfigMap
 */
export interface AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCaConfigMap(obj: AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCaConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCaSecret
 */
export interface AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCaSecret(obj: AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCaSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCertConfigMap
 */
export interface AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCertConfigMap(obj: AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCertConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCertSecret
 */
export interface AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCertSecret(obj: AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCertSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientIdConfigMap
 */
export interface AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientIdConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientIdConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientIdConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientIdConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientIdConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientIdConfigMap(obj: AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientIdConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientIdSecret
 */
export interface AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientIdSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientIdSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientIdSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientIdSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientIdSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientIdSecret(obj: AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientIdSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCaConfigMap
 */
export interface AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCaConfigMap(obj: AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCaConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCaSecret
 */
export interface AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCaSecret(obj: AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCaSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCertConfigMap
 */
export interface AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCertConfigMap(obj: AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCertConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCertSecret
 */
export interface AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCertSecret(obj: AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCertSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientIdConfigMap
 */
export interface AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientIdConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientIdConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientIdConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientIdConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientIdConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientIdConfigMap(obj: AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientIdConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientIdSecret
 */
export interface AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientIdSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientIdSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientIdSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientIdSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientIdSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientIdSecret(obj: AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientIdSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCaConfigMap
 */
export interface AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCaConfigMap(obj: AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCaConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCaSecret
 */
export interface AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCaSecret(obj: AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCaSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCertConfigMap
 */
export interface AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCertConfigMap(obj: AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCertConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCertSecret
 */
export interface AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCertSecret(obj: AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCertSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

