// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * A CertificateRequest is used to request a signed certificate from one of the
configured issuers.

All fields within the CertificateRequest's `spec` are immutable after creation.
A CertificateRequest will either succeed or fail, as denoted by its `Ready` status
condition and its `status.failureTime` field.

A CertificateRequest is a one-shot resource, meaning it represents a single
point in time request for a certificate and cannot be re-used.
 *
 * @schema CertificateRequest
 */
export class CertificateRequest extends ApiObject {
  /**
   * Returns the apiVersion and kind for "CertificateRequest"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cert-manager.io/v1',
    kind: 'CertificateRequest',
  }

  /**
   * Renders a Kubernetes manifest for "CertificateRequest".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CertificateRequestProps = {}): any {
    return {
      ...CertificateRequest.GVK,
      ...toJson_CertificateRequestProps(props),
    };
  }

  /**
   * Defines a "CertificateRequest" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CertificateRequestProps = {}) {
    super(scope, id, {
      ...CertificateRequest.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...CertificateRequest.GVK,
      ...toJson_CertificateRequestProps(resolved),
    };
  }
}

/**
 * A CertificateRequest is used to request a signed certificate from one of the
 * configured issuers.
 *
 * All fields within the CertificateRequest's `spec` are immutable after creation.
 * A CertificateRequest will either succeed or fail, as denoted by its `Ready` status
 * condition and its `status.failureTime` field.
 *
 * A CertificateRequest is a one-shot resource, meaning it represents a single
 * point in time request for a certificate and cannot be re-used.
 *
 * @schema CertificateRequest
 */
export interface CertificateRequestProps {
  /**
   * @schema CertificateRequest#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Specification of the desired state of the CertificateRequest resource.
   * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
   *
   * @schema CertificateRequest#spec
   */
  readonly spec?: CertificateRequestSpec;

}

/**
 * Converts an object of type 'CertificateRequestProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateRequestProps(obj: CertificateRequestProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CertificateRequestSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specification of the desired state of the CertificateRequest resource.
 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
 *
 * @schema CertificateRequestSpec
 */
export interface CertificateRequestSpec {
  /**
   * Requested 'duration' (i.e. lifetime) of the Certificate. Note that the
   * issuer may choose to ignore the requested duration, just like any other
   * requested attribute.
   *
   * @schema CertificateRequestSpec#duration
   */
  readonly duration?: string;

  /**
   * Extra contains extra attributes of the user that created the CertificateRequest.
   * Populated by the cert-manager webhook on creation and immutable.
   *
   * @schema CertificateRequestSpec#extra
   */
  readonly extra?: { [key: string]: string[] };

  /**
   * Groups contains group membership of the user that created the CertificateRequest.
   * Populated by the cert-manager webhook on creation and immutable.
   *
   * @schema CertificateRequestSpec#groups
   */
  readonly groups?: string[];

  /**
   * Requested basic constraints isCA value. Note that the issuer may choose
   * to ignore the requested isCA value, just like any other requested attribute.
   *
   * NOTE: If the CSR in the `Request` field has a BasicConstraints extension,
   * it must have the same isCA value as specified here.
   *
   * If true, this will automatically add the `cert sign` usage to the list
   * of requested `usages`.
   *
   * @schema CertificateRequestSpec#isCA
   */
  readonly isCa?: boolean;

  /**
   * Reference to the issuer responsible for issuing the certificate.
   * If the issuer is namespace-scoped, it must be in the same namespace
   * as the Certificate. If the issuer is cluster-scoped, it can be used
   * from any namespace.
   *
   * The `name` field of the reference must always be specified.
   *
   * @schema CertificateRequestSpec#issuerRef
   */
  readonly issuerRef: CertificateRequestSpecIssuerRef;

  /**
   * The PEM-encoded X.509 certificate signing request to be submitted to the
   * issuer for signing.
   *
   * If the CSR has a BasicConstraints extension, its isCA attribute must
   * match the `isCA` value of this CertificateRequest.
   * If the CSR has a KeyUsage extension, its key usages must match the
   * key usages in the `usages` field of this CertificateRequest.
   * If the CSR has a ExtKeyUsage extension, its extended key usages
   * must match the extended key usages in the `usages` field of this
   * CertificateRequest.
   *
   * @schema CertificateRequestSpec#request
   */
  readonly request: string;

  /**
   * UID contains the uid of the user that created the CertificateRequest.
   * Populated by the cert-manager webhook on creation and immutable.
   *
   * @schema CertificateRequestSpec#uid
   */
  readonly uid?: string;

  /**
   * Requested key usages and extended key usages.
   *
   * NOTE: If the CSR in the `Request` field has uses the KeyUsage or
   * ExtKeyUsage extension, these extensions must have the same values
   * as specified here without any additional values.
   *
   * If unset, defaults to `digital signature` and `key encipherment`.
   *
   * @schema CertificateRequestSpec#usages
   */
  readonly usages?: CertificateRequestSpecUsages[];

  /**
   * Username contains the name of the user that created the CertificateRequest.
   * Populated by the cert-manager webhook on creation and immutable.
   *
   * @schema CertificateRequestSpec#username
   */
  readonly username?: string;

}

/**
 * Converts an object of type 'CertificateRequestSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateRequestSpec(obj: CertificateRequestSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'duration': obj.duration,
    'extra': ((obj.extra) === undefined) ? undefined : (Object.entries(obj.extra).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.map(y => y) }), {})),
    'groups': obj.groups?.map(y => y),
    'isCA': obj.isCa,
    'issuerRef': toJson_CertificateRequestSpecIssuerRef(obj.issuerRef),
    'request': obj.request,
    'uid': obj.uid,
    'usages': obj.usages?.map(y => y),
    'username': obj.username,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to the issuer responsible for issuing the certificate.
 * If the issuer is namespace-scoped, it must be in the same namespace
 * as the Certificate. If the issuer is cluster-scoped, it can be used
 * from any namespace.
 *
 * The `name` field of the reference must always be specified.
 *
 * @schema CertificateRequestSpecIssuerRef
 */
export interface CertificateRequestSpecIssuerRef {
  /**
   * Group of the resource being referred to.
   *
   * @schema CertificateRequestSpecIssuerRef#group
   */
  readonly group?: string;

  /**
   * Kind of the resource being referred to.
   *
   * @schema CertificateRequestSpecIssuerRef#kind
   */
  readonly kind?: string;

  /**
   * Name of the resource being referred to.
   *
   * @schema CertificateRequestSpecIssuerRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CertificateRequestSpecIssuerRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateRequestSpecIssuerRef(obj: CertificateRequestSpecIssuerRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * KeyUsage specifies valid usage contexts for keys.
 * See:
 * https://tools.ietf.org/html/rfc5280#section-4.2.1.3
 * https://tools.ietf.org/html/rfc5280#section-4.2.1.12
 *
 * Valid KeyUsage values are as follows:
 * "signing",
 * "digital signature",
 * "content commitment",
 * "key encipherment",
 * "key agreement",
 * "data encipherment",
 * "cert sign",
 * "crl sign",
 * "encipher only",
 * "decipher only",
 * "any",
 * "server auth",
 * "client auth",
 * "code signing",
 * "email protection",
 * "s/mime",
 * "ipsec end system",
 * "ipsec tunnel",
 * "ipsec user",
 * "timestamping",
 * "ocsp signing",
 * "microsoft sgc",
 * "netscape sgc"
 *
 * @schema CertificateRequestSpecUsages
 */
export enum CertificateRequestSpecUsages {
  /** signing */
  SIGNING = "signing",
  /** digital signature */
  DIGITAL_SIGNATURE = "digital signature",
  /** content commitment */
  CONTENT_COMMITMENT = "content commitment",
  /** key encipherment */
  KEY_ENCIPHERMENT = "key encipherment",
  /** key agreement */
  KEY_AGREEMENT = "key agreement",
  /** data encipherment */
  DATA_ENCIPHERMENT = "data encipherment",
  /** cert sign */
  CERT_SIGN = "cert sign",
  /** crl sign */
  CRL_SIGN = "crl sign",
  /** encipher only */
  ENCIPHER_ONLY = "encipher only",
  /** decipher only */
  DECIPHER_ONLY = "decipher only",
  /** any */
  ANY = "any",
  /** server auth */
  SERVER_AUTH = "server auth",
  /** client auth */
  CLIENT_AUTH = "client auth",
  /** code signing */
  CODE_SIGNING = "code signing",
  /** email protection */
  EMAIL_PROTECTION = "email protection",
  /** s/mime */
  S_FORWARD_SLASH_MIME = "s/mime",
  /** ipsec end system */
  IPSEC_END_SYSTEM = "ipsec end system",
  /** ipsec tunnel */
  IPSEC_TUNNEL = "ipsec tunnel",
  /** ipsec user */
  IPSEC_USER = "ipsec user",
  /** timestamping */
  TIMESTAMPING = "timestamping",
  /** ocsp signing */
  OCSP_SIGNING = "ocsp signing",
  /** microsoft sgc */
  MICROSOFT_SGC = "microsoft sgc",
  /** netscape sgc */
  NETSCAPE_SGC = "netscape sgc",
}

