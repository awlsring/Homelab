// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Probe defines monitoring for a set of static targets or ingresses.
 *
 * @schema Probe
 */
export class Probe extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Probe"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'monitoring.coreos.com/v1',
    kind: 'Probe',
  }

  /**
   * Renders a Kubernetes manifest for "Probe".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ProbeProps): any {
    return {
      ...Probe.GVK,
      ...toJson_ProbeProps(props),
    };
  }

  /**
   * Defines a "Probe" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ProbeProps) {
    super(scope, id, {
      ...Probe.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Probe.GVK,
      ...toJson_ProbeProps(resolved),
    };
  }
}

/**
 * Probe defines monitoring for a set of static targets or ingresses.
 *
 * @schema Probe
 */
export interface ProbeProps {
  /**
   * @schema Probe#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Specification of desired Ingress selection for target discovery by Prometheus.
   *
   * @schema Probe#spec
   */
  readonly spec: ProbeSpec;

}

/**
 * Converts an object of type 'ProbeProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProbeProps(obj: ProbeProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ProbeSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specification of desired Ingress selection for target discovery by Prometheus.
 *
 * @schema ProbeSpec
 */
export interface ProbeSpec {
  /**
   * Authorization section for this endpoint
   *
   * @schema ProbeSpec#authorization
   */
  readonly authorization?: ProbeSpecAuthorization;

  /**
   * BasicAuth allow an endpoint to authenticate over basic authentication.
   * More info: https://prometheus.io/docs/operating/configuration/#endpoint
   *
   * @schema ProbeSpec#basicAuth
   */
  readonly basicAuth?: ProbeSpecBasicAuth;

  /**
   * Secret to mount to read bearer token for scraping targets. The secret
   * needs to be in the same namespace as the probe and accessible by
   * the Prometheus Operator.
   *
   * @schema ProbeSpec#bearerTokenSecret
   */
  readonly bearerTokenSecret?: ProbeSpecBearerTokenSecret;

  /**
   * Interval at which targets are probed using the configured prober.
   * If not specified Prometheus' global scrape interval is used.
   *
   * @schema ProbeSpec#interval
   */
  readonly interval?: string;

  /**
   * The job name assigned to scraped metrics by default.
   *
   * @schema ProbeSpec#jobName
   */
  readonly jobName?: string;

  /**
   * Per-scrape limit on the number of targets dropped by relabeling
   * that will be kept in memory. 0 means no limit.
   *
   *
   * It requires Prometheus >= v2.47.0.
   *
   * @schema ProbeSpec#keepDroppedTargets
   */
  readonly keepDroppedTargets?: number;

  /**
   * Per-scrape limit on number of labels that will be accepted for a sample.
   * Only valid in Prometheus versions 2.27.0 and newer.
   *
   * @schema ProbeSpec#labelLimit
   */
  readonly labelLimit?: number;

  /**
   * Per-scrape limit on length of labels name that will be accepted for a sample.
   * Only valid in Prometheus versions 2.27.0 and newer.
   *
   * @schema ProbeSpec#labelNameLengthLimit
   */
  readonly labelNameLengthLimit?: number;

  /**
   * Per-scrape limit on length of labels value that will be accepted for a sample.
   * Only valid in Prometheus versions 2.27.0 and newer.
   *
   * @schema ProbeSpec#labelValueLengthLimit
   */
  readonly labelValueLengthLimit?: number;

  /**
   * MetricRelabelConfigs to apply to samples before ingestion.
   *
   * @schema ProbeSpec#metricRelabelings
   */
  readonly metricRelabelings?: ProbeSpecMetricRelabelings[];

  /**
   * The module to use for probing specifying how to probe the target.
   * Example module configuring in the blackbox exporter:
   * https://github.com/prometheus/blackbox_exporter/blob/master/example.yml
   *
   * @schema ProbeSpec#module
   */
  readonly module?: string;

  /**
   * OAuth2 for the URL. Only valid in Prometheus versions 2.27.0 and newer.
   *
   * @schema ProbeSpec#oauth2
   */
  readonly oauth2?: ProbeSpecOauth2;

  /**
   * Specification for the prober to use for probing targets.
   * The prober.URL parameter is required. Targets cannot be probed if left empty.
   *
   * @schema ProbeSpec#prober
   */
  readonly prober?: ProbeSpecProber;

  /**
   * SampleLimit defines per-scrape limit on number of scraped samples that will be accepted.
   *
   * @schema ProbeSpec#sampleLimit
   */
  readonly sampleLimit?: number;

  /**
   * The scrape class to apply.
   *
   * @schema ProbeSpec#scrapeClass
   */
  readonly scrapeClass?: string;

  /**
   * `scrapeProtocols` defines the protocols to negotiate during a scrape. It tells clients the
   * protocols supported by Prometheus in order of preference (from most to least preferred).
   *
   *
   * If unset, Prometheus uses its default value.
   *
   *
   * It requires Prometheus >= v2.49.0.
   *
   * @schema ProbeSpec#scrapeProtocols
   */
  readonly scrapeProtocols?: ProbeSpecScrapeProtocols[];

  /**
   * Timeout for scraping metrics from the Prometheus exporter.
   * If not specified, the Prometheus global scrape timeout is used.
   *
   * @schema ProbeSpec#scrapeTimeout
   */
  readonly scrapeTimeout?: string;

  /**
   * TargetLimit defines a limit on the number of scraped targets that will be accepted.
   *
   * @schema ProbeSpec#targetLimit
   */
  readonly targetLimit?: number;

  /**
   * Targets defines a set of static or dynamically discovered targets to probe.
   *
   * @schema ProbeSpec#targets
   */
  readonly targets?: ProbeSpecTargets;

  /**
   * TLS configuration to use when scraping the endpoint.
   *
   * @schema ProbeSpec#tlsConfig
   */
  readonly tlsConfig?: ProbeSpecTlsConfig;

}

/**
 * Converts an object of type 'ProbeSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProbeSpec(obj: ProbeSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authorization': toJson_ProbeSpecAuthorization(obj.authorization),
    'basicAuth': toJson_ProbeSpecBasicAuth(obj.basicAuth),
    'bearerTokenSecret': toJson_ProbeSpecBearerTokenSecret(obj.bearerTokenSecret),
    'interval': obj.interval,
    'jobName': obj.jobName,
    'keepDroppedTargets': obj.keepDroppedTargets,
    'labelLimit': obj.labelLimit,
    'labelNameLengthLimit': obj.labelNameLengthLimit,
    'labelValueLengthLimit': obj.labelValueLengthLimit,
    'metricRelabelings': obj.metricRelabelings?.map(y => toJson_ProbeSpecMetricRelabelings(y)),
    'module': obj.module,
    'oauth2': toJson_ProbeSpecOauth2(obj.oauth2),
    'prober': toJson_ProbeSpecProber(obj.prober),
    'sampleLimit': obj.sampleLimit,
    'scrapeClass': obj.scrapeClass,
    'scrapeProtocols': obj.scrapeProtocols?.map(y => y),
    'scrapeTimeout': obj.scrapeTimeout,
    'targetLimit': obj.targetLimit,
    'targets': toJson_ProbeSpecTargets(obj.targets),
    'tlsConfig': toJson_ProbeSpecTlsConfig(obj.tlsConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Authorization section for this endpoint
 *
 * @schema ProbeSpecAuthorization
 */
export interface ProbeSpecAuthorization {
  /**
   * Selects a key of a Secret in the namespace that contains the credentials for authentication.
   *
   * @schema ProbeSpecAuthorization#credentials
   */
  readonly credentials?: ProbeSpecAuthorizationCredentials;

  /**
   * Defines the authentication type. The value is case-insensitive.
   *
   *
   * "Basic" is not a supported value.
   *
   *
   * Default: "Bearer"
   *
   * @schema ProbeSpecAuthorization#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ProbeSpecAuthorization' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProbeSpecAuthorization(obj: ProbeSpecAuthorization | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentials': toJson_ProbeSpecAuthorizationCredentials(obj.credentials),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BasicAuth allow an endpoint to authenticate over basic authentication.
 * More info: https://prometheus.io/docs/operating/configuration/#endpoint
 *
 * @schema ProbeSpecBasicAuth
 */
export interface ProbeSpecBasicAuth {
  /**
   * `password` specifies a key of a Secret containing the password for
   * authentication.
   *
   * @schema ProbeSpecBasicAuth#password
   */
  readonly password?: ProbeSpecBasicAuthPassword;

  /**
   * `username` specifies a key of a Secret containing the username for
   * authentication.
   *
   * @schema ProbeSpecBasicAuth#username
   */
  readonly username?: ProbeSpecBasicAuthUsername;

}

/**
 * Converts an object of type 'ProbeSpecBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProbeSpecBasicAuth(obj: ProbeSpecBasicAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_ProbeSpecBasicAuthPassword(obj.password),
    'username': toJson_ProbeSpecBasicAuthUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret to mount to read bearer token for scraping targets. The secret
 * needs to be in the same namespace as the probe and accessible by
 * the Prometheus Operator.
 *
 * @schema ProbeSpecBearerTokenSecret
 */
export interface ProbeSpecBearerTokenSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ProbeSpecBearerTokenSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ProbeSpecBearerTokenSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ProbeSpecBearerTokenSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ProbeSpecBearerTokenSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProbeSpecBearerTokenSecret(obj: ProbeSpecBearerTokenSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RelabelConfig allows dynamic rewriting of the label set for targets, alerts,
 * scraped samples and remote write samples.
 *
 *
 * More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
 *
 * @schema ProbeSpecMetricRelabelings
 */
export interface ProbeSpecMetricRelabelings {
  /**
   * Action to perform based on the regex matching.
   *
   *
   * `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0.
   * `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.
   *
   *
   * Default: "Replace"
   *
   * @schema ProbeSpecMetricRelabelings#action
   */
  readonly action?: ProbeSpecMetricRelabelingsAction;

  /**
   * Modulus to take of the hash of the source label values.
   *
   *
   * Only applicable when the action is `HashMod`.
   *
   * @schema ProbeSpecMetricRelabelings#modulus
   */
  readonly modulus?: number;

  /**
   * Regular expression against which the extracted value is matched.
   *
   * @schema ProbeSpecMetricRelabelings#regex
   */
  readonly regex?: string;

  /**
   * Replacement value against which a Replace action is performed if the
   * regular expression matches.
   *
   *
   * Regex capture groups are available.
   *
   * @schema ProbeSpecMetricRelabelings#replacement
   */
  readonly replacement?: string;

  /**
   * Separator is the string between concatenated SourceLabels.
   *
   * @schema ProbeSpecMetricRelabelings#separator
   */
  readonly separator?: string;

  /**
   * The source labels select values from existing labels. Their content is
   * concatenated using the configured Separator and matched against the
   * configured regular expression.
   *
   * @schema ProbeSpecMetricRelabelings#sourceLabels
   */
  readonly sourceLabels?: string[];

  /**
   * Label to which the resulting string is written in a replacement.
   *
   *
   * It is mandatory for `Replace`, `HashMod`, `Lowercase`, `Uppercase`,
   * `KeepEqual` and `DropEqual` actions.
   *
   *
   * Regex capture groups are available.
   *
   * @schema ProbeSpecMetricRelabelings#targetLabel
   */
  readonly targetLabel?: string;

}

/**
 * Converts an object of type 'ProbeSpecMetricRelabelings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProbeSpecMetricRelabelings(obj: ProbeSpecMetricRelabelings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'modulus': obj.modulus,
    'regex': obj.regex,
    'replacement': obj.replacement,
    'separator': obj.separator,
    'sourceLabels': obj.sourceLabels?.map(y => y),
    'targetLabel': obj.targetLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * OAuth2 for the URL. Only valid in Prometheus versions 2.27.0 and newer.
 *
 * @schema ProbeSpecOauth2
 */
export interface ProbeSpecOauth2 {
  /**
   * `clientId` specifies a key of a Secret or ConfigMap containing the
   * OAuth2 client's ID.
   *
   * @schema ProbeSpecOauth2#clientId
   */
  readonly clientId: ProbeSpecOauth2ClientId;

  /**
   * `clientSecret` specifies a key of a Secret containing the OAuth2
   * client's secret.
   *
   * @schema ProbeSpecOauth2#clientSecret
   */
  readonly clientSecret: ProbeSpecOauth2ClientSecret;

  /**
   * `endpointParams` configures the HTTP parameters to append to the token
   * URL.
   *
   * @schema ProbeSpecOauth2#endpointParams
   */
  readonly endpointParams?: { [key: string]: string };

  /**
   * `scopes` defines the OAuth2 scopes used for the token request.
   *
   * @schema ProbeSpecOauth2#scopes
   */
  readonly scopes?: string[];

  /**
   * `tokenURL` configures the URL to fetch the token from.
   *
   * @schema ProbeSpecOauth2#tokenUrl
   */
  readonly tokenUrl: string;

}

/**
 * Converts an object of type 'ProbeSpecOauth2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProbeSpecOauth2(obj: ProbeSpecOauth2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientId': toJson_ProbeSpecOauth2ClientId(obj.clientId),
    'clientSecret': toJson_ProbeSpecOauth2ClientSecret(obj.clientSecret),
    'endpointParams': ((obj.endpointParams) === undefined) ? undefined : (Object.entries(obj.endpointParams).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'scopes': obj.scopes?.map(y => y),
    'tokenUrl': obj.tokenUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specification for the prober to use for probing targets.
 * The prober.URL parameter is required. Targets cannot be probed if left empty.
 *
 * @schema ProbeSpecProber
 */
export interface ProbeSpecProber {
  /**
   * Path to collect metrics from.
   * Defaults to `/probe`.
   *
   * @default probe`.
   * @schema ProbeSpecProber#path
   */
  readonly path?: string;

  /**
   * Optional ProxyURL.
   *
   * @schema ProbeSpecProber#proxyUrl
   */
  readonly proxyUrl?: string;

  /**
   * HTTP scheme to use for scraping.
   * `http` and `https` are the expected values unless you rewrite the `__scheme__` label via relabeling.
   * If empty, Prometheus uses the default value `http`.
   *
   * @schema ProbeSpecProber#scheme
   */
  readonly scheme?: ProbeSpecProberScheme;

  /**
   * Mandatory URL of the prober.
   *
   * @schema ProbeSpecProber#url
   */
  readonly url: string;

}

/**
 * Converts an object of type 'ProbeSpecProber' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProbeSpecProber(obj: ProbeSpecProber | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'proxyUrl': obj.proxyUrl,
    'scheme': obj.scheme,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ScrapeProtocol represents a protocol used by Prometheus for scraping metrics.
 * Supported values are:
 * * `OpenMetricsText0.0.1`
 * * `OpenMetricsText1.0.0`
 * * `PrometheusProto`
 * * `PrometheusText0.0.4`
 *
 * @schema ProbeSpecScrapeProtocols
 */
export enum ProbeSpecScrapeProtocols {
  /** PrometheusProto */
  PROMETHEUS_PROTO = "PrometheusProto",
  /** OpenMetricsText0.0.1 */
  OPEN_METRICS_TEXT0_0_1 = "OpenMetricsText0.0.1",
  /** OpenMetricsText1.0.0 */
  OPEN_METRICS_TEXT1_0_0 = "OpenMetricsText1.0.0",
  /** PrometheusText0.0.4 */
  PROMETHEUS_TEXT0_0_4 = "PrometheusText0.0.4",
}

/**
 * Targets defines a set of static or dynamically discovered targets to probe.
 *
 * @schema ProbeSpecTargets
 */
export interface ProbeSpecTargets {
  /**
   * ingress defines the Ingress objects to probe and the relabeling
   * configuration.
   * If `staticConfig` is also defined, `staticConfig` takes precedence.
   *
   * @schema ProbeSpecTargets#ingress
   */
  readonly ingress?: ProbeSpecTargetsIngress;

  /**
   * staticConfig defines the static list of targets to probe and the
   * relabeling configuration.
   * If `ingress` is also defined, `staticConfig` takes precedence.
   * More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#static_config.
   *
   * @schema ProbeSpecTargets#staticConfig
   */
  readonly staticConfig?: ProbeSpecTargetsStaticConfig;

}

/**
 * Converts an object of type 'ProbeSpecTargets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProbeSpecTargets(obj: ProbeSpecTargets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ingress': toJson_ProbeSpecTargetsIngress(obj.ingress),
    'staticConfig': toJson_ProbeSpecTargetsStaticConfig(obj.staticConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLS configuration to use when scraping the endpoint.
 *
 * @schema ProbeSpecTlsConfig
 */
export interface ProbeSpecTlsConfig {
  /**
   * Certificate authority used when verifying server certificates.
   *
   * @schema ProbeSpecTlsConfig#ca
   */
  readonly ca?: ProbeSpecTlsConfigCa;

  /**
   * Client certificate to present when doing client-authentication.
   *
   * @schema ProbeSpecTlsConfig#cert
   */
  readonly cert?: ProbeSpecTlsConfigCert;

  /**
   * Disable target certificate validation.
   *
   * @schema ProbeSpecTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema ProbeSpecTlsConfig#keySecret
   */
  readonly keySecret?: ProbeSpecTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema ProbeSpecTlsConfig#serverName
   */
  readonly serverName?: string;

}

/**
 * Converts an object of type 'ProbeSpecTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProbeSpecTlsConfig(obj: ProbeSpecTlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ca': toJson_ProbeSpecTlsConfigCa(obj.ca),
    'cert': toJson_ProbeSpecTlsConfigCert(obj.cert),
    'insecureSkipVerify': obj.insecureSkipVerify,
    'keySecret': toJson_ProbeSpecTlsConfigKeySecret(obj.keySecret),
    'serverName': obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a Secret in the namespace that contains the credentials for authentication.
 *
 * @schema ProbeSpecAuthorizationCredentials
 */
export interface ProbeSpecAuthorizationCredentials {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ProbeSpecAuthorizationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ProbeSpecAuthorizationCredentials#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ProbeSpecAuthorizationCredentials#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ProbeSpecAuthorizationCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProbeSpecAuthorizationCredentials(obj: ProbeSpecAuthorizationCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `password` specifies a key of a Secret containing the password for
 * authentication.
 *
 * @schema ProbeSpecBasicAuthPassword
 */
export interface ProbeSpecBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ProbeSpecBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ProbeSpecBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ProbeSpecBasicAuthPassword#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ProbeSpecBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProbeSpecBasicAuthPassword(obj: ProbeSpecBasicAuthPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `username` specifies a key of a Secret containing the username for
 * authentication.
 *
 * @schema ProbeSpecBasicAuthUsername
 */
export interface ProbeSpecBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ProbeSpecBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ProbeSpecBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ProbeSpecBasicAuthUsername#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ProbeSpecBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProbeSpecBasicAuthUsername(obj: ProbeSpecBasicAuthUsername | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Action to perform based on the regex matching.
 *
 *
 * `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0.
 * `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.
 *
 *
 * Default: "Replace"
 *
 * @schema ProbeSpecMetricRelabelingsAction
 */
export enum ProbeSpecMetricRelabelingsAction {
  /** replace */
  REPLACE = "replace",
  /** keep */
  KEEP = "keep",
  /** drop */
  DROP = "drop",
  /** hashmod */
  HASHMOD = "hashmod",
  /** labelmap */
  LABELMAP = "labelmap",
  /** labeldrop */
  LABELDROP = "labeldrop",
  /** labelkeep */
  LABELKEEP = "labelkeep",
  /** lowercase */
  LOWERCASE = "lowercase",
  /** uppercase */
  UPPERCASE = "uppercase",
  /** keepequal */
  KEEPEQUAL = "keepequal",
  /** dropequal */
  DROPEQUAL = "dropequal",
}

/**
 * `clientId` specifies a key of a Secret or ConfigMap containing the
 * OAuth2 client's ID.
 *
 * @schema ProbeSpecOauth2ClientId
 */
export interface ProbeSpecOauth2ClientId {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema ProbeSpecOauth2ClientId#configMap
   */
  readonly configMap?: ProbeSpecOauth2ClientIdConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema ProbeSpecOauth2ClientId#secret
   */
  readonly secret?: ProbeSpecOauth2ClientIdSecret;

}

/**
 * Converts an object of type 'ProbeSpecOauth2ClientId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProbeSpecOauth2ClientId(obj: ProbeSpecOauth2ClientId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_ProbeSpecOauth2ClientIdConfigMap(obj.configMap),
    'secret': toJson_ProbeSpecOauth2ClientIdSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `clientSecret` specifies a key of a Secret containing the OAuth2
 * client's secret.
 *
 * @schema ProbeSpecOauth2ClientSecret
 */
export interface ProbeSpecOauth2ClientSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ProbeSpecOauth2ClientSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ProbeSpecOauth2ClientSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ProbeSpecOauth2ClientSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ProbeSpecOauth2ClientSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProbeSpecOauth2ClientSecret(obj: ProbeSpecOauth2ClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTP scheme to use for scraping.
 * `http` and `https` are the expected values unless you rewrite the `__scheme__` label via relabeling.
 * If empty, Prometheus uses the default value `http`.
 *
 * @schema ProbeSpecProberScheme
 */
export enum ProbeSpecProberScheme {
  /** http */
  HTTP = "http",
  /** https */
  HTTPS = "https",
}

/**
 * ingress defines the Ingress objects to probe and the relabeling
 * configuration.
 * If `staticConfig` is also defined, `staticConfig` takes precedence.
 *
 * @schema ProbeSpecTargetsIngress
 */
export interface ProbeSpecTargetsIngress {
  /**
   * From which namespaces to select Ingress objects.
   *
   * @schema ProbeSpecTargetsIngress#namespaceSelector
   */
  readonly namespaceSelector?: ProbeSpecTargetsIngressNamespaceSelector;

  /**
   * RelabelConfigs to apply to the label set of the target before it gets
   * scraped.
   * The original ingress address is available via the
   * `__tmp_prometheus_ingress_address` label. It can be used to customize the
   * probed URL.
   * The original scrape job's name is available via the `__tmp_prometheus_job_name` label.
   * More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
   *
   * @schema ProbeSpecTargetsIngress#relabelingConfigs
   */
  readonly relabelingConfigs?: ProbeSpecTargetsIngressRelabelingConfigs[];

  /**
   * Selector to select the Ingress objects.
   *
   * @schema ProbeSpecTargetsIngress#selector
   */
  readonly selector?: ProbeSpecTargetsIngressSelector;

}

/**
 * Converts an object of type 'ProbeSpecTargetsIngress' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProbeSpecTargetsIngress(obj: ProbeSpecTargetsIngress | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'namespaceSelector': toJson_ProbeSpecTargetsIngressNamespaceSelector(obj.namespaceSelector),
    'relabelingConfigs': obj.relabelingConfigs?.map(y => toJson_ProbeSpecTargetsIngressRelabelingConfigs(y)),
    'selector': toJson_ProbeSpecTargetsIngressSelector(obj.selector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * staticConfig defines the static list of targets to probe and the
 * relabeling configuration.
 * If `ingress` is also defined, `staticConfig` takes precedence.
 * More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#static_config.
 *
 * @schema ProbeSpecTargetsStaticConfig
 */
export interface ProbeSpecTargetsStaticConfig {
  /**
   * Labels assigned to all metrics scraped from the targets.
   *
   * @schema ProbeSpecTargetsStaticConfig#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * RelabelConfigs to apply to the label set of the targets before it gets
   * scraped.
   * More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
   *
   * @schema ProbeSpecTargetsStaticConfig#relabelingConfigs
   */
  readonly relabelingConfigs?: ProbeSpecTargetsStaticConfigRelabelingConfigs[];

  /**
   * The list of hosts to probe.
   *
   * @schema ProbeSpecTargetsStaticConfig#static
   */
  readonly static?: string[];

}

/**
 * Converts an object of type 'ProbeSpecTargetsStaticConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProbeSpecTargetsStaticConfig(obj: ProbeSpecTargetsStaticConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'relabelingConfigs': obj.relabelingConfigs?.map(y => toJson_ProbeSpecTargetsStaticConfigRelabelingConfigs(y)),
    'static': obj.static?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Certificate authority used when verifying server certificates.
 *
 * @schema ProbeSpecTlsConfigCa
 */
export interface ProbeSpecTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema ProbeSpecTlsConfigCa#configMap
   */
  readonly configMap?: ProbeSpecTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema ProbeSpecTlsConfigCa#secret
   */
  readonly secret?: ProbeSpecTlsConfigCaSecret;

}

/**
 * Converts an object of type 'ProbeSpecTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProbeSpecTlsConfigCa(obj: ProbeSpecTlsConfigCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_ProbeSpecTlsConfigCaConfigMap(obj.configMap),
    'secret': toJson_ProbeSpecTlsConfigCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Client certificate to present when doing client-authentication.
 *
 * @schema ProbeSpecTlsConfigCert
 */
export interface ProbeSpecTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema ProbeSpecTlsConfigCert#configMap
   */
  readonly configMap?: ProbeSpecTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema ProbeSpecTlsConfigCert#secret
   */
  readonly secret?: ProbeSpecTlsConfigCertSecret;

}

/**
 * Converts an object of type 'ProbeSpecTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProbeSpecTlsConfigCert(obj: ProbeSpecTlsConfigCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_ProbeSpecTlsConfigCertConfigMap(obj.configMap),
    'secret': toJson_ProbeSpecTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema ProbeSpecTlsConfigKeySecret
 */
export interface ProbeSpecTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ProbeSpecTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ProbeSpecTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ProbeSpecTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ProbeSpecTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProbeSpecTlsConfigKeySecret(obj: ProbeSpecTlsConfigKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema ProbeSpecOauth2ClientIdConfigMap
 */
export interface ProbeSpecOauth2ClientIdConfigMap {
  /**
   * The key to select.
   *
   * @schema ProbeSpecOauth2ClientIdConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ProbeSpecOauth2ClientIdConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema ProbeSpecOauth2ClientIdConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ProbeSpecOauth2ClientIdConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProbeSpecOauth2ClientIdConfigMap(obj: ProbeSpecOauth2ClientIdConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema ProbeSpecOauth2ClientIdSecret
 */
export interface ProbeSpecOauth2ClientIdSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ProbeSpecOauth2ClientIdSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ProbeSpecOauth2ClientIdSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ProbeSpecOauth2ClientIdSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ProbeSpecOauth2ClientIdSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProbeSpecOauth2ClientIdSecret(obj: ProbeSpecOauth2ClientIdSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * From which namespaces to select Ingress objects.
 *
 * @schema ProbeSpecTargetsIngressNamespaceSelector
 */
export interface ProbeSpecTargetsIngressNamespaceSelector {
  /**
   * Boolean describing whether all namespaces are selected in contrast to a
   * list restricting them.
   *
   * @schema ProbeSpecTargetsIngressNamespaceSelector#any
   */
  readonly any?: boolean;

  /**
   * List of namespace names to select from.
   *
   * @schema ProbeSpecTargetsIngressNamespaceSelector#matchNames
   */
  readonly matchNames?: string[];

}

/**
 * Converts an object of type 'ProbeSpecTargetsIngressNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProbeSpecTargetsIngressNamespaceSelector(obj: ProbeSpecTargetsIngressNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'any': obj.any,
    'matchNames': obj.matchNames?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RelabelConfig allows dynamic rewriting of the label set for targets, alerts,
 * scraped samples and remote write samples.
 *
 *
 * More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
 *
 * @schema ProbeSpecTargetsIngressRelabelingConfigs
 */
export interface ProbeSpecTargetsIngressRelabelingConfigs {
  /**
   * Action to perform based on the regex matching.
   *
   *
   * `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0.
   * `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.
   *
   *
   * Default: "Replace"
   *
   * @schema ProbeSpecTargetsIngressRelabelingConfigs#action
   */
  readonly action?: ProbeSpecTargetsIngressRelabelingConfigsAction;

  /**
   * Modulus to take of the hash of the source label values.
   *
   *
   * Only applicable when the action is `HashMod`.
   *
   * @schema ProbeSpecTargetsIngressRelabelingConfigs#modulus
   */
  readonly modulus?: number;

  /**
   * Regular expression against which the extracted value is matched.
   *
   * @schema ProbeSpecTargetsIngressRelabelingConfigs#regex
   */
  readonly regex?: string;

  /**
   * Replacement value against which a Replace action is performed if the
   * regular expression matches.
   *
   *
   * Regex capture groups are available.
   *
   * @schema ProbeSpecTargetsIngressRelabelingConfigs#replacement
   */
  readonly replacement?: string;

  /**
   * Separator is the string between concatenated SourceLabels.
   *
   * @schema ProbeSpecTargetsIngressRelabelingConfigs#separator
   */
  readonly separator?: string;

  /**
   * The source labels select values from existing labels. Their content is
   * concatenated using the configured Separator and matched against the
   * configured regular expression.
   *
   * @schema ProbeSpecTargetsIngressRelabelingConfigs#sourceLabels
   */
  readonly sourceLabels?: string[];

  /**
   * Label to which the resulting string is written in a replacement.
   *
   *
   * It is mandatory for `Replace`, `HashMod`, `Lowercase`, `Uppercase`,
   * `KeepEqual` and `DropEqual` actions.
   *
   *
   * Regex capture groups are available.
   *
   * @schema ProbeSpecTargetsIngressRelabelingConfigs#targetLabel
   */
  readonly targetLabel?: string;

}

/**
 * Converts an object of type 'ProbeSpecTargetsIngressRelabelingConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProbeSpecTargetsIngressRelabelingConfigs(obj: ProbeSpecTargetsIngressRelabelingConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'modulus': obj.modulus,
    'regex': obj.regex,
    'replacement': obj.replacement,
    'separator': obj.separator,
    'sourceLabels': obj.sourceLabels?.map(y => y),
    'targetLabel': obj.targetLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector to select the Ingress objects.
 *
 * @schema ProbeSpecTargetsIngressSelector
 */
export interface ProbeSpecTargetsIngressSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ProbeSpecTargetsIngressSelector#matchExpressions
   */
  readonly matchExpressions?: ProbeSpecTargetsIngressSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ProbeSpecTargetsIngressSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ProbeSpecTargetsIngressSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProbeSpecTargetsIngressSelector(obj: ProbeSpecTargetsIngressSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ProbeSpecTargetsIngressSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RelabelConfig allows dynamic rewriting of the label set for targets, alerts,
 * scraped samples and remote write samples.
 *
 *
 * More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
 *
 * @schema ProbeSpecTargetsStaticConfigRelabelingConfigs
 */
export interface ProbeSpecTargetsStaticConfigRelabelingConfigs {
  /**
   * Action to perform based on the regex matching.
   *
   *
   * `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0.
   * `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.
   *
   *
   * Default: "Replace"
   *
   * @schema ProbeSpecTargetsStaticConfigRelabelingConfigs#action
   */
  readonly action?: ProbeSpecTargetsStaticConfigRelabelingConfigsAction;

  /**
   * Modulus to take of the hash of the source label values.
   *
   *
   * Only applicable when the action is `HashMod`.
   *
   * @schema ProbeSpecTargetsStaticConfigRelabelingConfigs#modulus
   */
  readonly modulus?: number;

  /**
   * Regular expression against which the extracted value is matched.
   *
   * @schema ProbeSpecTargetsStaticConfigRelabelingConfigs#regex
   */
  readonly regex?: string;

  /**
   * Replacement value against which a Replace action is performed if the
   * regular expression matches.
   *
   *
   * Regex capture groups are available.
   *
   * @schema ProbeSpecTargetsStaticConfigRelabelingConfigs#replacement
   */
  readonly replacement?: string;

  /**
   * Separator is the string between concatenated SourceLabels.
   *
   * @schema ProbeSpecTargetsStaticConfigRelabelingConfigs#separator
   */
  readonly separator?: string;

  /**
   * The source labels select values from existing labels. Their content is
   * concatenated using the configured Separator and matched against the
   * configured regular expression.
   *
   * @schema ProbeSpecTargetsStaticConfigRelabelingConfigs#sourceLabels
   */
  readonly sourceLabels?: string[];

  /**
   * Label to which the resulting string is written in a replacement.
   *
   *
   * It is mandatory for `Replace`, `HashMod`, `Lowercase`, `Uppercase`,
   * `KeepEqual` and `DropEqual` actions.
   *
   *
   * Regex capture groups are available.
   *
   * @schema ProbeSpecTargetsStaticConfigRelabelingConfigs#targetLabel
   */
  readonly targetLabel?: string;

}

/**
 * Converts an object of type 'ProbeSpecTargetsStaticConfigRelabelingConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProbeSpecTargetsStaticConfigRelabelingConfigs(obj: ProbeSpecTargetsStaticConfigRelabelingConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'modulus': obj.modulus,
    'regex': obj.regex,
    'replacement': obj.replacement,
    'separator': obj.separator,
    'sourceLabels': obj.sourceLabels?.map(y => y),
    'targetLabel': obj.targetLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema ProbeSpecTlsConfigCaConfigMap
 */
export interface ProbeSpecTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema ProbeSpecTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ProbeSpecTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema ProbeSpecTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ProbeSpecTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProbeSpecTlsConfigCaConfigMap(obj: ProbeSpecTlsConfigCaConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema ProbeSpecTlsConfigCaSecret
 */
export interface ProbeSpecTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ProbeSpecTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ProbeSpecTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ProbeSpecTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ProbeSpecTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProbeSpecTlsConfigCaSecret(obj: ProbeSpecTlsConfigCaSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema ProbeSpecTlsConfigCertConfigMap
 */
export interface ProbeSpecTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema ProbeSpecTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ProbeSpecTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema ProbeSpecTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ProbeSpecTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProbeSpecTlsConfigCertConfigMap(obj: ProbeSpecTlsConfigCertConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema ProbeSpecTlsConfigCertSecret
 */
export interface ProbeSpecTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ProbeSpecTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ProbeSpecTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ProbeSpecTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ProbeSpecTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProbeSpecTlsConfigCertSecret(obj: ProbeSpecTlsConfigCertSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Action to perform based on the regex matching.
 *
 *
 * `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0.
 * `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.
 *
 *
 * Default: "Replace"
 *
 * @schema ProbeSpecTargetsIngressRelabelingConfigsAction
 */
export enum ProbeSpecTargetsIngressRelabelingConfigsAction {
  /** replace */
  REPLACE = "replace",
  /** keep */
  KEEP = "keep",
  /** drop */
  DROP = "drop",
  /** hashmod */
  HASHMOD = "hashmod",
  /** labelmap */
  LABELMAP = "labelmap",
  /** labeldrop */
  LABELDROP = "labeldrop",
  /** labelkeep */
  LABELKEEP = "labelkeep",
  /** lowercase */
  LOWERCASE = "lowercase",
  /** uppercase */
  UPPERCASE = "uppercase",
  /** keepequal */
  KEEPEQUAL = "keepequal",
  /** dropequal */
  DROPEQUAL = "dropequal",
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ProbeSpecTargetsIngressSelectorMatchExpressions
 */
export interface ProbeSpecTargetsIngressSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ProbeSpecTargetsIngressSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ProbeSpecTargetsIngressSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ProbeSpecTargetsIngressSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ProbeSpecTargetsIngressSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProbeSpecTargetsIngressSelectorMatchExpressions(obj: ProbeSpecTargetsIngressSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Action to perform based on the regex matching.
 *
 *
 * `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0.
 * `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.
 *
 *
 * Default: "Replace"
 *
 * @schema ProbeSpecTargetsStaticConfigRelabelingConfigsAction
 */
export enum ProbeSpecTargetsStaticConfigRelabelingConfigsAction {
  /** replace */
  REPLACE = "replace",
  /** keep */
  KEEP = "keep",
  /** drop */
  DROP = "drop",
  /** hashmod */
  HASHMOD = "hashmod",
  /** labelmap */
  LABELMAP = "labelmap",
  /** labeldrop */
  LABELDROP = "labeldrop",
  /** labelkeep */
  LABELKEEP = "labelkeep",
  /** lowercase */
  LOWERCASE = "lowercase",
  /** uppercase */
  UPPERCASE = "uppercase",
  /** keepequal */
  KEEPEQUAL = "keepequal",
  /** dropequal */
  DROPEQUAL = "dropequal",
}

