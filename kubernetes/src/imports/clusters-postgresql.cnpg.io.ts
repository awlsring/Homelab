// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Cluster is the Schema for the PostgreSQL API
 *
 * @schema Cluster
 */
export class Cluster extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Cluster"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'postgresql.cnpg.io/v1',
    kind: 'Cluster',
  }

  /**
   * Renders a Kubernetes manifest for "Cluster".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ClusterProps): any {
    return {
      ...Cluster.GVK,
      ...toJson_ClusterProps(props),
    };
  }

  /**
   * Defines a "Cluster" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ClusterProps) {
    super(scope, id, {
      ...Cluster.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Cluster.GVK,
      ...toJson_ClusterProps(resolved),
    };
  }
}

/**
 * Cluster is the Schema for the PostgreSQL API
 *
 * @schema Cluster
 */
export interface ClusterProps {
  /**
   * @schema Cluster#metadata
   */
  readonly metadata: ApiObjectMetadata;

  /**
   * Specification of the desired behavior of the cluster.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
   *
   * @schema Cluster#spec
   */
  readonly spec: ClusterSpec;

}

/**
 * Converts an object of type 'ClusterProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterProps(obj: ClusterProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ClusterSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specification of the desired behavior of the cluster.
 * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
 *
 * @schema ClusterSpec
 */
export interface ClusterSpec {
  /**
   * Affinity/Anti-affinity rules for Pods
   *
   * @schema ClusterSpec#affinity
   */
  readonly affinity?: ClusterSpecAffinity;

  /**
   * The configuration to be used for backups
   *
   * @schema ClusterSpec#backup
   */
  readonly backup?: ClusterSpecBackup;

  /**
   * Instructions to bootstrap this cluster
   *
   * @schema ClusterSpec#bootstrap
   */
  readonly bootstrap?: ClusterSpecBootstrap;

  /**
   * The configuration for the CA and related certificates
   *
   * @schema ClusterSpec#certificates
   */
  readonly certificates?: ClusterSpecCertificates;

  /**
   * Description of this PostgreSQL cluster
   *
   * @schema ClusterSpec#description
   */
  readonly description?: string;

  /**
   * Manage the `PodDisruptionBudget` resources within the cluster. When
   * configured as `true` (default setting), the pod disruption budgets
   * will safeguard the primary node from being terminated. Conversely,
   * setting it to `false` will result in the absence of any
   * `PodDisruptionBudget` resource, permitting the shutdown of all nodes
   * hosting the PostgreSQL cluster. This latter configuration is
   * advisable for any PostgreSQL cluster employed for
   * development/staging purposes.
   *
   * @schema ClusterSpec#enablePDB
   */
  readonly enablePdb?: boolean;

  /**
   * When this option is enabled, the operator will use the `SuperuserSecret`
   * to update the `postgres` user password (if the secret is
   * not present, the operator will automatically create one). When this
   * option is disabled, the operator will ignore the `SuperuserSecret` content, delete
   * it when automatically created, and then blank the password of the `postgres`
   * user by setting it to `NULL`. Disabled by default.
   *
   * @schema ClusterSpec#enableSuperuserAccess
   */
  readonly enableSuperuserAccess?: boolean;

  /**
   * Env follows the Env format to pass environment variables
   * to the pods created in the cluster
   *
   * @schema ClusterSpec#env
   */
  readonly env?: ClusterSpecEnv[];

  /**
   * EnvFrom follows the EnvFrom format to pass environment variables
   * sources to the pods to be used by Env
   *
   * @schema ClusterSpec#envFrom
   */
  readonly envFrom?: ClusterSpecEnvFrom[];

  /**
   * EphemeralVolumeSource allows the user to configure the source of ephemeral volumes.
   *
   * @schema ClusterSpec#ephemeralVolumeSource
   */
  readonly ephemeralVolumeSource?: ClusterSpecEphemeralVolumeSource;

  /**
   * EphemeralVolumesSizeLimit allows the user to set the limits for the ephemeral
   * volumes
   *
   * @schema ClusterSpec#ephemeralVolumesSizeLimit
   */
  readonly ephemeralVolumesSizeLimit?: ClusterSpecEphemeralVolumesSizeLimit;

  /**
   * The list of external clusters which are used in the configuration
   *
   * @schema ClusterSpec#externalClusters
   */
  readonly externalClusters?: ClusterSpecExternalClusters[];

  /**
   * The amount of time (in seconds) to wait before triggering a failover
   * after the primary PostgreSQL instance in the cluster was detected
   * to be unhealthy
   *
   * @schema ClusterSpec#failoverDelay
   */
  readonly failoverDelay?: number;

  /**
   * Defines the major PostgreSQL version we want to use within an ImageCatalog
   *
   * @schema ClusterSpec#imageCatalogRef
   */
  readonly imageCatalogRef?: ClusterSpecImageCatalogRef;

  /**
   * Name of the container image, supporting both tags (`<image>:<tag>`)
   * and digests for deterministic and repeatable deployments
   * (`<image>:<tag>@sha256:<digestValue>`)
   *
   * @schema ClusterSpec#imageName
   */
  readonly imageName?: string;

  /**
   * Image pull policy.
   * One of `Always`, `Never` or `IfNotPresent`.
   * If not defined, it defaults to `IfNotPresent`.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   *
   * @schema ClusterSpec#imagePullPolicy
   */
  readonly imagePullPolicy?: string;

  /**
   * The list of pull secrets to be used to pull the images
   *
   * @schema ClusterSpec#imagePullSecrets
   */
  readonly imagePullSecrets?: ClusterSpecImagePullSecrets[];

  /**
   * Metadata that will be inherited by all objects related to the Cluster
   *
   * @schema ClusterSpec#inheritedMetadata
   */
  readonly inheritedMetadata?: ClusterSpecInheritedMetadata;

  /**
   * Number of instances required in the cluster
   *
   * @schema ClusterSpec#instances
   */
  readonly instances: number;

  /**
   * The instances' log level, one of the following values: error, warning, info (default), debug, trace
   *
   * @schema ClusterSpec#logLevel
   */
  readonly logLevel?: ClusterSpecLogLevel;

  /**
   * The configuration that is used by the portions of PostgreSQL that are managed by the instance manager
   *
   * @schema ClusterSpec#managed
   */
  readonly managed?: ClusterSpecManaged;

  /**
   * The target value for the synchronous replication quorum, that can be
   * decreased if the number of ready standbys is lower than this.
   * Undefined or 0 disable synchronous replication.
   *
   * @schema ClusterSpec#maxSyncReplicas
   */
  readonly maxSyncReplicas?: number;

  /**
   * Minimum number of instances required in synchronous replication with the
   * primary. Undefined or 0 allow writes to complete when no standby is
   * available.
   *
   * @schema ClusterSpec#minSyncReplicas
   */
  readonly minSyncReplicas?: number;

  /**
   * The configuration of the monitoring infrastructure of this cluster
   *
   * @schema ClusterSpec#monitoring
   */
  readonly monitoring?: ClusterSpecMonitoring;

  /**
   * Define a maintenance window for the Kubernetes nodes
   *
   * @schema ClusterSpec#nodeMaintenanceWindow
   */
  readonly nodeMaintenanceWindow?: ClusterSpecNodeMaintenanceWindow;

  /**
   * The plugins configuration, containing
   * any plugin to be loaded with the corresponding configuration
   *
   * @schema ClusterSpec#plugins
   */
  readonly plugins?: ClusterSpecPlugins[];

  /**
   * The GID of the `postgres` user inside the image, defaults to `26`
   *
   * @schema ClusterSpec#postgresGID
   */
  readonly postgresGid?: number;

  /**
   * The UID of the `postgres` user inside the image, defaults to `26`
   *
   * @schema ClusterSpec#postgresUID
   */
  readonly postgresUid?: number;

  /**
   * Configuration of the PostgreSQL server
   *
   * @schema ClusterSpec#postgresql
   */
  readonly postgresql?: ClusterSpecPostgresql;

  /**
   * Method to follow to upgrade the primary server during a rolling
   * update procedure, after all replicas have been successfully updated:
   * it can be with a switchover (`switchover`) or in-place (`restart` - default)
   *
   * @schema ClusterSpec#primaryUpdateMethod
   */
  readonly primaryUpdateMethod?: ClusterSpecPrimaryUpdateMethod;

  /**
   * Deployment strategy to follow to upgrade the primary server during a rolling
   * update procedure, after all replicas have been successfully updated:
   * it can be automated (`unsupervised` - default) or manual (`supervised`)
   *
   * @schema ClusterSpec#primaryUpdateStrategy
   */
  readonly primaryUpdateStrategy?: ClusterSpecPrimaryUpdateStrategy;

  /**
   * Name of the priority class which will be used in every generated Pod, if the PriorityClass
   * specified does not exist, the pod will not be able to schedule.  Please refer to
   * https://kubernetes.io/docs/concepts/scheduling-eviction/pod-priority-preemption/#priorityclass
   * for more information
   *
   * @schema ClusterSpec#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * Template to be used to define projected volumes, projected volumes will be mounted
   * under `/projected` base folder
   *
   * @schema ClusterSpec#projectedVolumeTemplate
   */
  readonly projectedVolumeTemplate?: ClusterSpecProjectedVolumeTemplate;

  /**
   * Replica cluster configuration
   *
   * @schema ClusterSpec#replica
   */
  readonly replica?: ClusterSpecReplica;

  /**
   * Replication slots management configuration
   *
   * @schema ClusterSpec#replicationSlots
   */
  readonly replicationSlots?: ClusterSpecReplicationSlots;

  /**
   * Resources requirements of every generated Pod. Please refer to
   * https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   * for more information.
   *
   * @schema ClusterSpec#resources
   */
  readonly resources?: ClusterSpecResources;

  /**
   * If specified, the pod will be dispatched by specified Kubernetes
   * scheduler. If not specified, the pod will be dispatched by the default
   * scheduler. More info:
   * https://kubernetes.io/docs/concepts/scheduling-eviction/kube-scheduler/
   *
   * @schema ClusterSpec#schedulerName
   */
  readonly schedulerName?: string;

  /**
   * The SeccompProfile applied to every Pod and Container.
   * Defaults to: `RuntimeDefault`
   *
   * @default RuntimeDefault`
   * @schema ClusterSpec#seccompProfile
   */
  readonly seccompProfile?: ClusterSpecSeccompProfile;

  /**
   * Configure the generation of the service account
   *
   * @schema ClusterSpec#serviceAccountTemplate
   */
  readonly serviceAccountTemplate?: ClusterSpecServiceAccountTemplate;

  /**
   * The time in seconds that controls the window of time reserved for the smart shutdown of Postgres to complete.
   * Make sure you reserve enough time for the operator to request a fast shutdown of Postgres
   * (that is: `stopDelay` - `smartShutdownTimeout`).
   *
   * @schema ClusterSpec#smartShutdownTimeout
   */
  readonly smartShutdownTimeout?: number;

  /**
   * The time in seconds that is allowed for a PostgreSQL instance to
   * successfully start up (default 3600).
   * The startup probe failure threshold is derived from this value using the formula:
   * ceiling(startDelay / 10).
   *
   * @schema ClusterSpec#startDelay
   */
  readonly startDelay?: number;

  /**
   * The time in seconds that is allowed for a PostgreSQL instance to
   * gracefully shutdown (default 1800)
   *
   * @schema ClusterSpec#stopDelay
   */
  readonly stopDelay?: number;

  /**
   * Configuration of the storage of the instances
   *
   * @schema ClusterSpec#storage
   */
  readonly storage?: ClusterSpecStorage;

  /**
   * The secret containing the superuser password. If not defined a new
   * secret will be created with a randomly generated password
   *
   * @schema ClusterSpec#superuserSecret
   */
  readonly superuserSecret?: ClusterSpecSuperuserSecret;

  /**
   * The time in seconds that is allowed for a primary PostgreSQL instance
   * to gracefully shutdown during a switchover.
   * Default value is 3600 seconds (1 hour).
   *
   * @schema ClusterSpec#switchoverDelay
   */
  readonly switchoverDelay?: number;

  /**
   * The tablespaces configuration
   *
   * @schema ClusterSpec#tablespaces
   */
  readonly tablespaces?: ClusterSpecTablespaces[];

  /**
   * TopologySpreadConstraints specifies how to spread matching pods among the given topology.
   * More info:
   * https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/
   *
   * @schema ClusterSpec#topologySpreadConstraints
   */
  readonly topologySpreadConstraints?: ClusterSpecTopologySpreadConstraints[];

  /**
   * Configuration of the storage for PostgreSQL WAL (Write-Ahead Log)
   *
   * @schema ClusterSpec#walStorage
   */
  readonly walStorage?: ClusterSpecWalStorage;

}

/**
 * Converts an object of type 'ClusterSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpec(obj: ClusterSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'affinity': toJson_ClusterSpecAffinity(obj.affinity),
    'backup': toJson_ClusterSpecBackup(obj.backup),
    'bootstrap': toJson_ClusterSpecBootstrap(obj.bootstrap),
    'certificates': toJson_ClusterSpecCertificates(obj.certificates),
    'description': obj.description,
    'enablePDB': obj.enablePdb,
    'enableSuperuserAccess': obj.enableSuperuserAccess,
    'env': obj.env?.map(y => toJson_ClusterSpecEnv(y)),
    'envFrom': obj.envFrom?.map(y => toJson_ClusterSpecEnvFrom(y)),
    'ephemeralVolumeSource': toJson_ClusterSpecEphemeralVolumeSource(obj.ephemeralVolumeSource),
    'ephemeralVolumesSizeLimit': toJson_ClusterSpecEphemeralVolumesSizeLimit(obj.ephemeralVolumesSizeLimit),
    'externalClusters': obj.externalClusters?.map(y => toJson_ClusterSpecExternalClusters(y)),
    'failoverDelay': obj.failoverDelay,
    'imageCatalogRef': toJson_ClusterSpecImageCatalogRef(obj.imageCatalogRef),
    'imageName': obj.imageName,
    'imagePullPolicy': obj.imagePullPolicy,
    'imagePullSecrets': obj.imagePullSecrets?.map(y => toJson_ClusterSpecImagePullSecrets(y)),
    'inheritedMetadata': toJson_ClusterSpecInheritedMetadata(obj.inheritedMetadata),
    'instances': obj.instances,
    'logLevel': obj.logLevel,
    'managed': toJson_ClusterSpecManaged(obj.managed),
    'maxSyncReplicas': obj.maxSyncReplicas,
    'minSyncReplicas': obj.minSyncReplicas,
    'monitoring': toJson_ClusterSpecMonitoring(obj.monitoring),
    'nodeMaintenanceWindow': toJson_ClusterSpecNodeMaintenanceWindow(obj.nodeMaintenanceWindow),
    'plugins': obj.plugins?.map(y => toJson_ClusterSpecPlugins(y)),
    'postgresGID': obj.postgresGid,
    'postgresUID': obj.postgresUid,
    'postgresql': toJson_ClusterSpecPostgresql(obj.postgresql),
    'primaryUpdateMethod': obj.primaryUpdateMethod,
    'primaryUpdateStrategy': obj.primaryUpdateStrategy,
    'priorityClassName': obj.priorityClassName,
    'projectedVolumeTemplate': toJson_ClusterSpecProjectedVolumeTemplate(obj.projectedVolumeTemplate),
    'replica': toJson_ClusterSpecReplica(obj.replica),
    'replicationSlots': toJson_ClusterSpecReplicationSlots(obj.replicationSlots),
    'resources': toJson_ClusterSpecResources(obj.resources),
    'schedulerName': obj.schedulerName,
    'seccompProfile': toJson_ClusterSpecSeccompProfile(obj.seccompProfile),
    'serviceAccountTemplate': toJson_ClusterSpecServiceAccountTemplate(obj.serviceAccountTemplate),
    'smartShutdownTimeout': obj.smartShutdownTimeout,
    'startDelay': obj.startDelay,
    'stopDelay': obj.stopDelay,
    'storage': toJson_ClusterSpecStorage(obj.storage),
    'superuserSecret': toJson_ClusterSpecSuperuserSecret(obj.superuserSecret),
    'switchoverDelay': obj.switchoverDelay,
    'tablespaces': obj.tablespaces?.map(y => toJson_ClusterSpecTablespaces(y)),
    'topologySpreadConstraints': obj.topologySpreadConstraints?.map(y => toJson_ClusterSpecTopologySpreadConstraints(y)),
    'walStorage': toJson_ClusterSpecWalStorage(obj.walStorage),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Affinity/Anti-affinity rules for Pods
 *
 * @schema ClusterSpecAffinity
 */
export interface ClusterSpecAffinity {
  /**
   * AdditionalPodAffinity allows to specify pod affinity terms to be passed to all the cluster's pods.
   *
   * @schema ClusterSpecAffinity#additionalPodAffinity
   */
  readonly additionalPodAffinity?: ClusterSpecAffinityAdditionalPodAffinity;

  /**
   * AdditionalPodAntiAffinity allows to specify pod anti-affinity terms to be added to the ones generated
   * by the operator if EnablePodAntiAffinity is set to true (default) or to be used exclusively if set to false.
   *
   * @schema ClusterSpecAffinity#additionalPodAntiAffinity
   */
  readonly additionalPodAntiAffinity?: ClusterSpecAffinityAdditionalPodAntiAffinity;

  /**
   * Activates anti-affinity for the pods. The operator will define pods
   * anti-affinity unless this field is explicitly set to false
   *
   * @schema ClusterSpecAffinity#enablePodAntiAffinity
   */
  readonly enablePodAntiAffinity?: boolean;

  /**
   * NodeAffinity describes node affinity scheduling rules for the pod.
   * More info: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#node-affinity
   *
   * @schema ClusterSpecAffinity#nodeAffinity
   */
  readonly nodeAffinity?: ClusterSpecAffinityNodeAffinity;

  /**
   * NodeSelector is map of key-value pairs used to define the nodes on which
   * the pods can run.
   * More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
   *
   * @schema ClusterSpecAffinity#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * PodAntiAffinityType allows the user to decide whether pod anti-affinity between cluster instance has to be
   * considered a strong requirement during scheduling or not. Allowed values are: "preferred" (default if empty) or
   * "required". Setting it to "required", could lead to instances remaining pending until new kubernetes nodes are
   * added if all the existing nodes don't match the required pod anti-affinity rule.
   * More info:
   * https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#inter-pod-affinity-and-anti-affinity
   *
   * @schema ClusterSpecAffinity#podAntiAffinityType
   */
  readonly podAntiAffinityType?: string;

  /**
   * Tolerations is a list of Tolerations that should be set for all the pods, in order to allow them to run
   * on tainted nodes.
   * More info: https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
   *
   * @schema ClusterSpecAffinity#tolerations
   */
  readonly tolerations?: ClusterSpecAffinityTolerations[];

  /**
   * TopologyKey to use for anti-affinity configuration. See k8s documentation
   * for more info on that
   *
   * @schema ClusterSpecAffinity#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * Converts an object of type 'ClusterSpecAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecAffinity(obj: ClusterSpecAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalPodAffinity': toJson_ClusterSpecAffinityAdditionalPodAffinity(obj.additionalPodAffinity),
    'additionalPodAntiAffinity': toJson_ClusterSpecAffinityAdditionalPodAntiAffinity(obj.additionalPodAntiAffinity),
    'enablePodAntiAffinity': obj.enablePodAntiAffinity,
    'nodeAffinity': toJson_ClusterSpecAffinityNodeAffinity(obj.nodeAffinity),
    'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'podAntiAffinityType': obj.podAntiAffinityType,
    'tolerations': obj.tolerations?.map(y => toJson_ClusterSpecAffinityTolerations(y)),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The configuration to be used for backups
 *
 * @schema ClusterSpecBackup
 */
export interface ClusterSpecBackup {
  /**
   * The configuration for the barman-cloud tool suite
   *
   * @schema ClusterSpecBackup#barmanObjectStore
   */
  readonly barmanObjectStore?: ClusterSpecBackupBarmanObjectStore;

  /**
   * RetentionPolicy is the retention policy to be used for backups
   * and WALs (i.e. '60d'). The retention policy is expressed in the form
   * of `XXu` where `XX` is a positive integer and `u` is in `[dwm]` -
   * days, weeks, months.
   * It's currently only applicable when using the BarmanObjectStore method.
   *
   * @schema ClusterSpecBackup#retentionPolicy
   */
  readonly retentionPolicy?: string;

  /**
   * The policy to decide which instance should perform backups. Available
   * options are empty string, which will default to `prefer-standby` policy,
   * `primary` to have backups run always on primary instances, `prefer-standby`
   * to have backups run preferably on the most updated standby, if available.
   *
   * @schema ClusterSpecBackup#target
   */
  readonly target?: ClusterSpecBackupTarget;

  /**
   * VolumeSnapshot provides the configuration for the execution of volume snapshot backups.
   *
   * @schema ClusterSpecBackup#volumeSnapshot
   */
  readonly volumeSnapshot?: ClusterSpecBackupVolumeSnapshot;

}

/**
 * Converts an object of type 'ClusterSpecBackup' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecBackup(obj: ClusterSpecBackup | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'barmanObjectStore': toJson_ClusterSpecBackupBarmanObjectStore(obj.barmanObjectStore),
    'retentionPolicy': obj.retentionPolicy,
    'target': obj.target,
    'volumeSnapshot': toJson_ClusterSpecBackupVolumeSnapshot(obj.volumeSnapshot),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Instructions to bootstrap this cluster
 *
 * @schema ClusterSpecBootstrap
 */
export interface ClusterSpecBootstrap {
  /**
   * Bootstrap the cluster via initdb
   *
   * @schema ClusterSpecBootstrap#initdb
   */
  readonly initdb?: ClusterSpecBootstrapInitdb;

  /**
   * Bootstrap the cluster taking a physical backup of another compatible
   * PostgreSQL instance
   *
   * @schema ClusterSpecBootstrap#pg_basebackup
   */
  readonly pgBasebackup?: ClusterSpecBootstrapPgBasebackup;

  /**
   * Bootstrap the cluster from a backup
   *
   * @schema ClusterSpecBootstrap#recovery
   */
  readonly recovery?: ClusterSpecBootstrapRecovery;

}

/**
 * Converts an object of type 'ClusterSpecBootstrap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecBootstrap(obj: ClusterSpecBootstrap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'initdb': toJson_ClusterSpecBootstrapInitdb(obj.initdb),
    'pg_basebackup': toJson_ClusterSpecBootstrapPgBasebackup(obj.pgBasebackup),
    'recovery': toJson_ClusterSpecBootstrapRecovery(obj.recovery),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The configuration for the CA and related certificates
 *
 * @schema ClusterSpecCertificates
 */
export interface ClusterSpecCertificates {
  /**
   * The secret containing the Client CA certificate. If not defined, a new secret will be created
   * with a self-signed CA and will be used to generate all the client certificates.<br />
   * <br />
   * Contains:<br />
   * <br />
   * - `ca.crt`: CA that should be used to validate the client certificates,
   * used as `ssl_ca_file` of all the instances.<br />
   * - `ca.key`: key used to generate client certificates, if ReplicationTLSSecret is provided,
   * this can be omitted.<br />
   *
   * @schema ClusterSpecCertificates#clientCASecret
   */
  readonly clientCaSecret?: string;

  /**
   * The secret of type kubernetes.io/tls containing the client certificate to authenticate as
   * the `streaming_replica` user.
   * If not defined, ClientCASecret must provide also `ca.key`, and a new secret will be
   * created using the provided CA.
   *
   * @schema ClusterSpecCertificates#replicationTLSSecret
   */
  readonly replicationTlsSecret?: string;

  /**
   * The list of the server alternative DNS names to be added to the generated server TLS certificates, when required.
   *
   * @schema ClusterSpecCertificates#serverAltDNSNames
   */
  readonly serverAltDnsNames?: string[];

  /**
   * The secret containing the Server CA certificate. If not defined, a new secret will be created
   * with a self-signed CA and will be used to generate the TLS certificate ServerTLSSecret.<br />
   * <br />
   * Contains:<br />
   * <br />
   * - `ca.crt`: CA that should be used to validate the server certificate,
   * used as `sslrootcert` in client connection strings.<br />
   * - `ca.key`: key used to generate Server SSL certs, if ServerTLSSecret is provided,
   * this can be omitted.<br />
   *
   * @schema ClusterSpecCertificates#serverCASecret
   */
  readonly serverCaSecret?: string;

  /**
   * The secret of type kubernetes.io/tls containing the server TLS certificate and key that will be set as
   * `ssl_cert_file` and `ssl_key_file` so that clients can connect to postgres securely.
   * If not defined, ServerCASecret must provide also `ca.key` and a new secret will be
   * created using the provided CA.
   *
   * @schema ClusterSpecCertificates#serverTLSSecret
   */
  readonly serverTlsSecret?: string;

}

/**
 * Converts an object of type 'ClusterSpecCertificates' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecCertificates(obj: ClusterSpecCertificates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientCASecret': obj.clientCaSecret,
    'replicationTLSSecret': obj.replicationTlsSecret,
    'serverAltDNSNames': obj.serverAltDnsNames?.map(y => y),
    'serverCASecret': obj.serverCaSecret,
    'serverTLSSecret': obj.serverTlsSecret,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema ClusterSpecEnv
 */
export interface ClusterSpecEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema ClusterSpecEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded
   * using the previously defined environment variables in the container and
   * any service environment variables. If a variable cannot be resolved,
   * the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
   * "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
   * Escaped references will never be expanded, regardless of whether the variable
   * exists or not.
   * Defaults to "".
   *
   * @default .
   * @schema ClusterSpecEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema ClusterSpecEnv#valueFrom
   */
  readonly valueFrom?: ClusterSpecEnvValueFrom;

}

/**
 * Converts an object of type 'ClusterSpecEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecEnv(obj: ClusterSpecEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
    'valueFrom': toJson_ClusterSpecEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema ClusterSpecEnvFrom
 */
export interface ClusterSpecEnvFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema ClusterSpecEnvFrom#configMapRef
   */
  readonly configMapRef?: ClusterSpecEnvFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema ClusterSpecEnvFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema ClusterSpecEnvFrom#secretRef
   */
  readonly secretRef?: ClusterSpecEnvFromSecretRef;

}

/**
 * Converts an object of type 'ClusterSpecEnvFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecEnvFrom(obj: ClusterSpecEnvFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapRef': toJson_ClusterSpecEnvFromConfigMapRef(obj.configMapRef),
    'prefix': obj.prefix,
    'secretRef': toJson_ClusterSpecEnvFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EphemeralVolumeSource allows the user to configure the source of ephemeral volumes.
 *
 * @schema ClusterSpecEphemeralVolumeSource
 */
export interface ClusterSpecEphemeralVolumeSource {
  /**
   * Will be used to create a stand-alone PVC to provision the volume.
   * The pod in which this EphemeralVolumeSource is embedded will be the
   * owner of the PVC, i.e. the PVC will be deleted together with the
   * pod.  The name of the PVC will be `<pod name>-<volume name>` where
   * `<volume name>` is the name from the `PodSpec.Volumes` array
   * entry. Pod validation will reject the pod if the concatenated name
   * is not valid for a PVC (for example, too long).
   *
   *
   * An existing PVC with that name that is not owned by the pod
   * will *not* be used for the pod to avoid using an unrelated
   * volume by mistake. Starting the pod is then blocked until
   * the unrelated PVC is removed. If such a pre-created PVC is
   * meant to be used by the pod, the PVC has to updated with an
   * owner reference to the pod once the pod exists. Normally
   * this should not be necessary, but it may be useful when
   * manually reconstructing a broken cluster.
   *
   *
   * This field is read-only and no changes will be made by Kubernetes
   * to the PVC after it has been created.
   *
   *
   * Required, must not be nil.
   *
   * @schema ClusterSpecEphemeralVolumeSource#volumeClaimTemplate
   */
  readonly volumeClaimTemplate?: ClusterSpecEphemeralVolumeSourceVolumeClaimTemplate;

}

/**
 * Converts an object of type 'ClusterSpecEphemeralVolumeSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecEphemeralVolumeSource(obj: ClusterSpecEphemeralVolumeSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'volumeClaimTemplate': toJson_ClusterSpecEphemeralVolumeSourceVolumeClaimTemplate(obj.volumeClaimTemplate),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EphemeralVolumesSizeLimit allows the user to set the limits for the ephemeral
 * volumes
 *
 * @schema ClusterSpecEphemeralVolumesSizeLimit
 */
export interface ClusterSpecEphemeralVolumesSizeLimit {
  /**
   * Shm is the size limit of the shared memory volume
   *
   * @schema ClusterSpecEphemeralVolumesSizeLimit#shm
   */
  readonly shm?: ClusterSpecEphemeralVolumesSizeLimitShm;

  /**
   * TemporaryData is the size limit of the temporary data volume
   *
   * @schema ClusterSpecEphemeralVolumesSizeLimit#temporaryData
   */
  readonly temporaryData?: ClusterSpecEphemeralVolumesSizeLimitTemporaryData;

}

/**
 * Converts an object of type 'ClusterSpecEphemeralVolumesSizeLimit' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecEphemeralVolumesSizeLimit(obj: ClusterSpecEphemeralVolumesSizeLimit | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'shm': obj.shm?.value,
    'temporaryData': obj.temporaryData?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ExternalCluster represents the connection parameters to an
 * external cluster which is used in the other sections of the configuration
 *
 * @schema ClusterSpecExternalClusters
 */
export interface ClusterSpecExternalClusters {
  /**
   * The configuration for the barman-cloud tool suite
   *
   * @schema ClusterSpecExternalClusters#barmanObjectStore
   */
  readonly barmanObjectStore?: ClusterSpecExternalClustersBarmanObjectStore;

  /**
   * The list of connection parameters, such as dbname, host, username, etc
   *
   * @schema ClusterSpecExternalClusters#connectionParameters
   */
  readonly connectionParameters?: { [key: string]: string };

  /**
   * The server name, required
   *
   * @schema ClusterSpecExternalClusters#name
   */
  readonly name: string;

  /**
   * The reference to the password to be used to connect to the server.
   * If a password is provided, CloudNativePG creates a PostgreSQL
   * passfile at `/controller/external/NAME/pass` (where "NAME" is the
   * cluster's name). This passfile is automatically referenced in the
   * connection string when establishing a connection to the remote
   * PostgreSQL server from the current PostgreSQL `Cluster`. This ensures
   * secure and efficient password management for external clusters.
   *
   * @schema ClusterSpecExternalClusters#password
   */
  readonly password?: ClusterSpecExternalClustersPassword;

  /**
   * The reference to an SSL certificate to be used to connect to this
   * instance
   *
   * @schema ClusterSpecExternalClusters#sslCert
   */
  readonly sslCert?: ClusterSpecExternalClustersSslCert;

  /**
   * The reference to an SSL private key to be used to connect to this
   * instance
   *
   * @schema ClusterSpecExternalClusters#sslKey
   */
  readonly sslKey?: ClusterSpecExternalClustersSslKey;

  /**
   * The reference to an SSL CA public key to be used to connect to this
   * instance
   *
   * @schema ClusterSpecExternalClusters#sslRootCert
   */
  readonly sslRootCert?: ClusterSpecExternalClustersSslRootCert;

}

/**
 * Converts an object of type 'ClusterSpecExternalClusters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecExternalClusters(obj: ClusterSpecExternalClusters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'barmanObjectStore': toJson_ClusterSpecExternalClustersBarmanObjectStore(obj.barmanObjectStore),
    'connectionParameters': ((obj.connectionParameters) === undefined) ? undefined : (Object.entries(obj.connectionParameters).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
    'password': toJson_ClusterSpecExternalClustersPassword(obj.password),
    'sslCert': toJson_ClusterSpecExternalClustersSslCert(obj.sslCert),
    'sslKey': toJson_ClusterSpecExternalClustersSslKey(obj.sslKey),
    'sslRootCert': toJson_ClusterSpecExternalClustersSslRootCert(obj.sslRootCert),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Defines the major PostgreSQL version we want to use within an ImageCatalog
 *
 * @schema ClusterSpecImageCatalogRef
 */
export interface ClusterSpecImageCatalogRef {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema ClusterSpecImageCatalogRef#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema ClusterSpecImageCatalogRef#kind
   */
  readonly kind: string;

  /**
   * The major version of PostgreSQL we want to use from the ImageCatalog
   *
   * @schema ClusterSpecImageCatalogRef#major
   */
  readonly major: number;

  /**
   * Name is the name of resource being referenced
   *
   * @schema ClusterSpecImageCatalogRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterSpecImageCatalogRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecImageCatalogRef(obj: ClusterSpecImageCatalogRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'major': obj.major,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LocalObjectReference contains enough information to let you locate a
 * local object with a known type inside the same namespace
 *
 * @schema ClusterSpecImagePullSecrets
 */
export interface ClusterSpecImagePullSecrets {
  /**
   * Name of the referent.
   *
   * @schema ClusterSpecImagePullSecrets#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterSpecImagePullSecrets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecImagePullSecrets(obj: ClusterSpecImagePullSecrets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata that will be inherited by all objects related to the Cluster
 *
 * @schema ClusterSpecInheritedMetadata
 */
export interface ClusterSpecInheritedMetadata {
  /**
   * @schema ClusterSpecInheritedMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * @schema ClusterSpecInheritedMetadata#labels
   */
  readonly labels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterSpecInheritedMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecInheritedMetadata(obj: ClusterSpecInheritedMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The instances' log level, one of the following values: error, warning, info (default), debug, trace
 *
 * @schema ClusterSpecLogLevel
 */
export enum ClusterSpecLogLevel {
  /** error */
  ERROR = "error",
  /** warning */
  WARNING = "warning",
  /** info */
  INFO = "info",
  /** debug */
  DEBUG = "debug",
  /** trace */
  TRACE = "trace",
}

/**
 * The configuration that is used by the portions of PostgreSQL that are managed by the instance manager
 *
 * @schema ClusterSpecManaged
 */
export interface ClusterSpecManaged {
  /**
   * Database roles managed by the `Cluster`
   *
   * @schema ClusterSpecManaged#roles
   */
  readonly roles?: ClusterSpecManagedRoles[];

}

/**
 * Converts an object of type 'ClusterSpecManaged' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecManaged(obj: ClusterSpecManaged | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'roles': obj.roles?.map(y => toJson_ClusterSpecManagedRoles(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The configuration of the monitoring infrastructure of this cluster
 *
 * @schema ClusterSpecMonitoring
 */
export interface ClusterSpecMonitoring {
  /**
   * The list of config maps containing the custom queries
   *
   * @schema ClusterSpecMonitoring#customQueriesConfigMap
   */
  readonly customQueriesConfigMap?: ClusterSpecMonitoringCustomQueriesConfigMap[];

  /**
   * The list of secrets containing the custom queries
   *
   * @schema ClusterSpecMonitoring#customQueriesSecret
   */
  readonly customQueriesSecret?: ClusterSpecMonitoringCustomQueriesSecret[];

  /**
   * Whether the default queries should be injected.
   * Set it to `true` if you don't want to inject default queries into the cluster.
   * Default: false.
   *
   * @schema ClusterSpecMonitoring#disableDefaultQueries
   */
  readonly disableDefaultQueries?: boolean;

  /**
   * Enable or disable the `PodMonitor`
   *
   * @schema ClusterSpecMonitoring#enablePodMonitor
   */
  readonly enablePodMonitor?: boolean;

  /**
   * The list of metric relabelings for the `PodMonitor`. Applied to samples before ingestion.
   *
   * @schema ClusterSpecMonitoring#podMonitorMetricRelabelings
   */
  readonly podMonitorMetricRelabelings?: ClusterSpecMonitoringPodMonitorMetricRelabelings[];

  /**
   * The list of relabelings for the `PodMonitor`. Applied to samples before scraping.
   *
   * @schema ClusterSpecMonitoring#podMonitorRelabelings
   */
  readonly podMonitorRelabelings?: ClusterSpecMonitoringPodMonitorRelabelings[];

}

/**
 * Converts an object of type 'ClusterSpecMonitoring' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecMonitoring(obj: ClusterSpecMonitoring | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customQueriesConfigMap': obj.customQueriesConfigMap?.map(y => toJson_ClusterSpecMonitoringCustomQueriesConfigMap(y)),
    'customQueriesSecret': obj.customQueriesSecret?.map(y => toJson_ClusterSpecMonitoringCustomQueriesSecret(y)),
    'disableDefaultQueries': obj.disableDefaultQueries,
    'enablePodMonitor': obj.enablePodMonitor,
    'podMonitorMetricRelabelings': obj.podMonitorMetricRelabelings?.map(y => toJson_ClusterSpecMonitoringPodMonitorMetricRelabelings(y)),
    'podMonitorRelabelings': obj.podMonitorRelabelings?.map(y => toJson_ClusterSpecMonitoringPodMonitorRelabelings(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Define a maintenance window for the Kubernetes nodes
 *
 * @schema ClusterSpecNodeMaintenanceWindow
 */
export interface ClusterSpecNodeMaintenanceWindow {
  /**
   * Is there a node maintenance activity in progress?
   *
   * @schema ClusterSpecNodeMaintenanceWindow#inProgress
   */
  readonly inProgress?: boolean;

  /**
   * Reuse the existing PVC (wait for the node to come
   * up again) or not (recreate it elsewhere - when `instances` >1)
   *
   * @schema ClusterSpecNodeMaintenanceWindow#reusePVC
   */
  readonly reusePvc?: boolean;

}

/**
 * Converts an object of type 'ClusterSpecNodeMaintenanceWindow' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecNodeMaintenanceWindow(obj: ClusterSpecNodeMaintenanceWindow | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'inProgress': obj.inProgress,
    'reusePVC': obj.reusePvc,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PluginConfiguration specifies a plugin that need to be loaded for this
 * cluster to be reconciled
 *
 * @schema ClusterSpecPlugins
 */
export interface ClusterSpecPlugins {
  /**
   * Name is the plugin name
   *
   * @schema ClusterSpecPlugins#name
   */
  readonly name: string;

  /**
   * Parameters is the configuration of the plugin
   *
   * @schema ClusterSpecPlugins#parameters
   */
  readonly parameters?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterSpecPlugins' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecPlugins(obj: ClusterSpecPlugins | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'parameters': ((obj.parameters) === undefined) ? undefined : (Object.entries(obj.parameters).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configuration of the PostgreSQL server
 *
 * @schema ClusterSpecPostgresql
 */
export interface ClusterSpecPostgresql {
  /**
   * If this parameter is true, the user will be able to invoke `ALTER SYSTEM`
   * on this CloudNativePG Cluster.
   * This should only be used for debugging and troubleshooting.
   * Defaults to false.
   *
   * @default false.
   * @schema ClusterSpecPostgresql#enableAlterSystem
   */
  readonly enableAlterSystem?: boolean;

  /**
   * Options to specify LDAP configuration
   *
   * @schema ClusterSpecPostgresql#ldap
   */
  readonly ldap?: ClusterSpecPostgresqlLdap;

  /**
   * PostgreSQL configuration options (postgresql.conf)
   *
   * @schema ClusterSpecPostgresql#parameters
   */
  readonly parameters?: { [key: string]: string };

  /**
   * PostgreSQL Host Based Authentication rules (lines to be appended
   * to the pg_hba.conf file)
   *
   * @schema ClusterSpecPostgresql#pg_hba
   */
  readonly pgHba?: string[];

  /**
   * PostgreSQL User Name Maps rules (lines to be appended
   * to the pg_ident.conf file)
   *
   * @schema ClusterSpecPostgresql#pg_ident
   */
  readonly pgIdent?: string[];

  /**
   * Specifies the maximum number of seconds to wait when promoting an instance to primary.
   * Default value is 40000000, greater than one year in seconds,
   * big enough to simulate an infinite timeout
   *
   * @schema ClusterSpecPostgresql#promotionTimeout
   */
  readonly promotionTimeout?: number;

  /**
   * Lists of shared preload libraries to add to the default ones
   *
   * @schema ClusterSpecPostgresql#shared_preload_libraries
   */
  readonly sharedPreloadLibraries?: string[];

  /**
   * Requirements to be met by sync replicas. This will affect how the "synchronous_standby_names" parameter will be
   * set up.
   *
   * @schema ClusterSpecPostgresql#syncReplicaElectionConstraint
   */
  readonly syncReplicaElectionConstraint?: ClusterSpecPostgresqlSyncReplicaElectionConstraint;

}

/**
 * Converts an object of type 'ClusterSpecPostgresql' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecPostgresql(obj: ClusterSpecPostgresql | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableAlterSystem': obj.enableAlterSystem,
    'ldap': toJson_ClusterSpecPostgresqlLdap(obj.ldap),
    'parameters': ((obj.parameters) === undefined) ? undefined : (Object.entries(obj.parameters).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'pg_hba': obj.pgHba?.map(y => y),
    'pg_ident': obj.pgIdent?.map(y => y),
    'promotionTimeout': obj.promotionTimeout,
    'shared_preload_libraries': obj.sharedPreloadLibraries?.map(y => y),
    'syncReplicaElectionConstraint': toJson_ClusterSpecPostgresqlSyncReplicaElectionConstraint(obj.syncReplicaElectionConstraint),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Method to follow to upgrade the primary server during a rolling
 * update procedure, after all replicas have been successfully updated:
 * it can be with a switchover (`switchover`) or in-place (`restart` - default)
 *
 * @schema ClusterSpecPrimaryUpdateMethod
 */
export enum ClusterSpecPrimaryUpdateMethod {
  /** switchover */
  SWITCHOVER = "switchover",
  /** restart */
  RESTART = "restart",
}

/**
 * Deployment strategy to follow to upgrade the primary server during a rolling
 * update procedure, after all replicas have been successfully updated:
 * it can be automated (`unsupervised` - default) or manual (`supervised`)
 *
 * @schema ClusterSpecPrimaryUpdateStrategy
 */
export enum ClusterSpecPrimaryUpdateStrategy {
  /** unsupervised */
  UNSUPERVISED = "unsupervised",
  /** supervised */
  SUPERVISED = "supervised",
}

/**
 * Template to be used to define projected volumes, projected volumes will be mounted
 * under `/projected` base folder
 *
 * @schema ClusterSpecProjectedVolumeTemplate
 */
export interface ClusterSpecProjectedVolumeTemplate {
  /**
   * defaultMode are the mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema ClusterSpecProjectedVolumeTemplate#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * sources is the list of volume projections
   *
   * @schema ClusterSpecProjectedVolumeTemplate#sources
   */
  readonly sources?: ClusterSpecProjectedVolumeTemplateSources[];

}

/**
 * Converts an object of type 'ClusterSpecProjectedVolumeTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecProjectedVolumeTemplate(obj: ClusterSpecProjectedVolumeTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'sources': obj.sources?.map(y => toJson_ClusterSpecProjectedVolumeTemplateSources(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Replica cluster configuration
 *
 * @schema ClusterSpecReplica
 */
export interface ClusterSpecReplica {
  /**
   * If replica mode is enabled, this cluster will be a replica of an
   * existing cluster. Replica cluster can be created from a recovery
   * object store or via streaming through pg_basebackup.
   * Refer to the Replica clusters page of the documentation for more information.
   *
   * @schema ClusterSpecReplica#enabled
   */
  readonly enabled: boolean;

  /**
   * The name of the external cluster which is the replication origin
   *
   * @schema ClusterSpecReplica#source
   */
  readonly source: string;

}

/**
 * Converts an object of type 'ClusterSpecReplica' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecReplica(obj: ClusterSpecReplica | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'source': obj.source,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Replication slots management configuration
 *
 * @schema ClusterSpecReplicationSlots
 */
export interface ClusterSpecReplicationSlots {
  /**
   * Replication slots for high availability configuration
   *
   * @schema ClusterSpecReplicationSlots#highAvailability
   */
  readonly highAvailability?: ClusterSpecReplicationSlotsHighAvailability;

  /**
   * Configures the synchronization of the user defined physical replication slots
   *
   * @schema ClusterSpecReplicationSlots#synchronizeReplicas
   */
  readonly synchronizeReplicas?: ClusterSpecReplicationSlotsSynchronizeReplicas;

  /**
   * Standby will update the status of the local replication slots
   * every `updateInterval` seconds (default 30).
   *
   * @schema ClusterSpecReplicationSlots#updateInterval
   */
  readonly updateInterval?: number;

}

/**
 * Converts an object of type 'ClusterSpecReplicationSlots' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecReplicationSlots(obj: ClusterSpecReplicationSlots | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'highAvailability': toJson_ClusterSpecReplicationSlotsHighAvailability(obj.highAvailability),
    'synchronizeReplicas': toJson_ClusterSpecReplicationSlotsSynchronizeReplicas(obj.synchronizeReplicas),
    'updateInterval': obj.updateInterval,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resources requirements of every generated Pod. Please refer to
 * https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
 * for more information.
 *
 * @schema ClusterSpecResources
 */
export interface ClusterSpecResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema ClusterSpecResources#claims
   */
  readonly claims?: ClusterSpecResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ClusterSpecResources#limits
   */
  readonly limits?: { [key: string]: ClusterSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ClusterSpecResources#requests
   */
  readonly requests?: { [key: string]: ClusterSpecResourcesRequests };

}

/**
 * Converts an object of type 'ClusterSpecResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecResources(obj: ClusterSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claims': obj.claims?.map(y => toJson_ClusterSpecResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The SeccompProfile applied to every Pod and Container.
 * Defaults to: `RuntimeDefault`
 *
 * @default RuntimeDefault`
 * @schema ClusterSpecSeccompProfile
 */
export interface ClusterSpecSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used.
   * The profile must be preconfigured on the node to work.
   * Must be a descending path, relative to the kubelet's configured seccomp profile location.
   * Must be set if type is "Localhost". Must NOT be set for any other type.
   *
   * @schema ClusterSpecSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied.
   * Valid options are:
   *
   *
   * Localhost - a profile defined in a file on the node should be used.
   * RuntimeDefault - the container runtime default profile should be used.
   * Unconfined - no profile should be applied.
   *
   * @schema ClusterSpecSeccompProfile#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'ClusterSpecSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecSeccompProfile(obj: ClusterSpecSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configure the generation of the service account
 *
 * @schema ClusterSpecServiceAccountTemplate
 */
export interface ClusterSpecServiceAccountTemplate {
  /**
   * Metadata are the metadata to be used for the generated
   * service account
   *
   * @schema ClusterSpecServiceAccountTemplate#metadata
   */
  readonly metadata: ClusterSpecServiceAccountTemplateMetadata;

}

/**
 * Converts an object of type 'ClusterSpecServiceAccountTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecServiceAccountTemplate(obj: ClusterSpecServiceAccountTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_ClusterSpecServiceAccountTemplateMetadata(obj.metadata),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configuration of the storage of the instances
 *
 * @schema ClusterSpecStorage
 */
export interface ClusterSpecStorage {
  /**
   * Template to be used to generate the Persistent Volume Claim
   *
   * @schema ClusterSpecStorage#pvcTemplate
   */
  readonly pvcTemplate?: ClusterSpecStoragePvcTemplate;

  /**
   * Resize existent PVCs, defaults to true
   *
   * @schema ClusterSpecStorage#resizeInUseVolumes
   */
  readonly resizeInUseVolumes?: boolean;

  /**
   * Size of the storage. Required if not already specified in the PVC template.
   * Changes to this field are automatically reapplied to the created PVCs.
   * Size cannot be decreased.
   *
   * @schema ClusterSpecStorage#size
   */
  readonly size?: string;

  /**
   * StorageClass to use for PVCs. Applied after
   * evaluating the PVC template, if available.
   * If not specified, the generated PVCs will use the
   * default storage class
   *
   * @schema ClusterSpecStorage#storageClass
   */
  readonly storageClass?: string;

}

/**
 * Converts an object of type 'ClusterSpecStorage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecStorage(obj: ClusterSpecStorage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pvcTemplate': toJson_ClusterSpecStoragePvcTemplate(obj.pvcTemplate),
    'resizeInUseVolumes': obj.resizeInUseVolumes,
    'size': obj.size,
    'storageClass': obj.storageClass,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The secret containing the superuser password. If not defined a new
 * secret will be created with a randomly generated password
 *
 * @schema ClusterSpecSuperuserSecret
 */
export interface ClusterSpecSuperuserSecret {
  /**
   * Name of the referent.
   *
   * @schema ClusterSpecSuperuserSecret#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterSpecSuperuserSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecSuperuserSecret(obj: ClusterSpecSuperuserSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TablespaceConfiguration is the configuration of a tablespace, and includes
 * the storage specification for the tablespace
 *
 * @schema ClusterSpecTablespaces
 */
export interface ClusterSpecTablespaces {
  /**
   * The name of the tablespace
   *
   * @schema ClusterSpecTablespaces#name
   */
  readonly name: string;

  /**
   * Owner is the PostgreSQL user owning the tablespace
   *
   * @schema ClusterSpecTablespaces#owner
   */
  readonly owner?: ClusterSpecTablespacesOwner;

  /**
   * The storage configuration for the tablespace
   *
   * @schema ClusterSpecTablespaces#storage
   */
  readonly storage: ClusterSpecTablespacesStorage;

  /**
   * When set to true, the tablespace will be added as a `temp_tablespaces`
   * entry in PostgreSQL, and will be available to automatically house temp
   * database objects, or other temporary files. Please refer to PostgreSQL
   * documentation for more information on the `temp_tablespaces` GUC.
   *
   * @schema ClusterSpecTablespaces#temporary
   */
  readonly temporary?: boolean;

}

/**
 * Converts an object of type 'ClusterSpecTablespaces' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecTablespaces(obj: ClusterSpecTablespaces | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'owner': toJson_ClusterSpecTablespacesOwner(obj.owner),
    'storage': toJson_ClusterSpecTablespacesStorage(obj.storage),
    'temporary': obj.temporary,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TopologySpreadConstraint specifies how to spread matching pods among the given topology.
 *
 * @schema ClusterSpecTopologySpreadConstraints
 */
export interface ClusterSpecTopologySpreadConstraints {
  /**
   * LabelSelector is used to find matching pods.
   * Pods that match this label selector are counted to determine the number of pods
   * in their corresponding topology domain.
   *
   * @schema ClusterSpecTopologySpreadConstraints#labelSelector
   */
  readonly labelSelector?: ClusterSpecTopologySpreadConstraintsLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select the pods over which
   * spreading will be calculated. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are ANDed with labelSelector
   * to select the group of existing pods over which spreading will be calculated
   * for the incoming pod. The same key is forbidden to exist in both MatchLabelKeys and LabelSelector.
   * MatchLabelKeys cannot be set when LabelSelector isn't set.
   * Keys that don't exist in the incoming pod labels will
   * be ignored. A null or empty list means only match against labelSelector.
   *
   *
   * This is a beta field and requires the MatchLabelKeysInPodTopologySpread feature gate to be enabled (enabled by default).
   *
   * @schema ClusterSpecTopologySpreadConstraints#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MaxSkew describes the degree to which pods may be unevenly distributed.
   * When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted difference
   * between the number of matching pods in the target topology and the global minimum.
   * The global minimum is the minimum number of matching pods in an eligible domain
   * or zero if the number of eligible domains is less than MinDomains.
   * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
   * labelSelector spread as 2/2/1:
   * In this case, the global minimum is 1.
   * | zone1 | zone2 | zone3 |
   * |  P P  |  P P  |   P   |
   * - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 2/2/2;
   * scheduling it onto zone1(zone2) would make the ActualSkew(3-1) on zone1(zone2)
   * violate MaxSkew(1).
   * - if MaxSkew is 2, incoming pod can be scheduled onto any zone.
   * When `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher precedence
   * to topologies that satisfy it.
   * It's a required field. Default value is 1 and 0 is not allowed.
   *
   * @schema ClusterSpecTopologySpreadConstraints#maxSkew
   */
  readonly maxSkew: number;

  /**
   * MinDomains indicates a minimum number of eligible domains.
   * When the number of eligible domains with matching topology keys is less than minDomains,
   * Pod Topology Spread treats "global minimum" as 0, and then the calculation of Skew is performed.
   * And when the number of eligible domains with matching topology keys equals or greater than minDomains,
   * this value has no effect on scheduling.
   * As a result, when the number of eligible domains is less than minDomains,
   * scheduler won't schedule more than maxSkew Pods to those domains.
   * If value is nil, the constraint behaves as if MinDomains is equal to 1.
   * Valid values are integers greater than 0.
   * When value is not nil, WhenUnsatisfiable must be DoNotSchedule.
   *
   *
   * For example, in a 3-zone cluster, MaxSkew is set to 2, MinDomains is set to 5 and pods with the same
   * labelSelector spread as 2/2/2:
   * | zone1 | zone2 | zone3 |
   * |  P P  |  P P  |  P P  |
   * The number of domains is less than 5(MinDomains), so "global minimum" is treated as 0.
   * In this situation, new pod with the same labelSelector cannot be scheduled,
   * because computed skew will be 3(3 - 0) if new Pod is scheduled to any of the three zones,
   * it will violate MaxSkew.
   *
   *
   * This is a beta field and requires the MinDomainsInPodTopologySpread feature gate to be enabled (enabled by default).
   *
   * @schema ClusterSpecTopologySpreadConstraints#minDomains
   */
  readonly minDomains?: number;

  /**
   * NodeAffinityPolicy indicates how we will treat Pod's nodeAffinity/nodeSelector
   * when calculating pod topology spread skew. Options are:
   * - Honor: only nodes matching nodeAffinity/nodeSelector are included in the calculations.
   * - Ignore: nodeAffinity/nodeSelector are ignored. All nodes are included in the calculations.
   *
   *
   * If this value is nil, the behavior is equivalent to the Honor policy.
   * This is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.
   *
   * @schema ClusterSpecTopologySpreadConstraints#nodeAffinityPolicy
   */
  readonly nodeAffinityPolicy?: string;

  /**
   * NodeTaintsPolicy indicates how we will treat node taints when calculating
   * pod topology spread skew. Options are:
   * - Honor: nodes without taints, along with tainted nodes for which the incoming pod
   * has a toleration, are included.
   * - Ignore: node taints are ignored. All nodes are included.
   *
   *
   * If this value is nil, the behavior is equivalent to the Ignore policy.
   * This is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.
   *
   * @schema ClusterSpecTopologySpreadConstraints#nodeTaintsPolicy
   */
  readonly nodeTaintsPolicy?: string;

  /**
   * TopologyKey is the key of node labels. Nodes that have a label with this key
   * and identical values are considered to be in the same topology.
   * We consider each <key, value> as a "bucket", and try to put balanced number
   * of pods into each bucket.
   * We define a domain as a particular instance of a topology.
   * Also, we define an eligible domain as a domain whose nodes meet the requirements of
   * nodeAffinityPolicy and nodeTaintsPolicy.
   * e.g. If TopologyKey is "kubernetes.io/hostname", each Node is a domain of that topology.
   * And, if TopologyKey is "topology.kubernetes.io/zone", each zone is a domain of that topology.
   * It's a required field.
   *
   * @schema ClusterSpecTopologySpreadConstraints#topologyKey
   */
  readonly topologyKey: string;

  /**
   * WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy
   * the spread constraint.
   * - DoNotSchedule (default) tells the scheduler not to schedule it.
   * - ScheduleAnyway tells the scheduler to schedule the pod in any location,
   * but giving higher precedence to topologies that would help reduce the
   * skew.
   * A constraint is considered "Unsatisfiable" for an incoming pod
   * if and only if every possible node assignment for that pod would violate
   * "MaxSkew" on some topology.
   * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
   * labelSelector spread as 3/1/1:
   * | zone1 | zone2 | zone3 |
   * | P P P |   P   |   P   |
   * If WhenUnsatisfiable is set to DoNotSchedule, incoming pod can only be scheduled
   * to zone2(zone3) to become 3/2/1(3/1/2) as ActualSkew(2-1) on zone2(zone3) satisfies
   * MaxSkew(1). In other words, the cluster can still be imbalanced, but scheduler
   * won't make it *more* imbalanced.
   * It's a required field.
   *
   * @schema ClusterSpecTopologySpreadConstraints#whenUnsatisfiable
   */
  readonly whenUnsatisfiable: string;

}

/**
 * Converts an object of type 'ClusterSpecTopologySpreadConstraints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecTopologySpreadConstraints(obj: ClusterSpecTopologySpreadConstraints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_ClusterSpecTopologySpreadConstraintsLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'maxSkew': obj.maxSkew,
    'minDomains': obj.minDomains,
    'nodeAffinityPolicy': obj.nodeAffinityPolicy,
    'nodeTaintsPolicy': obj.nodeTaintsPolicy,
    'topologyKey': obj.topologyKey,
    'whenUnsatisfiable': obj.whenUnsatisfiable,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configuration of the storage for PostgreSQL WAL (Write-Ahead Log)
 *
 * @schema ClusterSpecWalStorage
 */
export interface ClusterSpecWalStorage {
  /**
   * Template to be used to generate the Persistent Volume Claim
   *
   * @schema ClusterSpecWalStorage#pvcTemplate
   */
  readonly pvcTemplate?: ClusterSpecWalStoragePvcTemplate;

  /**
   * Resize existent PVCs, defaults to true
   *
   * @schema ClusterSpecWalStorage#resizeInUseVolumes
   */
  readonly resizeInUseVolumes?: boolean;

  /**
   * Size of the storage. Required if not already specified in the PVC template.
   * Changes to this field are automatically reapplied to the created PVCs.
   * Size cannot be decreased.
   *
   * @schema ClusterSpecWalStorage#size
   */
  readonly size?: string;

  /**
   * StorageClass to use for PVCs. Applied after
   * evaluating the PVC template, if available.
   * If not specified, the generated PVCs will use the
   * default storage class
   *
   * @schema ClusterSpecWalStorage#storageClass
   */
  readonly storageClass?: string;

}

/**
 * Converts an object of type 'ClusterSpecWalStorage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecWalStorage(obj: ClusterSpecWalStorage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pvcTemplate': toJson_ClusterSpecWalStoragePvcTemplate(obj.pvcTemplate),
    'resizeInUseVolumes': obj.resizeInUseVolumes,
    'size': obj.size,
    'storageClass': obj.storageClass,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AdditionalPodAffinity allows to specify pod affinity terms to be passed to all the cluster's pods.
 *
 * @schema ClusterSpecAffinityAdditionalPodAffinity
 */
export interface ClusterSpecAffinityAdditionalPodAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema ClusterSpecAffinityAdditionalPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to a pod label update), the
   * system may or may not try to eventually evict the pod from its node.
   * When there are multiple elements, the lists of nodes corresponding to each
   * podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema ClusterSpecAffinityAdditionalPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'ClusterSpecAffinityAdditionalPodAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecAffinityAdditionalPodAffinity(obj: ClusterSpecAffinityAdditionalPodAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AdditionalPodAntiAffinity allows to specify pod anti-affinity terms to be added to the ones generated
 * by the operator if EnablePodAntiAffinity is set to true (default) or to be used exclusively if set to false.
 *
 * @schema ClusterSpecAffinityAdditionalPodAntiAffinity
 */
export interface ClusterSpecAffinityAdditionalPodAntiAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the anti-affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling anti-affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema ClusterSpecAffinityAdditionalPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the anti-affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the anti-affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to a pod label update), the
   * system may or may not try to eventually evict the pod from its node.
   * When there are multiple elements, the lists of nodes corresponding to each
   * podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema ClusterSpecAffinityAdditionalPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'ClusterSpecAffinityAdditionalPodAntiAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecAffinityAdditionalPodAntiAffinity(obj: ClusterSpecAffinityAdditionalPodAntiAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NodeAffinity describes node affinity scheduling rules for the pod.
 * More info: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#node-affinity
 *
 * @schema ClusterSpecAffinityNodeAffinity
 */
export interface ClusterSpecAffinityNodeAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node matches the corresponding matchExpressions; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema ClusterSpecAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: ClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to an update), the system
   * may or may not try to eventually evict the pod from its node.
   *
   * @schema ClusterSpecAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: ClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;

}

/**
 * Converts an object of type 'ClusterSpecAffinityNodeAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecAffinityNodeAffinity(obj: ClusterSpecAffinityNodeAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_ClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': toJson_ClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj.requiredDuringSchedulingIgnoredDuringExecution),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema ClusterSpecAffinityTolerations
 */
export interface ClusterSpecAffinityTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema ClusterSpecAffinityTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema ClusterSpecAffinityTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema ClusterSpecAffinityTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict). Zero and
   * negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema ClusterSpecAffinityTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema ClusterSpecAffinityTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ClusterSpecAffinityTolerations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecAffinityTolerations(obj: ClusterSpecAffinityTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The configuration for the barman-cloud tool suite
 *
 * @schema ClusterSpecBackupBarmanObjectStore
 */
export interface ClusterSpecBackupBarmanObjectStore {
  /**
   * The credentials to use to upload data to Azure Blob Storage
   *
   * @schema ClusterSpecBackupBarmanObjectStore#azureCredentials
   */
  readonly azureCredentials?: ClusterSpecBackupBarmanObjectStoreAzureCredentials;

  /**
   * The configuration to be used to backup the data files
   * When not defined, base backups files will be stored uncompressed and may
   * be unencrypted in the object store, according to the bucket default
   * policy.
   *
   * @schema ClusterSpecBackupBarmanObjectStore#data
   */
  readonly data?: ClusterSpecBackupBarmanObjectStoreData;

  /**
   * The path where to store the backup (i.e. s3://bucket/path/to/folder)
   * this path, with different destination folders, will be used for WALs
   * and for data
   *
   * @schema ClusterSpecBackupBarmanObjectStore#destinationPath
   */
  readonly destinationPath: string;

  /**
   * EndpointCA store the CA bundle of the barman endpoint.
   * Useful when using self-signed certificates to avoid
   * errors with certificate issuer and barman-cloud-wal-archive
   *
   * @schema ClusterSpecBackupBarmanObjectStore#endpointCA
   */
  readonly endpointCa?: ClusterSpecBackupBarmanObjectStoreEndpointCa;

  /**
   * Endpoint to be used to upload data to the cloud,
   * overriding the automatic endpoint discovery
   *
   * @schema ClusterSpecBackupBarmanObjectStore#endpointURL
   */
  readonly endpointUrl?: string;

  /**
   * The credentials to use to upload data to Google Cloud Storage
   *
   * @schema ClusterSpecBackupBarmanObjectStore#googleCredentials
   */
  readonly googleCredentials?: ClusterSpecBackupBarmanObjectStoreGoogleCredentials;

  /**
   * HistoryTags is a list of key value pairs that will be passed to the
   * Barman --history-tags option.
   *
   * @schema ClusterSpecBackupBarmanObjectStore#historyTags
   */
  readonly historyTags?: { [key: string]: string };

  /**
   * The credentials to use to upload data to S3
   *
   * @schema ClusterSpecBackupBarmanObjectStore#s3Credentials
   */
  readonly s3Credentials?: ClusterSpecBackupBarmanObjectStoreS3Credentials;

  /**
   * The server name on S3, the cluster name is used if this
   * parameter is omitted
   *
   * @schema ClusterSpecBackupBarmanObjectStore#serverName
   */
  readonly serverName?: string;

  /**
   * Tags is a list of key value pairs that will be passed to the
   * Barman --tags option.
   *
   * @schema ClusterSpecBackupBarmanObjectStore#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The configuration for the backup of the WAL stream.
   * When not defined, WAL files will be stored uncompressed and may be
   * unencrypted in the object store, according to the bucket default policy.
   *
   * @schema ClusterSpecBackupBarmanObjectStore#wal
   */
  readonly wal?: ClusterSpecBackupBarmanObjectStoreWal;

}

/**
 * Converts an object of type 'ClusterSpecBackupBarmanObjectStore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecBackupBarmanObjectStore(obj: ClusterSpecBackupBarmanObjectStore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'azureCredentials': toJson_ClusterSpecBackupBarmanObjectStoreAzureCredentials(obj.azureCredentials),
    'data': toJson_ClusterSpecBackupBarmanObjectStoreData(obj.data),
    'destinationPath': obj.destinationPath,
    'endpointCA': toJson_ClusterSpecBackupBarmanObjectStoreEndpointCa(obj.endpointCa),
    'endpointURL': obj.endpointUrl,
    'googleCredentials': toJson_ClusterSpecBackupBarmanObjectStoreGoogleCredentials(obj.googleCredentials),
    'historyTags': ((obj.historyTags) === undefined) ? undefined : (Object.entries(obj.historyTags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    's3Credentials': toJson_ClusterSpecBackupBarmanObjectStoreS3Credentials(obj.s3Credentials),
    'serverName': obj.serverName,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'wal': toJson_ClusterSpecBackupBarmanObjectStoreWal(obj.wal),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The policy to decide which instance should perform backups. Available
 * options are empty string, which will default to `prefer-standby` policy,
 * `primary` to have backups run always on primary instances, `prefer-standby`
 * to have backups run preferably on the most updated standby, if available.
 *
 * @schema ClusterSpecBackupTarget
 */
export enum ClusterSpecBackupTarget {
  /** primary */
  PRIMARY = "primary",
  /** prefer-standby */
  PREFER_HYPHEN_STANDBY = "prefer-standby",
}

/**
 * VolumeSnapshot provides the configuration for the execution of volume snapshot backups.
 *
 * @schema ClusterSpecBackupVolumeSnapshot
 */
export interface ClusterSpecBackupVolumeSnapshot {
  /**
   * Annotations key-value pairs that will be added to .metadata.annotations snapshot resources.
   *
   * @schema ClusterSpecBackupVolumeSnapshot#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * ClassName specifies the Snapshot Class to be used for PG_DATA PersistentVolumeClaim.
   * It is the default class for the other types if no specific class is present
   *
   * @schema ClusterSpecBackupVolumeSnapshot#className
   */
  readonly className?: string;

  /**
   * Labels are key-value pairs that will be added to .metadata.labels snapshot resources.
   *
   * @schema ClusterSpecBackupVolumeSnapshot#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Whether the default type of backup with volume snapshots is
   * online/hot (`true`, default) or offline/cold (`false`)
   *
   * @schema ClusterSpecBackupVolumeSnapshot#online
   */
  readonly online?: boolean;

  /**
   * Configuration parameters to control the online/hot backup with volume snapshots
   *
   * @schema ClusterSpecBackupVolumeSnapshot#onlineConfiguration
   */
  readonly onlineConfiguration?: ClusterSpecBackupVolumeSnapshotOnlineConfiguration;

  /**
   * SnapshotOwnerReference indicates the type of owner reference the snapshot should have
   *
   * @schema ClusterSpecBackupVolumeSnapshot#snapshotOwnerReference
   */
  readonly snapshotOwnerReference?: ClusterSpecBackupVolumeSnapshotSnapshotOwnerReference;

  /**
   * TablespaceClassName specifies the Snapshot Class to be used for the tablespaces.
   * defaults to the PGDATA Snapshot Class, if set
   *
   * @schema ClusterSpecBackupVolumeSnapshot#tablespaceClassName
   */
  readonly tablespaceClassName?: { [key: string]: string };

  /**
   * WalClassName specifies the Snapshot Class to be used for the PG_WAL PersistentVolumeClaim.
   *
   * @schema ClusterSpecBackupVolumeSnapshot#walClassName
   */
  readonly walClassName?: string;

}

/**
 * Converts an object of type 'ClusterSpecBackupVolumeSnapshot' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecBackupVolumeSnapshot(obj: ClusterSpecBackupVolumeSnapshot | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'className': obj.className,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'online': obj.online,
    'onlineConfiguration': toJson_ClusterSpecBackupVolumeSnapshotOnlineConfiguration(obj.onlineConfiguration),
    'snapshotOwnerReference': obj.snapshotOwnerReference,
    'tablespaceClassName': ((obj.tablespaceClassName) === undefined) ? undefined : (Object.entries(obj.tablespaceClassName).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'walClassName': obj.walClassName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Bootstrap the cluster via initdb
 *
 * @schema ClusterSpecBootstrapInitdb
 */
export interface ClusterSpecBootstrapInitdb {
  /**
   * Whether the `-k` option should be passed to initdb,
   * enabling checksums on data pages (default: `false`)
   *
   * @schema ClusterSpecBootstrapInitdb#dataChecksums
   */
  readonly dataChecksums?: boolean;

  /**
   * Name of the database used by the application. Default: `app`.
   *
   * @schema ClusterSpecBootstrapInitdb#database
   */
  readonly database?: string;

  /**
   * The value to be passed as option `--encoding` for initdb (default:`UTF8`)
   *
   * @schema ClusterSpecBootstrapInitdb#encoding
   */
  readonly encoding?: string;

  /**
   * Bootstraps the new cluster by importing data from an existing PostgreSQL
   * instance using logical backup (`pg_dump` and `pg_restore`)
   *
   * @schema ClusterSpecBootstrapInitdb#import
   */
  readonly import?: ClusterSpecBootstrapInitdbImport;

  /**
   * The value to be passed as option `--lc-ctype` for initdb (default:`C`)
   *
   * @schema ClusterSpecBootstrapInitdb#localeCType
   */
  readonly localeCType?: string;

  /**
   * The value to be passed as option `--lc-collate` for initdb (default:`C`)
   *
   * @schema ClusterSpecBootstrapInitdb#localeCollate
   */
  readonly localeCollate?: string;

  /**
   * The list of options that must be passed to initdb when creating the cluster.
   * Deprecated: This could lead to inconsistent configurations,
   * please use the explicit provided parameters instead.
   * If defined, explicit values will be ignored.
   *
   * @schema ClusterSpecBootstrapInitdb#options
   */
  readonly options?: string[];

  /**
   * Name of the owner of the database in the instance to be used
   * by applications. Defaults to the value of the `database` key.
   *
   * @default the value of the `database` key.
   * @schema ClusterSpecBootstrapInitdb#owner
   */
  readonly owner?: string;

  /**
   * List of SQL queries to be executed as a superuser in the application
   * database right after is created - to be used with extreme care
   * (by default empty)
   *
   * @schema ClusterSpecBootstrapInitdb#postInitApplicationSQL
   */
  readonly postInitApplicationSql?: string[];

  /**
   * PostInitApplicationSQLRefs points references to ConfigMaps or Secrets which
   * contain SQL files, the general implementation order to these references is
   * from all Secrets to all ConfigMaps, and inside Secrets or ConfigMaps,
   * the implementation order is same as the order of each array
   * (by default empty)
   *
   * @schema ClusterSpecBootstrapInitdb#postInitApplicationSQLRefs
   */
  readonly postInitApplicationSqlRefs?: ClusterSpecBootstrapInitdbPostInitApplicationSqlRefs;

  /**
   * List of SQL queries to be executed as a superuser immediately
   * after the cluster has been created - to be used with extreme care
   * (by default empty)
   *
   * @schema ClusterSpecBootstrapInitdb#postInitSQL
   */
  readonly postInitSql?: string[];

  /**
   * List of SQL queries to be executed as a superuser in the `template1`
   * after the cluster has been created - to be used with extreme care
   * (by default empty)
   *
   * @schema ClusterSpecBootstrapInitdb#postInitTemplateSQL
   */
  readonly postInitTemplateSql?: string[];

  /**
   * Name of the secret containing the initial credentials for the
   * owner of the user database. If empty a new secret will be
   * created from scratch
   *
   * @schema ClusterSpecBootstrapInitdb#secret
   */
  readonly secret?: ClusterSpecBootstrapInitdbSecret;

  /**
   * The value in megabytes (1 to 1024) to be passed to the `--wal-segsize`
   * option for initdb (default: empty, resulting in PostgreSQL default: 16MB)
   *
   * @schema ClusterSpecBootstrapInitdb#walSegmentSize
   */
  readonly walSegmentSize?: number;

}

/**
 * Converts an object of type 'ClusterSpecBootstrapInitdb' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecBootstrapInitdb(obj: ClusterSpecBootstrapInitdb | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dataChecksums': obj.dataChecksums,
    'database': obj.database,
    'encoding': obj.encoding,
    'import': toJson_ClusterSpecBootstrapInitdbImport(obj.import),
    'localeCType': obj.localeCType,
    'localeCollate': obj.localeCollate,
    'options': obj.options?.map(y => y),
    'owner': obj.owner,
    'postInitApplicationSQL': obj.postInitApplicationSql?.map(y => y),
    'postInitApplicationSQLRefs': toJson_ClusterSpecBootstrapInitdbPostInitApplicationSqlRefs(obj.postInitApplicationSqlRefs),
    'postInitSQL': obj.postInitSql?.map(y => y),
    'postInitTemplateSQL': obj.postInitTemplateSql?.map(y => y),
    'secret': toJson_ClusterSpecBootstrapInitdbSecret(obj.secret),
    'walSegmentSize': obj.walSegmentSize,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Bootstrap the cluster taking a physical backup of another compatible
 * PostgreSQL instance
 *
 * @schema ClusterSpecBootstrapPgBasebackup
 */
export interface ClusterSpecBootstrapPgBasebackup {
  /**
   * Name of the database used by the application. Default: `app`.
   *
   * @schema ClusterSpecBootstrapPgBasebackup#database
   */
  readonly database?: string;

  /**
   * Name of the owner of the database in the instance to be used
   * by applications. Defaults to the value of the `database` key.
   *
   * @default the value of the `database` key.
   * @schema ClusterSpecBootstrapPgBasebackup#owner
   */
  readonly owner?: string;

  /**
   * Name of the secret containing the initial credentials for the
   * owner of the user database. If empty a new secret will be
   * created from scratch
   *
   * @schema ClusterSpecBootstrapPgBasebackup#secret
   */
  readonly secret?: ClusterSpecBootstrapPgBasebackupSecret;

  /**
   * The name of the server of which we need to take a physical backup
   *
   * @schema ClusterSpecBootstrapPgBasebackup#source
   */
  readonly source: string;

}

/**
 * Converts an object of type 'ClusterSpecBootstrapPgBasebackup' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecBootstrapPgBasebackup(obj: ClusterSpecBootstrapPgBasebackup | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'database': obj.database,
    'owner': obj.owner,
    'secret': toJson_ClusterSpecBootstrapPgBasebackupSecret(obj.secret),
    'source': obj.source,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Bootstrap the cluster from a backup
 *
 * @schema ClusterSpecBootstrapRecovery
 */
export interface ClusterSpecBootstrapRecovery {
  /**
   * The backup object containing the physical base backup from which to
   * initiate the recovery procedure.
   * Mutually exclusive with `source` and `volumeSnapshots`.
   *
   * @schema ClusterSpecBootstrapRecovery#backup
   */
  readonly backup?: ClusterSpecBootstrapRecoveryBackup;

  /**
   * Name of the database used by the application. Default: `app`.
   *
   * @schema ClusterSpecBootstrapRecovery#database
   */
  readonly database?: string;

  /**
   * Name of the owner of the database in the instance to be used
   * by applications. Defaults to the value of the `database` key.
   *
   * @default the value of the `database` key.
   * @schema ClusterSpecBootstrapRecovery#owner
   */
  readonly owner?: string;

  /**
   * By default, the recovery process applies all the available
   * WAL files in the archive (full recovery). However, you can also
   * end the recovery as soon as a consistent state is reached or
   * recover to a point-in-time (PITR) by specifying a `RecoveryTarget` object,
   * as expected by PostgreSQL (i.e., timestamp, transaction Id, LSN, ...).
   * More info: https://www.postgresql.org/docs/current/runtime-config-wal.html#RUNTIME-CONFIG-WAL-RECOVERY-TARGET
   *
   * @schema ClusterSpecBootstrapRecovery#recoveryTarget
   */
  readonly recoveryTarget?: ClusterSpecBootstrapRecoveryRecoveryTarget;

  /**
   * Name of the secret containing the initial credentials for the
   * owner of the user database. If empty a new secret will be
   * created from scratch
   *
   * @schema ClusterSpecBootstrapRecovery#secret
   */
  readonly secret?: ClusterSpecBootstrapRecoverySecret;

  /**
   * The external cluster whose backup we will restore. This is also
   * used as the name of the folder under which the backup is stored,
   * so it must be set to the name of the source cluster
   * Mutually exclusive with `backup`.
   *
   * @schema ClusterSpecBootstrapRecovery#source
   */
  readonly source?: string;

  /**
   * The static PVC data source(s) from which to initiate the
   * recovery procedure. Currently supporting `VolumeSnapshot`
   * and `PersistentVolumeClaim` resources that map an existing
   * PVC group, compatible with CloudNativePG, and taken with
   * a cold backup copy on a fenced Postgres instance (limitation
   * which will be removed in the future when online backup
   * will be implemented).
   * Mutually exclusive with `backup`.
   *
   * @schema ClusterSpecBootstrapRecovery#volumeSnapshots
   */
  readonly volumeSnapshots?: ClusterSpecBootstrapRecoveryVolumeSnapshots;

}

/**
 * Converts an object of type 'ClusterSpecBootstrapRecovery' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecBootstrapRecovery(obj: ClusterSpecBootstrapRecovery | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'backup': toJson_ClusterSpecBootstrapRecoveryBackup(obj.backup),
    'database': obj.database,
    'owner': obj.owner,
    'recoveryTarget': toJson_ClusterSpecBootstrapRecoveryRecoveryTarget(obj.recoveryTarget),
    'secret': toJson_ClusterSpecBootstrapRecoverySecret(obj.secret),
    'source': obj.source,
    'volumeSnapshots': toJson_ClusterSpecBootstrapRecoveryVolumeSnapshots(obj.volumeSnapshots),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema ClusterSpecEnvValueFrom
 */
export interface ClusterSpecEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema ClusterSpecEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: ClusterSpecEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
   * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema ClusterSpecEnvValueFrom#fieldRef
   */
  readonly fieldRef?: ClusterSpecEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema ClusterSpecEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: ClusterSpecEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema ClusterSpecEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: ClusterSpecEnvValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'ClusterSpecEnvValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecEnvValueFrom(obj: ClusterSpecEnvValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_ClusterSpecEnvValueFromConfigMapKeyRef(obj.configMapKeyRef),
    'fieldRef': toJson_ClusterSpecEnvValueFromFieldRef(obj.fieldRef),
    'resourceFieldRef': toJson_ClusterSpecEnvValueFromResourceFieldRef(obj.resourceFieldRef),
    'secretKeyRef': toJson_ClusterSpecEnvValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema ClusterSpecEnvFromConfigMapRef
 */
export interface ClusterSpecEnvFromConfigMapRef {
  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ClusterSpecEnvFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema ClusterSpecEnvFromConfigMapRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ClusterSpecEnvFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecEnvFromConfigMapRef(obj: ClusterSpecEnvFromConfigMapRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Secret to select from
 *
 * @schema ClusterSpecEnvFromSecretRef
 */
export interface ClusterSpecEnvFromSecretRef {
  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ClusterSpecEnvFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema ClusterSpecEnvFromSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ClusterSpecEnvFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecEnvFromSecretRef(obj: ClusterSpecEnvFromSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Will be used to create a stand-alone PVC to provision the volume.
 * The pod in which this EphemeralVolumeSource is embedded will be the
 * owner of the PVC, i.e. the PVC will be deleted together with the
 * pod.  The name of the PVC will be `<pod name>-<volume name>` where
 * `<volume name>` is the name from the `PodSpec.Volumes` array
 * entry. Pod validation will reject the pod if the concatenated name
 * is not valid for a PVC (for example, too long).
 *
 *
 * An existing PVC with that name that is not owned by the pod
 * will *not* be used for the pod to avoid using an unrelated
 * volume by mistake. Starting the pod is then blocked until
 * the unrelated PVC is removed. If such a pre-created PVC is
 * meant to be used by the pod, the PVC has to updated with an
 * owner reference to the pod once the pod exists. Normally
 * this should not be necessary, but it may be useful when
 * manually reconstructing a broken cluster.
 *
 *
 * This field is read-only and no changes will be made by Kubernetes
 * to the PVC after it has been created.
 *
 *
 * Required, must not be nil.
 *
 * @schema ClusterSpecEphemeralVolumeSourceVolumeClaimTemplate
 */
export interface ClusterSpecEphemeralVolumeSourceVolumeClaimTemplate {
  /**
   * May contain labels and annotations that will be copied into the PVC
   * when creating it. No other fields are allowed and will be rejected during
   * validation.
   *
   * @schema ClusterSpecEphemeralVolumeSourceVolumeClaimTemplate#metadata
   */
  readonly metadata?: any;

  /**
   * The specification for the PersistentVolumeClaim. The entire content is
   * copied unchanged into the PVC that gets created from this
   * template. The same fields as in a PersistentVolumeClaim
   * are also valid here.
   *
   * @schema ClusterSpecEphemeralVolumeSourceVolumeClaimTemplate#spec
   */
  readonly spec: ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpec;

}

/**
 * Converts an object of type 'ClusterSpecEphemeralVolumeSourceVolumeClaimTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecEphemeralVolumeSourceVolumeClaimTemplate(obj: ClusterSpecEphemeralVolumeSourceVolumeClaimTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Shm is the size limit of the shared memory volume
 *
 * @schema ClusterSpecEphemeralVolumesSizeLimitShm
 */
export class ClusterSpecEphemeralVolumesSizeLimitShm {
  public static fromNumber(value: number): ClusterSpecEphemeralVolumesSizeLimitShm {
    return new ClusterSpecEphemeralVolumesSizeLimitShm(value);
  }
  public static fromString(value: string): ClusterSpecEphemeralVolumesSizeLimitShm {
    return new ClusterSpecEphemeralVolumesSizeLimitShm(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * TemporaryData is the size limit of the temporary data volume
 *
 * @schema ClusterSpecEphemeralVolumesSizeLimitTemporaryData
 */
export class ClusterSpecEphemeralVolumesSizeLimitTemporaryData {
  public static fromNumber(value: number): ClusterSpecEphemeralVolumesSizeLimitTemporaryData {
    return new ClusterSpecEphemeralVolumesSizeLimitTemporaryData(value);
  }
  public static fromString(value: string): ClusterSpecEphemeralVolumesSizeLimitTemporaryData {
    return new ClusterSpecEphemeralVolumesSizeLimitTemporaryData(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * The configuration for the barman-cloud tool suite
 *
 * @schema ClusterSpecExternalClustersBarmanObjectStore
 */
export interface ClusterSpecExternalClustersBarmanObjectStore {
  /**
   * The credentials to use to upload data to Azure Blob Storage
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStore#azureCredentials
   */
  readonly azureCredentials?: ClusterSpecExternalClustersBarmanObjectStoreAzureCredentials;

  /**
   * The configuration to be used to backup the data files
   * When not defined, base backups files will be stored uncompressed and may
   * be unencrypted in the object store, according to the bucket default
   * policy.
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStore#data
   */
  readonly data?: ClusterSpecExternalClustersBarmanObjectStoreData;

  /**
   * The path where to store the backup (i.e. s3://bucket/path/to/folder)
   * this path, with different destination folders, will be used for WALs
   * and for data
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStore#destinationPath
   */
  readonly destinationPath: string;

  /**
   * EndpointCA store the CA bundle of the barman endpoint.
   * Useful when using self-signed certificates to avoid
   * errors with certificate issuer and barman-cloud-wal-archive
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStore#endpointCA
   */
  readonly endpointCa?: ClusterSpecExternalClustersBarmanObjectStoreEndpointCa;

  /**
   * Endpoint to be used to upload data to the cloud,
   * overriding the automatic endpoint discovery
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStore#endpointURL
   */
  readonly endpointUrl?: string;

  /**
   * The credentials to use to upload data to Google Cloud Storage
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStore#googleCredentials
   */
  readonly googleCredentials?: ClusterSpecExternalClustersBarmanObjectStoreGoogleCredentials;

  /**
   * HistoryTags is a list of key value pairs that will be passed to the
   * Barman --history-tags option.
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStore#historyTags
   */
  readonly historyTags?: { [key: string]: string };

  /**
   * The credentials to use to upload data to S3
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStore#s3Credentials
   */
  readonly s3Credentials?: ClusterSpecExternalClustersBarmanObjectStoreS3Credentials;

  /**
   * The server name on S3, the cluster name is used if this
   * parameter is omitted
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStore#serverName
   */
  readonly serverName?: string;

  /**
   * Tags is a list of key value pairs that will be passed to the
   * Barman --tags option.
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStore#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The configuration for the backup of the WAL stream.
   * When not defined, WAL files will be stored uncompressed and may be
   * unencrypted in the object store, according to the bucket default policy.
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStore#wal
   */
  readonly wal?: ClusterSpecExternalClustersBarmanObjectStoreWal;

}

/**
 * Converts an object of type 'ClusterSpecExternalClustersBarmanObjectStore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecExternalClustersBarmanObjectStore(obj: ClusterSpecExternalClustersBarmanObjectStore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'azureCredentials': toJson_ClusterSpecExternalClustersBarmanObjectStoreAzureCredentials(obj.azureCredentials),
    'data': toJson_ClusterSpecExternalClustersBarmanObjectStoreData(obj.data),
    'destinationPath': obj.destinationPath,
    'endpointCA': toJson_ClusterSpecExternalClustersBarmanObjectStoreEndpointCa(obj.endpointCa),
    'endpointURL': obj.endpointUrl,
    'googleCredentials': toJson_ClusterSpecExternalClustersBarmanObjectStoreGoogleCredentials(obj.googleCredentials),
    'historyTags': ((obj.historyTags) === undefined) ? undefined : (Object.entries(obj.historyTags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    's3Credentials': toJson_ClusterSpecExternalClustersBarmanObjectStoreS3Credentials(obj.s3Credentials),
    'serverName': obj.serverName,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'wal': toJson_ClusterSpecExternalClustersBarmanObjectStoreWal(obj.wal),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The reference to the password to be used to connect to the server.
 * If a password is provided, CloudNativePG creates a PostgreSQL
 * passfile at `/controller/external/NAME/pass` (where "NAME" is the
 * cluster's name). This passfile is automatically referenced in the
 * connection string when establishing a connection to the remote
 * PostgreSQL server from the current PostgreSQL `Cluster`. This ensures
 * secure and efficient password management for external clusters.
 *
 * @schema ClusterSpecExternalClustersPassword
 */
export interface ClusterSpecExternalClustersPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ClusterSpecExternalClustersPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ClusterSpecExternalClustersPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ClusterSpecExternalClustersPassword#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ClusterSpecExternalClustersPassword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecExternalClustersPassword(obj: ClusterSpecExternalClustersPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The reference to an SSL certificate to be used to connect to this
 * instance
 *
 * @schema ClusterSpecExternalClustersSslCert
 */
export interface ClusterSpecExternalClustersSslCert {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ClusterSpecExternalClustersSslCert#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ClusterSpecExternalClustersSslCert#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ClusterSpecExternalClustersSslCert#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ClusterSpecExternalClustersSslCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecExternalClustersSslCert(obj: ClusterSpecExternalClustersSslCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The reference to an SSL private key to be used to connect to this
 * instance
 *
 * @schema ClusterSpecExternalClustersSslKey
 */
export interface ClusterSpecExternalClustersSslKey {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ClusterSpecExternalClustersSslKey#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ClusterSpecExternalClustersSslKey#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ClusterSpecExternalClustersSslKey#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ClusterSpecExternalClustersSslKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecExternalClustersSslKey(obj: ClusterSpecExternalClustersSslKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The reference to an SSL CA public key to be used to connect to this
 * instance
 *
 * @schema ClusterSpecExternalClustersSslRootCert
 */
export interface ClusterSpecExternalClustersSslRootCert {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ClusterSpecExternalClustersSslRootCert#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ClusterSpecExternalClustersSslRootCert#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ClusterSpecExternalClustersSslRootCert#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ClusterSpecExternalClustersSslRootCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecExternalClustersSslRootCert(obj: ClusterSpecExternalClustersSslRootCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RoleConfiguration is the representation, in Kubernetes, of a PostgreSQL role
 * with the additional field Ensure specifying whether to ensure the presence or
 * absence of the role in the database
 *
 *
 * The defaults of the CREATE ROLE command are applied
 * Reference: https://www.postgresql.org/docs/current/sql-createrole.html
 *
 * @schema ClusterSpecManagedRoles
 */
export interface ClusterSpecManagedRoles {
  /**
   * Whether a role bypasses every row-level security (RLS) policy.
   * Default is `false`.
   *
   * @default false`.
   * @schema ClusterSpecManagedRoles#bypassrls
   */
  readonly bypassrls?: boolean;

  /**
   * Description of the role
   *
   * @schema ClusterSpecManagedRoles#comment
   */
  readonly comment?: string;

  /**
   * If the role can log in, this specifies how many concurrent
   * connections the role can make. `-1` (the default) means no limit.
   *
   * @schema ClusterSpecManagedRoles#connectionLimit
   */
  readonly connectionLimit?: number;

  /**
   * When set to `true`, the role being defined will be allowed to create
   * new databases. Specifying `false` (default) will deny a role the
   * ability to create databases.
   *
   * @schema ClusterSpecManagedRoles#createdb
   */
  readonly createdb?: boolean;

  /**
   * Whether the role will be permitted to create, alter, drop, comment
   * on, change the security label for, and grant or revoke membership in
   * other roles. Default is `false`.
   *
   * @default false`.
   * @schema ClusterSpecManagedRoles#createrole
   */
  readonly createrole?: boolean;

  /**
   * DisablePassword indicates that a role's password should be set to NULL in Postgres
   *
   * @schema ClusterSpecManagedRoles#disablePassword
   */
  readonly disablePassword?: boolean;

  /**
   * Ensure the role is `present` or `absent` - defaults to "present"
   *
   * @schema ClusterSpecManagedRoles#ensure
   */
  readonly ensure?: ClusterSpecManagedRolesEnsure;

  /**
   * List of one or more existing roles to which this role will be
   * immediately added as a new member. Default empty.
   *
   * @schema ClusterSpecManagedRoles#inRoles
   */
  readonly inRoles?: string[];

  /**
   * Whether a role "inherits" the privileges of roles it is a member of.
   * Defaults is `true`.
   *
   * @default true`.
   * @schema ClusterSpecManagedRoles#inherit
   */
  readonly inherit?: boolean;

  /**
   * Whether the role is allowed to log in. A role having the `login`
   * attribute can be thought of as a user. Roles without this attribute
   * are useful for managing database privileges, but are not users in
   * the usual sense of the word. Default is `false`.
   *
   * @default false`.
   * @schema ClusterSpecManagedRoles#login
   */
  readonly login?: boolean;

  /**
   * Name of the role
   *
   * @schema ClusterSpecManagedRoles#name
   */
  readonly name: string;

  /**
   * Secret containing the password of the role (if present)
   * If null, the password will be ignored unless DisablePassword is set
   *
   * @schema ClusterSpecManagedRoles#passwordSecret
   */
  readonly passwordSecret?: ClusterSpecManagedRolesPasswordSecret;

  /**
   * Whether a role is a replication role. A role must have this
   * attribute (or be a superuser) in order to be able to connect to the
   * server in replication mode (physical or logical replication) and in
   * order to be able to create or drop replication slots. A role having
   * the `replication` attribute is a very highly privileged role, and
   * should only be used on roles actually used for replication. Default
   * is `false`.
   *
   * @default false`.
   * @schema ClusterSpecManagedRoles#replication
   */
  readonly replication?: boolean;

  /**
   * Whether the role is a `superuser` who can override all access
   * restrictions within the database - superuser status is dangerous and
   * should be used only when really needed. You must yourself be a
   * superuser to create a new superuser. Defaults is `false`.
   *
   * @default false`.
   * @schema ClusterSpecManagedRoles#superuser
   */
  readonly superuser?: boolean;

  /**
   * Date and time after which the role's password is no longer valid.
   * When omitted, the password will never expire (default).
   *
   * @schema ClusterSpecManagedRoles#validUntil
   */
  readonly validUntil?: Date;

}

/**
 * Converts an object of type 'ClusterSpecManagedRoles' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecManagedRoles(obj: ClusterSpecManagedRoles | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bypassrls': obj.bypassrls,
    'comment': obj.comment,
    'connectionLimit': obj.connectionLimit,
    'createdb': obj.createdb,
    'createrole': obj.createrole,
    'disablePassword': obj.disablePassword,
    'ensure': obj.ensure,
    'inRoles': obj.inRoles?.map(y => y),
    'inherit': obj.inherit,
    'login': obj.login,
    'name': obj.name,
    'passwordSecret': toJson_ClusterSpecManagedRolesPasswordSecret(obj.passwordSecret),
    'replication': obj.replication,
    'superuser': obj.superuser,
    'validUntil': obj.validUntil?.toISOString(),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMapKeySelector contains enough information to let you locate
 * the key of a ConfigMap
 *
 * @schema ClusterSpecMonitoringCustomQueriesConfigMap
 */
export interface ClusterSpecMonitoringCustomQueriesConfigMap {
  /**
   * The key to select
   *
   * @schema ClusterSpecMonitoringCustomQueriesConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   *
   * @schema ClusterSpecMonitoringCustomQueriesConfigMap#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterSpecMonitoringCustomQueriesConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecMonitoringCustomQueriesConfigMap(obj: ClusterSpecMonitoringCustomQueriesConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector contains enough information to let you locate
 * the key of a Secret
 *
 * @schema ClusterSpecMonitoringCustomQueriesSecret
 */
export interface ClusterSpecMonitoringCustomQueriesSecret {
  /**
   * The key to select
   *
   * @schema ClusterSpecMonitoringCustomQueriesSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   *
   * @schema ClusterSpecMonitoringCustomQueriesSecret#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterSpecMonitoringCustomQueriesSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecMonitoringCustomQueriesSecret(obj: ClusterSpecMonitoringCustomQueriesSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RelabelConfig allows dynamic rewriting of the label set for targets, alerts,
 * scraped samples and remote write samples.
 *
 *
 * More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
 *
 * @schema ClusterSpecMonitoringPodMonitorMetricRelabelings
 */
export interface ClusterSpecMonitoringPodMonitorMetricRelabelings {
  /**
   * Action to perform based on the regex matching.
   *
   *
   * `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0.
   * `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.
   *
   *
   * Default: "Replace"
   *
   * @schema ClusterSpecMonitoringPodMonitorMetricRelabelings#action
   */
  readonly action?: ClusterSpecMonitoringPodMonitorMetricRelabelingsAction;

  /**
   * Modulus to take of the hash of the source label values.
   *
   *
   * Only applicable when the action is `HashMod`.
   *
   * @schema ClusterSpecMonitoringPodMonitorMetricRelabelings#modulus
   */
  readonly modulus?: number;

  /**
   * Regular expression against which the extracted value is matched.
   *
   * @schema ClusterSpecMonitoringPodMonitorMetricRelabelings#regex
   */
  readonly regex?: string;

  /**
   * Replacement value against which a Replace action is performed if the
   * regular expression matches.
   *
   *
   * Regex capture groups are available.
   *
   * @schema ClusterSpecMonitoringPodMonitorMetricRelabelings#replacement
   */
  readonly replacement?: string;

  /**
   * Separator is the string between concatenated SourceLabels.
   *
   * @schema ClusterSpecMonitoringPodMonitorMetricRelabelings#separator
   */
  readonly separator?: string;

  /**
   * The source labels select values from existing labels. Their content is
   * concatenated using the configured Separator and matched against the
   * configured regular expression.
   *
   * @schema ClusterSpecMonitoringPodMonitorMetricRelabelings#sourceLabels
   */
  readonly sourceLabels?: string[];

  /**
   * Label to which the resulting string is written in a replacement.
   *
   *
   * It is mandatory for `Replace`, `HashMod`, `Lowercase`, `Uppercase`,
   * `KeepEqual` and `DropEqual` actions.
   *
   *
   * Regex capture groups are available.
   *
   * @schema ClusterSpecMonitoringPodMonitorMetricRelabelings#targetLabel
   */
  readonly targetLabel?: string;

}

/**
 * Converts an object of type 'ClusterSpecMonitoringPodMonitorMetricRelabelings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecMonitoringPodMonitorMetricRelabelings(obj: ClusterSpecMonitoringPodMonitorMetricRelabelings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'modulus': obj.modulus,
    'regex': obj.regex,
    'replacement': obj.replacement,
    'separator': obj.separator,
    'sourceLabels': obj.sourceLabels?.map(y => y),
    'targetLabel': obj.targetLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RelabelConfig allows dynamic rewriting of the label set for targets, alerts,
 * scraped samples and remote write samples.
 *
 *
 * More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
 *
 * @schema ClusterSpecMonitoringPodMonitorRelabelings
 */
export interface ClusterSpecMonitoringPodMonitorRelabelings {
  /**
   * Action to perform based on the regex matching.
   *
   *
   * `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0.
   * `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.
   *
   *
   * Default: "Replace"
   *
   * @schema ClusterSpecMonitoringPodMonitorRelabelings#action
   */
  readonly action?: ClusterSpecMonitoringPodMonitorRelabelingsAction;

  /**
   * Modulus to take of the hash of the source label values.
   *
   *
   * Only applicable when the action is `HashMod`.
   *
   * @schema ClusterSpecMonitoringPodMonitorRelabelings#modulus
   */
  readonly modulus?: number;

  /**
   * Regular expression against which the extracted value is matched.
   *
   * @schema ClusterSpecMonitoringPodMonitorRelabelings#regex
   */
  readonly regex?: string;

  /**
   * Replacement value against which a Replace action is performed if the
   * regular expression matches.
   *
   *
   * Regex capture groups are available.
   *
   * @schema ClusterSpecMonitoringPodMonitorRelabelings#replacement
   */
  readonly replacement?: string;

  /**
   * Separator is the string between concatenated SourceLabels.
   *
   * @schema ClusterSpecMonitoringPodMonitorRelabelings#separator
   */
  readonly separator?: string;

  /**
   * The source labels select values from existing labels. Their content is
   * concatenated using the configured Separator and matched against the
   * configured regular expression.
   *
   * @schema ClusterSpecMonitoringPodMonitorRelabelings#sourceLabels
   */
  readonly sourceLabels?: string[];

  /**
   * Label to which the resulting string is written in a replacement.
   *
   *
   * It is mandatory for `Replace`, `HashMod`, `Lowercase`, `Uppercase`,
   * `KeepEqual` and `DropEqual` actions.
   *
   *
   * Regex capture groups are available.
   *
   * @schema ClusterSpecMonitoringPodMonitorRelabelings#targetLabel
   */
  readonly targetLabel?: string;

}

/**
 * Converts an object of type 'ClusterSpecMonitoringPodMonitorRelabelings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecMonitoringPodMonitorRelabelings(obj: ClusterSpecMonitoringPodMonitorRelabelings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'modulus': obj.modulus,
    'regex': obj.regex,
    'replacement': obj.replacement,
    'separator': obj.separator,
    'sourceLabels': obj.sourceLabels?.map(y => y),
    'targetLabel': obj.targetLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Options to specify LDAP configuration
 *
 * @schema ClusterSpecPostgresqlLdap
 */
export interface ClusterSpecPostgresqlLdap {
  /**
   * Bind as authentication configuration
   *
   * @schema ClusterSpecPostgresqlLdap#bindAsAuth
   */
  readonly bindAsAuth?: ClusterSpecPostgresqlLdapBindAsAuth;

  /**
   * Bind+Search authentication configuration
   *
   * @schema ClusterSpecPostgresqlLdap#bindSearchAuth
   */
  readonly bindSearchAuth?: ClusterSpecPostgresqlLdapBindSearchAuth;

  /**
   * LDAP server port
   *
   * @schema ClusterSpecPostgresqlLdap#port
   */
  readonly port?: number;

  /**
   * LDAP schema to be used, possible options are `ldap` and `ldaps`
   *
   * @schema ClusterSpecPostgresqlLdap#scheme
   */
  readonly scheme?: ClusterSpecPostgresqlLdapScheme;

  /**
   * LDAP hostname or IP address
   *
   * @schema ClusterSpecPostgresqlLdap#server
   */
  readonly server?: string;

  /**
   * Set to 'true' to enable LDAP over TLS. 'false' is default
   *
   * @schema ClusterSpecPostgresqlLdap#tls
   */
  readonly tls?: boolean;

}

/**
 * Converts an object of type 'ClusterSpecPostgresqlLdap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecPostgresqlLdap(obj: ClusterSpecPostgresqlLdap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bindAsAuth': toJson_ClusterSpecPostgresqlLdapBindAsAuth(obj.bindAsAuth),
    'bindSearchAuth': toJson_ClusterSpecPostgresqlLdapBindSearchAuth(obj.bindSearchAuth),
    'port': obj.port,
    'scheme': obj.scheme,
    'server': obj.server,
    'tls': obj.tls,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Requirements to be met by sync replicas. This will affect how the "synchronous_standby_names" parameter will be
 * set up.
 *
 * @schema ClusterSpecPostgresqlSyncReplicaElectionConstraint
 */
export interface ClusterSpecPostgresqlSyncReplicaElectionConstraint {
  /**
   * This flag enables the constraints for sync replicas
   *
   * @schema ClusterSpecPostgresqlSyncReplicaElectionConstraint#enabled
   */
  readonly enabled: boolean;

  /**
   * A list of node labels values to extract and compare to evaluate if the pods reside in the same topology or not
   *
   * @schema ClusterSpecPostgresqlSyncReplicaElectionConstraint#nodeLabelsAntiAffinity
   */
  readonly nodeLabelsAntiAffinity?: string[];

}

/**
 * Converts an object of type 'ClusterSpecPostgresqlSyncReplicaElectionConstraint' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecPostgresqlSyncReplicaElectionConstraint(obj: ClusterSpecPostgresqlSyncReplicaElectionConstraint | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'nodeLabelsAntiAffinity': obj.nodeLabelsAntiAffinity?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Projection that may be projected along with other supported volume types
 *
 * @schema ClusterSpecProjectedVolumeTemplateSources
 */
export interface ClusterSpecProjectedVolumeTemplateSources {
  /**
   * ClusterTrustBundle allows a pod to access the `.spec.trustBundle` field
   * of ClusterTrustBundle objects in an auto-updating file.
   *
   *
   * Alpha, gated by the ClusterTrustBundleProjection feature gate.
   *
   *
   * ClusterTrustBundle objects can either be selected by name, or by the
   * combination of signer name and a label selector.
   *
   *
   * Kubelet performs aggressive normalization of the PEM contents written
   * into the pod filesystem.  Esoteric PEM features such as inter-block
   * comments and block headers are stripped.  Certificates are deduplicated.
   * The ordering of certificates within the file is arbitrary, and Kubelet
   * may change the order over time.
   *
   * @schema ClusterSpecProjectedVolumeTemplateSources#clusterTrustBundle
   */
  readonly clusterTrustBundle?: ClusterSpecProjectedVolumeTemplateSourcesClusterTrustBundle;

  /**
   * configMap information about the configMap data to project
   *
   * @schema ClusterSpecProjectedVolumeTemplateSources#configMap
   */
  readonly configMap?: ClusterSpecProjectedVolumeTemplateSourcesConfigMap;

  /**
   * downwardAPI information about the downwardAPI data to project
   *
   * @schema ClusterSpecProjectedVolumeTemplateSources#downwardAPI
   */
  readonly downwardApi?: ClusterSpecProjectedVolumeTemplateSourcesDownwardApi;

  /**
   * secret information about the secret data to project
   *
   * @schema ClusterSpecProjectedVolumeTemplateSources#secret
   */
  readonly secret?: ClusterSpecProjectedVolumeTemplateSourcesSecret;

  /**
   * serviceAccountToken is information about the serviceAccountToken data to project
   *
   * @schema ClusterSpecProjectedVolumeTemplateSources#serviceAccountToken
   */
  readonly serviceAccountToken?: ClusterSpecProjectedVolumeTemplateSourcesServiceAccountToken;

}

/**
 * Converts an object of type 'ClusterSpecProjectedVolumeTemplateSources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecProjectedVolumeTemplateSources(obj: ClusterSpecProjectedVolumeTemplateSources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterTrustBundle': toJson_ClusterSpecProjectedVolumeTemplateSourcesClusterTrustBundle(obj.clusterTrustBundle),
    'configMap': toJson_ClusterSpecProjectedVolumeTemplateSourcesConfigMap(obj.configMap),
    'downwardAPI': toJson_ClusterSpecProjectedVolumeTemplateSourcesDownwardApi(obj.downwardApi),
    'secret': toJson_ClusterSpecProjectedVolumeTemplateSourcesSecret(obj.secret),
    'serviceAccountToken': toJson_ClusterSpecProjectedVolumeTemplateSourcesServiceAccountToken(obj.serviceAccountToken),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Replication slots for high availability configuration
 *
 * @schema ClusterSpecReplicationSlotsHighAvailability
 */
export interface ClusterSpecReplicationSlotsHighAvailability {
  /**
   * If enabled (default), the operator will automatically manage replication slots
   * on the primary instance and use them in streaming replication
   * connections with all the standby instances that are part of the HA
   * cluster. If disabled, the operator will not take advantage
   * of replication slots in streaming connections with the replicas.
   * This feature also controls replication slots in replica cluster,
   * from the designated primary to its cascading replicas.
   *
   * @schema ClusterSpecReplicationSlotsHighAvailability#enabled
   */
  readonly enabled?: boolean;

  /**
   * Prefix for replication slots managed by the operator for HA.
   * It may only contain lower case letters, numbers, and the underscore character.
   * This can only be set at creation time. By default set to `_cnpg_`.
   *
   * @schema ClusterSpecReplicationSlotsHighAvailability#slotPrefix
   */
  readonly slotPrefix?: string;

}

/**
 * Converts an object of type 'ClusterSpecReplicationSlotsHighAvailability' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecReplicationSlotsHighAvailability(obj: ClusterSpecReplicationSlotsHighAvailability | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'slotPrefix': obj.slotPrefix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configures the synchronization of the user defined physical replication slots
 *
 * @schema ClusterSpecReplicationSlotsSynchronizeReplicas
 */
export interface ClusterSpecReplicationSlotsSynchronizeReplicas {
  /**
   * When set to true, every replication slot that is on the primary is synchronized on each standby
   *
   * @schema ClusterSpecReplicationSlotsSynchronizeReplicas#enabled
   */
  readonly enabled: boolean;

  /**
   * List of regular expression patterns to match the names of replication slots to be excluded (by default empty)
   *
   * @schema ClusterSpecReplicationSlotsSynchronizeReplicas#excludePatterns
   */
  readonly excludePatterns?: string[];

}

/**
 * Converts an object of type 'ClusterSpecReplicationSlotsSynchronizeReplicas' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecReplicationSlotsSynchronizeReplicas(obj: ClusterSpecReplicationSlotsSynchronizeReplicas | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'excludePatterns': obj.excludePatterns?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema ClusterSpecResourcesClaims
 */
export interface ClusterSpecResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema ClusterSpecResourcesClaims#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterSpecResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecResourcesClaims(obj: ClusterSpecResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecResourcesLimits
 */
export class ClusterSpecResourcesLimits {
  public static fromNumber(value: number): ClusterSpecResourcesLimits {
    return new ClusterSpecResourcesLimits(value);
  }
  public static fromString(value: string): ClusterSpecResourcesLimits {
    return new ClusterSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema ClusterSpecResourcesRequests
 */
export class ClusterSpecResourcesRequests {
  public static fromNumber(value: number): ClusterSpecResourcesRequests {
    return new ClusterSpecResourcesRequests(value);
  }
  public static fromString(value: string): ClusterSpecResourcesRequests {
    return new ClusterSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Metadata are the metadata to be used for the generated
 * service account
 *
 * @schema ClusterSpecServiceAccountTemplateMetadata
 */
export interface ClusterSpecServiceAccountTemplateMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be
   * set by external tools to store and retrieve arbitrary metadata. They are not
   * queryable and should be preserved when modifying objects.
   * More info: http://kubernetes.io/docs/user-guide/annotations
   *
   * @schema ClusterSpecServiceAccountTemplateMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Map of string keys and values that can be used to organize and categorize
   * (scope and select) objects. May match selectors of replication controllers
   * and services.
   * More info: http://kubernetes.io/docs/user-guide/labels
   *
   * @schema ClusterSpecServiceAccountTemplateMetadata#labels
   */
  readonly labels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterSpecServiceAccountTemplateMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecServiceAccountTemplateMetadata(obj: ClusterSpecServiceAccountTemplateMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template to be used to generate the Persistent Volume Claim
 *
 * @schema ClusterSpecStoragePvcTemplate
 */
export interface ClusterSpecStoragePvcTemplate {
  /**
   * accessModes contains the desired access modes the volume should have.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema ClusterSpecStoragePvcTemplate#accessModes
   */
  readonly accessModes?: string[];

  /**
   * dataSource field can be used to specify either:
   * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
   * * An existing PVC (PersistentVolumeClaim)
   * If the provisioner or an external controller can support the specified data source,
   * it will create a new volume based on the contents of the specified data source.
   * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
   * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
   * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
   *
   * @schema ClusterSpecStoragePvcTemplate#dataSource
   */
  readonly dataSource?: ClusterSpecStoragePvcTemplateDataSource;

  /**
   * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
   * volume is desired. This may be any object from a non-empty API group (non
   * core object) or a PersistentVolumeClaim object.
   * When this field is specified, volume binding will only succeed if the type of
   * the specified object matches some installed volume populator or dynamic
   * provisioner.
   * This field will replace the functionality of the dataSource field and as such
   * if both fields are non-empty, they must have the same value. For backwards
   * compatibility, when namespace isn't specified in dataSourceRef,
   * both fields (dataSource and dataSourceRef) will be set to the same
   * value automatically if one of them is empty and the other is non-empty.
   * When namespace is specified in dataSourceRef,
   * dataSource isn't set to the same value and must be empty.
   * There are three important differences between dataSource and dataSourceRef:
   * * While dataSource only allows two specific types of objects, dataSourceRef
   * allows any non-core object, as well as PersistentVolumeClaim objects.
   * * While dataSource ignores disallowed values (dropping them), dataSourceRef
   * preserves all values, and generates an error if a disallowed value is
   * specified.
   * * While dataSource only allows local objects, dataSourceRef allows objects
   * in any namespaces.
   * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
   * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema ClusterSpecStoragePvcTemplate#dataSourceRef
   */
  readonly dataSourceRef?: ClusterSpecStoragePvcTemplateDataSourceRef;

  /**
   * resources represents the minimum resources the volume should have.
   * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
   * that are lower than previous value but must still be higher than capacity recorded in the
   * status field of the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
   *
   * @schema ClusterSpecStoragePvcTemplate#resources
   */
  readonly resources?: ClusterSpecStoragePvcTemplateResources;

  /**
   * selector is a label query over volumes to consider for binding.
   *
   * @schema ClusterSpecStoragePvcTemplate#selector
   */
  readonly selector?: ClusterSpecStoragePvcTemplateSelector;

  /**
   * storageClassName is the name of the StorageClass required by the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   *
   * @schema ClusterSpecStoragePvcTemplate#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
   * If specified, the CSI driver will create or update the volume with the attributes defined
   * in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
   * it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
   * will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
   * If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
   * will be set by the persistentvolume controller if it exists.
   * If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
   * set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
   * exists.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#volumeattributesclass
   * (Alpha) Using this field requires the VolumeAttributesClass feature gate to be enabled.
   *
   * @schema ClusterSpecStoragePvcTemplate#volumeAttributesClassName
   */
  readonly volumeAttributesClassName?: string;

  /**
   * volumeMode defines what type of volume is required by the claim.
   * Value of Filesystem is implied when not included in claim spec.
   *
   * @schema ClusterSpecStoragePvcTemplate#volumeMode
   */
  readonly volumeMode?: string;

  /**
   * volumeName is the binding reference to the PersistentVolume backing this claim.
   *
   * @schema ClusterSpecStoragePvcTemplate#volumeName
   */
  readonly volumeName?: string;

}

/**
 * Converts an object of type 'ClusterSpecStoragePvcTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecStoragePvcTemplate(obj: ClusterSpecStoragePvcTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessModes': obj.accessModes?.map(y => y),
    'dataSource': toJson_ClusterSpecStoragePvcTemplateDataSource(obj.dataSource),
    'dataSourceRef': toJson_ClusterSpecStoragePvcTemplateDataSourceRef(obj.dataSourceRef),
    'resources': toJson_ClusterSpecStoragePvcTemplateResources(obj.resources),
    'selector': toJson_ClusterSpecStoragePvcTemplateSelector(obj.selector),
    'storageClassName': obj.storageClassName,
    'volumeAttributesClassName': obj.volumeAttributesClassName,
    'volumeMode': obj.volumeMode,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Owner is the PostgreSQL user owning the tablespace
 *
 * @schema ClusterSpecTablespacesOwner
 */
export interface ClusterSpecTablespacesOwner {
  /**
   * @schema ClusterSpecTablespacesOwner#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'ClusterSpecTablespacesOwner' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecTablespacesOwner(obj: ClusterSpecTablespacesOwner | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The storage configuration for the tablespace
 *
 * @schema ClusterSpecTablespacesStorage
 */
export interface ClusterSpecTablespacesStorage {
  /**
   * Template to be used to generate the Persistent Volume Claim
   *
   * @schema ClusterSpecTablespacesStorage#pvcTemplate
   */
  readonly pvcTemplate?: ClusterSpecTablespacesStoragePvcTemplate;

  /**
   * Resize existent PVCs, defaults to true
   *
   * @schema ClusterSpecTablespacesStorage#resizeInUseVolumes
   */
  readonly resizeInUseVolumes?: boolean;

  /**
   * Size of the storage. Required if not already specified in the PVC template.
   * Changes to this field are automatically reapplied to the created PVCs.
   * Size cannot be decreased.
   *
   * @schema ClusterSpecTablespacesStorage#size
   */
  readonly size?: string;

  /**
   * StorageClass to use for PVCs. Applied after
   * evaluating the PVC template, if available.
   * If not specified, the generated PVCs will use the
   * default storage class
   *
   * @schema ClusterSpecTablespacesStorage#storageClass
   */
  readonly storageClass?: string;

}

/**
 * Converts an object of type 'ClusterSpecTablespacesStorage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecTablespacesStorage(obj: ClusterSpecTablespacesStorage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pvcTemplate': toJson_ClusterSpecTablespacesStoragePvcTemplate(obj.pvcTemplate),
    'resizeInUseVolumes': obj.resizeInUseVolumes,
    'size': obj.size,
    'storageClass': obj.storageClass,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LabelSelector is used to find matching pods.
 * Pods that match this label selector are counted to determine the number of pods
 * in their corresponding topology domain.
 *
 * @schema ClusterSpecTopologySpreadConstraintsLabelSelector
 */
export interface ClusterSpecTopologySpreadConstraintsLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterSpecTopologySpreadConstraintsLabelSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterSpecTopologySpreadConstraintsLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterSpecTopologySpreadConstraintsLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterSpecTopologySpreadConstraintsLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecTopologySpreadConstraintsLabelSelector(obj: ClusterSpecTopologySpreadConstraintsLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterSpecTopologySpreadConstraintsLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template to be used to generate the Persistent Volume Claim
 *
 * @schema ClusterSpecWalStoragePvcTemplate
 */
export interface ClusterSpecWalStoragePvcTemplate {
  /**
   * accessModes contains the desired access modes the volume should have.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema ClusterSpecWalStoragePvcTemplate#accessModes
   */
  readonly accessModes?: string[];

  /**
   * dataSource field can be used to specify either:
   * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
   * * An existing PVC (PersistentVolumeClaim)
   * If the provisioner or an external controller can support the specified data source,
   * it will create a new volume based on the contents of the specified data source.
   * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
   * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
   * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
   *
   * @schema ClusterSpecWalStoragePvcTemplate#dataSource
   */
  readonly dataSource?: ClusterSpecWalStoragePvcTemplateDataSource;

  /**
   * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
   * volume is desired. This may be any object from a non-empty API group (non
   * core object) or a PersistentVolumeClaim object.
   * When this field is specified, volume binding will only succeed if the type of
   * the specified object matches some installed volume populator or dynamic
   * provisioner.
   * This field will replace the functionality of the dataSource field and as such
   * if both fields are non-empty, they must have the same value. For backwards
   * compatibility, when namespace isn't specified in dataSourceRef,
   * both fields (dataSource and dataSourceRef) will be set to the same
   * value automatically if one of them is empty and the other is non-empty.
   * When namespace is specified in dataSourceRef,
   * dataSource isn't set to the same value and must be empty.
   * There are three important differences between dataSource and dataSourceRef:
   * * While dataSource only allows two specific types of objects, dataSourceRef
   * allows any non-core object, as well as PersistentVolumeClaim objects.
   * * While dataSource ignores disallowed values (dropping them), dataSourceRef
   * preserves all values, and generates an error if a disallowed value is
   * specified.
   * * While dataSource only allows local objects, dataSourceRef allows objects
   * in any namespaces.
   * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
   * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema ClusterSpecWalStoragePvcTemplate#dataSourceRef
   */
  readonly dataSourceRef?: ClusterSpecWalStoragePvcTemplateDataSourceRef;

  /**
   * resources represents the minimum resources the volume should have.
   * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
   * that are lower than previous value but must still be higher than capacity recorded in the
   * status field of the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
   *
   * @schema ClusterSpecWalStoragePvcTemplate#resources
   */
  readonly resources?: ClusterSpecWalStoragePvcTemplateResources;

  /**
   * selector is a label query over volumes to consider for binding.
   *
   * @schema ClusterSpecWalStoragePvcTemplate#selector
   */
  readonly selector?: ClusterSpecWalStoragePvcTemplateSelector;

  /**
   * storageClassName is the name of the StorageClass required by the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   *
   * @schema ClusterSpecWalStoragePvcTemplate#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
   * If specified, the CSI driver will create or update the volume with the attributes defined
   * in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
   * it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
   * will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
   * If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
   * will be set by the persistentvolume controller if it exists.
   * If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
   * set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
   * exists.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#volumeattributesclass
   * (Alpha) Using this field requires the VolumeAttributesClass feature gate to be enabled.
   *
   * @schema ClusterSpecWalStoragePvcTemplate#volumeAttributesClassName
   */
  readonly volumeAttributesClassName?: string;

  /**
   * volumeMode defines what type of volume is required by the claim.
   * Value of Filesystem is implied when not included in claim spec.
   *
   * @schema ClusterSpecWalStoragePvcTemplate#volumeMode
   */
  readonly volumeMode?: string;

  /**
   * volumeName is the binding reference to the PersistentVolume backing this claim.
   *
   * @schema ClusterSpecWalStoragePvcTemplate#volumeName
   */
  readonly volumeName?: string;

}

/**
 * Converts an object of type 'ClusterSpecWalStoragePvcTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecWalStoragePvcTemplate(obj: ClusterSpecWalStoragePvcTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessModes': obj.accessModes?.map(y => y),
    'dataSource': toJson_ClusterSpecWalStoragePvcTemplateDataSource(obj.dataSource),
    'dataSourceRef': toJson_ClusterSpecWalStoragePvcTemplateDataSourceRef(obj.dataSourceRef),
    'resources': toJson_ClusterSpecWalStoragePvcTemplateResources(obj.resources),
    'selector': toJson_ClusterSpecWalStoragePvcTemplateSelector(obj.selector),
    'storageClassName': obj.storageClassName,
    'volumeAttributesClassName': obj.volumeAttributesClassName,
    'volumeMode': obj.volumeMode,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm: ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm,
   * in the range 1-100.
   *
   * @schema ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;

}

/**
 * Converts an object of type 'ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podAffinityTerm': toJson_ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector
 * relative to the given namespace(s)) that this pod should be
 * co-located (affinity) or not co-located (anti-affinity) with,
 * where co-located is defined as running on a node whose value of
 * the label with key <topologyKey> matches that of any node on which
 * a pod of the set of pods is running
 *
 * @schema ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `LabelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both MatchLabelKeys and LabelSelector.
   * Also, MatchLabelKeys cannot be set when LabelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `LabelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both MismatchLabelKeys and LabelSelector.
   * Also, MismatchLabelKeys cannot be set when LabelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'mismatchLabelKeys': obj.mismatchLabelKeys?.map(y => y),
    'namespaceSelector': toJson_ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm: ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm,
   * in the range 1-100.
   *
   * @schema ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;

}

/**
 * Converts an object of type 'ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podAffinityTerm': toJson_ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector
 * relative to the given namespace(s)) that this pod should be
 * co-located (affinity) or not co-located (anti-affinity) with,
 * where co-located is defined as running on a node whose value of
 * the label with key <topologyKey> matches that of any node on which
 * a pod of the set of pods is running
 *
 * @schema ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `LabelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both MatchLabelKeys and LabelSelector.
   * Also, MatchLabelKeys cannot be set when LabelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `LabelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both MismatchLabelKeys and LabelSelector.
   * Also, MismatchLabelKeys cannot be set when LabelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'mismatchLabelKeys': obj.mismatchLabelKeys?.map(y => y),
    'namespaceSelector': toJson_ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * An empty preferred scheduling term matches all objects with implicit weight 0
 * (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
 *
 * @schema ClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface ClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * A node selector term, associated with the corresponding weight.
   *
   * @schema ClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference: ClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
   *
   * @schema ClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;

}

/**
 * Converts an object of type 'ClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: ClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preference': toJson_ClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj.preference),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * If the affinity requirements specified by this field are not met at
 * scheduling time, the pod will not be scheduled onto the node.
 * If the affinity requirements specified by this field cease to be met
 * at some point during pod execution (e.g. due to an update), the system
 * may or may not try to eventually evict the pod from its node.
 *
 * @schema ClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface ClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A list of node selector terms. The terms are ORed.
   *
   * @schema ClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms: ClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];

}

/**
 * Converts an object of type 'ClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: ClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeSelectorTerms': obj.nodeSelectorTerms?.map(y => toJson_ClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The credentials to use to upload data to Azure Blob Storage
 *
 * @schema ClusterSpecBackupBarmanObjectStoreAzureCredentials
 */
export interface ClusterSpecBackupBarmanObjectStoreAzureCredentials {
  /**
   * The connection string to be used
   *
   * @schema ClusterSpecBackupBarmanObjectStoreAzureCredentials#connectionString
   */
  readonly connectionString?: ClusterSpecBackupBarmanObjectStoreAzureCredentialsConnectionString;

  /**
   * Use the Azure AD based authentication without providing explicitly the keys.
   *
   * @schema ClusterSpecBackupBarmanObjectStoreAzureCredentials#inheritFromAzureAD
   */
  readonly inheritFromAzureAd?: boolean;

  /**
   * The storage account where to upload data
   *
   * @schema ClusterSpecBackupBarmanObjectStoreAzureCredentials#storageAccount
   */
  readonly storageAccount?: ClusterSpecBackupBarmanObjectStoreAzureCredentialsStorageAccount;

  /**
   * The storage account key to be used in conjunction
   * with the storage account name
   *
   * @schema ClusterSpecBackupBarmanObjectStoreAzureCredentials#storageKey
   */
  readonly storageKey?: ClusterSpecBackupBarmanObjectStoreAzureCredentialsStorageKey;

  /**
   * A shared-access-signature to be used in conjunction with
   * the storage account name
   *
   * @schema ClusterSpecBackupBarmanObjectStoreAzureCredentials#storageSasToken
   */
  readonly storageSasToken?: ClusterSpecBackupBarmanObjectStoreAzureCredentialsStorageSasToken;

}

/**
 * Converts an object of type 'ClusterSpecBackupBarmanObjectStoreAzureCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecBackupBarmanObjectStoreAzureCredentials(obj: ClusterSpecBackupBarmanObjectStoreAzureCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionString': toJson_ClusterSpecBackupBarmanObjectStoreAzureCredentialsConnectionString(obj.connectionString),
    'inheritFromAzureAD': obj.inheritFromAzureAd,
    'storageAccount': toJson_ClusterSpecBackupBarmanObjectStoreAzureCredentialsStorageAccount(obj.storageAccount),
    'storageKey': toJson_ClusterSpecBackupBarmanObjectStoreAzureCredentialsStorageKey(obj.storageKey),
    'storageSasToken': toJson_ClusterSpecBackupBarmanObjectStoreAzureCredentialsStorageSasToken(obj.storageSasToken),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The configuration to be used to backup the data files
 * When not defined, base backups files will be stored uncompressed and may
 * be unencrypted in the object store, according to the bucket default
 * policy.
 *
 * @schema ClusterSpecBackupBarmanObjectStoreData
 */
export interface ClusterSpecBackupBarmanObjectStoreData {
  /**
   * AdditionalCommandArgs represents additional arguments that can be appended
   * to the 'barman-cloud-backup' command-line invocation. These arguments
   * provide flexibility to customize the backup process further according to
   * specific requirements or configurations.
   *
   *
   * Example:
   * In a scenario where specialized backup options are required, such as setting
   * a specific timeout or defining custom behavior, users can use this field
   * to specify additional command arguments.
   *
   *
   * Note:
   * It's essential to ensure that the provided arguments are valid and supported
   * by the 'barman-cloud-backup' command, to avoid potential errors or unintended
   * behavior during execution.
   *
   * @schema ClusterSpecBackupBarmanObjectStoreData#additionalCommandArgs
   */
  readonly additionalCommandArgs?: string[];

  /**
   * Compress a backup file (a tar file per tablespace) while streaming it
   * to the object store. Available options are empty string (no
   * compression, default), `gzip`, `bzip2` or `snappy`.
   *
   * @schema ClusterSpecBackupBarmanObjectStoreData#compression
   */
  readonly compression?: ClusterSpecBackupBarmanObjectStoreDataCompression;

  /**
   * Whenever to force the encryption of files (if the bucket is
   * not already configured for that).
   * Allowed options are empty string (use the bucket policy, default),
   * `AES256` and `aws:kms`
   *
   * @schema ClusterSpecBackupBarmanObjectStoreData#encryption
   */
  readonly encryption?: ClusterSpecBackupBarmanObjectStoreDataEncryption;

  /**
   * Control whether the I/O workload for the backup initial checkpoint will
   * be limited, according to the `checkpoint_completion_target` setting on
   * the PostgreSQL server. If set to true, an immediate checkpoint will be
   * used, meaning PostgreSQL will complete the checkpoint as soon as
   * possible. `false` by default.
   *
   * @schema ClusterSpecBackupBarmanObjectStoreData#immediateCheckpoint
   */
  readonly immediateCheckpoint?: boolean;

  /**
   * The number of parallel jobs to be used to upload the backup, defaults
   * to 2
   *
   * @schema ClusterSpecBackupBarmanObjectStoreData#jobs
   */
  readonly jobs?: number;

}

/**
 * Converts an object of type 'ClusterSpecBackupBarmanObjectStoreData' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecBackupBarmanObjectStoreData(obj: ClusterSpecBackupBarmanObjectStoreData | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalCommandArgs': obj.additionalCommandArgs?.map(y => y),
    'compression': obj.compression,
    'encryption': obj.encryption,
    'immediateCheckpoint': obj.immediateCheckpoint,
    'jobs': obj.jobs,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EndpointCA store the CA bundle of the barman endpoint.
 * Useful when using self-signed certificates to avoid
 * errors with certificate issuer and barman-cloud-wal-archive
 *
 * @schema ClusterSpecBackupBarmanObjectStoreEndpointCa
 */
export interface ClusterSpecBackupBarmanObjectStoreEndpointCa {
  /**
   * The key to select
   *
   * @schema ClusterSpecBackupBarmanObjectStoreEndpointCa#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   *
   * @schema ClusterSpecBackupBarmanObjectStoreEndpointCa#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterSpecBackupBarmanObjectStoreEndpointCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecBackupBarmanObjectStoreEndpointCa(obj: ClusterSpecBackupBarmanObjectStoreEndpointCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The credentials to use to upload data to Google Cloud Storage
 *
 * @schema ClusterSpecBackupBarmanObjectStoreGoogleCredentials
 */
export interface ClusterSpecBackupBarmanObjectStoreGoogleCredentials {
  /**
   * The secret containing the Google Cloud Storage JSON file with the credentials
   *
   * @schema ClusterSpecBackupBarmanObjectStoreGoogleCredentials#applicationCredentials
   */
  readonly applicationCredentials?: ClusterSpecBackupBarmanObjectStoreGoogleCredentialsApplicationCredentials;

  /**
   * If set to true, will presume that it's running inside a GKE environment,
   * default to false.
   *
   * @schema ClusterSpecBackupBarmanObjectStoreGoogleCredentials#gkeEnvironment
   */
  readonly gkeEnvironment?: boolean;

}

/**
 * Converts an object of type 'ClusterSpecBackupBarmanObjectStoreGoogleCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecBackupBarmanObjectStoreGoogleCredentials(obj: ClusterSpecBackupBarmanObjectStoreGoogleCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'applicationCredentials': toJson_ClusterSpecBackupBarmanObjectStoreGoogleCredentialsApplicationCredentials(obj.applicationCredentials),
    'gkeEnvironment': obj.gkeEnvironment,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The credentials to use to upload data to S3
 *
 * @schema ClusterSpecBackupBarmanObjectStoreS3Credentials
 */
export interface ClusterSpecBackupBarmanObjectStoreS3Credentials {
  /**
   * The reference to the access key id
   *
   * @schema ClusterSpecBackupBarmanObjectStoreS3Credentials#accessKeyId
   */
  readonly accessKeyId?: ClusterSpecBackupBarmanObjectStoreS3CredentialsAccessKeyId;

  /**
   * Use the role based authentication without providing explicitly the keys.
   *
   * @schema ClusterSpecBackupBarmanObjectStoreS3Credentials#inheritFromIAMRole
   */
  readonly inheritFromIamRole?: boolean;

  /**
   * The reference to the secret containing the region name
   *
   * @schema ClusterSpecBackupBarmanObjectStoreS3Credentials#region
   */
  readonly region?: ClusterSpecBackupBarmanObjectStoreS3CredentialsRegion;

  /**
   * The reference to the secret access key
   *
   * @schema ClusterSpecBackupBarmanObjectStoreS3Credentials#secretAccessKey
   */
  readonly secretAccessKey?: ClusterSpecBackupBarmanObjectStoreS3CredentialsSecretAccessKey;

  /**
   * The references to the session key
   *
   * @schema ClusterSpecBackupBarmanObjectStoreS3Credentials#sessionToken
   */
  readonly sessionToken?: ClusterSpecBackupBarmanObjectStoreS3CredentialsSessionToken;

}

/**
 * Converts an object of type 'ClusterSpecBackupBarmanObjectStoreS3Credentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecBackupBarmanObjectStoreS3Credentials(obj: ClusterSpecBackupBarmanObjectStoreS3Credentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessKeyId': toJson_ClusterSpecBackupBarmanObjectStoreS3CredentialsAccessKeyId(obj.accessKeyId),
    'inheritFromIAMRole': obj.inheritFromIamRole,
    'region': toJson_ClusterSpecBackupBarmanObjectStoreS3CredentialsRegion(obj.region),
    'secretAccessKey': toJson_ClusterSpecBackupBarmanObjectStoreS3CredentialsSecretAccessKey(obj.secretAccessKey),
    'sessionToken': toJson_ClusterSpecBackupBarmanObjectStoreS3CredentialsSessionToken(obj.sessionToken),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The configuration for the backup of the WAL stream.
 * When not defined, WAL files will be stored uncompressed and may be
 * unencrypted in the object store, according to the bucket default policy.
 *
 * @schema ClusterSpecBackupBarmanObjectStoreWal
 */
export interface ClusterSpecBackupBarmanObjectStoreWal {
  /**
   * Compress a WAL file before sending it to the object store. Available
   * options are empty string (no compression, default), `gzip`, `bzip2` or `snappy`.
   *
   * @schema ClusterSpecBackupBarmanObjectStoreWal#compression
   */
  readonly compression?: ClusterSpecBackupBarmanObjectStoreWalCompression;

  /**
   * Whenever to force the encryption of files (if the bucket is
   * not already configured for that).
   * Allowed options are empty string (use the bucket policy, default),
   * `AES256` and `aws:kms`
   *
   * @schema ClusterSpecBackupBarmanObjectStoreWal#encryption
   */
  readonly encryption?: ClusterSpecBackupBarmanObjectStoreWalEncryption;

  /**
   * Number of WAL files to be either archived in parallel (when the
   * PostgreSQL instance is archiving to a backup object store) or
   * restored in parallel (when a PostgreSQL standby is fetching WAL
   * files from a recovery object store). If not specified, WAL files
   * will be processed one at a time. It accepts a positive integer as a
   * value - with 1 being the minimum accepted value.
   *
   * @schema ClusterSpecBackupBarmanObjectStoreWal#maxParallel
   */
  readonly maxParallel?: number;

}

/**
 * Converts an object of type 'ClusterSpecBackupBarmanObjectStoreWal' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecBackupBarmanObjectStoreWal(obj: ClusterSpecBackupBarmanObjectStoreWal | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'compression': obj.compression,
    'encryption': obj.encryption,
    'maxParallel': obj.maxParallel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configuration parameters to control the online/hot backup with volume snapshots
 *
 * @schema ClusterSpecBackupVolumeSnapshotOnlineConfiguration
 */
export interface ClusterSpecBackupVolumeSnapshotOnlineConfiguration {
  /**
   * Control whether the I/O workload for the backup initial checkpoint will
   * be limited, according to the `checkpoint_completion_target` setting on
   * the PostgreSQL server. If set to true, an immediate checkpoint will be
   * used, meaning PostgreSQL will complete the checkpoint as soon as
   * possible. `false` by default.
   *
   * @schema ClusterSpecBackupVolumeSnapshotOnlineConfiguration#immediateCheckpoint
   */
  readonly immediateCheckpoint?: boolean;

  /**
   * If false, the function will return immediately after the backup is completed,
   * without waiting for WAL to be archived.
   * This behavior is only useful with backup software that independently monitors WAL archiving.
   * Otherwise, WAL required to make the backup consistent might be missing and make the backup useless.
   * By default, or when this parameter is true, pg_backup_stop will wait for WAL to be archived when archiving is
   * enabled.
   * On a standby, this means that it will wait only when archive_mode = always.
   * If write activity on the primary is low, it may be useful to run pg_switch_wal on the primary in order to trigger
   * an immediate segment switch.
   *
   * @schema ClusterSpecBackupVolumeSnapshotOnlineConfiguration#waitForArchive
   */
  readonly waitForArchive?: boolean;

}

/**
 * Converts an object of type 'ClusterSpecBackupVolumeSnapshotOnlineConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecBackupVolumeSnapshotOnlineConfiguration(obj: ClusterSpecBackupVolumeSnapshotOnlineConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'immediateCheckpoint': obj.immediateCheckpoint,
    'waitForArchive': obj.waitForArchive,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SnapshotOwnerReference indicates the type of owner reference the snapshot should have
 *
 * @schema ClusterSpecBackupVolumeSnapshotSnapshotOwnerReference
 */
export enum ClusterSpecBackupVolumeSnapshotSnapshotOwnerReference {
  /** none */
  NONE = "none",
  /** cluster */
  CLUSTER = "cluster",
  /** backup */
  BACKUP = "backup",
}

/**
 * Bootstraps the new cluster by importing data from an existing PostgreSQL
 * instance using logical backup (`pg_dump` and `pg_restore`)
 *
 * @schema ClusterSpecBootstrapInitdbImport
 */
export interface ClusterSpecBootstrapInitdbImport {
  /**
   * The databases to import
   *
   * @schema ClusterSpecBootstrapInitdbImport#databases
   */
  readonly databases: string[];

  /**
   * List of SQL queries to be executed as a superuser in the application
   * database right after is imported - to be used with extreme care
   * (by default empty). Only available in microservice type.
   *
   * @schema ClusterSpecBootstrapInitdbImport#postImportApplicationSQL
   */
  readonly postImportApplicationSql?: string[];

  /**
   * The roles to import
   *
   * @schema ClusterSpecBootstrapInitdbImport#roles
   */
  readonly roles?: string[];

  /**
   * When set to true, only the `pre-data` and `post-data` sections of
   * `pg_restore` are invoked, avoiding data import. Default: `false`.
   *
   * @schema ClusterSpecBootstrapInitdbImport#schemaOnly
   */
  readonly schemaOnly?: boolean;

  /**
   * The source of the import
   *
   * @schema ClusterSpecBootstrapInitdbImport#source
   */
  readonly source: ClusterSpecBootstrapInitdbImportSource;

  /**
   * The import type. Can be `microservice` or `monolith`.
   *
   * @schema ClusterSpecBootstrapInitdbImport#type
   */
  readonly type: ClusterSpecBootstrapInitdbImportType;

}

/**
 * Converts an object of type 'ClusterSpecBootstrapInitdbImport' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecBootstrapInitdbImport(obj: ClusterSpecBootstrapInitdbImport | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'databases': obj.databases?.map(y => y),
    'postImportApplicationSQL': obj.postImportApplicationSql?.map(y => y),
    'roles': obj.roles?.map(y => y),
    'schemaOnly': obj.schemaOnly,
    'source': toJson_ClusterSpecBootstrapInitdbImportSource(obj.source),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PostInitApplicationSQLRefs points references to ConfigMaps or Secrets which
 * contain SQL files, the general implementation order to these references is
 * from all Secrets to all ConfigMaps, and inside Secrets or ConfigMaps,
 * the implementation order is same as the order of each array
 * (by default empty)
 *
 * @schema ClusterSpecBootstrapInitdbPostInitApplicationSqlRefs
 */
export interface ClusterSpecBootstrapInitdbPostInitApplicationSqlRefs {
  /**
   * ConfigMapRefs holds a list of references to ConfigMaps
   *
   * @schema ClusterSpecBootstrapInitdbPostInitApplicationSqlRefs#configMapRefs
   */
  readonly configMapRefs?: ClusterSpecBootstrapInitdbPostInitApplicationSqlRefsConfigMapRefs[];

  /**
   * SecretRefs holds a list of references to Secrets
   *
   * @schema ClusterSpecBootstrapInitdbPostInitApplicationSqlRefs#secretRefs
   */
  readonly secretRefs?: ClusterSpecBootstrapInitdbPostInitApplicationSqlRefsSecretRefs[];

}

/**
 * Converts an object of type 'ClusterSpecBootstrapInitdbPostInitApplicationSqlRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecBootstrapInitdbPostInitApplicationSqlRefs(obj: ClusterSpecBootstrapInitdbPostInitApplicationSqlRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapRefs': obj.configMapRefs?.map(y => toJson_ClusterSpecBootstrapInitdbPostInitApplicationSqlRefsConfigMapRefs(y)),
    'secretRefs': obj.secretRefs?.map(y => toJson_ClusterSpecBootstrapInitdbPostInitApplicationSqlRefsSecretRefs(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name of the secret containing the initial credentials for the
 * owner of the user database. If empty a new secret will be
 * created from scratch
 *
 * @schema ClusterSpecBootstrapInitdbSecret
 */
export interface ClusterSpecBootstrapInitdbSecret {
  /**
   * Name of the referent.
   *
   * @schema ClusterSpecBootstrapInitdbSecret#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterSpecBootstrapInitdbSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecBootstrapInitdbSecret(obj: ClusterSpecBootstrapInitdbSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name of the secret containing the initial credentials for the
 * owner of the user database. If empty a new secret will be
 * created from scratch
 *
 * @schema ClusterSpecBootstrapPgBasebackupSecret
 */
export interface ClusterSpecBootstrapPgBasebackupSecret {
  /**
   * Name of the referent.
   *
   * @schema ClusterSpecBootstrapPgBasebackupSecret#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterSpecBootstrapPgBasebackupSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecBootstrapPgBasebackupSecret(obj: ClusterSpecBootstrapPgBasebackupSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The backup object containing the physical base backup from which to
 * initiate the recovery procedure.
 * Mutually exclusive with `source` and `volumeSnapshots`.
 *
 * @schema ClusterSpecBootstrapRecoveryBackup
 */
export interface ClusterSpecBootstrapRecoveryBackup {
  /**
   * EndpointCA store the CA bundle of the barman endpoint.
   * Useful when using self-signed certificates to avoid
   * errors with certificate issuer and barman-cloud-wal-archive.
   *
   * @schema ClusterSpecBootstrapRecoveryBackup#endpointCA
   */
  readonly endpointCa?: ClusterSpecBootstrapRecoveryBackupEndpointCa;

  /**
   * Name of the referent.
   *
   * @schema ClusterSpecBootstrapRecoveryBackup#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterSpecBootstrapRecoveryBackup' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecBootstrapRecoveryBackup(obj: ClusterSpecBootstrapRecoveryBackup | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'endpointCA': toJson_ClusterSpecBootstrapRecoveryBackupEndpointCa(obj.endpointCa),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * By default, the recovery process applies all the available
 * WAL files in the archive (full recovery). However, you can also
 * end the recovery as soon as a consistent state is reached or
 * recover to a point-in-time (PITR) by specifying a `RecoveryTarget` object,
 * as expected by PostgreSQL (i.e., timestamp, transaction Id, LSN, ...).
 * More info: https://www.postgresql.org/docs/current/runtime-config-wal.html#RUNTIME-CONFIG-WAL-RECOVERY-TARGET
 *
 * @schema ClusterSpecBootstrapRecoveryRecoveryTarget
 */
export interface ClusterSpecBootstrapRecoveryRecoveryTarget {
  /**
   * The ID of the backup from which to start the recovery process.
   * If empty (default) the operator will automatically detect the backup
   * based on targetTime or targetLSN if specified. Otherwise use the
   * latest available backup in chronological order.
   *
   * @schema ClusterSpecBootstrapRecoveryRecoveryTarget#backupID
   */
  readonly backupId?: string;

  /**
   * Set the target to be exclusive. If omitted, defaults to false, so that
   * in Postgres, `recovery_target_inclusive` will be true
   *
   * @schema ClusterSpecBootstrapRecoveryRecoveryTarget#exclusive
   */
  readonly exclusive?: boolean;

  /**
   * End recovery as soon as a consistent state is reached
   *
   * @schema ClusterSpecBootstrapRecoveryRecoveryTarget#targetImmediate
   */
  readonly targetImmediate?: boolean;

  /**
   * The target LSN (Log Sequence Number)
   *
   * @schema ClusterSpecBootstrapRecoveryRecoveryTarget#targetLSN
   */
  readonly targetLsn?: string;

  /**
   * The target name (to be previously created
   * with `pg_create_restore_point`)
   *
   * @schema ClusterSpecBootstrapRecoveryRecoveryTarget#targetName
   */
  readonly targetName?: string;

  /**
   * The target timeline ("latest" or a positive integer)
   *
   * @schema ClusterSpecBootstrapRecoveryRecoveryTarget#targetTLI
   */
  readonly targetTli?: string;

  /**
   * The target time as a timestamp in the RFC3339 standard
   *
   * @schema ClusterSpecBootstrapRecoveryRecoveryTarget#targetTime
   */
  readonly targetTime?: string;

  /**
   * The target transaction ID
   *
   * @schema ClusterSpecBootstrapRecoveryRecoveryTarget#targetXID
   */
  readonly targetXid?: string;

}

/**
 * Converts an object of type 'ClusterSpecBootstrapRecoveryRecoveryTarget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecBootstrapRecoveryRecoveryTarget(obj: ClusterSpecBootstrapRecoveryRecoveryTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'backupID': obj.backupId,
    'exclusive': obj.exclusive,
    'targetImmediate': obj.targetImmediate,
    'targetLSN': obj.targetLsn,
    'targetName': obj.targetName,
    'targetTLI': obj.targetTli,
    'targetTime': obj.targetTime,
    'targetXID': obj.targetXid,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name of the secret containing the initial credentials for the
 * owner of the user database. If empty a new secret will be
 * created from scratch
 *
 * @schema ClusterSpecBootstrapRecoverySecret
 */
export interface ClusterSpecBootstrapRecoverySecret {
  /**
   * Name of the referent.
   *
   * @schema ClusterSpecBootstrapRecoverySecret#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterSpecBootstrapRecoverySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecBootstrapRecoverySecret(obj: ClusterSpecBootstrapRecoverySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The static PVC data source(s) from which to initiate the
 * recovery procedure. Currently supporting `VolumeSnapshot`
 * and `PersistentVolumeClaim` resources that map an existing
 * PVC group, compatible with CloudNativePG, and taken with
 * a cold backup copy on a fenced Postgres instance (limitation
 * which will be removed in the future when online backup
 * will be implemented).
 * Mutually exclusive with `backup`.
 *
 * @schema ClusterSpecBootstrapRecoveryVolumeSnapshots
 */
export interface ClusterSpecBootstrapRecoveryVolumeSnapshots {
  /**
   * Configuration of the storage of the instances
   *
   * @schema ClusterSpecBootstrapRecoveryVolumeSnapshots#storage
   */
  readonly storage: ClusterSpecBootstrapRecoveryVolumeSnapshotsStorage;

  /**
   * Configuration of the storage for PostgreSQL tablespaces
   *
   * @schema ClusterSpecBootstrapRecoveryVolumeSnapshots#tablespaceStorage
   */
  readonly tablespaceStorage?: { [key: string]: ClusterSpecBootstrapRecoveryVolumeSnapshotsTablespaceStorage };

  /**
   * Configuration of the storage for PostgreSQL WAL (Write-Ahead Log)
   *
   * @schema ClusterSpecBootstrapRecoveryVolumeSnapshots#walStorage
   */
  readonly walStorage?: ClusterSpecBootstrapRecoveryVolumeSnapshotsWalStorage;

}

/**
 * Converts an object of type 'ClusterSpecBootstrapRecoveryVolumeSnapshots' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecBootstrapRecoveryVolumeSnapshots(obj: ClusterSpecBootstrapRecoveryVolumeSnapshots | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'storage': toJson_ClusterSpecBootstrapRecoveryVolumeSnapshotsStorage(obj.storage),
    'tablespaceStorage': ((obj.tablespaceStorage) === undefined) ? undefined : (Object.entries(obj.tablespaceStorage).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: toJson_ClusterSpecBootstrapRecoveryVolumeSnapshotsTablespaceStorage(i[1]) }), {})),
    'walStorage': toJson_ClusterSpecBootstrapRecoveryVolumeSnapshotsWalStorage(obj.walStorage),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a ConfigMap.
 *
 * @schema ClusterSpecEnvValueFromConfigMapKeyRef
 */
export interface ClusterSpecEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema ClusterSpecEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ClusterSpecEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema ClusterSpecEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ClusterSpecEnvValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecEnvValueFromConfigMapKeyRef(obj: ClusterSpecEnvValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
 * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema ClusterSpecEnvValueFromFieldRef
 */
export interface ClusterSpecEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema ClusterSpecEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema ClusterSpecEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'ClusterSpecEnvValueFromFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecEnvValueFromFieldRef(obj: ClusterSpecEnvValueFromFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema ClusterSpecEnvValueFromResourceFieldRef
 */
export interface ClusterSpecEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema ClusterSpecEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema ClusterSpecEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: ClusterSpecEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema ClusterSpecEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'ClusterSpecEnvValueFromResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecEnvValueFromResourceFieldRef(obj: ClusterSpecEnvValueFromResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema ClusterSpecEnvValueFromSecretKeyRef
 */
export interface ClusterSpecEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ClusterSpecEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ClusterSpecEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ClusterSpecEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ClusterSpecEnvValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecEnvValueFromSecretKeyRef(obj: ClusterSpecEnvValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The specification for the PersistentVolumeClaim. The entire content is
 * copied unchanged into the PVC that gets created from this
 * template. The same fields as in a PersistentVolumeClaim
 * are also valid here.
 *
 * @schema ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpec
 */
export interface ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpec {
  /**
   * accessModes contains the desired access modes the volume should have.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpec#accessModes
   */
  readonly accessModes?: string[];

  /**
   * dataSource field can be used to specify either:
   * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
   * * An existing PVC (PersistentVolumeClaim)
   * If the provisioner or an external controller can support the specified data source,
   * it will create a new volume based on the contents of the specified data source.
   * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
   * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
   * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
   *
   * @schema ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpec#dataSource
   */
  readonly dataSource?: ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecDataSource;

  /**
   * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
   * volume is desired. This may be any object from a non-empty API group (non
   * core object) or a PersistentVolumeClaim object.
   * When this field is specified, volume binding will only succeed if the type of
   * the specified object matches some installed volume populator or dynamic
   * provisioner.
   * This field will replace the functionality of the dataSource field and as such
   * if both fields are non-empty, they must have the same value. For backwards
   * compatibility, when namespace isn't specified in dataSourceRef,
   * both fields (dataSource and dataSourceRef) will be set to the same
   * value automatically if one of them is empty and the other is non-empty.
   * When namespace is specified in dataSourceRef,
   * dataSource isn't set to the same value and must be empty.
   * There are three important differences between dataSource and dataSourceRef:
   * * While dataSource only allows two specific types of objects, dataSourceRef
   * allows any non-core object, as well as PersistentVolumeClaim objects.
   * * While dataSource ignores disallowed values (dropping them), dataSourceRef
   * preserves all values, and generates an error if a disallowed value is
   * specified.
   * * While dataSource only allows local objects, dataSourceRef allows objects
   * in any namespaces.
   * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
   * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpec#dataSourceRef
   */
  readonly dataSourceRef?: ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecDataSourceRef;

  /**
   * resources represents the minimum resources the volume should have.
   * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
   * that are lower than previous value but must still be higher than capacity recorded in the
   * status field of the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
   *
   * @schema ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpec#resources
   */
  readonly resources?: ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecResources;

  /**
   * selector is a label query over volumes to consider for binding.
   *
   * @schema ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpec#selector
   */
  readonly selector?: ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecSelector;

  /**
   * storageClassName is the name of the StorageClass required by the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   *
   * @schema ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpec#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
   * If specified, the CSI driver will create or update the volume with the attributes defined
   * in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
   * it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
   * will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
   * If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
   * will be set by the persistentvolume controller if it exists.
   * If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
   * set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
   * exists.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#volumeattributesclass
   * (Alpha) Using this field requires the VolumeAttributesClass feature gate to be enabled.
   *
   * @schema ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpec#volumeAttributesClassName
   */
  readonly volumeAttributesClassName?: string;

  /**
   * volumeMode defines what type of volume is required by the claim.
   * Value of Filesystem is implied when not included in claim spec.
   *
   * @schema ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpec#volumeMode
   */
  readonly volumeMode?: string;

  /**
   * volumeName is the binding reference to the PersistentVolume backing this claim.
   *
   * @schema ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpec#volumeName
   */
  readonly volumeName?: string;

}

/**
 * Converts an object of type 'ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpec(obj: ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessModes': obj.accessModes?.map(y => y),
    'dataSource': toJson_ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecDataSource(obj.dataSource),
    'dataSourceRef': toJson_ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecDataSourceRef(obj.dataSourceRef),
    'resources': toJson_ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecResources(obj.resources),
    'selector': toJson_ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecSelector(obj.selector),
    'storageClassName': obj.storageClassName,
    'volumeAttributesClassName': obj.volumeAttributesClassName,
    'volumeMode': obj.volumeMode,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The credentials to use to upload data to Azure Blob Storage
 *
 * @schema ClusterSpecExternalClustersBarmanObjectStoreAzureCredentials
 */
export interface ClusterSpecExternalClustersBarmanObjectStoreAzureCredentials {
  /**
   * The connection string to be used
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreAzureCredentials#connectionString
   */
  readonly connectionString?: ClusterSpecExternalClustersBarmanObjectStoreAzureCredentialsConnectionString;

  /**
   * Use the Azure AD based authentication without providing explicitly the keys.
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreAzureCredentials#inheritFromAzureAD
   */
  readonly inheritFromAzureAd?: boolean;

  /**
   * The storage account where to upload data
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreAzureCredentials#storageAccount
   */
  readonly storageAccount?: ClusterSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageAccount;

  /**
   * The storage account key to be used in conjunction
   * with the storage account name
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreAzureCredentials#storageKey
   */
  readonly storageKey?: ClusterSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageKey;

  /**
   * A shared-access-signature to be used in conjunction with
   * the storage account name
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreAzureCredentials#storageSasToken
   */
  readonly storageSasToken?: ClusterSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageSasToken;

}

/**
 * Converts an object of type 'ClusterSpecExternalClustersBarmanObjectStoreAzureCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecExternalClustersBarmanObjectStoreAzureCredentials(obj: ClusterSpecExternalClustersBarmanObjectStoreAzureCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionString': toJson_ClusterSpecExternalClustersBarmanObjectStoreAzureCredentialsConnectionString(obj.connectionString),
    'inheritFromAzureAD': obj.inheritFromAzureAd,
    'storageAccount': toJson_ClusterSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageAccount(obj.storageAccount),
    'storageKey': toJson_ClusterSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageKey(obj.storageKey),
    'storageSasToken': toJson_ClusterSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageSasToken(obj.storageSasToken),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The configuration to be used to backup the data files
 * When not defined, base backups files will be stored uncompressed and may
 * be unencrypted in the object store, according to the bucket default
 * policy.
 *
 * @schema ClusterSpecExternalClustersBarmanObjectStoreData
 */
export interface ClusterSpecExternalClustersBarmanObjectStoreData {
  /**
   * AdditionalCommandArgs represents additional arguments that can be appended
   * to the 'barman-cloud-backup' command-line invocation. These arguments
   * provide flexibility to customize the backup process further according to
   * specific requirements or configurations.
   *
   *
   * Example:
   * In a scenario where specialized backup options are required, such as setting
   * a specific timeout or defining custom behavior, users can use this field
   * to specify additional command arguments.
   *
   *
   * Note:
   * It's essential to ensure that the provided arguments are valid and supported
   * by the 'barman-cloud-backup' command, to avoid potential errors or unintended
   * behavior during execution.
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreData#additionalCommandArgs
   */
  readonly additionalCommandArgs?: string[];

  /**
   * Compress a backup file (a tar file per tablespace) while streaming it
   * to the object store. Available options are empty string (no
   * compression, default), `gzip`, `bzip2` or `snappy`.
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreData#compression
   */
  readonly compression?: ClusterSpecExternalClustersBarmanObjectStoreDataCompression;

  /**
   * Whenever to force the encryption of files (if the bucket is
   * not already configured for that).
   * Allowed options are empty string (use the bucket policy, default),
   * `AES256` and `aws:kms`
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreData#encryption
   */
  readonly encryption?: ClusterSpecExternalClustersBarmanObjectStoreDataEncryption;

  /**
   * Control whether the I/O workload for the backup initial checkpoint will
   * be limited, according to the `checkpoint_completion_target` setting on
   * the PostgreSQL server. If set to true, an immediate checkpoint will be
   * used, meaning PostgreSQL will complete the checkpoint as soon as
   * possible. `false` by default.
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreData#immediateCheckpoint
   */
  readonly immediateCheckpoint?: boolean;

  /**
   * The number of parallel jobs to be used to upload the backup, defaults
   * to 2
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreData#jobs
   */
  readonly jobs?: number;

}

/**
 * Converts an object of type 'ClusterSpecExternalClustersBarmanObjectStoreData' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecExternalClustersBarmanObjectStoreData(obj: ClusterSpecExternalClustersBarmanObjectStoreData | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalCommandArgs': obj.additionalCommandArgs?.map(y => y),
    'compression': obj.compression,
    'encryption': obj.encryption,
    'immediateCheckpoint': obj.immediateCheckpoint,
    'jobs': obj.jobs,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EndpointCA store the CA bundle of the barman endpoint.
 * Useful when using self-signed certificates to avoid
 * errors with certificate issuer and barman-cloud-wal-archive
 *
 * @schema ClusterSpecExternalClustersBarmanObjectStoreEndpointCa
 */
export interface ClusterSpecExternalClustersBarmanObjectStoreEndpointCa {
  /**
   * The key to select
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreEndpointCa#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreEndpointCa#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterSpecExternalClustersBarmanObjectStoreEndpointCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecExternalClustersBarmanObjectStoreEndpointCa(obj: ClusterSpecExternalClustersBarmanObjectStoreEndpointCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The credentials to use to upload data to Google Cloud Storage
 *
 * @schema ClusterSpecExternalClustersBarmanObjectStoreGoogleCredentials
 */
export interface ClusterSpecExternalClustersBarmanObjectStoreGoogleCredentials {
  /**
   * The secret containing the Google Cloud Storage JSON file with the credentials
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreGoogleCredentials#applicationCredentials
   */
  readonly applicationCredentials?: ClusterSpecExternalClustersBarmanObjectStoreGoogleCredentialsApplicationCredentials;

  /**
   * If set to true, will presume that it's running inside a GKE environment,
   * default to false.
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreGoogleCredentials#gkeEnvironment
   */
  readonly gkeEnvironment?: boolean;

}

/**
 * Converts an object of type 'ClusterSpecExternalClustersBarmanObjectStoreGoogleCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecExternalClustersBarmanObjectStoreGoogleCredentials(obj: ClusterSpecExternalClustersBarmanObjectStoreGoogleCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'applicationCredentials': toJson_ClusterSpecExternalClustersBarmanObjectStoreGoogleCredentialsApplicationCredentials(obj.applicationCredentials),
    'gkeEnvironment': obj.gkeEnvironment,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The credentials to use to upload data to S3
 *
 * @schema ClusterSpecExternalClustersBarmanObjectStoreS3Credentials
 */
export interface ClusterSpecExternalClustersBarmanObjectStoreS3Credentials {
  /**
   * The reference to the access key id
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreS3Credentials#accessKeyId
   */
  readonly accessKeyId?: ClusterSpecExternalClustersBarmanObjectStoreS3CredentialsAccessKeyId;

  /**
   * Use the role based authentication without providing explicitly the keys.
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreS3Credentials#inheritFromIAMRole
   */
  readonly inheritFromIamRole?: boolean;

  /**
   * The reference to the secret containing the region name
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreS3Credentials#region
   */
  readonly region?: ClusterSpecExternalClustersBarmanObjectStoreS3CredentialsRegion;

  /**
   * The reference to the secret access key
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreS3Credentials#secretAccessKey
   */
  readonly secretAccessKey?: ClusterSpecExternalClustersBarmanObjectStoreS3CredentialsSecretAccessKey;

  /**
   * The references to the session key
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreS3Credentials#sessionToken
   */
  readonly sessionToken?: ClusterSpecExternalClustersBarmanObjectStoreS3CredentialsSessionToken;

}

/**
 * Converts an object of type 'ClusterSpecExternalClustersBarmanObjectStoreS3Credentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecExternalClustersBarmanObjectStoreS3Credentials(obj: ClusterSpecExternalClustersBarmanObjectStoreS3Credentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessKeyId': toJson_ClusterSpecExternalClustersBarmanObjectStoreS3CredentialsAccessKeyId(obj.accessKeyId),
    'inheritFromIAMRole': obj.inheritFromIamRole,
    'region': toJson_ClusterSpecExternalClustersBarmanObjectStoreS3CredentialsRegion(obj.region),
    'secretAccessKey': toJson_ClusterSpecExternalClustersBarmanObjectStoreS3CredentialsSecretAccessKey(obj.secretAccessKey),
    'sessionToken': toJson_ClusterSpecExternalClustersBarmanObjectStoreS3CredentialsSessionToken(obj.sessionToken),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The configuration for the backup of the WAL stream.
 * When not defined, WAL files will be stored uncompressed and may be
 * unencrypted in the object store, according to the bucket default policy.
 *
 * @schema ClusterSpecExternalClustersBarmanObjectStoreWal
 */
export interface ClusterSpecExternalClustersBarmanObjectStoreWal {
  /**
   * Compress a WAL file before sending it to the object store. Available
   * options are empty string (no compression, default), `gzip`, `bzip2` or `snappy`.
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreWal#compression
   */
  readonly compression?: ClusterSpecExternalClustersBarmanObjectStoreWalCompression;

  /**
   * Whenever to force the encryption of files (if the bucket is
   * not already configured for that).
   * Allowed options are empty string (use the bucket policy, default),
   * `AES256` and `aws:kms`
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreWal#encryption
   */
  readonly encryption?: ClusterSpecExternalClustersBarmanObjectStoreWalEncryption;

  /**
   * Number of WAL files to be either archived in parallel (when the
   * PostgreSQL instance is archiving to a backup object store) or
   * restored in parallel (when a PostgreSQL standby is fetching WAL
   * files from a recovery object store). If not specified, WAL files
   * will be processed one at a time. It accepts a positive integer as a
   * value - with 1 being the minimum accepted value.
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreWal#maxParallel
   */
  readonly maxParallel?: number;

}

/**
 * Converts an object of type 'ClusterSpecExternalClustersBarmanObjectStoreWal' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecExternalClustersBarmanObjectStoreWal(obj: ClusterSpecExternalClustersBarmanObjectStoreWal | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'compression': obj.compression,
    'encryption': obj.encryption,
    'maxParallel': obj.maxParallel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Ensure the role is `present` or `absent` - defaults to "present"
 *
 * @schema ClusterSpecManagedRolesEnsure
 */
export enum ClusterSpecManagedRolesEnsure {
  /** present */
  PRESENT = "present",
  /** absent */
  ABSENT = "absent",
}

/**
 * Secret containing the password of the role (if present)
 * If null, the password will be ignored unless DisablePassword is set
 *
 * @schema ClusterSpecManagedRolesPasswordSecret
 */
export interface ClusterSpecManagedRolesPasswordSecret {
  /**
   * Name of the referent.
   *
   * @schema ClusterSpecManagedRolesPasswordSecret#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterSpecManagedRolesPasswordSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecManagedRolesPasswordSecret(obj: ClusterSpecManagedRolesPasswordSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Action to perform based on the regex matching.
 *
 *
 * `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0.
 * `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.
 *
 *
 * Default: "Replace"
 *
 * @schema ClusterSpecMonitoringPodMonitorMetricRelabelingsAction
 */
export enum ClusterSpecMonitoringPodMonitorMetricRelabelingsAction {
  /** replace */
  REPLACE = "replace",
  /** keep */
  KEEP = "keep",
  /** drop */
  DROP = "drop",
  /** hashmod */
  HASHMOD = "hashmod",
  /** labelmap */
  LABELMAP = "labelmap",
  /** labeldrop */
  LABELDROP = "labeldrop",
  /** labelkeep */
  LABELKEEP = "labelkeep",
  /** lowercase */
  LOWERCASE = "lowercase",
  /** uppercase */
  UPPERCASE = "uppercase",
  /** keepequal */
  KEEPEQUAL = "keepequal",
  /** dropequal */
  DROPEQUAL = "dropequal",
}

/**
 * Action to perform based on the regex matching.
 *
 *
 * `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0.
 * `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.
 *
 *
 * Default: "Replace"
 *
 * @schema ClusterSpecMonitoringPodMonitorRelabelingsAction
 */
export enum ClusterSpecMonitoringPodMonitorRelabelingsAction {
  /** replace */
  REPLACE = "replace",
  /** keep */
  KEEP = "keep",
  /** drop */
  DROP = "drop",
  /** hashmod */
  HASHMOD = "hashmod",
  /** labelmap */
  LABELMAP = "labelmap",
  /** labeldrop */
  LABELDROP = "labeldrop",
  /** labelkeep */
  LABELKEEP = "labelkeep",
  /** lowercase */
  LOWERCASE = "lowercase",
  /** uppercase */
  UPPERCASE = "uppercase",
  /** keepequal */
  KEEPEQUAL = "keepequal",
  /** dropequal */
  DROPEQUAL = "dropequal",
}

/**
 * Bind as authentication configuration
 *
 * @schema ClusterSpecPostgresqlLdapBindAsAuth
 */
export interface ClusterSpecPostgresqlLdapBindAsAuth {
  /**
   * Prefix for the bind authentication option
   *
   * @schema ClusterSpecPostgresqlLdapBindAsAuth#prefix
   */
  readonly prefix?: string;

  /**
   * Suffix for the bind authentication option
   *
   * @schema ClusterSpecPostgresqlLdapBindAsAuth#suffix
   */
  readonly suffix?: string;

}

/**
 * Converts an object of type 'ClusterSpecPostgresqlLdapBindAsAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecPostgresqlLdapBindAsAuth(obj: ClusterSpecPostgresqlLdapBindAsAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'prefix': obj.prefix,
    'suffix': obj.suffix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Bind+Search authentication configuration
 *
 * @schema ClusterSpecPostgresqlLdapBindSearchAuth
 */
export interface ClusterSpecPostgresqlLdapBindSearchAuth {
  /**
   * Root DN to begin the user search
   *
   * @schema ClusterSpecPostgresqlLdapBindSearchAuth#baseDN
   */
  readonly baseDn?: string;

  /**
   * DN of the user to bind to the directory
   *
   * @schema ClusterSpecPostgresqlLdapBindSearchAuth#bindDN
   */
  readonly bindDn?: string;

  /**
   * Secret with the password for the user to bind to the directory
   *
   * @schema ClusterSpecPostgresqlLdapBindSearchAuth#bindPassword
   */
  readonly bindPassword?: ClusterSpecPostgresqlLdapBindSearchAuthBindPassword;

  /**
   * Attribute to match against the username
   *
   * @schema ClusterSpecPostgresqlLdapBindSearchAuth#searchAttribute
   */
  readonly searchAttribute?: string;

  /**
   * Search filter to use when doing the search+bind authentication
   *
   * @schema ClusterSpecPostgresqlLdapBindSearchAuth#searchFilter
   */
  readonly searchFilter?: string;

}

/**
 * Converts an object of type 'ClusterSpecPostgresqlLdapBindSearchAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecPostgresqlLdapBindSearchAuth(obj: ClusterSpecPostgresqlLdapBindSearchAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'baseDN': obj.baseDn,
    'bindDN': obj.bindDn,
    'bindPassword': toJson_ClusterSpecPostgresqlLdapBindSearchAuthBindPassword(obj.bindPassword),
    'searchAttribute': obj.searchAttribute,
    'searchFilter': obj.searchFilter,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LDAP schema to be used, possible options are `ldap` and `ldaps`
 *
 * @schema ClusterSpecPostgresqlLdapScheme
 */
export enum ClusterSpecPostgresqlLdapScheme {
  /** ldap */
  LDAP = "ldap",
  /** ldaps */
  LDAPS = "ldaps",
}

/**
 * ClusterTrustBundle allows a pod to access the `.spec.trustBundle` field
 * of ClusterTrustBundle objects in an auto-updating file.
 *
 *
 * Alpha, gated by the ClusterTrustBundleProjection feature gate.
 *
 *
 * ClusterTrustBundle objects can either be selected by name, or by the
 * combination of signer name and a label selector.
 *
 *
 * Kubelet performs aggressive normalization of the PEM contents written
 * into the pod filesystem.  Esoteric PEM features such as inter-block
 * comments and block headers are stripped.  Certificates are deduplicated.
 * The ordering of certificates within the file is arbitrary, and Kubelet
 * may change the order over time.
 *
 * @schema ClusterSpecProjectedVolumeTemplateSourcesClusterTrustBundle
 */
export interface ClusterSpecProjectedVolumeTemplateSourcesClusterTrustBundle {
  /**
   * Select all ClusterTrustBundles that match this label selector.  Only has
   * effect if signerName is set.  Mutually-exclusive with name.  If unset,
   * interpreted as "match nothing".  If set but empty, interpreted as "match
   * everything".
   *
   * @schema ClusterSpecProjectedVolumeTemplateSourcesClusterTrustBundle#labelSelector
   */
  readonly labelSelector?: ClusterSpecProjectedVolumeTemplateSourcesClusterTrustBundleLabelSelector;

  /**
   * Select a single ClusterTrustBundle by object name.  Mutually-exclusive
   * with signerName and labelSelector.
   *
   * @schema ClusterSpecProjectedVolumeTemplateSourcesClusterTrustBundle#name
   */
  readonly name?: string;

  /**
   * If true, don't block pod startup if the referenced ClusterTrustBundle(s)
   * aren't available.  If using name, then the named ClusterTrustBundle is
   * allowed not to exist.  If using signerName, then the combination of
   * signerName and labelSelector is allowed to match zero
   * ClusterTrustBundles.
   *
   * @schema ClusterSpecProjectedVolumeTemplateSourcesClusterTrustBundle#optional
   */
  readonly optional?: boolean;

  /**
   * Relative path from the volume root to write the bundle.
   *
   * @schema ClusterSpecProjectedVolumeTemplateSourcesClusterTrustBundle#path
   */
  readonly path: string;

  /**
   * Select all ClusterTrustBundles that match this signer name.
   * Mutually-exclusive with name.  The contents of all selected
   * ClusterTrustBundles will be unified and deduplicated.
   *
   * @schema ClusterSpecProjectedVolumeTemplateSourcesClusterTrustBundle#signerName
   */
  readonly signerName?: string;

}

/**
 * Converts an object of type 'ClusterSpecProjectedVolumeTemplateSourcesClusterTrustBundle' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecProjectedVolumeTemplateSourcesClusterTrustBundle(obj: ClusterSpecProjectedVolumeTemplateSourcesClusterTrustBundle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_ClusterSpecProjectedVolumeTemplateSourcesClusterTrustBundleLabelSelector(obj.labelSelector),
    'name': obj.name,
    'optional': obj.optional,
    'path': obj.path,
    'signerName': obj.signerName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * configMap information about the configMap data to project
 *
 * @schema ClusterSpecProjectedVolumeTemplateSourcesConfigMap
 */
export interface ClusterSpecProjectedVolumeTemplateSourcesConfigMap {
  /**
   * items if unspecified, each key-value pair in the Data field of the referenced
   * ConfigMap will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the ConfigMap,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   *
   * @schema ClusterSpecProjectedVolumeTemplateSourcesConfigMap#items
   */
  readonly items?: ClusterSpecProjectedVolumeTemplateSourcesConfigMapItems[];

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ClusterSpecProjectedVolumeTemplateSourcesConfigMap#name
   */
  readonly name?: string;

  /**
   * optional specify whether the ConfigMap or its keys must be defined
   *
   * @schema ClusterSpecProjectedVolumeTemplateSourcesConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ClusterSpecProjectedVolumeTemplateSourcesConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecProjectedVolumeTemplateSourcesConfigMap(obj: ClusterSpecProjectedVolumeTemplateSourcesConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_ClusterSpecProjectedVolumeTemplateSourcesConfigMapItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * downwardAPI information about the downwardAPI data to project
 *
 * @schema ClusterSpecProjectedVolumeTemplateSourcesDownwardApi
 */
export interface ClusterSpecProjectedVolumeTemplateSourcesDownwardApi {
  /**
   * Items is a list of DownwardAPIVolume file
   *
   * @schema ClusterSpecProjectedVolumeTemplateSourcesDownwardApi#items
   */
  readonly items?: ClusterSpecProjectedVolumeTemplateSourcesDownwardApiItems[];

}

/**
 * Converts an object of type 'ClusterSpecProjectedVolumeTemplateSourcesDownwardApi' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecProjectedVolumeTemplateSourcesDownwardApi(obj: ClusterSpecProjectedVolumeTemplateSourcesDownwardApi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_ClusterSpecProjectedVolumeTemplateSourcesDownwardApiItems(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * secret information about the secret data to project
 *
 * @schema ClusterSpecProjectedVolumeTemplateSourcesSecret
 */
export interface ClusterSpecProjectedVolumeTemplateSourcesSecret {
  /**
   * items if unspecified, each key-value pair in the Data field of the referenced
   * Secret will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the Secret,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   *
   * @schema ClusterSpecProjectedVolumeTemplateSourcesSecret#items
   */
  readonly items?: ClusterSpecProjectedVolumeTemplateSourcesSecretItems[];

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ClusterSpecProjectedVolumeTemplateSourcesSecret#name
   */
  readonly name?: string;

  /**
   * optional field specify whether the Secret or its key must be defined
   *
   * @schema ClusterSpecProjectedVolumeTemplateSourcesSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ClusterSpecProjectedVolumeTemplateSourcesSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecProjectedVolumeTemplateSourcesSecret(obj: ClusterSpecProjectedVolumeTemplateSourcesSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_ClusterSpecProjectedVolumeTemplateSourcesSecretItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * serviceAccountToken is information about the serviceAccountToken data to project
 *
 * @schema ClusterSpecProjectedVolumeTemplateSourcesServiceAccountToken
 */
export interface ClusterSpecProjectedVolumeTemplateSourcesServiceAccountToken {
  /**
   * audience is the intended audience of the token. A recipient of a token
   * must identify itself with an identifier specified in the audience of the
   * token, and otherwise should reject the token. The audience defaults to the
   * identifier of the apiserver.
   *
   * @schema ClusterSpecProjectedVolumeTemplateSourcesServiceAccountToken#audience
   */
  readonly audience?: string;

  /**
   * expirationSeconds is the requested duration of validity of the service
   * account token. As the token approaches expiration, the kubelet volume
   * plugin will proactively rotate the service account token. The kubelet will
   * start trying to rotate the token if the token is older than 80 percent of
   * its time to live or if the token is older than 24 hours.Defaults to 1 hour
   * and must be at least 10 minutes.
   *
   * @default 1 hour
   * @schema ClusterSpecProjectedVolumeTemplateSourcesServiceAccountToken#expirationSeconds
   */
  readonly expirationSeconds?: number;

  /**
   * path is the path relative to the mount point of the file to project the
   * token into.
   *
   * @schema ClusterSpecProjectedVolumeTemplateSourcesServiceAccountToken#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'ClusterSpecProjectedVolumeTemplateSourcesServiceAccountToken' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecProjectedVolumeTemplateSourcesServiceAccountToken(obj: ClusterSpecProjectedVolumeTemplateSourcesServiceAccountToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audience': obj.audience,
    'expirationSeconds': obj.expirationSeconds,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * dataSource field can be used to specify either:
 * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
 * * An existing PVC (PersistentVolumeClaim)
 * If the provisioner or an external controller can support the specified data source,
 * it will create a new volume based on the contents of the specified data source.
 * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
 * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
 * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
 *
 * @schema ClusterSpecStoragePvcTemplateDataSource
 */
export interface ClusterSpecStoragePvcTemplateDataSource {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema ClusterSpecStoragePvcTemplateDataSource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema ClusterSpecStoragePvcTemplateDataSource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema ClusterSpecStoragePvcTemplateDataSource#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterSpecStoragePvcTemplateDataSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecStoragePvcTemplateDataSource(obj: ClusterSpecStoragePvcTemplateDataSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
 * volume is desired. This may be any object from a non-empty API group (non
 * core object) or a PersistentVolumeClaim object.
 * When this field is specified, volume binding will only succeed if the type of
 * the specified object matches some installed volume populator or dynamic
 * provisioner.
 * This field will replace the functionality of the dataSource field and as such
 * if both fields are non-empty, they must have the same value. For backwards
 * compatibility, when namespace isn't specified in dataSourceRef,
 * both fields (dataSource and dataSourceRef) will be set to the same
 * value automatically if one of them is empty and the other is non-empty.
 * When namespace is specified in dataSourceRef,
 * dataSource isn't set to the same value and must be empty.
 * There are three important differences between dataSource and dataSourceRef:
 * * While dataSource only allows two specific types of objects, dataSourceRef
 * allows any non-core object, as well as PersistentVolumeClaim objects.
 * * While dataSource ignores disallowed values (dropping them), dataSourceRef
 * preserves all values, and generates an error if a disallowed value is
 * specified.
 * * While dataSource only allows local objects, dataSourceRef allows objects
 * in any namespaces.
 * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
 * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
 *
 * @schema ClusterSpecStoragePvcTemplateDataSourceRef
 */
export interface ClusterSpecStoragePvcTemplateDataSourceRef {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema ClusterSpecStoragePvcTemplateDataSourceRef#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema ClusterSpecStoragePvcTemplateDataSourceRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema ClusterSpecStoragePvcTemplateDataSourceRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of resource being referenced
   * Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
   * (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema ClusterSpecStoragePvcTemplateDataSourceRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSpecStoragePvcTemplateDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecStoragePvcTemplateDataSourceRef(obj: ClusterSpecStoragePvcTemplateDataSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * resources represents the minimum resources the volume should have.
 * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
 * that are lower than previous value but must still be higher than capacity recorded in the
 * status field of the claim.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
 *
 * @schema ClusterSpecStoragePvcTemplateResources
 */
export interface ClusterSpecStoragePvcTemplateResources {
  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ClusterSpecStoragePvcTemplateResources#limits
   */
  readonly limits?: { [key: string]: ClusterSpecStoragePvcTemplateResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ClusterSpecStoragePvcTemplateResources#requests
   */
  readonly requests?: { [key: string]: ClusterSpecStoragePvcTemplateResourcesRequests };

}

/**
 * Converts an object of type 'ClusterSpecStoragePvcTemplateResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecStoragePvcTemplateResources(obj: ClusterSpecStoragePvcTemplateResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * selector is a label query over volumes to consider for binding.
 *
 * @schema ClusterSpecStoragePvcTemplateSelector
 */
export interface ClusterSpecStoragePvcTemplateSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterSpecStoragePvcTemplateSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterSpecStoragePvcTemplateSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterSpecStoragePvcTemplateSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterSpecStoragePvcTemplateSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecStoragePvcTemplateSelector(obj: ClusterSpecStoragePvcTemplateSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterSpecStoragePvcTemplateSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template to be used to generate the Persistent Volume Claim
 *
 * @schema ClusterSpecTablespacesStoragePvcTemplate
 */
export interface ClusterSpecTablespacesStoragePvcTemplate {
  /**
   * accessModes contains the desired access modes the volume should have.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema ClusterSpecTablespacesStoragePvcTemplate#accessModes
   */
  readonly accessModes?: string[];

  /**
   * dataSource field can be used to specify either:
   * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
   * * An existing PVC (PersistentVolumeClaim)
   * If the provisioner or an external controller can support the specified data source,
   * it will create a new volume based on the contents of the specified data source.
   * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
   * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
   * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
   *
   * @schema ClusterSpecTablespacesStoragePvcTemplate#dataSource
   */
  readonly dataSource?: ClusterSpecTablespacesStoragePvcTemplateDataSource;

  /**
   * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
   * volume is desired. This may be any object from a non-empty API group (non
   * core object) or a PersistentVolumeClaim object.
   * When this field is specified, volume binding will only succeed if the type of
   * the specified object matches some installed volume populator or dynamic
   * provisioner.
   * This field will replace the functionality of the dataSource field and as such
   * if both fields are non-empty, they must have the same value. For backwards
   * compatibility, when namespace isn't specified in dataSourceRef,
   * both fields (dataSource and dataSourceRef) will be set to the same
   * value automatically if one of them is empty and the other is non-empty.
   * When namespace is specified in dataSourceRef,
   * dataSource isn't set to the same value and must be empty.
   * There are three important differences between dataSource and dataSourceRef:
   * * While dataSource only allows two specific types of objects, dataSourceRef
   * allows any non-core object, as well as PersistentVolumeClaim objects.
   * * While dataSource ignores disallowed values (dropping them), dataSourceRef
   * preserves all values, and generates an error if a disallowed value is
   * specified.
   * * While dataSource only allows local objects, dataSourceRef allows objects
   * in any namespaces.
   * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
   * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema ClusterSpecTablespacesStoragePvcTemplate#dataSourceRef
   */
  readonly dataSourceRef?: ClusterSpecTablespacesStoragePvcTemplateDataSourceRef;

  /**
   * resources represents the minimum resources the volume should have.
   * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
   * that are lower than previous value but must still be higher than capacity recorded in the
   * status field of the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
   *
   * @schema ClusterSpecTablespacesStoragePvcTemplate#resources
   */
  readonly resources?: ClusterSpecTablespacesStoragePvcTemplateResources;

  /**
   * selector is a label query over volumes to consider for binding.
   *
   * @schema ClusterSpecTablespacesStoragePvcTemplate#selector
   */
  readonly selector?: ClusterSpecTablespacesStoragePvcTemplateSelector;

  /**
   * storageClassName is the name of the StorageClass required by the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   *
   * @schema ClusterSpecTablespacesStoragePvcTemplate#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
   * If specified, the CSI driver will create or update the volume with the attributes defined
   * in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
   * it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
   * will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
   * If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
   * will be set by the persistentvolume controller if it exists.
   * If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
   * set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
   * exists.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#volumeattributesclass
   * (Alpha) Using this field requires the VolumeAttributesClass feature gate to be enabled.
   *
   * @schema ClusterSpecTablespacesStoragePvcTemplate#volumeAttributesClassName
   */
  readonly volumeAttributesClassName?: string;

  /**
   * volumeMode defines what type of volume is required by the claim.
   * Value of Filesystem is implied when not included in claim spec.
   *
   * @schema ClusterSpecTablespacesStoragePvcTemplate#volumeMode
   */
  readonly volumeMode?: string;

  /**
   * volumeName is the binding reference to the PersistentVolume backing this claim.
   *
   * @schema ClusterSpecTablespacesStoragePvcTemplate#volumeName
   */
  readonly volumeName?: string;

}

/**
 * Converts an object of type 'ClusterSpecTablespacesStoragePvcTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecTablespacesStoragePvcTemplate(obj: ClusterSpecTablespacesStoragePvcTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessModes': obj.accessModes?.map(y => y),
    'dataSource': toJson_ClusterSpecTablespacesStoragePvcTemplateDataSource(obj.dataSource),
    'dataSourceRef': toJson_ClusterSpecTablespacesStoragePvcTemplateDataSourceRef(obj.dataSourceRef),
    'resources': toJson_ClusterSpecTablespacesStoragePvcTemplateResources(obj.resources),
    'selector': toJson_ClusterSpecTablespacesStoragePvcTemplateSelector(obj.selector),
    'storageClassName': obj.storageClassName,
    'volumeAttributesClassName': obj.volumeAttributesClassName,
    'volumeMode': obj.volumeMode,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterSpecTopologySpreadConstraintsLabelSelectorMatchExpressions
 */
export interface ClusterSpecTopologySpreadConstraintsLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterSpecTopologySpreadConstraintsLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterSpecTopologySpreadConstraintsLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterSpecTopologySpreadConstraintsLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterSpecTopologySpreadConstraintsLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecTopologySpreadConstraintsLabelSelectorMatchExpressions(obj: ClusterSpecTopologySpreadConstraintsLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * dataSource field can be used to specify either:
 * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
 * * An existing PVC (PersistentVolumeClaim)
 * If the provisioner or an external controller can support the specified data source,
 * it will create a new volume based on the contents of the specified data source.
 * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
 * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
 * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
 *
 * @schema ClusterSpecWalStoragePvcTemplateDataSource
 */
export interface ClusterSpecWalStoragePvcTemplateDataSource {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema ClusterSpecWalStoragePvcTemplateDataSource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema ClusterSpecWalStoragePvcTemplateDataSource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema ClusterSpecWalStoragePvcTemplateDataSource#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterSpecWalStoragePvcTemplateDataSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecWalStoragePvcTemplateDataSource(obj: ClusterSpecWalStoragePvcTemplateDataSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
 * volume is desired. This may be any object from a non-empty API group (non
 * core object) or a PersistentVolumeClaim object.
 * When this field is specified, volume binding will only succeed if the type of
 * the specified object matches some installed volume populator or dynamic
 * provisioner.
 * This field will replace the functionality of the dataSource field and as such
 * if both fields are non-empty, they must have the same value. For backwards
 * compatibility, when namespace isn't specified in dataSourceRef,
 * both fields (dataSource and dataSourceRef) will be set to the same
 * value automatically if one of them is empty and the other is non-empty.
 * When namespace is specified in dataSourceRef,
 * dataSource isn't set to the same value and must be empty.
 * There are three important differences between dataSource and dataSourceRef:
 * * While dataSource only allows two specific types of objects, dataSourceRef
 * allows any non-core object, as well as PersistentVolumeClaim objects.
 * * While dataSource ignores disallowed values (dropping them), dataSourceRef
 * preserves all values, and generates an error if a disallowed value is
 * specified.
 * * While dataSource only allows local objects, dataSourceRef allows objects
 * in any namespaces.
 * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
 * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
 *
 * @schema ClusterSpecWalStoragePvcTemplateDataSourceRef
 */
export interface ClusterSpecWalStoragePvcTemplateDataSourceRef {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema ClusterSpecWalStoragePvcTemplateDataSourceRef#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema ClusterSpecWalStoragePvcTemplateDataSourceRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema ClusterSpecWalStoragePvcTemplateDataSourceRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of resource being referenced
   * Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
   * (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema ClusterSpecWalStoragePvcTemplateDataSourceRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSpecWalStoragePvcTemplateDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecWalStoragePvcTemplateDataSourceRef(obj: ClusterSpecWalStoragePvcTemplateDataSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * resources represents the minimum resources the volume should have.
 * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
 * that are lower than previous value but must still be higher than capacity recorded in the
 * status field of the claim.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
 *
 * @schema ClusterSpecWalStoragePvcTemplateResources
 */
export interface ClusterSpecWalStoragePvcTemplateResources {
  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ClusterSpecWalStoragePvcTemplateResources#limits
   */
  readonly limits?: { [key: string]: ClusterSpecWalStoragePvcTemplateResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ClusterSpecWalStoragePvcTemplateResources#requests
   */
  readonly requests?: { [key: string]: ClusterSpecWalStoragePvcTemplateResourcesRequests };

}

/**
 * Converts an object of type 'ClusterSpecWalStoragePvcTemplateResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecWalStoragePvcTemplateResources(obj: ClusterSpecWalStoragePvcTemplateResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * selector is a label query over volumes to consider for binding.
 *
 * @schema ClusterSpecWalStoragePvcTemplateSelector
 */
export interface ClusterSpecWalStoragePvcTemplateSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterSpecWalStoragePvcTemplateSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterSpecWalStoragePvcTemplateSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterSpecWalStoragePvcTemplateSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterSpecWalStoragePvcTemplateSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecWalStoragePvcTemplateSelector(obj: ClusterSpecWalStoragePvcTemplateSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterSpecWalStoragePvcTemplateSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `LabelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both MatchLabelKeys and LabelSelector.
   * Also, MatchLabelKeys cannot be set when LabelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `LabelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both MismatchLabelKeys and LabelSelector.
   * Also, MismatchLabelKeys cannot be set when LabelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'mismatchLabelKeys': obj.mismatchLabelKeys?.map(y => y),
    'namespaceSelector': toJson_ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `LabelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both MatchLabelKeys and LabelSelector.
   * Also, MatchLabelKeys cannot be set when LabelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `LabelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both MismatchLabelKeys and LabelSelector.
   * Also, MismatchLabelKeys cannot be set when LabelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'mismatchLabelKeys': obj.mismatchLabelKeys?.map(y => y),
    'namespaceSelector': toJson_ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector term, associated with the corresponding weight.
 *
 * @schema ClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface ClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema ClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: ClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema ClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: ClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];

}

/**
 * Converts an object of type 'ClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj: ClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_ClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A null or empty node selector term matches no objects. The requirements of
 * them are ANDed.
 * The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
 *
 * @schema ClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface ClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema ClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: ClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema ClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: ClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];

}

/**
 * Converts an object of type 'ClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(obj: ClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_ClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The connection string to be used
 *
 * @schema ClusterSpecBackupBarmanObjectStoreAzureCredentialsConnectionString
 */
export interface ClusterSpecBackupBarmanObjectStoreAzureCredentialsConnectionString {
  /**
   * The key to select
   *
   * @schema ClusterSpecBackupBarmanObjectStoreAzureCredentialsConnectionString#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   *
   * @schema ClusterSpecBackupBarmanObjectStoreAzureCredentialsConnectionString#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterSpecBackupBarmanObjectStoreAzureCredentialsConnectionString' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecBackupBarmanObjectStoreAzureCredentialsConnectionString(obj: ClusterSpecBackupBarmanObjectStoreAzureCredentialsConnectionString | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The storage account where to upload data
 *
 * @schema ClusterSpecBackupBarmanObjectStoreAzureCredentialsStorageAccount
 */
export interface ClusterSpecBackupBarmanObjectStoreAzureCredentialsStorageAccount {
  /**
   * The key to select
   *
   * @schema ClusterSpecBackupBarmanObjectStoreAzureCredentialsStorageAccount#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   *
   * @schema ClusterSpecBackupBarmanObjectStoreAzureCredentialsStorageAccount#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterSpecBackupBarmanObjectStoreAzureCredentialsStorageAccount' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecBackupBarmanObjectStoreAzureCredentialsStorageAccount(obj: ClusterSpecBackupBarmanObjectStoreAzureCredentialsStorageAccount | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The storage account key to be used in conjunction
 * with the storage account name
 *
 * @schema ClusterSpecBackupBarmanObjectStoreAzureCredentialsStorageKey
 */
export interface ClusterSpecBackupBarmanObjectStoreAzureCredentialsStorageKey {
  /**
   * The key to select
   *
   * @schema ClusterSpecBackupBarmanObjectStoreAzureCredentialsStorageKey#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   *
   * @schema ClusterSpecBackupBarmanObjectStoreAzureCredentialsStorageKey#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterSpecBackupBarmanObjectStoreAzureCredentialsStorageKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecBackupBarmanObjectStoreAzureCredentialsStorageKey(obj: ClusterSpecBackupBarmanObjectStoreAzureCredentialsStorageKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A shared-access-signature to be used in conjunction with
 * the storage account name
 *
 * @schema ClusterSpecBackupBarmanObjectStoreAzureCredentialsStorageSasToken
 */
export interface ClusterSpecBackupBarmanObjectStoreAzureCredentialsStorageSasToken {
  /**
   * The key to select
   *
   * @schema ClusterSpecBackupBarmanObjectStoreAzureCredentialsStorageSasToken#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   *
   * @schema ClusterSpecBackupBarmanObjectStoreAzureCredentialsStorageSasToken#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterSpecBackupBarmanObjectStoreAzureCredentialsStorageSasToken' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecBackupBarmanObjectStoreAzureCredentialsStorageSasToken(obj: ClusterSpecBackupBarmanObjectStoreAzureCredentialsStorageSasToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Compress a backup file (a tar file per tablespace) while streaming it
 * to the object store. Available options are empty string (no
 * compression, default), `gzip`, `bzip2` or `snappy`.
 *
 * @schema ClusterSpecBackupBarmanObjectStoreDataCompression
 */
export enum ClusterSpecBackupBarmanObjectStoreDataCompression {
  /** gzip */
  GZIP = "gzip",
  /** bzip2 */
  BZIP2 = "bzip2",
  /** snappy */
  SNAPPY = "snappy",
}

/**
 * Whenever to force the encryption of files (if the bucket is
 * not already configured for that).
 * Allowed options are empty string (use the bucket policy, default),
 * `AES256` and `aws:kms`
 *
 * @schema ClusterSpecBackupBarmanObjectStoreDataEncryption
 */
export enum ClusterSpecBackupBarmanObjectStoreDataEncryption {
  /** AES256 */
  AES256 = "AES256",
  /** aws:kms */
  AWS_KMS = "aws:kms",
}

/**
 * The secret containing the Google Cloud Storage JSON file with the credentials
 *
 * @schema ClusterSpecBackupBarmanObjectStoreGoogleCredentialsApplicationCredentials
 */
export interface ClusterSpecBackupBarmanObjectStoreGoogleCredentialsApplicationCredentials {
  /**
   * The key to select
   *
   * @schema ClusterSpecBackupBarmanObjectStoreGoogleCredentialsApplicationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   *
   * @schema ClusterSpecBackupBarmanObjectStoreGoogleCredentialsApplicationCredentials#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterSpecBackupBarmanObjectStoreGoogleCredentialsApplicationCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecBackupBarmanObjectStoreGoogleCredentialsApplicationCredentials(obj: ClusterSpecBackupBarmanObjectStoreGoogleCredentialsApplicationCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The reference to the access key id
 *
 * @schema ClusterSpecBackupBarmanObjectStoreS3CredentialsAccessKeyId
 */
export interface ClusterSpecBackupBarmanObjectStoreS3CredentialsAccessKeyId {
  /**
   * The key to select
   *
   * @schema ClusterSpecBackupBarmanObjectStoreS3CredentialsAccessKeyId#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   *
   * @schema ClusterSpecBackupBarmanObjectStoreS3CredentialsAccessKeyId#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterSpecBackupBarmanObjectStoreS3CredentialsAccessKeyId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecBackupBarmanObjectStoreS3CredentialsAccessKeyId(obj: ClusterSpecBackupBarmanObjectStoreS3CredentialsAccessKeyId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The reference to the secret containing the region name
 *
 * @schema ClusterSpecBackupBarmanObjectStoreS3CredentialsRegion
 */
export interface ClusterSpecBackupBarmanObjectStoreS3CredentialsRegion {
  /**
   * The key to select
   *
   * @schema ClusterSpecBackupBarmanObjectStoreS3CredentialsRegion#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   *
   * @schema ClusterSpecBackupBarmanObjectStoreS3CredentialsRegion#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterSpecBackupBarmanObjectStoreS3CredentialsRegion' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecBackupBarmanObjectStoreS3CredentialsRegion(obj: ClusterSpecBackupBarmanObjectStoreS3CredentialsRegion | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The reference to the secret access key
 *
 * @schema ClusterSpecBackupBarmanObjectStoreS3CredentialsSecretAccessKey
 */
export interface ClusterSpecBackupBarmanObjectStoreS3CredentialsSecretAccessKey {
  /**
   * The key to select
   *
   * @schema ClusterSpecBackupBarmanObjectStoreS3CredentialsSecretAccessKey#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   *
   * @schema ClusterSpecBackupBarmanObjectStoreS3CredentialsSecretAccessKey#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterSpecBackupBarmanObjectStoreS3CredentialsSecretAccessKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecBackupBarmanObjectStoreS3CredentialsSecretAccessKey(obj: ClusterSpecBackupBarmanObjectStoreS3CredentialsSecretAccessKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The references to the session key
 *
 * @schema ClusterSpecBackupBarmanObjectStoreS3CredentialsSessionToken
 */
export interface ClusterSpecBackupBarmanObjectStoreS3CredentialsSessionToken {
  /**
   * The key to select
   *
   * @schema ClusterSpecBackupBarmanObjectStoreS3CredentialsSessionToken#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   *
   * @schema ClusterSpecBackupBarmanObjectStoreS3CredentialsSessionToken#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterSpecBackupBarmanObjectStoreS3CredentialsSessionToken' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecBackupBarmanObjectStoreS3CredentialsSessionToken(obj: ClusterSpecBackupBarmanObjectStoreS3CredentialsSessionToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Compress a WAL file before sending it to the object store. Available
 * options are empty string (no compression, default), `gzip`, `bzip2` or `snappy`.
 *
 * @schema ClusterSpecBackupBarmanObjectStoreWalCompression
 */
export enum ClusterSpecBackupBarmanObjectStoreWalCompression {
  /** gzip */
  GZIP = "gzip",
  /** bzip2 */
  BZIP2 = "bzip2",
  /** snappy */
  SNAPPY = "snappy",
}

/**
 * Whenever to force the encryption of files (if the bucket is
 * not already configured for that).
 * Allowed options are empty string (use the bucket policy, default),
 * `AES256` and `aws:kms`
 *
 * @schema ClusterSpecBackupBarmanObjectStoreWalEncryption
 */
export enum ClusterSpecBackupBarmanObjectStoreWalEncryption {
  /** AES256 */
  AES256 = "AES256",
  /** aws:kms */
  AWS_KMS = "aws:kms",
}

/**
 * The source of the import
 *
 * @schema ClusterSpecBootstrapInitdbImportSource
 */
export interface ClusterSpecBootstrapInitdbImportSource {
  /**
   * The name of the externalCluster used for import
   *
   * @schema ClusterSpecBootstrapInitdbImportSource#externalCluster
   */
  readonly externalCluster: string;

}

/**
 * Converts an object of type 'ClusterSpecBootstrapInitdbImportSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecBootstrapInitdbImportSource(obj: ClusterSpecBootstrapInitdbImportSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'externalCluster': obj.externalCluster,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The import type. Can be `microservice` or `monolith`.
 *
 * @schema ClusterSpecBootstrapInitdbImportType
 */
export enum ClusterSpecBootstrapInitdbImportType {
  /** microservice */
  MICROSERVICE = "microservice",
  /** monolith */
  MONOLITH = "monolith",
}

/**
 * ConfigMapKeySelector contains enough information to let you locate
 * the key of a ConfigMap
 *
 * @schema ClusterSpecBootstrapInitdbPostInitApplicationSqlRefsConfigMapRefs
 */
export interface ClusterSpecBootstrapInitdbPostInitApplicationSqlRefsConfigMapRefs {
  /**
   * The key to select
   *
   * @schema ClusterSpecBootstrapInitdbPostInitApplicationSqlRefsConfigMapRefs#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   *
   * @schema ClusterSpecBootstrapInitdbPostInitApplicationSqlRefsConfigMapRefs#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterSpecBootstrapInitdbPostInitApplicationSqlRefsConfigMapRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecBootstrapInitdbPostInitApplicationSqlRefsConfigMapRefs(obj: ClusterSpecBootstrapInitdbPostInitApplicationSqlRefsConfigMapRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector contains enough information to let you locate
 * the key of a Secret
 *
 * @schema ClusterSpecBootstrapInitdbPostInitApplicationSqlRefsSecretRefs
 */
export interface ClusterSpecBootstrapInitdbPostInitApplicationSqlRefsSecretRefs {
  /**
   * The key to select
   *
   * @schema ClusterSpecBootstrapInitdbPostInitApplicationSqlRefsSecretRefs#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   *
   * @schema ClusterSpecBootstrapInitdbPostInitApplicationSqlRefsSecretRefs#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterSpecBootstrapInitdbPostInitApplicationSqlRefsSecretRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecBootstrapInitdbPostInitApplicationSqlRefsSecretRefs(obj: ClusterSpecBootstrapInitdbPostInitApplicationSqlRefsSecretRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EndpointCA store the CA bundle of the barman endpoint.
 * Useful when using self-signed certificates to avoid
 * errors with certificate issuer and barman-cloud-wal-archive.
 *
 * @schema ClusterSpecBootstrapRecoveryBackupEndpointCa
 */
export interface ClusterSpecBootstrapRecoveryBackupEndpointCa {
  /**
   * The key to select
   *
   * @schema ClusterSpecBootstrapRecoveryBackupEndpointCa#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   *
   * @schema ClusterSpecBootstrapRecoveryBackupEndpointCa#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterSpecBootstrapRecoveryBackupEndpointCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecBootstrapRecoveryBackupEndpointCa(obj: ClusterSpecBootstrapRecoveryBackupEndpointCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configuration of the storage of the instances
 *
 * @schema ClusterSpecBootstrapRecoveryVolumeSnapshotsStorage
 */
export interface ClusterSpecBootstrapRecoveryVolumeSnapshotsStorage {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema ClusterSpecBootstrapRecoveryVolumeSnapshotsStorage#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema ClusterSpecBootstrapRecoveryVolumeSnapshotsStorage#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema ClusterSpecBootstrapRecoveryVolumeSnapshotsStorage#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterSpecBootstrapRecoveryVolumeSnapshotsStorage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecBootstrapRecoveryVolumeSnapshotsStorage(obj: ClusterSpecBootstrapRecoveryVolumeSnapshotsStorage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TypedLocalObjectReference contains enough information to let you locate the
 * typed referenced object inside the same namespace.
 *
 * @schema ClusterSpecBootstrapRecoveryVolumeSnapshotsTablespaceStorage
 */
export interface ClusterSpecBootstrapRecoveryVolumeSnapshotsTablespaceStorage {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema ClusterSpecBootstrapRecoveryVolumeSnapshotsTablespaceStorage#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema ClusterSpecBootstrapRecoveryVolumeSnapshotsTablespaceStorage#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema ClusterSpecBootstrapRecoveryVolumeSnapshotsTablespaceStorage#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterSpecBootstrapRecoveryVolumeSnapshotsTablespaceStorage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecBootstrapRecoveryVolumeSnapshotsTablespaceStorage(obj: ClusterSpecBootstrapRecoveryVolumeSnapshotsTablespaceStorage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configuration of the storage for PostgreSQL WAL (Write-Ahead Log)
 *
 * @schema ClusterSpecBootstrapRecoveryVolumeSnapshotsWalStorage
 */
export interface ClusterSpecBootstrapRecoveryVolumeSnapshotsWalStorage {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema ClusterSpecBootstrapRecoveryVolumeSnapshotsWalStorage#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema ClusterSpecBootstrapRecoveryVolumeSnapshotsWalStorage#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema ClusterSpecBootstrapRecoveryVolumeSnapshotsWalStorage#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterSpecBootstrapRecoveryVolumeSnapshotsWalStorage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecBootstrapRecoveryVolumeSnapshotsWalStorage(obj: ClusterSpecBootstrapRecoveryVolumeSnapshotsWalStorage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema ClusterSpecEnvValueFromResourceFieldRefDivisor
 */
export class ClusterSpecEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(value: number): ClusterSpecEnvValueFromResourceFieldRefDivisor {
    return new ClusterSpecEnvValueFromResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): ClusterSpecEnvValueFromResourceFieldRefDivisor {
    return new ClusterSpecEnvValueFromResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * dataSource field can be used to specify either:
 * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
 * * An existing PVC (PersistentVolumeClaim)
 * If the provisioner or an external controller can support the specified data source,
 * it will create a new volume based on the contents of the specified data source.
 * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
 * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
 * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
 *
 * @schema ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecDataSource
 */
export interface ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecDataSource {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecDataSource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecDataSource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecDataSource#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecDataSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecDataSource(obj: ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecDataSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
 * volume is desired. This may be any object from a non-empty API group (non
 * core object) or a PersistentVolumeClaim object.
 * When this field is specified, volume binding will only succeed if the type of
 * the specified object matches some installed volume populator or dynamic
 * provisioner.
 * This field will replace the functionality of the dataSource field and as such
 * if both fields are non-empty, they must have the same value. For backwards
 * compatibility, when namespace isn't specified in dataSourceRef,
 * both fields (dataSource and dataSourceRef) will be set to the same
 * value automatically if one of them is empty and the other is non-empty.
 * When namespace is specified in dataSourceRef,
 * dataSource isn't set to the same value and must be empty.
 * There are three important differences between dataSource and dataSourceRef:
 * * While dataSource only allows two specific types of objects, dataSourceRef
 * allows any non-core object, as well as PersistentVolumeClaim objects.
 * * While dataSource ignores disallowed values (dropping them), dataSourceRef
 * preserves all values, and generates an error if a disallowed value is
 * specified.
 * * While dataSource only allows local objects, dataSourceRef allows objects
 * in any namespaces.
 * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
 * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
 *
 * @schema ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecDataSourceRef
 */
export interface ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecDataSourceRef {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecDataSourceRef#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecDataSourceRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecDataSourceRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of resource being referenced
   * Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
   * (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecDataSourceRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecDataSourceRef(obj: ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecDataSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * resources represents the minimum resources the volume should have.
 * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
 * that are lower than previous value but must still be higher than capacity recorded in the
 * status field of the claim.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
 *
 * @schema ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecResources
 */
export interface ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecResources {
  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecResources#limits
   */
  readonly limits?: { [key: string]: ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecResources#requests
   */
  readonly requests?: { [key: string]: ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecResourcesRequests };

}

/**
 * Converts an object of type 'ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecResources(obj: ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * selector is a label query over volumes to consider for binding.
 *
 * @schema ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecSelector
 */
export interface ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecSelector(obj: ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The connection string to be used
 *
 * @schema ClusterSpecExternalClustersBarmanObjectStoreAzureCredentialsConnectionString
 */
export interface ClusterSpecExternalClustersBarmanObjectStoreAzureCredentialsConnectionString {
  /**
   * The key to select
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreAzureCredentialsConnectionString#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreAzureCredentialsConnectionString#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterSpecExternalClustersBarmanObjectStoreAzureCredentialsConnectionString' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecExternalClustersBarmanObjectStoreAzureCredentialsConnectionString(obj: ClusterSpecExternalClustersBarmanObjectStoreAzureCredentialsConnectionString | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The storage account where to upload data
 *
 * @schema ClusterSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageAccount
 */
export interface ClusterSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageAccount {
  /**
   * The key to select
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageAccount#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageAccount#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageAccount' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageAccount(obj: ClusterSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageAccount | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The storage account key to be used in conjunction
 * with the storage account name
 *
 * @schema ClusterSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageKey
 */
export interface ClusterSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageKey {
  /**
   * The key to select
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageKey#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageKey#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageKey(obj: ClusterSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A shared-access-signature to be used in conjunction with
 * the storage account name
 *
 * @schema ClusterSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageSasToken
 */
export interface ClusterSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageSasToken {
  /**
   * The key to select
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageSasToken#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageSasToken#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageSasToken' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageSasToken(obj: ClusterSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageSasToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Compress a backup file (a tar file per tablespace) while streaming it
 * to the object store. Available options are empty string (no
 * compression, default), `gzip`, `bzip2` or `snappy`.
 *
 * @schema ClusterSpecExternalClustersBarmanObjectStoreDataCompression
 */
export enum ClusterSpecExternalClustersBarmanObjectStoreDataCompression {
  /** gzip */
  GZIP = "gzip",
  /** bzip2 */
  BZIP2 = "bzip2",
  /** snappy */
  SNAPPY = "snappy",
}

/**
 * Whenever to force the encryption of files (if the bucket is
 * not already configured for that).
 * Allowed options are empty string (use the bucket policy, default),
 * `AES256` and `aws:kms`
 *
 * @schema ClusterSpecExternalClustersBarmanObjectStoreDataEncryption
 */
export enum ClusterSpecExternalClustersBarmanObjectStoreDataEncryption {
  /** AES256 */
  AES256 = "AES256",
  /** aws:kms */
  AWS_KMS = "aws:kms",
}

/**
 * The secret containing the Google Cloud Storage JSON file with the credentials
 *
 * @schema ClusterSpecExternalClustersBarmanObjectStoreGoogleCredentialsApplicationCredentials
 */
export interface ClusterSpecExternalClustersBarmanObjectStoreGoogleCredentialsApplicationCredentials {
  /**
   * The key to select
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreGoogleCredentialsApplicationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreGoogleCredentialsApplicationCredentials#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterSpecExternalClustersBarmanObjectStoreGoogleCredentialsApplicationCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecExternalClustersBarmanObjectStoreGoogleCredentialsApplicationCredentials(obj: ClusterSpecExternalClustersBarmanObjectStoreGoogleCredentialsApplicationCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The reference to the access key id
 *
 * @schema ClusterSpecExternalClustersBarmanObjectStoreS3CredentialsAccessKeyId
 */
export interface ClusterSpecExternalClustersBarmanObjectStoreS3CredentialsAccessKeyId {
  /**
   * The key to select
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreS3CredentialsAccessKeyId#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreS3CredentialsAccessKeyId#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterSpecExternalClustersBarmanObjectStoreS3CredentialsAccessKeyId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecExternalClustersBarmanObjectStoreS3CredentialsAccessKeyId(obj: ClusterSpecExternalClustersBarmanObjectStoreS3CredentialsAccessKeyId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The reference to the secret containing the region name
 *
 * @schema ClusterSpecExternalClustersBarmanObjectStoreS3CredentialsRegion
 */
export interface ClusterSpecExternalClustersBarmanObjectStoreS3CredentialsRegion {
  /**
   * The key to select
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreS3CredentialsRegion#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreS3CredentialsRegion#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterSpecExternalClustersBarmanObjectStoreS3CredentialsRegion' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecExternalClustersBarmanObjectStoreS3CredentialsRegion(obj: ClusterSpecExternalClustersBarmanObjectStoreS3CredentialsRegion | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The reference to the secret access key
 *
 * @schema ClusterSpecExternalClustersBarmanObjectStoreS3CredentialsSecretAccessKey
 */
export interface ClusterSpecExternalClustersBarmanObjectStoreS3CredentialsSecretAccessKey {
  /**
   * The key to select
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreS3CredentialsSecretAccessKey#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreS3CredentialsSecretAccessKey#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterSpecExternalClustersBarmanObjectStoreS3CredentialsSecretAccessKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecExternalClustersBarmanObjectStoreS3CredentialsSecretAccessKey(obj: ClusterSpecExternalClustersBarmanObjectStoreS3CredentialsSecretAccessKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The references to the session key
 *
 * @schema ClusterSpecExternalClustersBarmanObjectStoreS3CredentialsSessionToken
 */
export interface ClusterSpecExternalClustersBarmanObjectStoreS3CredentialsSessionToken {
  /**
   * The key to select
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreS3CredentialsSessionToken#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   *
   * @schema ClusterSpecExternalClustersBarmanObjectStoreS3CredentialsSessionToken#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterSpecExternalClustersBarmanObjectStoreS3CredentialsSessionToken' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecExternalClustersBarmanObjectStoreS3CredentialsSessionToken(obj: ClusterSpecExternalClustersBarmanObjectStoreS3CredentialsSessionToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Compress a WAL file before sending it to the object store. Available
 * options are empty string (no compression, default), `gzip`, `bzip2` or `snappy`.
 *
 * @schema ClusterSpecExternalClustersBarmanObjectStoreWalCompression
 */
export enum ClusterSpecExternalClustersBarmanObjectStoreWalCompression {
  /** gzip */
  GZIP = "gzip",
  /** bzip2 */
  BZIP2 = "bzip2",
  /** snappy */
  SNAPPY = "snappy",
}

/**
 * Whenever to force the encryption of files (if the bucket is
 * not already configured for that).
 * Allowed options are empty string (use the bucket policy, default),
 * `AES256` and `aws:kms`
 *
 * @schema ClusterSpecExternalClustersBarmanObjectStoreWalEncryption
 */
export enum ClusterSpecExternalClustersBarmanObjectStoreWalEncryption {
  /** AES256 */
  AES256 = "AES256",
  /** aws:kms */
  AWS_KMS = "aws:kms",
}

/**
 * Secret with the password for the user to bind to the directory
 *
 * @schema ClusterSpecPostgresqlLdapBindSearchAuthBindPassword
 */
export interface ClusterSpecPostgresqlLdapBindSearchAuthBindPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ClusterSpecPostgresqlLdapBindSearchAuthBindPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ClusterSpecPostgresqlLdapBindSearchAuthBindPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ClusterSpecPostgresqlLdapBindSearchAuthBindPassword#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ClusterSpecPostgresqlLdapBindSearchAuthBindPassword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecPostgresqlLdapBindSearchAuthBindPassword(obj: ClusterSpecPostgresqlLdapBindSearchAuthBindPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Select all ClusterTrustBundles that match this label selector.  Only has
 * effect if signerName is set.  Mutually-exclusive with name.  If unset,
 * interpreted as "match nothing".  If set but empty, interpreted as "match
 * everything".
 *
 * @schema ClusterSpecProjectedVolumeTemplateSourcesClusterTrustBundleLabelSelector
 */
export interface ClusterSpecProjectedVolumeTemplateSourcesClusterTrustBundleLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterSpecProjectedVolumeTemplateSourcesClusterTrustBundleLabelSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterSpecProjectedVolumeTemplateSourcesClusterTrustBundleLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterSpecProjectedVolumeTemplateSourcesClusterTrustBundleLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterSpecProjectedVolumeTemplateSourcesClusterTrustBundleLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecProjectedVolumeTemplateSourcesClusterTrustBundleLabelSelector(obj: ClusterSpecProjectedVolumeTemplateSourcesClusterTrustBundleLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterSpecProjectedVolumeTemplateSourcesClusterTrustBundleLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema ClusterSpecProjectedVolumeTemplateSourcesConfigMapItems
 */
export interface ClusterSpecProjectedVolumeTemplateSourcesConfigMapItems {
  /**
   * key is the key to project.
   *
   * @schema ClusterSpecProjectedVolumeTemplateSourcesConfigMapItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema ClusterSpecProjectedVolumeTemplateSourcesConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to.
   * May not be an absolute path.
   * May not contain the path element '..'.
   * May not start with the string '..'.
   *
   * @schema ClusterSpecProjectedVolumeTemplateSourcesConfigMapItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'ClusterSpecProjectedVolumeTemplateSourcesConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecProjectedVolumeTemplateSourcesConfigMapItems(obj: ClusterSpecProjectedVolumeTemplateSourcesConfigMapItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DownwardAPIVolumeFile represents information to create the file containing the pod field
 *
 * @schema ClusterSpecProjectedVolumeTemplateSourcesDownwardApiItems
 */
export interface ClusterSpecProjectedVolumeTemplateSourcesDownwardApiItems {
  /**
   * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
   *
   * @schema ClusterSpecProjectedVolumeTemplateSourcesDownwardApiItems#fieldRef
   */
  readonly fieldRef?: ClusterSpecProjectedVolumeTemplateSourcesDownwardApiItemsFieldRef;

  /**
   * Optional: mode bits used to set permissions on this file, must be an octal value
   * between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema ClusterSpecProjectedVolumeTemplateSourcesDownwardApiItems#mode
   */
  readonly mode?: number;

  /**
   * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
   *
   * @schema ClusterSpecProjectedVolumeTemplateSourcesDownwardApiItems#path
   */
  readonly path: string;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
   *
   * @schema ClusterSpecProjectedVolumeTemplateSourcesDownwardApiItems#resourceFieldRef
   */
  readonly resourceFieldRef?: ClusterSpecProjectedVolumeTemplateSourcesDownwardApiItemsResourceFieldRef;

}

/**
 * Converts an object of type 'ClusterSpecProjectedVolumeTemplateSourcesDownwardApiItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecProjectedVolumeTemplateSourcesDownwardApiItems(obj: ClusterSpecProjectedVolumeTemplateSourcesDownwardApiItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fieldRef': toJson_ClusterSpecProjectedVolumeTemplateSourcesDownwardApiItemsFieldRef(obj.fieldRef),
    'mode': obj.mode,
    'path': obj.path,
    'resourceFieldRef': toJson_ClusterSpecProjectedVolumeTemplateSourcesDownwardApiItemsResourceFieldRef(obj.resourceFieldRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema ClusterSpecProjectedVolumeTemplateSourcesSecretItems
 */
export interface ClusterSpecProjectedVolumeTemplateSourcesSecretItems {
  /**
   * key is the key to project.
   *
   * @schema ClusterSpecProjectedVolumeTemplateSourcesSecretItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema ClusterSpecProjectedVolumeTemplateSourcesSecretItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to.
   * May not be an absolute path.
   * May not contain the path element '..'.
   * May not start with the string '..'.
   *
   * @schema ClusterSpecProjectedVolumeTemplateSourcesSecretItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'ClusterSpecProjectedVolumeTemplateSourcesSecretItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecProjectedVolumeTemplateSourcesSecretItems(obj: ClusterSpecProjectedVolumeTemplateSourcesSecretItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecStoragePvcTemplateResourcesLimits
 */
export class ClusterSpecStoragePvcTemplateResourcesLimits {
  public static fromNumber(value: number): ClusterSpecStoragePvcTemplateResourcesLimits {
    return new ClusterSpecStoragePvcTemplateResourcesLimits(value);
  }
  public static fromString(value: string): ClusterSpecStoragePvcTemplateResourcesLimits {
    return new ClusterSpecStoragePvcTemplateResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema ClusterSpecStoragePvcTemplateResourcesRequests
 */
export class ClusterSpecStoragePvcTemplateResourcesRequests {
  public static fromNumber(value: number): ClusterSpecStoragePvcTemplateResourcesRequests {
    return new ClusterSpecStoragePvcTemplateResourcesRequests(value);
  }
  public static fromString(value: string): ClusterSpecStoragePvcTemplateResourcesRequests {
    return new ClusterSpecStoragePvcTemplateResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterSpecStoragePvcTemplateSelectorMatchExpressions
 */
export interface ClusterSpecStoragePvcTemplateSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterSpecStoragePvcTemplateSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterSpecStoragePvcTemplateSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterSpecStoragePvcTemplateSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterSpecStoragePvcTemplateSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecStoragePvcTemplateSelectorMatchExpressions(obj: ClusterSpecStoragePvcTemplateSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * dataSource field can be used to specify either:
 * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
 * * An existing PVC (PersistentVolumeClaim)
 * If the provisioner or an external controller can support the specified data source,
 * it will create a new volume based on the contents of the specified data source.
 * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
 * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
 * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
 *
 * @schema ClusterSpecTablespacesStoragePvcTemplateDataSource
 */
export interface ClusterSpecTablespacesStoragePvcTemplateDataSource {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema ClusterSpecTablespacesStoragePvcTemplateDataSource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema ClusterSpecTablespacesStoragePvcTemplateDataSource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema ClusterSpecTablespacesStoragePvcTemplateDataSource#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterSpecTablespacesStoragePvcTemplateDataSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecTablespacesStoragePvcTemplateDataSource(obj: ClusterSpecTablespacesStoragePvcTemplateDataSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
 * volume is desired. This may be any object from a non-empty API group (non
 * core object) or a PersistentVolumeClaim object.
 * When this field is specified, volume binding will only succeed if the type of
 * the specified object matches some installed volume populator or dynamic
 * provisioner.
 * This field will replace the functionality of the dataSource field and as such
 * if both fields are non-empty, they must have the same value. For backwards
 * compatibility, when namespace isn't specified in dataSourceRef,
 * both fields (dataSource and dataSourceRef) will be set to the same
 * value automatically if one of them is empty and the other is non-empty.
 * When namespace is specified in dataSourceRef,
 * dataSource isn't set to the same value and must be empty.
 * There are three important differences between dataSource and dataSourceRef:
 * * While dataSource only allows two specific types of objects, dataSourceRef
 * allows any non-core object, as well as PersistentVolumeClaim objects.
 * * While dataSource ignores disallowed values (dropping them), dataSourceRef
 * preserves all values, and generates an error if a disallowed value is
 * specified.
 * * While dataSource only allows local objects, dataSourceRef allows objects
 * in any namespaces.
 * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
 * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
 *
 * @schema ClusterSpecTablespacesStoragePvcTemplateDataSourceRef
 */
export interface ClusterSpecTablespacesStoragePvcTemplateDataSourceRef {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema ClusterSpecTablespacesStoragePvcTemplateDataSourceRef#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema ClusterSpecTablespacesStoragePvcTemplateDataSourceRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema ClusterSpecTablespacesStoragePvcTemplateDataSourceRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of resource being referenced
   * Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
   * (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema ClusterSpecTablespacesStoragePvcTemplateDataSourceRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSpecTablespacesStoragePvcTemplateDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecTablespacesStoragePvcTemplateDataSourceRef(obj: ClusterSpecTablespacesStoragePvcTemplateDataSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * resources represents the minimum resources the volume should have.
 * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
 * that are lower than previous value but must still be higher than capacity recorded in the
 * status field of the claim.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
 *
 * @schema ClusterSpecTablespacesStoragePvcTemplateResources
 */
export interface ClusterSpecTablespacesStoragePvcTemplateResources {
  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ClusterSpecTablespacesStoragePvcTemplateResources#limits
   */
  readonly limits?: { [key: string]: ClusterSpecTablespacesStoragePvcTemplateResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ClusterSpecTablespacesStoragePvcTemplateResources#requests
   */
  readonly requests?: { [key: string]: ClusterSpecTablespacesStoragePvcTemplateResourcesRequests };

}

/**
 * Converts an object of type 'ClusterSpecTablespacesStoragePvcTemplateResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecTablespacesStoragePvcTemplateResources(obj: ClusterSpecTablespacesStoragePvcTemplateResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * selector is a label query over volumes to consider for binding.
 *
 * @schema ClusterSpecTablespacesStoragePvcTemplateSelector
 */
export interface ClusterSpecTablespacesStoragePvcTemplateSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterSpecTablespacesStoragePvcTemplateSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterSpecTablespacesStoragePvcTemplateSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterSpecTablespacesStoragePvcTemplateSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterSpecTablespacesStoragePvcTemplateSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecTablespacesStoragePvcTemplateSelector(obj: ClusterSpecTablespacesStoragePvcTemplateSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterSpecTablespacesStoragePvcTemplateSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecWalStoragePvcTemplateResourcesLimits
 */
export class ClusterSpecWalStoragePvcTemplateResourcesLimits {
  public static fromNumber(value: number): ClusterSpecWalStoragePvcTemplateResourcesLimits {
    return new ClusterSpecWalStoragePvcTemplateResourcesLimits(value);
  }
  public static fromString(value: string): ClusterSpecWalStoragePvcTemplateResourcesLimits {
    return new ClusterSpecWalStoragePvcTemplateResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema ClusterSpecWalStoragePvcTemplateResourcesRequests
 */
export class ClusterSpecWalStoragePvcTemplateResourcesRequests {
  public static fromNumber(value: number): ClusterSpecWalStoragePvcTemplateResourcesRequests {
    return new ClusterSpecWalStoragePvcTemplateResourcesRequests(value);
  }
  public static fromString(value: string): ClusterSpecWalStoragePvcTemplateResourcesRequests {
    return new ClusterSpecWalStoragePvcTemplateResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterSpecWalStoragePvcTemplateSelectorMatchExpressions
 */
export interface ClusterSpecWalStoragePvcTemplateSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterSpecWalStoragePvcTemplateSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterSpecWalStoragePvcTemplateSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterSpecWalStoragePvcTemplateSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterSpecWalStoragePvcTemplateSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecWalStoragePvcTemplateSelectorMatchExpressions(obj: ClusterSpecWalStoragePvcTemplateSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: ClusterSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: ClusterSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema ClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface ClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema ClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema ClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema ClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(obj: ClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema ClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface ClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema ClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema ClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema ClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(obj: ClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema ClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface ClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema ClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema ClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema ClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(obj: ClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema ClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface ClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema ClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema ClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema ClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(obj: ClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecResourcesLimits
 */
export class ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecResourcesLimits {
  public static fromNumber(value: number): ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecResourcesLimits {
    return new ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecResourcesLimits(value);
  }
  public static fromString(value: string): ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecResourcesLimits {
    return new ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecResourcesRequests
 */
export class ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecResourcesRequests {
  public static fromNumber(value: number): ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecResourcesRequests {
    return new ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecResourcesRequests(value);
  }
  public static fromString(value: string): ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecResourcesRequests {
    return new ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecSelectorMatchExpressions
 */
export interface ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecSelectorMatchExpressions(obj: ClusterSpecEphemeralVolumeSourceVolumeClaimTemplateSpecSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterSpecProjectedVolumeTemplateSourcesClusterTrustBundleLabelSelectorMatchExpressions
 */
export interface ClusterSpecProjectedVolumeTemplateSourcesClusterTrustBundleLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterSpecProjectedVolumeTemplateSourcesClusterTrustBundleLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterSpecProjectedVolumeTemplateSourcesClusterTrustBundleLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterSpecProjectedVolumeTemplateSourcesClusterTrustBundleLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterSpecProjectedVolumeTemplateSourcesClusterTrustBundleLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecProjectedVolumeTemplateSourcesClusterTrustBundleLabelSelectorMatchExpressions(obj: ClusterSpecProjectedVolumeTemplateSourcesClusterTrustBundleLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
 *
 * @schema ClusterSpecProjectedVolumeTemplateSourcesDownwardApiItemsFieldRef
 */
export interface ClusterSpecProjectedVolumeTemplateSourcesDownwardApiItemsFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema ClusterSpecProjectedVolumeTemplateSourcesDownwardApiItemsFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema ClusterSpecProjectedVolumeTemplateSourcesDownwardApiItemsFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'ClusterSpecProjectedVolumeTemplateSourcesDownwardApiItemsFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecProjectedVolumeTemplateSourcesDownwardApiItemsFieldRef(obj: ClusterSpecProjectedVolumeTemplateSourcesDownwardApiItemsFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
 *
 * @schema ClusterSpecProjectedVolumeTemplateSourcesDownwardApiItemsResourceFieldRef
 */
export interface ClusterSpecProjectedVolumeTemplateSourcesDownwardApiItemsResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema ClusterSpecProjectedVolumeTemplateSourcesDownwardApiItemsResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema ClusterSpecProjectedVolumeTemplateSourcesDownwardApiItemsResourceFieldRef#divisor
   */
  readonly divisor?: ClusterSpecProjectedVolumeTemplateSourcesDownwardApiItemsResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema ClusterSpecProjectedVolumeTemplateSourcesDownwardApiItemsResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'ClusterSpecProjectedVolumeTemplateSourcesDownwardApiItemsResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecProjectedVolumeTemplateSourcesDownwardApiItemsResourceFieldRef(obj: ClusterSpecProjectedVolumeTemplateSourcesDownwardApiItemsResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecTablespacesStoragePvcTemplateResourcesLimits
 */
export class ClusterSpecTablespacesStoragePvcTemplateResourcesLimits {
  public static fromNumber(value: number): ClusterSpecTablespacesStoragePvcTemplateResourcesLimits {
    return new ClusterSpecTablespacesStoragePvcTemplateResourcesLimits(value);
  }
  public static fromString(value: string): ClusterSpecTablespacesStoragePvcTemplateResourcesLimits {
    return new ClusterSpecTablespacesStoragePvcTemplateResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema ClusterSpecTablespacesStoragePvcTemplateResourcesRequests
 */
export class ClusterSpecTablespacesStoragePvcTemplateResourcesRequests {
  public static fromNumber(value: number): ClusterSpecTablespacesStoragePvcTemplateResourcesRequests {
    return new ClusterSpecTablespacesStoragePvcTemplateResourcesRequests(value);
  }
  public static fromString(value: string): ClusterSpecTablespacesStoragePvcTemplateResourcesRequests {
    return new ClusterSpecTablespacesStoragePvcTemplateResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterSpecTablespacesStoragePvcTemplateSelectorMatchExpressions
 */
export interface ClusterSpecTablespacesStoragePvcTemplateSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterSpecTablespacesStoragePvcTemplateSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterSpecTablespacesStoragePvcTemplateSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterSpecTablespacesStoragePvcTemplateSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterSpecTablespacesStoragePvcTemplateSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecTablespacesStoragePvcTemplateSelectorMatchExpressions(obj: ClusterSpecTablespacesStoragePvcTemplateSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: ClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: ClusterSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema ClusterSpecProjectedVolumeTemplateSourcesDownwardApiItemsResourceFieldRefDivisor
 */
export class ClusterSpecProjectedVolumeTemplateSourcesDownwardApiItemsResourceFieldRefDivisor {
  public static fromNumber(value: number): ClusterSpecProjectedVolumeTemplateSourcesDownwardApiItemsResourceFieldRefDivisor {
    return new ClusterSpecProjectedVolumeTemplateSourcesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): ClusterSpecProjectedVolumeTemplateSourcesDownwardApiItemsResourceFieldRefDivisor {
    return new ClusterSpecProjectedVolumeTemplateSourcesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

