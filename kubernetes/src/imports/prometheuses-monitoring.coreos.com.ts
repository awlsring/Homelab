// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Prometheus defines a Prometheus deployment.
 *
 * @schema Prometheus
 */
export class Prometheus extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Prometheus"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'monitoring.coreos.com/v1',
    kind: 'Prometheus',
  }

  /**
   * Renders a Kubernetes manifest for "Prometheus".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: PrometheusProps): any {
    return {
      ...Prometheus.GVK,
      ...toJson_PrometheusProps(props),
    };
  }

  /**
   * Defines a "Prometheus" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: PrometheusProps) {
    super(scope, id, {
      ...Prometheus.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Prometheus.GVK,
      ...toJson_PrometheusProps(resolved),
    };
  }
}

/**
 * Prometheus defines a Prometheus deployment.
 *
 * @schema Prometheus
 */
export interface PrometheusProps {
  /**
   * @schema Prometheus#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Specification of the desired behavior of the Prometheus cluster. More info:
   * https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
   *
   * @schema Prometheus#spec
   */
  readonly spec: PrometheusSpec;

}

/**
 * Converts an object of type 'PrometheusProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusProps(obj: PrometheusProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_PrometheusSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specification of the desired behavior of the Prometheus cluster. More info:
 * https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
 *
 * @schema PrometheusSpec
 */
export interface PrometheusSpec {
  /**
   * AdditionalAlertManagerConfigs specifies a key of a Secret containing
   * additional Prometheus Alertmanager configurations. The Alertmanager
   * configurations are appended to the configuration generated by the
   * Prometheus Operator. They must be formatted according to the official
   * Prometheus documentation:
   *
   *
   * https://prometheus.io/docs/prometheus/latest/configuration/configuration/#alertmanager_config
   *
   *
   * The user is responsible for making sure that the configurations are valid
   *
   *
   * Note that using this feature may expose the possibility to break
   * upgrades of Prometheus. It is advised to review Prometheus release notes
   * to ensure that no incompatible AlertManager configs are going to break
   * Prometheus after the upgrade.
   *
   * @schema PrometheusSpec#additionalAlertManagerConfigs
   */
  readonly additionalAlertManagerConfigs?: PrometheusSpecAdditionalAlertManagerConfigs;

  /**
   * AdditionalAlertRelabelConfigs specifies a key of a Secret containing
   * additional Prometheus alert relabel configurations. The alert relabel
   * configurations are appended to the configuration generated by the
   * Prometheus Operator. They must be formatted according to the official
   * Prometheus documentation:
   *
   *
   * https://prometheus.io/docs/prometheus/latest/configuration/configuration/#alert_relabel_configs
   *
   *
   * The user is responsible for making sure that the configurations are valid
   *
   *
   * Note that using this feature may expose the possibility to break
   * upgrades of Prometheus. It is advised to review Prometheus release notes
   * to ensure that no incompatible alert relabel configs are going to break
   * Prometheus after the upgrade.
   *
   * @schema PrometheusSpec#additionalAlertRelabelConfigs
   */
  readonly additionalAlertRelabelConfigs?: PrometheusSpecAdditionalAlertRelabelConfigs;

  /**
   * AdditionalArgs allows setting additional arguments for the 'prometheus' container.
   *
   *
   * It is intended for e.g. activating hidden flags which are not supported by
   * the dedicated configuration options yet. The arguments are passed as-is to the
   * Prometheus container which may cause issues if they are invalid or not supported
   * by the given Prometheus version.
   *
   *
   * In case of an argument conflict (e.g. an argument which is already set by the
   * operator itself) or when providing an invalid argument, the reconciliation will
   * fail and an error will be logged.
   *
   * @schema PrometheusSpec#additionalArgs
   */
  readonly additionalArgs?: PrometheusSpecAdditionalArgs[];

  /**
   * AdditionalScrapeConfigs allows specifying a key of a Secret containing
   * additional Prometheus scrape configurations. Scrape configurations
   * specified are appended to the configurations generated by the Prometheus
   * Operator. Job configurations specified must have the form as specified
   * in the official Prometheus documentation:
   * https://prometheus.io/docs/prometheus/latest/configuration/configuration/#scrape_config.
   * As scrape configs are appended, the user is responsible to make sure it
   * is valid. Note that using this feature may expose the possibility to
   * break upgrades of Prometheus. It is advised to review Prometheus release
   * notes to ensure that no incompatible scrape configs are going to break
   * Prometheus after the upgrade.
   *
   * @schema PrometheusSpec#additionalScrapeConfigs
   */
  readonly additionalScrapeConfigs?: PrometheusSpecAdditionalScrapeConfigs;

  /**
   * Defines the Pods' affinity scheduling rules if specified.
   *
   * @schema PrometheusSpec#affinity
   */
  readonly affinity?: PrometheusSpecAffinity;

  /**
   * Defines the settings related to Alertmanager.
   *
   * @schema PrometheusSpec#alerting
   */
  readonly alerting?: PrometheusSpecAlerting;

  /**
   * AllowOverlappingBlocks enables vertical compaction and vertical query
   * merge in Prometheus.
   *
   *
   * Deprecated: this flag has no effect for Prometheus >= 2.39.0 where overlapping blocks are enabled by default.
   *
   * @schema PrometheusSpec#allowOverlappingBlocks
   */
  readonly allowOverlappingBlocks?: boolean;

  /**
   * APIServerConfig allows specifying a host and auth methods to access the
   * Kuberntees API server.
   * If null, Prometheus is assumed to run inside of the cluster: it will
   * discover the API servers automatically and use the Pod's CA certificate
   * and bearer token file at /var/run/secrets/kubernetes.io/serviceaccount/.
   *
   * @schema PrometheusSpec#apiserverConfig
   */
  readonly apiserverConfig?: PrometheusSpecApiserverConfig;

  /**
   * When true, ServiceMonitor, PodMonitor and Probe object are forbidden to
   * reference arbitrary files on the file system of the 'prometheus'
   * container.
   * When a ServiceMonitor's endpoint specifies a `bearerTokenFile` value
   * (e.g.  '/var/run/secrets/kubernetes.io/serviceaccount/token'), a
   * malicious target can get access to the Prometheus service account's
   * token in the Prometheus' scrape request. Setting
   * `spec.arbitraryFSAccessThroughSM` to 'true' would prevent the attack.
   * Users should instead provide the credentials using the
   * `spec.bearerTokenSecret` field.
   *
   * @schema PrometheusSpec#arbitraryFSAccessThroughSMs
   */
  readonly arbitraryFsAccessThroughSMs?: PrometheusSpecArbitraryFsAccessThroughSMs;

  /**
   * AutomountServiceAccountToken indicates whether a service account token should be automatically mounted in the pod.
   * If the field isn't set, the operator mounts the service account token by default.
   *
   *
   * **Warning:** be aware that by default, Prometheus requires the service account token for Kubernetes service discovery.
   * It is possible to use strategic merge patch to project the service account token into the 'prometheus' container.
   *
   * @schema PrometheusSpec#automountServiceAccountToken
   */
  readonly automountServiceAccountToken?: boolean;

  /**
   * Deprecated: use 'spec.image' instead.
   *
   * @schema PrometheusSpec#baseImage
   */
  readonly baseImage?: string;

  /**
   * BodySizeLimit defines per-scrape on response body size.
   * Only valid in Prometheus versions 2.45.0 and newer.
   *
   * @schema PrometheusSpec#bodySizeLimit
   */
  readonly bodySizeLimit?: string;

  /**
   * ConfigMaps is a list of ConfigMaps in the same namespace as the Prometheus
   * object, which shall be mounted into the Prometheus Pods.
   * Each ConfigMap is added to the StatefulSet definition as a volume named `configmap-<configmap-name>`.
   * The ConfigMaps are mounted into /etc/prometheus/configmaps/<configmap-name> in the 'prometheus' container.
   *
   * @schema PrometheusSpec#configMaps
   */
  readonly configMaps?: string[];

  /**
   * Containers allows injecting additional containers or modifying operator
   * generated containers. This can be used to allow adding an authentication
   * proxy to the Pods or to change the behavior of an operator generated
   * container. Containers described here modify an operator generated
   * container if they share the same name and modifications are done via a
   * strategic merge patch.
   *
   *
   * The names of containers managed by the operator are:
   * * `prometheus`
   * * `config-reloader`
   * * `thanos-sidecar`
   *
   *
   * Overriding containers is entirely outside the scope of what the
   * maintainers will support and by doing so, you accept that this behaviour
   * may break at any time without notice.
   *
   * @schema PrometheusSpec#containers
   */
  readonly containers?: PrometheusSpecContainers[];

  /**
   * When true, the Prometheus compaction is disabled.
   *
   * @schema PrometheusSpec#disableCompaction
   */
  readonly disableCompaction?: boolean;

  /**
   * Enables access to the Prometheus web admin API.
   *
   *
   * WARNING: Enabling the admin APIs enables mutating endpoints, to delete data,
   * shutdown Prometheus, and more. Enabling this should be done with care and the
   * user is advised to add additional authentication authorization via a proxy to
   * ensure only clients authorized to perform these actions can do so.
   *
   *
   * For more information:
   * https://prometheus.io/docs/prometheus/latest/querying/api/#tsdb-admin-apis
   *
   * @schema PrometheusSpec#enableAdminAPI
   */
  readonly enableAdminApi?: boolean;

  /**
   * Enable access to Prometheus feature flags. By default, no features are enabled.
   *
   *
   * Enabling features which are disabled by default is entirely outside the
   * scope of what the maintainers will support and by doing so, you accept
   * that this behaviour may break at any time without notice.
   *
   *
   * For more information see https://prometheus.io/docs/prometheus/latest/feature_flags/
   *
   * @schema PrometheusSpec#enableFeatures
   */
  readonly enableFeatures?: string[];

  /**
   * Enable Prometheus to be used as a receiver for the Prometheus remote
   * write protocol.
   *
   *
   * WARNING: This is not considered an efficient way of ingesting samples.
   * Use it with caution for specific low-volume use cases.
   * It is not suitable for replacing the ingestion via scraping and turning
   * Prometheus into a push-based metrics collection system.
   * For more information see https://prometheus.io/docs/prometheus/latest/querying/api/#remote-write-receiver
   *
   *
   * It requires Prometheus >= v2.33.0.
   *
   * @schema PrometheusSpec#enableRemoteWriteReceiver
   */
  readonly enableRemoteWriteReceiver?: boolean;

  /**
   * When defined, enforcedBodySizeLimit specifies a global limit on the size
   * of uncompressed response body that will be accepted by Prometheus.
   * Targets responding with a body larger than this many bytes will cause
   * the scrape to fail.
   *
   *
   * It requires Prometheus >= v2.28.0.
   *
   * @schema PrometheusSpec#enforcedBodySizeLimit
   */
  readonly enforcedBodySizeLimit?: string;

  /**
   * When defined, enforcedKeepDroppedTargets specifies a global limit on the number of targets
   * dropped by relabeling that will be kept in memory. The value overrides
   * any `spec.keepDroppedTargets` set by
   * ServiceMonitor, PodMonitor, Probe objects unless `spec.keepDroppedTargets` is
   * greater than zero and less than `spec.enforcedKeepDroppedTargets`.
   *
   *
   * It requires Prometheus >= v2.47.0.
   *
   * @schema PrometheusSpec#enforcedKeepDroppedTargets
   */
  readonly enforcedKeepDroppedTargets?: number;

  /**
   * When defined, enforcedLabelLimit specifies a global limit on the number
   * of labels per sample. The value overrides any `spec.labelLimit` set by
   * ServiceMonitor, PodMonitor, Probe objects unless `spec.labelLimit` is
   * greater than zero and less than `spec.enforcedLabelLimit`.
   *
   *
   * It requires Prometheus >= v2.27.0.
   *
   * @schema PrometheusSpec#enforcedLabelLimit
   */
  readonly enforcedLabelLimit?: number;

  /**
   * When defined, enforcedLabelNameLengthLimit specifies a global limit on the length
   * of labels name per sample. The value overrides any `spec.labelNameLengthLimit` set by
   * ServiceMonitor, PodMonitor, Probe objects unless `spec.labelNameLengthLimit` is
   * greater than zero and less than `spec.enforcedLabelNameLengthLimit`.
   *
   *
   * It requires Prometheus >= v2.27.0.
   *
   * @schema PrometheusSpec#enforcedLabelNameLengthLimit
   */
  readonly enforcedLabelNameLengthLimit?: number;

  /**
   * When not null, enforcedLabelValueLengthLimit defines a global limit on the length
   * of labels value per sample. The value overrides any `spec.labelValueLengthLimit` set by
   * ServiceMonitor, PodMonitor, Probe objects unless `spec.labelValueLengthLimit` is
   * greater than zero and less than `spec.enforcedLabelValueLengthLimit`.
   *
   *
   * It requires Prometheus >= v2.27.0.
   *
   * @schema PrometheusSpec#enforcedLabelValueLengthLimit
   */
  readonly enforcedLabelValueLengthLimit?: number;

  /**
   * When not empty, a label will be added to:
   *
   *
   * 1. All metrics scraped from `ServiceMonitor`, `PodMonitor`, `Probe` and `ScrapeConfig` objects.
   * 2. All metrics generated from recording rules defined in `PrometheusRule` objects.
   * 3. All alerts generated from alerting rules defined in `PrometheusRule` objects.
   * 4. All vector selectors of PromQL expressions defined in `PrometheusRule` objects.
   *
   *
   * The label will not added for objects referenced in `spec.excludedFromEnforcement`.
   *
   *
   * The label's name is this field's value.
   * The label's value is the namespace of the `ServiceMonitor`,
   * `PodMonitor`, `Probe`, `PrometheusRule` or `ScrapeConfig` object.
   *
   * @schema PrometheusSpec#enforcedNamespaceLabel
   */
  readonly enforcedNamespaceLabel?: string;

  /**
   * When defined, enforcedSampleLimit specifies a global limit on the number
   * of scraped samples that will be accepted. This overrides any
   * `spec.sampleLimit` set by ServiceMonitor, PodMonitor, Probe objects
   * unless `spec.sampleLimit` is greater than zero and less than
   * `spec.enforcedSampleLimit`.
   *
   *
   * It is meant to be used by admins to keep the overall number of
   * samples/series under a desired limit.
   *
   * @schema PrometheusSpec#enforcedSampleLimit
   */
  readonly enforcedSampleLimit?: number;

  /**
   * When defined, enforcedTargetLimit specifies a global limit on the number
   * of scraped targets. The value overrides any `spec.targetLimit` set by
   * ServiceMonitor, PodMonitor, Probe objects unless `spec.targetLimit` is
   * greater than zero and less than `spec.enforcedTargetLimit`.
   *
   *
   * It is meant to be used by admins to to keep the overall number of
   * targets under a desired limit.
   *
   * @schema PrometheusSpec#enforcedTargetLimit
   */
  readonly enforcedTargetLimit?: number;

  /**
   * Interval between rule evaluations.
   * Default: "30s"
   *
   * @schema PrometheusSpec#evaluationInterval
   */
  readonly evaluationInterval?: string;

  /**
   * List of references to PodMonitor, ServiceMonitor, Probe and PrometheusRule objects
   * to be excluded from enforcing a namespace label of origin.
   *
   *
   * It is only applicable if `spec.enforcedNamespaceLabel` set to true.
   *
   * @schema PrometheusSpec#excludedFromEnforcement
   */
  readonly excludedFromEnforcement?: PrometheusSpecExcludedFromEnforcement[];

  /**
   * Exemplars related settings that are runtime reloadable.
   * It requires to enable the `exemplar-storage` feature flag to be effective.
   *
   * @schema PrometheusSpec#exemplars
   */
  readonly exemplars?: PrometheusSpecExemplars;

  /**
   * The labels to add to any time series or alerts when communicating with
   * external systems (federation, remote storage, Alertmanager).
   * Labels defined by `spec.replicaExternalLabelName` and
   * `spec.prometheusExternalLabelName` take precedence over this list.
   *
   * @schema PrometheusSpec#externalLabels
   */
  readonly externalLabels?: { [key: string]: string };

  /**
   * The external URL under which the Prometheus service is externally
   * available. This is necessary to generate correct URLs (for instance if
   * Prometheus is accessible behind an Ingress resource).
   *
   * @schema PrometheusSpec#externalUrl
   */
  readonly externalUrl?: string;

  /**
   * Optional list of hosts and IPs that will be injected into the Pod's
   * hosts file if specified.
   *
   * @schema PrometheusSpec#hostAliases
   */
  readonly hostAliases?: PrometheusSpecHostAliases[];

  /**
   * Use the host's network namespace if true.
   *
   *
   * Make sure to understand the security implications if you want to enable
   * it (https://kubernetes.io/docs/concepts/configuration/overview/).
   *
   *
   * When hostNetwork is enabled, this will set the DNS policy to
   * `ClusterFirstWithHostNet` automatically.
   *
   * @schema PrometheusSpec#hostNetwork
   */
  readonly hostNetwork?: boolean;

  /**
   * When true, `spec.namespaceSelector` from all PodMonitor, ServiceMonitor
   * and Probe objects will be ignored. They will only discover targets
   * within the namespace of the PodMonitor, ServiceMonitor and Probe
   * object.
   *
   * @schema PrometheusSpec#ignoreNamespaceSelectors
   */
  readonly ignoreNamespaceSelectors?: boolean;

  /**
   * Container image name for Prometheus. If specified, it takes precedence
   * over the `spec.baseImage`, `spec.tag` and `spec.sha` fields.
   *
   *
   * Specifying `spec.version` is still necessary to ensure the Prometheus
   * Operator knows which version of Prometheus is being configured.
   *
   *
   * If neither `spec.image` nor `spec.baseImage` are defined, the operator
   * will use the latest upstream version of Prometheus available at the time
   * when the operator was released.
   *
   * @schema PrometheusSpec#image
   */
  readonly image?: string;

  /**
   * Image pull policy for the 'prometheus', 'init-config-reloader' and 'config-reloader' containers.
   * See https://kubernetes.io/docs/concepts/containers/images/#image-pull-policy for more details.
   *
   * @schema PrometheusSpec#imagePullPolicy
   */
  readonly imagePullPolicy?: PrometheusSpecImagePullPolicy;

  /**
   * An optional list of references to Secrets in the same namespace
   * to use for pulling images from registries.
   * See http://kubernetes.io/docs/user-guide/images#specifying-imagepullsecrets-on-a-pod
   *
   * @schema PrometheusSpec#imagePullSecrets
   */
  readonly imagePullSecrets?: PrometheusSpecImagePullSecrets[];

  /**
   * InitContainers allows injecting initContainers to the Pod definition. Those
   * can be used to e.g.  fetch secrets for injection into the Prometheus
   * configuration from external sources. Any errors during the execution of
   * an initContainer will lead to a restart of the Pod. More info:
   * https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
   * InitContainers described here modify an operator generated init
   * containers if they share the same name and modifications are done via a
   * strategic merge patch.
   *
   *
   * The names of init container name managed by the operator are:
   * * `init-config-reloader`.
   *
   *
   * Overriding init containers is entirely outside the scope of what the
   * maintainers will support and by doing so, you accept that this behaviour
   * may break at any time without notice.
   *
   * @schema PrometheusSpec#initContainers
   */
  readonly initContainers?: PrometheusSpecInitContainers[];

  /**
   * Per-scrape limit on the number of targets dropped by relabeling
   * that will be kept in memory. 0 means no limit.
   *
   *
   * It requires Prometheus >= v2.47.0.
   *
   * @schema PrometheusSpec#keepDroppedTargets
   */
  readonly keepDroppedTargets?: number;

  /**
   * Per-scrape limit on number of labels that will be accepted for a sample.
   * Only valid in Prometheus versions 2.45.0 and newer.
   *
   * @schema PrometheusSpec#labelLimit
   */
  readonly labelLimit?: number;

  /**
   * Per-scrape limit on length of labels name that will be accepted for a sample.
   * Only valid in Prometheus versions 2.45.0 and newer.
   *
   * @schema PrometheusSpec#labelNameLengthLimit
   */
  readonly labelNameLengthLimit?: number;

  /**
   * Per-scrape limit on length of labels value that will be accepted for a sample.
   * Only valid in Prometheus versions 2.45.0 and newer.
   *
   * @schema PrometheusSpec#labelValueLengthLimit
   */
  readonly labelValueLengthLimit?: number;

  /**
   * When true, the Prometheus server listens on the loopback address
   * instead of the Pod IP's address.
   *
   * @schema PrometheusSpec#listenLocal
   */
  readonly listenLocal?: boolean;

  /**
   * Log format for Log level for Prometheus and the config-reloader sidecar.
   *
   * @schema PrometheusSpec#logFormat
   */
  readonly logFormat?: PrometheusSpecLogFormat;

  /**
   * Log level for Prometheus and the config-reloader sidecar.
   *
   * @schema PrometheusSpec#logLevel
   */
  readonly logLevel?: PrometheusSpecLogLevel;

  /**
   * Defines the maximum time that the `prometheus` container's startup probe will wait before being considered failed. The startup probe will return success after the WAL replay is complete.
   * If set, the value should be greater than 60 (seconds). Otherwise it will be equal to 600 seconds (15 minutes).
   *
   * @schema PrometheusSpec#maximumStartupDurationSeconds
   */
  readonly maximumStartupDurationSeconds?: number;

  /**
   * Minimum number of seconds for which a newly created Pod should be ready
   * without any of its container crashing for it to be considered available.
   * Defaults to 0 (pod will be considered available as soon as it is ready)
   *
   *
   * This is an alpha field from kubernetes 1.22 until 1.24 which requires
   * enabling the StatefulSetMinReadySeconds feature gate.
   *
   * @default 0 (pod will be considered available as soon as it is ready)
   * @schema PrometheusSpec#minReadySeconds
   */
  readonly minReadySeconds?: number;

  /**
   * Defines on which Nodes the Pods are scheduled.
   *
   * @schema PrometheusSpec#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * When true, Prometheus resolves label conflicts by renaming the labels in
   * the scraped data to "exported_<label value>" for all targets created
   * from service and pod monitors.
   * Otherwise the HonorLabels field of the service or pod monitor applies.
   *
   * @schema PrometheusSpec#overrideHonorLabels
   */
  readonly overrideHonorLabels?: boolean;

  /**
   * When true, Prometheus ignores the timestamps for all the targets created
   * from service and pod monitors.
   * Otherwise the HonorTimestamps field of the service or pod monitor applies.
   *
   * @schema PrometheusSpec#overrideHonorTimestamps
   */
  readonly overrideHonorTimestamps?: boolean;

  /**
   * When a Prometheus deployment is paused, no actions except for deletion
   * will be performed on the underlying objects.
   *
   * @schema PrometheusSpec#paused
   */
  readonly paused?: boolean;

  /**
   * The field controls if and how PVCs are deleted during the lifecycle of a StatefulSet.
   * The default behavior is all PVCs are retained.
   * This is an alpha field from kubernetes 1.23 until 1.26 and a beta field from 1.26.
   * It requires enabling the StatefulSetAutoDeletePVC feature gate.
   *
   * @schema PrometheusSpec#persistentVolumeClaimRetentionPolicy
   */
  readonly persistentVolumeClaimRetentionPolicy?: PrometheusSpecPersistentVolumeClaimRetentionPolicy;

  /**
   * PodMetadata configures labels and annotations which are propagated to the Prometheus pods.
   *
   *
   * The following items are reserved and cannot be overridden:
   * * "prometheus" label, set to the name of the Prometheus object.
   * * "app.kubernetes.io/instance" label, set to the name of the Prometheus object.
   * * "app.kubernetes.io/managed-by" label, set to "prometheus-operator".
   * * "app.kubernetes.io/name" label, set to "prometheus".
   * * "app.kubernetes.io/version" label, set to the Prometheus version.
   * * "operator.prometheus.io/name" label, set to the name of the Prometheus object.
   * * "operator.prometheus.io/shard" label, set to the shard number of the Prometheus object.
   * * "kubectl.kubernetes.io/default-container" annotation, set to "prometheus".
   *
   * @schema PrometheusSpec#podMetadata
   */
  readonly podMetadata?: PrometheusSpecPodMetadata;

  /**
   * Namespaces to match for PodMonitors discovery. An empty label selector
   * matches all namespaces. A null label selector matches the current
   * namespace only.
   *
   * @schema PrometheusSpec#podMonitorNamespaceSelector
   */
  readonly podMonitorNamespaceSelector?: PrometheusSpecPodMonitorNamespaceSelector;

  /**
   * PodMonitors to be selected for target discovery. An empty label selector
   * matches all objects. A null label selector matches no objects.
   *
   *
   * If `spec.serviceMonitorSelector`, `spec.podMonitorSelector`, `spec.probeSelector`
   * and `spec.scrapeConfigSelector` are null, the Prometheus configuration is unmanaged.
   * The Prometheus operator will ensure that the Prometheus configuration's
   * Secret exists, but it is the responsibility of the user to provide the raw
   * gzipped Prometheus configuration under the `prometheus.yaml.gz` key.
   * This behavior is *deprecated* and will be removed in the next major version
   * of the custom resource definition. It is recommended to use
   * `spec.additionalScrapeConfigs` instead.
   *
   * @schema PrometheusSpec#podMonitorSelector
   */
  readonly podMonitorSelector?: PrometheusSpecPodMonitorSelector;

  /**
   * PodTargetLabels are appended to the `spec.podTargetLabels` field of all
   * PodMonitor and ServiceMonitor objects.
   *
   * @schema PrometheusSpec#podTargetLabels
   */
  readonly podTargetLabels?: string[];

  /**
   * Port name used for the pods and governing service.
   * Default: "web"
   *
   * @schema PrometheusSpec#portName
   */
  readonly portName?: string;

  /**
   * Priority class assigned to the Pods.
   *
   * @schema PrometheusSpec#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * Namespaces to match for Probe discovery. An empty label
   * selector matches all namespaces. A null label selector matches the
   * current namespace only.
   *
   * @schema PrometheusSpec#probeNamespaceSelector
   */
  readonly probeNamespaceSelector?: PrometheusSpecProbeNamespaceSelector;

  /**
   * Probes to be selected for target discovery. An empty label selector
   * matches all objects. A null label selector matches no objects.
   *
   *
   * If `spec.serviceMonitorSelector`, `spec.podMonitorSelector`, `spec.probeSelector`
   * and `spec.scrapeConfigSelector` are null, the Prometheus configuration is unmanaged.
   * The Prometheus operator will ensure that the Prometheus configuration's
   * Secret exists, but it is the responsibility of the user to provide the raw
   * gzipped Prometheus configuration under the `prometheus.yaml.gz` key.
   * This behavior is *deprecated* and will be removed in the next major version
   * of the custom resource definition. It is recommended to use
   * `spec.additionalScrapeConfigs` instead.
   *
   * @schema PrometheusSpec#probeSelector
   */
  readonly probeSelector?: PrometheusSpecProbeSelector;

  /**
   * Name of Prometheus external label used to denote the Prometheus instance
   * name. The external label will _not_ be added when the field is set to
   * the empty string (`""`).
   *
   *
   * Default: "prometheus"
   *
   * @schema PrometheusSpec#prometheusExternalLabelName
   */
  readonly prometheusExternalLabelName?: string;

  /**
   * Defines the list of PrometheusRule objects to which the namespace label
   * enforcement doesn't apply.
   * This is only relevant when `spec.enforcedNamespaceLabel` is set to true.
   * Deprecated: use `spec.excludedFromEnforcement` instead.
   *
   * @schema PrometheusSpec#prometheusRulesExcludedFromEnforce
   */
  readonly prometheusRulesExcludedFromEnforce?: PrometheusSpecPrometheusRulesExcludedFromEnforce[];

  /**
   * QuerySpec defines the configuration of the Promethus query service.
   *
   * @schema PrometheusSpec#query
   */
  readonly query?: PrometheusSpecQuery;

  /**
   * queryLogFile specifies where the file to which PromQL queries are logged.
   *
   *
   * If the filename has an empty path, e.g. 'query.log', The Prometheus Pods
   * will mount the file into an emptyDir volume at `/var/log/prometheus`.
   * If a full path is provided, e.g. '/var/log/prometheus/query.log', you
   * must mount a volume in the specified directory and it must be writable.
   * This is because the prometheus container runs with a read-only root
   * filesystem for security reasons.
   * Alternatively, the location can be set to a standard I/O stream, e.g.
   * `/dev/stdout`, to log query information to the default Prometheus log
   * stream.
   *
   * @schema PrometheusSpec#queryLogFile
   */
  readonly queryLogFile?: string;

  /**
   * Defines the strategy used to reload the Prometheus configuration.
   * If not specified, the configuration is reloaded using the /-/reload HTTP endpoint.
   *
   * @schema PrometheusSpec#reloadStrategy
   */
  readonly reloadStrategy?: PrometheusSpecReloadStrategy;

  /**
   * Defines the list of remote read configurations.
   *
   * @schema PrometheusSpec#remoteRead
   */
  readonly remoteRead?: PrometheusSpecRemoteRead[];

  /**
   * Defines the list of remote write configurations.
   *
   * @schema PrometheusSpec#remoteWrite
   */
  readonly remoteWrite?: PrometheusSpecRemoteWrite[];

  /**
   * Name of Prometheus external label used to denote the replica name.
   * The external label will _not_ be added when the field is set to the
   * empty string (`""`).
   *
   *
   * Default: "prometheus_replica"
   *
   * @schema PrometheusSpec#replicaExternalLabelName
   */
  readonly replicaExternalLabelName?: string;

  /**
   * Number of replicas of each shard to deploy for a Prometheus deployment.
   * `spec.replicas` multiplied by `spec.shards` is the total number of Pods
   * created.
   *
   *
   * Default: 1
   *
   * @schema PrometheusSpec#replicas
   */
  readonly replicas?: number;

  /**
   * Defines the resources requests and limits of the 'prometheus' container.
   *
   * @schema PrometheusSpec#resources
   */
  readonly resources?: PrometheusSpecResources;

  /**
   * How long to retain the Prometheus data.
   *
   *
   * Default: "24h" if `spec.retention` and `spec.retentionSize` are empty.
   *
   * @schema PrometheusSpec#retention
   */
  readonly retention?: string;

  /**
   * Maximum number of bytes used by the Prometheus data.
   *
   * @schema PrometheusSpec#retentionSize
   */
  readonly retentionSize?: string;

  /**
   * The route prefix Prometheus registers HTTP handlers for.
   *
   *
   * This is useful when using `spec.externalURL`, and a proxy is rewriting
   * HTTP routes of a request, and the actual ExternalURL is still true, but
   * the server serves requests under a different route prefix. For example
   * for use with `kubectl proxy`.
   *
   * @schema PrometheusSpec#routePrefix
   */
  readonly routePrefix?: string;

  /**
   * Namespaces to match for PrometheusRule discovery. An empty label selector
   * matches all namespaces. A null label selector matches the current
   * namespace only.
   *
   * @schema PrometheusSpec#ruleNamespaceSelector
   */
  readonly ruleNamespaceSelector?: PrometheusSpecRuleNamespaceSelector;

  /**
   * PrometheusRule objects to be selected for rule evaluation. An empty
   * label selector matches all objects. A null label selector matches no
   * objects.
   *
   * @schema PrometheusSpec#ruleSelector
   */
  readonly ruleSelector?: PrometheusSpecRuleSelector;

  /**
   * Defines the configuration of the Prometheus rules' engine.
   *
   * @schema PrometheusSpec#rules
   */
  readonly rules?: PrometheusSpecRules;

  /**
   * SampleLimit defines per-scrape limit on number of scraped samples that will be accepted.
   * Only valid in Prometheus versions 2.45.0 and newer.
   *
   * @schema PrometheusSpec#sampleLimit
   */
  readonly sampleLimit?: number;

  /**
   * List of scrape classes to expose to scraping objects such as
   * PodMonitors, ServiceMonitors, Probes and ScrapeConfigs.
   *
   *
   * This is an *experimental feature*, it may change in any upcoming release
   * in a breaking way.
   *
   * @schema PrometheusSpec#scrapeClasses
   */
  readonly scrapeClasses?: PrometheusSpecScrapeClasses[];

  /**
   * Namespaces to match for ScrapeConfig discovery. An empty label selector
   * matches all namespaces. A null label selector matches the current
   * namespace only.
   *
   *
   * Note that the ScrapeConfig custom resource definition is currently at Alpha level.
   *
   * @schema PrometheusSpec#scrapeConfigNamespaceSelector
   */
  readonly scrapeConfigNamespaceSelector?: PrometheusSpecScrapeConfigNamespaceSelector;

  /**
   * ScrapeConfigs to be selected for target discovery. An empty label
   * selector matches all objects. A null label selector matches no objects.
   *
   *
   * If `spec.serviceMonitorSelector`, `spec.podMonitorSelector`, `spec.probeSelector`
   * and `spec.scrapeConfigSelector` are null, the Prometheus configuration is unmanaged.
   * The Prometheus operator will ensure that the Prometheus configuration's
   * Secret exists, but it is the responsibility of the user to provide the raw
   * gzipped Prometheus configuration under the `prometheus.yaml.gz` key.
   * This behavior is *deprecated* and will be removed in the next major version
   * of the custom resource definition. It is recommended to use
   * `spec.additionalScrapeConfigs` instead.
   *
   *
   * Note that the ScrapeConfig custom resource definition is currently at Alpha level.
   *
   * @schema PrometheusSpec#scrapeConfigSelector
   */
  readonly scrapeConfigSelector?: PrometheusSpecScrapeConfigSelector;

  /**
   * Interval between consecutive scrapes.
   *
   *
   * Default: "30s"
   *
   * @schema PrometheusSpec#scrapeInterval
   */
  readonly scrapeInterval?: string;

  /**
   * The protocols to negotiate during a scrape. It tells clients the
   * protocols supported by Prometheus in order of preference (from most to least preferred).
   *
   *
   * If unset, Prometheus uses its default value.
   *
   *
   * It requires Prometheus >= v2.49.0.
   *
   * @schema PrometheusSpec#scrapeProtocols
   */
  readonly scrapeProtocols?: PrometheusSpecScrapeProtocols[];

  /**
   * Number of seconds to wait until a scrape request times out.
   *
   * @schema PrometheusSpec#scrapeTimeout
   */
  readonly scrapeTimeout?: string;

  /**
   * Secrets is a list of Secrets in the same namespace as the Prometheus
   * object, which shall be mounted into the Prometheus Pods.
   * Each Secret is added to the StatefulSet definition as a volume named `secret-<secret-name>`.
   * The Secrets are mounted into /etc/prometheus/secrets/<secret-name> in the 'prometheus' container.
   *
   * @schema PrometheusSpec#secrets
   */
  readonly secrets?: string[];

  /**
   * SecurityContext holds pod-level security attributes and common container settings.
   * This defaults to the default PodSecurityContext.
   *
   * @schema PrometheusSpec#securityContext
   */
  readonly securityContext?: PrometheusSpecSecurityContext;

  /**
   * ServiceAccountName is the name of the ServiceAccount to use to run the
   * Prometheus Pods.
   *
   * @schema PrometheusSpec#serviceAccountName
   */
  readonly serviceAccountName?: string;

  /**
   * Namespaces to match for ServicedMonitors discovery. An empty label selector
   * matches all namespaces. A null label selector matches the current
   * namespace only.
   *
   * @schema PrometheusSpec#serviceMonitorNamespaceSelector
   */
  readonly serviceMonitorNamespaceSelector?: PrometheusSpecServiceMonitorNamespaceSelector;

  /**
   * ServiceMonitors to be selected for target discovery. An empty label
   * selector matches all objects. A null label selector matches no objects.
   *
   *
   * If `spec.serviceMonitorSelector`, `spec.podMonitorSelector`, `spec.probeSelector`
   * and `spec.scrapeConfigSelector` are null, the Prometheus configuration is unmanaged.
   * The Prometheus operator will ensure that the Prometheus configuration's
   * Secret exists, but it is the responsibility of the user to provide the raw
   * gzipped Prometheus configuration under the `prometheus.yaml.gz` key.
   * This behavior is *deprecated* and will be removed in the next major version
   * of the custom resource definition. It is recommended to use
   * `spec.additionalScrapeConfigs` instead.
   *
   * @schema PrometheusSpec#serviceMonitorSelector
   */
  readonly serviceMonitorSelector?: PrometheusSpecServiceMonitorSelector;

  /**
   * Deprecated: use 'spec.image' instead. The image's digest can be specified as part of the image name.
   *
   * @schema PrometheusSpec#sha
   */
  readonly sha?: string;

  /**
   * Number of shards to distribute targets onto. `spec.replicas`
   * multiplied by `spec.shards` is the total number of Pods created.
   *
   *
   * Note that scaling down shards will not reshard data onto remaining
   * instances, it must be manually moved. Increasing shards will not reshard
   * data either but it will continue to be available from the same
   * instances. To query globally, use Thanos sidecar and Thanos querier or
   * remote write data to a central location.
   *
   *
   * Sharding is performed on the content of the `__address__` target meta-label
   * for PodMonitors and ServiceMonitors and `__param_target__` for Probes.
   *
   *
   * Default: 1
   *
   * @schema PrometheusSpec#shards
   */
  readonly shards?: number;

  /**
   * Storage defines the storage used by Prometheus.
   *
   * @schema PrometheusSpec#storage
   */
  readonly storage?: PrometheusSpecStorage;

  /**
   * Deprecated: use 'spec.image' instead. The image's tag can be specified as part of the image name.
   *
   * @schema PrometheusSpec#tag
   */
  readonly tag?: string;

  /**
   * TargetLimit defines a limit on the number of scraped targets that will be accepted.
   * Only valid in Prometheus versions 2.45.0 and newer.
   *
   * @schema PrometheusSpec#targetLimit
   */
  readonly targetLimit?: number;

  /**
   * Defines the configuration of the optional Thanos sidecar.
   *
   * @schema PrometheusSpec#thanos
   */
  readonly thanos?: PrometheusSpecThanos;

  /**
   * Defines the Pods' tolerations if specified.
   *
   * @schema PrometheusSpec#tolerations
   */
  readonly tolerations?: PrometheusSpecTolerations[];

  /**
   * Defines the pod's topology spread constraints if specified.
   *
   * @schema PrometheusSpec#topologySpreadConstraints
   */
  readonly topologySpreadConstraints?: PrometheusSpecTopologySpreadConstraints[];

  /**
   * TracingConfig configures tracing in Prometheus.
   *
   *
   * This is an *experimental feature*, it may change in any upcoming release
   * in a breaking way.
   *
   * @schema PrometheusSpec#tracingConfig
   */
  readonly tracingConfig?: PrometheusSpecTracingConfig;

  /**
   * Defines the runtime reloadable configuration of the timeseries database
   * (TSDB).
   *
   * @schema PrometheusSpec#tsdb
   */
  readonly tsdb?: PrometheusSpecTsdb;

  /**
   * Version of Prometheus being deployed. The operator uses this information
   * to generate the Prometheus StatefulSet + configuration files.
   *
   *
   * If not specified, the operator assumes the latest upstream version of
   * Prometheus available at the time when the version of the operator was
   * released.
   *
   * @schema PrometheusSpec#version
   */
  readonly version?: string;

  /**
   * VolumeMounts allows the configuration of additional VolumeMounts.
   *
   *
   * VolumeMounts will be appended to other VolumeMounts in the 'prometheus'
   * container, that are generated as a result of StorageSpec objects.
   *
   * @schema PrometheusSpec#volumeMounts
   */
  readonly volumeMounts?: PrometheusSpecVolumeMounts[];

  /**
   * Volumes allows the configuration of additional volumes on the output
   * StatefulSet definition. Volumes specified will be appended to other
   * volumes that are generated as a result of StorageSpec objects.
   *
   * @schema PrometheusSpec#volumes
   */
  readonly volumes?: PrometheusSpecVolumes[];

  /**
   * Configures compression of the write-ahead log (WAL) using Snappy.
   *
   *
   * WAL compression is enabled by default for Prometheus >= 2.20.0
   *
   *
   * Requires Prometheus v2.11.0 and above.
   *
   * @schema PrometheusSpec#walCompression
   */
  readonly walCompression?: boolean;

  /**
   * Defines the configuration of the Prometheus web server.
   *
   * @schema PrometheusSpec#web
   */
  readonly web?: PrometheusSpecWeb;

}

/**
 * Converts an object of type 'PrometheusSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpec(obj: PrometheusSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalAlertManagerConfigs': toJson_PrometheusSpecAdditionalAlertManagerConfigs(obj.additionalAlertManagerConfigs),
    'additionalAlertRelabelConfigs': toJson_PrometheusSpecAdditionalAlertRelabelConfigs(obj.additionalAlertRelabelConfigs),
    'additionalArgs': obj.additionalArgs?.map(y => toJson_PrometheusSpecAdditionalArgs(y)),
    'additionalScrapeConfigs': toJson_PrometheusSpecAdditionalScrapeConfigs(obj.additionalScrapeConfigs),
    'affinity': toJson_PrometheusSpecAffinity(obj.affinity),
    'alerting': toJson_PrometheusSpecAlerting(obj.alerting),
    'allowOverlappingBlocks': obj.allowOverlappingBlocks,
    'apiserverConfig': toJson_PrometheusSpecApiserverConfig(obj.apiserverConfig),
    'arbitraryFSAccessThroughSMs': toJson_PrometheusSpecArbitraryFsAccessThroughSMs(obj.arbitraryFsAccessThroughSMs),
    'automountServiceAccountToken': obj.automountServiceAccountToken,
    'baseImage': obj.baseImage,
    'bodySizeLimit': obj.bodySizeLimit,
    'configMaps': obj.configMaps?.map(y => y),
    'containers': obj.containers?.map(y => toJson_PrometheusSpecContainers(y)),
    'disableCompaction': obj.disableCompaction,
    'enableAdminAPI': obj.enableAdminApi,
    'enableFeatures': obj.enableFeatures?.map(y => y),
    'enableRemoteWriteReceiver': obj.enableRemoteWriteReceiver,
    'enforcedBodySizeLimit': obj.enforcedBodySizeLimit,
    'enforcedKeepDroppedTargets': obj.enforcedKeepDroppedTargets,
    'enforcedLabelLimit': obj.enforcedLabelLimit,
    'enforcedLabelNameLengthLimit': obj.enforcedLabelNameLengthLimit,
    'enforcedLabelValueLengthLimit': obj.enforcedLabelValueLengthLimit,
    'enforcedNamespaceLabel': obj.enforcedNamespaceLabel,
    'enforcedSampleLimit': obj.enforcedSampleLimit,
    'enforcedTargetLimit': obj.enforcedTargetLimit,
    'evaluationInterval': obj.evaluationInterval,
    'excludedFromEnforcement': obj.excludedFromEnforcement?.map(y => toJson_PrometheusSpecExcludedFromEnforcement(y)),
    'exemplars': toJson_PrometheusSpecExemplars(obj.exemplars),
    'externalLabels': ((obj.externalLabels) === undefined) ? undefined : (Object.entries(obj.externalLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'externalUrl': obj.externalUrl,
    'hostAliases': obj.hostAliases?.map(y => toJson_PrometheusSpecHostAliases(y)),
    'hostNetwork': obj.hostNetwork,
    'ignoreNamespaceSelectors': obj.ignoreNamespaceSelectors,
    'image': obj.image,
    'imagePullPolicy': obj.imagePullPolicy,
    'imagePullSecrets': obj.imagePullSecrets?.map(y => toJson_PrometheusSpecImagePullSecrets(y)),
    'initContainers': obj.initContainers?.map(y => toJson_PrometheusSpecInitContainers(y)),
    'keepDroppedTargets': obj.keepDroppedTargets,
    'labelLimit': obj.labelLimit,
    'labelNameLengthLimit': obj.labelNameLengthLimit,
    'labelValueLengthLimit': obj.labelValueLengthLimit,
    'listenLocal': obj.listenLocal,
    'logFormat': obj.logFormat,
    'logLevel': obj.logLevel,
    'maximumStartupDurationSeconds': obj.maximumStartupDurationSeconds,
    'minReadySeconds': obj.minReadySeconds,
    'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'overrideHonorLabels': obj.overrideHonorLabels,
    'overrideHonorTimestamps': obj.overrideHonorTimestamps,
    'paused': obj.paused,
    'persistentVolumeClaimRetentionPolicy': toJson_PrometheusSpecPersistentVolumeClaimRetentionPolicy(obj.persistentVolumeClaimRetentionPolicy),
    'podMetadata': toJson_PrometheusSpecPodMetadata(obj.podMetadata),
    'podMonitorNamespaceSelector': toJson_PrometheusSpecPodMonitorNamespaceSelector(obj.podMonitorNamespaceSelector),
    'podMonitorSelector': toJson_PrometheusSpecPodMonitorSelector(obj.podMonitorSelector),
    'podTargetLabels': obj.podTargetLabels?.map(y => y),
    'portName': obj.portName,
    'priorityClassName': obj.priorityClassName,
    'probeNamespaceSelector': toJson_PrometheusSpecProbeNamespaceSelector(obj.probeNamespaceSelector),
    'probeSelector': toJson_PrometheusSpecProbeSelector(obj.probeSelector),
    'prometheusExternalLabelName': obj.prometheusExternalLabelName,
    'prometheusRulesExcludedFromEnforce': obj.prometheusRulesExcludedFromEnforce?.map(y => toJson_PrometheusSpecPrometheusRulesExcludedFromEnforce(y)),
    'query': toJson_PrometheusSpecQuery(obj.query),
    'queryLogFile': obj.queryLogFile,
    'reloadStrategy': obj.reloadStrategy,
    'remoteRead': obj.remoteRead?.map(y => toJson_PrometheusSpecRemoteRead(y)),
    'remoteWrite': obj.remoteWrite?.map(y => toJson_PrometheusSpecRemoteWrite(y)),
    'replicaExternalLabelName': obj.replicaExternalLabelName,
    'replicas': obj.replicas,
    'resources': toJson_PrometheusSpecResources(obj.resources),
    'retention': obj.retention,
    'retentionSize': obj.retentionSize,
    'routePrefix': obj.routePrefix,
    'ruleNamespaceSelector': toJson_PrometheusSpecRuleNamespaceSelector(obj.ruleNamespaceSelector),
    'ruleSelector': toJson_PrometheusSpecRuleSelector(obj.ruleSelector),
    'rules': toJson_PrometheusSpecRules(obj.rules),
    'sampleLimit': obj.sampleLimit,
    'scrapeClasses': obj.scrapeClasses?.map(y => toJson_PrometheusSpecScrapeClasses(y)),
    'scrapeConfigNamespaceSelector': toJson_PrometheusSpecScrapeConfigNamespaceSelector(obj.scrapeConfigNamespaceSelector),
    'scrapeConfigSelector': toJson_PrometheusSpecScrapeConfigSelector(obj.scrapeConfigSelector),
    'scrapeInterval': obj.scrapeInterval,
    'scrapeProtocols': obj.scrapeProtocols?.map(y => y),
    'scrapeTimeout': obj.scrapeTimeout,
    'secrets': obj.secrets?.map(y => y),
    'securityContext': toJson_PrometheusSpecSecurityContext(obj.securityContext),
    'serviceAccountName': obj.serviceAccountName,
    'serviceMonitorNamespaceSelector': toJson_PrometheusSpecServiceMonitorNamespaceSelector(obj.serviceMonitorNamespaceSelector),
    'serviceMonitorSelector': toJson_PrometheusSpecServiceMonitorSelector(obj.serviceMonitorSelector),
    'sha': obj.sha,
    'shards': obj.shards,
    'storage': toJson_PrometheusSpecStorage(obj.storage),
    'tag': obj.tag,
    'targetLimit': obj.targetLimit,
    'thanos': toJson_PrometheusSpecThanos(obj.thanos),
    'tolerations': obj.tolerations?.map(y => toJson_PrometheusSpecTolerations(y)),
    'topologySpreadConstraints': obj.topologySpreadConstraints?.map(y => toJson_PrometheusSpecTopologySpreadConstraints(y)),
    'tracingConfig': toJson_PrometheusSpecTracingConfig(obj.tracingConfig),
    'tsdb': toJson_PrometheusSpecTsdb(obj.tsdb),
    'version': obj.version,
    'volumeMounts': obj.volumeMounts?.map(y => toJson_PrometheusSpecVolumeMounts(y)),
    'volumes': obj.volumes?.map(y => toJson_PrometheusSpecVolumes(y)),
    'walCompression': obj.walCompression,
    'web': toJson_PrometheusSpecWeb(obj.web),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AdditionalAlertManagerConfigs specifies a key of a Secret containing
 * additional Prometheus Alertmanager configurations. The Alertmanager
 * configurations are appended to the configuration generated by the
 * Prometheus Operator. They must be formatted according to the official
 * Prometheus documentation:
 *
 *
 * https://prometheus.io/docs/prometheus/latest/configuration/configuration/#alertmanager_config
 *
 *
 * The user is responsible for making sure that the configurations are valid
 *
 *
 * Note that using this feature may expose the possibility to break
 * upgrades of Prometheus. It is advised to review Prometheus release notes
 * to ensure that no incompatible AlertManager configs are going to break
 * Prometheus after the upgrade.
 *
 * @schema PrometheusSpecAdditionalAlertManagerConfigs
 */
export interface PrometheusSpecAdditionalAlertManagerConfigs {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecAdditionalAlertManagerConfigs#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecAdditionalAlertManagerConfigs#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecAdditionalAlertManagerConfigs#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecAdditionalAlertManagerConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAdditionalAlertManagerConfigs(obj: PrometheusSpecAdditionalAlertManagerConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AdditionalAlertRelabelConfigs specifies a key of a Secret containing
 * additional Prometheus alert relabel configurations. The alert relabel
 * configurations are appended to the configuration generated by the
 * Prometheus Operator. They must be formatted according to the official
 * Prometheus documentation:
 *
 *
 * https://prometheus.io/docs/prometheus/latest/configuration/configuration/#alert_relabel_configs
 *
 *
 * The user is responsible for making sure that the configurations are valid
 *
 *
 * Note that using this feature may expose the possibility to break
 * upgrades of Prometheus. It is advised to review Prometheus release notes
 * to ensure that no incompatible alert relabel configs are going to break
 * Prometheus after the upgrade.
 *
 * @schema PrometheusSpecAdditionalAlertRelabelConfigs
 */
export interface PrometheusSpecAdditionalAlertRelabelConfigs {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecAdditionalAlertRelabelConfigs#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecAdditionalAlertRelabelConfigs#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecAdditionalAlertRelabelConfigs#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecAdditionalAlertRelabelConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAdditionalAlertRelabelConfigs(obj: PrometheusSpecAdditionalAlertRelabelConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Argument as part of the AdditionalArgs list.
 *
 * @schema PrometheusSpecAdditionalArgs
 */
export interface PrometheusSpecAdditionalArgs {
  /**
   * Name of the argument, e.g. "scrape.discovery-reload-interval".
   *
   * @schema PrometheusSpecAdditionalArgs#name
   */
  readonly name: string;

  /**
   * Argument value, e.g. 30s. Can be empty for name-only arguments (e.g. --storage.tsdb.no-lockfile)
   *
   * @schema PrometheusSpecAdditionalArgs#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'PrometheusSpecAdditionalArgs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAdditionalArgs(obj: PrometheusSpecAdditionalArgs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AdditionalScrapeConfigs allows specifying a key of a Secret containing
 * additional Prometheus scrape configurations. Scrape configurations
 * specified are appended to the configurations generated by the Prometheus
 * Operator. Job configurations specified must have the form as specified
 * in the official Prometheus documentation:
 * https://prometheus.io/docs/prometheus/latest/configuration/configuration/#scrape_config.
 * As scrape configs are appended, the user is responsible to make sure it
 * is valid. Note that using this feature may expose the possibility to
 * break upgrades of Prometheus. It is advised to review Prometheus release
 * notes to ensure that no incompatible scrape configs are going to break
 * Prometheus after the upgrade.
 *
 * @schema PrometheusSpecAdditionalScrapeConfigs
 */
export interface PrometheusSpecAdditionalScrapeConfigs {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecAdditionalScrapeConfigs#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecAdditionalScrapeConfigs#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecAdditionalScrapeConfigs#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecAdditionalScrapeConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAdditionalScrapeConfigs(obj: PrometheusSpecAdditionalScrapeConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Defines the Pods' affinity scheduling rules if specified.
 *
 * @schema PrometheusSpecAffinity
 */
export interface PrometheusSpecAffinity {
  /**
   * Describes node affinity scheduling rules for the pod.
   *
   * @schema PrometheusSpecAffinity#nodeAffinity
   */
  readonly nodeAffinity?: PrometheusSpecAffinityNodeAffinity;

  /**
   * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
   *
   * @schema PrometheusSpecAffinity#podAffinity
   */
  readonly podAffinity?: PrometheusSpecAffinityPodAffinity;

  /**
   * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
   *
   * @schema PrometheusSpecAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: PrometheusSpecAffinityPodAntiAffinity;

}

/**
 * Converts an object of type 'PrometheusSpecAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAffinity(obj: PrometheusSpecAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeAffinity': toJson_PrometheusSpecAffinityNodeAffinity(obj.nodeAffinity),
    'podAffinity': toJson_PrometheusSpecAffinityPodAffinity(obj.podAffinity),
    'podAntiAffinity': toJson_PrometheusSpecAffinityPodAntiAffinity(obj.podAntiAffinity),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Defines the settings related to Alertmanager.
 *
 * @schema PrometheusSpecAlerting
 */
export interface PrometheusSpecAlerting {
  /**
   * AlertmanagerEndpoints Prometheus should fire alerts against.
   *
   * @schema PrometheusSpecAlerting#alertmanagers
   */
  readonly alertmanagers: PrometheusSpecAlertingAlertmanagers[];

}

/**
 * Converts an object of type 'PrometheusSpecAlerting' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAlerting(obj: PrometheusSpecAlerting | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alertmanagers': obj.alertmanagers?.map(y => toJson_PrometheusSpecAlertingAlertmanagers(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * APIServerConfig allows specifying a host and auth methods to access the
 * Kuberntees API server.
 * If null, Prometheus is assumed to run inside of the cluster: it will
 * discover the API servers automatically and use the Pod's CA certificate
 * and bearer token file at /var/run/secrets/kubernetes.io/serviceaccount/.
 *
 * @schema PrometheusSpecApiserverConfig
 */
export interface PrometheusSpecApiserverConfig {
  /**
   * Authorization section for the API server.
   *
   *
   * Cannot be set at the same time as `basicAuth`, `bearerToken`, or
   * `bearerTokenFile`.
   *
   * @schema PrometheusSpecApiserverConfig#authorization
   */
  readonly authorization?: PrometheusSpecApiserverConfigAuthorization;

  /**
   * BasicAuth configuration for the API server.
   *
   *
   * Cannot be set at the same time as `authorization`, `bearerToken`, or
   * `bearerTokenFile`.
   *
   * @schema PrometheusSpecApiserverConfig#basicAuth
   */
  readonly basicAuth?: PrometheusSpecApiserverConfigBasicAuth;

  /**
   * *Warning: this field shouldn't be used because the token value appears
   * in clear-text. Prefer using `authorization`.*
   *
   *
   * Deprecated: this will be removed in a future release.
   *
   * @schema PrometheusSpecApiserverConfig#bearerToken
   */
  readonly bearerToken?: string;

  /**
   * File to read bearer token for accessing apiserver.
   *
   *
   * Cannot be set at the same time as `basicAuth`, `authorization`, or `bearerToken`.
   *
   *
   * Deprecated: this will be removed in a future release. Prefer using `authorization`.
   *
   * @schema PrometheusSpecApiserverConfig#bearerTokenFile
   */
  readonly bearerTokenFile?: string;

  /**
   * Kubernetes API address consisting of a hostname or IP address followed
   * by an optional port number.
   *
   * @schema PrometheusSpecApiserverConfig#host
   */
  readonly host: string;

  /**
   * TLS Config to use for the API server.
   *
   * @schema PrometheusSpecApiserverConfig#tlsConfig
   */
  readonly tlsConfig?: PrometheusSpecApiserverConfigTlsConfig;

}

/**
 * Converts an object of type 'PrometheusSpecApiserverConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecApiserverConfig(obj: PrometheusSpecApiserverConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authorization': toJson_PrometheusSpecApiserverConfigAuthorization(obj.authorization),
    'basicAuth': toJson_PrometheusSpecApiserverConfigBasicAuth(obj.basicAuth),
    'bearerToken': obj.bearerToken,
    'bearerTokenFile': obj.bearerTokenFile,
    'host': obj.host,
    'tlsConfig': toJson_PrometheusSpecApiserverConfigTlsConfig(obj.tlsConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * When true, ServiceMonitor, PodMonitor and Probe object are forbidden to
 * reference arbitrary files on the file system of the 'prometheus'
 * container.
 * When a ServiceMonitor's endpoint specifies a `bearerTokenFile` value
 * (e.g.  '/var/run/secrets/kubernetes.io/serviceaccount/token'), a
 * malicious target can get access to the Prometheus service account's
 * token in the Prometheus' scrape request. Setting
 * `spec.arbitraryFSAccessThroughSM` to 'true' would prevent the attack.
 * Users should instead provide the credentials using the
 * `spec.bearerTokenSecret` field.
 *
 * @schema PrometheusSpecArbitraryFsAccessThroughSMs
 */
export interface PrometheusSpecArbitraryFsAccessThroughSMs {
  /**
   * @schema PrometheusSpecArbitraryFsAccessThroughSMs#deny
   */
  readonly deny?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecArbitraryFsAccessThroughSMs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecArbitraryFsAccessThroughSMs(obj: PrometheusSpecArbitraryFsAccessThroughSMs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deny': obj.deny,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A single application container that you want to run within a pod.
 *
 * @schema PrometheusSpecContainers
 */
export interface PrometheusSpecContainers {
  /**
   * Arguments to the entrypoint.
   * The container image's CMD is used if this is not provided.
   * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
   * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
   * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
   * of whether the variable exists or not. Cannot be updated.
   * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema PrometheusSpecContainers#args
   */
  readonly args?: string[];

  /**
   * Entrypoint array. Not executed within a shell.
   * The container image's ENTRYPOINT is used if this is not provided.
   * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
   * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
   * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
   * of whether the variable exists or not. Cannot be updated.
   * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema PrometheusSpecContainers#command
   */
  readonly command?: string[];

  /**
   * List of environment variables to set in the container.
   * Cannot be updated.
   *
   * @schema PrometheusSpecContainers#env
   */
  readonly env?: PrometheusSpecContainersEnv[];

  /**
   * List of sources to populate environment variables in the container.
   * The keys defined within a source must be a C_IDENTIFIER. All invalid keys
   * will be reported as an event when the container is starting. When a key exists in multiple
   * sources, the value associated with the last source will take precedence.
   * Values defined by an Env with a duplicate key will take precedence.
   * Cannot be updated.
   *
   * @schema PrometheusSpecContainers#envFrom
   */
  readonly envFrom?: PrometheusSpecContainersEnvFrom[];

  /**
   * Container image name.
   * More info: https://kubernetes.io/docs/concepts/containers/images
   * This field is optional to allow higher level config management to default or override
   * container images in workload controllers like Deployments and StatefulSets.
   *
   * @schema PrometheusSpecContainers#image
   */
  readonly image?: string;

  /**
   * Image pull policy.
   * One of Always, Never, IfNotPresent.
   * Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   *
   * @default Always if :latest tag is specified, or IfNotPresent otherwise.
   * @schema PrometheusSpecContainers#imagePullPolicy
   */
  readonly imagePullPolicy?: string;

  /**
   * Actions that the management system should take in response to container lifecycle events.
   * Cannot be updated.
   *
   * @schema PrometheusSpecContainers#lifecycle
   */
  readonly lifecycle?: PrometheusSpecContainersLifecycle;

  /**
   * Periodic probe of container liveness.
   * Container will be restarted if the probe fails.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema PrometheusSpecContainers#livenessProbe
   */
  readonly livenessProbe?: PrometheusSpecContainersLivenessProbe;

  /**
   * Name of the container specified as a DNS_LABEL.
   * Each container in a pod must have a unique name (DNS_LABEL).
   * Cannot be updated.
   *
   * @schema PrometheusSpecContainers#name
   */
  readonly name: string;

  /**
   * List of ports to expose from the container. Not specifying a port here
   * DOES NOT prevent that port from being exposed. Any port which is
   * listening on the default "0.0.0.0" address inside a container will be
   * accessible from the network.
   * Modifying this array with strategic merge patch may corrupt the data.
   * For more information See https://github.com/kubernetes/kubernetes/issues/108255.
   * Cannot be updated.
   *
   * @schema PrometheusSpecContainers#ports
   */
  readonly ports?: PrometheusSpecContainersPorts[];

  /**
   * Periodic probe of container service readiness.
   * Container will be removed from service endpoints if the probe fails.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema PrometheusSpecContainers#readinessProbe
   */
  readonly readinessProbe?: PrometheusSpecContainersReadinessProbe;

  /**
   * Resources resize policy for the container.
   *
   * @schema PrometheusSpecContainers#resizePolicy
   */
  readonly resizePolicy?: PrometheusSpecContainersResizePolicy[];

  /**
   * Compute Resources required by this container.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema PrometheusSpecContainers#resources
   */
  readonly resources?: PrometheusSpecContainersResources;

  /**
   * RestartPolicy defines the restart behavior of individual containers in a pod.
   * This field may only be set for init containers, and the only allowed value is "Always".
   * For non-init containers or when this field is not specified,
   * the restart behavior is defined by the Pod's restart policy and the container type.
   * Setting the RestartPolicy as "Always" for the init container will have the following effect:
   * this init container will be continually restarted on
   * exit until all regular containers have terminated. Once all regular
   * containers have completed, all init containers with restartPolicy "Always"
   * will be shut down. This lifecycle differs from normal init containers and
   * is often referred to as a "sidecar" container. Although this init
   * container still starts in the init container sequence, it does not wait
   * for the container to complete before proceeding to the next init
   * container. Instead, the next init container starts immediately after this
   * init container is started, or after any startupProbe has successfully
   * completed.
   *
   * @schema PrometheusSpecContainers#restartPolicy
   */
  readonly restartPolicy?: string;

  /**
   * SecurityContext defines the security options the container should be run with.
   * If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
   * More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
   *
   * @schema PrometheusSpecContainers#securityContext
   */
  readonly securityContext?: PrometheusSpecContainersSecurityContext;

  /**
   * StartupProbe indicates that the Pod has successfully initialized.
   * If specified, no other probes are executed until this completes successfully.
   * If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
   * This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
   * when it might take a long time to load data or warm a cache, than during steady-state operation.
   * This cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema PrometheusSpecContainers#startupProbe
   */
  readonly startupProbe?: PrometheusSpecContainersStartupProbe;

  /**
   * Whether this container should allocate a buffer for stdin in the container runtime. If this
   * is not set, reads from stdin in the container will always result in EOF.
   * Default is false.
   *
   * @default false.
   * @schema PrometheusSpecContainers#stdin
   */
  readonly stdin?: boolean;

  /**
   * Whether the container runtime should close the stdin channel after it has been opened by
   * a single attach. When stdin is true the stdin stream will remain open across multiple attach
   * sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
   * first client attaches to stdin, and then remains open and accepts data until the client disconnects,
   * at which time stdin is closed and remains closed until the container is restarted. If this
   * flag is false, a container processes that reads from stdin will never receive an EOF.
   * Default is false
   *
   * @default false
   * @schema PrometheusSpecContainers#stdinOnce
   */
  readonly stdinOnce?: boolean;

  /**
   * Optional: Path at which the file to which the container's termination message
   * will be written is mounted into the container's filesystem.
   * Message written is intended to be brief final status, such as an assertion failure message.
   * Will be truncated by the node if greater than 4096 bytes. The total message length across
   * all containers will be limited to 12kb.
   * Defaults to /dev/termination-log.
   * Cannot be updated.
   *
   * @default dev/termination-log.
   * @schema PrometheusSpecContainers#terminationMessagePath
   */
  readonly terminationMessagePath?: string;

  /**
   * Indicate how the termination message should be populated. File will use the contents of
   * terminationMessagePath to populate the container status message on both success and failure.
   * FallbackToLogsOnError will use the last chunk of container log output if the termination
   * message file is empty and the container exited with an error.
   * The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
   * Defaults to File.
   * Cannot be updated.
   *
   * @default File.
   * @schema PrometheusSpecContainers#terminationMessagePolicy
   */
  readonly terminationMessagePolicy?: string;

  /**
   * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
   * Default is false.
   *
   * @default false.
   * @schema PrometheusSpecContainers#tty
   */
  readonly tty?: boolean;

  /**
   * volumeDevices is the list of block devices to be used by the container.
   *
   * @schema PrometheusSpecContainers#volumeDevices
   */
  readonly volumeDevices?: PrometheusSpecContainersVolumeDevices[];

  /**
   * Pod volumes to mount into the container's filesystem.
   * Cannot be updated.
   *
   * @schema PrometheusSpecContainers#volumeMounts
   */
  readonly volumeMounts?: PrometheusSpecContainersVolumeMounts[];

  /**
   * Container's working directory.
   * If not specified, the container runtime's default will be used, which
   * might be configured in the container image.
   * Cannot be updated.
   *
   * @schema PrometheusSpecContainers#workingDir
   */
  readonly workingDir?: string;

}

/**
 * Converts an object of type 'PrometheusSpecContainers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainers(obj: PrometheusSpecContainers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'args': obj.args?.map(y => y),
    'command': obj.command?.map(y => y),
    'env': obj.env?.map(y => toJson_PrometheusSpecContainersEnv(y)),
    'envFrom': obj.envFrom?.map(y => toJson_PrometheusSpecContainersEnvFrom(y)),
    'image': obj.image,
    'imagePullPolicy': obj.imagePullPolicy,
    'lifecycle': toJson_PrometheusSpecContainersLifecycle(obj.lifecycle),
    'livenessProbe': toJson_PrometheusSpecContainersLivenessProbe(obj.livenessProbe),
    'name': obj.name,
    'ports': obj.ports?.map(y => toJson_PrometheusSpecContainersPorts(y)),
    'readinessProbe': toJson_PrometheusSpecContainersReadinessProbe(obj.readinessProbe),
    'resizePolicy': obj.resizePolicy?.map(y => toJson_PrometheusSpecContainersResizePolicy(y)),
    'resources': toJson_PrometheusSpecContainersResources(obj.resources),
    'restartPolicy': obj.restartPolicy,
    'securityContext': toJson_PrometheusSpecContainersSecurityContext(obj.securityContext),
    'startupProbe': toJson_PrometheusSpecContainersStartupProbe(obj.startupProbe),
    'stdin': obj.stdin,
    'stdinOnce': obj.stdinOnce,
    'terminationMessagePath': obj.terminationMessagePath,
    'terminationMessagePolicy': obj.terminationMessagePolicy,
    'tty': obj.tty,
    'volumeDevices': obj.volumeDevices?.map(y => toJson_PrometheusSpecContainersVolumeDevices(y)),
    'volumeMounts': obj.volumeMounts?.map(y => toJson_PrometheusSpecContainersVolumeMounts(y)),
    'workingDir': obj.workingDir,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ObjectReference references a PodMonitor, ServiceMonitor, Probe or PrometheusRule object.
 *
 * @schema PrometheusSpecExcludedFromEnforcement
 */
export interface PrometheusSpecExcludedFromEnforcement {
  /**
   * Group of the referent. When not specified, it defaults to `monitoring.coreos.com`
   *
   * @schema PrometheusSpecExcludedFromEnforcement#group
   */
  readonly group?: PrometheusSpecExcludedFromEnforcementGroup;

  /**
   * Name of the referent. When not set, all resources in the namespace are matched.
   *
   * @schema PrometheusSpecExcludedFromEnforcement#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema PrometheusSpecExcludedFromEnforcement#namespace
   */
  readonly namespace: string;

  /**
   * Resource of the referent.
   *
   * @schema PrometheusSpecExcludedFromEnforcement#resource
   */
  readonly resource: PrometheusSpecExcludedFromEnforcementResource;

}

/**
 * Converts an object of type 'PrometheusSpecExcludedFromEnforcement' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecExcludedFromEnforcement(obj: PrometheusSpecExcludedFromEnforcement | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'name': obj.name,
    'namespace': obj.namespace,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exemplars related settings that are runtime reloadable.
 * It requires to enable the `exemplar-storage` feature flag to be effective.
 *
 * @schema PrometheusSpecExemplars
 */
export interface PrometheusSpecExemplars {
  /**
   * Maximum number of exemplars stored in memory for all series.
   *
   *
   * exemplar-storage itself must be enabled using the `spec.enableFeature`
   * option for exemplars to be scraped in the first place.
   *
   *
   * If not set, Prometheus uses its default value. A value of zero or less
   * than zero disables the storage.
   *
   * @schema PrometheusSpecExemplars#maxSize
   */
  readonly maxSize?: number;

}

/**
 * Converts an object of type 'PrometheusSpecExemplars' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecExemplars(obj: PrometheusSpecExemplars | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxSize': obj.maxSize,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the
 * pod's hosts file.
 *
 * @schema PrometheusSpecHostAliases
 */
export interface PrometheusSpecHostAliases {
  /**
   * Hostnames for the above IP address.
   *
   * @schema PrometheusSpecHostAliases#hostnames
   */
  readonly hostnames: string[];

  /**
   * IP address of the host file entry.
   *
   * @schema PrometheusSpecHostAliases#ip
   */
  readonly ip: string;

}

/**
 * Converts an object of type 'PrometheusSpecHostAliases' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecHostAliases(obj: PrometheusSpecHostAliases | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostnames': obj.hostnames?.map(y => y),
    'ip': obj.ip,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Image pull policy for the 'prometheus', 'init-config-reloader' and 'config-reloader' containers.
 * See https://kubernetes.io/docs/concepts/containers/images/#image-pull-policy for more details.
 *
 * @schema PrometheusSpecImagePullPolicy
 */
export enum PrometheusSpecImagePullPolicy {
  /** Always */
  ALWAYS = "Always",
  /** Never */
  NEVER = "Never",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * LocalObjectReference contains enough information to let you locate the
 * referenced object inside the same namespace.
 *
 * @schema PrometheusSpecImagePullSecrets
 */
export interface PrometheusSpecImagePullSecrets {
  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecImagePullSecrets#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'PrometheusSpecImagePullSecrets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecImagePullSecrets(obj: PrometheusSpecImagePullSecrets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A single application container that you want to run within a pod.
 *
 * @schema PrometheusSpecInitContainers
 */
export interface PrometheusSpecInitContainers {
  /**
   * Arguments to the entrypoint.
   * The container image's CMD is used if this is not provided.
   * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
   * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
   * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
   * of whether the variable exists or not. Cannot be updated.
   * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema PrometheusSpecInitContainers#args
   */
  readonly args?: string[];

  /**
   * Entrypoint array. Not executed within a shell.
   * The container image's ENTRYPOINT is used if this is not provided.
   * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
   * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
   * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
   * of whether the variable exists or not. Cannot be updated.
   * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema PrometheusSpecInitContainers#command
   */
  readonly command?: string[];

  /**
   * List of environment variables to set in the container.
   * Cannot be updated.
   *
   * @schema PrometheusSpecInitContainers#env
   */
  readonly env?: PrometheusSpecInitContainersEnv[];

  /**
   * List of sources to populate environment variables in the container.
   * The keys defined within a source must be a C_IDENTIFIER. All invalid keys
   * will be reported as an event when the container is starting. When a key exists in multiple
   * sources, the value associated with the last source will take precedence.
   * Values defined by an Env with a duplicate key will take precedence.
   * Cannot be updated.
   *
   * @schema PrometheusSpecInitContainers#envFrom
   */
  readonly envFrom?: PrometheusSpecInitContainersEnvFrom[];

  /**
   * Container image name.
   * More info: https://kubernetes.io/docs/concepts/containers/images
   * This field is optional to allow higher level config management to default or override
   * container images in workload controllers like Deployments and StatefulSets.
   *
   * @schema PrometheusSpecInitContainers#image
   */
  readonly image?: string;

  /**
   * Image pull policy.
   * One of Always, Never, IfNotPresent.
   * Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   *
   * @default Always if :latest tag is specified, or IfNotPresent otherwise.
   * @schema PrometheusSpecInitContainers#imagePullPolicy
   */
  readonly imagePullPolicy?: string;

  /**
   * Actions that the management system should take in response to container lifecycle events.
   * Cannot be updated.
   *
   * @schema PrometheusSpecInitContainers#lifecycle
   */
  readonly lifecycle?: PrometheusSpecInitContainersLifecycle;

  /**
   * Periodic probe of container liveness.
   * Container will be restarted if the probe fails.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema PrometheusSpecInitContainers#livenessProbe
   */
  readonly livenessProbe?: PrometheusSpecInitContainersLivenessProbe;

  /**
   * Name of the container specified as a DNS_LABEL.
   * Each container in a pod must have a unique name (DNS_LABEL).
   * Cannot be updated.
   *
   * @schema PrometheusSpecInitContainers#name
   */
  readonly name: string;

  /**
   * List of ports to expose from the container. Not specifying a port here
   * DOES NOT prevent that port from being exposed. Any port which is
   * listening on the default "0.0.0.0" address inside a container will be
   * accessible from the network.
   * Modifying this array with strategic merge patch may corrupt the data.
   * For more information See https://github.com/kubernetes/kubernetes/issues/108255.
   * Cannot be updated.
   *
   * @schema PrometheusSpecInitContainers#ports
   */
  readonly ports?: PrometheusSpecInitContainersPorts[];

  /**
   * Periodic probe of container service readiness.
   * Container will be removed from service endpoints if the probe fails.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema PrometheusSpecInitContainers#readinessProbe
   */
  readonly readinessProbe?: PrometheusSpecInitContainersReadinessProbe;

  /**
   * Resources resize policy for the container.
   *
   * @schema PrometheusSpecInitContainers#resizePolicy
   */
  readonly resizePolicy?: PrometheusSpecInitContainersResizePolicy[];

  /**
   * Compute Resources required by this container.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema PrometheusSpecInitContainers#resources
   */
  readonly resources?: PrometheusSpecInitContainersResources;

  /**
   * RestartPolicy defines the restart behavior of individual containers in a pod.
   * This field may only be set for init containers, and the only allowed value is "Always".
   * For non-init containers or when this field is not specified,
   * the restart behavior is defined by the Pod's restart policy and the container type.
   * Setting the RestartPolicy as "Always" for the init container will have the following effect:
   * this init container will be continually restarted on
   * exit until all regular containers have terminated. Once all regular
   * containers have completed, all init containers with restartPolicy "Always"
   * will be shut down. This lifecycle differs from normal init containers and
   * is often referred to as a "sidecar" container. Although this init
   * container still starts in the init container sequence, it does not wait
   * for the container to complete before proceeding to the next init
   * container. Instead, the next init container starts immediately after this
   * init container is started, or after any startupProbe has successfully
   * completed.
   *
   * @schema PrometheusSpecInitContainers#restartPolicy
   */
  readonly restartPolicy?: string;

  /**
   * SecurityContext defines the security options the container should be run with.
   * If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
   * More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
   *
   * @schema PrometheusSpecInitContainers#securityContext
   */
  readonly securityContext?: PrometheusSpecInitContainersSecurityContext;

  /**
   * StartupProbe indicates that the Pod has successfully initialized.
   * If specified, no other probes are executed until this completes successfully.
   * If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
   * This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
   * when it might take a long time to load data or warm a cache, than during steady-state operation.
   * This cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema PrometheusSpecInitContainers#startupProbe
   */
  readonly startupProbe?: PrometheusSpecInitContainersStartupProbe;

  /**
   * Whether this container should allocate a buffer for stdin in the container runtime. If this
   * is not set, reads from stdin in the container will always result in EOF.
   * Default is false.
   *
   * @default false.
   * @schema PrometheusSpecInitContainers#stdin
   */
  readonly stdin?: boolean;

  /**
   * Whether the container runtime should close the stdin channel after it has been opened by
   * a single attach. When stdin is true the stdin stream will remain open across multiple attach
   * sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
   * first client attaches to stdin, and then remains open and accepts data until the client disconnects,
   * at which time stdin is closed and remains closed until the container is restarted. If this
   * flag is false, a container processes that reads from stdin will never receive an EOF.
   * Default is false
   *
   * @default false
   * @schema PrometheusSpecInitContainers#stdinOnce
   */
  readonly stdinOnce?: boolean;

  /**
   * Optional: Path at which the file to which the container's termination message
   * will be written is mounted into the container's filesystem.
   * Message written is intended to be brief final status, such as an assertion failure message.
   * Will be truncated by the node if greater than 4096 bytes. The total message length across
   * all containers will be limited to 12kb.
   * Defaults to /dev/termination-log.
   * Cannot be updated.
   *
   * @default dev/termination-log.
   * @schema PrometheusSpecInitContainers#terminationMessagePath
   */
  readonly terminationMessagePath?: string;

  /**
   * Indicate how the termination message should be populated. File will use the contents of
   * terminationMessagePath to populate the container status message on both success and failure.
   * FallbackToLogsOnError will use the last chunk of container log output if the termination
   * message file is empty and the container exited with an error.
   * The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
   * Defaults to File.
   * Cannot be updated.
   *
   * @default File.
   * @schema PrometheusSpecInitContainers#terminationMessagePolicy
   */
  readonly terminationMessagePolicy?: string;

  /**
   * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
   * Default is false.
   *
   * @default false.
   * @schema PrometheusSpecInitContainers#tty
   */
  readonly tty?: boolean;

  /**
   * volumeDevices is the list of block devices to be used by the container.
   *
   * @schema PrometheusSpecInitContainers#volumeDevices
   */
  readonly volumeDevices?: PrometheusSpecInitContainersVolumeDevices[];

  /**
   * Pod volumes to mount into the container's filesystem.
   * Cannot be updated.
   *
   * @schema PrometheusSpecInitContainers#volumeMounts
   */
  readonly volumeMounts?: PrometheusSpecInitContainersVolumeMounts[];

  /**
   * Container's working directory.
   * If not specified, the container runtime's default will be used, which
   * might be configured in the container image.
   * Cannot be updated.
   *
   * @schema PrometheusSpecInitContainers#workingDir
   */
  readonly workingDir?: string;

}

/**
 * Converts an object of type 'PrometheusSpecInitContainers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainers(obj: PrometheusSpecInitContainers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'args': obj.args?.map(y => y),
    'command': obj.command?.map(y => y),
    'env': obj.env?.map(y => toJson_PrometheusSpecInitContainersEnv(y)),
    'envFrom': obj.envFrom?.map(y => toJson_PrometheusSpecInitContainersEnvFrom(y)),
    'image': obj.image,
    'imagePullPolicy': obj.imagePullPolicy,
    'lifecycle': toJson_PrometheusSpecInitContainersLifecycle(obj.lifecycle),
    'livenessProbe': toJson_PrometheusSpecInitContainersLivenessProbe(obj.livenessProbe),
    'name': obj.name,
    'ports': obj.ports?.map(y => toJson_PrometheusSpecInitContainersPorts(y)),
    'readinessProbe': toJson_PrometheusSpecInitContainersReadinessProbe(obj.readinessProbe),
    'resizePolicy': obj.resizePolicy?.map(y => toJson_PrometheusSpecInitContainersResizePolicy(y)),
    'resources': toJson_PrometheusSpecInitContainersResources(obj.resources),
    'restartPolicy': obj.restartPolicy,
    'securityContext': toJson_PrometheusSpecInitContainersSecurityContext(obj.securityContext),
    'startupProbe': toJson_PrometheusSpecInitContainersStartupProbe(obj.startupProbe),
    'stdin': obj.stdin,
    'stdinOnce': obj.stdinOnce,
    'terminationMessagePath': obj.terminationMessagePath,
    'terminationMessagePolicy': obj.terminationMessagePolicy,
    'tty': obj.tty,
    'volumeDevices': obj.volumeDevices?.map(y => toJson_PrometheusSpecInitContainersVolumeDevices(y)),
    'volumeMounts': obj.volumeMounts?.map(y => toJson_PrometheusSpecInitContainersVolumeMounts(y)),
    'workingDir': obj.workingDir,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Log format for Log level for Prometheus and the config-reloader sidecar.
 *
 * @schema PrometheusSpecLogFormat
 */
export enum PrometheusSpecLogFormat {
  /** logfmt */
  LOGFMT = "logfmt",
  /** json */
  JSON = "json",
}

/**
 * Log level for Prometheus and the config-reloader sidecar.
 *
 * @schema PrometheusSpecLogLevel
 */
export enum PrometheusSpecLogLevel {
  /** debug */
  DEBUG = "debug",
  /** info */
  INFO = "info",
  /** warn */
  WARN = "warn",
  /** error */
  ERROR = "error",
}

/**
 * The field controls if and how PVCs are deleted during the lifecycle of a StatefulSet.
 * The default behavior is all PVCs are retained.
 * This is an alpha field from kubernetes 1.23 until 1.26 and a beta field from 1.26.
 * It requires enabling the StatefulSetAutoDeletePVC feature gate.
 *
 * @schema PrometheusSpecPersistentVolumeClaimRetentionPolicy
 */
export interface PrometheusSpecPersistentVolumeClaimRetentionPolicy {
  /**
   * WhenDeleted specifies what happens to PVCs created from StatefulSet
   * VolumeClaimTemplates when the StatefulSet is deleted. The default policy
   * of `Retain` causes PVCs to not be affected by StatefulSet deletion. The
   * `Delete` policy causes those PVCs to be deleted.
   *
   * @schema PrometheusSpecPersistentVolumeClaimRetentionPolicy#whenDeleted
   */
  readonly whenDeleted?: string;

  /**
   * WhenScaled specifies what happens to PVCs created from StatefulSet
   * VolumeClaimTemplates when the StatefulSet is scaled down. The default
   * policy of `Retain` causes PVCs to not be affected by a scaledown. The
   * `Delete` policy causes the associated PVCs for any excess pods above
   * the replica count to be deleted.
   *
   * @schema PrometheusSpecPersistentVolumeClaimRetentionPolicy#whenScaled
   */
  readonly whenScaled?: string;

}

/**
 * Converts an object of type 'PrometheusSpecPersistentVolumeClaimRetentionPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecPersistentVolumeClaimRetentionPolicy(obj: PrometheusSpecPersistentVolumeClaimRetentionPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'whenDeleted': obj.whenDeleted,
    'whenScaled': obj.whenScaled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PodMetadata configures labels and annotations which are propagated to the Prometheus pods.
 *
 *
 * The following items are reserved and cannot be overridden:
 * * "prometheus" label, set to the name of the Prometheus object.
 * * "app.kubernetes.io/instance" label, set to the name of the Prometheus object.
 * * "app.kubernetes.io/managed-by" label, set to "prometheus-operator".
 * * "app.kubernetes.io/name" label, set to "prometheus".
 * * "app.kubernetes.io/version" label, set to the Prometheus version.
 * * "operator.prometheus.io/name" label, set to the name of the Prometheus object.
 * * "operator.prometheus.io/shard" label, set to the shard number of the Prometheus object.
 * * "kubectl.kubernetes.io/default-container" annotation, set to "prometheus".
 *
 * @schema PrometheusSpecPodMetadata
 */
export interface PrometheusSpecPodMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be
   * set by external tools to store and retrieve arbitrary metadata. They are not
   * queryable and should be preserved when modifying objects.
   * More info: http://kubernetes.io/docs/user-guide/annotations
   *
   * @schema PrometheusSpecPodMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Map of string keys and values that can be used to organize and categorize
   * (scope and select) objects. May match selectors of replication controllers
   * and services.
   * More info: http://kubernetes.io/docs/user-guide/labels
   *
   * @schema PrometheusSpecPodMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Name must be unique within a namespace. Is required when creating resources, although
   * some resources may allow a client to request the generation of an appropriate name
   * automatically. Name is primarily intended for creation idempotence and configuration
   * definition.
   * Cannot be updated.
   * More info: http://kubernetes.io/docs/user-guide/identifiers#names
   *
   * @schema PrometheusSpecPodMetadata#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'PrometheusSpecPodMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecPodMetadata(obj: PrometheusSpecPodMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Namespaces to match for PodMonitors discovery. An empty label selector
 * matches all namespaces. A null label selector matches the current
 * namespace only.
 *
 * @schema PrometheusSpecPodMonitorNamespaceSelector
 */
export interface PrometheusSpecPodMonitorNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PrometheusSpecPodMonitorNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: PrometheusSpecPodMonitorNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PrometheusSpecPodMonitorNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'PrometheusSpecPodMonitorNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecPodMonitorNamespaceSelector(obj: PrometheusSpecPodMonitorNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_PrometheusSpecPodMonitorNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PodMonitors to be selected for target discovery. An empty label selector
 * matches all objects. A null label selector matches no objects.
 *
 *
 * If `spec.serviceMonitorSelector`, `spec.podMonitorSelector`, `spec.probeSelector`
 * and `spec.scrapeConfigSelector` are null, the Prometheus configuration is unmanaged.
 * The Prometheus operator will ensure that the Prometheus configuration's
 * Secret exists, but it is the responsibility of the user to provide the raw
 * gzipped Prometheus configuration under the `prometheus.yaml.gz` key.
 * This behavior is *deprecated* and will be removed in the next major version
 * of the custom resource definition. It is recommended to use
 * `spec.additionalScrapeConfigs` instead.
 *
 * @schema PrometheusSpecPodMonitorSelector
 */
export interface PrometheusSpecPodMonitorSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PrometheusSpecPodMonitorSelector#matchExpressions
   */
  readonly matchExpressions?: PrometheusSpecPodMonitorSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PrometheusSpecPodMonitorSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'PrometheusSpecPodMonitorSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecPodMonitorSelector(obj: PrometheusSpecPodMonitorSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_PrometheusSpecPodMonitorSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Namespaces to match for Probe discovery. An empty label
 * selector matches all namespaces. A null label selector matches the
 * current namespace only.
 *
 * @schema PrometheusSpecProbeNamespaceSelector
 */
export interface PrometheusSpecProbeNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PrometheusSpecProbeNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: PrometheusSpecProbeNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PrometheusSpecProbeNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'PrometheusSpecProbeNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecProbeNamespaceSelector(obj: PrometheusSpecProbeNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_PrometheusSpecProbeNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Probes to be selected for target discovery. An empty label selector
 * matches all objects. A null label selector matches no objects.
 *
 *
 * If `spec.serviceMonitorSelector`, `spec.podMonitorSelector`, `spec.probeSelector`
 * and `spec.scrapeConfigSelector` are null, the Prometheus configuration is unmanaged.
 * The Prometheus operator will ensure that the Prometheus configuration's
 * Secret exists, but it is the responsibility of the user to provide the raw
 * gzipped Prometheus configuration under the `prometheus.yaml.gz` key.
 * This behavior is *deprecated* and will be removed in the next major version
 * of the custom resource definition. It is recommended to use
 * `spec.additionalScrapeConfigs` instead.
 *
 * @schema PrometheusSpecProbeSelector
 */
export interface PrometheusSpecProbeSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PrometheusSpecProbeSelector#matchExpressions
   */
  readonly matchExpressions?: PrometheusSpecProbeSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PrometheusSpecProbeSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'PrometheusSpecProbeSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecProbeSelector(obj: PrometheusSpecProbeSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_PrometheusSpecProbeSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PrometheusRuleExcludeConfig enables users to configure excluded
 * PrometheusRule names and their namespaces to be ignored while enforcing
 * namespace label for alerts and metrics.
 *
 * @schema PrometheusSpecPrometheusRulesExcludedFromEnforce
 */
export interface PrometheusSpecPrometheusRulesExcludedFromEnforce {
  /**
   * Name of the excluded PrometheusRule object.
   *
   * @schema PrometheusSpecPrometheusRulesExcludedFromEnforce#ruleName
   */
  readonly ruleName: string;

  /**
   * Namespace of the excluded PrometheusRule object.
   *
   * @schema PrometheusSpecPrometheusRulesExcludedFromEnforce#ruleNamespace
   */
  readonly ruleNamespace: string;

}

/**
 * Converts an object of type 'PrometheusSpecPrometheusRulesExcludedFromEnforce' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecPrometheusRulesExcludedFromEnforce(obj: PrometheusSpecPrometheusRulesExcludedFromEnforce | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ruleName': obj.ruleName,
    'ruleNamespace': obj.ruleNamespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * QuerySpec defines the configuration of the Promethus query service.
 *
 * @schema PrometheusSpecQuery
 */
export interface PrometheusSpecQuery {
  /**
   * The delta difference allowed for retrieving metrics during expression evaluations.
   *
   * @schema PrometheusSpecQuery#lookbackDelta
   */
  readonly lookbackDelta?: string;

  /**
   * Number of concurrent queries that can be run at once.
   *
   * @schema PrometheusSpecQuery#maxConcurrency
   */
  readonly maxConcurrency?: number;

  /**
   * Maximum number of samples a single query can load into memory. Note that
   * queries will fail if they would load more samples than this into memory,
   * so this also limits the number of samples a query can return.
   *
   * @schema PrometheusSpecQuery#maxSamples
   */
  readonly maxSamples?: number;

  /**
   * Maximum time a query may take before being aborted.
   *
   * @schema PrometheusSpecQuery#timeout
   */
  readonly timeout?: string;

}

/**
 * Converts an object of type 'PrometheusSpecQuery' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecQuery(obj: PrometheusSpecQuery | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'lookbackDelta': obj.lookbackDelta,
    'maxConcurrency': obj.maxConcurrency,
    'maxSamples': obj.maxSamples,
    'timeout': obj.timeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Defines the strategy used to reload the Prometheus configuration.
 * If not specified, the configuration is reloaded using the /-/reload HTTP endpoint.
 *
 * @schema PrometheusSpecReloadStrategy
 */
export enum PrometheusSpecReloadStrategy {
  /** HTTP */
  HTTP = "HTTP",
  /** ProcessSignal */
  PROCESS_SIGNAL = "ProcessSignal",
}

/**
 * RemoteReadSpec defines the configuration for Prometheus to read back samples
 * from a remote endpoint.
 *
 * @schema PrometheusSpecRemoteRead
 */
export interface PrometheusSpecRemoteRead {
  /**
   * Authorization section for the URL.
   *
   *
   * It requires Prometheus >= v2.26.0.
   *
   *
   * Cannot be set at the same time as `basicAuth`, or `oauth2`.
   *
   * @schema PrometheusSpecRemoteRead#authorization
   */
  readonly authorization?: PrometheusSpecRemoteReadAuthorization;

  /**
   * BasicAuth configuration for the URL.
   *
   *
   * Cannot be set at the same time as `authorization`, or `oauth2`.
   *
   * @schema PrometheusSpecRemoteRead#basicAuth
   */
  readonly basicAuth?: PrometheusSpecRemoteReadBasicAuth;

  /**
   * *Warning: this field shouldn't be used because the token value appears
   * in clear-text. Prefer using `authorization`.*
   *
   *
   * Deprecated: this will be removed in a future release.
   *
   * @schema PrometheusSpecRemoteRead#bearerToken
   */
  readonly bearerToken?: string;

  /**
   * File from which to read the bearer token for the URL.
   *
   *
   * Deprecated: this will be removed in a future release. Prefer using `authorization`.
   *
   * @schema PrometheusSpecRemoteRead#bearerTokenFile
   */
  readonly bearerTokenFile?: string;

  /**
   * Whether to use the external labels as selectors for the remote read endpoint.
   *
   *
   * It requires Prometheus >= v2.34.0.
   *
   * @schema PrometheusSpecRemoteRead#filterExternalLabels
   */
  readonly filterExternalLabels?: boolean;

  /**
   * Configure whether HTTP requests follow HTTP 3xx redirects.
   *
   *
   * It requires Prometheus >= v2.26.0.
   *
   * @schema PrometheusSpecRemoteRead#followRedirects
   */
  readonly followRedirects?: boolean;

  /**
   * Custom HTTP headers to be sent along with each remote read request.
   * Be aware that headers that are set by Prometheus itself can't be overwritten.
   * Only valid in Prometheus versions 2.26.0 and newer.
   *
   * @schema PrometheusSpecRemoteRead#headers
   */
  readonly headers?: { [key: string]: string };

  /**
   * The name of the remote read queue, it must be unique if specified. The
   * name is used in metrics and logging in order to differentiate read
   * configurations.
   *
   *
   * It requires Prometheus >= v2.15.0.
   *
   * @schema PrometheusSpecRemoteRead#name
   */
  readonly name?: string;

  /**
   * OAuth2 configuration for the URL.
   *
   *
   * It requires Prometheus >= v2.27.0.
   *
   *
   * Cannot be set at the same time as `authorization`, or `basicAuth`.
   *
   * @schema PrometheusSpecRemoteRead#oauth2
   */
  readonly oauth2?: PrometheusSpecRemoteReadOauth2;

  /**
   * Optional ProxyURL.
   *
   * @schema PrometheusSpecRemoteRead#proxyUrl
   */
  readonly proxyUrl?: string;

  /**
   * Whether reads should be made for queries for time ranges that
   * the local storage should have complete data for.
   *
   * @schema PrometheusSpecRemoteRead#readRecent
   */
  readonly readRecent?: boolean;

  /**
   * Timeout for requests to the remote read endpoint.
   *
   * @schema PrometheusSpecRemoteRead#remoteTimeout
   */
  readonly remoteTimeout?: string;

  /**
   * An optional list of equality matchers which have to be present
   * in a selector to query the remote read endpoint.
   *
   * @schema PrometheusSpecRemoteRead#requiredMatchers
   */
  readonly requiredMatchers?: { [key: string]: string };

  /**
   * TLS Config to use for the URL.
   *
   * @schema PrometheusSpecRemoteRead#tlsConfig
   */
  readonly tlsConfig?: PrometheusSpecRemoteReadTlsConfig;

  /**
   * The URL of the endpoint to query from.
   *
   * @schema PrometheusSpecRemoteRead#url
   */
  readonly url: string;

}

/**
 * Converts an object of type 'PrometheusSpecRemoteRead' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteRead(obj: PrometheusSpecRemoteRead | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authorization': toJson_PrometheusSpecRemoteReadAuthorization(obj.authorization),
    'basicAuth': toJson_PrometheusSpecRemoteReadBasicAuth(obj.basicAuth),
    'bearerToken': obj.bearerToken,
    'bearerTokenFile': obj.bearerTokenFile,
    'filterExternalLabels': obj.filterExternalLabels,
    'followRedirects': obj.followRedirects,
    'headers': ((obj.headers) === undefined) ? undefined : (Object.entries(obj.headers).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
    'oauth2': toJson_PrometheusSpecRemoteReadOauth2(obj.oauth2),
    'proxyUrl': obj.proxyUrl,
    'readRecent': obj.readRecent,
    'remoteTimeout': obj.remoteTimeout,
    'requiredMatchers': ((obj.requiredMatchers) === undefined) ? undefined : (Object.entries(obj.requiredMatchers).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'tlsConfig': toJson_PrometheusSpecRemoteReadTlsConfig(obj.tlsConfig),
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RemoteWriteSpec defines the configuration to write samples from Prometheus
 * to a remote endpoint.
 *
 * @schema PrometheusSpecRemoteWrite
 */
export interface PrometheusSpecRemoteWrite {
  /**
   * Authorization section for the URL.
   *
   *
   * It requires Prometheus >= v2.26.0.
   *
   *
   * Cannot be set at the same time as `sigv4`, `basicAuth`, `oauth2`, or `azureAd`.
   *
   * @schema PrometheusSpecRemoteWrite#authorization
   */
  readonly authorization?: PrometheusSpecRemoteWriteAuthorization;

  /**
   * AzureAD for the URL.
   *
   *
   * It requires Prometheus >= v2.45.0.
   *
   *
   * Cannot be set at the same time as `authorization`, `basicAuth`, `oauth2`, or `sigv4`.
   *
   * @schema PrometheusSpecRemoteWrite#azureAd
   */
  readonly azureAd?: PrometheusSpecRemoteWriteAzureAd;

  /**
   * BasicAuth configuration for the URL.
   *
   *
   * Cannot be set at the same time as `sigv4`, `authorization`, `oauth2`, or `azureAd`.
   *
   * @schema PrometheusSpecRemoteWrite#basicAuth
   */
  readonly basicAuth?: PrometheusSpecRemoteWriteBasicAuth;

  /**
   * *Warning: this field shouldn't be used because the token value appears
   * in clear-text. Prefer using `authorization`.*
   *
   *
   * Deprecated: this will be removed in a future release.
   *
   * @schema PrometheusSpecRemoteWrite#bearerToken
   */
  readonly bearerToken?: string;

  /**
   * File from which to read bearer token for the URL.
   *
   *
   * Deprecated: this will be removed in a future release. Prefer using `authorization`.
   *
   * @schema PrometheusSpecRemoteWrite#bearerTokenFile
   */
  readonly bearerTokenFile?: string;

  /**
   * Whether to enable HTTP2.
   *
   * @schema PrometheusSpecRemoteWrite#enableHTTP2
   */
  readonly enableHttp2?: boolean;

  /**
   * Custom HTTP headers to be sent along with each remote write request.
   * Be aware that headers that are set by Prometheus itself can't be overwritten.
   *
   *
   * It requires Prometheus >= v2.25.0.
   *
   * @schema PrometheusSpecRemoteWrite#headers
   */
  readonly headers?: { [key: string]: string };

  /**
   * MetadataConfig configures the sending of series metadata to the remote storage.
   *
   * @schema PrometheusSpecRemoteWrite#metadataConfig
   */
  readonly metadataConfig?: PrometheusSpecRemoteWriteMetadataConfig;

  /**
   * The name of the remote write queue, it must be unique if specified. The
   * name is used in metrics and logging in order to differentiate queues.
   *
   *
   * It requires Prometheus >= v2.15.0.
   *
   * @schema PrometheusSpecRemoteWrite#name
   */
  readonly name?: string;

  /**
   * OAuth2 configuration for the URL.
   *
   *
   * It requires Prometheus >= v2.27.0.
   *
   *
   * Cannot be set at the same time as `sigv4`, `authorization`, `basicAuth`, or `azureAd`.
   *
   * @schema PrometheusSpecRemoteWrite#oauth2
   */
  readonly oauth2?: PrometheusSpecRemoteWriteOauth2;

  /**
   * Optional ProxyURL.
   *
   * @schema PrometheusSpecRemoteWrite#proxyUrl
   */
  readonly proxyUrl?: string;

  /**
   * QueueConfig allows tuning of the remote write queue parameters.
   *
   * @schema PrometheusSpecRemoteWrite#queueConfig
   */
  readonly queueConfig?: PrometheusSpecRemoteWriteQueueConfig;

  /**
   * Timeout for requests to the remote write endpoint.
   *
   * @schema PrometheusSpecRemoteWrite#remoteTimeout
   */
  readonly remoteTimeout?: string;

  /**
   * Enables sending of exemplars over remote write. Note that
   * exemplar-storage itself must be enabled using the `spec.enableFeature`
   * option for exemplars to be scraped in the first place.
   *
   *
   * It requires Prometheus >= v2.27.0.
   *
   * @schema PrometheusSpecRemoteWrite#sendExemplars
   */
  readonly sendExemplars?: boolean;

  /**
   * Enables sending of native histograms, also known as sparse histograms
   * over remote write.
   *
   *
   * It requires Prometheus >= v2.40.0.
   *
   * @schema PrometheusSpecRemoteWrite#sendNativeHistograms
   */
  readonly sendNativeHistograms?: boolean;

  /**
   * Sigv4 allows to configures AWS's Signature Verification 4 for the URL.
   *
   *
   * It requires Prometheus >= v2.26.0.
   *
   *
   * Cannot be set at the same time as `authorization`, `basicAuth`, `oauth2`, or `azureAd`.
   *
   * @schema PrometheusSpecRemoteWrite#sigv4
   */
  readonly sigv4?: PrometheusSpecRemoteWriteSigv4;

  /**
   * TLS Config to use for the URL.
   *
   * @schema PrometheusSpecRemoteWrite#tlsConfig
   */
  readonly tlsConfig?: PrometheusSpecRemoteWriteTlsConfig;

  /**
   * The URL of the endpoint to send samples to.
   *
   * @schema PrometheusSpecRemoteWrite#url
   */
  readonly url: string;

  /**
   * The list of remote write relabel configurations.
   *
   * @schema PrometheusSpecRemoteWrite#writeRelabelConfigs
   */
  readonly writeRelabelConfigs?: PrometheusSpecRemoteWriteWriteRelabelConfigs[];

}

/**
 * Converts an object of type 'PrometheusSpecRemoteWrite' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteWrite(obj: PrometheusSpecRemoteWrite | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authorization': toJson_PrometheusSpecRemoteWriteAuthorization(obj.authorization),
    'azureAd': toJson_PrometheusSpecRemoteWriteAzureAd(obj.azureAd),
    'basicAuth': toJson_PrometheusSpecRemoteWriteBasicAuth(obj.basicAuth),
    'bearerToken': obj.bearerToken,
    'bearerTokenFile': obj.bearerTokenFile,
    'enableHTTP2': obj.enableHttp2,
    'headers': ((obj.headers) === undefined) ? undefined : (Object.entries(obj.headers).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'metadataConfig': toJson_PrometheusSpecRemoteWriteMetadataConfig(obj.metadataConfig),
    'name': obj.name,
    'oauth2': toJson_PrometheusSpecRemoteWriteOauth2(obj.oauth2),
    'proxyUrl': obj.proxyUrl,
    'queueConfig': toJson_PrometheusSpecRemoteWriteQueueConfig(obj.queueConfig),
    'remoteTimeout': obj.remoteTimeout,
    'sendExemplars': obj.sendExemplars,
    'sendNativeHistograms': obj.sendNativeHistograms,
    'sigv4': toJson_PrometheusSpecRemoteWriteSigv4(obj.sigv4),
    'tlsConfig': toJson_PrometheusSpecRemoteWriteTlsConfig(obj.tlsConfig),
    'url': obj.url,
    'writeRelabelConfigs': obj.writeRelabelConfigs?.map(y => toJson_PrometheusSpecRemoteWriteWriteRelabelConfigs(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Defines the resources requests and limits of the 'prometheus' container.
 *
 * @schema PrometheusSpecResources
 */
export interface PrometheusSpecResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema PrometheusSpecResources#claims
   */
  readonly claims?: PrometheusSpecResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema PrometheusSpecResources#limits
   */
  readonly limits?: { [key: string]: PrometheusSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema PrometheusSpecResources#requests
   */
  readonly requests?: { [key: string]: PrometheusSpecResourcesRequests };

}

/**
 * Converts an object of type 'PrometheusSpecResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecResources(obj: PrometheusSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claims': obj.claims?.map(y => toJson_PrometheusSpecResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Namespaces to match for PrometheusRule discovery. An empty label selector
 * matches all namespaces. A null label selector matches the current
 * namespace only.
 *
 * @schema PrometheusSpecRuleNamespaceSelector
 */
export interface PrometheusSpecRuleNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PrometheusSpecRuleNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: PrometheusSpecRuleNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PrometheusSpecRuleNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'PrometheusSpecRuleNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRuleNamespaceSelector(obj: PrometheusSpecRuleNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_PrometheusSpecRuleNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PrometheusRule objects to be selected for rule evaluation. An empty
 * label selector matches all objects. A null label selector matches no
 * objects.
 *
 * @schema PrometheusSpecRuleSelector
 */
export interface PrometheusSpecRuleSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PrometheusSpecRuleSelector#matchExpressions
   */
  readonly matchExpressions?: PrometheusSpecRuleSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PrometheusSpecRuleSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'PrometheusSpecRuleSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRuleSelector(obj: PrometheusSpecRuleSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_PrometheusSpecRuleSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Defines the configuration of the Prometheus rules' engine.
 *
 * @schema PrometheusSpecRules
 */
export interface PrometheusSpecRules {
  /**
   * Defines the parameters of the Prometheus rules' engine.
   *
   *
   * Any update to these parameters trigger a restart of the pods.
   *
   * @schema PrometheusSpecRules#alert
   */
  readonly alert?: PrometheusSpecRulesAlert;

}

/**
 * Converts an object of type 'PrometheusSpecRules' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRules(obj: PrometheusSpecRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alert': toJson_PrometheusSpecRulesAlert(obj.alert),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PrometheusSpecScrapeClasses
 */
export interface PrometheusSpecScrapeClasses {
  /**
   * Default indicates that the scrape applies to all scrape objects that
   * don't configure an explicit scrape class name.
   *
   *
   * Only one scrape class can be set as the default.
   *
   * @schema PrometheusSpecScrapeClasses#default
   */
  readonly default?: boolean;

  /**
   * Name of the scrape class.
   *
   * @schema PrometheusSpecScrapeClasses#name
   */
  readonly name: string;

  /**
   * Relabelings configures the relabeling rules to apply to all scrape targets.
   *
   *
   * The Operator automatically adds relabelings for a few standard Kubernetes fields
   * like `__meta_kubernetes_namespace` and `__meta_kubernetes_service_name`.
   * Then the Operator adds the scrape class relabelings defined here.
   * Then the Operator adds the target-specific relabelings defined in the scrape object.
   *
   *
   * More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
   *
   * @schema PrometheusSpecScrapeClasses#relabelings
   */
  readonly relabelings?: PrometheusSpecScrapeClassesRelabelings[];

  /**
   * TLSConfig defines the TLS settings to use for the scrape. When the
   * scrape objects define their own CA, certificate and/or key, they take
   * precedence over the corresponding scrape class fields.
   *
   *
   * For now only the `caFile`, `certFile` and `keyFile` fields are supported.
   *
   * @schema PrometheusSpecScrapeClasses#tlsConfig
   */
  readonly tlsConfig?: PrometheusSpecScrapeClassesTlsConfig;

}

/**
 * Converts an object of type 'PrometheusSpecScrapeClasses' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecScrapeClasses(obj: PrometheusSpecScrapeClasses | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'default': obj.default,
    'name': obj.name,
    'relabelings': obj.relabelings?.map(y => toJson_PrometheusSpecScrapeClassesRelabelings(y)),
    'tlsConfig': toJson_PrometheusSpecScrapeClassesTlsConfig(obj.tlsConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Namespaces to match for ScrapeConfig discovery. An empty label selector
 * matches all namespaces. A null label selector matches the current
 * namespace only.
 *
 *
 * Note that the ScrapeConfig custom resource definition is currently at Alpha level.
 *
 * @schema PrometheusSpecScrapeConfigNamespaceSelector
 */
export interface PrometheusSpecScrapeConfigNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PrometheusSpecScrapeConfigNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: PrometheusSpecScrapeConfigNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PrometheusSpecScrapeConfigNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'PrometheusSpecScrapeConfigNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecScrapeConfigNamespaceSelector(obj: PrometheusSpecScrapeConfigNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_PrometheusSpecScrapeConfigNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ScrapeConfigs to be selected for target discovery. An empty label
 * selector matches all objects. A null label selector matches no objects.
 *
 *
 * If `spec.serviceMonitorSelector`, `spec.podMonitorSelector`, `spec.probeSelector`
 * and `spec.scrapeConfigSelector` are null, the Prometheus configuration is unmanaged.
 * The Prometheus operator will ensure that the Prometheus configuration's
 * Secret exists, but it is the responsibility of the user to provide the raw
 * gzipped Prometheus configuration under the `prometheus.yaml.gz` key.
 * This behavior is *deprecated* and will be removed in the next major version
 * of the custom resource definition. It is recommended to use
 * `spec.additionalScrapeConfigs` instead.
 *
 *
 * Note that the ScrapeConfig custom resource definition is currently at Alpha level.
 *
 * @schema PrometheusSpecScrapeConfigSelector
 */
export interface PrometheusSpecScrapeConfigSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PrometheusSpecScrapeConfigSelector#matchExpressions
   */
  readonly matchExpressions?: PrometheusSpecScrapeConfigSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PrometheusSpecScrapeConfigSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'PrometheusSpecScrapeConfigSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecScrapeConfigSelector(obj: PrometheusSpecScrapeConfigSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_PrometheusSpecScrapeConfigSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ScrapeProtocol represents a protocol used by Prometheus for scraping metrics.
 * Supported values are:
 * * `OpenMetricsText0.0.1`
 * * `OpenMetricsText1.0.0`
 * * `PrometheusProto`
 * * `PrometheusText0.0.4`
 *
 * @schema PrometheusSpecScrapeProtocols
 */
export enum PrometheusSpecScrapeProtocols {
  /** PrometheusProto */
  PROMETHEUS_PROTO = "PrometheusProto",
  /** OpenMetricsText0.0.1 */
  OPEN_METRICS_TEXT0_0_1 = "OpenMetricsText0.0.1",
  /** OpenMetricsText1.0.0 */
  OPEN_METRICS_TEXT1_0_0 = "OpenMetricsText1.0.0",
  /** PrometheusText0.0.4 */
  PROMETHEUS_TEXT0_0_4 = "PrometheusText0.0.4",
}

/**
 * SecurityContext holds pod-level security attributes and common container settings.
 * This defaults to the default PodSecurityContext.
 *
 * @schema PrometheusSpecSecurityContext
 */
export interface PrometheusSpecSecurityContext {
  /**
   * A special supplemental group that applies to all containers in a pod.
   * Some volume types allow the Kubelet to change the ownership of that volume
   * to be owned by the pod:
   *
   *
   * 1. The owning GID will be the FSGroup
   * 2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
   * 3. The permission bits are OR'd with rw-rw----
   *
   *
   * If unset, the Kubelet will not modify the ownership and permissions of any volume.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PrometheusSpecSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * fsGroupChangePolicy defines behavior of changing ownership and permission of the volume
   * before being exposed inside Pod. This field will only apply to
   * volume types which support fsGroup based ownership(and permissions).
   * It will have no effect on ephemeral volume types such as: secret, configmaps
   * and emptydir.
   * Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PrometheusSpecSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * The GID to run the entrypoint of the container process.
   * Uses runtime default if unset.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence
   * for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PrometheusSpecSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user.
   * If true, the Kubelet will validate the image at runtime to ensure that it
   * does not run as UID 0 (root) and fail to start the container if it does.
   * If unset or false, no such validation will be performed.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema PrometheusSpecSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process.
   * Defaults to user specified in image metadata if unspecified.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence
   * for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified.
   * @schema PrometheusSpecSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to all containers.
   * If unspecified, the container runtime will allocate a random SELinux context for each
   * container.  May also be set in SecurityContext.  If set in
   * both SecurityContext and PodSecurityContext, the value specified in SecurityContext
   * takes precedence for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PrometheusSpecSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: PrometheusSpecSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by the containers in this pod.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PrometheusSpecSecurityContext#seccompProfile
   */
  readonly seccompProfile?: PrometheusSpecSecurityContextSeccompProfile;

  /**
   * A list of groups applied to the first process run in each container, in addition
   * to the container's primary GID, the fsGroup (if specified), and group memberships
   * defined in the container image for the uid of the container process. If unspecified,
   * no additional groups are added to any container. Note that group memberships
   * defined in the container image for the uid of the container process are still effective,
   * even if they are not included in this list.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PrometheusSpecSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported
   * sysctls (by the container runtime) might fail to launch.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PrometheusSpecSecurityContext#sysctls
   */
  readonly sysctls?: PrometheusSpecSecurityContextSysctls[];

  /**
   * The Windows specific settings applied to all containers.
   * If unspecified, the options within a container's SecurityContext will be used.
   * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema PrometheusSpecSecurityContext#windowsOptions
   */
  readonly windowsOptions?: PrometheusSpecSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'PrometheusSpecSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecSecurityContext(obj: PrometheusSpecSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsGroup': obj.fsGroup,
    'fsGroupChangePolicy': obj.fsGroupChangePolicy,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_PrometheusSpecSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_PrometheusSpecSecurityContextSeccompProfile(obj.seccompProfile),
    'supplementalGroups': obj.supplementalGroups?.map(y => y),
    'sysctls': obj.sysctls?.map(y => toJson_PrometheusSpecSecurityContextSysctls(y)),
    'windowsOptions': toJson_PrometheusSpecSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Namespaces to match for ServicedMonitors discovery. An empty label selector
 * matches all namespaces. A null label selector matches the current
 * namespace only.
 *
 * @schema PrometheusSpecServiceMonitorNamespaceSelector
 */
export interface PrometheusSpecServiceMonitorNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PrometheusSpecServiceMonitorNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: PrometheusSpecServiceMonitorNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PrometheusSpecServiceMonitorNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'PrometheusSpecServiceMonitorNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecServiceMonitorNamespaceSelector(obj: PrometheusSpecServiceMonitorNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_PrometheusSpecServiceMonitorNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ServiceMonitors to be selected for target discovery. An empty label
 * selector matches all objects. A null label selector matches no objects.
 *
 *
 * If `spec.serviceMonitorSelector`, `spec.podMonitorSelector`, `spec.probeSelector`
 * and `spec.scrapeConfigSelector` are null, the Prometheus configuration is unmanaged.
 * The Prometheus operator will ensure that the Prometheus configuration's
 * Secret exists, but it is the responsibility of the user to provide the raw
 * gzipped Prometheus configuration under the `prometheus.yaml.gz` key.
 * This behavior is *deprecated* and will be removed in the next major version
 * of the custom resource definition. It is recommended to use
 * `spec.additionalScrapeConfigs` instead.
 *
 * @schema PrometheusSpecServiceMonitorSelector
 */
export interface PrometheusSpecServiceMonitorSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PrometheusSpecServiceMonitorSelector#matchExpressions
   */
  readonly matchExpressions?: PrometheusSpecServiceMonitorSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PrometheusSpecServiceMonitorSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'PrometheusSpecServiceMonitorSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecServiceMonitorSelector(obj: PrometheusSpecServiceMonitorSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_PrometheusSpecServiceMonitorSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Storage defines the storage used by Prometheus.
 *
 * @schema PrometheusSpecStorage
 */
export interface PrometheusSpecStorage {
  /**
   * Deprecated: subPath usage will be removed in a future release.
   *
   * @schema PrometheusSpecStorage#disableMountSubPath
   */
  readonly disableMountSubPath?: boolean;

  /**
   * EmptyDirVolumeSource to be used by the StatefulSet.
   * If specified, it takes precedence over `ephemeral` and `volumeClaimTemplate`.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes/#emptydir
   *
   * @schema PrometheusSpecStorage#emptyDir
   */
  readonly emptyDir?: PrometheusSpecStorageEmptyDir;

  /**
   * EphemeralVolumeSource to be used by the StatefulSet.
   * This is a beta field in k8s 1.21 and GA in 1.15.
   * For lower versions, starting with k8s 1.19, it requires enabling the GenericEphemeralVolume feature gate.
   * More info: https://kubernetes.io/docs/concepts/storage/ephemeral-volumes/#generic-ephemeral-volumes
   *
   * @schema PrometheusSpecStorage#ephemeral
   */
  readonly ephemeral?: PrometheusSpecStorageEphemeral;

  /**
   * Defines the PVC spec to be used by the Prometheus StatefulSets.
   * The easiest way to use a volume that cannot be automatically provisioned
   * is to use a label selector alongside manually created PersistentVolumes.
   *
   * @schema PrometheusSpecStorage#volumeClaimTemplate
   */
  readonly volumeClaimTemplate?: PrometheusSpecStorageVolumeClaimTemplate;

}

/**
 * Converts an object of type 'PrometheusSpecStorage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecStorage(obj: PrometheusSpecStorage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disableMountSubPath': obj.disableMountSubPath,
    'emptyDir': toJson_PrometheusSpecStorageEmptyDir(obj.emptyDir),
    'ephemeral': toJson_PrometheusSpecStorageEphemeral(obj.ephemeral),
    'volumeClaimTemplate': toJson_PrometheusSpecStorageVolumeClaimTemplate(obj.volumeClaimTemplate),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Defines the configuration of the optional Thanos sidecar.
 *
 * @schema PrometheusSpecThanos
 */
export interface PrometheusSpecThanos {
  /**
   * AdditionalArgs allows setting additional arguments for the Thanos container.
   * The arguments are passed as-is to the Thanos container which may cause issues
   * if they are invalid or not supported the given Thanos version.
   * In case of an argument conflict (e.g. an argument which is already set by the
   * operator itself) or when providing an invalid argument, the reconciliation will
   * fail and an error will be logged.
   *
   * @schema PrometheusSpecThanos#additionalArgs
   */
  readonly additionalArgs?: PrometheusSpecThanosAdditionalArgs[];

  /**
   * Deprecated: use 'image' instead.
   *
   * @schema PrometheusSpecThanos#baseImage
   */
  readonly baseImage?: string;

  /**
   * BlockDuration controls the size of TSDB blocks produced by Prometheus.
   * The default value is 2h to match the upstream Prometheus defaults.
   *
   *
   * WARNING: Changing the block duration can impact the performance and
   * efficiency of the entire Prometheus/Thanos stack due to how it interacts
   * with memory and Thanos compactors. It is recommended to keep this value
   * set to a multiple of 120 times your longest scrape or rule interval. For
   * example, 30s * 120 = 1h.
   *
   * @schema PrometheusSpecThanos#blockSize
   */
  readonly blockSize?: string;

  /**
   * How often to retrieve the Prometheus configuration.
   *
   * @schema PrometheusSpecThanos#getConfigInterval
   */
  readonly getConfigInterval?: string;

  /**
   * Maximum time to wait when retrieving the Prometheus configuration.
   *
   * @schema PrometheusSpecThanos#getConfigTimeout
   */
  readonly getConfigTimeout?: string;

  /**
   * When true, the Thanos sidecar listens on the loopback interface instead
   * of the Pod IP's address for the gRPC endpoints.
   *
   *
   * It has no effect if `listenLocal` is true.
   *
   * @schema PrometheusSpecThanos#grpcListenLocal
   */
  readonly grpcListenLocal?: boolean;

  /**
   * Configures the TLS parameters for the gRPC server providing the StoreAPI.
   *
   *
   * Note: Currently only the `caFile`, `certFile`, and `keyFile` fields are supported.
   *
   * @schema PrometheusSpecThanos#grpcServerTlsConfig
   */
  readonly grpcServerTlsConfig?: PrometheusSpecThanosGrpcServerTlsConfig;

  /**
   * When true, the Thanos sidecar listens on the loopback interface instead
   * of the Pod IP's address for the HTTP endpoints.
   *
   *
   * It has no effect if `listenLocal` is true.
   *
   * @schema PrometheusSpecThanos#httpListenLocal
   */
  readonly httpListenLocal?: boolean;

  /**
   * Container image name for Thanos. If specified, it takes precedence over
   * the `spec.thanos.baseImage`, `spec.thanos.tag` and `spec.thanos.sha`
   * fields.
   *
   *
   * Specifying `spec.thanos.version` is still necessary to ensure the
   * Prometheus Operator knows which version of Thanos is being configured.
   *
   *
   * If neither `spec.thanos.image` nor `spec.thanos.baseImage` are defined,
   * the operator will use the latest upstream version of Thanos available at
   * the time when the operator was released.
   *
   * @schema PrometheusSpecThanos#image
   */
  readonly image?: string;

  /**
   * Deprecated: use `grpcListenLocal` and `httpListenLocal` instead.
   *
   * @schema PrometheusSpecThanos#listenLocal
   */
  readonly listenLocal?: boolean;

  /**
   * Log format for the Thanos sidecar.
   *
   * @schema PrometheusSpecThanos#logFormat
   */
  readonly logFormat?: PrometheusSpecThanosLogFormat;

  /**
   * Log level for the Thanos sidecar.
   *
   * @schema PrometheusSpecThanos#logLevel
   */
  readonly logLevel?: PrometheusSpecThanosLogLevel;

  /**
   * Defines the start of time range limit served by the Thanos sidecar's StoreAPI.
   * The field's value should be a constant time in RFC3339 format or a time
   * duration relative to current time, such as -1d or 2h45m. Valid duration
   * units are ms, s, m, h, d, w, y.
   *
   * @schema PrometheusSpecThanos#minTime
   */
  readonly minTime?: string;

  /**
   * Defines the Thanos sidecar's configuration to upload TSDB blocks to object storage.
   *
   *
   * More info: https://thanos.io/tip/thanos/storage.md/
   *
   *
   * objectStorageConfigFile takes precedence over this field.
   *
   * @schema PrometheusSpecThanos#objectStorageConfig
   */
  readonly objectStorageConfig?: PrometheusSpecThanosObjectStorageConfig;

  /**
   * Defines the Thanos sidecar's configuration file to upload TSDB blocks to object storage.
   *
   *
   * More info: https://thanos.io/tip/thanos/storage.md/
   *
   *
   * This field takes precedence over objectStorageConfig.
   *
   * @schema PrometheusSpecThanos#objectStorageConfigFile
   */
  readonly objectStorageConfigFile?: string;

  /**
   * ReadyTimeout is the maximum time that the Thanos sidecar will wait for
   * Prometheus to start.
   *
   * @schema PrometheusSpecThanos#readyTimeout
   */
  readonly readyTimeout?: string;

  /**
   * Defines the resources requests and limits of the Thanos sidecar.
   *
   * @schema PrometheusSpecThanos#resources
   */
  readonly resources?: PrometheusSpecThanosResources;

  /**
   * Deprecated: use 'image' instead.  The image digest can be specified as part of the image name.
   *
   * @schema PrometheusSpecThanos#sha
   */
  readonly sha?: string;

  /**
   * Deprecated: use 'image' instead. The image's tag can be specified as as part of the image name.
   *
   * @schema PrometheusSpecThanos#tag
   */
  readonly tag?: string;

  /**
   * Defines the tracing configuration for the Thanos sidecar.
   *
   *
   * `tracingConfigFile` takes precedence over this field.
   *
   *
   * More info: https://thanos.io/tip/thanos/tracing.md/
   *
   *
   * This is an *experimental feature*, it may change in any upcoming release
   * in a breaking way.
   *
   * @schema PrometheusSpecThanos#tracingConfig
   */
  readonly tracingConfig?: PrometheusSpecThanosTracingConfig;

  /**
   * Defines the tracing configuration file for the Thanos sidecar.
   *
   *
   * This field takes precedence over `tracingConfig`.
   *
   *
   * More info: https://thanos.io/tip/thanos/tracing.md/
   *
   *
   * This is an *experimental feature*, it may change in any upcoming release
   * in a breaking way.
   *
   * @schema PrometheusSpecThanos#tracingConfigFile
   */
  readonly tracingConfigFile?: string;

  /**
   * Version of Thanos being deployed. The operator uses this information
   * to generate the Prometheus StatefulSet + configuration files.
   *
   *
   * If not specified, the operator assumes the latest upstream release of
   * Thanos available at the time when the version of the operator was
   * released.
   *
   * @schema PrometheusSpecThanos#version
   */
  readonly version?: string;

  /**
   * VolumeMounts allows configuration of additional VolumeMounts for Thanos.
   * VolumeMounts specified will be appended to other VolumeMounts in the
   * 'thanos-sidecar' container.
   *
   * @schema PrometheusSpecThanos#volumeMounts
   */
  readonly volumeMounts?: PrometheusSpecThanosVolumeMounts[];

}

/**
 * Converts an object of type 'PrometheusSpecThanos' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecThanos(obj: PrometheusSpecThanos | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalArgs': obj.additionalArgs?.map(y => toJson_PrometheusSpecThanosAdditionalArgs(y)),
    'baseImage': obj.baseImage,
    'blockSize': obj.blockSize,
    'getConfigInterval': obj.getConfigInterval,
    'getConfigTimeout': obj.getConfigTimeout,
    'grpcListenLocal': obj.grpcListenLocal,
    'grpcServerTlsConfig': toJson_PrometheusSpecThanosGrpcServerTlsConfig(obj.grpcServerTlsConfig),
    'httpListenLocal': obj.httpListenLocal,
    'image': obj.image,
    'listenLocal': obj.listenLocal,
    'logFormat': obj.logFormat,
    'logLevel': obj.logLevel,
    'minTime': obj.minTime,
    'objectStorageConfig': toJson_PrometheusSpecThanosObjectStorageConfig(obj.objectStorageConfig),
    'objectStorageConfigFile': obj.objectStorageConfigFile,
    'readyTimeout': obj.readyTimeout,
    'resources': toJson_PrometheusSpecThanosResources(obj.resources),
    'sha': obj.sha,
    'tag': obj.tag,
    'tracingConfig': toJson_PrometheusSpecThanosTracingConfig(obj.tracingConfig),
    'tracingConfigFile': obj.tracingConfigFile,
    'version': obj.version,
    'volumeMounts': obj.volumeMounts?.map(y => toJson_PrometheusSpecThanosVolumeMounts(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema PrometheusSpecTolerations
 */
export interface PrometheusSpecTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema PrometheusSpecTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema PrometheusSpecTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema PrometheusSpecTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict). Zero and
   * negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema PrometheusSpecTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema PrometheusSpecTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'PrometheusSpecTolerations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecTolerations(obj: PrometheusSpecTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PrometheusSpecTopologySpreadConstraints
 */
export interface PrometheusSpecTopologySpreadConstraints {
  /**
   * Defines what Prometheus Operator managed labels should be added to labelSelector on the topologySpreadConstraint.
   *
   * @schema PrometheusSpecTopologySpreadConstraints#additionalLabelSelectors
   */
  readonly additionalLabelSelectors?: PrometheusSpecTopologySpreadConstraintsAdditionalLabelSelectors;

  /**
   * LabelSelector is used to find matching pods.
   * Pods that match this label selector are counted to determine the number of pods
   * in their corresponding topology domain.
   *
   * @schema PrometheusSpecTopologySpreadConstraints#labelSelector
   */
  readonly labelSelector?: PrometheusSpecTopologySpreadConstraintsLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select the pods over which
   * spreading will be calculated. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are ANDed with labelSelector
   * to select the group of existing pods over which spreading will be calculated
   * for the incoming pod. The same key is forbidden to exist in both MatchLabelKeys and LabelSelector.
   * MatchLabelKeys cannot be set when LabelSelector isn't set.
   * Keys that don't exist in the incoming pod labels will
   * be ignored. A null or empty list means only match against labelSelector.
   *
   *
   * This is a beta field and requires the MatchLabelKeysInPodTopologySpread feature gate to be enabled (enabled by default).
   *
   * @schema PrometheusSpecTopologySpreadConstraints#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MaxSkew describes the degree to which pods may be unevenly distributed.
   * When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted difference
   * between the number of matching pods in the target topology and the global minimum.
   * The global minimum is the minimum number of matching pods in an eligible domain
   * or zero if the number of eligible domains is less than MinDomains.
   * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
   * labelSelector spread as 2/2/1:
   * In this case, the global minimum is 1.
   * | zone1 | zone2 | zone3 |
   * |  P P  |  P P  |   P   |
   * - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 2/2/2;
   * scheduling it onto zone1(zone2) would make the ActualSkew(3-1) on zone1(zone2)
   * violate MaxSkew(1).
   * - if MaxSkew is 2, incoming pod can be scheduled onto any zone.
   * When `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher precedence
   * to topologies that satisfy it.
   * It's a required field. Default value is 1 and 0 is not allowed.
   *
   * @schema PrometheusSpecTopologySpreadConstraints#maxSkew
   */
  readonly maxSkew: number;

  /**
   * MinDomains indicates a minimum number of eligible domains.
   * When the number of eligible domains with matching topology keys is less than minDomains,
   * Pod Topology Spread treats "global minimum" as 0, and then the calculation of Skew is performed.
   * And when the number of eligible domains with matching topology keys equals or greater than minDomains,
   * this value has no effect on scheduling.
   * As a result, when the number of eligible domains is less than minDomains,
   * scheduler won't schedule more than maxSkew Pods to those domains.
   * If value is nil, the constraint behaves as if MinDomains is equal to 1.
   * Valid values are integers greater than 0.
   * When value is not nil, WhenUnsatisfiable must be DoNotSchedule.
   *
   *
   * For example, in a 3-zone cluster, MaxSkew is set to 2, MinDomains is set to 5 and pods with the same
   * labelSelector spread as 2/2/2:
   * | zone1 | zone2 | zone3 |
   * |  P P  |  P P  |  P P  |
   * The number of domains is less than 5(MinDomains), so "global minimum" is treated as 0.
   * In this situation, new pod with the same labelSelector cannot be scheduled,
   * because computed skew will be 3(3 - 0) if new Pod is scheduled to any of the three zones,
   * it will violate MaxSkew.
   *
   *
   * This is a beta field and requires the MinDomainsInPodTopologySpread feature gate to be enabled (enabled by default).
   *
   * @schema PrometheusSpecTopologySpreadConstraints#minDomains
   */
  readonly minDomains?: number;

  /**
   * NodeAffinityPolicy indicates how we will treat Pod's nodeAffinity/nodeSelector
   * when calculating pod topology spread skew. Options are:
   * - Honor: only nodes matching nodeAffinity/nodeSelector are included in the calculations.
   * - Ignore: nodeAffinity/nodeSelector are ignored. All nodes are included in the calculations.
   *
   *
   * If this value is nil, the behavior is equivalent to the Honor policy.
   * This is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.
   *
   * @schema PrometheusSpecTopologySpreadConstraints#nodeAffinityPolicy
   */
  readonly nodeAffinityPolicy?: string;

  /**
   * NodeTaintsPolicy indicates how we will treat node taints when calculating
   * pod topology spread skew. Options are:
   * - Honor: nodes without taints, along with tainted nodes for which the incoming pod
   * has a toleration, are included.
   * - Ignore: node taints are ignored. All nodes are included.
   *
   *
   * If this value is nil, the behavior is equivalent to the Ignore policy.
   * This is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.
   *
   * @schema PrometheusSpecTopologySpreadConstraints#nodeTaintsPolicy
   */
  readonly nodeTaintsPolicy?: string;

  /**
   * TopologyKey is the key of node labels. Nodes that have a label with this key
   * and identical values are considered to be in the same topology.
   * We consider each <key, value> as a "bucket", and try to put balanced number
   * of pods into each bucket.
   * We define a domain as a particular instance of a topology.
   * Also, we define an eligible domain as a domain whose nodes meet the requirements of
   * nodeAffinityPolicy and nodeTaintsPolicy.
   * e.g. If TopologyKey is "kubernetes.io/hostname", each Node is a domain of that topology.
   * And, if TopologyKey is "topology.kubernetes.io/zone", each zone is a domain of that topology.
   * It's a required field.
   *
   * @schema PrometheusSpecTopologySpreadConstraints#topologyKey
   */
  readonly topologyKey: string;

  /**
   * WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy
   * the spread constraint.
   * - DoNotSchedule (default) tells the scheduler not to schedule it.
   * - ScheduleAnyway tells the scheduler to schedule the pod in any location,
   * but giving higher precedence to topologies that would help reduce the
   * skew.
   * A constraint is considered "Unsatisfiable" for an incoming pod
   * if and only if every possible node assignment for that pod would violate
   * "MaxSkew" on some topology.
   * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
   * labelSelector spread as 3/1/1:
   * | zone1 | zone2 | zone3 |
   * | P P P |   P   |   P   |
   * If WhenUnsatisfiable is set to DoNotSchedule, incoming pod can only be scheduled
   * to zone2(zone3) to become 3/2/1(3/1/2) as ActualSkew(2-1) on zone2(zone3) satisfies
   * MaxSkew(1). In other words, the cluster can still be imbalanced, but scheduler
   * won't make it *more* imbalanced.
   * It's a required field.
   *
   * @schema PrometheusSpecTopologySpreadConstraints#whenUnsatisfiable
   */
  readonly whenUnsatisfiable: string;

}

/**
 * Converts an object of type 'PrometheusSpecTopologySpreadConstraints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecTopologySpreadConstraints(obj: PrometheusSpecTopologySpreadConstraints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalLabelSelectors': obj.additionalLabelSelectors,
    'labelSelector': toJson_PrometheusSpecTopologySpreadConstraintsLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'maxSkew': obj.maxSkew,
    'minDomains': obj.minDomains,
    'nodeAffinityPolicy': obj.nodeAffinityPolicy,
    'nodeTaintsPolicy': obj.nodeTaintsPolicy,
    'topologyKey': obj.topologyKey,
    'whenUnsatisfiable': obj.whenUnsatisfiable,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TracingConfig configures tracing in Prometheus.
 *
 *
 * This is an *experimental feature*, it may change in any upcoming release
 * in a breaking way.
 *
 * @schema PrometheusSpecTracingConfig
 */
export interface PrometheusSpecTracingConfig {
  /**
   * Client used to export the traces. Supported values are `http` or `grpc`.
   *
   * @schema PrometheusSpecTracingConfig#clientType
   */
  readonly clientType?: PrometheusSpecTracingConfigClientType;

  /**
   * Compression key for supported compression types. The only supported value is `gzip`.
   *
   * @schema PrometheusSpecTracingConfig#compression
   */
  readonly compression?: PrometheusSpecTracingConfigCompression;

  /**
   * Endpoint to send the traces to. Should be provided in format <host>:<port>.
   *
   * @schema PrometheusSpecTracingConfig#endpoint
   */
  readonly endpoint: string;

  /**
   * Key-value pairs to be used as headers associated with gRPC or HTTP requests.
   *
   * @schema PrometheusSpecTracingConfig#headers
   */
  readonly headers?: { [key: string]: string };

  /**
   * If disabled, the client will use a secure connection.
   *
   * @schema PrometheusSpecTracingConfig#insecure
   */
  readonly insecure?: boolean;

  /**
   * Sets the probability a given trace will be sampled. Must be a float from 0 through 1.
   *
   * @schema PrometheusSpecTracingConfig#samplingFraction
   */
  readonly samplingFraction?: PrometheusSpecTracingConfigSamplingFraction;

  /**
   * Maximum time the exporter will wait for each batch export.
   *
   * @schema PrometheusSpecTracingConfig#timeout
   */
  readonly timeout?: string;

  /**
   * TLS Config to use when sending traces.
   *
   * @schema PrometheusSpecTracingConfig#tlsConfig
   */
  readonly tlsConfig?: PrometheusSpecTracingConfigTlsConfig;

}

/**
 * Converts an object of type 'PrometheusSpecTracingConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecTracingConfig(obj: PrometheusSpecTracingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientType': obj.clientType,
    'compression': obj.compression,
    'endpoint': obj.endpoint,
    'headers': ((obj.headers) === undefined) ? undefined : (Object.entries(obj.headers).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'insecure': obj.insecure,
    'samplingFraction': obj.samplingFraction?.value,
    'timeout': obj.timeout,
    'tlsConfig': toJson_PrometheusSpecTracingConfigTlsConfig(obj.tlsConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Defines the runtime reloadable configuration of the timeseries database
 * (TSDB).
 *
 * @schema PrometheusSpecTsdb
 */
export interface PrometheusSpecTsdb {
  /**
   * Configures how old an out-of-order/out-of-bounds sample can be with
   * respect to the TSDB max time.
   *
   *
   * An out-of-order/out-of-bounds sample is ingested into the TSDB as long as
   * the timestamp of the sample is >= (TSDB.MaxTime - outOfOrderTimeWindow).
   *
   *
   * This is an *experimental feature*, it may change in any upcoming release
   * in a breaking way.
   *
   *
   * It requires Prometheus >= v2.39.0.
   *
   * @schema PrometheusSpecTsdb#outOfOrderTimeWindow
   */
  readonly outOfOrderTimeWindow?: string;

}

/**
 * Converts an object of type 'PrometheusSpecTsdb' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecTsdb(obj: PrometheusSpecTsdb | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'outOfOrderTimeWindow': obj.outOfOrderTimeWindow,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema PrometheusSpecVolumeMounts
 */
export interface PrometheusSpecVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must
   * not contain ':'.
   *
   * @schema PrometheusSpecVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host
   * to container and the other way around.
   * When not set, MountPropagationNone is used.
   * This field is beta in 1.10.
   *
   * @schema PrometheusSpecVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema PrometheusSpecVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified).
   * Defaults to false.
   *
   * @default false.
   * @schema PrometheusSpecVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Path within the volume from which the container's volume should be mounted.
   * Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema PrometheusSpecVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted.
   * Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
   * Defaults to "" (volume's root).
   * SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root).
   * @schema PrometheusSpecVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;

}

/**
 * Converts an object of type 'PrometheusSpecVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumeMounts(obj: PrometheusSpecVolumeMounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'mountPropagation': obj.mountPropagation,
    'name': obj.name,
    'readOnly': obj.readOnly,
    'subPath': obj.subPath,
    'subPathExpr': obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Volume represents a named volume in a pod that may be accessed by any container in the pod.
 *
 * @schema PrometheusSpecVolumes
 */
export interface PrometheusSpecVolumes {
  /**
   * awsElasticBlockStore represents an AWS Disk resource that is attached to a
   * kubelet's host machine and then exposed to the pod.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema PrometheusSpecVolumes#awsElasticBlockStore
   */
  readonly awsElasticBlockStore?: PrometheusSpecVolumesAwsElasticBlockStore;

  /**
   * azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
   *
   * @schema PrometheusSpecVolumes#azureDisk
   */
  readonly azureDisk?: PrometheusSpecVolumesAzureDisk;

  /**
   * azureFile represents an Azure File Service mount on the host and bind mount to the pod.
   *
   * @schema PrometheusSpecVolumes#azureFile
   */
  readonly azureFile?: PrometheusSpecVolumesAzureFile;

  /**
   * cephFS represents a Ceph FS mount on the host that shares a pod's lifetime
   *
   * @schema PrometheusSpecVolumes#cephfs
   */
  readonly cephfs?: PrometheusSpecVolumesCephfs;

  /**
   * cinder represents a cinder volume attached and mounted on kubelets host machine.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema PrometheusSpecVolumes#cinder
   */
  readonly cinder?: PrometheusSpecVolumesCinder;

  /**
   * configMap represents a configMap that should populate this volume
   *
   * @schema PrometheusSpecVolumes#configMap
   */
  readonly configMap?: PrometheusSpecVolumesConfigMap;

  /**
   * csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers (Beta feature).
   *
   * @schema PrometheusSpecVolumes#csi
   */
  readonly csi?: PrometheusSpecVolumesCsi;

  /**
   * downwardAPI represents downward API about the pod that should populate this volume
   *
   * @schema PrometheusSpecVolumes#downwardAPI
   */
  readonly downwardApi?: PrometheusSpecVolumesDownwardApi;

  /**
   * emptyDir represents a temporary directory that shares a pod's lifetime.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema PrometheusSpecVolumes#emptyDir
   */
  readonly emptyDir?: PrometheusSpecVolumesEmptyDir;

  /**
   * ephemeral represents a volume that is handled by a cluster storage driver.
   * The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts,
   * and deleted when the pod is removed.
   *
   *
   * Use this if:
   * a) the volume is only needed while the pod runs,
   * b) features of normal volumes like restoring from snapshot or capacity
   * tracking are needed,
   * c) the storage driver is specified through a storage class, and
   * d) the storage driver supports dynamic volume provisioning through
   * a PersistentVolumeClaim (see EphemeralVolumeSource for more
   * information on the connection between this volume type
   * and PersistentVolumeClaim).
   *
   *
   * Use PersistentVolumeClaim or one of the vendor-specific
   * APIs for volumes that persist for longer than the lifecycle
   * of an individual pod.
   *
   *
   * Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to
   * be used that way - see the documentation of the driver for
   * more information.
   *
   *
   * A pod can use both types of ephemeral volumes and
   * persistent volumes at the same time.
   *
   * @schema PrometheusSpecVolumes#ephemeral
   */
  readonly ephemeral?: PrometheusSpecVolumesEphemeral;

  /**
   * fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
   *
   * @schema PrometheusSpecVolumes#fc
   */
  readonly fc?: PrometheusSpecVolumesFc;

  /**
   * flexVolume represents a generic volume resource that is
   * provisioned/attached using an exec based plugin.
   *
   * @schema PrometheusSpecVolumes#flexVolume
   */
  readonly flexVolume?: PrometheusSpecVolumesFlexVolume;

  /**
   * flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running
   *
   * @schema PrometheusSpecVolumes#flocker
   */
  readonly flocker?: PrometheusSpecVolumesFlocker;

  /**
   * gcePersistentDisk represents a GCE Disk resource that is attached to a
   * kubelet's host machine and then exposed to the pod.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema PrometheusSpecVolumes#gcePersistentDisk
   */
  readonly gcePersistentDisk?: PrometheusSpecVolumesGcePersistentDisk;

  /**
   * gitRepo represents a git repository at a particular revision.
   * DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an
   * EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir
   * into the Pod's container.
   *
   * @schema PrometheusSpecVolumes#gitRepo
   */
  readonly gitRepo?: PrometheusSpecVolumesGitRepo;

  /**
   * glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md
   *
   * @schema PrometheusSpecVolumes#glusterfs
   */
  readonly glusterfs?: PrometheusSpecVolumesGlusterfs;

  /**
   * hostPath represents a pre-existing file or directory on the host
   * machine that is directly exposed to the container. This is generally
   * used for system agents or other privileged things that are allowed
   * to see the host machine. Most containers will NOT need this.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   * ---
   * TODO(jonesdl) We need to restrict who can use host directory mounts and who can/can not
   * mount host directories as read/write.
   *
   * @schema PrometheusSpecVolumes#hostPath
   */
  readonly hostPath?: PrometheusSpecVolumesHostPath;

  /**
   * iscsi represents an ISCSI Disk resource that is attached to a
   * kubelet's host machine and then exposed to the pod.
   * More info: https://examples.k8s.io/volumes/iscsi/README.md
   *
   * @schema PrometheusSpecVolumes#iscsi
   */
  readonly iscsi?: PrometheusSpecVolumesIscsi;

  /**
   * name of the volume.
   * Must be a DNS_LABEL and unique within the pod.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema PrometheusSpecVolumes#name
   */
  readonly name: string;

  /**
   * nfs represents an NFS mount on the host that shares a pod's lifetime
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema PrometheusSpecVolumes#nfs
   */
  readonly nfs?: PrometheusSpecVolumesNfs;

  /**
   * persistentVolumeClaimVolumeSource represents a reference to a
   * PersistentVolumeClaim in the same namespace.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema PrometheusSpecVolumes#persistentVolumeClaim
   */
  readonly persistentVolumeClaim?: PrometheusSpecVolumesPersistentVolumeClaim;

  /**
   * photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
   *
   * @schema PrometheusSpecVolumes#photonPersistentDisk
   */
  readonly photonPersistentDisk?: PrometheusSpecVolumesPhotonPersistentDisk;

  /**
   * portworxVolume represents a portworx volume attached and mounted on kubelets host machine
   *
   * @schema PrometheusSpecVolumes#portworxVolume
   */
  readonly portworxVolume?: PrometheusSpecVolumesPortworxVolume;

  /**
   * projected items for all in one resources secrets, configmaps, and downward API
   *
   * @schema PrometheusSpecVolumes#projected
   */
  readonly projected?: PrometheusSpecVolumesProjected;

  /**
   * quobyte represents a Quobyte mount on the host that shares a pod's lifetime
   *
   * @schema PrometheusSpecVolumes#quobyte
   */
  readonly quobyte?: PrometheusSpecVolumesQuobyte;

  /**
   * rbd represents a Rados Block Device mount on the host that shares a pod's lifetime.
   * More info: https://examples.k8s.io/volumes/rbd/README.md
   *
   * @schema PrometheusSpecVolumes#rbd
   */
  readonly rbd?: PrometheusSpecVolumesRbd;

  /**
   * scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
   *
   * @schema PrometheusSpecVolumes#scaleIO
   */
  readonly scaleIo?: PrometheusSpecVolumesScaleIo;

  /**
   * secret represents a secret that should populate this volume.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   *
   * @schema PrometheusSpecVolumes#secret
   */
  readonly secret?: PrometheusSpecVolumesSecret;

  /**
   * storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
   *
   * @schema PrometheusSpecVolumes#storageos
   */
  readonly storageos?: PrometheusSpecVolumesStorageos;

  /**
   * vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
   *
   * @schema PrometheusSpecVolumes#vsphereVolume
   */
  readonly vsphereVolume?: PrometheusSpecVolumesVsphereVolume;

}

/**
 * Converts an object of type 'PrometheusSpecVolumes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumes(obj: PrometheusSpecVolumes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'awsElasticBlockStore': toJson_PrometheusSpecVolumesAwsElasticBlockStore(obj.awsElasticBlockStore),
    'azureDisk': toJson_PrometheusSpecVolumesAzureDisk(obj.azureDisk),
    'azureFile': toJson_PrometheusSpecVolumesAzureFile(obj.azureFile),
    'cephfs': toJson_PrometheusSpecVolumesCephfs(obj.cephfs),
    'cinder': toJson_PrometheusSpecVolumesCinder(obj.cinder),
    'configMap': toJson_PrometheusSpecVolumesConfigMap(obj.configMap),
    'csi': toJson_PrometheusSpecVolumesCsi(obj.csi),
    'downwardAPI': toJson_PrometheusSpecVolumesDownwardApi(obj.downwardApi),
    'emptyDir': toJson_PrometheusSpecVolumesEmptyDir(obj.emptyDir),
    'ephemeral': toJson_PrometheusSpecVolumesEphemeral(obj.ephemeral),
    'fc': toJson_PrometheusSpecVolumesFc(obj.fc),
    'flexVolume': toJson_PrometheusSpecVolumesFlexVolume(obj.flexVolume),
    'flocker': toJson_PrometheusSpecVolumesFlocker(obj.flocker),
    'gcePersistentDisk': toJson_PrometheusSpecVolumesGcePersistentDisk(obj.gcePersistentDisk),
    'gitRepo': toJson_PrometheusSpecVolumesGitRepo(obj.gitRepo),
    'glusterfs': toJson_PrometheusSpecVolumesGlusterfs(obj.glusterfs),
    'hostPath': toJson_PrometheusSpecVolumesHostPath(obj.hostPath),
    'iscsi': toJson_PrometheusSpecVolumesIscsi(obj.iscsi),
    'name': obj.name,
    'nfs': toJson_PrometheusSpecVolumesNfs(obj.nfs),
    'persistentVolumeClaim': toJson_PrometheusSpecVolumesPersistentVolumeClaim(obj.persistentVolumeClaim),
    'photonPersistentDisk': toJson_PrometheusSpecVolumesPhotonPersistentDisk(obj.photonPersistentDisk),
    'portworxVolume': toJson_PrometheusSpecVolumesPortworxVolume(obj.portworxVolume),
    'projected': toJson_PrometheusSpecVolumesProjected(obj.projected),
    'quobyte': toJson_PrometheusSpecVolumesQuobyte(obj.quobyte),
    'rbd': toJson_PrometheusSpecVolumesRbd(obj.rbd),
    'scaleIO': toJson_PrometheusSpecVolumesScaleIo(obj.scaleIo),
    'secret': toJson_PrometheusSpecVolumesSecret(obj.secret),
    'storageos': toJson_PrometheusSpecVolumesStorageos(obj.storageos),
    'vsphereVolume': toJson_PrometheusSpecVolumesVsphereVolume(obj.vsphereVolume),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Defines the configuration of the Prometheus web server.
 *
 * @schema PrometheusSpecWeb
 */
export interface PrometheusSpecWeb {
  /**
   * Defines HTTP parameters for web server.
   *
   * @schema PrometheusSpecWeb#httpConfig
   */
  readonly httpConfig?: PrometheusSpecWebHttpConfig;

  /**
   * Defines the maximum number of simultaneous connections
   * A zero value means that Prometheus doesn't accept any incoming connection.
   *
   * @schema PrometheusSpecWeb#maxConnections
   */
  readonly maxConnections?: number;

  /**
   * The prometheus web page title.
   *
   * @schema PrometheusSpecWeb#pageTitle
   */
  readonly pageTitle?: string;

  /**
   * Defines the TLS parameters for HTTPS.
   *
   * @schema PrometheusSpecWeb#tlsConfig
   */
  readonly tlsConfig?: PrometheusSpecWebTlsConfig;

}

/**
 * Converts an object of type 'PrometheusSpecWeb' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecWeb(obj: PrometheusSpecWeb | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpConfig': toJson_PrometheusSpecWebHttpConfig(obj.httpConfig),
    'maxConnections': obj.maxConnections,
    'pageTitle': obj.pageTitle,
    'tlsConfig': toJson_PrometheusSpecWebTlsConfig(obj.tlsConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Describes node affinity scheduling rules for the pod.
 *
 * @schema PrometheusSpecAffinityNodeAffinity
 */
export interface PrometheusSpecAffinityNodeAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node matches the corresponding matchExpressions; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema PrometheusSpecAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: PrometheusSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to an update), the system
   * may or may not try to eventually evict the pod from its node.
   *
   * @schema PrometheusSpecAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: PrometheusSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;

}

/**
 * Converts an object of type 'PrometheusSpecAffinityNodeAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAffinityNodeAffinity(obj: PrometheusSpecAffinityNodeAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_PrometheusSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': toJson_PrometheusSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj.requiredDuringSchedulingIgnoredDuringExecution),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
 *
 * @schema PrometheusSpecAffinityPodAffinity
 */
export interface PrometheusSpecAffinityPodAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema PrometheusSpecAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to a pod label update), the
   * system may or may not try to eventually evict the pod from its node.
   * When there are multiple elements, the lists of nodes corresponding to each
   * podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema PrometheusSpecAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'PrometheusSpecAffinityPodAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAffinityPodAffinity(obj: PrometheusSpecAffinityPodAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
 *
 * @schema PrometheusSpecAffinityPodAntiAffinity
 */
export interface PrometheusSpecAffinityPodAntiAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the anti-affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling anti-affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema PrometheusSpecAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the anti-affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the anti-affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to a pod label update), the
   * system may or may not try to eventually evict the pod from its node.
   * When there are multiple elements, the lists of nodes corresponding to each
   * podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema PrometheusSpecAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'PrometheusSpecAffinityPodAntiAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAffinityPodAntiAffinity(obj: PrometheusSpecAffinityPodAntiAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AlertmanagerEndpoints defines a selection of a single Endpoints object
 * containing Alertmanager IPs to fire alerts against.
 *
 * @schema PrometheusSpecAlertingAlertmanagers
 */
export interface PrometheusSpecAlertingAlertmanagers {
  /**
   * Relabeling configs applied before sending alerts to a specific Alertmanager.
   * It requires Prometheus >= v2.51.0.
   *
   * @schema PrometheusSpecAlertingAlertmanagers#alertRelabelings
   */
  readonly alertRelabelings?: PrometheusSpecAlertingAlertmanagersAlertRelabelings[];

  /**
   * Version of the Alertmanager API that Prometheus uses to send alerts.
   * It can be "v1" or "v2".
   *
   * @schema PrometheusSpecAlertingAlertmanagers#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Authorization section for Alertmanager.
   *
   *
   * Cannot be set at the same time as `basicAuth`, `bearerTokenFile` or `sigv4`.
   *
   * @schema PrometheusSpecAlertingAlertmanagers#authorization
   */
  readonly authorization?: PrometheusSpecAlertingAlertmanagersAuthorization;

  /**
   * BasicAuth configuration for Alertmanager.
   *
   *
   * Cannot be set at the same time as `bearerTokenFile`, `authorization` or `sigv4`.
   *
   * @schema PrometheusSpecAlertingAlertmanagers#basicAuth
   */
  readonly basicAuth?: PrometheusSpecAlertingAlertmanagersBasicAuth;

  /**
   * File to read bearer token for Alertmanager.
   *
   *
   * Cannot be set at the same time as `basicAuth`, `authorization`, or `sigv4`.
   *
   *
   * Deprecated: this will be removed in a future release. Prefer using `authorization`.
   *
   * @schema PrometheusSpecAlertingAlertmanagers#bearerTokenFile
   */
  readonly bearerTokenFile?: string;

  /**
   * Whether to enable HTTP2.
   *
   * @schema PrometheusSpecAlertingAlertmanagers#enableHttp2
   */
  readonly enableHttp2?: boolean;

  /**
   * Name of the Endpoints object in the namespace.
   *
   * @schema PrometheusSpecAlertingAlertmanagers#name
   */
  readonly name: string;

  /**
   * Namespace of the Endpoints object.
   *
   * @schema PrometheusSpecAlertingAlertmanagers#namespace
   */
  readonly namespace: string;

  /**
   * Prefix for the HTTP path alerts are pushed to.
   *
   * @schema PrometheusSpecAlertingAlertmanagers#pathPrefix
   */
  readonly pathPrefix?: string;

  /**
   * Port on which the Alertmanager API is exposed.
   *
   * @schema PrometheusSpecAlertingAlertmanagers#port
   */
  readonly port: PrometheusSpecAlertingAlertmanagersPort;

  /**
   * Relabel configuration applied to the discovered Alertmanagers.
   *
   * @schema PrometheusSpecAlertingAlertmanagers#relabelings
   */
  readonly relabelings?: PrometheusSpecAlertingAlertmanagersRelabelings[];

  /**
   * Scheme to use when firing alerts.
   *
   * @schema PrometheusSpecAlertingAlertmanagers#scheme
   */
  readonly scheme?: string;

  /**
   * Sigv4 allows to configures AWS's Signature Verification 4 for the URL.
   *
   *
   * It requires Prometheus >= v2.48.0.
   *
   *
   * Cannot be set at the same time as `basicAuth`, `bearerTokenFile` or `authorization`.
   *
   * @schema PrometheusSpecAlertingAlertmanagers#sigv4
   */
  readonly sigv4?: PrometheusSpecAlertingAlertmanagersSigv4;

  /**
   * Timeout is a per-target Alertmanager timeout when pushing alerts.
   *
   * @schema PrometheusSpecAlertingAlertmanagers#timeout
   */
  readonly timeout?: string;

  /**
   * TLS Config to use for Alertmanager.
   *
   * @schema PrometheusSpecAlertingAlertmanagers#tlsConfig
   */
  readonly tlsConfig?: PrometheusSpecAlertingAlertmanagersTlsConfig;

}

/**
 * Converts an object of type 'PrometheusSpecAlertingAlertmanagers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAlertingAlertmanagers(obj: PrometheusSpecAlertingAlertmanagers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alertRelabelings': obj.alertRelabelings?.map(y => toJson_PrometheusSpecAlertingAlertmanagersAlertRelabelings(y)),
    'apiVersion': obj.apiVersion,
    'authorization': toJson_PrometheusSpecAlertingAlertmanagersAuthorization(obj.authorization),
    'basicAuth': toJson_PrometheusSpecAlertingAlertmanagersBasicAuth(obj.basicAuth),
    'bearerTokenFile': obj.bearerTokenFile,
    'enableHttp2': obj.enableHttp2,
    'name': obj.name,
    'namespace': obj.namespace,
    'pathPrefix': obj.pathPrefix,
    'port': obj.port?.value,
    'relabelings': obj.relabelings?.map(y => toJson_PrometheusSpecAlertingAlertmanagersRelabelings(y)),
    'scheme': obj.scheme,
    'sigv4': toJson_PrometheusSpecAlertingAlertmanagersSigv4(obj.sigv4),
    'timeout': obj.timeout,
    'tlsConfig': toJson_PrometheusSpecAlertingAlertmanagersTlsConfig(obj.tlsConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Authorization section for the API server.
 *
 *
 * Cannot be set at the same time as `basicAuth`, `bearerToken`, or
 * `bearerTokenFile`.
 *
 * @schema PrometheusSpecApiserverConfigAuthorization
 */
export interface PrometheusSpecApiserverConfigAuthorization {
  /**
   * Selects a key of a Secret in the namespace that contains the credentials for authentication.
   *
   * @schema PrometheusSpecApiserverConfigAuthorization#credentials
   */
  readonly credentials?: PrometheusSpecApiserverConfigAuthorizationCredentials;

  /**
   * File to read a secret from, mutually exclusive with `credentials`.
   *
   * @schema PrometheusSpecApiserverConfigAuthorization#credentialsFile
   */
  readonly credentialsFile?: string;

  /**
   * Defines the authentication type. The value is case-insensitive.
   *
   *
   * "Basic" is not a supported value.
   *
   *
   * Default: "Bearer"
   *
   * @schema PrometheusSpecApiserverConfigAuthorization#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'PrometheusSpecApiserverConfigAuthorization' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecApiserverConfigAuthorization(obj: PrometheusSpecApiserverConfigAuthorization | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentials': toJson_PrometheusSpecApiserverConfigAuthorizationCredentials(obj.credentials),
    'credentialsFile': obj.credentialsFile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BasicAuth configuration for the API server.
 *
 *
 * Cannot be set at the same time as `authorization`, `bearerToken`, or
 * `bearerTokenFile`.
 *
 * @schema PrometheusSpecApiserverConfigBasicAuth
 */
export interface PrometheusSpecApiserverConfigBasicAuth {
  /**
   * `password` specifies a key of a Secret containing the password for
   * authentication.
   *
   * @schema PrometheusSpecApiserverConfigBasicAuth#password
   */
  readonly password?: PrometheusSpecApiserverConfigBasicAuthPassword;

  /**
   * `username` specifies a key of a Secret containing the username for
   * authentication.
   *
   * @schema PrometheusSpecApiserverConfigBasicAuth#username
   */
  readonly username?: PrometheusSpecApiserverConfigBasicAuthUsername;

}

/**
 * Converts an object of type 'PrometheusSpecApiserverConfigBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecApiserverConfigBasicAuth(obj: PrometheusSpecApiserverConfigBasicAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_PrometheusSpecApiserverConfigBasicAuthPassword(obj.password),
    'username': toJson_PrometheusSpecApiserverConfigBasicAuthUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLS Config to use for the API server.
 *
 * @schema PrometheusSpecApiserverConfigTlsConfig
 */
export interface PrometheusSpecApiserverConfigTlsConfig {
  /**
   * Certificate authority used when verifying server certificates.
   *
   * @schema PrometheusSpecApiserverConfigTlsConfig#ca
   */
  readonly ca?: PrometheusSpecApiserverConfigTlsConfigCa;

  /**
   * Path to the CA cert in the Prometheus container to use for the targets.
   *
   * @schema PrometheusSpecApiserverConfigTlsConfig#caFile
   */
  readonly caFile?: string;

  /**
   * Client certificate to present when doing client-authentication.
   *
   * @schema PrometheusSpecApiserverConfigTlsConfig#cert
   */
  readonly cert?: PrometheusSpecApiserverConfigTlsConfigCert;

  /**
   * Path to the client cert file in the Prometheus container for the targets.
   *
   * @schema PrometheusSpecApiserverConfigTlsConfig#certFile
   */
  readonly certFile?: string;

  /**
   * Disable target certificate validation.
   *
   * @schema PrometheusSpecApiserverConfigTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Path to the client key file in the Prometheus container for the targets.
   *
   * @schema PrometheusSpecApiserverConfigTlsConfig#keyFile
   */
  readonly keyFile?: string;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema PrometheusSpecApiserverConfigTlsConfig#keySecret
   */
  readonly keySecret?: PrometheusSpecApiserverConfigTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema PrometheusSpecApiserverConfigTlsConfig#serverName
   */
  readonly serverName?: string;

}

/**
 * Converts an object of type 'PrometheusSpecApiserverConfigTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecApiserverConfigTlsConfig(obj: PrometheusSpecApiserverConfigTlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ca': toJson_PrometheusSpecApiserverConfigTlsConfigCa(obj.ca),
    'caFile': obj.caFile,
    'cert': toJson_PrometheusSpecApiserverConfigTlsConfigCert(obj.cert),
    'certFile': obj.certFile,
    'insecureSkipVerify': obj.insecureSkipVerify,
    'keyFile': obj.keyFile,
    'keySecret': toJson_PrometheusSpecApiserverConfigTlsConfigKeySecret(obj.keySecret),
    'serverName': obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema PrometheusSpecContainersEnv
 */
export interface PrometheusSpecContainersEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema PrometheusSpecContainersEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded
   * using the previously defined environment variables in the container and
   * any service environment variables. If a variable cannot be resolved,
   * the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
   * "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
   * Escaped references will never be expanded, regardless of whether the variable
   * exists or not.
   * Defaults to "".
   *
   * @default .
   * @schema PrometheusSpecContainersEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema PrometheusSpecContainersEnv#valueFrom
   */
  readonly valueFrom?: PrometheusSpecContainersEnvValueFrom;

}

/**
 * Converts an object of type 'PrometheusSpecContainersEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersEnv(obj: PrometheusSpecContainersEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
    'valueFrom': toJson_PrometheusSpecContainersEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema PrometheusSpecContainersEnvFrom
 */
export interface PrometheusSpecContainersEnvFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema PrometheusSpecContainersEnvFrom#configMapRef
   */
  readonly configMapRef?: PrometheusSpecContainersEnvFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema PrometheusSpecContainersEnvFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema PrometheusSpecContainersEnvFrom#secretRef
   */
  readonly secretRef?: PrometheusSpecContainersEnvFromSecretRef;

}

/**
 * Converts an object of type 'PrometheusSpecContainersEnvFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersEnvFrom(obj: PrometheusSpecContainersEnvFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapRef': toJson_PrometheusSpecContainersEnvFromConfigMapRef(obj.configMapRef),
    'prefix': obj.prefix,
    'secretRef': toJson_PrometheusSpecContainersEnvFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Actions that the management system should take in response to container lifecycle events.
 * Cannot be updated.
 *
 * @schema PrometheusSpecContainersLifecycle
 */
export interface PrometheusSpecContainersLifecycle {
  /**
   * PostStart is called immediately after a container is created. If the handler fails,
   * the container is terminated and restarted according to its restart policy.
   * Other management of the container blocks until the hook completes.
   * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema PrometheusSpecContainersLifecycle#postStart
   */
  readonly postStart?: PrometheusSpecContainersLifecyclePostStart;

  /**
   * PreStop is called immediately before a container is terminated due to an
   * API request or management event such as liveness/startup probe failure,
   * preemption, resource contention, etc. The handler is not called if the
   * container crashes or exits. The Pod's termination grace period countdown begins before the
   * PreStop hook is executed. Regardless of the outcome of the handler, the
   * container will eventually terminate within the Pod's termination grace
   * period (unless delayed by finalizers). Other management of the container blocks until the hook completes
   * or until the termination grace period is reached.
   * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema PrometheusSpecContainersLifecycle#preStop
   */
  readonly preStop?: PrometheusSpecContainersLifecyclePreStop;

}

/**
 * Converts an object of type 'PrometheusSpecContainersLifecycle' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersLifecycle(obj: PrometheusSpecContainersLifecycle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'postStart': toJson_PrometheusSpecContainersLifecyclePostStart(obj.postStart),
    'preStop': toJson_PrometheusSpecContainersLifecyclePreStop(obj.preStop),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Periodic probe of container liveness.
 * Container will be restarted if the probe fails.
 * Cannot be updated.
 * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema PrometheusSpecContainersLivenessProbe
 */
export interface PrometheusSpecContainersLivenessProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema PrometheusSpecContainersLivenessProbe#exec
   */
  readonly exec?: PrometheusSpecContainersLivenessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   * Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema PrometheusSpecContainersLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port.
   *
   * @schema PrometheusSpecContainersLivenessProbe#grpc
   */
  readonly grpc?: PrometheusSpecContainersLivenessProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema PrometheusSpecContainersLivenessProbe#httpGet
   */
  readonly httpGet?: PrometheusSpecContainersLivenessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema PrometheusSpecContainersLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe.
   * Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema PrometheusSpecContainersLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema PrometheusSpecContainersLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema PrometheusSpecContainersLivenessProbe#tcpSocket
   */
  readonly tcpSocket?: PrometheusSpecContainersLivenessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
   * value overrides the value provided by the pod spec.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
   * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema PrometheusSpecContainersLivenessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out.
   * Defaults to 1 second. Minimum value is 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1.
   * @schema PrometheusSpecContainersLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'PrometheusSpecContainersLivenessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersLivenessProbe(obj: PrometheusSpecContainersLivenessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_PrometheusSpecContainersLivenessProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_PrometheusSpecContainersLivenessProbeGrpc(obj.grpc),
    'httpGet': toJson_PrometheusSpecContainersLivenessProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_PrometheusSpecContainersLivenessProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ContainerPort represents a network port in a single container.
 *
 * @schema PrometheusSpecContainersPorts
 */
export interface PrometheusSpecContainersPorts {
  /**
   * Number of port to expose on the pod's IP address.
   * This must be a valid port number, 0 < x < 65536.
   *
   * @schema PrometheusSpecContainersPorts#containerPort
   */
  readonly containerPort: number;

  /**
   * What host IP to bind the external port to.
   *
   * @schema PrometheusSpecContainersPorts#hostIP
   */
  readonly hostIp?: string;

  /**
   * Number of port to expose on the host.
   * If specified, this must be a valid port number, 0 < x < 65536.
   * If HostNetwork is specified, this must match ContainerPort.
   * Most containers do not need this.
   *
   * @schema PrometheusSpecContainersPorts#hostPort
   */
  readonly hostPort?: number;

  /**
   * If specified, this must be an IANA_SVC_NAME and unique within the pod. Each
   * named port in a pod must have a unique name. Name for the port that can be
   * referred to by services.
   *
   * @schema PrometheusSpecContainersPorts#name
   */
  readonly name?: string;

  /**
   * Protocol for port. Must be UDP, TCP, or SCTP.
   * Defaults to "TCP".
   *
   * @default TCP".
   * @schema PrometheusSpecContainersPorts#protocol
   */
  readonly protocol?: string;

}

/**
 * Converts an object of type 'PrometheusSpecContainersPorts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersPorts(obj: PrometheusSpecContainersPorts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerPort': obj.containerPort,
    'hostIP': obj.hostIp,
    'hostPort': obj.hostPort,
    'name': obj.name,
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Periodic probe of container service readiness.
 * Container will be removed from service endpoints if the probe fails.
 * Cannot be updated.
 * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema PrometheusSpecContainersReadinessProbe
 */
export interface PrometheusSpecContainersReadinessProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema PrometheusSpecContainersReadinessProbe#exec
   */
  readonly exec?: PrometheusSpecContainersReadinessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   * Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema PrometheusSpecContainersReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port.
   *
   * @schema PrometheusSpecContainersReadinessProbe#grpc
   */
  readonly grpc?: PrometheusSpecContainersReadinessProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema PrometheusSpecContainersReadinessProbe#httpGet
   */
  readonly httpGet?: PrometheusSpecContainersReadinessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema PrometheusSpecContainersReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe.
   * Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema PrometheusSpecContainersReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema PrometheusSpecContainersReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema PrometheusSpecContainersReadinessProbe#tcpSocket
   */
  readonly tcpSocket?: PrometheusSpecContainersReadinessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
   * value overrides the value provided by the pod spec.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
   * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema PrometheusSpecContainersReadinessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out.
   * Defaults to 1 second. Minimum value is 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1.
   * @schema PrometheusSpecContainersReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'PrometheusSpecContainersReadinessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersReadinessProbe(obj: PrometheusSpecContainersReadinessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_PrometheusSpecContainersReadinessProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_PrometheusSpecContainersReadinessProbeGrpc(obj.grpc),
    'httpGet': toJson_PrometheusSpecContainersReadinessProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_PrometheusSpecContainersReadinessProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ContainerResizePolicy represents resource resize policy for the container.
 *
 * @schema PrometheusSpecContainersResizePolicy
 */
export interface PrometheusSpecContainersResizePolicy {
  /**
   * Name of the resource to which this resource resize policy applies.
   * Supported values: cpu, memory.
   *
   * @schema PrometheusSpecContainersResizePolicy#resourceName
   */
  readonly resourceName: string;

  /**
   * Restart policy to apply when specified resource is resized.
   * If not specified, it defaults to NotRequired.
   *
   * @schema PrometheusSpecContainersResizePolicy#restartPolicy
   */
  readonly restartPolicy: string;

}

/**
 * Converts an object of type 'PrometheusSpecContainersResizePolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersResizePolicy(obj: PrometheusSpecContainersResizePolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resourceName': obj.resourceName,
    'restartPolicy': obj.restartPolicy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Compute Resources required by this container.
 * Cannot be updated.
 * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
 *
 * @schema PrometheusSpecContainersResources
 */
export interface PrometheusSpecContainersResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema PrometheusSpecContainersResources#claims
   */
  readonly claims?: PrometheusSpecContainersResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema PrometheusSpecContainersResources#limits
   */
  readonly limits?: { [key: string]: PrometheusSpecContainersResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema PrometheusSpecContainersResources#requests
   */
  readonly requests?: { [key: string]: PrometheusSpecContainersResourcesRequests };

}

/**
 * Converts an object of type 'PrometheusSpecContainersResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersResources(obj: PrometheusSpecContainersResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claims': obj.claims?.map(y => toJson_PrometheusSpecContainersResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecurityContext defines the security options the container should be run with.
 * If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
 * More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
 *
 * @schema PrometheusSpecContainersSecurityContext
 */
export interface PrometheusSpecContainersSecurityContext {
  /**
   * AllowPrivilegeEscalation controls whether a process can gain more
   * privileges than its parent process. This bool directly controls if
   * the no_new_privs flag will be set on the container process.
   * AllowPrivilegeEscalation is true always when the container is:
   * 1) run as Privileged
   * 2) has CAP_SYS_ADMIN
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PrometheusSpecContainersSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * The capabilities to add/drop when running containers.
   * Defaults to the default set of capabilities granted by the container runtime.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default the default set of capabilities granted by the container runtime.
   * @schema PrometheusSpecContainersSecurityContext#capabilities
   */
  readonly capabilities?: PrometheusSpecContainersSecurityContextCapabilities;

  /**
   * Run container in privileged mode.
   * Processes in privileged containers are essentially equivalent to root on the host.
   * Defaults to false.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false.
   * @schema PrometheusSpecContainersSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * procMount denotes the type of proc mount to use for the containers.
   * The default is DefaultProcMount which uses the container runtime defaults for
   * readonly paths and masked paths.
   * This requires the ProcMountType feature flag to be enabled.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PrometheusSpecContainersSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * Whether this container has a read-only root filesystem.
   * Default is false.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false.
   * @schema PrometheusSpecContainersSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * The GID to run the entrypoint of the container process.
   * Uses runtime default if unset.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PrometheusSpecContainersSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user.
   * If true, the Kubelet will validate the image at runtime to ensure that it
   * does not run as UID 0 (root) and fail to start the container if it does.
   * If unset or false, no such validation will be performed.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema PrometheusSpecContainersSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process.
   * Defaults to user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified.
   * @schema PrometheusSpecContainersSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to the container.
   * If unspecified, the container runtime will allocate a random SELinux context for each
   * container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PrometheusSpecContainersSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: PrometheusSpecContainersSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by this container. If seccomp options are
   * provided at both the pod & container level, the container options
   * override the pod options.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PrometheusSpecContainersSecurityContext#seccompProfile
   */
  readonly seccompProfile?: PrometheusSpecContainersSecurityContextSeccompProfile;

  /**
   * The Windows specific settings applied to all containers.
   * If unspecified, the options from the PodSecurityContext will be used.
   * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema PrometheusSpecContainersSecurityContext#windowsOptions
   */
  readonly windowsOptions?: PrometheusSpecContainersSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'PrometheusSpecContainersSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersSecurityContext(obj: PrometheusSpecContainersSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowPrivilegeEscalation': obj.allowPrivilegeEscalation,
    'capabilities': toJson_PrometheusSpecContainersSecurityContextCapabilities(obj.capabilities),
    'privileged': obj.privileged,
    'procMount': obj.procMount,
    'readOnlyRootFilesystem': obj.readOnlyRootFilesystem,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_PrometheusSpecContainersSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_PrometheusSpecContainersSecurityContextSeccompProfile(obj.seccompProfile),
    'windowsOptions': toJson_PrometheusSpecContainersSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * StartupProbe indicates that the Pod has successfully initialized.
 * If specified, no other probes are executed until this completes successfully.
 * If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
 * This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
 * when it might take a long time to load data or warm a cache, than during steady-state operation.
 * This cannot be updated.
 * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema PrometheusSpecContainersStartupProbe
 */
export interface PrometheusSpecContainersStartupProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema PrometheusSpecContainersStartupProbe#exec
   */
  readonly exec?: PrometheusSpecContainersStartupProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   * Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema PrometheusSpecContainersStartupProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port.
   *
   * @schema PrometheusSpecContainersStartupProbe#grpc
   */
  readonly grpc?: PrometheusSpecContainersStartupProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema PrometheusSpecContainersStartupProbe#httpGet
   */
  readonly httpGet?: PrometheusSpecContainersStartupProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema PrometheusSpecContainersStartupProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe.
   * Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema PrometheusSpecContainersStartupProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema PrometheusSpecContainersStartupProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema PrometheusSpecContainersStartupProbe#tcpSocket
   */
  readonly tcpSocket?: PrometheusSpecContainersStartupProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
   * value overrides the value provided by the pod spec.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
   * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema PrometheusSpecContainersStartupProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out.
   * Defaults to 1 second. Minimum value is 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1.
   * @schema PrometheusSpecContainersStartupProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'PrometheusSpecContainersStartupProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersStartupProbe(obj: PrometheusSpecContainersStartupProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_PrometheusSpecContainersStartupProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_PrometheusSpecContainersStartupProbeGrpc(obj.grpc),
    'httpGet': toJson_PrometheusSpecContainersStartupProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_PrometheusSpecContainersStartupProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * volumeDevice describes a mapping of a raw block device within a container.
 *
 * @schema PrometheusSpecContainersVolumeDevices
 */
export interface PrometheusSpecContainersVolumeDevices {
  /**
   * devicePath is the path inside of the container that the device will be mapped to.
   *
   * @schema PrometheusSpecContainersVolumeDevices#devicePath
   */
  readonly devicePath: string;

  /**
   * name must match the name of a persistentVolumeClaim in the pod
   *
   * @schema PrometheusSpecContainersVolumeDevices#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'PrometheusSpecContainersVolumeDevices' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersVolumeDevices(obj: PrometheusSpecContainersVolumeDevices | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'devicePath': obj.devicePath,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema PrometheusSpecContainersVolumeMounts
 */
export interface PrometheusSpecContainersVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must
   * not contain ':'.
   *
   * @schema PrometheusSpecContainersVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host
   * to container and the other way around.
   * When not set, MountPropagationNone is used.
   * This field is beta in 1.10.
   *
   * @schema PrometheusSpecContainersVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema PrometheusSpecContainersVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified).
   * Defaults to false.
   *
   * @default false.
   * @schema PrometheusSpecContainersVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Path within the volume from which the container's volume should be mounted.
   * Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema PrometheusSpecContainersVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted.
   * Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
   * Defaults to "" (volume's root).
   * SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root).
   * @schema PrometheusSpecContainersVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;

}

/**
 * Converts an object of type 'PrometheusSpecContainersVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersVolumeMounts(obj: PrometheusSpecContainersVolumeMounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'mountPropagation': obj.mountPropagation,
    'name': obj.name,
    'readOnly': obj.readOnly,
    'subPath': obj.subPath,
    'subPathExpr': obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Group of the referent. When not specified, it defaults to `monitoring.coreos.com`
 *
 * @schema PrometheusSpecExcludedFromEnforcementGroup
 */
export enum PrometheusSpecExcludedFromEnforcementGroup {
  /** monitoring.coreos.com */
  MONITORING_PERIOD_COREOS_PERIOD_COM = "monitoring.coreos.com",
}

/**
 * Resource of the referent.
 *
 * @schema PrometheusSpecExcludedFromEnforcementResource
 */
export enum PrometheusSpecExcludedFromEnforcementResource {
  /** prometheusrules */
  PROMETHEUSRULES = "prometheusrules",
  /** servicemonitors */
  SERVICEMONITORS = "servicemonitors",
  /** podmonitors */
  PODMONITORS = "podmonitors",
  /** probes */
  PROBES = "probes",
  /** scrapeconfigs */
  SCRAPECONFIGS = "scrapeconfigs",
}

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema PrometheusSpecInitContainersEnv
 */
export interface PrometheusSpecInitContainersEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema PrometheusSpecInitContainersEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded
   * using the previously defined environment variables in the container and
   * any service environment variables. If a variable cannot be resolved,
   * the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
   * "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
   * Escaped references will never be expanded, regardless of whether the variable
   * exists or not.
   * Defaults to "".
   *
   * @default .
   * @schema PrometheusSpecInitContainersEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema PrometheusSpecInitContainersEnv#valueFrom
   */
  readonly valueFrom?: PrometheusSpecInitContainersEnvValueFrom;

}

/**
 * Converts an object of type 'PrometheusSpecInitContainersEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersEnv(obj: PrometheusSpecInitContainersEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
    'valueFrom': toJson_PrometheusSpecInitContainersEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema PrometheusSpecInitContainersEnvFrom
 */
export interface PrometheusSpecInitContainersEnvFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema PrometheusSpecInitContainersEnvFrom#configMapRef
   */
  readonly configMapRef?: PrometheusSpecInitContainersEnvFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema PrometheusSpecInitContainersEnvFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema PrometheusSpecInitContainersEnvFrom#secretRef
   */
  readonly secretRef?: PrometheusSpecInitContainersEnvFromSecretRef;

}

/**
 * Converts an object of type 'PrometheusSpecInitContainersEnvFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersEnvFrom(obj: PrometheusSpecInitContainersEnvFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapRef': toJson_PrometheusSpecInitContainersEnvFromConfigMapRef(obj.configMapRef),
    'prefix': obj.prefix,
    'secretRef': toJson_PrometheusSpecInitContainersEnvFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Actions that the management system should take in response to container lifecycle events.
 * Cannot be updated.
 *
 * @schema PrometheusSpecInitContainersLifecycle
 */
export interface PrometheusSpecInitContainersLifecycle {
  /**
   * PostStart is called immediately after a container is created. If the handler fails,
   * the container is terminated and restarted according to its restart policy.
   * Other management of the container blocks until the hook completes.
   * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema PrometheusSpecInitContainersLifecycle#postStart
   */
  readonly postStart?: PrometheusSpecInitContainersLifecyclePostStart;

  /**
   * PreStop is called immediately before a container is terminated due to an
   * API request or management event such as liveness/startup probe failure,
   * preemption, resource contention, etc. The handler is not called if the
   * container crashes or exits. The Pod's termination grace period countdown begins before the
   * PreStop hook is executed. Regardless of the outcome of the handler, the
   * container will eventually terminate within the Pod's termination grace
   * period (unless delayed by finalizers). Other management of the container blocks until the hook completes
   * or until the termination grace period is reached.
   * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema PrometheusSpecInitContainersLifecycle#preStop
   */
  readonly preStop?: PrometheusSpecInitContainersLifecyclePreStop;

}

/**
 * Converts an object of type 'PrometheusSpecInitContainersLifecycle' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersLifecycle(obj: PrometheusSpecInitContainersLifecycle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'postStart': toJson_PrometheusSpecInitContainersLifecyclePostStart(obj.postStart),
    'preStop': toJson_PrometheusSpecInitContainersLifecyclePreStop(obj.preStop),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Periodic probe of container liveness.
 * Container will be restarted if the probe fails.
 * Cannot be updated.
 * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema PrometheusSpecInitContainersLivenessProbe
 */
export interface PrometheusSpecInitContainersLivenessProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema PrometheusSpecInitContainersLivenessProbe#exec
   */
  readonly exec?: PrometheusSpecInitContainersLivenessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   * Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema PrometheusSpecInitContainersLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port.
   *
   * @schema PrometheusSpecInitContainersLivenessProbe#grpc
   */
  readonly grpc?: PrometheusSpecInitContainersLivenessProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema PrometheusSpecInitContainersLivenessProbe#httpGet
   */
  readonly httpGet?: PrometheusSpecInitContainersLivenessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema PrometheusSpecInitContainersLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe.
   * Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema PrometheusSpecInitContainersLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema PrometheusSpecInitContainersLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema PrometheusSpecInitContainersLivenessProbe#tcpSocket
   */
  readonly tcpSocket?: PrometheusSpecInitContainersLivenessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
   * value overrides the value provided by the pod spec.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
   * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema PrometheusSpecInitContainersLivenessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out.
   * Defaults to 1 second. Minimum value is 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1.
   * @schema PrometheusSpecInitContainersLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'PrometheusSpecInitContainersLivenessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersLivenessProbe(obj: PrometheusSpecInitContainersLivenessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_PrometheusSpecInitContainersLivenessProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_PrometheusSpecInitContainersLivenessProbeGrpc(obj.grpc),
    'httpGet': toJson_PrometheusSpecInitContainersLivenessProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_PrometheusSpecInitContainersLivenessProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ContainerPort represents a network port in a single container.
 *
 * @schema PrometheusSpecInitContainersPorts
 */
export interface PrometheusSpecInitContainersPorts {
  /**
   * Number of port to expose on the pod's IP address.
   * This must be a valid port number, 0 < x < 65536.
   *
   * @schema PrometheusSpecInitContainersPorts#containerPort
   */
  readonly containerPort: number;

  /**
   * What host IP to bind the external port to.
   *
   * @schema PrometheusSpecInitContainersPorts#hostIP
   */
  readonly hostIp?: string;

  /**
   * Number of port to expose on the host.
   * If specified, this must be a valid port number, 0 < x < 65536.
   * If HostNetwork is specified, this must match ContainerPort.
   * Most containers do not need this.
   *
   * @schema PrometheusSpecInitContainersPorts#hostPort
   */
  readonly hostPort?: number;

  /**
   * If specified, this must be an IANA_SVC_NAME and unique within the pod. Each
   * named port in a pod must have a unique name. Name for the port that can be
   * referred to by services.
   *
   * @schema PrometheusSpecInitContainersPorts#name
   */
  readonly name?: string;

  /**
   * Protocol for port. Must be UDP, TCP, or SCTP.
   * Defaults to "TCP".
   *
   * @default TCP".
   * @schema PrometheusSpecInitContainersPorts#protocol
   */
  readonly protocol?: string;

}

/**
 * Converts an object of type 'PrometheusSpecInitContainersPorts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersPorts(obj: PrometheusSpecInitContainersPorts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerPort': obj.containerPort,
    'hostIP': obj.hostIp,
    'hostPort': obj.hostPort,
    'name': obj.name,
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Periodic probe of container service readiness.
 * Container will be removed from service endpoints if the probe fails.
 * Cannot be updated.
 * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema PrometheusSpecInitContainersReadinessProbe
 */
export interface PrometheusSpecInitContainersReadinessProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema PrometheusSpecInitContainersReadinessProbe#exec
   */
  readonly exec?: PrometheusSpecInitContainersReadinessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   * Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema PrometheusSpecInitContainersReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port.
   *
   * @schema PrometheusSpecInitContainersReadinessProbe#grpc
   */
  readonly grpc?: PrometheusSpecInitContainersReadinessProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema PrometheusSpecInitContainersReadinessProbe#httpGet
   */
  readonly httpGet?: PrometheusSpecInitContainersReadinessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema PrometheusSpecInitContainersReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe.
   * Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema PrometheusSpecInitContainersReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema PrometheusSpecInitContainersReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema PrometheusSpecInitContainersReadinessProbe#tcpSocket
   */
  readonly tcpSocket?: PrometheusSpecInitContainersReadinessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
   * value overrides the value provided by the pod spec.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
   * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema PrometheusSpecInitContainersReadinessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out.
   * Defaults to 1 second. Minimum value is 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1.
   * @schema PrometheusSpecInitContainersReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'PrometheusSpecInitContainersReadinessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersReadinessProbe(obj: PrometheusSpecInitContainersReadinessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_PrometheusSpecInitContainersReadinessProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_PrometheusSpecInitContainersReadinessProbeGrpc(obj.grpc),
    'httpGet': toJson_PrometheusSpecInitContainersReadinessProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_PrometheusSpecInitContainersReadinessProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ContainerResizePolicy represents resource resize policy for the container.
 *
 * @schema PrometheusSpecInitContainersResizePolicy
 */
export interface PrometheusSpecInitContainersResizePolicy {
  /**
   * Name of the resource to which this resource resize policy applies.
   * Supported values: cpu, memory.
   *
   * @schema PrometheusSpecInitContainersResizePolicy#resourceName
   */
  readonly resourceName: string;

  /**
   * Restart policy to apply when specified resource is resized.
   * If not specified, it defaults to NotRequired.
   *
   * @schema PrometheusSpecInitContainersResizePolicy#restartPolicy
   */
  readonly restartPolicy: string;

}

/**
 * Converts an object of type 'PrometheusSpecInitContainersResizePolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersResizePolicy(obj: PrometheusSpecInitContainersResizePolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resourceName': obj.resourceName,
    'restartPolicy': obj.restartPolicy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Compute Resources required by this container.
 * Cannot be updated.
 * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
 *
 * @schema PrometheusSpecInitContainersResources
 */
export interface PrometheusSpecInitContainersResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema PrometheusSpecInitContainersResources#claims
   */
  readonly claims?: PrometheusSpecInitContainersResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema PrometheusSpecInitContainersResources#limits
   */
  readonly limits?: { [key: string]: PrometheusSpecInitContainersResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema PrometheusSpecInitContainersResources#requests
   */
  readonly requests?: { [key: string]: PrometheusSpecInitContainersResourcesRequests };

}

/**
 * Converts an object of type 'PrometheusSpecInitContainersResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersResources(obj: PrometheusSpecInitContainersResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claims': obj.claims?.map(y => toJson_PrometheusSpecInitContainersResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecurityContext defines the security options the container should be run with.
 * If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
 * More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
 *
 * @schema PrometheusSpecInitContainersSecurityContext
 */
export interface PrometheusSpecInitContainersSecurityContext {
  /**
   * AllowPrivilegeEscalation controls whether a process can gain more
   * privileges than its parent process. This bool directly controls if
   * the no_new_privs flag will be set on the container process.
   * AllowPrivilegeEscalation is true always when the container is:
   * 1) run as Privileged
   * 2) has CAP_SYS_ADMIN
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PrometheusSpecInitContainersSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * The capabilities to add/drop when running containers.
   * Defaults to the default set of capabilities granted by the container runtime.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default the default set of capabilities granted by the container runtime.
   * @schema PrometheusSpecInitContainersSecurityContext#capabilities
   */
  readonly capabilities?: PrometheusSpecInitContainersSecurityContextCapabilities;

  /**
   * Run container in privileged mode.
   * Processes in privileged containers are essentially equivalent to root on the host.
   * Defaults to false.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false.
   * @schema PrometheusSpecInitContainersSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * procMount denotes the type of proc mount to use for the containers.
   * The default is DefaultProcMount which uses the container runtime defaults for
   * readonly paths and masked paths.
   * This requires the ProcMountType feature flag to be enabled.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PrometheusSpecInitContainersSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * Whether this container has a read-only root filesystem.
   * Default is false.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false.
   * @schema PrometheusSpecInitContainersSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * The GID to run the entrypoint of the container process.
   * Uses runtime default if unset.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PrometheusSpecInitContainersSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user.
   * If true, the Kubelet will validate the image at runtime to ensure that it
   * does not run as UID 0 (root) and fail to start the container if it does.
   * If unset or false, no such validation will be performed.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema PrometheusSpecInitContainersSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process.
   * Defaults to user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified.
   * @schema PrometheusSpecInitContainersSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to the container.
   * If unspecified, the container runtime will allocate a random SELinux context for each
   * container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PrometheusSpecInitContainersSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: PrometheusSpecInitContainersSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by this container. If seccomp options are
   * provided at both the pod & container level, the container options
   * override the pod options.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PrometheusSpecInitContainersSecurityContext#seccompProfile
   */
  readonly seccompProfile?: PrometheusSpecInitContainersSecurityContextSeccompProfile;

  /**
   * The Windows specific settings applied to all containers.
   * If unspecified, the options from the PodSecurityContext will be used.
   * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema PrometheusSpecInitContainersSecurityContext#windowsOptions
   */
  readonly windowsOptions?: PrometheusSpecInitContainersSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'PrometheusSpecInitContainersSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersSecurityContext(obj: PrometheusSpecInitContainersSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowPrivilegeEscalation': obj.allowPrivilegeEscalation,
    'capabilities': toJson_PrometheusSpecInitContainersSecurityContextCapabilities(obj.capabilities),
    'privileged': obj.privileged,
    'procMount': obj.procMount,
    'readOnlyRootFilesystem': obj.readOnlyRootFilesystem,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_PrometheusSpecInitContainersSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_PrometheusSpecInitContainersSecurityContextSeccompProfile(obj.seccompProfile),
    'windowsOptions': toJson_PrometheusSpecInitContainersSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * StartupProbe indicates that the Pod has successfully initialized.
 * If specified, no other probes are executed until this completes successfully.
 * If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
 * This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
 * when it might take a long time to load data or warm a cache, than during steady-state operation.
 * This cannot be updated.
 * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema PrometheusSpecInitContainersStartupProbe
 */
export interface PrometheusSpecInitContainersStartupProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema PrometheusSpecInitContainersStartupProbe#exec
   */
  readonly exec?: PrometheusSpecInitContainersStartupProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   * Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema PrometheusSpecInitContainersStartupProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port.
   *
   * @schema PrometheusSpecInitContainersStartupProbe#grpc
   */
  readonly grpc?: PrometheusSpecInitContainersStartupProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema PrometheusSpecInitContainersStartupProbe#httpGet
   */
  readonly httpGet?: PrometheusSpecInitContainersStartupProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema PrometheusSpecInitContainersStartupProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe.
   * Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema PrometheusSpecInitContainersStartupProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema PrometheusSpecInitContainersStartupProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema PrometheusSpecInitContainersStartupProbe#tcpSocket
   */
  readonly tcpSocket?: PrometheusSpecInitContainersStartupProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
   * value overrides the value provided by the pod spec.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
   * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema PrometheusSpecInitContainersStartupProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out.
   * Defaults to 1 second. Minimum value is 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1.
   * @schema PrometheusSpecInitContainersStartupProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'PrometheusSpecInitContainersStartupProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersStartupProbe(obj: PrometheusSpecInitContainersStartupProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_PrometheusSpecInitContainersStartupProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_PrometheusSpecInitContainersStartupProbeGrpc(obj.grpc),
    'httpGet': toJson_PrometheusSpecInitContainersStartupProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_PrometheusSpecInitContainersStartupProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * volumeDevice describes a mapping of a raw block device within a container.
 *
 * @schema PrometheusSpecInitContainersVolumeDevices
 */
export interface PrometheusSpecInitContainersVolumeDevices {
  /**
   * devicePath is the path inside of the container that the device will be mapped to.
   *
   * @schema PrometheusSpecInitContainersVolumeDevices#devicePath
   */
  readonly devicePath: string;

  /**
   * name must match the name of a persistentVolumeClaim in the pod
   *
   * @schema PrometheusSpecInitContainersVolumeDevices#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'PrometheusSpecInitContainersVolumeDevices' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersVolumeDevices(obj: PrometheusSpecInitContainersVolumeDevices | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'devicePath': obj.devicePath,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema PrometheusSpecInitContainersVolumeMounts
 */
export interface PrometheusSpecInitContainersVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must
   * not contain ':'.
   *
   * @schema PrometheusSpecInitContainersVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host
   * to container and the other way around.
   * When not set, MountPropagationNone is used.
   * This field is beta in 1.10.
   *
   * @schema PrometheusSpecInitContainersVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema PrometheusSpecInitContainersVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified).
   * Defaults to false.
   *
   * @default false.
   * @schema PrometheusSpecInitContainersVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Path within the volume from which the container's volume should be mounted.
   * Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema PrometheusSpecInitContainersVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted.
   * Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
   * Defaults to "" (volume's root).
   * SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root).
   * @schema PrometheusSpecInitContainersVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;

}

/**
 * Converts an object of type 'PrometheusSpecInitContainersVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersVolumeMounts(obj: PrometheusSpecInitContainersVolumeMounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'mountPropagation': obj.mountPropagation,
    'name': obj.name,
    'readOnly': obj.readOnly,
    'subPath': obj.subPath,
    'subPathExpr': obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema PrometheusSpecPodMonitorNamespaceSelectorMatchExpressions
 */
export interface PrometheusSpecPodMonitorNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PrometheusSpecPodMonitorNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PrometheusSpecPodMonitorNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema PrometheusSpecPodMonitorNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'PrometheusSpecPodMonitorNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecPodMonitorNamespaceSelectorMatchExpressions(obj: PrometheusSpecPodMonitorNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema PrometheusSpecPodMonitorSelectorMatchExpressions
 */
export interface PrometheusSpecPodMonitorSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PrometheusSpecPodMonitorSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PrometheusSpecPodMonitorSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema PrometheusSpecPodMonitorSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'PrometheusSpecPodMonitorSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecPodMonitorSelectorMatchExpressions(obj: PrometheusSpecPodMonitorSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema PrometheusSpecProbeNamespaceSelectorMatchExpressions
 */
export interface PrometheusSpecProbeNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PrometheusSpecProbeNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PrometheusSpecProbeNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema PrometheusSpecProbeNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'PrometheusSpecProbeNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecProbeNamespaceSelectorMatchExpressions(obj: PrometheusSpecProbeNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema PrometheusSpecProbeSelectorMatchExpressions
 */
export interface PrometheusSpecProbeSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PrometheusSpecProbeSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PrometheusSpecProbeSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema PrometheusSpecProbeSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'PrometheusSpecProbeSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecProbeSelectorMatchExpressions(obj: PrometheusSpecProbeSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Authorization section for the URL.
 *
 *
 * It requires Prometheus >= v2.26.0.
 *
 *
 * Cannot be set at the same time as `basicAuth`, or `oauth2`.
 *
 * @schema PrometheusSpecRemoteReadAuthorization
 */
export interface PrometheusSpecRemoteReadAuthorization {
  /**
   * Selects a key of a Secret in the namespace that contains the credentials for authentication.
   *
   * @schema PrometheusSpecRemoteReadAuthorization#credentials
   */
  readonly credentials?: PrometheusSpecRemoteReadAuthorizationCredentials;

  /**
   * File to read a secret from, mutually exclusive with `credentials`.
   *
   * @schema PrometheusSpecRemoteReadAuthorization#credentialsFile
   */
  readonly credentialsFile?: string;

  /**
   * Defines the authentication type. The value is case-insensitive.
   *
   *
   * "Basic" is not a supported value.
   *
   *
   * Default: "Bearer"
   *
   * @schema PrometheusSpecRemoteReadAuthorization#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'PrometheusSpecRemoteReadAuthorization' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteReadAuthorization(obj: PrometheusSpecRemoteReadAuthorization | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentials': toJson_PrometheusSpecRemoteReadAuthorizationCredentials(obj.credentials),
    'credentialsFile': obj.credentialsFile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BasicAuth configuration for the URL.
 *
 *
 * Cannot be set at the same time as `authorization`, or `oauth2`.
 *
 * @schema PrometheusSpecRemoteReadBasicAuth
 */
export interface PrometheusSpecRemoteReadBasicAuth {
  /**
   * `password` specifies a key of a Secret containing the password for
   * authentication.
   *
   * @schema PrometheusSpecRemoteReadBasicAuth#password
   */
  readonly password?: PrometheusSpecRemoteReadBasicAuthPassword;

  /**
   * `username` specifies a key of a Secret containing the username for
   * authentication.
   *
   * @schema PrometheusSpecRemoteReadBasicAuth#username
   */
  readonly username?: PrometheusSpecRemoteReadBasicAuthUsername;

}

/**
 * Converts an object of type 'PrometheusSpecRemoteReadBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteReadBasicAuth(obj: PrometheusSpecRemoteReadBasicAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_PrometheusSpecRemoteReadBasicAuthPassword(obj.password),
    'username': toJson_PrometheusSpecRemoteReadBasicAuthUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * OAuth2 configuration for the URL.
 *
 *
 * It requires Prometheus >= v2.27.0.
 *
 *
 * Cannot be set at the same time as `authorization`, or `basicAuth`.
 *
 * @schema PrometheusSpecRemoteReadOauth2
 */
export interface PrometheusSpecRemoteReadOauth2 {
  /**
   * `clientId` specifies a key of a Secret or ConfigMap containing the
   * OAuth2 client's ID.
   *
   * @schema PrometheusSpecRemoteReadOauth2#clientId
   */
  readonly clientId: PrometheusSpecRemoteReadOauth2ClientId;

  /**
   * `clientSecret` specifies a key of a Secret containing the OAuth2
   * client's secret.
   *
   * @schema PrometheusSpecRemoteReadOauth2#clientSecret
   */
  readonly clientSecret: PrometheusSpecRemoteReadOauth2ClientSecret;

  /**
   * `endpointParams` configures the HTTP parameters to append to the token
   * URL.
   *
   * @schema PrometheusSpecRemoteReadOauth2#endpointParams
   */
  readonly endpointParams?: { [key: string]: string };

  /**
   * `scopes` defines the OAuth2 scopes used for the token request.
   *
   * @schema PrometheusSpecRemoteReadOauth2#scopes
   */
  readonly scopes?: string[];

  /**
   * `tokenURL` configures the URL to fetch the token from.
   *
   * @schema PrometheusSpecRemoteReadOauth2#tokenUrl
   */
  readonly tokenUrl: string;

}

/**
 * Converts an object of type 'PrometheusSpecRemoteReadOauth2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteReadOauth2(obj: PrometheusSpecRemoteReadOauth2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientId': toJson_PrometheusSpecRemoteReadOauth2ClientId(obj.clientId),
    'clientSecret': toJson_PrometheusSpecRemoteReadOauth2ClientSecret(obj.clientSecret),
    'endpointParams': ((obj.endpointParams) === undefined) ? undefined : (Object.entries(obj.endpointParams).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'scopes': obj.scopes?.map(y => y),
    'tokenUrl': obj.tokenUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLS Config to use for the URL.
 *
 * @schema PrometheusSpecRemoteReadTlsConfig
 */
export interface PrometheusSpecRemoteReadTlsConfig {
  /**
   * Certificate authority used when verifying server certificates.
   *
   * @schema PrometheusSpecRemoteReadTlsConfig#ca
   */
  readonly ca?: PrometheusSpecRemoteReadTlsConfigCa;

  /**
   * Path to the CA cert in the Prometheus container to use for the targets.
   *
   * @schema PrometheusSpecRemoteReadTlsConfig#caFile
   */
  readonly caFile?: string;

  /**
   * Client certificate to present when doing client-authentication.
   *
   * @schema PrometheusSpecRemoteReadTlsConfig#cert
   */
  readonly cert?: PrometheusSpecRemoteReadTlsConfigCert;

  /**
   * Path to the client cert file in the Prometheus container for the targets.
   *
   * @schema PrometheusSpecRemoteReadTlsConfig#certFile
   */
  readonly certFile?: string;

  /**
   * Disable target certificate validation.
   *
   * @schema PrometheusSpecRemoteReadTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Path to the client key file in the Prometheus container for the targets.
   *
   * @schema PrometheusSpecRemoteReadTlsConfig#keyFile
   */
  readonly keyFile?: string;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema PrometheusSpecRemoteReadTlsConfig#keySecret
   */
  readonly keySecret?: PrometheusSpecRemoteReadTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema PrometheusSpecRemoteReadTlsConfig#serverName
   */
  readonly serverName?: string;

}

/**
 * Converts an object of type 'PrometheusSpecRemoteReadTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteReadTlsConfig(obj: PrometheusSpecRemoteReadTlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ca': toJson_PrometheusSpecRemoteReadTlsConfigCa(obj.ca),
    'caFile': obj.caFile,
    'cert': toJson_PrometheusSpecRemoteReadTlsConfigCert(obj.cert),
    'certFile': obj.certFile,
    'insecureSkipVerify': obj.insecureSkipVerify,
    'keyFile': obj.keyFile,
    'keySecret': toJson_PrometheusSpecRemoteReadTlsConfigKeySecret(obj.keySecret),
    'serverName': obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Authorization section for the URL.
 *
 *
 * It requires Prometheus >= v2.26.0.
 *
 *
 * Cannot be set at the same time as `sigv4`, `basicAuth`, `oauth2`, or `azureAd`.
 *
 * @schema PrometheusSpecRemoteWriteAuthorization
 */
export interface PrometheusSpecRemoteWriteAuthorization {
  /**
   * Selects a key of a Secret in the namespace that contains the credentials for authentication.
   *
   * @schema PrometheusSpecRemoteWriteAuthorization#credentials
   */
  readonly credentials?: PrometheusSpecRemoteWriteAuthorizationCredentials;

  /**
   * File to read a secret from, mutually exclusive with `credentials`.
   *
   * @schema PrometheusSpecRemoteWriteAuthorization#credentialsFile
   */
  readonly credentialsFile?: string;

  /**
   * Defines the authentication type. The value is case-insensitive.
   *
   *
   * "Basic" is not a supported value.
   *
   *
   * Default: "Bearer"
   *
   * @schema PrometheusSpecRemoteWriteAuthorization#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'PrometheusSpecRemoteWriteAuthorization' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteWriteAuthorization(obj: PrometheusSpecRemoteWriteAuthorization | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentials': toJson_PrometheusSpecRemoteWriteAuthorizationCredentials(obj.credentials),
    'credentialsFile': obj.credentialsFile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AzureAD for the URL.
 *
 *
 * It requires Prometheus >= v2.45.0.
 *
 *
 * Cannot be set at the same time as `authorization`, `basicAuth`, `oauth2`, or `sigv4`.
 *
 * @schema PrometheusSpecRemoteWriteAzureAd
 */
export interface PrometheusSpecRemoteWriteAzureAd {
  /**
   * The Azure Cloud. Options are 'AzurePublic', 'AzureChina', or 'AzureGovernment'.
   *
   * @schema PrometheusSpecRemoteWriteAzureAd#cloud
   */
  readonly cloud?: PrometheusSpecRemoteWriteAzureAdCloud;

  /**
   * ManagedIdentity defines the Azure User-assigned Managed identity.
   * Cannot be set at the same time as `oauth` or `sdk`.
   *
   * @schema PrometheusSpecRemoteWriteAzureAd#managedIdentity
   */
  readonly managedIdentity?: PrometheusSpecRemoteWriteAzureAdManagedIdentity;

  /**
   * OAuth defines the oauth config that is being used to authenticate.
   * Cannot be set at the same time as `managedIdentity` or `sdk`.
   *
   *
   * It requires Prometheus >= v2.48.0.
   *
   * @schema PrometheusSpecRemoteWriteAzureAd#oauth
   */
  readonly oauth?: PrometheusSpecRemoteWriteAzureAdOauth;

  /**
   * SDK defines the Azure SDK config that is being used to authenticate.
   * See https://learn.microsoft.com/en-us/azure/developer/go/azure-sdk-authentication
   * Cannot be set at the same time as `oauth` or `managedIdentity`.
   *
   *
   * It requires Prometheus >= 2.52.0.
   *
   * @schema PrometheusSpecRemoteWriteAzureAd#sdk
   */
  readonly sdk?: PrometheusSpecRemoteWriteAzureAdSdk;

}

/**
 * Converts an object of type 'PrometheusSpecRemoteWriteAzureAd' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteWriteAzureAd(obj: PrometheusSpecRemoteWriteAzureAd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloud': obj.cloud,
    'managedIdentity': toJson_PrometheusSpecRemoteWriteAzureAdManagedIdentity(obj.managedIdentity),
    'oauth': toJson_PrometheusSpecRemoteWriteAzureAdOauth(obj.oauth),
    'sdk': toJson_PrometheusSpecRemoteWriteAzureAdSdk(obj.sdk),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BasicAuth configuration for the URL.
 *
 *
 * Cannot be set at the same time as `sigv4`, `authorization`, `oauth2`, or `azureAd`.
 *
 * @schema PrometheusSpecRemoteWriteBasicAuth
 */
export interface PrometheusSpecRemoteWriteBasicAuth {
  /**
   * `password` specifies a key of a Secret containing the password for
   * authentication.
   *
   * @schema PrometheusSpecRemoteWriteBasicAuth#password
   */
  readonly password?: PrometheusSpecRemoteWriteBasicAuthPassword;

  /**
   * `username` specifies a key of a Secret containing the username for
   * authentication.
   *
   * @schema PrometheusSpecRemoteWriteBasicAuth#username
   */
  readonly username?: PrometheusSpecRemoteWriteBasicAuthUsername;

}

/**
 * Converts an object of type 'PrometheusSpecRemoteWriteBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteWriteBasicAuth(obj: PrometheusSpecRemoteWriteBasicAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_PrometheusSpecRemoteWriteBasicAuthPassword(obj.password),
    'username': toJson_PrometheusSpecRemoteWriteBasicAuthUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * MetadataConfig configures the sending of series metadata to the remote storage.
 *
 * @schema PrometheusSpecRemoteWriteMetadataConfig
 */
export interface PrometheusSpecRemoteWriteMetadataConfig {
  /**
   * Defines whether metric metadata is sent to the remote storage or not.
   *
   * @schema PrometheusSpecRemoteWriteMetadataConfig#send
   */
  readonly send?: boolean;

  /**
   * Defines how frequently metric metadata is sent to the remote storage.
   *
   * @schema PrometheusSpecRemoteWriteMetadataConfig#sendInterval
   */
  readonly sendInterval?: string;

}

/**
 * Converts an object of type 'PrometheusSpecRemoteWriteMetadataConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteWriteMetadataConfig(obj: PrometheusSpecRemoteWriteMetadataConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'send': obj.send,
    'sendInterval': obj.sendInterval,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * OAuth2 configuration for the URL.
 *
 *
 * It requires Prometheus >= v2.27.0.
 *
 *
 * Cannot be set at the same time as `sigv4`, `authorization`, `basicAuth`, or `azureAd`.
 *
 * @schema PrometheusSpecRemoteWriteOauth2
 */
export interface PrometheusSpecRemoteWriteOauth2 {
  /**
   * `clientId` specifies a key of a Secret or ConfigMap containing the
   * OAuth2 client's ID.
   *
   * @schema PrometheusSpecRemoteWriteOauth2#clientId
   */
  readonly clientId: PrometheusSpecRemoteWriteOauth2ClientId;

  /**
   * `clientSecret` specifies a key of a Secret containing the OAuth2
   * client's secret.
   *
   * @schema PrometheusSpecRemoteWriteOauth2#clientSecret
   */
  readonly clientSecret: PrometheusSpecRemoteWriteOauth2ClientSecret;

  /**
   * `endpointParams` configures the HTTP parameters to append to the token
   * URL.
   *
   * @schema PrometheusSpecRemoteWriteOauth2#endpointParams
   */
  readonly endpointParams?: { [key: string]: string };

  /**
   * `scopes` defines the OAuth2 scopes used for the token request.
   *
   * @schema PrometheusSpecRemoteWriteOauth2#scopes
   */
  readonly scopes?: string[];

  /**
   * `tokenURL` configures the URL to fetch the token from.
   *
   * @schema PrometheusSpecRemoteWriteOauth2#tokenUrl
   */
  readonly tokenUrl: string;

}

/**
 * Converts an object of type 'PrometheusSpecRemoteWriteOauth2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteWriteOauth2(obj: PrometheusSpecRemoteWriteOauth2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientId': toJson_PrometheusSpecRemoteWriteOauth2ClientId(obj.clientId),
    'clientSecret': toJson_PrometheusSpecRemoteWriteOauth2ClientSecret(obj.clientSecret),
    'endpointParams': ((obj.endpointParams) === undefined) ? undefined : (Object.entries(obj.endpointParams).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'scopes': obj.scopes?.map(y => y),
    'tokenUrl': obj.tokenUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * QueueConfig allows tuning of the remote write queue parameters.
 *
 * @schema PrometheusSpecRemoteWriteQueueConfig
 */
export interface PrometheusSpecRemoteWriteQueueConfig {
  /**
   * BatchSendDeadline is the maximum time a sample will wait in buffer.
   *
   * @schema PrometheusSpecRemoteWriteQueueConfig#batchSendDeadline
   */
  readonly batchSendDeadline?: string;

  /**
   * Capacity is the number of samples to buffer per shard before we start
   * dropping them.
   *
   * @schema PrometheusSpecRemoteWriteQueueConfig#capacity
   */
  readonly capacity?: number;

  /**
   * MaxBackoff is the maximum retry delay.
   *
   * @schema PrometheusSpecRemoteWriteQueueConfig#maxBackoff
   */
  readonly maxBackoff?: string;

  /**
   * MaxRetries is the maximum number of times to retry a batch on recoverable errors.
   *
   * @schema PrometheusSpecRemoteWriteQueueConfig#maxRetries
   */
  readonly maxRetries?: number;

  /**
   * MaxSamplesPerSend is the maximum number of samples per send.
   *
   * @schema PrometheusSpecRemoteWriteQueueConfig#maxSamplesPerSend
   */
  readonly maxSamplesPerSend?: number;

  /**
   * MaxShards is the maximum number of shards, i.e. amount of concurrency.
   *
   * @schema PrometheusSpecRemoteWriteQueueConfig#maxShards
   */
  readonly maxShards?: number;

  /**
   * MinBackoff is the initial retry delay. Gets doubled for every retry.
   *
   * @schema PrometheusSpecRemoteWriteQueueConfig#minBackoff
   */
  readonly minBackoff?: string;

  /**
   * MinShards is the minimum number of shards, i.e. amount of concurrency.
   *
   * @schema PrometheusSpecRemoteWriteQueueConfig#minShards
   */
  readonly minShards?: number;

  /**
   * Retry upon receiving a 429 status code from the remote-write storage.
   *
   *
   * This is an *experimental feature*, it may change in any upcoming release
   * in a breaking way.
   *
   * @schema PrometheusSpecRemoteWriteQueueConfig#retryOnRateLimit
   */
  readonly retryOnRateLimit?: boolean;

  /**
   * SampleAgeLimit drops samples older than the limit.
   * It requires Prometheus >= v2.50.0.
   *
   * @schema PrometheusSpecRemoteWriteQueueConfig#sampleAgeLimit
   */
  readonly sampleAgeLimit?: string;

}

/**
 * Converts an object of type 'PrometheusSpecRemoteWriteQueueConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteWriteQueueConfig(obj: PrometheusSpecRemoteWriteQueueConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'batchSendDeadline': obj.batchSendDeadline,
    'capacity': obj.capacity,
    'maxBackoff': obj.maxBackoff,
    'maxRetries': obj.maxRetries,
    'maxSamplesPerSend': obj.maxSamplesPerSend,
    'maxShards': obj.maxShards,
    'minBackoff': obj.minBackoff,
    'minShards': obj.minShards,
    'retryOnRateLimit': obj.retryOnRateLimit,
    'sampleAgeLimit': obj.sampleAgeLimit,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Sigv4 allows to configures AWS's Signature Verification 4 for the URL.
 *
 *
 * It requires Prometheus >= v2.26.0.
 *
 *
 * Cannot be set at the same time as `authorization`, `basicAuth`, `oauth2`, or `azureAd`.
 *
 * @schema PrometheusSpecRemoteWriteSigv4
 */
export interface PrometheusSpecRemoteWriteSigv4 {
  /**
   * AccessKey is the AWS API key. If not specified, the environment variable
   * `AWS_ACCESS_KEY_ID` is used.
   *
   * @schema PrometheusSpecRemoteWriteSigv4#accessKey
   */
  readonly accessKey?: PrometheusSpecRemoteWriteSigv4AccessKey;

  /**
   * Profile is the named AWS profile used to authenticate.
   *
   * @schema PrometheusSpecRemoteWriteSigv4#profile
   */
  readonly profile?: string;

  /**
   * Region is the AWS region. If blank, the region from the default credentials chain used.
   *
   * @schema PrometheusSpecRemoteWriteSigv4#region
   */
  readonly region?: string;

  /**
   * RoleArn is the named AWS profile used to authenticate.
   *
   * @schema PrometheusSpecRemoteWriteSigv4#roleArn
   */
  readonly roleArn?: string;

  /**
   * SecretKey is the AWS API secret. If not specified, the environment
   * variable `AWS_SECRET_ACCESS_KEY` is used.
   *
   * @schema PrometheusSpecRemoteWriteSigv4#secretKey
   */
  readonly secretKey?: PrometheusSpecRemoteWriteSigv4SecretKey;

}

/**
 * Converts an object of type 'PrometheusSpecRemoteWriteSigv4' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteWriteSigv4(obj: PrometheusSpecRemoteWriteSigv4 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessKey': toJson_PrometheusSpecRemoteWriteSigv4AccessKey(obj.accessKey),
    'profile': obj.profile,
    'region': obj.region,
    'roleArn': obj.roleArn,
    'secretKey': toJson_PrometheusSpecRemoteWriteSigv4SecretKey(obj.secretKey),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLS Config to use for the URL.
 *
 * @schema PrometheusSpecRemoteWriteTlsConfig
 */
export interface PrometheusSpecRemoteWriteTlsConfig {
  /**
   * Certificate authority used when verifying server certificates.
   *
   * @schema PrometheusSpecRemoteWriteTlsConfig#ca
   */
  readonly ca?: PrometheusSpecRemoteWriteTlsConfigCa;

  /**
   * Path to the CA cert in the Prometheus container to use for the targets.
   *
   * @schema PrometheusSpecRemoteWriteTlsConfig#caFile
   */
  readonly caFile?: string;

  /**
   * Client certificate to present when doing client-authentication.
   *
   * @schema PrometheusSpecRemoteWriteTlsConfig#cert
   */
  readonly cert?: PrometheusSpecRemoteWriteTlsConfigCert;

  /**
   * Path to the client cert file in the Prometheus container for the targets.
   *
   * @schema PrometheusSpecRemoteWriteTlsConfig#certFile
   */
  readonly certFile?: string;

  /**
   * Disable target certificate validation.
   *
   * @schema PrometheusSpecRemoteWriteTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Path to the client key file in the Prometheus container for the targets.
   *
   * @schema PrometheusSpecRemoteWriteTlsConfig#keyFile
   */
  readonly keyFile?: string;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema PrometheusSpecRemoteWriteTlsConfig#keySecret
   */
  readonly keySecret?: PrometheusSpecRemoteWriteTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema PrometheusSpecRemoteWriteTlsConfig#serverName
   */
  readonly serverName?: string;

}

/**
 * Converts an object of type 'PrometheusSpecRemoteWriteTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteWriteTlsConfig(obj: PrometheusSpecRemoteWriteTlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ca': toJson_PrometheusSpecRemoteWriteTlsConfigCa(obj.ca),
    'caFile': obj.caFile,
    'cert': toJson_PrometheusSpecRemoteWriteTlsConfigCert(obj.cert),
    'certFile': obj.certFile,
    'insecureSkipVerify': obj.insecureSkipVerify,
    'keyFile': obj.keyFile,
    'keySecret': toJson_PrometheusSpecRemoteWriteTlsConfigKeySecret(obj.keySecret),
    'serverName': obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RelabelConfig allows dynamic rewriting of the label set for targets, alerts,
 * scraped samples and remote write samples.
 *
 *
 * More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
 *
 * @schema PrometheusSpecRemoteWriteWriteRelabelConfigs
 */
export interface PrometheusSpecRemoteWriteWriteRelabelConfigs {
  /**
   * Action to perform based on the regex matching.
   *
   *
   * `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0.
   * `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.
   *
   *
   * Default: "Replace"
   *
   * @schema PrometheusSpecRemoteWriteWriteRelabelConfigs#action
   */
  readonly action?: PrometheusSpecRemoteWriteWriteRelabelConfigsAction;

  /**
   * Modulus to take of the hash of the source label values.
   *
   *
   * Only applicable when the action is `HashMod`.
   *
   * @schema PrometheusSpecRemoteWriteWriteRelabelConfigs#modulus
   */
  readonly modulus?: number;

  /**
   * Regular expression against which the extracted value is matched.
   *
   * @schema PrometheusSpecRemoteWriteWriteRelabelConfigs#regex
   */
  readonly regex?: string;

  /**
   * Replacement value against which a Replace action is performed if the
   * regular expression matches.
   *
   *
   * Regex capture groups are available.
   *
   * @schema PrometheusSpecRemoteWriteWriteRelabelConfigs#replacement
   */
  readonly replacement?: string;

  /**
   * Separator is the string between concatenated SourceLabels.
   *
   * @schema PrometheusSpecRemoteWriteWriteRelabelConfigs#separator
   */
  readonly separator?: string;

  /**
   * The source labels select values from existing labels. Their content is
   * concatenated using the configured Separator and matched against the
   * configured regular expression.
   *
   * @schema PrometheusSpecRemoteWriteWriteRelabelConfigs#sourceLabels
   */
  readonly sourceLabels?: string[];

  /**
   * Label to which the resulting string is written in a replacement.
   *
   *
   * It is mandatory for `Replace`, `HashMod`, `Lowercase`, `Uppercase`,
   * `KeepEqual` and `DropEqual` actions.
   *
   *
   * Regex capture groups are available.
   *
   * @schema PrometheusSpecRemoteWriteWriteRelabelConfigs#targetLabel
   */
  readonly targetLabel?: string;

}

/**
 * Converts an object of type 'PrometheusSpecRemoteWriteWriteRelabelConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteWriteWriteRelabelConfigs(obj: PrometheusSpecRemoteWriteWriteRelabelConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'modulus': obj.modulus,
    'regex': obj.regex,
    'replacement': obj.replacement,
    'separator': obj.separator,
    'sourceLabels': obj.sourceLabels?.map(y => y),
    'targetLabel': obj.targetLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema PrometheusSpecResourcesClaims
 */
export interface PrometheusSpecResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema PrometheusSpecResourcesClaims#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'PrometheusSpecResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecResourcesClaims(obj: PrometheusSpecResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PrometheusSpecResourcesLimits
 */
export class PrometheusSpecResourcesLimits {
  public static fromNumber(value: number): PrometheusSpecResourcesLimits {
    return new PrometheusSpecResourcesLimits(value);
  }
  public static fromString(value: string): PrometheusSpecResourcesLimits {
    return new PrometheusSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema PrometheusSpecResourcesRequests
 */
export class PrometheusSpecResourcesRequests {
  public static fromNumber(value: number): PrometheusSpecResourcesRequests {
    return new PrometheusSpecResourcesRequests(value);
  }
  public static fromString(value: string): PrometheusSpecResourcesRequests {
    return new PrometheusSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema PrometheusSpecRuleNamespaceSelectorMatchExpressions
 */
export interface PrometheusSpecRuleNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PrometheusSpecRuleNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PrometheusSpecRuleNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema PrometheusSpecRuleNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'PrometheusSpecRuleNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRuleNamespaceSelectorMatchExpressions(obj: PrometheusSpecRuleNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema PrometheusSpecRuleSelectorMatchExpressions
 */
export interface PrometheusSpecRuleSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PrometheusSpecRuleSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PrometheusSpecRuleSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema PrometheusSpecRuleSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'PrometheusSpecRuleSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRuleSelectorMatchExpressions(obj: PrometheusSpecRuleSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Defines the parameters of the Prometheus rules' engine.
 *
 *
 * Any update to these parameters trigger a restart of the pods.
 *
 * @schema PrometheusSpecRulesAlert
 */
export interface PrometheusSpecRulesAlert {
  /**
   * Minimum duration between alert and restored 'for' state.
   *
   *
   * This is maintained only for alerts with a configured 'for' time greater
   * than the grace period.
   *
   * @schema PrometheusSpecRulesAlert#forGracePeriod
   */
  readonly forGracePeriod?: string;

  /**
   * Max time to tolerate prometheus outage for restoring 'for' state of
   * alert.
   *
   * @schema PrometheusSpecRulesAlert#forOutageTolerance
   */
  readonly forOutageTolerance?: string;

  /**
   * Minimum amount of time to wait before resending an alert to
   * Alertmanager.
   *
   * @schema PrometheusSpecRulesAlert#resendDelay
   */
  readonly resendDelay?: string;

}

/**
 * Converts an object of type 'PrometheusSpecRulesAlert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRulesAlert(obj: PrometheusSpecRulesAlert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'forGracePeriod': obj.forGracePeriod,
    'forOutageTolerance': obj.forOutageTolerance,
    'resendDelay': obj.resendDelay,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RelabelConfig allows dynamic rewriting of the label set for targets, alerts,
 * scraped samples and remote write samples.
 *
 *
 * More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
 *
 * @schema PrometheusSpecScrapeClassesRelabelings
 */
export interface PrometheusSpecScrapeClassesRelabelings {
  /**
   * Action to perform based on the regex matching.
   *
   *
   * `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0.
   * `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.
   *
   *
   * Default: "Replace"
   *
   * @schema PrometheusSpecScrapeClassesRelabelings#action
   */
  readonly action?: PrometheusSpecScrapeClassesRelabelingsAction;

  /**
   * Modulus to take of the hash of the source label values.
   *
   *
   * Only applicable when the action is `HashMod`.
   *
   * @schema PrometheusSpecScrapeClassesRelabelings#modulus
   */
  readonly modulus?: number;

  /**
   * Regular expression against which the extracted value is matched.
   *
   * @schema PrometheusSpecScrapeClassesRelabelings#regex
   */
  readonly regex?: string;

  /**
   * Replacement value against which a Replace action is performed if the
   * regular expression matches.
   *
   *
   * Regex capture groups are available.
   *
   * @schema PrometheusSpecScrapeClassesRelabelings#replacement
   */
  readonly replacement?: string;

  /**
   * Separator is the string between concatenated SourceLabels.
   *
   * @schema PrometheusSpecScrapeClassesRelabelings#separator
   */
  readonly separator?: string;

  /**
   * The source labels select values from existing labels. Their content is
   * concatenated using the configured Separator and matched against the
   * configured regular expression.
   *
   * @schema PrometheusSpecScrapeClassesRelabelings#sourceLabels
   */
  readonly sourceLabels?: string[];

  /**
   * Label to which the resulting string is written in a replacement.
   *
   *
   * It is mandatory for `Replace`, `HashMod`, `Lowercase`, `Uppercase`,
   * `KeepEqual` and `DropEqual` actions.
   *
   *
   * Regex capture groups are available.
   *
   * @schema PrometheusSpecScrapeClassesRelabelings#targetLabel
   */
  readonly targetLabel?: string;

}

/**
 * Converts an object of type 'PrometheusSpecScrapeClassesRelabelings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecScrapeClassesRelabelings(obj: PrometheusSpecScrapeClassesRelabelings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'modulus': obj.modulus,
    'regex': obj.regex,
    'replacement': obj.replacement,
    'separator': obj.separator,
    'sourceLabels': obj.sourceLabels?.map(y => y),
    'targetLabel': obj.targetLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLSConfig defines the TLS settings to use for the scrape. When the
 * scrape objects define their own CA, certificate and/or key, they take
 * precedence over the corresponding scrape class fields.
 *
 *
 * For now only the `caFile`, `certFile` and `keyFile` fields are supported.
 *
 * @schema PrometheusSpecScrapeClassesTlsConfig
 */
export interface PrometheusSpecScrapeClassesTlsConfig {
  /**
   * Certificate authority used when verifying server certificates.
   *
   * @schema PrometheusSpecScrapeClassesTlsConfig#ca
   */
  readonly ca?: PrometheusSpecScrapeClassesTlsConfigCa;

  /**
   * Path to the CA cert in the Prometheus container to use for the targets.
   *
   * @schema PrometheusSpecScrapeClassesTlsConfig#caFile
   */
  readonly caFile?: string;

  /**
   * Client certificate to present when doing client-authentication.
   *
   * @schema PrometheusSpecScrapeClassesTlsConfig#cert
   */
  readonly cert?: PrometheusSpecScrapeClassesTlsConfigCert;

  /**
   * Path to the client cert file in the Prometheus container for the targets.
   *
   * @schema PrometheusSpecScrapeClassesTlsConfig#certFile
   */
  readonly certFile?: string;

  /**
   * Disable target certificate validation.
   *
   * @schema PrometheusSpecScrapeClassesTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Path to the client key file in the Prometheus container for the targets.
   *
   * @schema PrometheusSpecScrapeClassesTlsConfig#keyFile
   */
  readonly keyFile?: string;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema PrometheusSpecScrapeClassesTlsConfig#keySecret
   */
  readonly keySecret?: PrometheusSpecScrapeClassesTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema PrometheusSpecScrapeClassesTlsConfig#serverName
   */
  readonly serverName?: string;

}

/**
 * Converts an object of type 'PrometheusSpecScrapeClassesTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecScrapeClassesTlsConfig(obj: PrometheusSpecScrapeClassesTlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ca': toJson_PrometheusSpecScrapeClassesTlsConfigCa(obj.ca),
    'caFile': obj.caFile,
    'cert': toJson_PrometheusSpecScrapeClassesTlsConfigCert(obj.cert),
    'certFile': obj.certFile,
    'insecureSkipVerify': obj.insecureSkipVerify,
    'keyFile': obj.keyFile,
    'keySecret': toJson_PrometheusSpecScrapeClassesTlsConfigKeySecret(obj.keySecret),
    'serverName': obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema PrometheusSpecScrapeConfigNamespaceSelectorMatchExpressions
 */
export interface PrometheusSpecScrapeConfigNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PrometheusSpecScrapeConfigNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PrometheusSpecScrapeConfigNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema PrometheusSpecScrapeConfigNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'PrometheusSpecScrapeConfigNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecScrapeConfigNamespaceSelectorMatchExpressions(obj: PrometheusSpecScrapeConfigNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema PrometheusSpecScrapeConfigSelectorMatchExpressions
 */
export interface PrometheusSpecScrapeConfigSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PrometheusSpecScrapeConfigSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PrometheusSpecScrapeConfigSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema PrometheusSpecScrapeConfigSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'PrometheusSpecScrapeConfigSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecScrapeConfigSelectorMatchExpressions(obj: PrometheusSpecScrapeConfigSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The SELinux context to be applied to all containers.
 * If unspecified, the container runtime will allocate a random SELinux context for each
 * container.  May also be set in SecurityContext.  If set in
 * both SecurityContext and PodSecurityContext, the value specified in SecurityContext
 * takes precedence for that container.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema PrometheusSpecSecurityContextSeLinuxOptions
 */
export interface PrometheusSpecSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema PrometheusSpecSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema PrometheusSpecSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema PrometheusSpecSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema PrometheusSpecSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'PrometheusSpecSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecSecurityContextSeLinuxOptions(obj: PrometheusSpecSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The seccomp options to use by the containers in this pod.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema PrometheusSpecSecurityContextSeccompProfile
 */
export interface PrometheusSpecSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used.
   * The profile must be preconfigured on the node to work.
   * Must be a descending path, relative to the kubelet's configured seccomp profile location.
   * Must be set if type is "Localhost". Must NOT be set for any other type.
   *
   * @schema PrometheusSpecSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied.
   * Valid options are:
   *
   *
   * Localhost - a profile defined in a file on the node should be used.
   * RuntimeDefault - the container runtime default profile should be used.
   * Unconfined - no profile should be applied.
   *
   * @schema PrometheusSpecSecurityContextSeccompProfile#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'PrometheusSpecSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecSecurityContextSeccompProfile(obj: PrometheusSpecSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Sysctl defines a kernel parameter to be set
 *
 * @schema PrometheusSpecSecurityContextSysctls
 */
export interface PrometheusSpecSecurityContextSysctls {
  /**
   * Name of a property to set
   *
   * @schema PrometheusSpecSecurityContextSysctls#name
   */
  readonly name: string;

  /**
   * Value of a property to set
   *
   * @schema PrometheusSpecSecurityContextSysctls#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'PrometheusSpecSecurityContextSysctls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecSecurityContextSysctls(obj: PrometheusSpecSecurityContextSysctls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Windows specific settings applied to all containers.
 * If unspecified, the options within a container's SecurityContext will be used.
 * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema PrometheusSpecSecurityContextWindowsOptions
 */
export interface PrometheusSpecSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook
   * (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
   * GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema PrometheusSpecSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema PrometheusSpecSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container.
   * All of a Pod's containers must have the same effective HostProcess value
   * (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
   * In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema PrometheusSpecSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process.
   * Defaults to the user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext. If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified.
   * @schema PrometheusSpecSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'PrometheusSpecSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecSecurityContextWindowsOptions(obj: PrometheusSpecSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema PrometheusSpecServiceMonitorNamespaceSelectorMatchExpressions
 */
export interface PrometheusSpecServiceMonitorNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PrometheusSpecServiceMonitorNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PrometheusSpecServiceMonitorNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema PrometheusSpecServiceMonitorNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'PrometheusSpecServiceMonitorNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecServiceMonitorNamespaceSelectorMatchExpressions(obj: PrometheusSpecServiceMonitorNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema PrometheusSpecServiceMonitorSelectorMatchExpressions
 */
export interface PrometheusSpecServiceMonitorSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PrometheusSpecServiceMonitorSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PrometheusSpecServiceMonitorSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema PrometheusSpecServiceMonitorSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'PrometheusSpecServiceMonitorSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecServiceMonitorSelectorMatchExpressions(obj: PrometheusSpecServiceMonitorSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EmptyDirVolumeSource to be used by the StatefulSet.
 * If specified, it takes precedence over `ephemeral` and `volumeClaimTemplate`.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes/#emptydir
 *
 * @schema PrometheusSpecStorageEmptyDir
 */
export interface PrometheusSpecStorageEmptyDir {
  /**
   * medium represents what type of storage medium should back this directory.
   * The default is "" which means to use the node's default medium.
   * Must be an empty string (default) or Memory.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema PrometheusSpecStorageEmptyDir#medium
   */
  readonly medium?: string;

  /**
   * sizeLimit is the total amount of local storage required for this EmptyDir volume.
   * The size limit is also applicable for memory medium.
   * The maximum usage on memory medium EmptyDir would be the minimum value between
   * the SizeLimit specified here and the sum of memory limits of all containers in a pod.
   * The default is nil which means that the limit is undefined.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema PrometheusSpecStorageEmptyDir#sizeLimit
   */
  readonly sizeLimit?: PrometheusSpecStorageEmptyDirSizeLimit;

}

/**
 * Converts an object of type 'PrometheusSpecStorageEmptyDir' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecStorageEmptyDir(obj: PrometheusSpecStorageEmptyDir | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'medium': obj.medium,
    'sizeLimit': obj.sizeLimit?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EphemeralVolumeSource to be used by the StatefulSet.
 * This is a beta field in k8s 1.21 and GA in 1.15.
 * For lower versions, starting with k8s 1.19, it requires enabling the GenericEphemeralVolume feature gate.
 * More info: https://kubernetes.io/docs/concepts/storage/ephemeral-volumes/#generic-ephemeral-volumes
 *
 * @schema PrometheusSpecStorageEphemeral
 */
export interface PrometheusSpecStorageEphemeral {
  /**
   * Will be used to create a stand-alone PVC to provision the volume.
   * The pod in which this EphemeralVolumeSource is embedded will be the
   * owner of the PVC, i.e. the PVC will be deleted together with the
   * pod.  The name of the PVC will be `<pod name>-<volume name>` where
   * `<volume name>` is the name from the `PodSpec.Volumes` array
   * entry. Pod validation will reject the pod if the concatenated name
   * is not valid for a PVC (for example, too long).
   *
   *
   * An existing PVC with that name that is not owned by the pod
   * will *not* be used for the pod to avoid using an unrelated
   * volume by mistake. Starting the pod is then blocked until
   * the unrelated PVC is removed. If such a pre-created PVC is
   * meant to be used by the pod, the PVC has to updated with an
   * owner reference to the pod once the pod exists. Normally
   * this should not be necessary, but it may be useful when
   * manually reconstructing a broken cluster.
   *
   *
   * This field is read-only and no changes will be made by Kubernetes
   * to the PVC after it has been created.
   *
   *
   * Required, must not be nil.
   *
   * @schema PrometheusSpecStorageEphemeral#volumeClaimTemplate
   */
  readonly volumeClaimTemplate?: PrometheusSpecStorageEphemeralVolumeClaimTemplate;

}

/**
 * Converts an object of type 'PrometheusSpecStorageEphemeral' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecStorageEphemeral(obj: PrometheusSpecStorageEphemeral | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'volumeClaimTemplate': toJson_PrometheusSpecStorageEphemeralVolumeClaimTemplate(obj.volumeClaimTemplate),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Defines the PVC spec to be used by the Prometheus StatefulSets.
 * The easiest way to use a volume that cannot be automatically provisioned
 * is to use a label selector alongside manually created PersistentVolumes.
 *
 * @schema PrometheusSpecStorageVolumeClaimTemplate
 */
export interface PrometheusSpecStorageVolumeClaimTemplate {
  /**
   * APIVersion defines the versioned schema of this representation of an object.
   * Servers should convert recognized schemas to the latest internal value, and
   * may reject unrecognized values.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplate#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Kind is a string value representing the REST resource this object represents.
   * Servers may infer this from the endpoint the client submits requests to.
   * Cannot be updated.
   * In CamelCase.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplate#kind
   */
  readonly kind?: string;

  /**
   * EmbeddedMetadata contains metadata relevant to an EmbeddedResource.
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplate#metadata
   */
  readonly metadata?: PrometheusSpecStorageVolumeClaimTemplateMetadata;

  /**
   * Defines the desired characteristics of a volume requested by a pod author.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplate#spec
   */
  readonly spec?: PrometheusSpecStorageVolumeClaimTemplateSpec;

  /**
   * Deprecated: this field is never set.
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplate#status
   */
  readonly status?: PrometheusSpecStorageVolumeClaimTemplateStatus;

}

/**
 * Converts an object of type 'PrometheusSpecStorageVolumeClaimTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecStorageVolumeClaimTemplate(obj: PrometheusSpecStorageVolumeClaimTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'kind': obj.kind,
    'metadata': toJson_PrometheusSpecStorageVolumeClaimTemplateMetadata(obj.metadata),
    'spec': toJson_PrometheusSpecStorageVolumeClaimTemplateSpec(obj.spec),
    'status': toJson_PrometheusSpecStorageVolumeClaimTemplateStatus(obj.status),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Argument as part of the AdditionalArgs list.
 *
 * @schema PrometheusSpecThanosAdditionalArgs
 */
export interface PrometheusSpecThanosAdditionalArgs {
  /**
   * Name of the argument, e.g. "scrape.discovery-reload-interval".
   *
   * @schema PrometheusSpecThanosAdditionalArgs#name
   */
  readonly name: string;

  /**
   * Argument value, e.g. 30s. Can be empty for name-only arguments (e.g. --storage.tsdb.no-lockfile)
   *
   * @schema PrometheusSpecThanosAdditionalArgs#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'PrometheusSpecThanosAdditionalArgs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecThanosAdditionalArgs(obj: PrometheusSpecThanosAdditionalArgs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configures the TLS parameters for the gRPC server providing the StoreAPI.
 *
 *
 * Note: Currently only the `caFile`, `certFile`, and `keyFile` fields are supported.
 *
 * @schema PrometheusSpecThanosGrpcServerTlsConfig
 */
export interface PrometheusSpecThanosGrpcServerTlsConfig {
  /**
   * Certificate authority used when verifying server certificates.
   *
   * @schema PrometheusSpecThanosGrpcServerTlsConfig#ca
   */
  readonly ca?: PrometheusSpecThanosGrpcServerTlsConfigCa;

  /**
   * Path to the CA cert in the Prometheus container to use for the targets.
   *
   * @schema PrometheusSpecThanosGrpcServerTlsConfig#caFile
   */
  readonly caFile?: string;

  /**
   * Client certificate to present when doing client-authentication.
   *
   * @schema PrometheusSpecThanosGrpcServerTlsConfig#cert
   */
  readonly cert?: PrometheusSpecThanosGrpcServerTlsConfigCert;

  /**
   * Path to the client cert file in the Prometheus container for the targets.
   *
   * @schema PrometheusSpecThanosGrpcServerTlsConfig#certFile
   */
  readonly certFile?: string;

  /**
   * Disable target certificate validation.
   *
   * @schema PrometheusSpecThanosGrpcServerTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Path to the client key file in the Prometheus container for the targets.
   *
   * @schema PrometheusSpecThanosGrpcServerTlsConfig#keyFile
   */
  readonly keyFile?: string;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema PrometheusSpecThanosGrpcServerTlsConfig#keySecret
   */
  readonly keySecret?: PrometheusSpecThanosGrpcServerTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema PrometheusSpecThanosGrpcServerTlsConfig#serverName
   */
  readonly serverName?: string;

}

/**
 * Converts an object of type 'PrometheusSpecThanosGrpcServerTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecThanosGrpcServerTlsConfig(obj: PrometheusSpecThanosGrpcServerTlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ca': toJson_PrometheusSpecThanosGrpcServerTlsConfigCa(obj.ca),
    'caFile': obj.caFile,
    'cert': toJson_PrometheusSpecThanosGrpcServerTlsConfigCert(obj.cert),
    'certFile': obj.certFile,
    'insecureSkipVerify': obj.insecureSkipVerify,
    'keyFile': obj.keyFile,
    'keySecret': toJson_PrometheusSpecThanosGrpcServerTlsConfigKeySecret(obj.keySecret),
    'serverName': obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Log format for the Thanos sidecar.
 *
 * @schema PrometheusSpecThanosLogFormat
 */
export enum PrometheusSpecThanosLogFormat {
  /** logfmt */
  LOGFMT = "logfmt",
  /** json */
  JSON = "json",
}

/**
 * Log level for the Thanos sidecar.
 *
 * @schema PrometheusSpecThanosLogLevel
 */
export enum PrometheusSpecThanosLogLevel {
  /** debug */
  DEBUG = "debug",
  /** info */
  INFO = "info",
  /** warn */
  WARN = "warn",
  /** error */
  ERROR = "error",
}

/**
 * Defines the Thanos sidecar's configuration to upload TSDB blocks to object storage.
 *
 *
 * More info: https://thanos.io/tip/thanos/storage.md/
 *
 *
 * objectStorageConfigFile takes precedence over this field.
 *
 * @schema PrometheusSpecThanosObjectStorageConfig
 */
export interface PrometheusSpecThanosObjectStorageConfig {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecThanosObjectStorageConfig#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecThanosObjectStorageConfig#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecThanosObjectStorageConfig#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecThanosObjectStorageConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecThanosObjectStorageConfig(obj: PrometheusSpecThanosObjectStorageConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Defines the resources requests and limits of the Thanos sidecar.
 *
 * @schema PrometheusSpecThanosResources
 */
export interface PrometheusSpecThanosResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema PrometheusSpecThanosResources#claims
   */
  readonly claims?: PrometheusSpecThanosResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema PrometheusSpecThanosResources#limits
   */
  readonly limits?: { [key: string]: PrometheusSpecThanosResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema PrometheusSpecThanosResources#requests
   */
  readonly requests?: { [key: string]: PrometheusSpecThanosResourcesRequests };

}

/**
 * Converts an object of type 'PrometheusSpecThanosResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecThanosResources(obj: PrometheusSpecThanosResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claims': obj.claims?.map(y => toJson_PrometheusSpecThanosResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Defines the tracing configuration for the Thanos sidecar.
 *
 *
 * `tracingConfigFile` takes precedence over this field.
 *
 *
 * More info: https://thanos.io/tip/thanos/tracing.md/
 *
 *
 * This is an *experimental feature*, it may change in any upcoming release
 * in a breaking way.
 *
 * @schema PrometheusSpecThanosTracingConfig
 */
export interface PrometheusSpecThanosTracingConfig {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecThanosTracingConfig#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecThanosTracingConfig#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecThanosTracingConfig#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecThanosTracingConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecThanosTracingConfig(obj: PrometheusSpecThanosTracingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema PrometheusSpecThanosVolumeMounts
 */
export interface PrometheusSpecThanosVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must
   * not contain ':'.
   *
   * @schema PrometheusSpecThanosVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host
   * to container and the other way around.
   * When not set, MountPropagationNone is used.
   * This field is beta in 1.10.
   *
   * @schema PrometheusSpecThanosVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema PrometheusSpecThanosVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified).
   * Defaults to false.
   *
   * @default false.
   * @schema PrometheusSpecThanosVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Path within the volume from which the container's volume should be mounted.
   * Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema PrometheusSpecThanosVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted.
   * Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
   * Defaults to "" (volume's root).
   * SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root).
   * @schema PrometheusSpecThanosVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;

}

/**
 * Converts an object of type 'PrometheusSpecThanosVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecThanosVolumeMounts(obj: PrometheusSpecThanosVolumeMounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'mountPropagation': obj.mountPropagation,
    'name': obj.name,
    'readOnly': obj.readOnly,
    'subPath': obj.subPath,
    'subPathExpr': obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Defines what Prometheus Operator managed labels should be added to labelSelector on the topologySpreadConstraint.
 *
 * @schema PrometheusSpecTopologySpreadConstraintsAdditionalLabelSelectors
 */
export enum PrometheusSpecTopologySpreadConstraintsAdditionalLabelSelectors {
  /** OnResource */
  ON_RESOURCE = "OnResource",
  /** OnShard */
  ON_SHARD = "OnShard",
}

/**
 * LabelSelector is used to find matching pods.
 * Pods that match this label selector are counted to determine the number of pods
 * in their corresponding topology domain.
 *
 * @schema PrometheusSpecTopologySpreadConstraintsLabelSelector
 */
export interface PrometheusSpecTopologySpreadConstraintsLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PrometheusSpecTopologySpreadConstraintsLabelSelector#matchExpressions
   */
  readonly matchExpressions?: PrometheusSpecTopologySpreadConstraintsLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PrometheusSpecTopologySpreadConstraintsLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'PrometheusSpecTopologySpreadConstraintsLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecTopologySpreadConstraintsLabelSelector(obj: PrometheusSpecTopologySpreadConstraintsLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_PrometheusSpecTopologySpreadConstraintsLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Client used to export the traces. Supported values are `http` or `grpc`.
 *
 * @schema PrometheusSpecTracingConfigClientType
 */
export enum PrometheusSpecTracingConfigClientType {
  /** http */
  HTTP = "http",
  /** grpc */
  GRPC = "grpc",
}

/**
 * Compression key for supported compression types. The only supported value is `gzip`.
 *
 * @schema PrometheusSpecTracingConfigCompression
 */
export enum PrometheusSpecTracingConfigCompression {
  /** gzip */
  GZIP = "gzip",
}

/**
 * Sets the probability a given trace will be sampled. Must be a float from 0 through 1.
 *
 * @schema PrometheusSpecTracingConfigSamplingFraction
 */
export class PrometheusSpecTracingConfigSamplingFraction {
  public static fromNumber(value: number): PrometheusSpecTracingConfigSamplingFraction {
    return new PrometheusSpecTracingConfigSamplingFraction(value);
  }
  public static fromString(value: string): PrometheusSpecTracingConfigSamplingFraction {
    return new PrometheusSpecTracingConfigSamplingFraction(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * TLS Config to use when sending traces.
 *
 * @schema PrometheusSpecTracingConfigTlsConfig
 */
export interface PrometheusSpecTracingConfigTlsConfig {
  /**
   * Certificate authority used when verifying server certificates.
   *
   * @schema PrometheusSpecTracingConfigTlsConfig#ca
   */
  readonly ca?: PrometheusSpecTracingConfigTlsConfigCa;

  /**
   * Path to the CA cert in the Prometheus container to use for the targets.
   *
   * @schema PrometheusSpecTracingConfigTlsConfig#caFile
   */
  readonly caFile?: string;

  /**
   * Client certificate to present when doing client-authentication.
   *
   * @schema PrometheusSpecTracingConfigTlsConfig#cert
   */
  readonly cert?: PrometheusSpecTracingConfigTlsConfigCert;

  /**
   * Path to the client cert file in the Prometheus container for the targets.
   *
   * @schema PrometheusSpecTracingConfigTlsConfig#certFile
   */
  readonly certFile?: string;

  /**
   * Disable target certificate validation.
   *
   * @schema PrometheusSpecTracingConfigTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Path to the client key file in the Prometheus container for the targets.
   *
   * @schema PrometheusSpecTracingConfigTlsConfig#keyFile
   */
  readonly keyFile?: string;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema PrometheusSpecTracingConfigTlsConfig#keySecret
   */
  readonly keySecret?: PrometheusSpecTracingConfigTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema PrometheusSpecTracingConfigTlsConfig#serverName
   */
  readonly serverName?: string;

}

/**
 * Converts an object of type 'PrometheusSpecTracingConfigTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecTracingConfigTlsConfig(obj: PrometheusSpecTracingConfigTlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ca': toJson_PrometheusSpecTracingConfigTlsConfigCa(obj.ca),
    'caFile': obj.caFile,
    'cert': toJson_PrometheusSpecTracingConfigTlsConfigCert(obj.cert),
    'certFile': obj.certFile,
    'insecureSkipVerify': obj.insecureSkipVerify,
    'keyFile': obj.keyFile,
    'keySecret': toJson_PrometheusSpecTracingConfigTlsConfigKeySecret(obj.keySecret),
    'serverName': obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * awsElasticBlockStore represents an AWS Disk resource that is attached to a
 * kubelet's host machine and then exposed to the pod.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
 *
 * @schema PrometheusSpecVolumesAwsElasticBlockStore
 */
export interface PrometheusSpecVolumesAwsElasticBlockStore {
  /**
   * fsType is the filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   * TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema PrometheusSpecVolumesAwsElasticBlockStore#fsType
   */
  readonly fsType?: string;

  /**
   * partition is the partition in the volume that you want to mount.
   * If omitted, the default is to mount by volume name.
   * Examples: For volume /dev/sda1, you specify the partition as "1".
   * Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
   *
   * @schema PrometheusSpecVolumesAwsElasticBlockStore#partition
   */
  readonly partition?: number;

  /**
   * readOnly value true will force the readOnly setting in VolumeMounts.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema PrometheusSpecVolumesAwsElasticBlockStore#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * volumeID is unique ID of the persistent disk resource in AWS (Amazon EBS volume).
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema PrometheusSpecVolumesAwsElasticBlockStore#volumeID
   */
  readonly volumeId: string;

}

/**
 * Converts an object of type 'PrometheusSpecVolumesAwsElasticBlockStore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesAwsElasticBlockStore(obj: PrometheusSpecVolumesAwsElasticBlockStore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'partition': obj.partition,
    'readOnly': obj.readOnly,
    'volumeID': obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
 *
 * @schema PrometheusSpecVolumesAzureDisk
 */
export interface PrometheusSpecVolumesAzureDisk {
  /**
   * cachingMode is the Host Caching mode: None, Read Only, Read Write.
   *
   * @schema PrometheusSpecVolumesAzureDisk#cachingMode
   */
  readonly cachingMode?: string;

  /**
   * diskName is the Name of the data disk in the blob storage
   *
   * @schema PrometheusSpecVolumesAzureDisk#diskName
   */
  readonly diskName: string;

  /**
   * diskURI is the URI of data disk in the blob storage
   *
   * @schema PrometheusSpecVolumesAzureDisk#diskURI
   */
  readonly diskUri: string;

  /**
   * fsType is Filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema PrometheusSpecVolumesAzureDisk#fsType
   */
  readonly fsType?: string;

  /**
   * kind expected values are Shared: multiple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared
   *
   * @schema PrometheusSpecVolumesAzureDisk#kind
   */
  readonly kind?: string;

  /**
   * readOnly Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force
   * @schema PrometheusSpecVolumesAzureDisk#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecVolumesAzureDisk' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesAzureDisk(obj: PrometheusSpecVolumesAzureDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cachingMode': obj.cachingMode,
    'diskName': obj.diskName,
    'diskURI': obj.diskUri,
    'fsType': obj.fsType,
    'kind': obj.kind,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * azureFile represents an Azure File Service mount on the host and bind mount to the pod.
 *
 * @schema PrometheusSpecVolumesAzureFile
 */
export interface PrometheusSpecVolumesAzureFile {
  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @schema PrometheusSpecVolumesAzureFile#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretName is the  name of secret that contains Azure Storage Account Name and Key
   *
   * @schema PrometheusSpecVolumesAzureFile#secretName
   */
  readonly secretName: string;

  /**
   * shareName is the azure share Name
   *
   * @schema PrometheusSpecVolumesAzureFile#shareName
   */
  readonly shareName: string;

}

/**
 * Converts an object of type 'PrometheusSpecVolumesAzureFile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesAzureFile(obj: PrometheusSpecVolumesAzureFile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'readOnly': obj.readOnly,
    'secretName': obj.secretName,
    'shareName': obj.shareName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * cephFS represents a Ceph FS mount on the host that shares a pod's lifetime
 *
 * @schema PrometheusSpecVolumesCephfs
 */
export interface PrometheusSpecVolumesCephfs {
  /**
   * monitors is Required: Monitors is a collection of Ceph monitors
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema PrometheusSpecVolumesCephfs#monitors
   */
  readonly monitors: string[];

  /**
   * path is Optional: Used as the mounted root, rather than the full Ceph tree, default is /
   *
   * @schema PrometheusSpecVolumesCephfs#path
   */
  readonly path?: string;

  /**
   * readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @default false (read/write). ReadOnly here will force
   * @schema PrometheusSpecVolumesCephfs#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretFile is Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema PrometheusSpecVolumesCephfs#secretFile
   */
  readonly secretFile?: string;

  /**
   * secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty.
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema PrometheusSpecVolumesCephfs#secretRef
   */
  readonly secretRef?: PrometheusSpecVolumesCephfsSecretRef;

  /**
   * user is optional: User is the rados user name, default is admin
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema PrometheusSpecVolumesCephfs#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'PrometheusSpecVolumesCephfs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesCephfs(obj: PrometheusSpecVolumesCephfs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'monitors': obj.monitors?.map(y => y),
    'path': obj.path,
    'readOnly': obj.readOnly,
    'secretFile': obj.secretFile,
    'secretRef': toJson_PrometheusSpecVolumesCephfsSecretRef(obj.secretRef),
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * cinder represents a cinder volume attached and mounted on kubelets host machine.
 * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
 *
 * @schema PrometheusSpecVolumesCinder
 */
export interface PrometheusSpecVolumesCinder {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema PrometheusSpecVolumesCinder#fsType
   */
  readonly fsType?: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema PrometheusSpecVolumesCinder#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is optional: points to a secret object containing parameters used to connect
   * to OpenStack.
   *
   * @schema PrometheusSpecVolumesCinder#secretRef
   */
  readonly secretRef?: PrometheusSpecVolumesCinderSecretRef;

  /**
   * volumeID used to identify the volume in cinder.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema PrometheusSpecVolumesCinder#volumeID
   */
  readonly volumeId: string;

}

/**
 * Converts an object of type 'PrometheusSpecVolumesCinder' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesCinder(obj: PrometheusSpecVolumesCinder | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'readOnly': obj.readOnly,
    'secretRef': toJson_PrometheusSpecVolumesCinderSecretRef(obj.secretRef),
    'volumeID': obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * configMap represents a configMap that should populate this volume
 *
 * @schema PrometheusSpecVolumesConfigMap
 */
export interface PrometheusSpecVolumesConfigMap {
  /**
   * defaultMode is optional: mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * Defaults to 0644.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644.
   * @schema PrometheusSpecVolumesConfigMap#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * items if unspecified, each key-value pair in the Data field of the referenced
   * ConfigMap will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the ConfigMap,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   *
   * @schema PrometheusSpecVolumesConfigMap#items
   */
  readonly items?: PrometheusSpecVolumesConfigMapItems[];

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecVolumesConfigMap#name
   */
  readonly name?: string;

  /**
   * optional specify whether the ConfigMap or its keys must be defined
   *
   * @schema PrometheusSpecVolumesConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecVolumesConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesConfigMap(obj: PrometheusSpecVolumesConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_PrometheusSpecVolumesConfigMapItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers (Beta feature).
 *
 * @schema PrometheusSpecVolumesCsi
 */
export interface PrometheusSpecVolumesCsi {
  /**
   * driver is the name of the CSI driver that handles this volume.
   * Consult with your admin for the correct name as registered in the cluster.
   *
   * @schema PrometheusSpecVolumesCsi#driver
   */
  readonly driver: string;

  /**
   * fsType to mount. Ex. "ext4", "xfs", "ntfs".
   * If not provided, the empty value is passed to the associated CSI driver
   * which will determine the default filesystem to apply.
   *
   * @schema PrometheusSpecVolumesCsi#fsType
   */
  readonly fsType?: string;

  /**
   * nodePublishSecretRef is a reference to the secret object containing
   * sensitive information to pass to the CSI driver to complete the CSI
   * NodePublishVolume and NodeUnpublishVolume calls.
   * This field is optional, and  may be empty if no secret is required. If the
   * secret object contains more than one secret, all secret references are passed.
   *
   * @schema PrometheusSpecVolumesCsi#nodePublishSecretRef
   */
  readonly nodePublishSecretRef?: PrometheusSpecVolumesCsiNodePublishSecretRef;

  /**
   * readOnly specifies a read-only configuration for the volume.
   * Defaults to false (read/write).
   *
   * @default false (read/write).
   * @schema PrometheusSpecVolumesCsi#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * volumeAttributes stores driver-specific properties that are passed to the CSI
   * driver. Consult your driver's documentation for supported values.
   *
   * @schema PrometheusSpecVolumesCsi#volumeAttributes
   */
  readonly volumeAttributes?: { [key: string]: string };

}

/**
 * Converts an object of type 'PrometheusSpecVolumesCsi' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesCsi(obj: PrometheusSpecVolumesCsi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'driver': obj.driver,
    'fsType': obj.fsType,
    'nodePublishSecretRef': toJson_PrometheusSpecVolumesCsiNodePublishSecretRef(obj.nodePublishSecretRef),
    'readOnly': obj.readOnly,
    'volumeAttributes': ((obj.volumeAttributes) === undefined) ? undefined : (Object.entries(obj.volumeAttributes).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * downwardAPI represents downward API about the pod that should populate this volume
 *
 * @schema PrometheusSpecVolumesDownwardApi
 */
export interface PrometheusSpecVolumesDownwardApi {
  /**
   * Optional: mode bits to use on created files by default. Must be a
   * Optional: mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * Defaults to 0644.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644.
   * @schema PrometheusSpecVolumesDownwardApi#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * Items is a list of downward API volume file
   *
   * @schema PrometheusSpecVolumesDownwardApi#items
   */
  readonly items?: PrometheusSpecVolumesDownwardApiItems[];

}

/**
 * Converts an object of type 'PrometheusSpecVolumesDownwardApi' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesDownwardApi(obj: PrometheusSpecVolumesDownwardApi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_PrometheusSpecVolumesDownwardApiItems(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * emptyDir represents a temporary directory that shares a pod's lifetime.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
 *
 * @schema PrometheusSpecVolumesEmptyDir
 */
export interface PrometheusSpecVolumesEmptyDir {
  /**
   * medium represents what type of storage medium should back this directory.
   * The default is "" which means to use the node's default medium.
   * Must be an empty string (default) or Memory.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema PrometheusSpecVolumesEmptyDir#medium
   */
  readonly medium?: string;

  /**
   * sizeLimit is the total amount of local storage required for this EmptyDir volume.
   * The size limit is also applicable for memory medium.
   * The maximum usage on memory medium EmptyDir would be the minimum value between
   * the SizeLimit specified here and the sum of memory limits of all containers in a pod.
   * The default is nil which means that the limit is undefined.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema PrometheusSpecVolumesEmptyDir#sizeLimit
   */
  readonly sizeLimit?: PrometheusSpecVolumesEmptyDirSizeLimit;

}

/**
 * Converts an object of type 'PrometheusSpecVolumesEmptyDir' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesEmptyDir(obj: PrometheusSpecVolumesEmptyDir | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'medium': obj.medium,
    'sizeLimit': obj.sizeLimit?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ephemeral represents a volume that is handled by a cluster storage driver.
 * The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts,
 * and deleted when the pod is removed.
 *
 *
 * Use this if:
 * a) the volume is only needed while the pod runs,
 * b) features of normal volumes like restoring from snapshot or capacity
 * tracking are needed,
 * c) the storage driver is specified through a storage class, and
 * d) the storage driver supports dynamic volume provisioning through
 * a PersistentVolumeClaim (see EphemeralVolumeSource for more
 * information on the connection between this volume type
 * and PersistentVolumeClaim).
 *
 *
 * Use PersistentVolumeClaim or one of the vendor-specific
 * APIs for volumes that persist for longer than the lifecycle
 * of an individual pod.
 *
 *
 * Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to
 * be used that way - see the documentation of the driver for
 * more information.
 *
 *
 * A pod can use both types of ephemeral volumes and
 * persistent volumes at the same time.
 *
 * @schema PrometheusSpecVolumesEphemeral
 */
export interface PrometheusSpecVolumesEphemeral {
  /**
   * Will be used to create a stand-alone PVC to provision the volume.
   * The pod in which this EphemeralVolumeSource is embedded will be the
   * owner of the PVC, i.e. the PVC will be deleted together with the
   * pod.  The name of the PVC will be `<pod name>-<volume name>` where
   * `<volume name>` is the name from the `PodSpec.Volumes` array
   * entry. Pod validation will reject the pod if the concatenated name
   * is not valid for a PVC (for example, too long).
   *
   *
   * An existing PVC with that name that is not owned by the pod
   * will *not* be used for the pod to avoid using an unrelated
   * volume by mistake. Starting the pod is then blocked until
   * the unrelated PVC is removed. If such a pre-created PVC is
   * meant to be used by the pod, the PVC has to updated with an
   * owner reference to the pod once the pod exists. Normally
   * this should not be necessary, but it may be useful when
   * manually reconstructing a broken cluster.
   *
   *
   * This field is read-only and no changes will be made by Kubernetes
   * to the PVC after it has been created.
   *
   *
   * Required, must not be nil.
   *
   * @schema PrometheusSpecVolumesEphemeral#volumeClaimTemplate
   */
  readonly volumeClaimTemplate?: PrometheusSpecVolumesEphemeralVolumeClaimTemplate;

}

/**
 * Converts an object of type 'PrometheusSpecVolumesEphemeral' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesEphemeral(obj: PrometheusSpecVolumesEphemeral | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'volumeClaimTemplate': toJson_PrometheusSpecVolumesEphemeralVolumeClaimTemplate(obj.volumeClaimTemplate),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
 *
 * @schema PrometheusSpecVolumesFc
 */
export interface PrometheusSpecVolumesFc {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema PrometheusSpecVolumesFc#fsType
   */
  readonly fsType?: string;

  /**
   * lun is Optional: FC target lun number
   *
   * @schema PrometheusSpecVolumesFc#lun
   */
  readonly lun?: number;

  /**
   * readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force
   * @schema PrometheusSpecVolumesFc#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * targetWWNs is Optional: FC target worldwide names (WWNs)
   *
   * @schema PrometheusSpecVolumesFc#targetWWNs
   */
  readonly targetWwNs?: string[];

  /**
   * wwids Optional: FC volume world wide identifiers (wwids)
   * Either wwids or combination of targetWWNs and lun must be set, but not both simultaneously.
   *
   * @schema PrometheusSpecVolumesFc#wwids
   */
  readonly wwids?: string[];

}

/**
 * Converts an object of type 'PrometheusSpecVolumesFc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesFc(obj: PrometheusSpecVolumesFc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'lun': obj.lun,
    'readOnly': obj.readOnly,
    'targetWWNs': obj.targetWwNs?.map(y => y),
    'wwids': obj.wwids?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * flexVolume represents a generic volume resource that is
 * provisioned/attached using an exec based plugin.
 *
 * @schema PrometheusSpecVolumesFlexVolume
 */
export interface PrometheusSpecVolumesFlexVolume {
  /**
   * driver is the name of the driver to use for this volume.
   *
   * @schema PrometheusSpecVolumesFlexVolume#driver
   */
  readonly driver: string;

  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
   *
   * @schema PrometheusSpecVolumesFlexVolume#fsType
   */
  readonly fsType?: string;

  /**
   * options is Optional: this field holds extra command options if any.
   *
   * @schema PrometheusSpecVolumesFlexVolume#options
   */
  readonly options?: { [key: string]: string };

  /**
   * readOnly is Optional: defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @schema PrometheusSpecVolumesFlexVolume#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is Optional: secretRef is reference to the secret object containing
   * sensitive information to pass to the plugin scripts. This may be
   * empty if no secret object is specified. If the secret object
   * contains more than one secret, all secrets are passed to the plugin
   * scripts.
   *
   * @schema PrometheusSpecVolumesFlexVolume#secretRef
   */
  readonly secretRef?: PrometheusSpecVolumesFlexVolumeSecretRef;

}

/**
 * Converts an object of type 'PrometheusSpecVolumesFlexVolume' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesFlexVolume(obj: PrometheusSpecVolumesFlexVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'driver': obj.driver,
    'fsType': obj.fsType,
    'options': ((obj.options) === undefined) ? undefined : (Object.entries(obj.options).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'readOnly': obj.readOnly,
    'secretRef': toJson_PrometheusSpecVolumesFlexVolumeSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running
 *
 * @schema PrometheusSpecVolumesFlocker
 */
export interface PrometheusSpecVolumesFlocker {
  /**
   * datasetName is Name of the dataset stored as metadata -> name on the dataset for Flocker
   * should be considered as deprecated
   *
   * @schema PrometheusSpecVolumesFlocker#datasetName
   */
  readonly datasetName?: string;

  /**
   * datasetUUID is the UUID of the dataset. This is unique identifier of a Flocker dataset
   *
   * @schema PrometheusSpecVolumesFlocker#datasetUUID
   */
  readonly datasetUuid?: string;

}

/**
 * Converts an object of type 'PrometheusSpecVolumesFlocker' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesFlocker(obj: PrometheusSpecVolumesFlocker | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'datasetName': obj.datasetName,
    'datasetUUID': obj.datasetUuid,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * gcePersistentDisk represents a GCE Disk resource that is attached to a
 * kubelet's host machine and then exposed to the pod.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
 *
 * @schema PrometheusSpecVolumesGcePersistentDisk
 */
export interface PrometheusSpecVolumesGcePersistentDisk {
  /**
   * fsType is filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   * TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema PrometheusSpecVolumesGcePersistentDisk#fsType
   */
  readonly fsType?: string;

  /**
   * partition is the partition in the volume that you want to mount.
   * If omitted, the default is to mount by volume name.
   * Examples: For volume /dev/sda1, you specify the partition as "1".
   * Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema PrometheusSpecVolumesGcePersistentDisk#partition
   */
  readonly partition?: number;

  /**
   * pdName is unique name of the PD resource in GCE. Used to identify the disk in GCE.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema PrometheusSpecVolumesGcePersistentDisk#pdName
   */
  readonly pdName: string;

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts.
   * Defaults to false.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @default false.
   * @schema PrometheusSpecVolumesGcePersistentDisk#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecVolumesGcePersistentDisk' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesGcePersistentDisk(obj: PrometheusSpecVolumesGcePersistentDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'partition': obj.partition,
    'pdName': obj.pdName,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * gitRepo represents a git repository at a particular revision.
 * DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an
 * EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir
 * into the Pod's container.
 *
 * @schema PrometheusSpecVolumesGitRepo
 */
export interface PrometheusSpecVolumesGitRepo {
  /**
   * directory is the target directory name.
   * Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the
   * git repository.  Otherwise, if specified, the volume will contain the git repository in
   * the subdirectory with the given name.
   *
   * @schema PrometheusSpecVolumesGitRepo#directory
   */
  readonly directory?: string;

  /**
   * repository is the URL
   *
   * @schema PrometheusSpecVolumesGitRepo#repository
   */
  readonly repository: string;

  /**
   * revision is the commit hash for the specified revision.
   *
   * @schema PrometheusSpecVolumesGitRepo#revision
   */
  readonly revision?: string;

}

/**
 * Converts an object of type 'PrometheusSpecVolumesGitRepo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesGitRepo(obj: PrometheusSpecVolumesGitRepo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'directory': obj.directory,
    'repository': obj.repository,
    'revision': obj.revision,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime.
 * More info: https://examples.k8s.io/volumes/glusterfs/README.md
 *
 * @schema PrometheusSpecVolumesGlusterfs
 */
export interface PrometheusSpecVolumesGlusterfs {
  /**
   * endpoints is the endpoint name that details Glusterfs topology.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @schema PrometheusSpecVolumesGlusterfs#endpoints
   */
  readonly endpoints: string;

  /**
   * path is the Glusterfs volume path.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @schema PrometheusSpecVolumesGlusterfs#path
   */
  readonly path: string;

  /**
   * readOnly here will force the Glusterfs volume to be mounted with read-only permissions.
   * Defaults to false.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @default false.
   * @schema PrometheusSpecVolumesGlusterfs#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecVolumesGlusterfs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesGlusterfs(obj: PrometheusSpecVolumesGlusterfs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'endpoints': obj.endpoints,
    'path': obj.path,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * hostPath represents a pre-existing file or directory on the host
 * machine that is directly exposed to the container. This is generally
 * used for system agents or other privileged things that are allowed
 * to see the host machine. Most containers will NOT need this.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
 * ---
 * TODO(jonesdl) We need to restrict who can use host directory mounts and who can/can not
 * mount host directories as read/write.
 *
 * @schema PrometheusSpecVolumesHostPath
 */
export interface PrometheusSpecVolumesHostPath {
  /**
   * path of the directory on the host.
   * If the path is a symlink, it will follow the link to the real path.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @schema PrometheusSpecVolumesHostPath#path
   */
  readonly path: string;

  /**
   * type for HostPath Volume
   * Defaults to ""
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @default More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   * @schema PrometheusSpecVolumesHostPath#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'PrometheusSpecVolumesHostPath' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesHostPath(obj: PrometheusSpecVolumesHostPath | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * iscsi represents an ISCSI Disk resource that is attached to a
 * kubelet's host machine and then exposed to the pod.
 * More info: https://examples.k8s.io/volumes/iscsi/README.md
 *
 * @schema PrometheusSpecVolumesIscsi
 */
export interface PrometheusSpecVolumesIscsi {
  /**
   * chapAuthDiscovery defines whether support iSCSI Discovery CHAP authentication
   *
   * @schema PrometheusSpecVolumesIscsi#chapAuthDiscovery
   */
  readonly chapAuthDiscovery?: boolean;

  /**
   * chapAuthSession defines whether support iSCSI Session CHAP authentication
   *
   * @schema PrometheusSpecVolumesIscsi#chapAuthSession
   */
  readonly chapAuthSession?: boolean;

  /**
   * fsType is the filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi
   * TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema PrometheusSpecVolumesIscsi#fsType
   */
  readonly fsType?: string;

  /**
   * initiatorName is the custom iSCSI Initiator Name.
   * If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface
   * <target portal>:<volume name> will be created for the connection.
   *
   * @schema PrometheusSpecVolumesIscsi#initiatorName
   */
  readonly initiatorName?: string;

  /**
   * iqn is the target iSCSI Qualified Name.
   *
   * @schema PrometheusSpecVolumesIscsi#iqn
   */
  readonly iqn: string;

  /**
   * iscsiInterface is the interface Name that uses an iSCSI transport.
   * Defaults to 'default' (tcp).
   *
   * @default default' (tcp).
   * @schema PrometheusSpecVolumesIscsi#iscsiInterface
   */
  readonly iscsiInterface?: string;

  /**
   * lun represents iSCSI Target Lun number.
   *
   * @schema PrometheusSpecVolumesIscsi#lun
   */
  readonly lun: number;

  /**
   * portals is the iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port
   * is other than default (typically TCP ports 860 and 3260).
   *
   * @schema PrometheusSpecVolumesIscsi#portals
   */
  readonly portals?: string[];

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts.
   * Defaults to false.
   *
   * @default false.
   * @schema PrometheusSpecVolumesIscsi#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is the CHAP Secret for iSCSI target and initiator authentication
   *
   * @schema PrometheusSpecVolumesIscsi#secretRef
   */
  readonly secretRef?: PrometheusSpecVolumesIscsiSecretRef;

  /**
   * targetPortal is iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port
   * is other than default (typically TCP ports 860 and 3260).
   *
   * @schema PrometheusSpecVolumesIscsi#targetPortal
   */
  readonly targetPortal: string;

}

/**
 * Converts an object of type 'PrometheusSpecVolumesIscsi' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesIscsi(obj: PrometheusSpecVolumesIscsi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'chapAuthDiscovery': obj.chapAuthDiscovery,
    'chapAuthSession': obj.chapAuthSession,
    'fsType': obj.fsType,
    'initiatorName': obj.initiatorName,
    'iqn': obj.iqn,
    'iscsiInterface': obj.iscsiInterface,
    'lun': obj.lun,
    'portals': obj.portals?.map(y => y),
    'readOnly': obj.readOnly,
    'secretRef': toJson_PrometheusSpecVolumesIscsiSecretRef(obj.secretRef),
    'targetPortal': obj.targetPortal,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * nfs represents an NFS mount on the host that shares a pod's lifetime
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
 *
 * @schema PrometheusSpecVolumesNfs
 */
export interface PrometheusSpecVolumesNfs {
  /**
   * path that is exported by the NFS server.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema PrometheusSpecVolumesNfs#path
   */
  readonly path: string;

  /**
   * readOnly here will force the NFS export to be mounted with read-only permissions.
   * Defaults to false.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @default false.
   * @schema PrometheusSpecVolumesNfs#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * server is the hostname or IP address of the NFS server.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema PrometheusSpecVolumesNfs#server
   */
  readonly server: string;

}

/**
 * Converts an object of type 'PrometheusSpecVolumesNfs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesNfs(obj: PrometheusSpecVolumesNfs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'readOnly': obj.readOnly,
    'server': obj.server,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * persistentVolumeClaimVolumeSource represents a reference to a
 * PersistentVolumeClaim in the same namespace.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
 *
 * @schema PrometheusSpecVolumesPersistentVolumeClaim
 */
export interface PrometheusSpecVolumesPersistentVolumeClaim {
  /**
   * claimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema PrometheusSpecVolumesPersistentVolumeClaim#claimName
   */
  readonly claimName: string;

  /**
   * readOnly Will force the ReadOnly setting in VolumeMounts.
   * Default false.
   *
   * @schema PrometheusSpecVolumesPersistentVolumeClaim#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecVolumesPersistentVolumeClaim' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesPersistentVolumeClaim(obj: PrometheusSpecVolumesPersistentVolumeClaim | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claimName': obj.claimName,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
 *
 * @schema PrometheusSpecVolumesPhotonPersistentDisk
 */
export interface PrometheusSpecVolumesPhotonPersistentDisk {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema PrometheusSpecVolumesPhotonPersistentDisk#fsType
   */
  readonly fsType?: string;

  /**
   * pdID is the ID that identifies Photon Controller persistent disk
   *
   * @schema PrometheusSpecVolumesPhotonPersistentDisk#pdID
   */
  readonly pdId: string;

}

/**
 * Converts an object of type 'PrometheusSpecVolumesPhotonPersistentDisk' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesPhotonPersistentDisk(obj: PrometheusSpecVolumesPhotonPersistentDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'pdID': obj.pdId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * portworxVolume represents a portworx volume attached and mounted on kubelets host machine
 *
 * @schema PrometheusSpecVolumesPortworxVolume
 */
export interface PrometheusSpecVolumesPortworxVolume {
  /**
   * fSType represents the filesystem type to mount
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema PrometheusSpecVolumesPortworxVolume#fsType
   */
  readonly fsType?: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @schema PrometheusSpecVolumesPortworxVolume#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * volumeID uniquely identifies a Portworx volume
   *
   * @schema PrometheusSpecVolumesPortworxVolume#volumeID
   */
  readonly volumeId: string;

}

/**
 * Converts an object of type 'PrometheusSpecVolumesPortworxVolume' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesPortworxVolume(obj: PrometheusSpecVolumesPortworxVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'readOnly': obj.readOnly,
    'volumeID': obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * projected items for all in one resources secrets, configmaps, and downward API
 *
 * @schema PrometheusSpecVolumesProjected
 */
export interface PrometheusSpecVolumesProjected {
  /**
   * defaultMode are the mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema PrometheusSpecVolumesProjected#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * sources is the list of volume projections
   *
   * @schema PrometheusSpecVolumesProjected#sources
   */
  readonly sources?: PrometheusSpecVolumesProjectedSources[];

}

/**
 * Converts an object of type 'PrometheusSpecVolumesProjected' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesProjected(obj: PrometheusSpecVolumesProjected | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'sources': obj.sources?.map(y => toJson_PrometheusSpecVolumesProjectedSources(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * quobyte represents a Quobyte mount on the host that shares a pod's lifetime
 *
 * @schema PrometheusSpecVolumesQuobyte
 */
export interface PrometheusSpecVolumesQuobyte {
  /**
   * group to map volume access to
   * Default is no group
   *
   * @default no group
   * @schema PrometheusSpecVolumesQuobyte#group
   */
  readonly group?: string;

  /**
   * readOnly here will force the Quobyte volume to be mounted with read-only permissions.
   * Defaults to false.
   *
   * @default false.
   * @schema PrometheusSpecVolumesQuobyte#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * registry represents a single or multiple Quobyte Registry services
   * specified as a string as host:port pair (multiple entries are separated with commas)
   * which acts as the central registry for volumes
   *
   * @schema PrometheusSpecVolumesQuobyte#registry
   */
  readonly registry: string;

  /**
   * tenant owning the given Quobyte volume in the Backend
   * Used with dynamically provisioned Quobyte volumes, value is set by the plugin
   *
   * @schema PrometheusSpecVolumesQuobyte#tenant
   */
  readonly tenant?: string;

  /**
   * user to map volume access to
   * Defaults to serivceaccount user
   *
   * @default serivceaccount user
   * @schema PrometheusSpecVolumesQuobyte#user
   */
  readonly user?: string;

  /**
   * volume is a string that references an already created Quobyte volume by name.
   *
   * @schema PrometheusSpecVolumesQuobyte#volume
   */
  readonly volume: string;

}

/**
 * Converts an object of type 'PrometheusSpecVolumesQuobyte' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesQuobyte(obj: PrometheusSpecVolumesQuobyte | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'readOnly': obj.readOnly,
    'registry': obj.registry,
    'tenant': obj.tenant,
    'user': obj.user,
    'volume': obj.volume,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * rbd represents a Rados Block Device mount on the host that shares a pod's lifetime.
 * More info: https://examples.k8s.io/volumes/rbd/README.md
 *
 * @schema PrometheusSpecVolumesRbd
 */
export interface PrometheusSpecVolumesRbd {
  /**
   * fsType is the filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd
   * TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema PrometheusSpecVolumesRbd#fsType
   */
  readonly fsType?: string;

  /**
   * image is the rados image name.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @schema PrometheusSpecVolumesRbd#image
   */
  readonly image: string;

  /**
   * keyring is the path to key ring for RBDUser.
   * Default is /etc/ceph/keyring.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default etc/ceph/keyring.
   * @schema PrometheusSpecVolumesRbd#keyring
   */
  readonly keyring?: string;

  /**
   * monitors is a collection of Ceph monitors.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @schema PrometheusSpecVolumesRbd#monitors
   */
  readonly monitors: string[];

  /**
   * pool is the rados pool name.
   * Default is rbd.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default rbd.
   * @schema PrometheusSpecVolumesRbd#pool
   */
  readonly pool?: string;

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts.
   * Defaults to false.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default false.
   * @schema PrometheusSpecVolumesRbd#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is name of the authentication secret for RBDUser. If provided
   * overrides keyring.
   * Default is nil.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default nil.
   * @schema PrometheusSpecVolumesRbd#secretRef
   */
  readonly secretRef?: PrometheusSpecVolumesRbdSecretRef;

  /**
   * user is the rados user name.
   * Default is admin.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default admin.
   * @schema PrometheusSpecVolumesRbd#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'PrometheusSpecVolumesRbd' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesRbd(obj: PrometheusSpecVolumesRbd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'image': obj.image,
    'keyring': obj.keyring,
    'monitors': obj.monitors?.map(y => y),
    'pool': obj.pool,
    'readOnly': obj.readOnly,
    'secretRef': toJson_PrometheusSpecVolumesRbdSecretRef(obj.secretRef),
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
 *
 * @schema PrometheusSpecVolumesScaleIo
 */
export interface PrometheusSpecVolumesScaleIo {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs".
   * Default is "xfs".
   *
   * @default xfs".
   * @schema PrometheusSpecVolumesScaleIo#fsType
   */
  readonly fsType?: string;

  /**
   * gateway is the host address of the ScaleIO API Gateway.
   *
   * @schema PrometheusSpecVolumesScaleIo#gateway
   */
  readonly gateway: string;

  /**
   * protectionDomain is the name of the ScaleIO Protection Domain for the configured storage.
   *
   * @schema PrometheusSpecVolumesScaleIo#protectionDomain
   */
  readonly protectionDomain?: string;

  /**
   * readOnly Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force
   * @schema PrometheusSpecVolumesScaleIo#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef references to the secret for ScaleIO user and other
   * sensitive information. If this is not provided, Login operation will fail.
   *
   * @schema PrometheusSpecVolumesScaleIo#secretRef
   */
  readonly secretRef: PrometheusSpecVolumesScaleIoSecretRef;

  /**
   * sslEnabled Flag enable/disable SSL communication with Gateway, default false
   *
   * @schema PrometheusSpecVolumesScaleIo#sslEnabled
   */
  readonly sslEnabled?: boolean;

  /**
   * storageMode indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned.
   * Default is ThinProvisioned.
   *
   * @default ThinProvisioned.
   * @schema PrometheusSpecVolumesScaleIo#storageMode
   */
  readonly storageMode?: string;

  /**
   * storagePool is the ScaleIO Storage Pool associated with the protection domain.
   *
   * @schema PrometheusSpecVolumesScaleIo#storagePool
   */
  readonly storagePool?: string;

  /**
   * system is the name of the storage system as configured in ScaleIO.
   *
   * @schema PrometheusSpecVolumesScaleIo#system
   */
  readonly system: string;

  /**
   * volumeName is the name of a volume already created in the ScaleIO system
   * that is associated with this volume source.
   *
   * @schema PrometheusSpecVolumesScaleIo#volumeName
   */
  readonly volumeName?: string;

}

/**
 * Converts an object of type 'PrometheusSpecVolumesScaleIo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesScaleIo(obj: PrometheusSpecVolumesScaleIo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'gateway': obj.gateway,
    'protectionDomain': obj.protectionDomain,
    'readOnly': obj.readOnly,
    'secretRef': toJson_PrometheusSpecVolumesScaleIoSecretRef(obj.secretRef),
    'sslEnabled': obj.sslEnabled,
    'storageMode': obj.storageMode,
    'storagePool': obj.storagePool,
    'system': obj.system,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * secret represents a secret that should populate this volume.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
 *
 * @schema PrometheusSpecVolumesSecret
 */
export interface PrometheusSpecVolumesSecret {
  /**
   * defaultMode is Optional: mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values
   * for mode bits. Defaults to 0644.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644.
   * @schema PrometheusSpecVolumesSecret#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * items If unspecified, each key-value pair in the Data field of the referenced
   * Secret will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the Secret,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   *
   * @schema PrometheusSpecVolumesSecret#items
   */
  readonly items?: PrometheusSpecVolumesSecretItems[];

  /**
   * optional field specify whether the Secret or its keys must be defined
   *
   * @schema PrometheusSpecVolumesSecret#optional
   */
  readonly optional?: boolean;

  /**
   * secretName is the name of the secret in the pod's namespace to use.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   *
   * @schema PrometheusSpecVolumesSecret#secretName
   */
  readonly secretName?: string;

}

/**
 * Converts an object of type 'PrometheusSpecVolumesSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesSecret(obj: PrometheusSpecVolumesSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_PrometheusSpecVolumesSecretItems(y)),
    'optional': obj.optional,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
 *
 * @schema PrometheusSpecVolumesStorageos
 */
export interface PrometheusSpecVolumesStorageos {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema PrometheusSpecVolumesStorageos#fsType
   */
  readonly fsType?: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @schema PrometheusSpecVolumesStorageos#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef specifies the secret to use for obtaining the StorageOS API
   * credentials.  If not specified, default values will be attempted.
   *
   * @schema PrometheusSpecVolumesStorageos#secretRef
   */
  readonly secretRef?: PrometheusSpecVolumesStorageosSecretRef;

  /**
   * volumeName is the human-readable name of the StorageOS volume.  Volume
   * names are only unique within a namespace.
   *
   * @schema PrometheusSpecVolumesStorageos#volumeName
   */
  readonly volumeName?: string;

  /**
   * volumeNamespace specifies the scope of the volume within StorageOS.  If no
   * namespace is specified then the Pod's namespace will be used.  This allows the
   * Kubernetes name scoping to be mirrored within StorageOS for tighter integration.
   * Set VolumeName to any name to override the default behaviour.
   * Set to "default" if you are not using namespaces within StorageOS.
   * Namespaces that do not pre-exist within StorageOS will be created.
   *
   * @schema PrometheusSpecVolumesStorageos#volumeNamespace
   */
  readonly volumeNamespace?: string;

}

/**
 * Converts an object of type 'PrometheusSpecVolumesStorageos' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesStorageos(obj: PrometheusSpecVolumesStorageos | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'readOnly': obj.readOnly,
    'secretRef': toJson_PrometheusSpecVolumesStorageosSecretRef(obj.secretRef),
    'volumeName': obj.volumeName,
    'volumeNamespace': obj.volumeNamespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
 *
 * @schema PrometheusSpecVolumesVsphereVolume
 */
export interface PrometheusSpecVolumesVsphereVolume {
  /**
   * fsType is filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema PrometheusSpecVolumesVsphereVolume#fsType
   */
  readonly fsType?: string;

  /**
   * storagePolicyID is the storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.
   *
   * @schema PrometheusSpecVolumesVsphereVolume#storagePolicyID
   */
  readonly storagePolicyId?: string;

  /**
   * storagePolicyName is the storage Policy Based Management (SPBM) profile name.
   *
   * @schema PrometheusSpecVolumesVsphereVolume#storagePolicyName
   */
  readonly storagePolicyName?: string;

  /**
   * volumePath is the path that identifies vSphere volume vmdk
   *
   * @schema PrometheusSpecVolumesVsphereVolume#volumePath
   */
  readonly volumePath: string;

}

/**
 * Converts an object of type 'PrometheusSpecVolumesVsphereVolume' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesVsphereVolume(obj: PrometheusSpecVolumesVsphereVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'storagePolicyID': obj.storagePolicyId,
    'storagePolicyName': obj.storagePolicyName,
    'volumePath': obj.volumePath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Defines HTTP parameters for web server.
 *
 * @schema PrometheusSpecWebHttpConfig
 */
export interface PrometheusSpecWebHttpConfig {
  /**
   * List of headers that can be added to HTTP responses.
   *
   * @schema PrometheusSpecWebHttpConfig#headers
   */
  readonly headers?: PrometheusSpecWebHttpConfigHeaders;

  /**
   * Enable HTTP/2 support. Note that HTTP/2 is only supported with TLS.
   * When TLSConfig is not configured, HTTP/2 will be disabled.
   * Whenever the value of the field changes, a rolling update will be triggered.
   *
   * @schema PrometheusSpecWebHttpConfig#http2
   */
  readonly http2?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecWebHttpConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecWebHttpConfig(obj: PrometheusSpecWebHttpConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'headers': toJson_PrometheusSpecWebHttpConfigHeaders(obj.headers),
    'http2': obj.http2,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Defines the TLS parameters for HTTPS.
 *
 * @schema PrometheusSpecWebTlsConfig
 */
export interface PrometheusSpecWebTlsConfig {
  /**
   * Contains the TLS certificate for the server.
   *
   * @schema PrometheusSpecWebTlsConfig#cert
   */
  readonly cert: PrometheusSpecWebTlsConfigCert;

  /**
   * List of supported cipher suites for TLS versions up to TLS 1.2. If empty,
   * Go default cipher suites are used. Available cipher suites are documented
   * in the go documentation: https://golang.org/pkg/crypto/tls/#pkg-constants
   *
   * @schema PrometheusSpecWebTlsConfig#cipherSuites
   */
  readonly cipherSuites?: string[];

  /**
   * Contains the CA certificate for client certificate authentication to the server.
   *
   * @schema PrometheusSpecWebTlsConfig#client_ca
   */
  readonly clientCa?: PrometheusSpecWebTlsConfigClientCa;

  /**
   * Server policy for client authentication. Maps to ClientAuth Policies.
   * For more detail on clientAuth options:
   * https://golang.org/pkg/crypto/tls/#ClientAuthType
   *
   * @schema PrometheusSpecWebTlsConfig#clientAuthType
   */
  readonly clientAuthType?: string;

  /**
   * Elliptic curves that will be used in an ECDHE handshake, in preference
   * order. Available curves are documented in the go documentation:
   * https://golang.org/pkg/crypto/tls/#CurveID
   *
   * @schema PrometheusSpecWebTlsConfig#curvePreferences
   */
  readonly curvePreferences?: string[];

  /**
   * Secret containing the TLS key for the server.
   *
   * @schema PrometheusSpecWebTlsConfig#keySecret
   */
  readonly keySecret: PrometheusSpecWebTlsConfigKeySecret;

  /**
   * Maximum TLS version that is acceptable. Defaults to TLS13.
   *
   * @default TLS13.
   * @schema PrometheusSpecWebTlsConfig#maxVersion
   */
  readonly maxVersion?: string;

  /**
   * Minimum TLS version that is acceptable. Defaults to TLS12.
   *
   * @default TLS12.
   * @schema PrometheusSpecWebTlsConfig#minVersion
   */
  readonly minVersion?: string;

  /**
   * Controls whether the server selects the
   * client's most preferred cipher suite, or the server's most preferred
   * cipher suite. If true then the server's preference, as expressed in
   * the order of elements in cipherSuites, is used.
   *
   * @schema PrometheusSpecWebTlsConfig#preferServerCipherSuites
   */
  readonly preferServerCipherSuites?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecWebTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecWebTlsConfig(obj: PrometheusSpecWebTlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cert': toJson_PrometheusSpecWebTlsConfigCert(obj.cert),
    'cipherSuites': obj.cipherSuites?.map(y => y),
    'client_ca': toJson_PrometheusSpecWebTlsConfigClientCa(obj.clientCa),
    'clientAuthType': obj.clientAuthType,
    'curvePreferences': obj.curvePreferences?.map(y => y),
    'keySecret': toJson_PrometheusSpecWebTlsConfigKeySecret(obj.keySecret),
    'maxVersion': obj.maxVersion,
    'minVersion': obj.minVersion,
    'preferServerCipherSuites': obj.preferServerCipherSuites,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * An empty preferred scheduling term matches all objects with implicit weight 0
 * (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
 *
 * @schema PrometheusSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface PrometheusSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * A node selector term, associated with the corresponding weight.
   *
   * @schema PrometheusSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference: PrometheusSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
   *
   * @schema PrometheusSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;

}

/**
 * Converts an object of type 'PrometheusSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: PrometheusSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preference': toJson_PrometheusSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj.preference),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * If the affinity requirements specified by this field are not met at
 * scheduling time, the pod will not be scheduled onto the node.
 * If the affinity requirements specified by this field cease to be met
 * at some point during pod execution (e.g. due to an update), the system
 * may or may not try to eventually evict the pod from its node.
 *
 * @schema PrometheusSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface PrometheusSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A list of node selector terms. The terms are ORed.
   *
   * @schema PrometheusSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms: PrometheusSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];

}

/**
 * Converts an object of type 'PrometheusSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: PrometheusSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeSelectorTerms': obj.nodeSelectorTerms?.map(y => toJson_PrometheusSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm: PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm,
   * in the range 1-100.
   *
   * @schema PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;

}

/**
 * Converts an object of type 'PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podAffinityTerm': toJson_PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector
 * relative to the given namespace(s)) that this pod should be
 * co-located (affinity) or not co-located (anti-affinity) with,
 * where co-located is defined as running on a node whose value of
 * the label with key <topologyKey> matches that of any node on which
 * a pod of the set of pods is running
 *
 * @schema PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `LabelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both MatchLabelKeys and LabelSelector.
   * Also, MatchLabelKeys cannot be set when LabelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `LabelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both MismatchLabelKeys and LabelSelector.
   * Also, MismatchLabelKeys cannot be set when LabelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'mismatchLabelKeys': obj.mismatchLabelKeys?.map(y => y),
    'namespaceSelector': toJson_PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm: PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm,
   * in the range 1-100.
   *
   * @schema PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;

}

/**
 * Converts an object of type 'PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podAffinityTerm': toJson_PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector
 * relative to the given namespace(s)) that this pod should be
 * co-located (affinity) or not co-located (anti-affinity) with,
 * where co-located is defined as running on a node whose value of
 * the label with key <topologyKey> matches that of any node on which
 * a pod of the set of pods is running
 *
 * @schema PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `LabelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both MatchLabelKeys and LabelSelector.
   * Also, MatchLabelKeys cannot be set when LabelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `LabelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both MismatchLabelKeys and LabelSelector.
   * Also, MismatchLabelKeys cannot be set when LabelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'mismatchLabelKeys': obj.mismatchLabelKeys?.map(y => y),
    'namespaceSelector': toJson_PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RelabelConfig allows dynamic rewriting of the label set for targets, alerts,
 * scraped samples and remote write samples.
 *
 *
 * More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
 *
 * @schema PrometheusSpecAlertingAlertmanagersAlertRelabelings
 */
export interface PrometheusSpecAlertingAlertmanagersAlertRelabelings {
  /**
   * Action to perform based on the regex matching.
   *
   *
   * `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0.
   * `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.
   *
   *
   * Default: "Replace"
   *
   * @schema PrometheusSpecAlertingAlertmanagersAlertRelabelings#action
   */
  readonly action?: PrometheusSpecAlertingAlertmanagersAlertRelabelingsAction;

  /**
   * Modulus to take of the hash of the source label values.
   *
   *
   * Only applicable when the action is `HashMod`.
   *
   * @schema PrometheusSpecAlertingAlertmanagersAlertRelabelings#modulus
   */
  readonly modulus?: number;

  /**
   * Regular expression against which the extracted value is matched.
   *
   * @schema PrometheusSpecAlertingAlertmanagersAlertRelabelings#regex
   */
  readonly regex?: string;

  /**
   * Replacement value against which a Replace action is performed if the
   * regular expression matches.
   *
   *
   * Regex capture groups are available.
   *
   * @schema PrometheusSpecAlertingAlertmanagersAlertRelabelings#replacement
   */
  readonly replacement?: string;

  /**
   * Separator is the string between concatenated SourceLabels.
   *
   * @schema PrometheusSpecAlertingAlertmanagersAlertRelabelings#separator
   */
  readonly separator?: string;

  /**
   * The source labels select values from existing labels. Their content is
   * concatenated using the configured Separator and matched against the
   * configured regular expression.
   *
   * @schema PrometheusSpecAlertingAlertmanagersAlertRelabelings#sourceLabels
   */
  readonly sourceLabels?: string[];

  /**
   * Label to which the resulting string is written in a replacement.
   *
   *
   * It is mandatory for `Replace`, `HashMod`, `Lowercase`, `Uppercase`,
   * `KeepEqual` and `DropEqual` actions.
   *
   *
   * Regex capture groups are available.
   *
   * @schema PrometheusSpecAlertingAlertmanagersAlertRelabelings#targetLabel
   */
  readonly targetLabel?: string;

}

/**
 * Converts an object of type 'PrometheusSpecAlertingAlertmanagersAlertRelabelings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAlertingAlertmanagersAlertRelabelings(obj: PrometheusSpecAlertingAlertmanagersAlertRelabelings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'modulus': obj.modulus,
    'regex': obj.regex,
    'replacement': obj.replacement,
    'separator': obj.separator,
    'sourceLabels': obj.sourceLabels?.map(y => y),
    'targetLabel': obj.targetLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Authorization section for Alertmanager.
 *
 *
 * Cannot be set at the same time as `basicAuth`, `bearerTokenFile` or `sigv4`.
 *
 * @schema PrometheusSpecAlertingAlertmanagersAuthorization
 */
export interface PrometheusSpecAlertingAlertmanagersAuthorization {
  /**
   * Selects a key of a Secret in the namespace that contains the credentials for authentication.
   *
   * @schema PrometheusSpecAlertingAlertmanagersAuthorization#credentials
   */
  readonly credentials?: PrometheusSpecAlertingAlertmanagersAuthorizationCredentials;

  /**
   * Defines the authentication type. The value is case-insensitive.
   *
   *
   * "Basic" is not a supported value.
   *
   *
   * Default: "Bearer"
   *
   * @schema PrometheusSpecAlertingAlertmanagersAuthorization#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'PrometheusSpecAlertingAlertmanagersAuthorization' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAlertingAlertmanagersAuthorization(obj: PrometheusSpecAlertingAlertmanagersAuthorization | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentials': toJson_PrometheusSpecAlertingAlertmanagersAuthorizationCredentials(obj.credentials),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BasicAuth configuration for Alertmanager.
 *
 *
 * Cannot be set at the same time as `bearerTokenFile`, `authorization` or `sigv4`.
 *
 * @schema PrometheusSpecAlertingAlertmanagersBasicAuth
 */
export interface PrometheusSpecAlertingAlertmanagersBasicAuth {
  /**
   * `password` specifies a key of a Secret containing the password for
   * authentication.
   *
   * @schema PrometheusSpecAlertingAlertmanagersBasicAuth#password
   */
  readonly password?: PrometheusSpecAlertingAlertmanagersBasicAuthPassword;

  /**
   * `username` specifies a key of a Secret containing the username for
   * authentication.
   *
   * @schema PrometheusSpecAlertingAlertmanagersBasicAuth#username
   */
  readonly username?: PrometheusSpecAlertingAlertmanagersBasicAuthUsername;

}

/**
 * Converts an object of type 'PrometheusSpecAlertingAlertmanagersBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAlertingAlertmanagersBasicAuth(obj: PrometheusSpecAlertingAlertmanagersBasicAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_PrometheusSpecAlertingAlertmanagersBasicAuthPassword(obj.password),
    'username': toJson_PrometheusSpecAlertingAlertmanagersBasicAuthUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Port on which the Alertmanager API is exposed.
 *
 * @schema PrometheusSpecAlertingAlertmanagersPort
 */
export class PrometheusSpecAlertingAlertmanagersPort {
  public static fromNumber(value: number): PrometheusSpecAlertingAlertmanagersPort {
    return new PrometheusSpecAlertingAlertmanagersPort(value);
  }
  public static fromString(value: string): PrometheusSpecAlertingAlertmanagersPort {
    return new PrometheusSpecAlertingAlertmanagersPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * RelabelConfig allows dynamic rewriting of the label set for targets, alerts,
 * scraped samples and remote write samples.
 *
 *
 * More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
 *
 * @schema PrometheusSpecAlertingAlertmanagersRelabelings
 */
export interface PrometheusSpecAlertingAlertmanagersRelabelings {
  /**
   * Action to perform based on the regex matching.
   *
   *
   * `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0.
   * `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.
   *
   *
   * Default: "Replace"
   *
   * @schema PrometheusSpecAlertingAlertmanagersRelabelings#action
   */
  readonly action?: PrometheusSpecAlertingAlertmanagersRelabelingsAction;

  /**
   * Modulus to take of the hash of the source label values.
   *
   *
   * Only applicable when the action is `HashMod`.
   *
   * @schema PrometheusSpecAlertingAlertmanagersRelabelings#modulus
   */
  readonly modulus?: number;

  /**
   * Regular expression against which the extracted value is matched.
   *
   * @schema PrometheusSpecAlertingAlertmanagersRelabelings#regex
   */
  readonly regex?: string;

  /**
   * Replacement value against which a Replace action is performed if the
   * regular expression matches.
   *
   *
   * Regex capture groups are available.
   *
   * @schema PrometheusSpecAlertingAlertmanagersRelabelings#replacement
   */
  readonly replacement?: string;

  /**
   * Separator is the string between concatenated SourceLabels.
   *
   * @schema PrometheusSpecAlertingAlertmanagersRelabelings#separator
   */
  readonly separator?: string;

  /**
   * The source labels select values from existing labels. Their content is
   * concatenated using the configured Separator and matched against the
   * configured regular expression.
   *
   * @schema PrometheusSpecAlertingAlertmanagersRelabelings#sourceLabels
   */
  readonly sourceLabels?: string[];

  /**
   * Label to which the resulting string is written in a replacement.
   *
   *
   * It is mandatory for `Replace`, `HashMod`, `Lowercase`, `Uppercase`,
   * `KeepEqual` and `DropEqual` actions.
   *
   *
   * Regex capture groups are available.
   *
   * @schema PrometheusSpecAlertingAlertmanagersRelabelings#targetLabel
   */
  readonly targetLabel?: string;

}

/**
 * Converts an object of type 'PrometheusSpecAlertingAlertmanagersRelabelings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAlertingAlertmanagersRelabelings(obj: PrometheusSpecAlertingAlertmanagersRelabelings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'modulus': obj.modulus,
    'regex': obj.regex,
    'replacement': obj.replacement,
    'separator': obj.separator,
    'sourceLabels': obj.sourceLabels?.map(y => y),
    'targetLabel': obj.targetLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Sigv4 allows to configures AWS's Signature Verification 4 for the URL.
 *
 *
 * It requires Prometheus >= v2.48.0.
 *
 *
 * Cannot be set at the same time as `basicAuth`, `bearerTokenFile` or `authorization`.
 *
 * @schema PrometheusSpecAlertingAlertmanagersSigv4
 */
export interface PrometheusSpecAlertingAlertmanagersSigv4 {
  /**
   * AccessKey is the AWS API key. If not specified, the environment variable
   * `AWS_ACCESS_KEY_ID` is used.
   *
   * @schema PrometheusSpecAlertingAlertmanagersSigv4#accessKey
   */
  readonly accessKey?: PrometheusSpecAlertingAlertmanagersSigv4AccessKey;

  /**
   * Profile is the named AWS profile used to authenticate.
   *
   * @schema PrometheusSpecAlertingAlertmanagersSigv4#profile
   */
  readonly profile?: string;

  /**
   * Region is the AWS region. If blank, the region from the default credentials chain used.
   *
   * @schema PrometheusSpecAlertingAlertmanagersSigv4#region
   */
  readonly region?: string;

  /**
   * RoleArn is the named AWS profile used to authenticate.
   *
   * @schema PrometheusSpecAlertingAlertmanagersSigv4#roleArn
   */
  readonly roleArn?: string;

  /**
   * SecretKey is the AWS API secret. If not specified, the environment
   * variable `AWS_SECRET_ACCESS_KEY` is used.
   *
   * @schema PrometheusSpecAlertingAlertmanagersSigv4#secretKey
   */
  readonly secretKey?: PrometheusSpecAlertingAlertmanagersSigv4SecretKey;

}

/**
 * Converts an object of type 'PrometheusSpecAlertingAlertmanagersSigv4' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAlertingAlertmanagersSigv4(obj: PrometheusSpecAlertingAlertmanagersSigv4 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessKey': toJson_PrometheusSpecAlertingAlertmanagersSigv4AccessKey(obj.accessKey),
    'profile': obj.profile,
    'region': obj.region,
    'roleArn': obj.roleArn,
    'secretKey': toJson_PrometheusSpecAlertingAlertmanagersSigv4SecretKey(obj.secretKey),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLS Config to use for Alertmanager.
 *
 * @schema PrometheusSpecAlertingAlertmanagersTlsConfig
 */
export interface PrometheusSpecAlertingAlertmanagersTlsConfig {
  /**
   * Certificate authority used when verifying server certificates.
   *
   * @schema PrometheusSpecAlertingAlertmanagersTlsConfig#ca
   */
  readonly ca?: PrometheusSpecAlertingAlertmanagersTlsConfigCa;

  /**
   * Path to the CA cert in the Prometheus container to use for the targets.
   *
   * @schema PrometheusSpecAlertingAlertmanagersTlsConfig#caFile
   */
  readonly caFile?: string;

  /**
   * Client certificate to present when doing client-authentication.
   *
   * @schema PrometheusSpecAlertingAlertmanagersTlsConfig#cert
   */
  readonly cert?: PrometheusSpecAlertingAlertmanagersTlsConfigCert;

  /**
   * Path to the client cert file in the Prometheus container for the targets.
   *
   * @schema PrometheusSpecAlertingAlertmanagersTlsConfig#certFile
   */
  readonly certFile?: string;

  /**
   * Disable target certificate validation.
   *
   * @schema PrometheusSpecAlertingAlertmanagersTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Path to the client key file in the Prometheus container for the targets.
   *
   * @schema PrometheusSpecAlertingAlertmanagersTlsConfig#keyFile
   */
  readonly keyFile?: string;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema PrometheusSpecAlertingAlertmanagersTlsConfig#keySecret
   */
  readonly keySecret?: PrometheusSpecAlertingAlertmanagersTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema PrometheusSpecAlertingAlertmanagersTlsConfig#serverName
   */
  readonly serverName?: string;

}

/**
 * Converts an object of type 'PrometheusSpecAlertingAlertmanagersTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAlertingAlertmanagersTlsConfig(obj: PrometheusSpecAlertingAlertmanagersTlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ca': toJson_PrometheusSpecAlertingAlertmanagersTlsConfigCa(obj.ca),
    'caFile': obj.caFile,
    'cert': toJson_PrometheusSpecAlertingAlertmanagersTlsConfigCert(obj.cert),
    'certFile': obj.certFile,
    'insecureSkipVerify': obj.insecureSkipVerify,
    'keyFile': obj.keyFile,
    'keySecret': toJson_PrometheusSpecAlertingAlertmanagersTlsConfigKeySecret(obj.keySecret),
    'serverName': obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a Secret in the namespace that contains the credentials for authentication.
 *
 * @schema PrometheusSpecApiserverConfigAuthorizationCredentials
 */
export interface PrometheusSpecApiserverConfigAuthorizationCredentials {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecApiserverConfigAuthorizationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecApiserverConfigAuthorizationCredentials#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecApiserverConfigAuthorizationCredentials#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecApiserverConfigAuthorizationCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecApiserverConfigAuthorizationCredentials(obj: PrometheusSpecApiserverConfigAuthorizationCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `password` specifies a key of a Secret containing the password for
 * authentication.
 *
 * @schema PrometheusSpecApiserverConfigBasicAuthPassword
 */
export interface PrometheusSpecApiserverConfigBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecApiserverConfigBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecApiserverConfigBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecApiserverConfigBasicAuthPassword#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecApiserverConfigBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecApiserverConfigBasicAuthPassword(obj: PrometheusSpecApiserverConfigBasicAuthPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `username` specifies a key of a Secret containing the username for
 * authentication.
 *
 * @schema PrometheusSpecApiserverConfigBasicAuthUsername
 */
export interface PrometheusSpecApiserverConfigBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecApiserverConfigBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecApiserverConfigBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecApiserverConfigBasicAuthUsername#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecApiserverConfigBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecApiserverConfigBasicAuthUsername(obj: PrometheusSpecApiserverConfigBasicAuthUsername | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Certificate authority used when verifying server certificates.
 *
 * @schema PrometheusSpecApiserverConfigTlsConfigCa
 */
export interface PrometheusSpecApiserverConfigTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema PrometheusSpecApiserverConfigTlsConfigCa#configMap
   */
  readonly configMap?: PrometheusSpecApiserverConfigTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema PrometheusSpecApiserverConfigTlsConfigCa#secret
   */
  readonly secret?: PrometheusSpecApiserverConfigTlsConfigCaSecret;

}

/**
 * Converts an object of type 'PrometheusSpecApiserverConfigTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecApiserverConfigTlsConfigCa(obj: PrometheusSpecApiserverConfigTlsConfigCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_PrometheusSpecApiserverConfigTlsConfigCaConfigMap(obj.configMap),
    'secret': toJson_PrometheusSpecApiserverConfigTlsConfigCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Client certificate to present when doing client-authentication.
 *
 * @schema PrometheusSpecApiserverConfigTlsConfigCert
 */
export interface PrometheusSpecApiserverConfigTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema PrometheusSpecApiserverConfigTlsConfigCert#configMap
   */
  readonly configMap?: PrometheusSpecApiserverConfigTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema PrometheusSpecApiserverConfigTlsConfigCert#secret
   */
  readonly secret?: PrometheusSpecApiserverConfigTlsConfigCertSecret;

}

/**
 * Converts an object of type 'PrometheusSpecApiserverConfigTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecApiserverConfigTlsConfigCert(obj: PrometheusSpecApiserverConfigTlsConfigCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_PrometheusSpecApiserverConfigTlsConfigCertConfigMap(obj.configMap),
    'secret': toJson_PrometheusSpecApiserverConfigTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema PrometheusSpecApiserverConfigTlsConfigKeySecret
 */
export interface PrometheusSpecApiserverConfigTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecApiserverConfigTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecApiserverConfigTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecApiserverConfigTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecApiserverConfigTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecApiserverConfigTlsConfigKeySecret(obj: PrometheusSpecApiserverConfigTlsConfigKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema PrometheusSpecContainersEnvValueFrom
 */
export interface PrometheusSpecContainersEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema PrometheusSpecContainersEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: PrometheusSpecContainersEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
   * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema PrometheusSpecContainersEnvValueFrom#fieldRef
   */
  readonly fieldRef?: PrometheusSpecContainersEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema PrometheusSpecContainersEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: PrometheusSpecContainersEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema PrometheusSpecContainersEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: PrometheusSpecContainersEnvValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'PrometheusSpecContainersEnvValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersEnvValueFrom(obj: PrometheusSpecContainersEnvValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_PrometheusSpecContainersEnvValueFromConfigMapKeyRef(obj.configMapKeyRef),
    'fieldRef': toJson_PrometheusSpecContainersEnvValueFromFieldRef(obj.fieldRef),
    'resourceFieldRef': toJson_PrometheusSpecContainersEnvValueFromResourceFieldRef(obj.resourceFieldRef),
    'secretKeyRef': toJson_PrometheusSpecContainersEnvValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema PrometheusSpecContainersEnvFromConfigMapRef
 */
export interface PrometheusSpecContainersEnvFromConfigMapRef {
  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecContainersEnvFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema PrometheusSpecContainersEnvFromConfigMapRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecContainersEnvFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersEnvFromConfigMapRef(obj: PrometheusSpecContainersEnvFromConfigMapRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Secret to select from
 *
 * @schema PrometheusSpecContainersEnvFromSecretRef
 */
export interface PrometheusSpecContainersEnvFromSecretRef {
  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecContainersEnvFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema PrometheusSpecContainersEnvFromSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecContainersEnvFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersEnvFromSecretRef(obj: PrometheusSpecContainersEnvFromSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PostStart is called immediately after a container is created. If the handler fails,
 * the container is terminated and restarted according to its restart policy.
 * Other management of the container blocks until the hook completes.
 * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema PrometheusSpecContainersLifecyclePostStart
 */
export interface PrometheusSpecContainersLifecyclePostStart {
  /**
   * Exec specifies the action to take.
   *
   * @schema PrometheusSpecContainersLifecyclePostStart#exec
   */
  readonly exec?: PrometheusSpecContainersLifecyclePostStartExec;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema PrometheusSpecContainersLifecyclePostStart#httpGet
   */
  readonly httpGet?: PrometheusSpecContainersLifecyclePostStartHttpGet;

  /**
   * Sleep represents the duration that the container should sleep before being terminated.
   *
   * @schema PrometheusSpecContainersLifecyclePostStart#sleep
   */
  readonly sleep?: PrometheusSpecContainersLifecyclePostStartSleep;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
   * for the backward compatibility. There are no validation of this field and
   * lifecycle hooks will fail in runtime when tcp handler is specified.
   *
   * @schema PrometheusSpecContainersLifecyclePostStart#tcpSocket
   */
  readonly tcpSocket?: PrometheusSpecContainersLifecyclePostStartTcpSocket;

}

/**
 * Converts an object of type 'PrometheusSpecContainersLifecyclePostStart' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersLifecyclePostStart(obj: PrometheusSpecContainersLifecyclePostStart | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_PrometheusSpecContainersLifecyclePostStartExec(obj.exec),
    'httpGet': toJson_PrometheusSpecContainersLifecyclePostStartHttpGet(obj.httpGet),
    'sleep': toJson_PrometheusSpecContainersLifecyclePostStartSleep(obj.sleep),
    'tcpSocket': toJson_PrometheusSpecContainersLifecyclePostStartTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PreStop is called immediately before a container is terminated due to an
 * API request or management event such as liveness/startup probe failure,
 * preemption, resource contention, etc. The handler is not called if the
 * container crashes or exits. The Pod's termination grace period countdown begins before the
 * PreStop hook is executed. Regardless of the outcome of the handler, the
 * container will eventually terminate within the Pod's termination grace
 * period (unless delayed by finalizers). Other management of the container blocks until the hook completes
 * or until the termination grace period is reached.
 * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema PrometheusSpecContainersLifecyclePreStop
 */
export interface PrometheusSpecContainersLifecyclePreStop {
  /**
   * Exec specifies the action to take.
   *
   * @schema PrometheusSpecContainersLifecyclePreStop#exec
   */
  readonly exec?: PrometheusSpecContainersLifecyclePreStopExec;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema PrometheusSpecContainersLifecyclePreStop#httpGet
   */
  readonly httpGet?: PrometheusSpecContainersLifecyclePreStopHttpGet;

  /**
   * Sleep represents the duration that the container should sleep before being terminated.
   *
   * @schema PrometheusSpecContainersLifecyclePreStop#sleep
   */
  readonly sleep?: PrometheusSpecContainersLifecyclePreStopSleep;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
   * for the backward compatibility. There are no validation of this field and
   * lifecycle hooks will fail in runtime when tcp handler is specified.
   *
   * @schema PrometheusSpecContainersLifecyclePreStop#tcpSocket
   */
  readonly tcpSocket?: PrometheusSpecContainersLifecyclePreStopTcpSocket;

}

/**
 * Converts an object of type 'PrometheusSpecContainersLifecyclePreStop' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersLifecyclePreStop(obj: PrometheusSpecContainersLifecyclePreStop | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_PrometheusSpecContainersLifecyclePreStopExec(obj.exec),
    'httpGet': toJson_PrometheusSpecContainersLifecyclePreStopHttpGet(obj.httpGet),
    'sleep': toJson_PrometheusSpecContainersLifecyclePreStopSleep(obj.sleep),
    'tcpSocket': toJson_PrometheusSpecContainersLifecyclePreStopTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema PrometheusSpecContainersLivenessProbeExec
 */
export interface PrometheusSpecContainersLivenessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema PrometheusSpecContainersLivenessProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'PrometheusSpecContainersLivenessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersLivenessProbeExec(obj: PrometheusSpecContainersLivenessProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port.
 *
 * @schema PrometheusSpecContainersLivenessProbeGrpc
 */
export interface PrometheusSpecContainersLivenessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema PrometheusSpecContainersLivenessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest
   * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   *
   *
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema PrometheusSpecContainersLivenessProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'PrometheusSpecContainersLivenessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersLivenessProbeGrpc(obj: PrometheusSpecContainersLivenessProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema PrometheusSpecContainersLivenessProbeHttpGet
 */
export interface PrometheusSpecContainersLivenessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema PrometheusSpecContainersLivenessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema PrometheusSpecContainersLivenessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: PrometheusSpecContainersLivenessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema PrometheusSpecContainersLivenessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema PrometheusSpecContainersLivenessProbeHttpGet#port
   */
  readonly port: PrometheusSpecContainersLivenessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema PrometheusSpecContainersLivenessProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'PrometheusSpecContainersLivenessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersLivenessProbeHttpGet(obj: PrometheusSpecContainersLivenessProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_PrometheusSpecContainersLivenessProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema PrometheusSpecContainersLivenessProbeTcpSocket
 */
export interface PrometheusSpecContainersLivenessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema PrometheusSpecContainersLivenessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema PrometheusSpecContainersLivenessProbeTcpSocket#port
   */
  readonly port: PrometheusSpecContainersLivenessProbeTcpSocketPort;

}

/**
 * Converts an object of type 'PrometheusSpecContainersLivenessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersLivenessProbeTcpSocket(obj: PrometheusSpecContainersLivenessProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema PrometheusSpecContainersReadinessProbeExec
 */
export interface PrometheusSpecContainersReadinessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema PrometheusSpecContainersReadinessProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'PrometheusSpecContainersReadinessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersReadinessProbeExec(obj: PrometheusSpecContainersReadinessProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port.
 *
 * @schema PrometheusSpecContainersReadinessProbeGrpc
 */
export interface PrometheusSpecContainersReadinessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema PrometheusSpecContainersReadinessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest
   * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   *
   *
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema PrometheusSpecContainersReadinessProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'PrometheusSpecContainersReadinessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersReadinessProbeGrpc(obj: PrometheusSpecContainersReadinessProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema PrometheusSpecContainersReadinessProbeHttpGet
 */
export interface PrometheusSpecContainersReadinessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema PrometheusSpecContainersReadinessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema PrometheusSpecContainersReadinessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: PrometheusSpecContainersReadinessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema PrometheusSpecContainersReadinessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema PrometheusSpecContainersReadinessProbeHttpGet#port
   */
  readonly port: PrometheusSpecContainersReadinessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema PrometheusSpecContainersReadinessProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'PrometheusSpecContainersReadinessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersReadinessProbeHttpGet(obj: PrometheusSpecContainersReadinessProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_PrometheusSpecContainersReadinessProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema PrometheusSpecContainersReadinessProbeTcpSocket
 */
export interface PrometheusSpecContainersReadinessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema PrometheusSpecContainersReadinessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema PrometheusSpecContainersReadinessProbeTcpSocket#port
   */
  readonly port: PrometheusSpecContainersReadinessProbeTcpSocketPort;

}

/**
 * Converts an object of type 'PrometheusSpecContainersReadinessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersReadinessProbeTcpSocket(obj: PrometheusSpecContainersReadinessProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema PrometheusSpecContainersResourcesClaims
 */
export interface PrometheusSpecContainersResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema PrometheusSpecContainersResourcesClaims#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'PrometheusSpecContainersResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersResourcesClaims(obj: PrometheusSpecContainersResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PrometheusSpecContainersResourcesLimits
 */
export class PrometheusSpecContainersResourcesLimits {
  public static fromNumber(value: number): PrometheusSpecContainersResourcesLimits {
    return new PrometheusSpecContainersResourcesLimits(value);
  }
  public static fromString(value: string): PrometheusSpecContainersResourcesLimits {
    return new PrometheusSpecContainersResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema PrometheusSpecContainersResourcesRequests
 */
export class PrometheusSpecContainersResourcesRequests {
  public static fromNumber(value: number): PrometheusSpecContainersResourcesRequests {
    return new PrometheusSpecContainersResourcesRequests(value);
  }
  public static fromString(value: string): PrometheusSpecContainersResourcesRequests {
    return new PrometheusSpecContainersResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * The capabilities to add/drop when running containers.
 * Defaults to the default set of capabilities granted by the container runtime.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @default the default set of capabilities granted by the container runtime.
 * @schema PrometheusSpecContainersSecurityContextCapabilities
 */
export interface PrometheusSpecContainersSecurityContextCapabilities {
  /**
   * Added capabilities
   *
   * @schema PrometheusSpecContainersSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * Removed capabilities
   *
   * @schema PrometheusSpecContainersSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * Converts an object of type 'PrometheusSpecContainersSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersSecurityContextCapabilities(obj: PrometheusSpecContainersSecurityContextCapabilities | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': obj.add?.map(y => y),
    'drop': obj.drop?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The SELinux context to be applied to the container.
 * If unspecified, the container runtime will allocate a random SELinux context for each
 * container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
 * PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema PrometheusSpecContainersSecurityContextSeLinuxOptions
 */
export interface PrometheusSpecContainersSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema PrometheusSpecContainersSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema PrometheusSpecContainersSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema PrometheusSpecContainersSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema PrometheusSpecContainersSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'PrometheusSpecContainersSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersSecurityContextSeLinuxOptions(obj: PrometheusSpecContainersSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The seccomp options to use by this container. If seccomp options are
 * provided at both the pod & container level, the container options
 * override the pod options.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema PrometheusSpecContainersSecurityContextSeccompProfile
 */
export interface PrometheusSpecContainersSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used.
   * The profile must be preconfigured on the node to work.
   * Must be a descending path, relative to the kubelet's configured seccomp profile location.
   * Must be set if type is "Localhost". Must NOT be set for any other type.
   *
   * @schema PrometheusSpecContainersSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied.
   * Valid options are:
   *
   *
   * Localhost - a profile defined in a file on the node should be used.
   * RuntimeDefault - the container runtime default profile should be used.
   * Unconfined - no profile should be applied.
   *
   * @schema PrometheusSpecContainersSecurityContextSeccompProfile#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'PrometheusSpecContainersSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersSecurityContextSeccompProfile(obj: PrometheusSpecContainersSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Windows specific settings applied to all containers.
 * If unspecified, the options from the PodSecurityContext will be used.
 * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema PrometheusSpecContainersSecurityContextWindowsOptions
 */
export interface PrometheusSpecContainersSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook
   * (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
   * GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema PrometheusSpecContainersSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema PrometheusSpecContainersSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container.
   * All of a Pod's containers must have the same effective HostProcess value
   * (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
   * In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema PrometheusSpecContainersSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process.
   * Defaults to the user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext. If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified.
   * @schema PrometheusSpecContainersSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'PrometheusSpecContainersSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersSecurityContextWindowsOptions(obj: PrometheusSpecContainersSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema PrometheusSpecContainersStartupProbeExec
 */
export interface PrometheusSpecContainersStartupProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema PrometheusSpecContainersStartupProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'PrometheusSpecContainersStartupProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersStartupProbeExec(obj: PrometheusSpecContainersStartupProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port.
 *
 * @schema PrometheusSpecContainersStartupProbeGrpc
 */
export interface PrometheusSpecContainersStartupProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema PrometheusSpecContainersStartupProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest
   * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   *
   *
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema PrometheusSpecContainersStartupProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'PrometheusSpecContainersStartupProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersStartupProbeGrpc(obj: PrometheusSpecContainersStartupProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema PrometheusSpecContainersStartupProbeHttpGet
 */
export interface PrometheusSpecContainersStartupProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema PrometheusSpecContainersStartupProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema PrometheusSpecContainersStartupProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: PrometheusSpecContainersStartupProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema PrometheusSpecContainersStartupProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema PrometheusSpecContainersStartupProbeHttpGet#port
   */
  readonly port: PrometheusSpecContainersStartupProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema PrometheusSpecContainersStartupProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'PrometheusSpecContainersStartupProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersStartupProbeHttpGet(obj: PrometheusSpecContainersStartupProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_PrometheusSpecContainersStartupProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema PrometheusSpecContainersStartupProbeTcpSocket
 */
export interface PrometheusSpecContainersStartupProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema PrometheusSpecContainersStartupProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema PrometheusSpecContainersStartupProbeTcpSocket#port
   */
  readonly port: PrometheusSpecContainersStartupProbeTcpSocketPort;

}

/**
 * Converts an object of type 'PrometheusSpecContainersStartupProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersStartupProbeTcpSocket(obj: PrometheusSpecContainersStartupProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema PrometheusSpecInitContainersEnvValueFrom
 */
export interface PrometheusSpecInitContainersEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema PrometheusSpecInitContainersEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: PrometheusSpecInitContainersEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
   * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema PrometheusSpecInitContainersEnvValueFrom#fieldRef
   */
  readonly fieldRef?: PrometheusSpecInitContainersEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema PrometheusSpecInitContainersEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: PrometheusSpecInitContainersEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema PrometheusSpecInitContainersEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: PrometheusSpecInitContainersEnvValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'PrometheusSpecInitContainersEnvValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersEnvValueFrom(obj: PrometheusSpecInitContainersEnvValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_PrometheusSpecInitContainersEnvValueFromConfigMapKeyRef(obj.configMapKeyRef),
    'fieldRef': toJson_PrometheusSpecInitContainersEnvValueFromFieldRef(obj.fieldRef),
    'resourceFieldRef': toJson_PrometheusSpecInitContainersEnvValueFromResourceFieldRef(obj.resourceFieldRef),
    'secretKeyRef': toJson_PrometheusSpecInitContainersEnvValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema PrometheusSpecInitContainersEnvFromConfigMapRef
 */
export interface PrometheusSpecInitContainersEnvFromConfigMapRef {
  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecInitContainersEnvFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema PrometheusSpecInitContainersEnvFromConfigMapRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecInitContainersEnvFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersEnvFromConfigMapRef(obj: PrometheusSpecInitContainersEnvFromConfigMapRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Secret to select from
 *
 * @schema PrometheusSpecInitContainersEnvFromSecretRef
 */
export interface PrometheusSpecInitContainersEnvFromSecretRef {
  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecInitContainersEnvFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema PrometheusSpecInitContainersEnvFromSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecInitContainersEnvFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersEnvFromSecretRef(obj: PrometheusSpecInitContainersEnvFromSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PostStart is called immediately after a container is created. If the handler fails,
 * the container is terminated and restarted according to its restart policy.
 * Other management of the container blocks until the hook completes.
 * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema PrometheusSpecInitContainersLifecyclePostStart
 */
export interface PrometheusSpecInitContainersLifecyclePostStart {
  /**
   * Exec specifies the action to take.
   *
   * @schema PrometheusSpecInitContainersLifecyclePostStart#exec
   */
  readonly exec?: PrometheusSpecInitContainersLifecyclePostStartExec;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema PrometheusSpecInitContainersLifecyclePostStart#httpGet
   */
  readonly httpGet?: PrometheusSpecInitContainersLifecyclePostStartHttpGet;

  /**
   * Sleep represents the duration that the container should sleep before being terminated.
   *
   * @schema PrometheusSpecInitContainersLifecyclePostStart#sleep
   */
  readonly sleep?: PrometheusSpecInitContainersLifecyclePostStartSleep;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
   * for the backward compatibility. There are no validation of this field and
   * lifecycle hooks will fail in runtime when tcp handler is specified.
   *
   * @schema PrometheusSpecInitContainersLifecyclePostStart#tcpSocket
   */
  readonly tcpSocket?: PrometheusSpecInitContainersLifecyclePostStartTcpSocket;

}

/**
 * Converts an object of type 'PrometheusSpecInitContainersLifecyclePostStart' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersLifecyclePostStart(obj: PrometheusSpecInitContainersLifecyclePostStart | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_PrometheusSpecInitContainersLifecyclePostStartExec(obj.exec),
    'httpGet': toJson_PrometheusSpecInitContainersLifecyclePostStartHttpGet(obj.httpGet),
    'sleep': toJson_PrometheusSpecInitContainersLifecyclePostStartSleep(obj.sleep),
    'tcpSocket': toJson_PrometheusSpecInitContainersLifecyclePostStartTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PreStop is called immediately before a container is terminated due to an
 * API request or management event such as liveness/startup probe failure,
 * preemption, resource contention, etc. The handler is not called if the
 * container crashes or exits. The Pod's termination grace period countdown begins before the
 * PreStop hook is executed. Regardless of the outcome of the handler, the
 * container will eventually terminate within the Pod's termination grace
 * period (unless delayed by finalizers). Other management of the container blocks until the hook completes
 * or until the termination grace period is reached.
 * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema PrometheusSpecInitContainersLifecyclePreStop
 */
export interface PrometheusSpecInitContainersLifecyclePreStop {
  /**
   * Exec specifies the action to take.
   *
   * @schema PrometheusSpecInitContainersLifecyclePreStop#exec
   */
  readonly exec?: PrometheusSpecInitContainersLifecyclePreStopExec;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema PrometheusSpecInitContainersLifecyclePreStop#httpGet
   */
  readonly httpGet?: PrometheusSpecInitContainersLifecyclePreStopHttpGet;

  /**
   * Sleep represents the duration that the container should sleep before being terminated.
   *
   * @schema PrometheusSpecInitContainersLifecyclePreStop#sleep
   */
  readonly sleep?: PrometheusSpecInitContainersLifecyclePreStopSleep;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
   * for the backward compatibility. There are no validation of this field and
   * lifecycle hooks will fail in runtime when tcp handler is specified.
   *
   * @schema PrometheusSpecInitContainersLifecyclePreStop#tcpSocket
   */
  readonly tcpSocket?: PrometheusSpecInitContainersLifecyclePreStopTcpSocket;

}

/**
 * Converts an object of type 'PrometheusSpecInitContainersLifecyclePreStop' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersLifecyclePreStop(obj: PrometheusSpecInitContainersLifecyclePreStop | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_PrometheusSpecInitContainersLifecyclePreStopExec(obj.exec),
    'httpGet': toJson_PrometheusSpecInitContainersLifecyclePreStopHttpGet(obj.httpGet),
    'sleep': toJson_PrometheusSpecInitContainersLifecyclePreStopSleep(obj.sleep),
    'tcpSocket': toJson_PrometheusSpecInitContainersLifecyclePreStopTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema PrometheusSpecInitContainersLivenessProbeExec
 */
export interface PrometheusSpecInitContainersLivenessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema PrometheusSpecInitContainersLivenessProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'PrometheusSpecInitContainersLivenessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersLivenessProbeExec(obj: PrometheusSpecInitContainersLivenessProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port.
 *
 * @schema PrometheusSpecInitContainersLivenessProbeGrpc
 */
export interface PrometheusSpecInitContainersLivenessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema PrometheusSpecInitContainersLivenessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest
   * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   *
   *
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema PrometheusSpecInitContainersLivenessProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'PrometheusSpecInitContainersLivenessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersLivenessProbeGrpc(obj: PrometheusSpecInitContainersLivenessProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema PrometheusSpecInitContainersLivenessProbeHttpGet
 */
export interface PrometheusSpecInitContainersLivenessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema PrometheusSpecInitContainersLivenessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema PrometheusSpecInitContainersLivenessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: PrometheusSpecInitContainersLivenessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema PrometheusSpecInitContainersLivenessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema PrometheusSpecInitContainersLivenessProbeHttpGet#port
   */
  readonly port: PrometheusSpecInitContainersLivenessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema PrometheusSpecInitContainersLivenessProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'PrometheusSpecInitContainersLivenessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersLivenessProbeHttpGet(obj: PrometheusSpecInitContainersLivenessProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_PrometheusSpecInitContainersLivenessProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema PrometheusSpecInitContainersLivenessProbeTcpSocket
 */
export interface PrometheusSpecInitContainersLivenessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema PrometheusSpecInitContainersLivenessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema PrometheusSpecInitContainersLivenessProbeTcpSocket#port
   */
  readonly port: PrometheusSpecInitContainersLivenessProbeTcpSocketPort;

}

/**
 * Converts an object of type 'PrometheusSpecInitContainersLivenessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersLivenessProbeTcpSocket(obj: PrometheusSpecInitContainersLivenessProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema PrometheusSpecInitContainersReadinessProbeExec
 */
export interface PrometheusSpecInitContainersReadinessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema PrometheusSpecInitContainersReadinessProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'PrometheusSpecInitContainersReadinessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersReadinessProbeExec(obj: PrometheusSpecInitContainersReadinessProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port.
 *
 * @schema PrometheusSpecInitContainersReadinessProbeGrpc
 */
export interface PrometheusSpecInitContainersReadinessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema PrometheusSpecInitContainersReadinessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest
   * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   *
   *
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema PrometheusSpecInitContainersReadinessProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'PrometheusSpecInitContainersReadinessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersReadinessProbeGrpc(obj: PrometheusSpecInitContainersReadinessProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema PrometheusSpecInitContainersReadinessProbeHttpGet
 */
export interface PrometheusSpecInitContainersReadinessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema PrometheusSpecInitContainersReadinessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema PrometheusSpecInitContainersReadinessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: PrometheusSpecInitContainersReadinessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema PrometheusSpecInitContainersReadinessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema PrometheusSpecInitContainersReadinessProbeHttpGet#port
   */
  readonly port: PrometheusSpecInitContainersReadinessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema PrometheusSpecInitContainersReadinessProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'PrometheusSpecInitContainersReadinessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersReadinessProbeHttpGet(obj: PrometheusSpecInitContainersReadinessProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_PrometheusSpecInitContainersReadinessProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema PrometheusSpecInitContainersReadinessProbeTcpSocket
 */
export interface PrometheusSpecInitContainersReadinessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema PrometheusSpecInitContainersReadinessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema PrometheusSpecInitContainersReadinessProbeTcpSocket#port
   */
  readonly port: PrometheusSpecInitContainersReadinessProbeTcpSocketPort;

}

/**
 * Converts an object of type 'PrometheusSpecInitContainersReadinessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersReadinessProbeTcpSocket(obj: PrometheusSpecInitContainersReadinessProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema PrometheusSpecInitContainersResourcesClaims
 */
export interface PrometheusSpecInitContainersResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema PrometheusSpecInitContainersResourcesClaims#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'PrometheusSpecInitContainersResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersResourcesClaims(obj: PrometheusSpecInitContainersResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PrometheusSpecInitContainersResourcesLimits
 */
export class PrometheusSpecInitContainersResourcesLimits {
  public static fromNumber(value: number): PrometheusSpecInitContainersResourcesLimits {
    return new PrometheusSpecInitContainersResourcesLimits(value);
  }
  public static fromString(value: string): PrometheusSpecInitContainersResourcesLimits {
    return new PrometheusSpecInitContainersResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema PrometheusSpecInitContainersResourcesRequests
 */
export class PrometheusSpecInitContainersResourcesRequests {
  public static fromNumber(value: number): PrometheusSpecInitContainersResourcesRequests {
    return new PrometheusSpecInitContainersResourcesRequests(value);
  }
  public static fromString(value: string): PrometheusSpecInitContainersResourcesRequests {
    return new PrometheusSpecInitContainersResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * The capabilities to add/drop when running containers.
 * Defaults to the default set of capabilities granted by the container runtime.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @default the default set of capabilities granted by the container runtime.
 * @schema PrometheusSpecInitContainersSecurityContextCapabilities
 */
export interface PrometheusSpecInitContainersSecurityContextCapabilities {
  /**
   * Added capabilities
   *
   * @schema PrometheusSpecInitContainersSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * Removed capabilities
   *
   * @schema PrometheusSpecInitContainersSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * Converts an object of type 'PrometheusSpecInitContainersSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersSecurityContextCapabilities(obj: PrometheusSpecInitContainersSecurityContextCapabilities | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': obj.add?.map(y => y),
    'drop': obj.drop?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The SELinux context to be applied to the container.
 * If unspecified, the container runtime will allocate a random SELinux context for each
 * container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
 * PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema PrometheusSpecInitContainersSecurityContextSeLinuxOptions
 */
export interface PrometheusSpecInitContainersSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema PrometheusSpecInitContainersSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema PrometheusSpecInitContainersSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema PrometheusSpecInitContainersSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema PrometheusSpecInitContainersSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'PrometheusSpecInitContainersSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersSecurityContextSeLinuxOptions(obj: PrometheusSpecInitContainersSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The seccomp options to use by this container. If seccomp options are
 * provided at both the pod & container level, the container options
 * override the pod options.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema PrometheusSpecInitContainersSecurityContextSeccompProfile
 */
export interface PrometheusSpecInitContainersSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used.
   * The profile must be preconfigured on the node to work.
   * Must be a descending path, relative to the kubelet's configured seccomp profile location.
   * Must be set if type is "Localhost". Must NOT be set for any other type.
   *
   * @schema PrometheusSpecInitContainersSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied.
   * Valid options are:
   *
   *
   * Localhost - a profile defined in a file on the node should be used.
   * RuntimeDefault - the container runtime default profile should be used.
   * Unconfined - no profile should be applied.
   *
   * @schema PrometheusSpecInitContainersSecurityContextSeccompProfile#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'PrometheusSpecInitContainersSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersSecurityContextSeccompProfile(obj: PrometheusSpecInitContainersSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Windows specific settings applied to all containers.
 * If unspecified, the options from the PodSecurityContext will be used.
 * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema PrometheusSpecInitContainersSecurityContextWindowsOptions
 */
export interface PrometheusSpecInitContainersSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook
   * (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
   * GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema PrometheusSpecInitContainersSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema PrometheusSpecInitContainersSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container.
   * All of a Pod's containers must have the same effective HostProcess value
   * (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
   * In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema PrometheusSpecInitContainersSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process.
   * Defaults to the user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext. If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified.
   * @schema PrometheusSpecInitContainersSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'PrometheusSpecInitContainersSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersSecurityContextWindowsOptions(obj: PrometheusSpecInitContainersSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema PrometheusSpecInitContainersStartupProbeExec
 */
export interface PrometheusSpecInitContainersStartupProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema PrometheusSpecInitContainersStartupProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'PrometheusSpecInitContainersStartupProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersStartupProbeExec(obj: PrometheusSpecInitContainersStartupProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port.
 *
 * @schema PrometheusSpecInitContainersStartupProbeGrpc
 */
export interface PrometheusSpecInitContainersStartupProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema PrometheusSpecInitContainersStartupProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest
   * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   *
   *
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema PrometheusSpecInitContainersStartupProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'PrometheusSpecInitContainersStartupProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersStartupProbeGrpc(obj: PrometheusSpecInitContainersStartupProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema PrometheusSpecInitContainersStartupProbeHttpGet
 */
export interface PrometheusSpecInitContainersStartupProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema PrometheusSpecInitContainersStartupProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema PrometheusSpecInitContainersStartupProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: PrometheusSpecInitContainersStartupProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema PrometheusSpecInitContainersStartupProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema PrometheusSpecInitContainersStartupProbeHttpGet#port
   */
  readonly port: PrometheusSpecInitContainersStartupProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema PrometheusSpecInitContainersStartupProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'PrometheusSpecInitContainersStartupProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersStartupProbeHttpGet(obj: PrometheusSpecInitContainersStartupProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_PrometheusSpecInitContainersStartupProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema PrometheusSpecInitContainersStartupProbeTcpSocket
 */
export interface PrometheusSpecInitContainersStartupProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema PrometheusSpecInitContainersStartupProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema PrometheusSpecInitContainersStartupProbeTcpSocket#port
   */
  readonly port: PrometheusSpecInitContainersStartupProbeTcpSocketPort;

}

/**
 * Converts an object of type 'PrometheusSpecInitContainersStartupProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersStartupProbeTcpSocket(obj: PrometheusSpecInitContainersStartupProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a Secret in the namespace that contains the credentials for authentication.
 *
 * @schema PrometheusSpecRemoteReadAuthorizationCredentials
 */
export interface PrometheusSpecRemoteReadAuthorizationCredentials {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecRemoteReadAuthorizationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecRemoteReadAuthorizationCredentials#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecRemoteReadAuthorizationCredentials#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecRemoteReadAuthorizationCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteReadAuthorizationCredentials(obj: PrometheusSpecRemoteReadAuthorizationCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `password` specifies a key of a Secret containing the password for
 * authentication.
 *
 * @schema PrometheusSpecRemoteReadBasicAuthPassword
 */
export interface PrometheusSpecRemoteReadBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecRemoteReadBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecRemoteReadBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecRemoteReadBasicAuthPassword#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecRemoteReadBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteReadBasicAuthPassword(obj: PrometheusSpecRemoteReadBasicAuthPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `username` specifies a key of a Secret containing the username for
 * authentication.
 *
 * @schema PrometheusSpecRemoteReadBasicAuthUsername
 */
export interface PrometheusSpecRemoteReadBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecRemoteReadBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecRemoteReadBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecRemoteReadBasicAuthUsername#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecRemoteReadBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteReadBasicAuthUsername(obj: PrometheusSpecRemoteReadBasicAuthUsername | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `clientId` specifies a key of a Secret or ConfigMap containing the
 * OAuth2 client's ID.
 *
 * @schema PrometheusSpecRemoteReadOauth2ClientId
 */
export interface PrometheusSpecRemoteReadOauth2ClientId {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema PrometheusSpecRemoteReadOauth2ClientId#configMap
   */
  readonly configMap?: PrometheusSpecRemoteReadOauth2ClientIdConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema PrometheusSpecRemoteReadOauth2ClientId#secret
   */
  readonly secret?: PrometheusSpecRemoteReadOauth2ClientIdSecret;

}

/**
 * Converts an object of type 'PrometheusSpecRemoteReadOauth2ClientId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteReadOauth2ClientId(obj: PrometheusSpecRemoteReadOauth2ClientId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_PrometheusSpecRemoteReadOauth2ClientIdConfigMap(obj.configMap),
    'secret': toJson_PrometheusSpecRemoteReadOauth2ClientIdSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `clientSecret` specifies a key of a Secret containing the OAuth2
 * client's secret.
 *
 * @schema PrometheusSpecRemoteReadOauth2ClientSecret
 */
export interface PrometheusSpecRemoteReadOauth2ClientSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecRemoteReadOauth2ClientSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecRemoteReadOauth2ClientSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecRemoteReadOauth2ClientSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecRemoteReadOauth2ClientSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteReadOauth2ClientSecret(obj: PrometheusSpecRemoteReadOauth2ClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Certificate authority used when verifying server certificates.
 *
 * @schema PrometheusSpecRemoteReadTlsConfigCa
 */
export interface PrometheusSpecRemoteReadTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema PrometheusSpecRemoteReadTlsConfigCa#configMap
   */
  readonly configMap?: PrometheusSpecRemoteReadTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema PrometheusSpecRemoteReadTlsConfigCa#secret
   */
  readonly secret?: PrometheusSpecRemoteReadTlsConfigCaSecret;

}

/**
 * Converts an object of type 'PrometheusSpecRemoteReadTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteReadTlsConfigCa(obj: PrometheusSpecRemoteReadTlsConfigCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_PrometheusSpecRemoteReadTlsConfigCaConfigMap(obj.configMap),
    'secret': toJson_PrometheusSpecRemoteReadTlsConfigCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Client certificate to present when doing client-authentication.
 *
 * @schema PrometheusSpecRemoteReadTlsConfigCert
 */
export interface PrometheusSpecRemoteReadTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema PrometheusSpecRemoteReadTlsConfigCert#configMap
   */
  readonly configMap?: PrometheusSpecRemoteReadTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema PrometheusSpecRemoteReadTlsConfigCert#secret
   */
  readonly secret?: PrometheusSpecRemoteReadTlsConfigCertSecret;

}

/**
 * Converts an object of type 'PrometheusSpecRemoteReadTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteReadTlsConfigCert(obj: PrometheusSpecRemoteReadTlsConfigCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_PrometheusSpecRemoteReadTlsConfigCertConfigMap(obj.configMap),
    'secret': toJson_PrometheusSpecRemoteReadTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema PrometheusSpecRemoteReadTlsConfigKeySecret
 */
export interface PrometheusSpecRemoteReadTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecRemoteReadTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecRemoteReadTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecRemoteReadTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecRemoteReadTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteReadTlsConfigKeySecret(obj: PrometheusSpecRemoteReadTlsConfigKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a Secret in the namespace that contains the credentials for authentication.
 *
 * @schema PrometheusSpecRemoteWriteAuthorizationCredentials
 */
export interface PrometheusSpecRemoteWriteAuthorizationCredentials {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecRemoteWriteAuthorizationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecRemoteWriteAuthorizationCredentials#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecRemoteWriteAuthorizationCredentials#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecRemoteWriteAuthorizationCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteWriteAuthorizationCredentials(obj: PrometheusSpecRemoteWriteAuthorizationCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Azure Cloud. Options are 'AzurePublic', 'AzureChina', or 'AzureGovernment'.
 *
 * @schema PrometheusSpecRemoteWriteAzureAdCloud
 */
export enum PrometheusSpecRemoteWriteAzureAdCloud {
  /** AzureChina */
  AZURE_CHINA = "AzureChina",
  /** AzureGovernment */
  AZURE_GOVERNMENT = "AzureGovernment",
  /** AzurePublic */
  AZURE_PUBLIC = "AzurePublic",
}

/**
 * ManagedIdentity defines the Azure User-assigned Managed identity.
 * Cannot be set at the same time as `oauth` or `sdk`.
 *
 * @schema PrometheusSpecRemoteWriteAzureAdManagedIdentity
 */
export interface PrometheusSpecRemoteWriteAzureAdManagedIdentity {
  /**
   * The client id
   *
   * @schema PrometheusSpecRemoteWriteAzureAdManagedIdentity#clientId
   */
  readonly clientId: string;

}

/**
 * Converts an object of type 'PrometheusSpecRemoteWriteAzureAdManagedIdentity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteWriteAzureAdManagedIdentity(obj: PrometheusSpecRemoteWriteAzureAdManagedIdentity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientId': obj.clientId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * OAuth defines the oauth config that is being used to authenticate.
 * Cannot be set at the same time as `managedIdentity` or `sdk`.
 *
 *
 * It requires Prometheus >= v2.48.0.
 *
 * @schema PrometheusSpecRemoteWriteAzureAdOauth
 */
export interface PrometheusSpecRemoteWriteAzureAdOauth {
  /**
   * `clientID` is the clientId of the Azure Active Directory application that is being used to authenticate.
   *
   * @schema PrometheusSpecRemoteWriteAzureAdOauth#clientId
   */
  readonly clientId: string;

  /**
   * `clientSecret` specifies a key of a Secret containing the client secret of the Azure Active Directory application that is being used to authenticate.
   *
   * @schema PrometheusSpecRemoteWriteAzureAdOauth#clientSecret
   */
  readonly clientSecret: PrometheusSpecRemoteWriteAzureAdOauthClientSecret;

  /**
   * `tenantId` is the tenant ID of the Azure Active Directory application that is being used to authenticate.
   *
   * @schema PrometheusSpecRemoteWriteAzureAdOauth#tenantId
   */
  readonly tenantId: string;

}

/**
 * Converts an object of type 'PrometheusSpecRemoteWriteAzureAdOauth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteWriteAzureAdOauth(obj: PrometheusSpecRemoteWriteAzureAdOauth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientId': obj.clientId,
    'clientSecret': toJson_PrometheusSpecRemoteWriteAzureAdOauthClientSecret(obj.clientSecret),
    'tenantId': obj.tenantId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SDK defines the Azure SDK config that is being used to authenticate.
 * See https://learn.microsoft.com/en-us/azure/developer/go/azure-sdk-authentication
 * Cannot be set at the same time as `oauth` or `managedIdentity`.
 *
 *
 * It requires Prometheus >= 2.52.0.
 *
 * @schema PrometheusSpecRemoteWriteAzureAdSdk
 */
export interface PrometheusSpecRemoteWriteAzureAdSdk {
  /**
   * `tenantId` is the tenant ID of the azure active directory application that is being used to authenticate.
   *
   * @schema PrometheusSpecRemoteWriteAzureAdSdk#tenantId
   */
  readonly tenantId?: string;

}

/**
 * Converts an object of type 'PrometheusSpecRemoteWriteAzureAdSdk' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteWriteAzureAdSdk(obj: PrometheusSpecRemoteWriteAzureAdSdk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'tenantId': obj.tenantId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `password` specifies a key of a Secret containing the password for
 * authentication.
 *
 * @schema PrometheusSpecRemoteWriteBasicAuthPassword
 */
export interface PrometheusSpecRemoteWriteBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecRemoteWriteBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecRemoteWriteBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecRemoteWriteBasicAuthPassword#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecRemoteWriteBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteWriteBasicAuthPassword(obj: PrometheusSpecRemoteWriteBasicAuthPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `username` specifies a key of a Secret containing the username for
 * authentication.
 *
 * @schema PrometheusSpecRemoteWriteBasicAuthUsername
 */
export interface PrometheusSpecRemoteWriteBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecRemoteWriteBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecRemoteWriteBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecRemoteWriteBasicAuthUsername#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecRemoteWriteBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteWriteBasicAuthUsername(obj: PrometheusSpecRemoteWriteBasicAuthUsername | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `clientId` specifies a key of a Secret or ConfigMap containing the
 * OAuth2 client's ID.
 *
 * @schema PrometheusSpecRemoteWriteOauth2ClientId
 */
export interface PrometheusSpecRemoteWriteOauth2ClientId {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema PrometheusSpecRemoteWriteOauth2ClientId#configMap
   */
  readonly configMap?: PrometheusSpecRemoteWriteOauth2ClientIdConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema PrometheusSpecRemoteWriteOauth2ClientId#secret
   */
  readonly secret?: PrometheusSpecRemoteWriteOauth2ClientIdSecret;

}

/**
 * Converts an object of type 'PrometheusSpecRemoteWriteOauth2ClientId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteWriteOauth2ClientId(obj: PrometheusSpecRemoteWriteOauth2ClientId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_PrometheusSpecRemoteWriteOauth2ClientIdConfigMap(obj.configMap),
    'secret': toJson_PrometheusSpecRemoteWriteOauth2ClientIdSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `clientSecret` specifies a key of a Secret containing the OAuth2
 * client's secret.
 *
 * @schema PrometheusSpecRemoteWriteOauth2ClientSecret
 */
export interface PrometheusSpecRemoteWriteOauth2ClientSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecRemoteWriteOauth2ClientSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecRemoteWriteOauth2ClientSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecRemoteWriteOauth2ClientSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecRemoteWriteOauth2ClientSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteWriteOauth2ClientSecret(obj: PrometheusSpecRemoteWriteOauth2ClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AccessKey is the AWS API key. If not specified, the environment variable
 * `AWS_ACCESS_KEY_ID` is used.
 *
 * @schema PrometheusSpecRemoteWriteSigv4AccessKey
 */
export interface PrometheusSpecRemoteWriteSigv4AccessKey {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecRemoteWriteSigv4AccessKey#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecRemoteWriteSigv4AccessKey#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecRemoteWriteSigv4AccessKey#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecRemoteWriteSigv4AccessKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteWriteSigv4AccessKey(obj: PrometheusSpecRemoteWriteSigv4AccessKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKey is the AWS API secret. If not specified, the environment
 * variable `AWS_SECRET_ACCESS_KEY` is used.
 *
 * @schema PrometheusSpecRemoteWriteSigv4SecretKey
 */
export interface PrometheusSpecRemoteWriteSigv4SecretKey {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecRemoteWriteSigv4SecretKey#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecRemoteWriteSigv4SecretKey#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecRemoteWriteSigv4SecretKey#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecRemoteWriteSigv4SecretKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteWriteSigv4SecretKey(obj: PrometheusSpecRemoteWriteSigv4SecretKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Certificate authority used when verifying server certificates.
 *
 * @schema PrometheusSpecRemoteWriteTlsConfigCa
 */
export interface PrometheusSpecRemoteWriteTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema PrometheusSpecRemoteWriteTlsConfigCa#configMap
   */
  readonly configMap?: PrometheusSpecRemoteWriteTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema PrometheusSpecRemoteWriteTlsConfigCa#secret
   */
  readonly secret?: PrometheusSpecRemoteWriteTlsConfigCaSecret;

}

/**
 * Converts an object of type 'PrometheusSpecRemoteWriteTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteWriteTlsConfigCa(obj: PrometheusSpecRemoteWriteTlsConfigCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_PrometheusSpecRemoteWriteTlsConfigCaConfigMap(obj.configMap),
    'secret': toJson_PrometheusSpecRemoteWriteTlsConfigCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Client certificate to present when doing client-authentication.
 *
 * @schema PrometheusSpecRemoteWriteTlsConfigCert
 */
export interface PrometheusSpecRemoteWriteTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema PrometheusSpecRemoteWriteTlsConfigCert#configMap
   */
  readonly configMap?: PrometheusSpecRemoteWriteTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema PrometheusSpecRemoteWriteTlsConfigCert#secret
   */
  readonly secret?: PrometheusSpecRemoteWriteTlsConfigCertSecret;

}

/**
 * Converts an object of type 'PrometheusSpecRemoteWriteTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteWriteTlsConfigCert(obj: PrometheusSpecRemoteWriteTlsConfigCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_PrometheusSpecRemoteWriteTlsConfigCertConfigMap(obj.configMap),
    'secret': toJson_PrometheusSpecRemoteWriteTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema PrometheusSpecRemoteWriteTlsConfigKeySecret
 */
export interface PrometheusSpecRemoteWriteTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecRemoteWriteTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecRemoteWriteTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecRemoteWriteTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecRemoteWriteTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteWriteTlsConfigKeySecret(obj: PrometheusSpecRemoteWriteTlsConfigKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Action to perform based on the regex matching.
 *
 *
 * `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0.
 * `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.
 *
 *
 * Default: "Replace"
 *
 * @schema PrometheusSpecRemoteWriteWriteRelabelConfigsAction
 */
export enum PrometheusSpecRemoteWriteWriteRelabelConfigsAction {
  /** replace */
  REPLACE = "replace",
  /** keep */
  KEEP = "keep",
  /** drop */
  DROP = "drop",
  /** hashmod */
  HASHMOD = "hashmod",
  /** labelmap */
  LABELMAP = "labelmap",
  /** labeldrop */
  LABELDROP = "labeldrop",
  /** labelkeep */
  LABELKEEP = "labelkeep",
  /** lowercase */
  LOWERCASE = "lowercase",
  /** uppercase */
  UPPERCASE = "uppercase",
  /** keepequal */
  KEEPEQUAL = "keepequal",
  /** dropequal */
  DROPEQUAL = "dropequal",
}

/**
 * Action to perform based on the regex matching.
 *
 *
 * `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0.
 * `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.
 *
 *
 * Default: "Replace"
 *
 * @schema PrometheusSpecScrapeClassesRelabelingsAction
 */
export enum PrometheusSpecScrapeClassesRelabelingsAction {
  /** replace */
  REPLACE = "replace",
  /** keep */
  KEEP = "keep",
  /** drop */
  DROP = "drop",
  /** hashmod */
  HASHMOD = "hashmod",
  /** labelmap */
  LABELMAP = "labelmap",
  /** labeldrop */
  LABELDROP = "labeldrop",
  /** labelkeep */
  LABELKEEP = "labelkeep",
  /** lowercase */
  LOWERCASE = "lowercase",
  /** uppercase */
  UPPERCASE = "uppercase",
  /** keepequal */
  KEEPEQUAL = "keepequal",
  /** dropequal */
  DROPEQUAL = "dropequal",
}

/**
 * Certificate authority used when verifying server certificates.
 *
 * @schema PrometheusSpecScrapeClassesTlsConfigCa
 */
export interface PrometheusSpecScrapeClassesTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema PrometheusSpecScrapeClassesTlsConfigCa#configMap
   */
  readonly configMap?: PrometheusSpecScrapeClassesTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema PrometheusSpecScrapeClassesTlsConfigCa#secret
   */
  readonly secret?: PrometheusSpecScrapeClassesTlsConfigCaSecret;

}

/**
 * Converts an object of type 'PrometheusSpecScrapeClassesTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecScrapeClassesTlsConfigCa(obj: PrometheusSpecScrapeClassesTlsConfigCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_PrometheusSpecScrapeClassesTlsConfigCaConfigMap(obj.configMap),
    'secret': toJson_PrometheusSpecScrapeClassesTlsConfigCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Client certificate to present when doing client-authentication.
 *
 * @schema PrometheusSpecScrapeClassesTlsConfigCert
 */
export interface PrometheusSpecScrapeClassesTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema PrometheusSpecScrapeClassesTlsConfigCert#configMap
   */
  readonly configMap?: PrometheusSpecScrapeClassesTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema PrometheusSpecScrapeClassesTlsConfigCert#secret
   */
  readonly secret?: PrometheusSpecScrapeClassesTlsConfigCertSecret;

}

/**
 * Converts an object of type 'PrometheusSpecScrapeClassesTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecScrapeClassesTlsConfigCert(obj: PrometheusSpecScrapeClassesTlsConfigCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_PrometheusSpecScrapeClassesTlsConfigCertConfigMap(obj.configMap),
    'secret': toJson_PrometheusSpecScrapeClassesTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema PrometheusSpecScrapeClassesTlsConfigKeySecret
 */
export interface PrometheusSpecScrapeClassesTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecScrapeClassesTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecScrapeClassesTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecScrapeClassesTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecScrapeClassesTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecScrapeClassesTlsConfigKeySecret(obj: PrometheusSpecScrapeClassesTlsConfigKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * sizeLimit is the total amount of local storage required for this EmptyDir volume.
 * The size limit is also applicable for memory medium.
 * The maximum usage on memory medium EmptyDir would be the minimum value between
 * the SizeLimit specified here and the sum of memory limits of all containers in a pod.
 * The default is nil which means that the limit is undefined.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
 *
 * @schema PrometheusSpecStorageEmptyDirSizeLimit
 */
export class PrometheusSpecStorageEmptyDirSizeLimit {
  public static fromNumber(value: number): PrometheusSpecStorageEmptyDirSizeLimit {
    return new PrometheusSpecStorageEmptyDirSizeLimit(value);
  }
  public static fromString(value: string): PrometheusSpecStorageEmptyDirSizeLimit {
    return new PrometheusSpecStorageEmptyDirSizeLimit(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Will be used to create a stand-alone PVC to provision the volume.
 * The pod in which this EphemeralVolumeSource is embedded will be the
 * owner of the PVC, i.e. the PVC will be deleted together with the
 * pod.  The name of the PVC will be `<pod name>-<volume name>` where
 * `<volume name>` is the name from the `PodSpec.Volumes` array
 * entry. Pod validation will reject the pod if the concatenated name
 * is not valid for a PVC (for example, too long).
 *
 *
 * An existing PVC with that name that is not owned by the pod
 * will *not* be used for the pod to avoid using an unrelated
 * volume by mistake. Starting the pod is then blocked until
 * the unrelated PVC is removed. If such a pre-created PVC is
 * meant to be used by the pod, the PVC has to updated with an
 * owner reference to the pod once the pod exists. Normally
 * this should not be necessary, but it may be useful when
 * manually reconstructing a broken cluster.
 *
 *
 * This field is read-only and no changes will be made by Kubernetes
 * to the PVC after it has been created.
 *
 *
 * Required, must not be nil.
 *
 * @schema PrometheusSpecStorageEphemeralVolumeClaimTemplate
 */
export interface PrometheusSpecStorageEphemeralVolumeClaimTemplate {
  /**
   * May contain labels and annotations that will be copied into the PVC
   * when creating it. No other fields are allowed and will be rejected during
   * validation.
   *
   * @schema PrometheusSpecStorageEphemeralVolumeClaimTemplate#metadata
   */
  readonly metadata?: any;

  /**
   * The specification for the PersistentVolumeClaim. The entire content is
   * copied unchanged into the PVC that gets created from this
   * template. The same fields as in a PersistentVolumeClaim
   * are also valid here.
   *
   * @schema PrometheusSpecStorageEphemeralVolumeClaimTemplate#spec
   */
  readonly spec: PrometheusSpecStorageEphemeralVolumeClaimTemplateSpec;

}

/**
 * Converts an object of type 'PrometheusSpecStorageEphemeralVolumeClaimTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecStorageEphemeralVolumeClaimTemplate(obj: PrometheusSpecStorageEphemeralVolumeClaimTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_PrometheusSpecStorageEphemeralVolumeClaimTemplateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EmbeddedMetadata contains metadata relevant to an EmbeddedResource.
 *
 * @schema PrometheusSpecStorageVolumeClaimTemplateMetadata
 */
export interface PrometheusSpecStorageVolumeClaimTemplateMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be
   * set by external tools to store and retrieve arbitrary metadata. They are not
   * queryable and should be preserved when modifying objects.
   * More info: http://kubernetes.io/docs/user-guide/annotations
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Map of string keys and values that can be used to organize and categorize
   * (scope and select) objects. May match selectors of replication controllers
   * and services.
   * More info: http://kubernetes.io/docs/user-guide/labels
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Name must be unique within a namespace. Is required when creating resources, although
   * some resources may allow a client to request the generation of an appropriate name
   * automatically. Name is primarily intended for creation idempotence and configuration
   * definition.
   * Cannot be updated.
   * More info: http://kubernetes.io/docs/user-guide/identifiers#names
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateMetadata#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'PrometheusSpecStorageVolumeClaimTemplateMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecStorageVolumeClaimTemplateMetadata(obj: PrometheusSpecStorageVolumeClaimTemplateMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Defines the desired characteristics of a volume requested by a pod author.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
 *
 * @schema PrometheusSpecStorageVolumeClaimTemplateSpec
 */
export interface PrometheusSpecStorageVolumeClaimTemplateSpec {
  /**
   * accessModes contains the desired access modes the volume should have.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateSpec#accessModes
   */
  readonly accessModes?: string[];

  /**
   * dataSource field can be used to specify either:
   * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
   * * An existing PVC (PersistentVolumeClaim)
   * If the provisioner or an external controller can support the specified data source,
   * it will create a new volume based on the contents of the specified data source.
   * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
   * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
   * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateSpec#dataSource
   */
  readonly dataSource?: PrometheusSpecStorageVolumeClaimTemplateSpecDataSource;

  /**
   * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
   * volume is desired. This may be any object from a non-empty API group (non
   * core object) or a PersistentVolumeClaim object.
   * When this field is specified, volume binding will only succeed if the type of
   * the specified object matches some installed volume populator or dynamic
   * provisioner.
   * This field will replace the functionality of the dataSource field and as such
   * if both fields are non-empty, they must have the same value. For backwards
   * compatibility, when namespace isn't specified in dataSourceRef,
   * both fields (dataSource and dataSourceRef) will be set to the same
   * value automatically if one of them is empty and the other is non-empty.
   * When namespace is specified in dataSourceRef,
   * dataSource isn't set to the same value and must be empty.
   * There are three important differences between dataSource and dataSourceRef:
   * * While dataSource only allows two specific types of objects, dataSourceRef
   * allows any non-core object, as well as PersistentVolumeClaim objects.
   * * While dataSource ignores disallowed values (dropping them), dataSourceRef
   * preserves all values, and generates an error if a disallowed value is
   * specified.
   * * While dataSource only allows local objects, dataSourceRef allows objects
   * in any namespaces.
   * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
   * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateSpec#dataSourceRef
   */
  readonly dataSourceRef?: PrometheusSpecStorageVolumeClaimTemplateSpecDataSourceRef;

  /**
   * resources represents the minimum resources the volume should have.
   * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
   * that are lower than previous value but must still be higher than capacity recorded in the
   * status field of the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateSpec#resources
   */
  readonly resources?: PrometheusSpecStorageVolumeClaimTemplateSpecResources;

  /**
   * selector is a label query over volumes to consider for binding.
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateSpec#selector
   */
  readonly selector?: PrometheusSpecStorageVolumeClaimTemplateSpecSelector;

  /**
   * storageClassName is the name of the StorageClass required by the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateSpec#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
   * If specified, the CSI driver will create or update the volume with the attributes defined
   * in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
   * it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
   * will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
   * If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
   * will be set by the persistentvolume controller if it exists.
   * If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
   * set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
   * exists.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#volumeattributesclass
   * (Alpha) Using this field requires the VolumeAttributesClass feature gate to be enabled.
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateSpec#volumeAttributesClassName
   */
  readonly volumeAttributesClassName?: string;

  /**
   * volumeMode defines what type of volume is required by the claim.
   * Value of Filesystem is implied when not included in claim spec.
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateSpec#volumeMode
   */
  readonly volumeMode?: string;

  /**
   * volumeName is the binding reference to the PersistentVolume backing this claim.
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateSpec#volumeName
   */
  readonly volumeName?: string;

}

/**
 * Converts an object of type 'PrometheusSpecStorageVolumeClaimTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecStorageVolumeClaimTemplateSpec(obj: PrometheusSpecStorageVolumeClaimTemplateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessModes': obj.accessModes?.map(y => y),
    'dataSource': toJson_PrometheusSpecStorageVolumeClaimTemplateSpecDataSource(obj.dataSource),
    'dataSourceRef': toJson_PrometheusSpecStorageVolumeClaimTemplateSpecDataSourceRef(obj.dataSourceRef),
    'resources': toJson_PrometheusSpecStorageVolumeClaimTemplateSpecResources(obj.resources),
    'selector': toJson_PrometheusSpecStorageVolumeClaimTemplateSpecSelector(obj.selector),
    'storageClassName': obj.storageClassName,
    'volumeAttributesClassName': obj.volumeAttributesClassName,
    'volumeMode': obj.volumeMode,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Deprecated: this field is never set.
 *
 * @schema PrometheusSpecStorageVolumeClaimTemplateStatus
 */
export interface PrometheusSpecStorageVolumeClaimTemplateStatus {
  /**
   * accessModes contains the actual access modes the volume backing the PVC has.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateStatus#accessModes
   */
  readonly accessModes?: string[];

  /**
   * allocatedResourceStatuses stores status of resource being resized for the given PVC.
   * Key names follow standard Kubernetes label syntax. Valid values are either:
   * * Un-prefixed keys:
   * - storage - the capacity of the volume.
   * * Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource"
   * Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered
   * reserved and hence may not be used.
   *
   *
   * ClaimResourceStatus can be in any of following states:
   * - ControllerResizeInProgress:
   * State set when resize controller starts resizing the volume in control-plane.
   * - ControllerResizeFailed:
   * State set when resize has failed in resize controller with a terminal error.
   * - NodeResizePending:
   * State set when resize controller has finished resizing the volume but further resizing of
   * volume is needed on the node.
   * - NodeResizeInProgress:
   * State set when kubelet starts resizing the volume.
   * - NodeResizeFailed:
   * State set when resizing has failed in kubelet with a terminal error. Transient errors don't set
   * NodeResizeFailed.
   * For example: if expanding a PVC for more capacity - this field can be one of the following states:
   * - pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeInProgress"
   * - pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeFailed"
   * - pvc.status.allocatedResourceStatus['storage'] = "NodeResizePending"
   * - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeInProgress"
   * - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeFailed"
   * When this field is not set, it means that no resize operation is in progress for the given PVC.
   *
   *
   * A controller that receives PVC update with previously unknown resourceName or ClaimResourceStatus
   * should ignore the update for the purpose it was designed. For example - a controller that
   * only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid
   * resources associated with PVC.
   *
   *
   * This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateStatus#allocatedResourceStatuses
   */
  readonly allocatedResourceStatuses?: { [key: string]: string };

  /**
   * allocatedResources tracks the resources allocated to a PVC including its capacity.
   * Key names follow standard Kubernetes label syntax. Valid values are either:
   * * Un-prefixed keys:
   * - storage - the capacity of the volume.
   * * Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource"
   * Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered
   * reserved and hence may not be used.
   *
   *
   * Capacity reported here may be larger than the actual capacity when a volume expansion operation
   * is requested.
   * For storage quota, the larger value from allocatedResources and PVC.spec.resources is used.
   * If allocatedResources is not set, PVC.spec.resources alone is used for quota calculation.
   * If a volume expansion capacity request is lowered, allocatedResources is only
   * lowered if there are no expansion operations in progress and if the actual volume capacity
   * is equal or lower than the requested capacity.
   *
   *
   * A controller that receives PVC update with previously unknown resourceName
   * should ignore the update for the purpose it was designed. For example - a controller that
   * only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid
   * resources associated with PVC.
   *
   *
   * This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateStatus#allocatedResources
   */
  readonly allocatedResources?: { [key: string]: PrometheusSpecStorageVolumeClaimTemplateStatusAllocatedResources };

  /**
   * capacity represents the actual resources of the underlying volume.
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateStatus#capacity
   */
  readonly capacity?: { [key: string]: PrometheusSpecStorageVolumeClaimTemplateStatusCapacity };

  /**
   * conditions is the current Condition of persistent volume claim. If underlying persistent volume is being
   * resized then the Condition will be set to 'ResizeStarted'.
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateStatus#conditions
   */
  readonly conditions?: PrometheusSpecStorageVolumeClaimTemplateStatusConditions[];

  /**
   * currentVolumeAttributesClassName is the current name of the VolumeAttributesClass the PVC is using.
   * When unset, there is no VolumeAttributeClass applied to this PersistentVolumeClaim
   * This is an alpha field and requires enabling VolumeAttributesClass feature.
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateStatus#currentVolumeAttributesClassName
   */
  readonly currentVolumeAttributesClassName?: string;

  /**
   * ModifyVolumeStatus represents the status object of ControllerModifyVolume operation.
   * When this is unset, there is no ModifyVolume operation being attempted.
   * This is an alpha field and requires enabling VolumeAttributesClass feature.
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateStatus#modifyVolumeStatus
   */
  readonly modifyVolumeStatus?: PrometheusSpecStorageVolumeClaimTemplateStatusModifyVolumeStatus;

  /**
   * phase represents the current phase of PersistentVolumeClaim.
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateStatus#phase
   */
  readonly phase?: string;

}

/**
 * Converts an object of type 'PrometheusSpecStorageVolumeClaimTemplateStatus' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecStorageVolumeClaimTemplateStatus(obj: PrometheusSpecStorageVolumeClaimTemplateStatus | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessModes': obj.accessModes?.map(y => y),
    'allocatedResourceStatuses': ((obj.allocatedResourceStatuses) === undefined) ? undefined : (Object.entries(obj.allocatedResourceStatuses).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'allocatedResources': ((obj.allocatedResources) === undefined) ? undefined : (Object.entries(obj.allocatedResources).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'capacity': ((obj.capacity) === undefined) ? undefined : (Object.entries(obj.capacity).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'conditions': obj.conditions?.map(y => toJson_PrometheusSpecStorageVolumeClaimTemplateStatusConditions(y)),
    'currentVolumeAttributesClassName': obj.currentVolumeAttributesClassName,
    'modifyVolumeStatus': toJson_PrometheusSpecStorageVolumeClaimTemplateStatusModifyVolumeStatus(obj.modifyVolumeStatus),
    'phase': obj.phase,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Certificate authority used when verifying server certificates.
 *
 * @schema PrometheusSpecThanosGrpcServerTlsConfigCa
 */
export interface PrometheusSpecThanosGrpcServerTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema PrometheusSpecThanosGrpcServerTlsConfigCa#configMap
   */
  readonly configMap?: PrometheusSpecThanosGrpcServerTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema PrometheusSpecThanosGrpcServerTlsConfigCa#secret
   */
  readonly secret?: PrometheusSpecThanosGrpcServerTlsConfigCaSecret;

}

/**
 * Converts an object of type 'PrometheusSpecThanosGrpcServerTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecThanosGrpcServerTlsConfigCa(obj: PrometheusSpecThanosGrpcServerTlsConfigCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_PrometheusSpecThanosGrpcServerTlsConfigCaConfigMap(obj.configMap),
    'secret': toJson_PrometheusSpecThanosGrpcServerTlsConfigCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Client certificate to present when doing client-authentication.
 *
 * @schema PrometheusSpecThanosGrpcServerTlsConfigCert
 */
export interface PrometheusSpecThanosGrpcServerTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema PrometheusSpecThanosGrpcServerTlsConfigCert#configMap
   */
  readonly configMap?: PrometheusSpecThanosGrpcServerTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema PrometheusSpecThanosGrpcServerTlsConfigCert#secret
   */
  readonly secret?: PrometheusSpecThanosGrpcServerTlsConfigCertSecret;

}

/**
 * Converts an object of type 'PrometheusSpecThanosGrpcServerTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecThanosGrpcServerTlsConfigCert(obj: PrometheusSpecThanosGrpcServerTlsConfigCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_PrometheusSpecThanosGrpcServerTlsConfigCertConfigMap(obj.configMap),
    'secret': toJson_PrometheusSpecThanosGrpcServerTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema PrometheusSpecThanosGrpcServerTlsConfigKeySecret
 */
export interface PrometheusSpecThanosGrpcServerTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecThanosGrpcServerTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecThanosGrpcServerTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecThanosGrpcServerTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecThanosGrpcServerTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecThanosGrpcServerTlsConfigKeySecret(obj: PrometheusSpecThanosGrpcServerTlsConfigKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema PrometheusSpecThanosResourcesClaims
 */
export interface PrometheusSpecThanosResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema PrometheusSpecThanosResourcesClaims#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'PrometheusSpecThanosResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecThanosResourcesClaims(obj: PrometheusSpecThanosResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PrometheusSpecThanosResourcesLimits
 */
export class PrometheusSpecThanosResourcesLimits {
  public static fromNumber(value: number): PrometheusSpecThanosResourcesLimits {
    return new PrometheusSpecThanosResourcesLimits(value);
  }
  public static fromString(value: string): PrometheusSpecThanosResourcesLimits {
    return new PrometheusSpecThanosResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema PrometheusSpecThanosResourcesRequests
 */
export class PrometheusSpecThanosResourcesRequests {
  public static fromNumber(value: number): PrometheusSpecThanosResourcesRequests {
    return new PrometheusSpecThanosResourcesRequests(value);
  }
  public static fromString(value: string): PrometheusSpecThanosResourcesRequests {
    return new PrometheusSpecThanosResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema PrometheusSpecTopologySpreadConstraintsLabelSelectorMatchExpressions
 */
export interface PrometheusSpecTopologySpreadConstraintsLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PrometheusSpecTopologySpreadConstraintsLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PrometheusSpecTopologySpreadConstraintsLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema PrometheusSpecTopologySpreadConstraintsLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'PrometheusSpecTopologySpreadConstraintsLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecTopologySpreadConstraintsLabelSelectorMatchExpressions(obj: PrometheusSpecTopologySpreadConstraintsLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Certificate authority used when verifying server certificates.
 *
 * @schema PrometheusSpecTracingConfigTlsConfigCa
 */
export interface PrometheusSpecTracingConfigTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema PrometheusSpecTracingConfigTlsConfigCa#configMap
   */
  readonly configMap?: PrometheusSpecTracingConfigTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema PrometheusSpecTracingConfigTlsConfigCa#secret
   */
  readonly secret?: PrometheusSpecTracingConfigTlsConfigCaSecret;

}

/**
 * Converts an object of type 'PrometheusSpecTracingConfigTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecTracingConfigTlsConfigCa(obj: PrometheusSpecTracingConfigTlsConfigCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_PrometheusSpecTracingConfigTlsConfigCaConfigMap(obj.configMap),
    'secret': toJson_PrometheusSpecTracingConfigTlsConfigCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Client certificate to present when doing client-authentication.
 *
 * @schema PrometheusSpecTracingConfigTlsConfigCert
 */
export interface PrometheusSpecTracingConfigTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema PrometheusSpecTracingConfigTlsConfigCert#configMap
   */
  readonly configMap?: PrometheusSpecTracingConfigTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema PrometheusSpecTracingConfigTlsConfigCert#secret
   */
  readonly secret?: PrometheusSpecTracingConfigTlsConfigCertSecret;

}

/**
 * Converts an object of type 'PrometheusSpecTracingConfigTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecTracingConfigTlsConfigCert(obj: PrometheusSpecTracingConfigTlsConfigCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_PrometheusSpecTracingConfigTlsConfigCertConfigMap(obj.configMap),
    'secret': toJson_PrometheusSpecTracingConfigTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema PrometheusSpecTracingConfigTlsConfigKeySecret
 */
export interface PrometheusSpecTracingConfigTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecTracingConfigTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecTracingConfigTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecTracingConfigTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecTracingConfigTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecTracingConfigTlsConfigKeySecret(obj: PrometheusSpecTracingConfigTlsConfigKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty.
 * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
 *
 * @schema PrometheusSpecVolumesCephfsSecretRef
 */
export interface PrometheusSpecVolumesCephfsSecretRef {
  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecVolumesCephfsSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'PrometheusSpecVolumesCephfsSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesCephfsSecretRef(obj: PrometheusSpecVolumesCephfsSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * secretRef is optional: points to a secret object containing parameters used to connect
 * to OpenStack.
 *
 * @schema PrometheusSpecVolumesCinderSecretRef
 */
export interface PrometheusSpecVolumesCinderSecretRef {
  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecVolumesCinderSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'PrometheusSpecVolumesCinderSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesCinderSecretRef(obj: PrometheusSpecVolumesCinderSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema PrometheusSpecVolumesConfigMapItems
 */
export interface PrometheusSpecVolumesConfigMapItems {
  /**
   * key is the key to project.
   *
   * @schema PrometheusSpecVolumesConfigMapItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema PrometheusSpecVolumesConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to.
   * May not be an absolute path.
   * May not contain the path element '..'.
   * May not start with the string '..'.
   *
   * @schema PrometheusSpecVolumesConfigMapItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'PrometheusSpecVolumesConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesConfigMapItems(obj: PrometheusSpecVolumesConfigMapItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * nodePublishSecretRef is a reference to the secret object containing
 * sensitive information to pass to the CSI driver to complete the CSI
 * NodePublishVolume and NodeUnpublishVolume calls.
 * This field is optional, and  may be empty if no secret is required. If the
 * secret object contains more than one secret, all secret references are passed.
 *
 * @schema PrometheusSpecVolumesCsiNodePublishSecretRef
 */
export interface PrometheusSpecVolumesCsiNodePublishSecretRef {
  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecVolumesCsiNodePublishSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'PrometheusSpecVolumesCsiNodePublishSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesCsiNodePublishSecretRef(obj: PrometheusSpecVolumesCsiNodePublishSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DownwardAPIVolumeFile represents information to create the file containing the pod field
 *
 * @schema PrometheusSpecVolumesDownwardApiItems
 */
export interface PrometheusSpecVolumesDownwardApiItems {
  /**
   * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
   *
   * @schema PrometheusSpecVolumesDownwardApiItems#fieldRef
   */
  readonly fieldRef?: PrometheusSpecVolumesDownwardApiItemsFieldRef;

  /**
   * Optional: mode bits used to set permissions on this file, must be an octal value
   * between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema PrometheusSpecVolumesDownwardApiItems#mode
   */
  readonly mode?: number;

  /**
   * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
   *
   * @schema PrometheusSpecVolumesDownwardApiItems#path
   */
  readonly path: string;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
   *
   * @schema PrometheusSpecVolumesDownwardApiItems#resourceFieldRef
   */
  readonly resourceFieldRef?: PrometheusSpecVolumesDownwardApiItemsResourceFieldRef;

}

/**
 * Converts an object of type 'PrometheusSpecVolumesDownwardApiItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesDownwardApiItems(obj: PrometheusSpecVolumesDownwardApiItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fieldRef': toJson_PrometheusSpecVolumesDownwardApiItemsFieldRef(obj.fieldRef),
    'mode': obj.mode,
    'path': obj.path,
    'resourceFieldRef': toJson_PrometheusSpecVolumesDownwardApiItemsResourceFieldRef(obj.resourceFieldRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * sizeLimit is the total amount of local storage required for this EmptyDir volume.
 * The size limit is also applicable for memory medium.
 * The maximum usage on memory medium EmptyDir would be the minimum value between
 * the SizeLimit specified here and the sum of memory limits of all containers in a pod.
 * The default is nil which means that the limit is undefined.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
 *
 * @schema PrometheusSpecVolumesEmptyDirSizeLimit
 */
export class PrometheusSpecVolumesEmptyDirSizeLimit {
  public static fromNumber(value: number): PrometheusSpecVolumesEmptyDirSizeLimit {
    return new PrometheusSpecVolumesEmptyDirSizeLimit(value);
  }
  public static fromString(value: string): PrometheusSpecVolumesEmptyDirSizeLimit {
    return new PrometheusSpecVolumesEmptyDirSizeLimit(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Will be used to create a stand-alone PVC to provision the volume.
 * The pod in which this EphemeralVolumeSource is embedded will be the
 * owner of the PVC, i.e. the PVC will be deleted together with the
 * pod.  The name of the PVC will be `<pod name>-<volume name>` where
 * `<volume name>` is the name from the `PodSpec.Volumes` array
 * entry. Pod validation will reject the pod if the concatenated name
 * is not valid for a PVC (for example, too long).
 *
 *
 * An existing PVC with that name that is not owned by the pod
 * will *not* be used for the pod to avoid using an unrelated
 * volume by mistake. Starting the pod is then blocked until
 * the unrelated PVC is removed. If such a pre-created PVC is
 * meant to be used by the pod, the PVC has to updated with an
 * owner reference to the pod once the pod exists. Normally
 * this should not be necessary, but it may be useful when
 * manually reconstructing a broken cluster.
 *
 *
 * This field is read-only and no changes will be made by Kubernetes
 * to the PVC after it has been created.
 *
 *
 * Required, must not be nil.
 *
 * @schema PrometheusSpecVolumesEphemeralVolumeClaimTemplate
 */
export interface PrometheusSpecVolumesEphemeralVolumeClaimTemplate {
  /**
   * May contain labels and annotations that will be copied into the PVC
   * when creating it. No other fields are allowed and will be rejected during
   * validation.
   *
   * @schema PrometheusSpecVolumesEphemeralVolumeClaimTemplate#metadata
   */
  readonly metadata?: any;

  /**
   * The specification for the PersistentVolumeClaim. The entire content is
   * copied unchanged into the PVC that gets created from this
   * template. The same fields as in a PersistentVolumeClaim
   * are also valid here.
   *
   * @schema PrometheusSpecVolumesEphemeralVolumeClaimTemplate#spec
   */
  readonly spec: PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpec;

}

/**
 * Converts an object of type 'PrometheusSpecVolumesEphemeralVolumeClaimTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesEphemeralVolumeClaimTemplate(obj: PrometheusSpecVolumesEphemeralVolumeClaimTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * secretRef is Optional: secretRef is reference to the secret object containing
 * sensitive information to pass to the plugin scripts. This may be
 * empty if no secret object is specified. If the secret object
 * contains more than one secret, all secrets are passed to the plugin
 * scripts.
 *
 * @schema PrometheusSpecVolumesFlexVolumeSecretRef
 */
export interface PrometheusSpecVolumesFlexVolumeSecretRef {
  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecVolumesFlexVolumeSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'PrometheusSpecVolumesFlexVolumeSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesFlexVolumeSecretRef(obj: PrometheusSpecVolumesFlexVolumeSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * secretRef is the CHAP Secret for iSCSI target and initiator authentication
 *
 * @schema PrometheusSpecVolumesIscsiSecretRef
 */
export interface PrometheusSpecVolumesIscsiSecretRef {
  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecVolumesIscsiSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'PrometheusSpecVolumesIscsiSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesIscsiSecretRef(obj: PrometheusSpecVolumesIscsiSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Projection that may be projected along with other supported volume types
 *
 * @schema PrometheusSpecVolumesProjectedSources
 */
export interface PrometheusSpecVolumesProjectedSources {
  /**
   * ClusterTrustBundle allows a pod to access the `.spec.trustBundle` field
   * of ClusterTrustBundle objects in an auto-updating file.
   *
   *
   * Alpha, gated by the ClusterTrustBundleProjection feature gate.
   *
   *
   * ClusterTrustBundle objects can either be selected by name, or by the
   * combination of signer name and a label selector.
   *
   *
   * Kubelet performs aggressive normalization of the PEM contents written
   * into the pod filesystem.  Esoteric PEM features such as inter-block
   * comments and block headers are stripped.  Certificates are deduplicated.
   * The ordering of certificates within the file is arbitrary, and Kubelet
   * may change the order over time.
   *
   * @schema PrometheusSpecVolumesProjectedSources#clusterTrustBundle
   */
  readonly clusterTrustBundle?: PrometheusSpecVolumesProjectedSourcesClusterTrustBundle;

  /**
   * configMap information about the configMap data to project
   *
   * @schema PrometheusSpecVolumesProjectedSources#configMap
   */
  readonly configMap?: PrometheusSpecVolumesProjectedSourcesConfigMap;

  /**
   * downwardAPI information about the downwardAPI data to project
   *
   * @schema PrometheusSpecVolumesProjectedSources#downwardAPI
   */
  readonly downwardApi?: PrometheusSpecVolumesProjectedSourcesDownwardApi;

  /**
   * secret information about the secret data to project
   *
   * @schema PrometheusSpecVolumesProjectedSources#secret
   */
  readonly secret?: PrometheusSpecVolumesProjectedSourcesSecret;

  /**
   * serviceAccountToken is information about the serviceAccountToken data to project
   *
   * @schema PrometheusSpecVolumesProjectedSources#serviceAccountToken
   */
  readonly serviceAccountToken?: PrometheusSpecVolumesProjectedSourcesServiceAccountToken;

}

/**
 * Converts an object of type 'PrometheusSpecVolumesProjectedSources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesProjectedSources(obj: PrometheusSpecVolumesProjectedSources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterTrustBundle': toJson_PrometheusSpecVolumesProjectedSourcesClusterTrustBundle(obj.clusterTrustBundle),
    'configMap': toJson_PrometheusSpecVolumesProjectedSourcesConfigMap(obj.configMap),
    'downwardAPI': toJson_PrometheusSpecVolumesProjectedSourcesDownwardApi(obj.downwardApi),
    'secret': toJson_PrometheusSpecVolumesProjectedSourcesSecret(obj.secret),
    'serviceAccountToken': toJson_PrometheusSpecVolumesProjectedSourcesServiceAccountToken(obj.serviceAccountToken),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * secretRef is name of the authentication secret for RBDUser. If provided
 * overrides keyring.
 * Default is nil.
 * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
 *
 * @default nil.
 * @schema PrometheusSpecVolumesRbdSecretRef
 */
export interface PrometheusSpecVolumesRbdSecretRef {
  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecVolumesRbdSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'PrometheusSpecVolumesRbdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesRbdSecretRef(obj: PrometheusSpecVolumesRbdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * secretRef references to the secret for ScaleIO user and other
 * sensitive information. If this is not provided, Login operation will fail.
 *
 * @schema PrometheusSpecVolumesScaleIoSecretRef
 */
export interface PrometheusSpecVolumesScaleIoSecretRef {
  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecVolumesScaleIoSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'PrometheusSpecVolumesScaleIoSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesScaleIoSecretRef(obj: PrometheusSpecVolumesScaleIoSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema PrometheusSpecVolumesSecretItems
 */
export interface PrometheusSpecVolumesSecretItems {
  /**
   * key is the key to project.
   *
   * @schema PrometheusSpecVolumesSecretItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema PrometheusSpecVolumesSecretItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to.
   * May not be an absolute path.
   * May not contain the path element '..'.
   * May not start with the string '..'.
   *
   * @schema PrometheusSpecVolumesSecretItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'PrometheusSpecVolumesSecretItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesSecretItems(obj: PrometheusSpecVolumesSecretItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * secretRef specifies the secret to use for obtaining the StorageOS API
 * credentials.  If not specified, default values will be attempted.
 *
 * @schema PrometheusSpecVolumesStorageosSecretRef
 */
export interface PrometheusSpecVolumesStorageosSecretRef {
  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecVolumesStorageosSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'PrometheusSpecVolumesStorageosSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesStorageosSecretRef(obj: PrometheusSpecVolumesStorageosSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * List of headers that can be added to HTTP responses.
 *
 * @schema PrometheusSpecWebHttpConfigHeaders
 */
export interface PrometheusSpecWebHttpConfigHeaders {
  /**
   * Set the Content-Security-Policy header to HTTP responses.
   * Unset if blank.
   *
   * @schema PrometheusSpecWebHttpConfigHeaders#contentSecurityPolicy
   */
  readonly contentSecurityPolicy?: string;

  /**
   * Set the Strict-Transport-Security header to HTTP responses.
   * Unset if blank.
   * Please make sure that you use this with care as this header might force
   * browsers to load Prometheus and the other applications hosted on the same
   * domain and subdomains over HTTPS.
   * https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security
   *
   * @schema PrometheusSpecWebHttpConfigHeaders#strictTransportSecurity
   */
  readonly strictTransportSecurity?: string;

  /**
   * Set the X-Content-Type-Options header to HTTP responses.
   * Unset if blank. Accepted value is nosniff.
   * https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Content-Type-Options
   *
   * @schema PrometheusSpecWebHttpConfigHeaders#xContentTypeOptions
   */
  readonly xContentTypeOptions?: PrometheusSpecWebHttpConfigHeadersXContentTypeOptions;

  /**
   * Set the X-Frame-Options header to HTTP responses.
   * Unset if blank. Accepted values are deny and sameorigin.
   * https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options
   *
   * @schema PrometheusSpecWebHttpConfigHeaders#xFrameOptions
   */
  readonly xFrameOptions?: PrometheusSpecWebHttpConfigHeadersXFrameOptions;

  /**
   * Set the X-XSS-Protection header to all responses.
   * Unset if blank.
   * https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-XSS-Protection
   *
   * @schema PrometheusSpecWebHttpConfigHeaders#xXSSProtection
   */
  readonly xXssProtection?: string;

}

/**
 * Converts an object of type 'PrometheusSpecWebHttpConfigHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecWebHttpConfigHeaders(obj: PrometheusSpecWebHttpConfigHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'contentSecurityPolicy': obj.contentSecurityPolicy,
    'strictTransportSecurity': obj.strictTransportSecurity,
    'xContentTypeOptions': obj.xContentTypeOptions,
    'xFrameOptions': obj.xFrameOptions,
    'xXSSProtection': obj.xXssProtection,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Contains the TLS certificate for the server.
 *
 * @schema PrometheusSpecWebTlsConfigCert
 */
export interface PrometheusSpecWebTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema PrometheusSpecWebTlsConfigCert#configMap
   */
  readonly configMap?: PrometheusSpecWebTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema PrometheusSpecWebTlsConfigCert#secret
   */
  readonly secret?: PrometheusSpecWebTlsConfigCertSecret;

}

/**
 * Converts an object of type 'PrometheusSpecWebTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecWebTlsConfigCert(obj: PrometheusSpecWebTlsConfigCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_PrometheusSpecWebTlsConfigCertConfigMap(obj.configMap),
    'secret': toJson_PrometheusSpecWebTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Contains the CA certificate for client certificate authentication to the server.
 *
 * @schema PrometheusSpecWebTlsConfigClientCa
 */
export interface PrometheusSpecWebTlsConfigClientCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema PrometheusSpecWebTlsConfigClientCa#configMap
   */
  readonly configMap?: PrometheusSpecWebTlsConfigClientCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema PrometheusSpecWebTlsConfigClientCa#secret
   */
  readonly secret?: PrometheusSpecWebTlsConfigClientCaSecret;

}

/**
 * Converts an object of type 'PrometheusSpecWebTlsConfigClientCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecWebTlsConfigClientCa(obj: PrometheusSpecWebTlsConfigClientCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_PrometheusSpecWebTlsConfigClientCaConfigMap(obj.configMap),
    'secret': toJson_PrometheusSpecWebTlsConfigClientCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the TLS key for the server.
 *
 * @schema PrometheusSpecWebTlsConfigKeySecret
 */
export interface PrometheusSpecWebTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecWebTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecWebTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecWebTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecWebTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecWebTlsConfigKeySecret(obj: PrometheusSpecWebTlsConfigKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector term, associated with the corresponding weight.
 *
 * @schema PrometheusSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface PrometheusSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema PrometheusSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: PrometheusSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema PrometheusSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: PrometheusSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];

}

/**
 * Converts an object of type 'PrometheusSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj: PrometheusSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_PrometheusSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_PrometheusSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A null or empty node selector term matches no objects. The requirements of
 * them are ANDed.
 * The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
 *
 * @schema PrometheusSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface PrometheusSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema PrometheusSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: PrometheusSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema PrometheusSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: PrometheusSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];

}

/**
 * Converts an object of type 'PrometheusSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(obj: PrometheusSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_PrometheusSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_PrometheusSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `LabelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both MatchLabelKeys and LabelSelector.
   * Also, MatchLabelKeys cannot be set when LabelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `LabelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both MismatchLabelKeys and LabelSelector.
   * Also, MismatchLabelKeys cannot be set when LabelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'mismatchLabelKeys': obj.mismatchLabelKeys?.map(y => y),
    'namespaceSelector': toJson_PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `LabelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both MatchLabelKeys and LabelSelector.
   * Also, MatchLabelKeys cannot be set when LabelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `LabelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both MismatchLabelKeys and LabelSelector.
   * Also, MismatchLabelKeys cannot be set when LabelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'mismatchLabelKeys': obj.mismatchLabelKeys?.map(y => y),
    'namespaceSelector': toJson_PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Action to perform based on the regex matching.
 *
 *
 * `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0.
 * `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.
 *
 *
 * Default: "Replace"
 *
 * @schema PrometheusSpecAlertingAlertmanagersAlertRelabelingsAction
 */
export enum PrometheusSpecAlertingAlertmanagersAlertRelabelingsAction {
  /** replace */
  REPLACE = "replace",
  /** keep */
  KEEP = "keep",
  /** drop */
  DROP = "drop",
  /** hashmod */
  HASHMOD = "hashmod",
  /** labelmap */
  LABELMAP = "labelmap",
  /** labeldrop */
  LABELDROP = "labeldrop",
  /** labelkeep */
  LABELKEEP = "labelkeep",
  /** lowercase */
  LOWERCASE = "lowercase",
  /** uppercase */
  UPPERCASE = "uppercase",
  /** keepequal */
  KEEPEQUAL = "keepequal",
  /** dropequal */
  DROPEQUAL = "dropequal",
}

/**
 * Selects a key of a Secret in the namespace that contains the credentials for authentication.
 *
 * @schema PrometheusSpecAlertingAlertmanagersAuthorizationCredentials
 */
export interface PrometheusSpecAlertingAlertmanagersAuthorizationCredentials {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecAlertingAlertmanagersAuthorizationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecAlertingAlertmanagersAuthorizationCredentials#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecAlertingAlertmanagersAuthorizationCredentials#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecAlertingAlertmanagersAuthorizationCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAlertingAlertmanagersAuthorizationCredentials(obj: PrometheusSpecAlertingAlertmanagersAuthorizationCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `password` specifies a key of a Secret containing the password for
 * authentication.
 *
 * @schema PrometheusSpecAlertingAlertmanagersBasicAuthPassword
 */
export interface PrometheusSpecAlertingAlertmanagersBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecAlertingAlertmanagersBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecAlertingAlertmanagersBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecAlertingAlertmanagersBasicAuthPassword#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecAlertingAlertmanagersBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAlertingAlertmanagersBasicAuthPassword(obj: PrometheusSpecAlertingAlertmanagersBasicAuthPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `username` specifies a key of a Secret containing the username for
 * authentication.
 *
 * @schema PrometheusSpecAlertingAlertmanagersBasicAuthUsername
 */
export interface PrometheusSpecAlertingAlertmanagersBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecAlertingAlertmanagersBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecAlertingAlertmanagersBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecAlertingAlertmanagersBasicAuthUsername#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecAlertingAlertmanagersBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAlertingAlertmanagersBasicAuthUsername(obj: PrometheusSpecAlertingAlertmanagersBasicAuthUsername | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Action to perform based on the regex matching.
 *
 *
 * `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0.
 * `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.
 *
 *
 * Default: "Replace"
 *
 * @schema PrometheusSpecAlertingAlertmanagersRelabelingsAction
 */
export enum PrometheusSpecAlertingAlertmanagersRelabelingsAction {
  /** replace */
  REPLACE = "replace",
  /** keep */
  KEEP = "keep",
  /** drop */
  DROP = "drop",
  /** hashmod */
  HASHMOD = "hashmod",
  /** labelmap */
  LABELMAP = "labelmap",
  /** labeldrop */
  LABELDROP = "labeldrop",
  /** labelkeep */
  LABELKEEP = "labelkeep",
  /** lowercase */
  LOWERCASE = "lowercase",
  /** uppercase */
  UPPERCASE = "uppercase",
  /** keepequal */
  KEEPEQUAL = "keepequal",
  /** dropequal */
  DROPEQUAL = "dropequal",
}

/**
 * AccessKey is the AWS API key. If not specified, the environment variable
 * `AWS_ACCESS_KEY_ID` is used.
 *
 * @schema PrometheusSpecAlertingAlertmanagersSigv4AccessKey
 */
export interface PrometheusSpecAlertingAlertmanagersSigv4AccessKey {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecAlertingAlertmanagersSigv4AccessKey#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecAlertingAlertmanagersSigv4AccessKey#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecAlertingAlertmanagersSigv4AccessKey#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecAlertingAlertmanagersSigv4AccessKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAlertingAlertmanagersSigv4AccessKey(obj: PrometheusSpecAlertingAlertmanagersSigv4AccessKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKey is the AWS API secret. If not specified, the environment
 * variable `AWS_SECRET_ACCESS_KEY` is used.
 *
 * @schema PrometheusSpecAlertingAlertmanagersSigv4SecretKey
 */
export interface PrometheusSpecAlertingAlertmanagersSigv4SecretKey {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecAlertingAlertmanagersSigv4SecretKey#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecAlertingAlertmanagersSigv4SecretKey#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecAlertingAlertmanagersSigv4SecretKey#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecAlertingAlertmanagersSigv4SecretKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAlertingAlertmanagersSigv4SecretKey(obj: PrometheusSpecAlertingAlertmanagersSigv4SecretKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Certificate authority used when verifying server certificates.
 *
 * @schema PrometheusSpecAlertingAlertmanagersTlsConfigCa
 */
export interface PrometheusSpecAlertingAlertmanagersTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema PrometheusSpecAlertingAlertmanagersTlsConfigCa#configMap
   */
  readonly configMap?: PrometheusSpecAlertingAlertmanagersTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema PrometheusSpecAlertingAlertmanagersTlsConfigCa#secret
   */
  readonly secret?: PrometheusSpecAlertingAlertmanagersTlsConfigCaSecret;

}

/**
 * Converts an object of type 'PrometheusSpecAlertingAlertmanagersTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAlertingAlertmanagersTlsConfigCa(obj: PrometheusSpecAlertingAlertmanagersTlsConfigCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_PrometheusSpecAlertingAlertmanagersTlsConfigCaConfigMap(obj.configMap),
    'secret': toJson_PrometheusSpecAlertingAlertmanagersTlsConfigCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Client certificate to present when doing client-authentication.
 *
 * @schema PrometheusSpecAlertingAlertmanagersTlsConfigCert
 */
export interface PrometheusSpecAlertingAlertmanagersTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema PrometheusSpecAlertingAlertmanagersTlsConfigCert#configMap
   */
  readonly configMap?: PrometheusSpecAlertingAlertmanagersTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema PrometheusSpecAlertingAlertmanagersTlsConfigCert#secret
   */
  readonly secret?: PrometheusSpecAlertingAlertmanagersTlsConfigCertSecret;

}

/**
 * Converts an object of type 'PrometheusSpecAlertingAlertmanagersTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAlertingAlertmanagersTlsConfigCert(obj: PrometheusSpecAlertingAlertmanagersTlsConfigCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_PrometheusSpecAlertingAlertmanagersTlsConfigCertConfigMap(obj.configMap),
    'secret': toJson_PrometheusSpecAlertingAlertmanagersTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema PrometheusSpecAlertingAlertmanagersTlsConfigKeySecret
 */
export interface PrometheusSpecAlertingAlertmanagersTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecAlertingAlertmanagersTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecAlertingAlertmanagersTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecAlertingAlertmanagersTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecAlertingAlertmanagersTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAlertingAlertmanagersTlsConfigKeySecret(obj: PrometheusSpecAlertingAlertmanagersTlsConfigKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema PrometheusSpecApiserverConfigTlsConfigCaConfigMap
 */
export interface PrometheusSpecApiserverConfigTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema PrometheusSpecApiserverConfigTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecApiserverConfigTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema PrometheusSpecApiserverConfigTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecApiserverConfigTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecApiserverConfigTlsConfigCaConfigMap(obj: PrometheusSpecApiserverConfigTlsConfigCaConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema PrometheusSpecApiserverConfigTlsConfigCaSecret
 */
export interface PrometheusSpecApiserverConfigTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecApiserverConfigTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecApiserverConfigTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecApiserverConfigTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecApiserverConfigTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecApiserverConfigTlsConfigCaSecret(obj: PrometheusSpecApiserverConfigTlsConfigCaSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema PrometheusSpecApiserverConfigTlsConfigCertConfigMap
 */
export interface PrometheusSpecApiserverConfigTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema PrometheusSpecApiserverConfigTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecApiserverConfigTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema PrometheusSpecApiserverConfigTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecApiserverConfigTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecApiserverConfigTlsConfigCertConfigMap(obj: PrometheusSpecApiserverConfigTlsConfigCertConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema PrometheusSpecApiserverConfigTlsConfigCertSecret
 */
export interface PrometheusSpecApiserverConfigTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecApiserverConfigTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecApiserverConfigTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecApiserverConfigTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecApiserverConfigTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecApiserverConfigTlsConfigCertSecret(obj: PrometheusSpecApiserverConfigTlsConfigCertSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a ConfigMap.
 *
 * @schema PrometheusSpecContainersEnvValueFromConfigMapKeyRef
 */
export interface PrometheusSpecContainersEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema PrometheusSpecContainersEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecContainersEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema PrometheusSpecContainersEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecContainersEnvValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersEnvValueFromConfigMapKeyRef(obj: PrometheusSpecContainersEnvValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
 * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema PrometheusSpecContainersEnvValueFromFieldRef
 */
export interface PrometheusSpecContainersEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema PrometheusSpecContainersEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema PrometheusSpecContainersEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'PrometheusSpecContainersEnvValueFromFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersEnvValueFromFieldRef(obj: PrometheusSpecContainersEnvValueFromFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema PrometheusSpecContainersEnvValueFromResourceFieldRef
 */
export interface PrometheusSpecContainersEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema PrometheusSpecContainersEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema PrometheusSpecContainersEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: PrometheusSpecContainersEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema PrometheusSpecContainersEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'PrometheusSpecContainersEnvValueFromResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersEnvValueFromResourceFieldRef(obj: PrometheusSpecContainersEnvValueFromResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema PrometheusSpecContainersEnvValueFromSecretKeyRef
 */
export interface PrometheusSpecContainersEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecContainersEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecContainersEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecContainersEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecContainersEnvValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersEnvValueFromSecretKeyRef(obj: PrometheusSpecContainersEnvValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema PrometheusSpecContainersLifecyclePostStartExec
 */
export interface PrometheusSpecContainersLifecyclePostStartExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema PrometheusSpecContainersLifecyclePostStartExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'PrometheusSpecContainersLifecyclePostStartExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersLifecyclePostStartExec(obj: PrometheusSpecContainersLifecyclePostStartExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema PrometheusSpecContainersLifecyclePostStartHttpGet
 */
export interface PrometheusSpecContainersLifecyclePostStartHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema PrometheusSpecContainersLifecyclePostStartHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema PrometheusSpecContainersLifecyclePostStartHttpGet#httpHeaders
   */
  readonly httpHeaders?: PrometheusSpecContainersLifecyclePostStartHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema PrometheusSpecContainersLifecyclePostStartHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema PrometheusSpecContainersLifecyclePostStartHttpGet#port
   */
  readonly port: PrometheusSpecContainersLifecyclePostStartHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema PrometheusSpecContainersLifecyclePostStartHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'PrometheusSpecContainersLifecyclePostStartHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersLifecyclePostStartHttpGet(obj: PrometheusSpecContainersLifecyclePostStartHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_PrometheusSpecContainersLifecyclePostStartHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Sleep represents the duration that the container should sleep before being terminated.
 *
 * @schema PrometheusSpecContainersLifecyclePostStartSleep
 */
export interface PrometheusSpecContainersLifecyclePostStartSleep {
  /**
   * Seconds is the number of seconds to sleep.
   *
   * @schema PrometheusSpecContainersLifecyclePostStartSleep#seconds
   */
  readonly seconds: number;

}

/**
 * Converts an object of type 'PrometheusSpecContainersLifecyclePostStartSleep' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersLifecyclePostStartSleep(obj: PrometheusSpecContainersLifecyclePostStartSleep | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
 * for the backward compatibility. There are no validation of this field and
 * lifecycle hooks will fail in runtime when tcp handler is specified.
 *
 * @schema PrometheusSpecContainersLifecyclePostStartTcpSocket
 */
export interface PrometheusSpecContainersLifecyclePostStartTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema PrometheusSpecContainersLifecyclePostStartTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema PrometheusSpecContainersLifecyclePostStartTcpSocket#port
   */
  readonly port: PrometheusSpecContainersLifecyclePostStartTcpSocketPort;

}

/**
 * Converts an object of type 'PrometheusSpecContainersLifecyclePostStartTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersLifecyclePostStartTcpSocket(obj: PrometheusSpecContainersLifecyclePostStartTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema PrometheusSpecContainersLifecyclePreStopExec
 */
export interface PrometheusSpecContainersLifecyclePreStopExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema PrometheusSpecContainersLifecyclePreStopExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'PrometheusSpecContainersLifecyclePreStopExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersLifecyclePreStopExec(obj: PrometheusSpecContainersLifecyclePreStopExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema PrometheusSpecContainersLifecyclePreStopHttpGet
 */
export interface PrometheusSpecContainersLifecyclePreStopHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema PrometheusSpecContainersLifecyclePreStopHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema PrometheusSpecContainersLifecyclePreStopHttpGet#httpHeaders
   */
  readonly httpHeaders?: PrometheusSpecContainersLifecyclePreStopHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema PrometheusSpecContainersLifecyclePreStopHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema PrometheusSpecContainersLifecyclePreStopHttpGet#port
   */
  readonly port: PrometheusSpecContainersLifecyclePreStopHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema PrometheusSpecContainersLifecyclePreStopHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'PrometheusSpecContainersLifecyclePreStopHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersLifecyclePreStopHttpGet(obj: PrometheusSpecContainersLifecyclePreStopHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_PrometheusSpecContainersLifecyclePreStopHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Sleep represents the duration that the container should sleep before being terminated.
 *
 * @schema PrometheusSpecContainersLifecyclePreStopSleep
 */
export interface PrometheusSpecContainersLifecyclePreStopSleep {
  /**
   * Seconds is the number of seconds to sleep.
   *
   * @schema PrometheusSpecContainersLifecyclePreStopSleep#seconds
   */
  readonly seconds: number;

}

/**
 * Converts an object of type 'PrometheusSpecContainersLifecyclePreStopSleep' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersLifecyclePreStopSleep(obj: PrometheusSpecContainersLifecyclePreStopSleep | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
 * for the backward compatibility. There are no validation of this field and
 * lifecycle hooks will fail in runtime when tcp handler is specified.
 *
 * @schema PrometheusSpecContainersLifecyclePreStopTcpSocket
 */
export interface PrometheusSpecContainersLifecyclePreStopTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema PrometheusSpecContainersLifecyclePreStopTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema PrometheusSpecContainersLifecyclePreStopTcpSocket#port
   */
  readonly port: PrometheusSpecContainersLifecyclePreStopTcpSocketPort;

}

/**
 * Converts an object of type 'PrometheusSpecContainersLifecyclePreStopTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersLifecyclePreStopTcpSocket(obj: PrometheusSpecContainersLifecyclePreStopTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema PrometheusSpecContainersLivenessProbeHttpGetHttpHeaders
 */
export interface PrometheusSpecContainersLivenessProbeHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema PrometheusSpecContainersLivenessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema PrometheusSpecContainersLivenessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'PrometheusSpecContainersLivenessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersLivenessProbeHttpGetHttpHeaders(obj: PrometheusSpecContainersLivenessProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema PrometheusSpecContainersLivenessProbeHttpGetPort
 */
export class PrometheusSpecContainersLivenessProbeHttpGetPort {
  public static fromNumber(value: number): PrometheusSpecContainersLivenessProbeHttpGetPort {
    return new PrometheusSpecContainersLivenessProbeHttpGetPort(value);
  }
  public static fromString(value: string): PrometheusSpecContainersLivenessProbeHttpGetPort {
    return new PrometheusSpecContainersLivenessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema PrometheusSpecContainersLivenessProbeTcpSocketPort
 */
export class PrometheusSpecContainersLivenessProbeTcpSocketPort {
  public static fromNumber(value: number): PrometheusSpecContainersLivenessProbeTcpSocketPort {
    return new PrometheusSpecContainersLivenessProbeTcpSocketPort(value);
  }
  public static fromString(value: string): PrometheusSpecContainersLivenessProbeTcpSocketPort {
    return new PrometheusSpecContainersLivenessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema PrometheusSpecContainersReadinessProbeHttpGetHttpHeaders
 */
export interface PrometheusSpecContainersReadinessProbeHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema PrometheusSpecContainersReadinessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema PrometheusSpecContainersReadinessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'PrometheusSpecContainersReadinessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersReadinessProbeHttpGetHttpHeaders(obj: PrometheusSpecContainersReadinessProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema PrometheusSpecContainersReadinessProbeHttpGetPort
 */
export class PrometheusSpecContainersReadinessProbeHttpGetPort {
  public static fromNumber(value: number): PrometheusSpecContainersReadinessProbeHttpGetPort {
    return new PrometheusSpecContainersReadinessProbeHttpGetPort(value);
  }
  public static fromString(value: string): PrometheusSpecContainersReadinessProbeHttpGetPort {
    return new PrometheusSpecContainersReadinessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema PrometheusSpecContainersReadinessProbeTcpSocketPort
 */
export class PrometheusSpecContainersReadinessProbeTcpSocketPort {
  public static fromNumber(value: number): PrometheusSpecContainersReadinessProbeTcpSocketPort {
    return new PrometheusSpecContainersReadinessProbeTcpSocketPort(value);
  }
  public static fromString(value: string): PrometheusSpecContainersReadinessProbeTcpSocketPort {
    return new PrometheusSpecContainersReadinessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema PrometheusSpecContainersStartupProbeHttpGetHttpHeaders
 */
export interface PrometheusSpecContainersStartupProbeHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema PrometheusSpecContainersStartupProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema PrometheusSpecContainersStartupProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'PrometheusSpecContainersStartupProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersStartupProbeHttpGetHttpHeaders(obj: PrometheusSpecContainersStartupProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema PrometheusSpecContainersStartupProbeHttpGetPort
 */
export class PrometheusSpecContainersStartupProbeHttpGetPort {
  public static fromNumber(value: number): PrometheusSpecContainersStartupProbeHttpGetPort {
    return new PrometheusSpecContainersStartupProbeHttpGetPort(value);
  }
  public static fromString(value: string): PrometheusSpecContainersStartupProbeHttpGetPort {
    return new PrometheusSpecContainersStartupProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema PrometheusSpecContainersStartupProbeTcpSocketPort
 */
export class PrometheusSpecContainersStartupProbeTcpSocketPort {
  public static fromNumber(value: number): PrometheusSpecContainersStartupProbeTcpSocketPort {
    return new PrometheusSpecContainersStartupProbeTcpSocketPort(value);
  }
  public static fromString(value: string): PrometheusSpecContainersStartupProbeTcpSocketPort {
    return new PrometheusSpecContainersStartupProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Selects a key of a ConfigMap.
 *
 * @schema PrometheusSpecInitContainersEnvValueFromConfigMapKeyRef
 */
export interface PrometheusSpecInitContainersEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema PrometheusSpecInitContainersEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecInitContainersEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema PrometheusSpecInitContainersEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecInitContainersEnvValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersEnvValueFromConfigMapKeyRef(obj: PrometheusSpecInitContainersEnvValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
 * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema PrometheusSpecInitContainersEnvValueFromFieldRef
 */
export interface PrometheusSpecInitContainersEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema PrometheusSpecInitContainersEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema PrometheusSpecInitContainersEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'PrometheusSpecInitContainersEnvValueFromFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersEnvValueFromFieldRef(obj: PrometheusSpecInitContainersEnvValueFromFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema PrometheusSpecInitContainersEnvValueFromResourceFieldRef
 */
export interface PrometheusSpecInitContainersEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema PrometheusSpecInitContainersEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema PrometheusSpecInitContainersEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: PrometheusSpecInitContainersEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema PrometheusSpecInitContainersEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'PrometheusSpecInitContainersEnvValueFromResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersEnvValueFromResourceFieldRef(obj: PrometheusSpecInitContainersEnvValueFromResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema PrometheusSpecInitContainersEnvValueFromSecretKeyRef
 */
export interface PrometheusSpecInitContainersEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecInitContainersEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecInitContainersEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecInitContainersEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecInitContainersEnvValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersEnvValueFromSecretKeyRef(obj: PrometheusSpecInitContainersEnvValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema PrometheusSpecInitContainersLifecyclePostStartExec
 */
export interface PrometheusSpecInitContainersLifecyclePostStartExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema PrometheusSpecInitContainersLifecyclePostStartExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'PrometheusSpecInitContainersLifecyclePostStartExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersLifecyclePostStartExec(obj: PrometheusSpecInitContainersLifecyclePostStartExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema PrometheusSpecInitContainersLifecyclePostStartHttpGet
 */
export interface PrometheusSpecInitContainersLifecyclePostStartHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema PrometheusSpecInitContainersLifecyclePostStartHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema PrometheusSpecInitContainersLifecyclePostStartHttpGet#httpHeaders
   */
  readonly httpHeaders?: PrometheusSpecInitContainersLifecyclePostStartHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema PrometheusSpecInitContainersLifecyclePostStartHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema PrometheusSpecInitContainersLifecyclePostStartHttpGet#port
   */
  readonly port: PrometheusSpecInitContainersLifecyclePostStartHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema PrometheusSpecInitContainersLifecyclePostStartHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'PrometheusSpecInitContainersLifecyclePostStartHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersLifecyclePostStartHttpGet(obj: PrometheusSpecInitContainersLifecyclePostStartHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_PrometheusSpecInitContainersLifecyclePostStartHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Sleep represents the duration that the container should sleep before being terminated.
 *
 * @schema PrometheusSpecInitContainersLifecyclePostStartSleep
 */
export interface PrometheusSpecInitContainersLifecyclePostStartSleep {
  /**
   * Seconds is the number of seconds to sleep.
   *
   * @schema PrometheusSpecInitContainersLifecyclePostStartSleep#seconds
   */
  readonly seconds: number;

}

/**
 * Converts an object of type 'PrometheusSpecInitContainersLifecyclePostStartSleep' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersLifecyclePostStartSleep(obj: PrometheusSpecInitContainersLifecyclePostStartSleep | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
 * for the backward compatibility. There are no validation of this field and
 * lifecycle hooks will fail in runtime when tcp handler is specified.
 *
 * @schema PrometheusSpecInitContainersLifecyclePostStartTcpSocket
 */
export interface PrometheusSpecInitContainersLifecyclePostStartTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema PrometheusSpecInitContainersLifecyclePostStartTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema PrometheusSpecInitContainersLifecyclePostStartTcpSocket#port
   */
  readonly port: PrometheusSpecInitContainersLifecyclePostStartTcpSocketPort;

}

/**
 * Converts an object of type 'PrometheusSpecInitContainersLifecyclePostStartTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersLifecyclePostStartTcpSocket(obj: PrometheusSpecInitContainersLifecyclePostStartTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema PrometheusSpecInitContainersLifecyclePreStopExec
 */
export interface PrometheusSpecInitContainersLifecyclePreStopExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema PrometheusSpecInitContainersLifecyclePreStopExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'PrometheusSpecInitContainersLifecyclePreStopExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersLifecyclePreStopExec(obj: PrometheusSpecInitContainersLifecyclePreStopExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema PrometheusSpecInitContainersLifecyclePreStopHttpGet
 */
export interface PrometheusSpecInitContainersLifecyclePreStopHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema PrometheusSpecInitContainersLifecyclePreStopHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema PrometheusSpecInitContainersLifecyclePreStopHttpGet#httpHeaders
   */
  readonly httpHeaders?: PrometheusSpecInitContainersLifecyclePreStopHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema PrometheusSpecInitContainersLifecyclePreStopHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema PrometheusSpecInitContainersLifecyclePreStopHttpGet#port
   */
  readonly port: PrometheusSpecInitContainersLifecyclePreStopHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema PrometheusSpecInitContainersLifecyclePreStopHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'PrometheusSpecInitContainersLifecyclePreStopHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersLifecyclePreStopHttpGet(obj: PrometheusSpecInitContainersLifecyclePreStopHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_PrometheusSpecInitContainersLifecyclePreStopHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Sleep represents the duration that the container should sleep before being terminated.
 *
 * @schema PrometheusSpecInitContainersLifecyclePreStopSleep
 */
export interface PrometheusSpecInitContainersLifecyclePreStopSleep {
  /**
   * Seconds is the number of seconds to sleep.
   *
   * @schema PrometheusSpecInitContainersLifecyclePreStopSleep#seconds
   */
  readonly seconds: number;

}

/**
 * Converts an object of type 'PrometheusSpecInitContainersLifecyclePreStopSleep' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersLifecyclePreStopSleep(obj: PrometheusSpecInitContainersLifecyclePreStopSleep | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
 * for the backward compatibility. There are no validation of this field and
 * lifecycle hooks will fail in runtime when tcp handler is specified.
 *
 * @schema PrometheusSpecInitContainersLifecyclePreStopTcpSocket
 */
export interface PrometheusSpecInitContainersLifecyclePreStopTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema PrometheusSpecInitContainersLifecyclePreStopTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema PrometheusSpecInitContainersLifecyclePreStopTcpSocket#port
   */
  readonly port: PrometheusSpecInitContainersLifecyclePreStopTcpSocketPort;

}

/**
 * Converts an object of type 'PrometheusSpecInitContainersLifecyclePreStopTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersLifecyclePreStopTcpSocket(obj: PrometheusSpecInitContainersLifecyclePreStopTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema PrometheusSpecInitContainersLivenessProbeHttpGetHttpHeaders
 */
export interface PrometheusSpecInitContainersLivenessProbeHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema PrometheusSpecInitContainersLivenessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema PrometheusSpecInitContainersLivenessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'PrometheusSpecInitContainersLivenessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersLivenessProbeHttpGetHttpHeaders(obj: PrometheusSpecInitContainersLivenessProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema PrometheusSpecInitContainersLivenessProbeHttpGetPort
 */
export class PrometheusSpecInitContainersLivenessProbeHttpGetPort {
  public static fromNumber(value: number): PrometheusSpecInitContainersLivenessProbeHttpGetPort {
    return new PrometheusSpecInitContainersLivenessProbeHttpGetPort(value);
  }
  public static fromString(value: string): PrometheusSpecInitContainersLivenessProbeHttpGetPort {
    return new PrometheusSpecInitContainersLivenessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema PrometheusSpecInitContainersLivenessProbeTcpSocketPort
 */
export class PrometheusSpecInitContainersLivenessProbeTcpSocketPort {
  public static fromNumber(value: number): PrometheusSpecInitContainersLivenessProbeTcpSocketPort {
    return new PrometheusSpecInitContainersLivenessProbeTcpSocketPort(value);
  }
  public static fromString(value: string): PrometheusSpecInitContainersLivenessProbeTcpSocketPort {
    return new PrometheusSpecInitContainersLivenessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema PrometheusSpecInitContainersReadinessProbeHttpGetHttpHeaders
 */
export interface PrometheusSpecInitContainersReadinessProbeHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema PrometheusSpecInitContainersReadinessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema PrometheusSpecInitContainersReadinessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'PrometheusSpecInitContainersReadinessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersReadinessProbeHttpGetHttpHeaders(obj: PrometheusSpecInitContainersReadinessProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema PrometheusSpecInitContainersReadinessProbeHttpGetPort
 */
export class PrometheusSpecInitContainersReadinessProbeHttpGetPort {
  public static fromNumber(value: number): PrometheusSpecInitContainersReadinessProbeHttpGetPort {
    return new PrometheusSpecInitContainersReadinessProbeHttpGetPort(value);
  }
  public static fromString(value: string): PrometheusSpecInitContainersReadinessProbeHttpGetPort {
    return new PrometheusSpecInitContainersReadinessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema PrometheusSpecInitContainersReadinessProbeTcpSocketPort
 */
export class PrometheusSpecInitContainersReadinessProbeTcpSocketPort {
  public static fromNumber(value: number): PrometheusSpecInitContainersReadinessProbeTcpSocketPort {
    return new PrometheusSpecInitContainersReadinessProbeTcpSocketPort(value);
  }
  public static fromString(value: string): PrometheusSpecInitContainersReadinessProbeTcpSocketPort {
    return new PrometheusSpecInitContainersReadinessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema PrometheusSpecInitContainersStartupProbeHttpGetHttpHeaders
 */
export interface PrometheusSpecInitContainersStartupProbeHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema PrometheusSpecInitContainersStartupProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema PrometheusSpecInitContainersStartupProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'PrometheusSpecInitContainersStartupProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersStartupProbeHttpGetHttpHeaders(obj: PrometheusSpecInitContainersStartupProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema PrometheusSpecInitContainersStartupProbeHttpGetPort
 */
export class PrometheusSpecInitContainersStartupProbeHttpGetPort {
  public static fromNumber(value: number): PrometheusSpecInitContainersStartupProbeHttpGetPort {
    return new PrometheusSpecInitContainersStartupProbeHttpGetPort(value);
  }
  public static fromString(value: string): PrometheusSpecInitContainersStartupProbeHttpGetPort {
    return new PrometheusSpecInitContainersStartupProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema PrometheusSpecInitContainersStartupProbeTcpSocketPort
 */
export class PrometheusSpecInitContainersStartupProbeTcpSocketPort {
  public static fromNumber(value: number): PrometheusSpecInitContainersStartupProbeTcpSocketPort {
    return new PrometheusSpecInitContainersStartupProbeTcpSocketPort(value);
  }
  public static fromString(value: string): PrometheusSpecInitContainersStartupProbeTcpSocketPort {
    return new PrometheusSpecInitContainersStartupProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema PrometheusSpecRemoteReadOauth2ClientIdConfigMap
 */
export interface PrometheusSpecRemoteReadOauth2ClientIdConfigMap {
  /**
   * The key to select.
   *
   * @schema PrometheusSpecRemoteReadOauth2ClientIdConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecRemoteReadOauth2ClientIdConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema PrometheusSpecRemoteReadOauth2ClientIdConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecRemoteReadOauth2ClientIdConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteReadOauth2ClientIdConfigMap(obj: PrometheusSpecRemoteReadOauth2ClientIdConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema PrometheusSpecRemoteReadOauth2ClientIdSecret
 */
export interface PrometheusSpecRemoteReadOauth2ClientIdSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecRemoteReadOauth2ClientIdSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecRemoteReadOauth2ClientIdSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecRemoteReadOauth2ClientIdSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecRemoteReadOauth2ClientIdSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteReadOauth2ClientIdSecret(obj: PrometheusSpecRemoteReadOauth2ClientIdSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema PrometheusSpecRemoteReadTlsConfigCaConfigMap
 */
export interface PrometheusSpecRemoteReadTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema PrometheusSpecRemoteReadTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecRemoteReadTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema PrometheusSpecRemoteReadTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecRemoteReadTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteReadTlsConfigCaConfigMap(obj: PrometheusSpecRemoteReadTlsConfigCaConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema PrometheusSpecRemoteReadTlsConfigCaSecret
 */
export interface PrometheusSpecRemoteReadTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecRemoteReadTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecRemoteReadTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecRemoteReadTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecRemoteReadTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteReadTlsConfigCaSecret(obj: PrometheusSpecRemoteReadTlsConfigCaSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema PrometheusSpecRemoteReadTlsConfigCertConfigMap
 */
export interface PrometheusSpecRemoteReadTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema PrometheusSpecRemoteReadTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecRemoteReadTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema PrometheusSpecRemoteReadTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecRemoteReadTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteReadTlsConfigCertConfigMap(obj: PrometheusSpecRemoteReadTlsConfigCertConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema PrometheusSpecRemoteReadTlsConfigCertSecret
 */
export interface PrometheusSpecRemoteReadTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecRemoteReadTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecRemoteReadTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecRemoteReadTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecRemoteReadTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteReadTlsConfigCertSecret(obj: PrometheusSpecRemoteReadTlsConfigCertSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `clientSecret` specifies a key of a Secret containing the client secret of the Azure Active Directory application that is being used to authenticate.
 *
 * @schema PrometheusSpecRemoteWriteAzureAdOauthClientSecret
 */
export interface PrometheusSpecRemoteWriteAzureAdOauthClientSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecRemoteWriteAzureAdOauthClientSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecRemoteWriteAzureAdOauthClientSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecRemoteWriteAzureAdOauthClientSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecRemoteWriteAzureAdOauthClientSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteWriteAzureAdOauthClientSecret(obj: PrometheusSpecRemoteWriteAzureAdOauthClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema PrometheusSpecRemoteWriteOauth2ClientIdConfigMap
 */
export interface PrometheusSpecRemoteWriteOauth2ClientIdConfigMap {
  /**
   * The key to select.
   *
   * @schema PrometheusSpecRemoteWriteOauth2ClientIdConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecRemoteWriteOauth2ClientIdConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema PrometheusSpecRemoteWriteOauth2ClientIdConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecRemoteWriteOauth2ClientIdConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteWriteOauth2ClientIdConfigMap(obj: PrometheusSpecRemoteWriteOauth2ClientIdConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema PrometheusSpecRemoteWriteOauth2ClientIdSecret
 */
export interface PrometheusSpecRemoteWriteOauth2ClientIdSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecRemoteWriteOauth2ClientIdSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecRemoteWriteOauth2ClientIdSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecRemoteWriteOauth2ClientIdSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecRemoteWriteOauth2ClientIdSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteWriteOauth2ClientIdSecret(obj: PrometheusSpecRemoteWriteOauth2ClientIdSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema PrometheusSpecRemoteWriteTlsConfigCaConfigMap
 */
export interface PrometheusSpecRemoteWriteTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema PrometheusSpecRemoteWriteTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecRemoteWriteTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema PrometheusSpecRemoteWriteTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecRemoteWriteTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteWriteTlsConfigCaConfigMap(obj: PrometheusSpecRemoteWriteTlsConfigCaConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema PrometheusSpecRemoteWriteTlsConfigCaSecret
 */
export interface PrometheusSpecRemoteWriteTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecRemoteWriteTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecRemoteWriteTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecRemoteWriteTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecRemoteWriteTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteWriteTlsConfigCaSecret(obj: PrometheusSpecRemoteWriteTlsConfigCaSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema PrometheusSpecRemoteWriteTlsConfigCertConfigMap
 */
export interface PrometheusSpecRemoteWriteTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema PrometheusSpecRemoteWriteTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecRemoteWriteTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema PrometheusSpecRemoteWriteTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecRemoteWriteTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteWriteTlsConfigCertConfigMap(obj: PrometheusSpecRemoteWriteTlsConfigCertConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema PrometheusSpecRemoteWriteTlsConfigCertSecret
 */
export interface PrometheusSpecRemoteWriteTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecRemoteWriteTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecRemoteWriteTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecRemoteWriteTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecRemoteWriteTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteWriteTlsConfigCertSecret(obj: PrometheusSpecRemoteWriteTlsConfigCertSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema PrometheusSpecScrapeClassesTlsConfigCaConfigMap
 */
export interface PrometheusSpecScrapeClassesTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema PrometheusSpecScrapeClassesTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecScrapeClassesTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema PrometheusSpecScrapeClassesTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecScrapeClassesTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecScrapeClassesTlsConfigCaConfigMap(obj: PrometheusSpecScrapeClassesTlsConfigCaConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema PrometheusSpecScrapeClassesTlsConfigCaSecret
 */
export interface PrometheusSpecScrapeClassesTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecScrapeClassesTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecScrapeClassesTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecScrapeClassesTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecScrapeClassesTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecScrapeClassesTlsConfigCaSecret(obj: PrometheusSpecScrapeClassesTlsConfigCaSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema PrometheusSpecScrapeClassesTlsConfigCertConfigMap
 */
export interface PrometheusSpecScrapeClassesTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema PrometheusSpecScrapeClassesTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecScrapeClassesTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema PrometheusSpecScrapeClassesTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecScrapeClassesTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecScrapeClassesTlsConfigCertConfigMap(obj: PrometheusSpecScrapeClassesTlsConfigCertConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema PrometheusSpecScrapeClassesTlsConfigCertSecret
 */
export interface PrometheusSpecScrapeClassesTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecScrapeClassesTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecScrapeClassesTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecScrapeClassesTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecScrapeClassesTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecScrapeClassesTlsConfigCertSecret(obj: PrometheusSpecScrapeClassesTlsConfigCertSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The specification for the PersistentVolumeClaim. The entire content is
 * copied unchanged into the PVC that gets created from this
 * template. The same fields as in a PersistentVolumeClaim
 * are also valid here.
 *
 * @schema PrometheusSpecStorageEphemeralVolumeClaimTemplateSpec
 */
export interface PrometheusSpecStorageEphemeralVolumeClaimTemplateSpec {
  /**
   * accessModes contains the desired access modes the volume should have.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema PrometheusSpecStorageEphemeralVolumeClaimTemplateSpec#accessModes
   */
  readonly accessModes?: string[];

  /**
   * dataSource field can be used to specify either:
   * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
   * * An existing PVC (PersistentVolumeClaim)
   * If the provisioner or an external controller can support the specified data source,
   * it will create a new volume based on the contents of the specified data source.
   * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
   * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
   * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
   *
   * @schema PrometheusSpecStorageEphemeralVolumeClaimTemplateSpec#dataSource
   */
  readonly dataSource?: PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecDataSource;

  /**
   * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
   * volume is desired. This may be any object from a non-empty API group (non
   * core object) or a PersistentVolumeClaim object.
   * When this field is specified, volume binding will only succeed if the type of
   * the specified object matches some installed volume populator or dynamic
   * provisioner.
   * This field will replace the functionality of the dataSource field and as such
   * if both fields are non-empty, they must have the same value. For backwards
   * compatibility, when namespace isn't specified in dataSourceRef,
   * both fields (dataSource and dataSourceRef) will be set to the same
   * value automatically if one of them is empty and the other is non-empty.
   * When namespace is specified in dataSourceRef,
   * dataSource isn't set to the same value and must be empty.
   * There are three important differences between dataSource and dataSourceRef:
   * * While dataSource only allows two specific types of objects, dataSourceRef
   * allows any non-core object, as well as PersistentVolumeClaim objects.
   * * While dataSource ignores disallowed values (dropping them), dataSourceRef
   * preserves all values, and generates an error if a disallowed value is
   * specified.
   * * While dataSource only allows local objects, dataSourceRef allows objects
   * in any namespaces.
   * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
   * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema PrometheusSpecStorageEphemeralVolumeClaimTemplateSpec#dataSourceRef
   */
  readonly dataSourceRef?: PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecDataSourceRef;

  /**
   * resources represents the minimum resources the volume should have.
   * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
   * that are lower than previous value but must still be higher than capacity recorded in the
   * status field of the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
   *
   * @schema PrometheusSpecStorageEphemeralVolumeClaimTemplateSpec#resources
   */
  readonly resources?: PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecResources;

  /**
   * selector is a label query over volumes to consider for binding.
   *
   * @schema PrometheusSpecStorageEphemeralVolumeClaimTemplateSpec#selector
   */
  readonly selector?: PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecSelector;

  /**
   * storageClassName is the name of the StorageClass required by the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   *
   * @schema PrometheusSpecStorageEphemeralVolumeClaimTemplateSpec#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
   * If specified, the CSI driver will create or update the volume with the attributes defined
   * in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
   * it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
   * will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
   * If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
   * will be set by the persistentvolume controller if it exists.
   * If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
   * set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
   * exists.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#volumeattributesclass
   * (Alpha) Using this field requires the VolumeAttributesClass feature gate to be enabled.
   *
   * @schema PrometheusSpecStorageEphemeralVolumeClaimTemplateSpec#volumeAttributesClassName
   */
  readonly volumeAttributesClassName?: string;

  /**
   * volumeMode defines what type of volume is required by the claim.
   * Value of Filesystem is implied when not included in claim spec.
   *
   * @schema PrometheusSpecStorageEphemeralVolumeClaimTemplateSpec#volumeMode
   */
  readonly volumeMode?: string;

  /**
   * volumeName is the binding reference to the PersistentVolume backing this claim.
   *
   * @schema PrometheusSpecStorageEphemeralVolumeClaimTemplateSpec#volumeName
   */
  readonly volumeName?: string;

}

/**
 * Converts an object of type 'PrometheusSpecStorageEphemeralVolumeClaimTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecStorageEphemeralVolumeClaimTemplateSpec(obj: PrometheusSpecStorageEphemeralVolumeClaimTemplateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessModes': obj.accessModes?.map(y => y),
    'dataSource': toJson_PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecDataSource(obj.dataSource),
    'dataSourceRef': toJson_PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecDataSourceRef(obj.dataSourceRef),
    'resources': toJson_PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecResources(obj.resources),
    'selector': toJson_PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecSelector(obj.selector),
    'storageClassName': obj.storageClassName,
    'volumeAttributesClassName': obj.volumeAttributesClassName,
    'volumeMode': obj.volumeMode,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * dataSource field can be used to specify either:
 * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
 * * An existing PVC (PersistentVolumeClaim)
 * If the provisioner or an external controller can support the specified data source,
 * it will create a new volume based on the contents of the specified data source.
 * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
 * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
 * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
 *
 * @schema PrometheusSpecStorageVolumeClaimTemplateSpecDataSource
 */
export interface PrometheusSpecStorageVolumeClaimTemplateSpecDataSource {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateSpecDataSource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateSpecDataSource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateSpecDataSource#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'PrometheusSpecStorageVolumeClaimTemplateSpecDataSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecStorageVolumeClaimTemplateSpecDataSource(obj: PrometheusSpecStorageVolumeClaimTemplateSpecDataSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
 * volume is desired. This may be any object from a non-empty API group (non
 * core object) or a PersistentVolumeClaim object.
 * When this field is specified, volume binding will only succeed if the type of
 * the specified object matches some installed volume populator or dynamic
 * provisioner.
 * This field will replace the functionality of the dataSource field and as such
 * if both fields are non-empty, they must have the same value. For backwards
 * compatibility, when namespace isn't specified in dataSourceRef,
 * both fields (dataSource and dataSourceRef) will be set to the same
 * value automatically if one of them is empty and the other is non-empty.
 * When namespace is specified in dataSourceRef,
 * dataSource isn't set to the same value and must be empty.
 * There are three important differences between dataSource and dataSourceRef:
 * * While dataSource only allows two specific types of objects, dataSourceRef
 * allows any non-core object, as well as PersistentVolumeClaim objects.
 * * While dataSource ignores disallowed values (dropping them), dataSourceRef
 * preserves all values, and generates an error if a disallowed value is
 * specified.
 * * While dataSource only allows local objects, dataSourceRef allows objects
 * in any namespaces.
 * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
 * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
 *
 * @schema PrometheusSpecStorageVolumeClaimTemplateSpecDataSourceRef
 */
export interface PrometheusSpecStorageVolumeClaimTemplateSpecDataSourceRef {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateSpecDataSourceRef#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateSpecDataSourceRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateSpecDataSourceRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of resource being referenced
   * Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
   * (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateSpecDataSourceRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'PrometheusSpecStorageVolumeClaimTemplateSpecDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecStorageVolumeClaimTemplateSpecDataSourceRef(obj: PrometheusSpecStorageVolumeClaimTemplateSpecDataSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * resources represents the minimum resources the volume should have.
 * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
 * that are lower than previous value but must still be higher than capacity recorded in the
 * status field of the claim.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
 *
 * @schema PrometheusSpecStorageVolumeClaimTemplateSpecResources
 */
export interface PrometheusSpecStorageVolumeClaimTemplateSpecResources {
  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateSpecResources#limits
   */
  readonly limits?: { [key: string]: PrometheusSpecStorageVolumeClaimTemplateSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateSpecResources#requests
   */
  readonly requests?: { [key: string]: PrometheusSpecStorageVolumeClaimTemplateSpecResourcesRequests };

}

/**
 * Converts an object of type 'PrometheusSpecStorageVolumeClaimTemplateSpecResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecStorageVolumeClaimTemplateSpecResources(obj: PrometheusSpecStorageVolumeClaimTemplateSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * selector is a label query over volumes to consider for binding.
 *
 * @schema PrometheusSpecStorageVolumeClaimTemplateSpecSelector
 */
export interface PrometheusSpecStorageVolumeClaimTemplateSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateSpecSelector#matchExpressions
   */
  readonly matchExpressions?: PrometheusSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'PrometheusSpecStorageVolumeClaimTemplateSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecStorageVolumeClaimTemplateSpecSelector(obj: PrometheusSpecStorageVolumeClaimTemplateSpecSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_PrometheusSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PrometheusSpecStorageVolumeClaimTemplateStatusAllocatedResources
 */
export class PrometheusSpecStorageVolumeClaimTemplateStatusAllocatedResources {
  public static fromNumber(value: number): PrometheusSpecStorageVolumeClaimTemplateStatusAllocatedResources {
    return new PrometheusSpecStorageVolumeClaimTemplateStatusAllocatedResources(value);
  }
  public static fromString(value: string): PrometheusSpecStorageVolumeClaimTemplateStatusAllocatedResources {
    return new PrometheusSpecStorageVolumeClaimTemplateStatusAllocatedResources(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema PrometheusSpecStorageVolumeClaimTemplateStatusCapacity
 */
export class PrometheusSpecStorageVolumeClaimTemplateStatusCapacity {
  public static fromNumber(value: number): PrometheusSpecStorageVolumeClaimTemplateStatusCapacity {
    return new PrometheusSpecStorageVolumeClaimTemplateStatusCapacity(value);
  }
  public static fromString(value: string): PrometheusSpecStorageVolumeClaimTemplateStatusCapacity {
    return new PrometheusSpecStorageVolumeClaimTemplateStatusCapacity(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * PersistentVolumeClaimCondition contains details about state of pvc
 *
 * @schema PrometheusSpecStorageVolumeClaimTemplateStatusConditions
 */
export interface PrometheusSpecStorageVolumeClaimTemplateStatusConditions {
  /**
   * lastProbeTime is the time we probed the condition.
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateStatusConditions#lastProbeTime
   */
  readonly lastProbeTime?: Date;

  /**
   * lastTransitionTime is the time the condition transitioned from one status to another.
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateStatusConditions#lastTransitionTime
   */
  readonly lastTransitionTime?: Date;

  /**
   * message is the human-readable message indicating details about last transition.
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateStatusConditions#message
   */
  readonly message?: string;

  /**
   * reason is a unique, this should be a short, machine understandable string that gives the reason
   * for condition's last transition. If it reports "ResizeStarted" that means the underlying
   * persistent volume is being resized.
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateStatusConditions#reason
   */
  readonly reason?: string;

  /**
   * @schema PrometheusSpecStorageVolumeClaimTemplateStatusConditions#status
   */
  readonly status: string;

  /**
   * PersistentVolumeClaimConditionType is a valid value of PersistentVolumeClaimCondition.Type
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateStatusConditions#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'PrometheusSpecStorageVolumeClaimTemplateStatusConditions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecStorageVolumeClaimTemplateStatusConditions(obj: PrometheusSpecStorageVolumeClaimTemplateStatusConditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'lastProbeTime': obj.lastProbeTime?.toISOString(),
    'lastTransitionTime': obj.lastTransitionTime?.toISOString(),
    'message': obj.message,
    'reason': obj.reason,
    'status': obj.status,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ModifyVolumeStatus represents the status object of ControllerModifyVolume operation.
 * When this is unset, there is no ModifyVolume operation being attempted.
 * This is an alpha field and requires enabling VolumeAttributesClass feature.
 *
 * @schema PrometheusSpecStorageVolumeClaimTemplateStatusModifyVolumeStatus
 */
export interface PrometheusSpecStorageVolumeClaimTemplateStatusModifyVolumeStatus {
  /**
   * status is the status of the ControllerModifyVolume operation. It can be in any of following states:
   * - Pending
   * Pending indicates that the PersistentVolumeClaim cannot be modified due to unmet requirements, such as
   * the specified VolumeAttributesClass not existing.
   * - InProgress
   * InProgress indicates that the volume is being modified.
   * - Infeasible
   * Infeasible indicates that the request has been rejected as invalid by the CSI driver. To
   * resolve the error, a valid VolumeAttributesClass needs to be specified.
   * Note: New statuses can be added in the future. Consumers should check for unknown statuses and fail appropriately.
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateStatusModifyVolumeStatus#status
   */
  readonly status: string;

  /**
   * targetVolumeAttributesClassName is the name of the VolumeAttributesClass the PVC currently being reconciled
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateStatusModifyVolumeStatus#targetVolumeAttributesClassName
   */
  readonly targetVolumeAttributesClassName?: string;

}

/**
 * Converts an object of type 'PrometheusSpecStorageVolumeClaimTemplateStatusModifyVolumeStatus' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecStorageVolumeClaimTemplateStatusModifyVolumeStatus(obj: PrometheusSpecStorageVolumeClaimTemplateStatusModifyVolumeStatus | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'status': obj.status,
    'targetVolumeAttributesClassName': obj.targetVolumeAttributesClassName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema PrometheusSpecThanosGrpcServerTlsConfigCaConfigMap
 */
export interface PrometheusSpecThanosGrpcServerTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema PrometheusSpecThanosGrpcServerTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecThanosGrpcServerTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema PrometheusSpecThanosGrpcServerTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecThanosGrpcServerTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecThanosGrpcServerTlsConfigCaConfigMap(obj: PrometheusSpecThanosGrpcServerTlsConfigCaConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema PrometheusSpecThanosGrpcServerTlsConfigCaSecret
 */
export interface PrometheusSpecThanosGrpcServerTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecThanosGrpcServerTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecThanosGrpcServerTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecThanosGrpcServerTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecThanosGrpcServerTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecThanosGrpcServerTlsConfigCaSecret(obj: PrometheusSpecThanosGrpcServerTlsConfigCaSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema PrometheusSpecThanosGrpcServerTlsConfigCertConfigMap
 */
export interface PrometheusSpecThanosGrpcServerTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema PrometheusSpecThanosGrpcServerTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecThanosGrpcServerTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema PrometheusSpecThanosGrpcServerTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecThanosGrpcServerTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecThanosGrpcServerTlsConfigCertConfigMap(obj: PrometheusSpecThanosGrpcServerTlsConfigCertConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema PrometheusSpecThanosGrpcServerTlsConfigCertSecret
 */
export interface PrometheusSpecThanosGrpcServerTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecThanosGrpcServerTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecThanosGrpcServerTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecThanosGrpcServerTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecThanosGrpcServerTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecThanosGrpcServerTlsConfigCertSecret(obj: PrometheusSpecThanosGrpcServerTlsConfigCertSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema PrometheusSpecTracingConfigTlsConfigCaConfigMap
 */
export interface PrometheusSpecTracingConfigTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema PrometheusSpecTracingConfigTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecTracingConfigTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema PrometheusSpecTracingConfigTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecTracingConfigTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecTracingConfigTlsConfigCaConfigMap(obj: PrometheusSpecTracingConfigTlsConfigCaConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema PrometheusSpecTracingConfigTlsConfigCaSecret
 */
export interface PrometheusSpecTracingConfigTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecTracingConfigTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecTracingConfigTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecTracingConfigTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecTracingConfigTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecTracingConfigTlsConfigCaSecret(obj: PrometheusSpecTracingConfigTlsConfigCaSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema PrometheusSpecTracingConfigTlsConfigCertConfigMap
 */
export interface PrometheusSpecTracingConfigTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema PrometheusSpecTracingConfigTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecTracingConfigTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema PrometheusSpecTracingConfigTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecTracingConfigTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecTracingConfigTlsConfigCertConfigMap(obj: PrometheusSpecTracingConfigTlsConfigCertConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema PrometheusSpecTracingConfigTlsConfigCertSecret
 */
export interface PrometheusSpecTracingConfigTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecTracingConfigTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecTracingConfigTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecTracingConfigTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecTracingConfigTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecTracingConfigTlsConfigCertSecret(obj: PrometheusSpecTracingConfigTlsConfigCertSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
 *
 * @schema PrometheusSpecVolumesDownwardApiItemsFieldRef
 */
export interface PrometheusSpecVolumesDownwardApiItemsFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema PrometheusSpecVolumesDownwardApiItemsFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema PrometheusSpecVolumesDownwardApiItemsFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'PrometheusSpecVolumesDownwardApiItemsFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesDownwardApiItemsFieldRef(obj: PrometheusSpecVolumesDownwardApiItemsFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
 *
 * @schema PrometheusSpecVolumesDownwardApiItemsResourceFieldRef
 */
export interface PrometheusSpecVolumesDownwardApiItemsResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema PrometheusSpecVolumesDownwardApiItemsResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema PrometheusSpecVolumesDownwardApiItemsResourceFieldRef#divisor
   */
  readonly divisor?: PrometheusSpecVolumesDownwardApiItemsResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema PrometheusSpecVolumesDownwardApiItemsResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'PrometheusSpecVolumesDownwardApiItemsResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesDownwardApiItemsResourceFieldRef(obj: PrometheusSpecVolumesDownwardApiItemsResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The specification for the PersistentVolumeClaim. The entire content is
 * copied unchanged into the PVC that gets created from this
 * template. The same fields as in a PersistentVolumeClaim
 * are also valid here.
 *
 * @schema PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpec
 */
export interface PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpec {
  /**
   * accessModes contains the desired access modes the volume should have.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpec#accessModes
   */
  readonly accessModes?: string[];

  /**
   * dataSource field can be used to specify either:
   * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
   * * An existing PVC (PersistentVolumeClaim)
   * If the provisioner or an external controller can support the specified data source,
   * it will create a new volume based on the contents of the specified data source.
   * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
   * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
   * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
   *
   * @schema PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpec#dataSource
   */
  readonly dataSource?: PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource;

  /**
   * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
   * volume is desired. This may be any object from a non-empty API group (non
   * core object) or a PersistentVolumeClaim object.
   * When this field is specified, volume binding will only succeed if the type of
   * the specified object matches some installed volume populator or dynamic
   * provisioner.
   * This field will replace the functionality of the dataSource field and as such
   * if both fields are non-empty, they must have the same value. For backwards
   * compatibility, when namespace isn't specified in dataSourceRef,
   * both fields (dataSource and dataSourceRef) will be set to the same
   * value automatically if one of them is empty and the other is non-empty.
   * When namespace is specified in dataSourceRef,
   * dataSource isn't set to the same value and must be empty.
   * There are three important differences between dataSource and dataSourceRef:
   * * While dataSource only allows two specific types of objects, dataSourceRef
   * allows any non-core object, as well as PersistentVolumeClaim objects.
   * * While dataSource ignores disallowed values (dropping them), dataSourceRef
   * preserves all values, and generates an error if a disallowed value is
   * specified.
   * * While dataSource only allows local objects, dataSourceRef allows objects
   * in any namespaces.
   * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
   * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpec#dataSourceRef
   */
  readonly dataSourceRef?: PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef;

  /**
   * resources represents the minimum resources the volume should have.
   * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
   * that are lower than previous value but must still be higher than capacity recorded in the
   * status field of the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
   *
   * @schema PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpec#resources
   */
  readonly resources?: PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecResources;

  /**
   * selector is a label query over volumes to consider for binding.
   *
   * @schema PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpec#selector
   */
  readonly selector?: PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecSelector;

  /**
   * storageClassName is the name of the StorageClass required by the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   *
   * @schema PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpec#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
   * If specified, the CSI driver will create or update the volume with the attributes defined
   * in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
   * it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
   * will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
   * If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
   * will be set by the persistentvolume controller if it exists.
   * If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
   * set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
   * exists.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#volumeattributesclass
   * (Alpha) Using this field requires the VolumeAttributesClass feature gate to be enabled.
   *
   * @schema PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpec#volumeAttributesClassName
   */
  readonly volumeAttributesClassName?: string;

  /**
   * volumeMode defines what type of volume is required by the claim.
   * Value of Filesystem is implied when not included in claim spec.
   *
   * @schema PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpec#volumeMode
   */
  readonly volumeMode?: string;

  /**
   * volumeName is the binding reference to the PersistentVolume backing this claim.
   *
   * @schema PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpec#volumeName
   */
  readonly volumeName?: string;

}

/**
 * Converts an object of type 'PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpec(obj: PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessModes': obj.accessModes?.map(y => y),
    'dataSource': toJson_PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource(obj.dataSource),
    'dataSourceRef': toJson_PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef(obj.dataSourceRef),
    'resources': toJson_PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecResources(obj.resources),
    'selector': toJson_PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecSelector(obj.selector),
    'storageClassName': obj.storageClassName,
    'volumeAttributesClassName': obj.volumeAttributesClassName,
    'volumeMode': obj.volumeMode,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ClusterTrustBundle allows a pod to access the `.spec.trustBundle` field
 * of ClusterTrustBundle objects in an auto-updating file.
 *
 *
 * Alpha, gated by the ClusterTrustBundleProjection feature gate.
 *
 *
 * ClusterTrustBundle objects can either be selected by name, or by the
 * combination of signer name and a label selector.
 *
 *
 * Kubelet performs aggressive normalization of the PEM contents written
 * into the pod filesystem.  Esoteric PEM features such as inter-block
 * comments and block headers are stripped.  Certificates are deduplicated.
 * The ordering of certificates within the file is arbitrary, and Kubelet
 * may change the order over time.
 *
 * @schema PrometheusSpecVolumesProjectedSourcesClusterTrustBundle
 */
export interface PrometheusSpecVolumesProjectedSourcesClusterTrustBundle {
  /**
   * Select all ClusterTrustBundles that match this label selector.  Only has
   * effect if signerName is set.  Mutually-exclusive with name.  If unset,
   * interpreted as "match nothing".  If set but empty, interpreted as "match
   * everything".
   *
   * @schema PrometheusSpecVolumesProjectedSourcesClusterTrustBundle#labelSelector
   */
  readonly labelSelector?: PrometheusSpecVolumesProjectedSourcesClusterTrustBundleLabelSelector;

  /**
   * Select a single ClusterTrustBundle by object name.  Mutually-exclusive
   * with signerName and labelSelector.
   *
   * @schema PrometheusSpecVolumesProjectedSourcesClusterTrustBundle#name
   */
  readonly name?: string;

  /**
   * If true, don't block pod startup if the referenced ClusterTrustBundle(s)
   * aren't available.  If using name, then the named ClusterTrustBundle is
   * allowed not to exist.  If using signerName, then the combination of
   * signerName and labelSelector is allowed to match zero
   * ClusterTrustBundles.
   *
   * @schema PrometheusSpecVolumesProjectedSourcesClusterTrustBundle#optional
   */
  readonly optional?: boolean;

  /**
   * Relative path from the volume root to write the bundle.
   *
   * @schema PrometheusSpecVolumesProjectedSourcesClusterTrustBundle#path
   */
  readonly path: string;

  /**
   * Select all ClusterTrustBundles that match this signer name.
   * Mutually-exclusive with name.  The contents of all selected
   * ClusterTrustBundles will be unified and deduplicated.
   *
   * @schema PrometheusSpecVolumesProjectedSourcesClusterTrustBundle#signerName
   */
  readonly signerName?: string;

}

/**
 * Converts an object of type 'PrometheusSpecVolumesProjectedSourcesClusterTrustBundle' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesProjectedSourcesClusterTrustBundle(obj: PrometheusSpecVolumesProjectedSourcesClusterTrustBundle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_PrometheusSpecVolumesProjectedSourcesClusterTrustBundleLabelSelector(obj.labelSelector),
    'name': obj.name,
    'optional': obj.optional,
    'path': obj.path,
    'signerName': obj.signerName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * configMap information about the configMap data to project
 *
 * @schema PrometheusSpecVolumesProjectedSourcesConfigMap
 */
export interface PrometheusSpecVolumesProjectedSourcesConfigMap {
  /**
   * items if unspecified, each key-value pair in the Data field of the referenced
   * ConfigMap will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the ConfigMap,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   *
   * @schema PrometheusSpecVolumesProjectedSourcesConfigMap#items
   */
  readonly items?: PrometheusSpecVolumesProjectedSourcesConfigMapItems[];

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecVolumesProjectedSourcesConfigMap#name
   */
  readonly name?: string;

  /**
   * optional specify whether the ConfigMap or its keys must be defined
   *
   * @schema PrometheusSpecVolumesProjectedSourcesConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecVolumesProjectedSourcesConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesProjectedSourcesConfigMap(obj: PrometheusSpecVolumesProjectedSourcesConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_PrometheusSpecVolumesProjectedSourcesConfigMapItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * downwardAPI information about the downwardAPI data to project
 *
 * @schema PrometheusSpecVolumesProjectedSourcesDownwardApi
 */
export interface PrometheusSpecVolumesProjectedSourcesDownwardApi {
  /**
   * Items is a list of DownwardAPIVolume file
   *
   * @schema PrometheusSpecVolumesProjectedSourcesDownwardApi#items
   */
  readonly items?: PrometheusSpecVolumesProjectedSourcesDownwardApiItems[];

}

/**
 * Converts an object of type 'PrometheusSpecVolumesProjectedSourcesDownwardApi' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesProjectedSourcesDownwardApi(obj: PrometheusSpecVolumesProjectedSourcesDownwardApi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_PrometheusSpecVolumesProjectedSourcesDownwardApiItems(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * secret information about the secret data to project
 *
 * @schema PrometheusSpecVolumesProjectedSourcesSecret
 */
export interface PrometheusSpecVolumesProjectedSourcesSecret {
  /**
   * items if unspecified, each key-value pair in the Data field of the referenced
   * Secret will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the Secret,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   *
   * @schema PrometheusSpecVolumesProjectedSourcesSecret#items
   */
  readonly items?: PrometheusSpecVolumesProjectedSourcesSecretItems[];

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecVolumesProjectedSourcesSecret#name
   */
  readonly name?: string;

  /**
   * optional field specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecVolumesProjectedSourcesSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecVolumesProjectedSourcesSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesProjectedSourcesSecret(obj: PrometheusSpecVolumesProjectedSourcesSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_PrometheusSpecVolumesProjectedSourcesSecretItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * serviceAccountToken is information about the serviceAccountToken data to project
 *
 * @schema PrometheusSpecVolumesProjectedSourcesServiceAccountToken
 */
export interface PrometheusSpecVolumesProjectedSourcesServiceAccountToken {
  /**
   * audience is the intended audience of the token. A recipient of a token
   * must identify itself with an identifier specified in the audience of the
   * token, and otherwise should reject the token. The audience defaults to the
   * identifier of the apiserver.
   *
   * @schema PrometheusSpecVolumesProjectedSourcesServiceAccountToken#audience
   */
  readonly audience?: string;

  /**
   * expirationSeconds is the requested duration of validity of the service
   * account token. As the token approaches expiration, the kubelet volume
   * plugin will proactively rotate the service account token. The kubelet will
   * start trying to rotate the token if the token is older than 80 percent of
   * its time to live or if the token is older than 24 hours.Defaults to 1 hour
   * and must be at least 10 minutes.
   *
   * @default 1 hour
   * @schema PrometheusSpecVolumesProjectedSourcesServiceAccountToken#expirationSeconds
   */
  readonly expirationSeconds?: number;

  /**
   * path is the path relative to the mount point of the file to project the
   * token into.
   *
   * @schema PrometheusSpecVolumesProjectedSourcesServiceAccountToken#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'PrometheusSpecVolumesProjectedSourcesServiceAccountToken' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesProjectedSourcesServiceAccountToken(obj: PrometheusSpecVolumesProjectedSourcesServiceAccountToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audience': obj.audience,
    'expirationSeconds': obj.expirationSeconds,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Set the X-Content-Type-Options header to HTTP responses.
 * Unset if blank. Accepted value is nosniff.
 * https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Content-Type-Options
 *
 * @schema PrometheusSpecWebHttpConfigHeadersXContentTypeOptions
 */
export enum PrometheusSpecWebHttpConfigHeadersXContentTypeOptions {
  /** NoSniff */
  NO_SNIFF = "NoSniff",
}

/**
 * Set the X-Frame-Options header to HTTP responses.
 * Unset if blank. Accepted values are deny and sameorigin.
 * https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options
 *
 * @schema PrometheusSpecWebHttpConfigHeadersXFrameOptions
 */
export enum PrometheusSpecWebHttpConfigHeadersXFrameOptions {
  /** Deny */
  DENY = "Deny",
  /** SameOrigin */
  SAME_ORIGIN = "SameOrigin",
}

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema PrometheusSpecWebTlsConfigCertConfigMap
 */
export interface PrometheusSpecWebTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema PrometheusSpecWebTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecWebTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema PrometheusSpecWebTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecWebTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecWebTlsConfigCertConfigMap(obj: PrometheusSpecWebTlsConfigCertConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema PrometheusSpecWebTlsConfigCertSecret
 */
export interface PrometheusSpecWebTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecWebTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecWebTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecWebTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecWebTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecWebTlsConfigCertSecret(obj: PrometheusSpecWebTlsConfigCertSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema PrometheusSpecWebTlsConfigClientCaConfigMap
 */
export interface PrometheusSpecWebTlsConfigClientCaConfigMap {
  /**
   * The key to select.
   *
   * @schema PrometheusSpecWebTlsConfigClientCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecWebTlsConfigClientCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema PrometheusSpecWebTlsConfigClientCaConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecWebTlsConfigClientCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecWebTlsConfigClientCaConfigMap(obj: PrometheusSpecWebTlsConfigClientCaConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema PrometheusSpecWebTlsConfigClientCaSecret
 */
export interface PrometheusSpecWebTlsConfigClientCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecWebTlsConfigClientCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecWebTlsConfigClientCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecWebTlsConfigClientCaSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecWebTlsConfigClientCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecWebTlsConfigClientCaSecret(obj: PrometheusSpecWebTlsConfigClientCaSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema PrometheusSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface PrometheusSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema PrometheusSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema PrometheusSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema PrometheusSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'PrometheusSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(obj: PrometheusSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema PrometheusSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface PrometheusSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema PrometheusSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema PrometheusSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema PrometheusSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'PrometheusSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(obj: PrometheusSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema PrometheusSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface PrometheusSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema PrometheusSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema PrometheusSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema PrometheusSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'PrometheusSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(obj: PrometheusSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema PrometheusSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface PrometheusSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema PrometheusSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema PrometheusSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema PrometheusSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'PrometheusSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(obj: PrometheusSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema PrometheusSpecAlertingAlertmanagersTlsConfigCaConfigMap
 */
export interface PrometheusSpecAlertingAlertmanagersTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema PrometheusSpecAlertingAlertmanagersTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecAlertingAlertmanagersTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema PrometheusSpecAlertingAlertmanagersTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecAlertingAlertmanagersTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAlertingAlertmanagersTlsConfigCaConfigMap(obj: PrometheusSpecAlertingAlertmanagersTlsConfigCaConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema PrometheusSpecAlertingAlertmanagersTlsConfigCaSecret
 */
export interface PrometheusSpecAlertingAlertmanagersTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecAlertingAlertmanagersTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecAlertingAlertmanagersTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecAlertingAlertmanagersTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecAlertingAlertmanagersTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAlertingAlertmanagersTlsConfigCaSecret(obj: PrometheusSpecAlertingAlertmanagersTlsConfigCaSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema PrometheusSpecAlertingAlertmanagersTlsConfigCertConfigMap
 */
export interface PrometheusSpecAlertingAlertmanagersTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema PrometheusSpecAlertingAlertmanagersTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecAlertingAlertmanagersTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema PrometheusSpecAlertingAlertmanagersTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecAlertingAlertmanagersTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAlertingAlertmanagersTlsConfigCertConfigMap(obj: PrometheusSpecAlertingAlertmanagersTlsConfigCertConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema PrometheusSpecAlertingAlertmanagersTlsConfigCertSecret
 */
export interface PrometheusSpecAlertingAlertmanagersTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecAlertingAlertmanagersTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecAlertingAlertmanagersTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecAlertingAlertmanagersTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'PrometheusSpecAlertingAlertmanagersTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAlertingAlertmanagersTlsConfigCertSecret(obj: PrometheusSpecAlertingAlertmanagersTlsConfigCertSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema PrometheusSpecContainersEnvValueFromResourceFieldRefDivisor
 */
export class PrometheusSpecContainersEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(value: number): PrometheusSpecContainersEnvValueFromResourceFieldRefDivisor {
    return new PrometheusSpecContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): PrometheusSpecContainersEnvValueFromResourceFieldRefDivisor {
    return new PrometheusSpecContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema PrometheusSpecContainersLifecyclePostStartHttpGetHttpHeaders
 */
export interface PrometheusSpecContainersLifecyclePostStartHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema PrometheusSpecContainersLifecyclePostStartHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema PrometheusSpecContainersLifecyclePostStartHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'PrometheusSpecContainersLifecyclePostStartHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersLifecyclePostStartHttpGetHttpHeaders(obj: PrometheusSpecContainersLifecyclePostStartHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema PrometheusSpecContainersLifecyclePostStartHttpGetPort
 */
export class PrometheusSpecContainersLifecyclePostStartHttpGetPort {
  public static fromNumber(value: number): PrometheusSpecContainersLifecyclePostStartHttpGetPort {
    return new PrometheusSpecContainersLifecyclePostStartHttpGetPort(value);
  }
  public static fromString(value: string): PrometheusSpecContainersLifecyclePostStartHttpGetPort {
    return new PrometheusSpecContainersLifecyclePostStartHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema PrometheusSpecContainersLifecyclePostStartTcpSocketPort
 */
export class PrometheusSpecContainersLifecyclePostStartTcpSocketPort {
  public static fromNumber(value: number): PrometheusSpecContainersLifecyclePostStartTcpSocketPort {
    return new PrometheusSpecContainersLifecyclePostStartTcpSocketPort(value);
  }
  public static fromString(value: string): PrometheusSpecContainersLifecyclePostStartTcpSocketPort {
    return new PrometheusSpecContainersLifecyclePostStartTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema PrometheusSpecContainersLifecyclePreStopHttpGetHttpHeaders
 */
export interface PrometheusSpecContainersLifecyclePreStopHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema PrometheusSpecContainersLifecyclePreStopHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema PrometheusSpecContainersLifecyclePreStopHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'PrometheusSpecContainersLifecyclePreStopHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersLifecyclePreStopHttpGetHttpHeaders(obj: PrometheusSpecContainersLifecyclePreStopHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema PrometheusSpecContainersLifecyclePreStopHttpGetPort
 */
export class PrometheusSpecContainersLifecyclePreStopHttpGetPort {
  public static fromNumber(value: number): PrometheusSpecContainersLifecyclePreStopHttpGetPort {
    return new PrometheusSpecContainersLifecyclePreStopHttpGetPort(value);
  }
  public static fromString(value: string): PrometheusSpecContainersLifecyclePreStopHttpGetPort {
    return new PrometheusSpecContainersLifecyclePreStopHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema PrometheusSpecContainersLifecyclePreStopTcpSocketPort
 */
export class PrometheusSpecContainersLifecyclePreStopTcpSocketPort {
  public static fromNumber(value: number): PrometheusSpecContainersLifecyclePreStopTcpSocketPort {
    return new PrometheusSpecContainersLifecyclePreStopTcpSocketPort(value);
  }
  public static fromString(value: string): PrometheusSpecContainersLifecyclePreStopTcpSocketPort {
    return new PrometheusSpecContainersLifecyclePreStopTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema PrometheusSpecInitContainersEnvValueFromResourceFieldRefDivisor
 */
export class PrometheusSpecInitContainersEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(value: number): PrometheusSpecInitContainersEnvValueFromResourceFieldRefDivisor {
    return new PrometheusSpecInitContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): PrometheusSpecInitContainersEnvValueFromResourceFieldRefDivisor {
    return new PrometheusSpecInitContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema PrometheusSpecInitContainersLifecyclePostStartHttpGetHttpHeaders
 */
export interface PrometheusSpecInitContainersLifecyclePostStartHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema PrometheusSpecInitContainersLifecyclePostStartHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema PrometheusSpecInitContainersLifecyclePostStartHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'PrometheusSpecInitContainersLifecyclePostStartHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersLifecyclePostStartHttpGetHttpHeaders(obj: PrometheusSpecInitContainersLifecyclePostStartHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema PrometheusSpecInitContainersLifecyclePostStartHttpGetPort
 */
export class PrometheusSpecInitContainersLifecyclePostStartHttpGetPort {
  public static fromNumber(value: number): PrometheusSpecInitContainersLifecyclePostStartHttpGetPort {
    return new PrometheusSpecInitContainersLifecyclePostStartHttpGetPort(value);
  }
  public static fromString(value: string): PrometheusSpecInitContainersLifecyclePostStartHttpGetPort {
    return new PrometheusSpecInitContainersLifecyclePostStartHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema PrometheusSpecInitContainersLifecyclePostStartTcpSocketPort
 */
export class PrometheusSpecInitContainersLifecyclePostStartTcpSocketPort {
  public static fromNumber(value: number): PrometheusSpecInitContainersLifecyclePostStartTcpSocketPort {
    return new PrometheusSpecInitContainersLifecyclePostStartTcpSocketPort(value);
  }
  public static fromString(value: string): PrometheusSpecInitContainersLifecyclePostStartTcpSocketPort {
    return new PrometheusSpecInitContainersLifecyclePostStartTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema PrometheusSpecInitContainersLifecyclePreStopHttpGetHttpHeaders
 */
export interface PrometheusSpecInitContainersLifecyclePreStopHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema PrometheusSpecInitContainersLifecyclePreStopHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema PrometheusSpecInitContainersLifecyclePreStopHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'PrometheusSpecInitContainersLifecyclePreStopHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersLifecyclePreStopHttpGetHttpHeaders(obj: PrometheusSpecInitContainersLifecyclePreStopHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema PrometheusSpecInitContainersLifecyclePreStopHttpGetPort
 */
export class PrometheusSpecInitContainersLifecyclePreStopHttpGetPort {
  public static fromNumber(value: number): PrometheusSpecInitContainersLifecyclePreStopHttpGetPort {
    return new PrometheusSpecInitContainersLifecyclePreStopHttpGetPort(value);
  }
  public static fromString(value: string): PrometheusSpecInitContainersLifecyclePreStopHttpGetPort {
    return new PrometheusSpecInitContainersLifecyclePreStopHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema PrometheusSpecInitContainersLifecyclePreStopTcpSocketPort
 */
export class PrometheusSpecInitContainersLifecyclePreStopTcpSocketPort {
  public static fromNumber(value: number): PrometheusSpecInitContainersLifecyclePreStopTcpSocketPort {
    return new PrometheusSpecInitContainersLifecyclePreStopTcpSocketPort(value);
  }
  public static fromString(value: string): PrometheusSpecInitContainersLifecyclePreStopTcpSocketPort {
    return new PrometheusSpecInitContainersLifecyclePreStopTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * dataSource field can be used to specify either:
 * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
 * * An existing PVC (PersistentVolumeClaim)
 * If the provisioner or an external controller can support the specified data source,
 * it will create a new volume based on the contents of the specified data source.
 * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
 * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
 * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
 *
 * @schema PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecDataSource
 */
export interface PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecDataSource {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecDataSource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecDataSource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecDataSource#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecDataSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecDataSource(obj: PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecDataSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
 * volume is desired. This may be any object from a non-empty API group (non
 * core object) or a PersistentVolumeClaim object.
 * When this field is specified, volume binding will only succeed if the type of
 * the specified object matches some installed volume populator or dynamic
 * provisioner.
 * This field will replace the functionality of the dataSource field and as such
 * if both fields are non-empty, they must have the same value. For backwards
 * compatibility, when namespace isn't specified in dataSourceRef,
 * both fields (dataSource and dataSourceRef) will be set to the same
 * value automatically if one of them is empty and the other is non-empty.
 * When namespace is specified in dataSourceRef,
 * dataSource isn't set to the same value and must be empty.
 * There are three important differences between dataSource and dataSourceRef:
 * * While dataSource only allows two specific types of objects, dataSourceRef
 * allows any non-core object, as well as PersistentVolumeClaim objects.
 * * While dataSource ignores disallowed values (dropping them), dataSourceRef
 * preserves all values, and generates an error if a disallowed value is
 * specified.
 * * While dataSource only allows local objects, dataSourceRef allows objects
 * in any namespaces.
 * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
 * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
 *
 * @schema PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecDataSourceRef
 */
export interface PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecDataSourceRef {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecDataSourceRef#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecDataSourceRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecDataSourceRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of resource being referenced
   * Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
   * (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecDataSourceRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecDataSourceRef(obj: PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecDataSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * resources represents the minimum resources the volume should have.
 * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
 * that are lower than previous value but must still be higher than capacity recorded in the
 * status field of the claim.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
 *
 * @schema PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecResources
 */
export interface PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecResources {
  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecResources#limits
   */
  readonly limits?: { [key: string]: PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecResources#requests
   */
  readonly requests?: { [key: string]: PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecResourcesRequests };

}

/**
 * Converts an object of type 'PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecResources(obj: PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * selector is a label query over volumes to consider for binding.
 *
 * @schema PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecSelector
 */
export interface PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecSelector#matchExpressions
   */
  readonly matchExpressions?: PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecSelector(obj: PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PrometheusSpecStorageVolumeClaimTemplateSpecResourcesLimits
 */
export class PrometheusSpecStorageVolumeClaimTemplateSpecResourcesLimits {
  public static fromNumber(value: number): PrometheusSpecStorageVolumeClaimTemplateSpecResourcesLimits {
    return new PrometheusSpecStorageVolumeClaimTemplateSpecResourcesLimits(value);
  }
  public static fromString(value: string): PrometheusSpecStorageVolumeClaimTemplateSpecResourcesLimits {
    return new PrometheusSpecStorageVolumeClaimTemplateSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema PrometheusSpecStorageVolumeClaimTemplateSpecResourcesRequests
 */
export class PrometheusSpecStorageVolumeClaimTemplateSpecResourcesRequests {
  public static fromNumber(value: number): PrometheusSpecStorageVolumeClaimTemplateSpecResourcesRequests {
    return new PrometheusSpecStorageVolumeClaimTemplateSpecResourcesRequests(value);
  }
  public static fromString(value: string): PrometheusSpecStorageVolumeClaimTemplateSpecResourcesRequests {
    return new PrometheusSpecStorageVolumeClaimTemplateSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema PrometheusSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions
 */
export interface PrometheusSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'PrometheusSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions(obj: PrometheusSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema PrometheusSpecVolumesDownwardApiItemsResourceFieldRefDivisor
 */
export class PrometheusSpecVolumesDownwardApiItemsResourceFieldRefDivisor {
  public static fromNumber(value: number): PrometheusSpecVolumesDownwardApiItemsResourceFieldRefDivisor {
    return new PrometheusSpecVolumesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): PrometheusSpecVolumesDownwardApiItemsResourceFieldRefDivisor {
    return new PrometheusSpecVolumesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * dataSource field can be used to specify either:
 * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
 * * An existing PVC (PersistentVolumeClaim)
 * If the provisioner or an external controller can support the specified data source,
 * it will create a new volume based on the contents of the specified data source.
 * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
 * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
 * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
 *
 * @schema PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource
 */
export interface PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource(obj: PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
 * volume is desired. This may be any object from a non-empty API group (non
 * core object) or a PersistentVolumeClaim object.
 * When this field is specified, volume binding will only succeed if the type of
 * the specified object matches some installed volume populator or dynamic
 * provisioner.
 * This field will replace the functionality of the dataSource field and as such
 * if both fields are non-empty, they must have the same value. For backwards
 * compatibility, when namespace isn't specified in dataSourceRef,
 * both fields (dataSource and dataSourceRef) will be set to the same
 * value automatically if one of them is empty and the other is non-empty.
 * When namespace is specified in dataSourceRef,
 * dataSource isn't set to the same value and must be empty.
 * There are three important differences between dataSource and dataSourceRef:
 * * While dataSource only allows two specific types of objects, dataSourceRef
 * allows any non-core object, as well as PersistentVolumeClaim objects.
 * * While dataSource ignores disallowed values (dropping them), dataSourceRef
 * preserves all values, and generates an error if a disallowed value is
 * specified.
 * * While dataSource only allows local objects, dataSourceRef allows objects
 * in any namespaces.
 * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
 * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
 *
 * @schema PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef
 */
export interface PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of resource being referenced
   * Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
   * (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef(obj: PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * resources represents the minimum resources the volume should have.
 * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
 * that are lower than previous value but must still be higher than capacity recorded in the
 * status field of the claim.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
 *
 * @schema PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecResources
 */
export interface PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecResources {
  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecResources#limits
   */
  readonly limits?: { [key: string]: PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecResources#requests
   */
  readonly requests?: { [key: string]: PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests };

}

/**
 * Converts an object of type 'PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecResources(obj: PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * selector is a label query over volumes to consider for binding.
 *
 * @schema PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecSelector
 */
export interface PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecSelector#matchExpressions
   */
  readonly matchExpressions?: PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecSelector(obj: PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Select all ClusterTrustBundles that match this label selector.  Only has
 * effect if signerName is set.  Mutually-exclusive with name.  If unset,
 * interpreted as "match nothing".  If set but empty, interpreted as "match
 * everything".
 *
 * @schema PrometheusSpecVolumesProjectedSourcesClusterTrustBundleLabelSelector
 */
export interface PrometheusSpecVolumesProjectedSourcesClusterTrustBundleLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PrometheusSpecVolumesProjectedSourcesClusterTrustBundleLabelSelector#matchExpressions
   */
  readonly matchExpressions?: PrometheusSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PrometheusSpecVolumesProjectedSourcesClusterTrustBundleLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'PrometheusSpecVolumesProjectedSourcesClusterTrustBundleLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesProjectedSourcesClusterTrustBundleLabelSelector(obj: PrometheusSpecVolumesProjectedSourcesClusterTrustBundleLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_PrometheusSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema PrometheusSpecVolumesProjectedSourcesConfigMapItems
 */
export interface PrometheusSpecVolumesProjectedSourcesConfigMapItems {
  /**
   * key is the key to project.
   *
   * @schema PrometheusSpecVolumesProjectedSourcesConfigMapItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema PrometheusSpecVolumesProjectedSourcesConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to.
   * May not be an absolute path.
   * May not contain the path element '..'.
   * May not start with the string '..'.
   *
   * @schema PrometheusSpecVolumesProjectedSourcesConfigMapItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'PrometheusSpecVolumesProjectedSourcesConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesProjectedSourcesConfigMapItems(obj: PrometheusSpecVolumesProjectedSourcesConfigMapItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DownwardAPIVolumeFile represents information to create the file containing the pod field
 *
 * @schema PrometheusSpecVolumesProjectedSourcesDownwardApiItems
 */
export interface PrometheusSpecVolumesProjectedSourcesDownwardApiItems {
  /**
   * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
   *
   * @schema PrometheusSpecVolumesProjectedSourcesDownwardApiItems#fieldRef
   */
  readonly fieldRef?: PrometheusSpecVolumesProjectedSourcesDownwardApiItemsFieldRef;

  /**
   * Optional: mode bits used to set permissions on this file, must be an octal value
   * between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema PrometheusSpecVolumesProjectedSourcesDownwardApiItems#mode
   */
  readonly mode?: number;

  /**
   * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
   *
   * @schema PrometheusSpecVolumesProjectedSourcesDownwardApiItems#path
   */
  readonly path: string;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
   *
   * @schema PrometheusSpecVolumesProjectedSourcesDownwardApiItems#resourceFieldRef
   */
  readonly resourceFieldRef?: PrometheusSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef;

}

/**
 * Converts an object of type 'PrometheusSpecVolumesProjectedSourcesDownwardApiItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesProjectedSourcesDownwardApiItems(obj: PrometheusSpecVolumesProjectedSourcesDownwardApiItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fieldRef': toJson_PrometheusSpecVolumesProjectedSourcesDownwardApiItemsFieldRef(obj.fieldRef),
    'mode': obj.mode,
    'path': obj.path,
    'resourceFieldRef': toJson_PrometheusSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef(obj.resourceFieldRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema PrometheusSpecVolumesProjectedSourcesSecretItems
 */
export interface PrometheusSpecVolumesProjectedSourcesSecretItems {
  /**
   * key is the key to project.
   *
   * @schema PrometheusSpecVolumesProjectedSourcesSecretItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema PrometheusSpecVolumesProjectedSourcesSecretItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to.
   * May not be an absolute path.
   * May not contain the path element '..'.
   * May not start with the string '..'.
   *
   * @schema PrometheusSpecVolumesProjectedSourcesSecretItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'PrometheusSpecVolumesProjectedSourcesSecretItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesProjectedSourcesSecretItems(obj: PrometheusSpecVolumesProjectedSourcesSecretItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecResourcesLimits
 */
export class PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecResourcesLimits {
  public static fromNumber(value: number): PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecResourcesLimits(value);
  }
  public static fromString(value: string): PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecResourcesRequests
 */
export class PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecResourcesRequests {
  public static fromNumber(value: number): PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecResourcesRequests(value);
  }
  public static fromString(value: string): PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions
 */
export interface PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(obj: PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits
 */
export class PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
  public static fromNumber(value: number): PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits(value);
  }
  public static fromString(value: string): PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests
 */
export class PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
  public static fromNumber(value: number): PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests(value);
  }
  public static fromString(value: string): PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions
 */
export interface PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(obj: PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema PrometheusSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions
 */
export interface PrometheusSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PrometheusSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PrometheusSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema PrometheusSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'PrometheusSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions(obj: PrometheusSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
 *
 * @schema PrometheusSpecVolumesProjectedSourcesDownwardApiItemsFieldRef
 */
export interface PrometheusSpecVolumesProjectedSourcesDownwardApiItemsFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema PrometheusSpecVolumesProjectedSourcesDownwardApiItemsFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema PrometheusSpecVolumesProjectedSourcesDownwardApiItemsFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'PrometheusSpecVolumesProjectedSourcesDownwardApiItemsFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesProjectedSourcesDownwardApiItemsFieldRef(obj: PrometheusSpecVolumesProjectedSourcesDownwardApiItemsFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
 *
 * @schema PrometheusSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef
 */
export interface PrometheusSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema PrometheusSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema PrometheusSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#divisor
   */
  readonly divisor?: PrometheusSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema PrometheusSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'PrometheusSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef(obj: PrometheusSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema PrometheusSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor
 */
export class PrometheusSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
  public static fromNumber(value: number): PrometheusSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
    return new PrometheusSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): PrometheusSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
    return new PrometheusSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

