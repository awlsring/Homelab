// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * ClusterTunnel is the Schema for the clustertunnels API
 *
 * @schema ClusterTunnel
 */
export class ClusterTunnel extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ClusterTunnel"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networking.cfargotunnel.com/v1alpha1',
    kind: 'ClusterTunnel',
  }

  /**
   * Renders a Kubernetes manifest for "ClusterTunnel".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ClusterTunnelProps = {}): any {
    return {
      ...ClusterTunnel.GVK,
      ...toJson_ClusterTunnelProps(props),
    };
  }

  /**
   * Defines a "ClusterTunnel" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ClusterTunnelProps = {}) {
    super(scope, id, {
      ...ClusterTunnel.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ClusterTunnel.GVK,
      ...toJson_ClusterTunnelProps(resolved),
    };
  }
}

/**
 * ClusterTunnel is the Schema for the clustertunnels API
 *
 * @schema ClusterTunnel
 */
export interface ClusterTunnelProps {
  /**
   * @schema ClusterTunnel#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * TunnelSpec defines the desired state of Tunnel
   *
   * @schema ClusterTunnel#spec
   */
  readonly spec?: ClusterTunnelSpec;

}

/**
 * Converts an object of type 'ClusterTunnelProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterTunnelProps(obj: ClusterTunnelProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ClusterTunnelSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TunnelSpec defines the desired state of Tunnel
 *
 * @schema ClusterTunnelSpec
 */
export interface ClusterTunnelSpec {
  /**
   * Cloudflare Credentials
   *
   * @schema ClusterTunnelSpec#cloudflare
   */
  readonly cloudflare?: ClusterTunnelSpecCloudflare;

  /**
   * Existing tunnel object. ExistingTunnel and NewTunnel cannot be both empty and are mutually exclusive.
   *
   * @schema ClusterTunnelSpec#existingTunnel
   */
  readonly existingTunnel?: ClusterTunnelSpecExistingTunnel;

  /**
   * FallbackTarget speficies the target for requests that do not match an ingress. Defaults to http_status:404
   *
   * @default http_status:404
   * @schema ClusterTunnelSpec#fallbackTarget
   */
  readonly fallbackTarget?: string;

  /**
   * Image sets the Cloudflared Image to use. Defaults to the image set during the release of the operator.
   *
   * @default the image set during the release of the operator.
   * @schema ClusterTunnelSpec#image
   */
  readonly image?: string;

  /**
   * New tunnel object. NewTunnel and ExistingTunnel cannot be both empty and are mutually exclusive.
   *
   * @schema ClusterTunnelSpec#newTunnel
   */
  readonly newTunnel?: ClusterTunnelSpecNewTunnel;

  /**
   * NoTlsVerify disables origin TLS certificate checks when the endpoint is HTTPS.
   *
   * @schema ClusterTunnelSpec#noTlsVerify
   */
  readonly noTlsVerify?: boolean;

  /**
   * OriginCaPool speficies the secret with tls.crt (and other certs as needed to be referred in the service annotation) of the Root CA to be trusted when sending traffic to HTTPS endpoints
   *
   * @schema ClusterTunnelSpec#originCaPool
   */
  readonly originCaPool?: string;

  /**
   * Size defines the number of Daemon pods to run for this tunnel
   *
   * @schema ClusterTunnelSpec#size
   */
  readonly size?: number;

}

/**
 * Converts an object of type 'ClusterTunnelSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterTunnelSpec(obj: ClusterTunnelSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloudflare': toJson_ClusterTunnelSpecCloudflare(obj.cloudflare),
    'existingTunnel': toJson_ClusterTunnelSpecExistingTunnel(obj.existingTunnel),
    'fallbackTarget': obj.fallbackTarget,
    'image': obj.image,
    'newTunnel': toJson_ClusterTunnelSpecNewTunnel(obj.newTunnel),
    'noTlsVerify': obj.noTlsVerify,
    'originCaPool': obj.originCaPool,
    'size': obj.size,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Cloudflare Credentials
 *
 * @schema ClusterTunnelSpecCloudflare
 */
export interface ClusterTunnelSpecCloudflare {
  /**
   * Key in the secret to use for Cloudflare API Key, defaults to CLOUDFLARE_API_KEY. Needs Email also to be provided. For Delete operations for new tunnels only, or as an alternate to API Token
   *
   * @schema ClusterTunnelSpecCloudflare#CLOUDFLARE_API_KEY
   */
  readonly cloudflareApiKey?: string;

  /**
   * Key in the secret to use for Cloudflare API token, defaults to CLOUDFLARE_API_TOKEN
   *
   * @schema ClusterTunnelSpecCloudflare#CLOUDFLARE_API_TOKEN
   */
  readonly cloudflareApiToken?: string;

  /**
   * Key in the secret to use as credentials.json for an existing tunnel, defaults to CLOUDFLARE_TUNNEL_CREDENTIAL_FILE
   *
   * @schema ClusterTunnelSpecCloudflare#CLOUDFLARE_TUNNEL_CREDENTIAL_FILE
   */
  readonly cloudflareTunnelCredentialFile?: string;

  /**
   * Key in the secret to use as tunnel secret for an existing tunnel, defaults to CLOUDFLARE_TUNNEL_CREDENTIAL_SECRET
   *
   * @schema ClusterTunnelSpecCloudflare#CLOUDFLARE_TUNNEL_CREDENTIAL_SECRET
   */
  readonly cloudflareTunnelCredentialSecret?: string;

  /**
   * Account ID in Cloudflare. AccountId and AccountName cannot be both empty. If both are provided, Account ID is used if valid, else falls back to Account Name.
   *
   * @schema ClusterTunnelSpecCloudflare#accountId
   */
  readonly accountId?: string;

  /**
   * Account Name in Cloudflare. AccountName and AccountId cannot be both empty. If both are provided, Account ID is used if valid, else falls back to Account Name.
   *
   * @schema ClusterTunnelSpecCloudflare#accountName
   */
  readonly accountName?: string;

  /**
   * Cloudflare Domain to which this tunnel belongs to
   *
   * @schema ClusterTunnelSpecCloudflare#domain
   */
  readonly domain?: string;

  /**
   * Email to use along with API Key for Delete operations for new tunnels only, or as an alternate to API Token
   *
   * @schema ClusterTunnelSpecCloudflare#email
   */
  readonly email?: string;

  /**
   * Secret containing Cloudflare API key/token
   *
   * @schema ClusterTunnelSpecCloudflare#secret
   */
  readonly secret?: string;

}

/**
 * Converts an object of type 'ClusterTunnelSpecCloudflare' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterTunnelSpecCloudflare(obj: ClusterTunnelSpecCloudflare | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'CLOUDFLARE_API_KEY': obj.cloudflareApiKey,
    'CLOUDFLARE_API_TOKEN': obj.cloudflareApiToken,
    'CLOUDFLARE_TUNNEL_CREDENTIAL_FILE': obj.cloudflareTunnelCredentialFile,
    'CLOUDFLARE_TUNNEL_CREDENTIAL_SECRET': obj.cloudflareTunnelCredentialSecret,
    'accountId': obj.accountId,
    'accountName': obj.accountName,
    'domain': obj.domain,
    'email': obj.email,
    'secret': obj.secret,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Existing tunnel object. ExistingTunnel and NewTunnel cannot be both empty and are mutually exclusive.
 *
 * @schema ClusterTunnelSpecExistingTunnel
 */
export interface ClusterTunnelSpecExistingTunnel {
  /**
   * Existing Tunnel ID to run on. Tunnel ID and Tunnel Name cannot be both empty. If both are provided, ID is used if valid, else falls back to Name.
   *
   * @schema ClusterTunnelSpecExistingTunnel#id
   */
  readonly id?: string;

  /**
   * Existing Tunnel name to run on. Tunnel Name and Tunnel ID cannot be both empty. If both are provided, ID is used if valid, else falls back to Name.
   *
   * @schema ClusterTunnelSpecExistingTunnel#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'ClusterTunnelSpecExistingTunnel' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterTunnelSpecExistingTunnel(obj: ClusterTunnelSpecExistingTunnel | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'id': obj.id,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * New tunnel object. NewTunnel and ExistingTunnel cannot be both empty and are mutually exclusive.
 *
 * @schema ClusterTunnelSpecNewTunnel
 */
export interface ClusterTunnelSpecNewTunnel {
  /**
   * Tunnel name to create on Cloudflare.
   *
   * @schema ClusterTunnelSpecNewTunnel#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'ClusterTunnelSpecNewTunnel' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterTunnelSpecNewTunnel(obj: ClusterTunnelSpecNewTunnel | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

