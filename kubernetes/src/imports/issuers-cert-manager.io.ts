// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * An Issuer represents a certificate issuing authority which can be
referenced as part of `issuerRef` fields.
It is scoped to a single namespace and can therefore only be referenced by
resources within the same namespace.
 *
 * @schema Issuer
 */
export class Issuer extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Issuer"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cert-manager.io/v1',
    kind: 'Issuer',
  }

  /**
   * Renders a Kubernetes manifest for "Issuer".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: IssuerProps): any {
    return {
      ...Issuer.GVK,
      ...toJson_IssuerProps(props),
    };
  }

  /**
   * Defines a "Issuer" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: IssuerProps) {
    super(scope, id, {
      ...Issuer.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Issuer.GVK,
      ...toJson_IssuerProps(resolved),
    };
  }
}

/**
 * An Issuer represents a certificate issuing authority which can be
 * referenced as part of `issuerRef` fields.
 * It is scoped to a single namespace and can therefore only be referenced by
 * resources within the same namespace.
 *
 * @schema Issuer
 */
export interface IssuerProps {
  /**
   * @schema Issuer#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Desired state of the Issuer resource.
   *
   * @schema Issuer#spec
   */
  readonly spec: IssuerSpec;

}

/**
 * Converts an object of type 'IssuerProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerProps(obj: IssuerProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_IssuerSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Desired state of the Issuer resource.
 *
 * @schema IssuerSpec
 */
export interface IssuerSpec {
  /**
   * ACME configures this issuer to communicate with a RFC8555 (ACME) server
   * to obtain signed x509 certificates.
   *
   * @schema IssuerSpec#acme
   */
  readonly acme?: IssuerSpecAcme;

  /**
   * CA configures this issuer to sign certificates using a signing CA keypair
   * stored in a Secret resource.
   * This is used to build internal PKIs that are managed by cert-manager.
   *
   * @schema IssuerSpec#ca
   */
  readonly ca?: IssuerSpecCa;

  /**
   * SelfSigned configures this issuer to 'self sign' certificates using the
   * private key used to create the CertificateRequest object.
   *
   * @schema IssuerSpec#selfSigned
   */
  readonly selfSigned?: IssuerSpecSelfSigned;

  /**
   * Vault configures this issuer to sign certificates using a HashiCorp Vault
   * PKI backend.
   *
   * @schema IssuerSpec#vault
   */
  readonly vault?: IssuerSpecVault;

  /**
   * Venafi configures this issuer to sign certificates using a Venafi TPP
   * or Venafi Cloud policy zone.
   *
   * @schema IssuerSpec#venafi
   */
  readonly venafi?: IssuerSpecVenafi;

}

/**
 * Converts an object of type 'IssuerSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpec(obj: IssuerSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'acme': toJson_IssuerSpecAcme(obj.acme),
    'ca': toJson_IssuerSpecCa(obj.ca),
    'selfSigned': toJson_IssuerSpecSelfSigned(obj.selfSigned),
    'vault': toJson_IssuerSpecVault(obj.vault),
    'venafi': toJson_IssuerSpecVenafi(obj.venafi),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ACME configures this issuer to communicate with a RFC8555 (ACME) server
 * to obtain signed x509 certificates.
 *
 * @schema IssuerSpecAcme
 */
export interface IssuerSpecAcme {
  /**
   * Base64-encoded bundle of PEM CAs which can be used to validate the certificate
   * chain presented by the ACME server.
   * Mutually exclusive with SkipTLSVerify; prefer using CABundle to prevent various
   * kinds of security vulnerabilities.
   * If CABundle and SkipTLSVerify are unset, the system certificate bundle inside
   * the container is used to validate the TLS connection.
   *
   * @schema IssuerSpecAcme#caBundle
   */
  readonly caBundle?: string;

  /**
   * Enables or disables generating a new ACME account key.
   * If true, the Issuer resource will *not* request a new account but will expect
   * the account key to be supplied via an existing secret.
   * If false, the cert-manager system will generate a new ACME account key
   * for the Issuer.
   * Defaults to false.
   *
   * @default false.
   * @schema IssuerSpecAcme#disableAccountKeyGeneration
   */
  readonly disableAccountKeyGeneration?: boolean;

  /**
   * Email is the email address to be associated with the ACME account.
   * This field is optional, but it is strongly recommended to be set.
   * It will be used to contact you in case of issues with your account or
   * certificates, including expiry notification emails.
   * This field may be updated after the account is initially registered.
   *
   * @schema IssuerSpecAcme#email
   */
  readonly email?: string;

  /**
   * Enables requesting a Not After date on certificates that matches the
   * duration of the certificate. This is not supported by all ACME servers
   * like Let's Encrypt. If set to true when the ACME server does not support
   * it, it will create an error on the Order.
   * Defaults to false.
   *
   * @default false.
   * @schema IssuerSpecAcme#enableDurationFeature
   */
  readonly enableDurationFeature?: boolean;

  /**
   * ExternalAccountBinding is a reference to a CA external account of the ACME
   * server.
   * If set, upon registration cert-manager will attempt to associate the given
   * external account credentials with the registered ACME account.
   *
   * @schema IssuerSpecAcme#externalAccountBinding
   */
  readonly externalAccountBinding?: IssuerSpecAcmeExternalAccountBinding;

  /**
   * PreferredChain is the chain to use if the ACME server outputs multiple.
   * PreferredChain is no guarantee that this one gets delivered by the ACME
   * endpoint.
   * For example, for Let's Encrypt's DST crosssign you would use:
   * "DST Root CA X3" or "ISRG Root X1" for the newer Let's Encrypt root CA.
   * This value picks the first certificate bundle in the combined set of
   * ACME default and alternative chains that has a root-most certificate with
   * this value as its issuer's commonname.
   *
   * @schema IssuerSpecAcme#preferredChain
   */
  readonly preferredChain?: string;

  /**
   * PrivateKey is the name of a Kubernetes Secret resource that will be used to
   * store the automatically generated ACME account private key.
   * Optionally, a `key` may be specified to select a specific entry within
   * the named Secret resource.
   * If `key` is not specified, a default of `tls.key` will be used.
   *
   * @schema IssuerSpecAcme#privateKeySecretRef
   */
  readonly privateKeySecretRef: IssuerSpecAcmePrivateKeySecretRef;

  /**
   * Server is the URL used to access the ACME server's 'directory' endpoint.
   * For example, for Let's Encrypt's staging endpoint, you would use:
   * "https://acme-staging-v02.api.letsencrypt.org/directory".
   * Only ACME v2 endpoints (i.e. RFC 8555) are supported.
   *
   * @schema IssuerSpecAcme#server
   */
  readonly server: string;

  /**
   * INSECURE: Enables or disables validation of the ACME server TLS certificate.
   * If true, requests to the ACME server will not have the TLS certificate chain
   * validated.
   * Mutually exclusive with CABundle; prefer using CABundle to prevent various
   * kinds of security vulnerabilities.
   * Only enable this option in development environments.
   * If CABundle and SkipTLSVerify are unset, the system certificate bundle inside
   * the container is used to validate the TLS connection.
   * Defaults to false.
   *
   * @default false.
   * @schema IssuerSpecAcme#skipTLSVerify
   */
  readonly skipTlsVerify?: boolean;

  /**
   * Solvers is a list of challenge solvers that will be used to solve
   * ACME challenges for the matching domains.
   * Solver configurations must be provided in order to obtain certificates
   * from an ACME server.
   * For more information, see: https://cert-manager.io/docs/configuration/acme/
   *
   * @schema IssuerSpecAcme#solvers
   */
  readonly solvers?: IssuerSpecAcmeSolvers[];

}

/**
 * Converts an object of type 'IssuerSpecAcme' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcme(obj: IssuerSpecAcme | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caBundle': obj.caBundle,
    'disableAccountKeyGeneration': obj.disableAccountKeyGeneration,
    'email': obj.email,
    'enableDurationFeature': obj.enableDurationFeature,
    'externalAccountBinding': toJson_IssuerSpecAcmeExternalAccountBinding(obj.externalAccountBinding),
    'preferredChain': obj.preferredChain,
    'privateKeySecretRef': toJson_IssuerSpecAcmePrivateKeySecretRef(obj.privateKeySecretRef),
    'server': obj.server,
    'skipTLSVerify': obj.skipTlsVerify,
    'solvers': obj.solvers?.map(y => toJson_IssuerSpecAcmeSolvers(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CA configures this issuer to sign certificates using a signing CA keypair
 * stored in a Secret resource.
 * This is used to build internal PKIs that are managed by cert-manager.
 *
 * @schema IssuerSpecCa
 */
export interface IssuerSpecCa {
  /**
   * The CRL distribution points is an X.509 v3 certificate extension which identifies
   * the location of the CRL from which the revocation of this certificate can be checked.
   * If not set, certificates will be issued without distribution points set.
   *
   * @schema IssuerSpecCa#crlDistributionPoints
   */
  readonly crlDistributionPoints?: string[];

  /**
   * IssuingCertificateURLs is a list of URLs which this issuer should embed into certificates
   * it creates. See https://www.rfc-editor.org/rfc/rfc5280#section-4.2.2.1 for more details.
   * As an example, such a URL might be "http://ca.domain.com/ca.crt".
   *
   * @schema IssuerSpecCa#issuingCertificateURLs
   */
  readonly issuingCertificateUrLs?: string[];

  /**
   * The OCSP server list is an X.509 v3 extension that defines a list of
   * URLs of OCSP responders. The OCSP responders can be queried for the
   * revocation status of an issued certificate. If not set, the
   * certificate will be issued with no OCSP servers set. For example, an
   * OCSP server URL could be "http://ocsp.int-x3.letsencrypt.org".
   *
   * @schema IssuerSpecCa#ocspServers
   */
  readonly ocspServers?: string[];

  /**
   * SecretName is the name of the secret used to sign Certificates issued
   * by this Issuer.
   *
   * @schema IssuerSpecCa#secretName
   */
  readonly secretName: string;

}

/**
 * Converts an object of type 'IssuerSpecCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecCa(obj: IssuerSpecCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'crlDistributionPoints': obj.crlDistributionPoints?.map(y => y),
    'issuingCertificateURLs': obj.issuingCertificateUrLs?.map(y => y),
    'ocspServers': obj.ocspServers?.map(y => y),
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SelfSigned configures this issuer to 'self sign' certificates using the
 * private key used to create the CertificateRequest object.
 *
 * @schema IssuerSpecSelfSigned
 */
export interface IssuerSpecSelfSigned {
  /**
   * The CRL distribution points is an X.509 v3 certificate extension which identifies
   * the location of the CRL from which the revocation of this certificate can be checked.
   * If not set certificate will be issued without CDP. Values are strings.
   *
   * @schema IssuerSpecSelfSigned#crlDistributionPoints
   */
  readonly crlDistributionPoints?: string[];

}

/**
 * Converts an object of type 'IssuerSpecSelfSigned' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecSelfSigned(obj: IssuerSpecSelfSigned | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'crlDistributionPoints': obj.crlDistributionPoints?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Vault configures this issuer to sign certificates using a HashiCorp Vault
 * PKI backend.
 *
 * @schema IssuerSpecVault
 */
export interface IssuerSpecVault {
  /**
   * Auth configures how cert-manager authenticates with the Vault server.
   *
   * @schema IssuerSpecVault#auth
   */
  readonly auth: IssuerSpecVaultAuth;

  /**
   * Base64-encoded bundle of PEM CAs which will be used to validate the certificate
   * chain presented by Vault. Only used if using HTTPS to connect to Vault and
   * ignored for HTTP connections.
   * Mutually exclusive with CABundleSecretRef.
   * If neither CABundle nor CABundleSecretRef are defined, the certificate bundle in
   * the cert-manager controller container is used to validate the TLS connection.
   *
   * @schema IssuerSpecVault#caBundle
   */
  readonly caBundle?: string;

  /**
   * Reference to a Secret containing a bundle of PEM-encoded CAs to use when
   * verifying the certificate chain presented by Vault when using HTTPS.
   * Mutually exclusive with CABundle.
   * If neither CABundle nor CABundleSecretRef are defined, the certificate bundle in
   * the cert-manager controller container is used to validate the TLS connection.
   * If no key for the Secret is specified, cert-manager will default to 'ca.crt'.
   *
   * @schema IssuerSpecVault#caBundleSecretRef
   */
  readonly caBundleSecretRef?: IssuerSpecVaultCaBundleSecretRef;

  /**
   * Reference to a Secret containing a PEM-encoded Client Certificate to use when the
   * Vault server requires mTLS.
   *
   * @schema IssuerSpecVault#clientCertSecretRef
   */
  readonly clientCertSecretRef?: IssuerSpecVaultClientCertSecretRef;

  /**
   * Reference to a Secret containing a PEM-encoded Client Private Key to use when the
   * Vault server requires mTLS.
   *
   * @schema IssuerSpecVault#clientKeySecretRef
   */
  readonly clientKeySecretRef?: IssuerSpecVaultClientKeySecretRef;

  /**
   * Name of the vault namespace. Namespaces is a set of features within Vault Enterprise that allows Vault environments to support Secure Multi-tenancy. e.g: "ns1"
   * More about namespaces can be found here https://www.vaultproject.io/docs/enterprise/namespaces
   *
   * @schema IssuerSpecVault#namespace
   */
  readonly namespace?: string;

  /**
   * Path is the mount path of the Vault PKI backend's `sign` endpoint, e.g:
   * "my_pki_mount/sign/my-role-name".
   *
   * @schema IssuerSpecVault#path
   */
  readonly path: string;

  /**
   * Server is the connection address for the Vault server, e.g: "https://vault.example.com:8200".
   *
   * @schema IssuerSpecVault#server
   */
  readonly server: string;

}

/**
 * Converts an object of type 'IssuerSpecVault' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecVault(obj: IssuerSpecVault | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_IssuerSpecVaultAuth(obj.auth),
    'caBundle': obj.caBundle,
    'caBundleSecretRef': toJson_IssuerSpecVaultCaBundleSecretRef(obj.caBundleSecretRef),
    'clientCertSecretRef': toJson_IssuerSpecVaultClientCertSecretRef(obj.clientCertSecretRef),
    'clientKeySecretRef': toJson_IssuerSpecVaultClientKeySecretRef(obj.clientKeySecretRef),
    'namespace': obj.namespace,
    'path': obj.path,
    'server': obj.server,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Venafi configures this issuer to sign certificates using a Venafi TPP
 * or Venafi Cloud policy zone.
 *
 * @schema IssuerSpecVenafi
 */
export interface IssuerSpecVenafi {
  /**
   * Cloud specifies the Venafi cloud configuration settings.
   * Only one of TPP or Cloud may be specified.
   *
   * @schema IssuerSpecVenafi#cloud
   */
  readonly cloud?: IssuerSpecVenafiCloud;

  /**
   * TPP specifies Trust Protection Platform configuration settings.
   * Only one of TPP or Cloud may be specified.
   *
   * @schema IssuerSpecVenafi#tpp
   */
  readonly tpp?: IssuerSpecVenafiTpp;

  /**
   * Zone is the Venafi Policy Zone to use for this issuer.
   * All requests made to the Venafi platform will be restricted by the named
   * zone policy.
   * This field is required.
   *
   * @schema IssuerSpecVenafi#zone
   */
  readonly zone: string;

}

/**
 * Converts an object of type 'IssuerSpecVenafi' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecVenafi(obj: IssuerSpecVenafi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloud': toJson_IssuerSpecVenafiCloud(obj.cloud),
    'tpp': toJson_IssuerSpecVenafiTpp(obj.tpp),
    'zone': obj.zone,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ExternalAccountBinding is a reference to a CA external account of the ACME
 * server.
 * If set, upon registration cert-manager will attempt to associate the given
 * external account credentials with the registered ACME account.
 *
 * @schema IssuerSpecAcmeExternalAccountBinding
 */
export interface IssuerSpecAcmeExternalAccountBinding {
  /**
   * Deprecated: keyAlgorithm field exists for historical compatibility
   * reasons and should not be used. The algorithm is now hardcoded to HS256
   * in golang/x/crypto/acme.
   *
   * @schema IssuerSpecAcmeExternalAccountBinding#keyAlgorithm
   */
  readonly keyAlgorithm?: IssuerSpecAcmeExternalAccountBindingKeyAlgorithm;

  /**
   * keyID is the ID of the CA key that the External Account is bound to.
   *
   * @schema IssuerSpecAcmeExternalAccountBinding#keyID
   */
  readonly keyId: string;

  /**
   * keySecretRef is a Secret Key Selector referencing a data item in a Kubernetes
   * Secret which holds the symmetric MAC key of the External Account Binding.
   * The `key` is the index string that is paired with the key data in the
   * Secret and should not be confused with the key data itself, or indeed with
   * the External Account Binding keyID above.
   * The secret key stored in the Secret **must** be un-padded, base64 URL
   * encoded data.
   *
   * @schema IssuerSpecAcmeExternalAccountBinding#keySecretRef
   */
  readonly keySecretRef: IssuerSpecAcmeExternalAccountBindingKeySecretRef;

}

/**
 * Converts an object of type 'IssuerSpecAcmeExternalAccountBinding' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeExternalAccountBinding(obj: IssuerSpecAcmeExternalAccountBinding | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'keyAlgorithm': obj.keyAlgorithm,
    'keyID': obj.keyId,
    'keySecretRef': toJson_IssuerSpecAcmeExternalAccountBindingKeySecretRef(obj.keySecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PrivateKey is the name of a Kubernetes Secret resource that will be used to
 * store the automatically generated ACME account private key.
 * Optionally, a `key` may be specified to select a specific entry within
 * the named Secret resource.
 * If `key` is not specified, a default of `tls.key` will be used.
 *
 * @schema IssuerSpecAcmePrivateKeySecretRef
 */
export interface IssuerSpecAcmePrivateKeySecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used.
   * Some instances of this field may be defaulted, in others it may be
   * required.
   *
   * @schema IssuerSpecAcmePrivateKeySecretRef#key
   */
  readonly key?: string;

  /**
   * Name of the resource being referred to.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema IssuerSpecAcmePrivateKeySecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'IssuerSpecAcmePrivateKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmePrivateKeySecretRef(obj: IssuerSpecAcmePrivateKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * An ACMEChallengeSolver describes how to solve ACME challenges for the issuer it is part of.
 * A selector may be provided to use different solving strategies for different DNS names.
 * Only one of HTTP01 or DNS01 must be provided.
 *
 * @schema IssuerSpecAcmeSolvers
 */
export interface IssuerSpecAcmeSolvers {
  /**
   * Configures cert-manager to attempt to complete authorizations by
   * performing the DNS01 challenge flow.
   *
   * @schema IssuerSpecAcmeSolvers#dns01
   */
  readonly dns01?: IssuerSpecAcmeSolversDns01;

  /**
   * Configures cert-manager to attempt to complete authorizations by
   * performing the HTTP01 challenge flow.
   * It is not possible to obtain certificates for wildcard domain names
   * (e.g. `*.example.com`) using the HTTP01 challenge mechanism.
   *
   * @schema IssuerSpecAcmeSolvers#http01
   */
  readonly http01?: IssuerSpecAcmeSolversHttp01;

  /**
   * Selector selects a set of DNSNames on the Certificate resource that
   * should be solved using this challenge solver.
   * If not specified, the solver will be treated as the 'default' solver
   * with the lowest priority, i.e. if any other solver has a more specific
   * match, it will be used instead.
   *
   * @schema IssuerSpecAcmeSolvers#selector
   */
  readonly selector?: IssuerSpecAcmeSolversSelector;

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolvers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolvers(obj: IssuerSpecAcmeSolvers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dns01': toJson_IssuerSpecAcmeSolversDns01(obj.dns01),
    'http01': toJson_IssuerSpecAcmeSolversHttp01(obj.http01),
    'selector': toJson_IssuerSpecAcmeSolversSelector(obj.selector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Auth configures how cert-manager authenticates with the Vault server.
 *
 * @schema IssuerSpecVaultAuth
 */
export interface IssuerSpecVaultAuth {
  /**
   * AppRole authenticates with Vault using the App Role auth mechanism,
   * with the role and secret stored in a Kubernetes Secret resource.
   *
   * @schema IssuerSpecVaultAuth#appRole
   */
  readonly appRole?: IssuerSpecVaultAuthAppRole;

  /**
   * ClientCertificate authenticates with Vault by presenting a client
   * certificate during the request's TLS handshake.
   * Works only when using HTTPS protocol.
   *
   * @schema IssuerSpecVaultAuth#clientCertificate
   */
  readonly clientCertificate?: IssuerSpecVaultAuthClientCertificate;

  /**
   * Kubernetes authenticates with Vault by passing the ServiceAccount
   * token stored in the named Secret resource to the Vault server.
   *
   * @schema IssuerSpecVaultAuth#kubernetes
   */
  readonly kubernetes?: IssuerSpecVaultAuthKubernetes;

  /**
   * TokenSecretRef authenticates with Vault by presenting a token.
   *
   * @schema IssuerSpecVaultAuth#tokenSecretRef
   */
  readonly tokenSecretRef?: IssuerSpecVaultAuthTokenSecretRef;

}

/**
 * Converts an object of type 'IssuerSpecVaultAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecVaultAuth(obj: IssuerSpecVaultAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'appRole': toJson_IssuerSpecVaultAuthAppRole(obj.appRole),
    'clientCertificate': toJson_IssuerSpecVaultAuthClientCertificate(obj.clientCertificate),
    'kubernetes': toJson_IssuerSpecVaultAuthKubernetes(obj.kubernetes),
    'tokenSecretRef': toJson_IssuerSpecVaultAuthTokenSecretRef(obj.tokenSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Secret containing a bundle of PEM-encoded CAs to use when
 * verifying the certificate chain presented by Vault when using HTTPS.
 * Mutually exclusive with CABundle.
 * If neither CABundle nor CABundleSecretRef are defined, the certificate bundle in
 * the cert-manager controller container is used to validate the TLS connection.
 * If no key for the Secret is specified, cert-manager will default to 'ca.crt'.
 *
 * @schema IssuerSpecVaultCaBundleSecretRef
 */
export interface IssuerSpecVaultCaBundleSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used.
   * Some instances of this field may be defaulted, in others it may be
   * required.
   *
   * @schema IssuerSpecVaultCaBundleSecretRef#key
   */
  readonly key?: string;

  /**
   * Name of the resource being referred to.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema IssuerSpecVaultCaBundleSecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'IssuerSpecVaultCaBundleSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecVaultCaBundleSecretRef(obj: IssuerSpecVaultCaBundleSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Secret containing a PEM-encoded Client Certificate to use when the
 * Vault server requires mTLS.
 *
 * @schema IssuerSpecVaultClientCertSecretRef
 */
export interface IssuerSpecVaultClientCertSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used.
   * Some instances of this field may be defaulted, in others it may be
   * required.
   *
   * @schema IssuerSpecVaultClientCertSecretRef#key
   */
  readonly key?: string;

  /**
   * Name of the resource being referred to.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema IssuerSpecVaultClientCertSecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'IssuerSpecVaultClientCertSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecVaultClientCertSecretRef(obj: IssuerSpecVaultClientCertSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Secret containing a PEM-encoded Client Private Key to use when the
 * Vault server requires mTLS.
 *
 * @schema IssuerSpecVaultClientKeySecretRef
 */
export interface IssuerSpecVaultClientKeySecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used.
   * Some instances of this field may be defaulted, in others it may be
   * required.
   *
   * @schema IssuerSpecVaultClientKeySecretRef#key
   */
  readonly key?: string;

  /**
   * Name of the resource being referred to.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema IssuerSpecVaultClientKeySecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'IssuerSpecVaultClientKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecVaultClientKeySecretRef(obj: IssuerSpecVaultClientKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Cloud specifies the Venafi cloud configuration settings.
 * Only one of TPP or Cloud may be specified.
 *
 * @schema IssuerSpecVenafiCloud
 */
export interface IssuerSpecVenafiCloud {
  /**
   * APITokenSecretRef is a secret key selector for the Venafi Cloud API token.
   *
   * @schema IssuerSpecVenafiCloud#apiTokenSecretRef
   */
  readonly apiTokenSecretRef: IssuerSpecVenafiCloudApiTokenSecretRef;

  /**
   * URL is the base URL for Venafi Cloud.
   * Defaults to "https://api.venafi.cloud/v1".
   *
   * @default https://api.venafi.cloud/v1".
   * @schema IssuerSpecVenafiCloud#url
   */
  readonly url?: string;

}

/**
 * Converts an object of type 'IssuerSpecVenafiCloud' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecVenafiCloud(obj: IssuerSpecVenafiCloud | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiTokenSecretRef': toJson_IssuerSpecVenafiCloudApiTokenSecretRef(obj.apiTokenSecretRef),
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TPP specifies Trust Protection Platform configuration settings.
 * Only one of TPP or Cloud may be specified.
 *
 * @schema IssuerSpecVenafiTpp
 */
export interface IssuerSpecVenafiTpp {
  /**
   * Base64-encoded bundle of PEM CAs which will be used to validate the certificate
   * chain presented by the TPP server. Only used if using HTTPS; ignored for HTTP.
   * If undefined, the certificate bundle in the cert-manager controller container
   * is used to validate the chain.
   *
   * @schema IssuerSpecVenafiTpp#caBundle
   */
  readonly caBundle?: string;

  /**
   * Reference to a Secret containing a base64-encoded bundle of PEM CAs
   * which will be used to validate the certificate chain presented by the TPP server.
   * Only used if using HTTPS; ignored for HTTP. Mutually exclusive with CABundle.
   * If neither CABundle nor CABundleSecretRef is defined, the certificate bundle in
   * the cert-manager controller container is used to validate the TLS connection.
   *
   * @schema IssuerSpecVenafiTpp#caBundleSecretRef
   */
  readonly caBundleSecretRef?: IssuerSpecVenafiTppCaBundleSecretRef;

  /**
   * CredentialsRef is a reference to a Secret containing the Venafi TPP API credentials.
   * The secret must contain the key 'access-token' for the Access Token Authentication,
   * or two keys, 'username' and 'password' for the API Keys Authentication.
   *
   * @schema IssuerSpecVenafiTpp#credentialsRef
   */
  readonly credentialsRef: IssuerSpecVenafiTppCredentialsRef;

  /**
   * URL is the base URL for the vedsdk endpoint of the Venafi TPP instance,
   * for example: "https://tpp.example.com/vedsdk".
   *
   * @schema IssuerSpecVenafiTpp#url
   */
  readonly url: string;

}

/**
 * Converts an object of type 'IssuerSpecVenafiTpp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecVenafiTpp(obj: IssuerSpecVenafiTpp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caBundle': obj.caBundle,
    'caBundleSecretRef': toJson_IssuerSpecVenafiTppCaBundleSecretRef(obj.caBundleSecretRef),
    'credentialsRef': toJson_IssuerSpecVenafiTppCredentialsRef(obj.credentialsRef),
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Deprecated: keyAlgorithm field exists for historical compatibility
 * reasons and should not be used. The algorithm is now hardcoded to HS256
 * in golang/x/crypto/acme.
 *
 * @schema IssuerSpecAcmeExternalAccountBindingKeyAlgorithm
 */
export enum IssuerSpecAcmeExternalAccountBindingKeyAlgorithm {
  /** HS256 */
  HS256 = "HS256",
  /** HS384 */
  HS384 = "HS384",
  /** HS512 */
  HS512 = "HS512",
}

/**
 * keySecretRef is a Secret Key Selector referencing a data item in a Kubernetes
 * Secret which holds the symmetric MAC key of the External Account Binding.
 * The `key` is the index string that is paired with the key data in the
 * Secret and should not be confused with the key data itself, or indeed with
 * the External Account Binding keyID above.
 * The secret key stored in the Secret **must** be un-padded, base64 URL
 * encoded data.
 *
 * @schema IssuerSpecAcmeExternalAccountBindingKeySecretRef
 */
export interface IssuerSpecAcmeExternalAccountBindingKeySecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used.
   * Some instances of this field may be defaulted, in others it may be
   * required.
   *
   * @schema IssuerSpecAcmeExternalAccountBindingKeySecretRef#key
   */
  readonly key?: string;

  /**
   * Name of the resource being referred to.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema IssuerSpecAcmeExternalAccountBindingKeySecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'IssuerSpecAcmeExternalAccountBindingKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeExternalAccountBindingKeySecretRef(obj: IssuerSpecAcmeExternalAccountBindingKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configures cert-manager to attempt to complete authorizations by
 * performing the DNS01 challenge flow.
 *
 * @schema IssuerSpecAcmeSolversDns01
 */
export interface IssuerSpecAcmeSolversDns01 {
  /**
   * Use the 'ACME DNS' (https://github.com/joohoi/acme-dns) API to manage
   * DNS01 challenge records.
   *
   * @schema IssuerSpecAcmeSolversDns01#acmeDNS
   */
  readonly acmeDns?: IssuerSpecAcmeSolversDns01AcmeDns;

  /**
   * Use the Akamai DNS zone management API to manage DNS01 challenge records.
   *
   * @schema IssuerSpecAcmeSolversDns01#akamai
   */
  readonly akamai?: IssuerSpecAcmeSolversDns01Akamai;

  /**
   * Use the Microsoft Azure DNS API to manage DNS01 challenge records.
   *
   * @schema IssuerSpecAcmeSolversDns01#azureDNS
   */
  readonly azureDns?: IssuerSpecAcmeSolversDns01AzureDns;

  /**
   * Use the Google Cloud DNS API to manage DNS01 challenge records.
   *
   * @schema IssuerSpecAcmeSolversDns01#cloudDNS
   */
  readonly cloudDns?: IssuerSpecAcmeSolversDns01CloudDns;

  /**
   * Use the Cloudflare API to manage DNS01 challenge records.
   *
   * @schema IssuerSpecAcmeSolversDns01#cloudflare
   */
  readonly cloudflare?: IssuerSpecAcmeSolversDns01Cloudflare;

  /**
   * CNAMEStrategy configures how the DNS01 provider should handle CNAME
   * records when found in DNS zones.
   *
   * @schema IssuerSpecAcmeSolversDns01#cnameStrategy
   */
  readonly cnameStrategy?: IssuerSpecAcmeSolversDns01CnameStrategy;

  /**
   * Use the DigitalOcean DNS API to manage DNS01 challenge records.
   *
   * @schema IssuerSpecAcmeSolversDns01#digitalocean
   */
  readonly digitalocean?: IssuerSpecAcmeSolversDns01Digitalocean;

  /**
   * Use RFC2136 ("Dynamic Updates in the Domain Name System") (https://datatracker.ietf.org/doc/rfc2136/)
   * to manage DNS01 challenge records.
   *
   * @schema IssuerSpecAcmeSolversDns01#rfc2136
   */
  readonly rfc2136?: IssuerSpecAcmeSolversDns01Rfc2136;

  /**
   * Use the AWS Route53 API to manage DNS01 challenge records.
   *
   * @schema IssuerSpecAcmeSolversDns01#route53
   */
  readonly route53?: IssuerSpecAcmeSolversDns01Route53;

  /**
   * Configure an external webhook based DNS01 challenge solver to manage
   * DNS01 challenge records.
   *
   * @schema IssuerSpecAcmeSolversDns01#webhook
   */
  readonly webhook?: IssuerSpecAcmeSolversDns01Webhook;

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversDns01' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversDns01(obj: IssuerSpecAcmeSolversDns01 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'acmeDNS': toJson_IssuerSpecAcmeSolversDns01AcmeDns(obj.acmeDns),
    'akamai': toJson_IssuerSpecAcmeSolversDns01Akamai(obj.akamai),
    'azureDNS': toJson_IssuerSpecAcmeSolversDns01AzureDns(obj.azureDns),
    'cloudDNS': toJson_IssuerSpecAcmeSolversDns01CloudDns(obj.cloudDns),
    'cloudflare': toJson_IssuerSpecAcmeSolversDns01Cloudflare(obj.cloudflare),
    'cnameStrategy': obj.cnameStrategy,
    'digitalocean': toJson_IssuerSpecAcmeSolversDns01Digitalocean(obj.digitalocean),
    'rfc2136': toJson_IssuerSpecAcmeSolversDns01Rfc2136(obj.rfc2136),
    'route53': toJson_IssuerSpecAcmeSolversDns01Route53(obj.route53),
    'webhook': toJson_IssuerSpecAcmeSolversDns01Webhook(obj.webhook),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configures cert-manager to attempt to complete authorizations by
 * performing the HTTP01 challenge flow.
 * It is not possible to obtain certificates for wildcard domain names
 * (e.g. `*.example.com`) using the HTTP01 challenge mechanism.
 *
 * @schema IssuerSpecAcmeSolversHttp01
 */
export interface IssuerSpecAcmeSolversHttp01 {
  /**
   * The Gateway API is a sig-network community API that models service networking
   * in Kubernetes (https://gateway-api.sigs.k8s.io/). The Gateway solver will
   * create HTTPRoutes with the specified labels in the same namespace as the challenge.
   * This solver is experimental, and fields / behaviour may change in the future.
   *
   * @schema IssuerSpecAcmeSolversHttp01#gatewayHTTPRoute
   */
  readonly gatewayHttpRoute?: IssuerSpecAcmeSolversHttp01GatewayHttpRoute;

  /**
   * The ingress based HTTP01 challenge solver will solve challenges by
   * creating or modifying Ingress resources in order to route requests for
   * '/.well-known/acme-challenge/XYZ' to 'challenge solver' pods that are
   * provisioned by cert-manager for each Challenge to be completed.
   *
   * @schema IssuerSpecAcmeSolversHttp01#ingress
   */
  readonly ingress?: IssuerSpecAcmeSolversHttp01Ingress;

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01(obj: IssuerSpecAcmeSolversHttp01 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gatewayHTTPRoute': toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoute(obj.gatewayHttpRoute),
    'ingress': toJson_IssuerSpecAcmeSolversHttp01Ingress(obj.ingress),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector selects a set of DNSNames on the Certificate resource that
 * should be solved using this challenge solver.
 * If not specified, the solver will be treated as the 'default' solver
 * with the lowest priority, i.e. if any other solver has a more specific
 * match, it will be used instead.
 *
 * @schema IssuerSpecAcmeSolversSelector
 */
export interface IssuerSpecAcmeSolversSelector {
  /**
   * List of DNSNames that this solver will be used to solve.
   * If specified and a match is found, a dnsNames selector will take
   * precedence over a dnsZones selector.
   * If multiple solvers match with the same dnsNames value, the solver
   * with the most matching labels in matchLabels will be selected.
   * If neither has more matches, the solver defined earlier in the list
   * will be selected.
   *
   * @schema IssuerSpecAcmeSolversSelector#dnsNames
   */
  readonly dnsNames?: string[];

  /**
   * List of DNSZones that this solver will be used to solve.
   * The most specific DNS zone match specified here will take precedence
   * over other DNS zone matches, so a solver specifying sys.example.com
   * will be selected over one specifying example.com for the domain
   * www.sys.example.com.
   * If multiple solvers match with the same dnsZones value, the solver
   * with the most matching labels in matchLabels will be selected.
   * If neither has more matches, the solver defined earlier in the list
   * will be selected.
   *
   * @schema IssuerSpecAcmeSolversSelector#dnsZones
   */
  readonly dnsZones?: string[];

  /**
   * A label selector that is used to refine the set of certificate's that
   * this challenge solver will apply to.
   *
   * @schema IssuerSpecAcmeSolversSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversSelector(obj: IssuerSpecAcmeSolversSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dnsNames': obj.dnsNames?.map(y => y),
    'dnsZones': obj.dnsZones?.map(y => y),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AppRole authenticates with Vault using the App Role auth mechanism,
 * with the role and secret stored in a Kubernetes Secret resource.
 *
 * @schema IssuerSpecVaultAuthAppRole
 */
export interface IssuerSpecVaultAuthAppRole {
  /**
   * Path where the App Role authentication backend is mounted in Vault, e.g:
   * "approle"
   *
   * @schema IssuerSpecVaultAuthAppRole#path
   */
  readonly path: string;

  /**
   * RoleID configured in the App Role authentication backend when setting
   * up the authentication backend in Vault.
   *
   * @schema IssuerSpecVaultAuthAppRole#roleId
   */
  readonly roleId: string;

  /**
   * Reference to a key in a Secret that contains the App Role secret used
   * to authenticate with Vault.
   * The `key` field must be specified and denotes which entry within the Secret
   * resource is used as the app role secret.
   *
   * @schema IssuerSpecVaultAuthAppRole#secretRef
   */
  readonly secretRef: IssuerSpecVaultAuthAppRoleSecretRef;

}

/**
 * Converts an object of type 'IssuerSpecVaultAuthAppRole' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecVaultAuthAppRole(obj: IssuerSpecVaultAuthAppRole | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'roleId': obj.roleId,
    'secretRef': toJson_IssuerSpecVaultAuthAppRoleSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ClientCertificate authenticates with Vault by presenting a client
 * certificate during the request's TLS handshake.
 * Works only when using HTTPS protocol.
 *
 * @schema IssuerSpecVaultAuthClientCertificate
 */
export interface IssuerSpecVaultAuthClientCertificate {
  /**
   * The Vault mountPath here is the mount path to use when authenticating with
   * Vault. For example, setting a value to `/v1/auth/foo`, will use the path
   * `/v1/auth/foo/login` to authenticate with Vault. If unspecified, the
   * default value "/v1/auth/cert" will be used.
   *
   * @schema IssuerSpecVaultAuthClientCertificate#mountPath
   */
  readonly mountPath?: string;

  /**
   * Name of the certificate role to authenticate against.
   * If not set, matching any certificate role, if available.
   *
   * @schema IssuerSpecVaultAuthClientCertificate#name
   */
  readonly name?: string;

  /**
   * Reference to Kubernetes Secret of type "kubernetes.io/tls" (hence containing
   * tls.crt and tls.key) used to authenticate to Vault using TLS client
   * authentication.
   *
   * @schema IssuerSpecVaultAuthClientCertificate#secretName
   */
  readonly secretName?: string;

}

/**
 * Converts an object of type 'IssuerSpecVaultAuthClientCertificate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecVaultAuthClientCertificate(obj: IssuerSpecVaultAuthClientCertificate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'name': obj.name,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Kubernetes authenticates with Vault by passing the ServiceAccount
 * token stored in the named Secret resource to the Vault server.
 *
 * @schema IssuerSpecVaultAuthKubernetes
 */
export interface IssuerSpecVaultAuthKubernetes {
  /**
   * The Vault mountPath here is the mount path to use when authenticating with
   * Vault. For example, setting a value to `/v1/auth/foo`, will use the path
   * `/v1/auth/foo/login` to authenticate with Vault. If unspecified, the
   * default value "/v1/auth/kubernetes" will be used.
   *
   * @schema IssuerSpecVaultAuthKubernetes#mountPath
   */
  readonly mountPath?: string;

  /**
   * A required field containing the Vault Role to assume. A Role binds a
   * Kubernetes ServiceAccount with a set of Vault policies.
   *
   * @schema IssuerSpecVaultAuthKubernetes#role
   */
  readonly role: string;

  /**
   * The required Secret field containing a Kubernetes ServiceAccount JWT used
   * for authenticating with Vault. Use of 'ambient credentials' is not
   * supported.
   *
   * @schema IssuerSpecVaultAuthKubernetes#secretRef
   */
  readonly secretRef?: IssuerSpecVaultAuthKubernetesSecretRef;

  /**
   * A reference to a service account that will be used to request a bound
   * token (also known as "projected token"). Compared to using "secretRef",
   * using this field means that you don't rely on statically bound tokens. To
   * use this field, you must configure an RBAC rule to let cert-manager
   * request a token.
   *
   * @schema IssuerSpecVaultAuthKubernetes#serviceAccountRef
   */
  readonly serviceAccountRef?: IssuerSpecVaultAuthKubernetesServiceAccountRef;

}

/**
 * Converts an object of type 'IssuerSpecVaultAuthKubernetes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecVaultAuthKubernetes(obj: IssuerSpecVaultAuthKubernetes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'role': obj.role,
    'secretRef': toJson_IssuerSpecVaultAuthKubernetesSecretRef(obj.secretRef),
    'serviceAccountRef': toJson_IssuerSpecVaultAuthKubernetesServiceAccountRef(obj.serviceAccountRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TokenSecretRef authenticates with Vault by presenting a token.
 *
 * @schema IssuerSpecVaultAuthTokenSecretRef
 */
export interface IssuerSpecVaultAuthTokenSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used.
   * Some instances of this field may be defaulted, in others it may be
   * required.
   *
   * @schema IssuerSpecVaultAuthTokenSecretRef#key
   */
  readonly key?: string;

  /**
   * Name of the resource being referred to.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema IssuerSpecVaultAuthTokenSecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'IssuerSpecVaultAuthTokenSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecVaultAuthTokenSecretRef(obj: IssuerSpecVaultAuthTokenSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * APITokenSecretRef is a secret key selector for the Venafi Cloud API token.
 *
 * @schema IssuerSpecVenafiCloudApiTokenSecretRef
 */
export interface IssuerSpecVenafiCloudApiTokenSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used.
   * Some instances of this field may be defaulted, in others it may be
   * required.
   *
   * @schema IssuerSpecVenafiCloudApiTokenSecretRef#key
   */
  readonly key?: string;

  /**
   * Name of the resource being referred to.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema IssuerSpecVenafiCloudApiTokenSecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'IssuerSpecVenafiCloudApiTokenSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecVenafiCloudApiTokenSecretRef(obj: IssuerSpecVenafiCloudApiTokenSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Secret containing a base64-encoded bundle of PEM CAs
 * which will be used to validate the certificate chain presented by the TPP server.
 * Only used if using HTTPS; ignored for HTTP. Mutually exclusive with CABundle.
 * If neither CABundle nor CABundleSecretRef is defined, the certificate bundle in
 * the cert-manager controller container is used to validate the TLS connection.
 *
 * @schema IssuerSpecVenafiTppCaBundleSecretRef
 */
export interface IssuerSpecVenafiTppCaBundleSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used.
   * Some instances of this field may be defaulted, in others it may be
   * required.
   *
   * @schema IssuerSpecVenafiTppCaBundleSecretRef#key
   */
  readonly key?: string;

  /**
   * Name of the resource being referred to.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema IssuerSpecVenafiTppCaBundleSecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'IssuerSpecVenafiTppCaBundleSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecVenafiTppCaBundleSecretRef(obj: IssuerSpecVenafiTppCaBundleSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CredentialsRef is a reference to a Secret containing the Venafi TPP API credentials.
 * The secret must contain the key 'access-token' for the Access Token Authentication,
 * or two keys, 'username' and 'password' for the API Keys Authentication.
 *
 * @schema IssuerSpecVenafiTppCredentialsRef
 */
export interface IssuerSpecVenafiTppCredentialsRef {
  /**
   * Name of the resource being referred to.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema IssuerSpecVenafiTppCredentialsRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'IssuerSpecVenafiTppCredentialsRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecVenafiTppCredentialsRef(obj: IssuerSpecVenafiTppCredentialsRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Use the 'ACME DNS' (https://github.com/joohoi/acme-dns) API to manage
 * DNS01 challenge records.
 *
 * @schema IssuerSpecAcmeSolversDns01AcmeDns
 */
export interface IssuerSpecAcmeSolversDns01AcmeDns {
  /**
   * A reference to a specific 'key' within a Secret resource.
   * In some instances, `key` is a required field.
   *
   * @schema IssuerSpecAcmeSolversDns01AcmeDns#accountSecretRef
   */
  readonly accountSecretRef: IssuerSpecAcmeSolversDns01AcmeDnsAccountSecretRef;

  /**
   * @schema IssuerSpecAcmeSolversDns01AcmeDns#host
   */
  readonly host: string;

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversDns01AcmeDns' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversDns01AcmeDns(obj: IssuerSpecAcmeSolversDns01AcmeDns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accountSecretRef': toJson_IssuerSpecAcmeSolversDns01AcmeDnsAccountSecretRef(obj.accountSecretRef),
    'host': obj.host,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Use the Akamai DNS zone management API to manage DNS01 challenge records.
 *
 * @schema IssuerSpecAcmeSolversDns01Akamai
 */
export interface IssuerSpecAcmeSolversDns01Akamai {
  /**
   * A reference to a specific 'key' within a Secret resource.
   * In some instances, `key` is a required field.
   *
   * @schema IssuerSpecAcmeSolversDns01Akamai#accessTokenSecretRef
   */
  readonly accessTokenSecretRef: IssuerSpecAcmeSolversDns01AkamaiAccessTokenSecretRef;

  /**
   * A reference to a specific 'key' within a Secret resource.
   * In some instances, `key` is a required field.
   *
   * @schema IssuerSpecAcmeSolversDns01Akamai#clientSecretSecretRef
   */
  readonly clientSecretSecretRef: IssuerSpecAcmeSolversDns01AkamaiClientSecretSecretRef;

  /**
   * A reference to a specific 'key' within a Secret resource.
   * In some instances, `key` is a required field.
   *
   * @schema IssuerSpecAcmeSolversDns01Akamai#clientTokenSecretRef
   */
  readonly clientTokenSecretRef: IssuerSpecAcmeSolversDns01AkamaiClientTokenSecretRef;

  /**
   * @schema IssuerSpecAcmeSolversDns01Akamai#serviceConsumerDomain
   */
  readonly serviceConsumerDomain: string;

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversDns01Akamai' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversDns01Akamai(obj: IssuerSpecAcmeSolversDns01Akamai | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessTokenSecretRef': toJson_IssuerSpecAcmeSolversDns01AkamaiAccessTokenSecretRef(obj.accessTokenSecretRef),
    'clientSecretSecretRef': toJson_IssuerSpecAcmeSolversDns01AkamaiClientSecretSecretRef(obj.clientSecretSecretRef),
    'clientTokenSecretRef': toJson_IssuerSpecAcmeSolversDns01AkamaiClientTokenSecretRef(obj.clientTokenSecretRef),
    'serviceConsumerDomain': obj.serviceConsumerDomain,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Use the Microsoft Azure DNS API to manage DNS01 challenge records.
 *
 * @schema IssuerSpecAcmeSolversDns01AzureDns
 */
export interface IssuerSpecAcmeSolversDns01AzureDns {
  /**
   * Auth: Azure Service Principal:
   * The ClientID of the Azure Service Principal used to authenticate with Azure DNS.
   * If set, ClientSecret and TenantID must also be set.
   *
   * @schema IssuerSpecAcmeSolversDns01AzureDns#clientID
   */
  readonly clientId?: string;

  /**
   * Auth: Azure Service Principal:
   * A reference to a Secret containing the password associated with the Service Principal.
   * If set, ClientID and TenantID must also be set.
   *
   * @schema IssuerSpecAcmeSolversDns01AzureDns#clientSecretSecretRef
   */
  readonly clientSecretSecretRef?: IssuerSpecAcmeSolversDns01AzureDnsClientSecretSecretRef;

  /**
   * name of the Azure environment (default AzurePublicCloud)
   *
   * @schema IssuerSpecAcmeSolversDns01AzureDns#environment
   */
  readonly environment?: IssuerSpecAcmeSolversDns01AzureDnsEnvironment;

  /**
   * name of the DNS zone that should be used
   *
   * @schema IssuerSpecAcmeSolversDns01AzureDns#hostedZoneName
   */
  readonly hostedZoneName?: string;

  /**
   * Auth: Azure Workload Identity or Azure Managed Service Identity:
   * Settings to enable Azure Workload Identity or Azure Managed Service Identity
   * If set, ClientID, ClientSecret and TenantID must not be set.
   *
   * @schema IssuerSpecAcmeSolversDns01AzureDns#managedIdentity
   */
  readonly managedIdentity?: IssuerSpecAcmeSolversDns01AzureDnsManagedIdentity;

  /**
   * resource group the DNS zone is located in
   *
   * @schema IssuerSpecAcmeSolversDns01AzureDns#resourceGroupName
   */
  readonly resourceGroupName: string;

  /**
   * ID of the Azure subscription
   *
   * @schema IssuerSpecAcmeSolversDns01AzureDns#subscriptionID
   */
  readonly subscriptionId: string;

  /**
   * Auth: Azure Service Principal:
   * The TenantID of the Azure Service Principal used to authenticate with Azure DNS.
   * If set, ClientID and ClientSecret must also be set.
   *
   * @schema IssuerSpecAcmeSolversDns01AzureDns#tenantID
   */
  readonly tenantId?: string;

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversDns01AzureDns' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversDns01AzureDns(obj: IssuerSpecAcmeSolversDns01AzureDns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientID': obj.clientId,
    'clientSecretSecretRef': toJson_IssuerSpecAcmeSolversDns01AzureDnsClientSecretSecretRef(obj.clientSecretSecretRef),
    'environment': obj.environment,
    'hostedZoneName': obj.hostedZoneName,
    'managedIdentity': toJson_IssuerSpecAcmeSolversDns01AzureDnsManagedIdentity(obj.managedIdentity),
    'resourceGroupName': obj.resourceGroupName,
    'subscriptionID': obj.subscriptionId,
    'tenantID': obj.tenantId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Use the Google Cloud DNS API to manage DNS01 challenge records.
 *
 * @schema IssuerSpecAcmeSolversDns01CloudDns
 */
export interface IssuerSpecAcmeSolversDns01CloudDns {
  /**
   * HostedZoneName is an optional field that tells cert-manager in which
   * Cloud DNS zone the challenge record has to be created.
   * If left empty cert-manager will automatically choose a zone.
   *
   * @schema IssuerSpecAcmeSolversDns01CloudDns#hostedZoneName
   */
  readonly hostedZoneName?: string;

  /**
   * @schema IssuerSpecAcmeSolversDns01CloudDns#project
   */
  readonly project: string;

  /**
   * A reference to a specific 'key' within a Secret resource.
   * In some instances, `key` is a required field.
   *
   * @schema IssuerSpecAcmeSolversDns01CloudDns#serviceAccountSecretRef
   */
  readonly serviceAccountSecretRef?: IssuerSpecAcmeSolversDns01CloudDnsServiceAccountSecretRef;

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversDns01CloudDns' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversDns01CloudDns(obj: IssuerSpecAcmeSolversDns01CloudDns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostedZoneName': obj.hostedZoneName,
    'project': obj.project,
    'serviceAccountSecretRef': toJson_IssuerSpecAcmeSolversDns01CloudDnsServiceAccountSecretRef(obj.serviceAccountSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Use the Cloudflare API to manage DNS01 challenge records.
 *
 * @schema IssuerSpecAcmeSolversDns01Cloudflare
 */
export interface IssuerSpecAcmeSolversDns01Cloudflare {
  /**
   * API key to use to authenticate with Cloudflare.
   * Note: using an API token to authenticate is now the recommended method
   * as it allows greater control of permissions.
   *
   * @schema IssuerSpecAcmeSolversDns01Cloudflare#apiKeySecretRef
   */
  readonly apiKeySecretRef?: IssuerSpecAcmeSolversDns01CloudflareApiKeySecretRef;

  /**
   * API token used to authenticate with Cloudflare.
   *
   * @schema IssuerSpecAcmeSolversDns01Cloudflare#apiTokenSecretRef
   */
  readonly apiTokenSecretRef?: IssuerSpecAcmeSolversDns01CloudflareApiTokenSecretRef;

  /**
   * Email of the account, only required when using API key based authentication.
   *
   * @schema IssuerSpecAcmeSolversDns01Cloudflare#email
   */
  readonly email?: string;

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversDns01Cloudflare' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversDns01Cloudflare(obj: IssuerSpecAcmeSolversDns01Cloudflare | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiKeySecretRef': toJson_IssuerSpecAcmeSolversDns01CloudflareApiKeySecretRef(obj.apiKeySecretRef),
    'apiTokenSecretRef': toJson_IssuerSpecAcmeSolversDns01CloudflareApiTokenSecretRef(obj.apiTokenSecretRef),
    'email': obj.email,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CNAMEStrategy configures how the DNS01 provider should handle CNAME
 * records when found in DNS zones.
 *
 * @schema IssuerSpecAcmeSolversDns01CnameStrategy
 */
export enum IssuerSpecAcmeSolversDns01CnameStrategy {
  /** None */
  NONE = "None",
  /** Follow */
  FOLLOW = "Follow",
}

/**
 * Use the DigitalOcean DNS API to manage DNS01 challenge records.
 *
 * @schema IssuerSpecAcmeSolversDns01Digitalocean
 */
export interface IssuerSpecAcmeSolversDns01Digitalocean {
  /**
   * A reference to a specific 'key' within a Secret resource.
   * In some instances, `key` is a required field.
   *
   * @schema IssuerSpecAcmeSolversDns01Digitalocean#tokenSecretRef
   */
  readonly tokenSecretRef: IssuerSpecAcmeSolversDns01DigitaloceanTokenSecretRef;

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversDns01Digitalocean' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversDns01Digitalocean(obj: IssuerSpecAcmeSolversDns01Digitalocean | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'tokenSecretRef': toJson_IssuerSpecAcmeSolversDns01DigitaloceanTokenSecretRef(obj.tokenSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Use RFC2136 ("Dynamic Updates in the Domain Name System") (https://datatracker.ietf.org/doc/rfc2136/)
 * to manage DNS01 challenge records.
 *
 * @schema IssuerSpecAcmeSolversDns01Rfc2136
 */
export interface IssuerSpecAcmeSolversDns01Rfc2136 {
  /**
   * The IP address or hostname of an authoritative DNS server supporting
   * RFC2136 in the form host:port. If the host is an IPv6 address it must be
   * enclosed in square brackets (e.g [2001:db8::1]); port is optional.
   * This field is required.
   *
   * @schema IssuerSpecAcmeSolversDns01Rfc2136#nameserver
   */
  readonly nameserver: string;

  /**
   * The TSIG Algorithm configured in the DNS supporting RFC2136. Used only
   * when ``tsigSecretSecretRef`` and ``tsigKeyName`` are defined.
   * Supported values are (case-insensitive): ``HMACMD5`` (default),
   * ``HMACSHA1``, ``HMACSHA256`` or ``HMACSHA512``.
   *
   * @schema IssuerSpecAcmeSolversDns01Rfc2136#tsigAlgorithm
   */
  readonly tsigAlgorithm?: string;

  /**
   * The TSIG Key name configured in the DNS.
   * If ``tsigSecretSecretRef`` is defined, this field is required.
   *
   * @schema IssuerSpecAcmeSolversDns01Rfc2136#tsigKeyName
   */
  readonly tsigKeyName?: string;

  /**
   * The name of the secret containing the TSIG value.
   * If ``tsigKeyName`` is defined, this field is required.
   *
   * @schema IssuerSpecAcmeSolversDns01Rfc2136#tsigSecretSecretRef
   */
  readonly tsigSecretSecretRef?: IssuerSpecAcmeSolversDns01Rfc2136TsigSecretSecretRef;

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversDns01Rfc2136' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversDns01Rfc2136(obj: IssuerSpecAcmeSolversDns01Rfc2136 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nameserver': obj.nameserver,
    'tsigAlgorithm': obj.tsigAlgorithm,
    'tsigKeyName': obj.tsigKeyName,
    'tsigSecretSecretRef': toJson_IssuerSpecAcmeSolversDns01Rfc2136TsigSecretSecretRef(obj.tsigSecretSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Use the AWS Route53 API to manage DNS01 challenge records.
 *
 * @schema IssuerSpecAcmeSolversDns01Route53
 */
export interface IssuerSpecAcmeSolversDns01Route53 {
  /**
   * The AccessKeyID is used for authentication.
   * Cannot be set when SecretAccessKeyID is set.
   * If neither the Access Key nor Key ID are set, we fall-back to using env
   * vars, shared credentials file or AWS Instance metadata,
   * see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
   *
   * @schema IssuerSpecAcmeSolversDns01Route53#accessKeyID
   */
  readonly accessKeyId?: string;

  /**
   * The SecretAccessKey is used for authentication. If set, pull the AWS
   * access key ID from a key within a Kubernetes Secret.
   * Cannot be set when AccessKeyID is set.
   * If neither the Access Key nor Key ID are set, we fall-back to using env
   * vars, shared credentials file or AWS Instance metadata,
   * see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
   *
   * @schema IssuerSpecAcmeSolversDns01Route53#accessKeyIDSecretRef
   */
  readonly accessKeyIdSecretRef?: IssuerSpecAcmeSolversDns01Route53AccessKeyIdSecretRef;

  /**
   * Auth configures how cert-manager authenticates.
   *
   * @schema IssuerSpecAcmeSolversDns01Route53#auth
   */
  readonly auth?: IssuerSpecAcmeSolversDns01Route53Auth;

  /**
   * If set, the provider will manage only this zone in Route53 and will not do a lookup using the route53:ListHostedZonesByName api call.
   *
   * @schema IssuerSpecAcmeSolversDns01Route53#hostedZoneID
   */
  readonly hostedZoneId?: string;

  /**
   * Override the AWS region.
   *
   * Route53 is a global service and does not have regional endpoints but the
   * region specified here (or via environment variables) is used as a hint to
   * help compute the correct AWS credential scope and partition when it
   * connects to Route53. See:
   * - [Amazon Route 53 endpoints and quotas](https://docs.aws.amazon.com/general/latest/gr/r53.html)
   * - [Global services](https://docs.aws.amazon.com/whitepapers/latest/aws-fault-isolation-boundaries/global-services.html)
   *
   * If you omit this region field, cert-manager will use the region from
   * AWS_REGION and AWS_DEFAULT_REGION environment variables, if they are set
   * in the cert-manager controller Pod.
   *
   * The `region` field is not needed if you use [IAM Roles for Service Accounts (IRSA)](https://docs.aws.amazon.com/eks/latest/userguide/iam-roles-for-service-accounts.html).
   * Instead an AWS_REGION environment variable is added to the cert-manager controller Pod by:
   * [Amazon EKS Pod Identity Webhook](https://github.com/aws/amazon-eks-pod-identity-webhook).
   * In this case this `region` field value is ignored.
   *
   * The `region` field is not needed if you use [EKS Pod Identities](https://docs.aws.amazon.com/eks/latest/userguide/pod-identities.html).
   * Instead an AWS_REGION environment variable is added to the cert-manager controller Pod by:
   * [Amazon EKS Pod Identity Agent](https://github.com/aws/eks-pod-identity-agent),
   * In this case this `region` field value is ignored.
   *
   * @schema IssuerSpecAcmeSolversDns01Route53#region
   */
  readonly region?: string;

  /**
   * Role is a Role ARN which the Route53 provider will assume using either the explicit credentials AccessKeyID/SecretAccessKey
   * or the inferred credentials from environment variables, shared credentials file or AWS Instance metadata
   *
   * @schema IssuerSpecAcmeSolversDns01Route53#role
   */
  readonly role?: string;

  /**
   * The SecretAccessKey is used for authentication.
   * If neither the Access Key nor Key ID are set, we fall-back to using env
   * vars, shared credentials file or AWS Instance metadata,
   * see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
   *
   * @schema IssuerSpecAcmeSolversDns01Route53#secretAccessKeySecretRef
   */
  readonly secretAccessKeySecretRef?: IssuerSpecAcmeSolversDns01Route53SecretAccessKeySecretRef;

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversDns01Route53' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversDns01Route53(obj: IssuerSpecAcmeSolversDns01Route53 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessKeyID': obj.accessKeyId,
    'accessKeyIDSecretRef': toJson_IssuerSpecAcmeSolversDns01Route53AccessKeyIdSecretRef(obj.accessKeyIdSecretRef),
    'auth': toJson_IssuerSpecAcmeSolversDns01Route53Auth(obj.auth),
    'hostedZoneID': obj.hostedZoneId,
    'region': obj.region,
    'role': obj.role,
    'secretAccessKeySecretRef': toJson_IssuerSpecAcmeSolversDns01Route53SecretAccessKeySecretRef(obj.secretAccessKeySecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configure an external webhook based DNS01 challenge solver to manage
 * DNS01 challenge records.
 *
 * @schema IssuerSpecAcmeSolversDns01Webhook
 */
export interface IssuerSpecAcmeSolversDns01Webhook {
  /**
   * Additional configuration that should be passed to the webhook apiserver
   * when challenges are processed.
   * This can contain arbitrary JSON data.
   * Secret values should not be specified in this stanza.
   * If secret values are needed (e.g. credentials for a DNS service), you
   * should use a SecretKeySelector to reference a Secret resource.
   * For details on the schema of this field, consult the webhook provider
   * implementation's documentation.
   *
   * @schema IssuerSpecAcmeSolversDns01Webhook#config
   */
  readonly config?: any;

  /**
   * The API group name that should be used when POSTing ChallengePayload
   * resources to the webhook apiserver.
   * This should be the same as the GroupName specified in the webhook
   * provider implementation.
   *
   * @schema IssuerSpecAcmeSolversDns01Webhook#groupName
   */
  readonly groupName: string;

  /**
   * The name of the solver to use, as defined in the webhook provider
   * implementation.
   * This will typically be the name of the provider, e.g. 'cloudflare'.
   *
   * @schema IssuerSpecAcmeSolversDns01Webhook#solverName
   */
  readonly solverName: string;

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversDns01Webhook' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversDns01Webhook(obj: IssuerSpecAcmeSolversDns01Webhook | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'config': obj.config,
    'groupName': obj.groupName,
    'solverName': obj.solverName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Gateway API is a sig-network community API that models service networking
 * in Kubernetes (https://gateway-api.sigs.k8s.io/). The Gateway solver will
 * create HTTPRoutes with the specified labels in the same namespace as the challenge.
 * This solver is experimental, and fields / behaviour may change in the future.
 *
 * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoute
 */
export interface IssuerSpecAcmeSolversHttp01GatewayHttpRoute {
  /**
   * Custom labels that will be applied to HTTPRoutes created by cert-manager
   * while solving HTTP-01 challenges.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoute#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * When solving an HTTP-01 challenge, cert-manager creates an HTTPRoute.
   * cert-manager needs to know which parentRefs should be used when creating
   * the HTTPRoute. Usually, the parentRef references a Gateway. See:
   * https://gateway-api.sigs.k8s.io/api-types/httproute/#attaching-to-gateways
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoute#parentRefs
   */
  readonly parentRefs?: IssuerSpecAcmeSolversHttp01GatewayHttpRouteParentRefs[];

  /**
   * Optional pod template used to configure the ACME challenge solver pods
   * used for HTTP01 challenges.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoute#podTemplate
   */
  readonly podTemplate?: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplate;

  /**
   * Optional service type for Kubernetes solver service. Supported values
   * are NodePort or ClusterIP. If unset, defaults to NodePort.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoute#serviceType
   */
  readonly serviceType?: string;

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01GatewayHttpRoute' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoute(obj: IssuerSpecAcmeSolversHttp01GatewayHttpRoute | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'parentRefs': obj.parentRefs?.map(y => toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRouteParentRefs(y)),
    'podTemplate': toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplate(obj.podTemplate),
    'serviceType': obj.serviceType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The ingress based HTTP01 challenge solver will solve challenges by
 * creating or modifying Ingress resources in order to route requests for
 * '/.well-known/acme-challenge/XYZ' to 'challenge solver' pods that are
 * provisioned by cert-manager for each Challenge to be completed.
 *
 * @schema IssuerSpecAcmeSolversHttp01Ingress
 */
export interface IssuerSpecAcmeSolversHttp01Ingress {
  /**
   * This field configures the annotation `kubernetes.io/ingress.class` when
   * creating Ingress resources to solve ACME challenges that use this
   * challenge solver. Only one of `class`, `name` or `ingressClassName` may
   * be specified.
   *
   * @schema IssuerSpecAcmeSolversHttp01Ingress#class
   */
  readonly class?: string;

  /**
   * This field configures the field `ingressClassName` on the created Ingress
   * resources used to solve ACME challenges that use this challenge solver.
   * This is the recommended way of configuring the ingress class. Only one of
   * `class`, `name` or `ingressClassName` may be specified.
   *
   * @schema IssuerSpecAcmeSolversHttp01Ingress#ingressClassName
   */
  readonly ingressClassName?: string;

  /**
   * Optional ingress template used to configure the ACME challenge solver
   * ingress used for HTTP01 challenges.
   *
   * @schema IssuerSpecAcmeSolversHttp01Ingress#ingressTemplate
   */
  readonly ingressTemplate?: IssuerSpecAcmeSolversHttp01IngressIngressTemplate;

  /**
   * The name of the ingress resource that should have ACME challenge solving
   * routes inserted into it in order to solve HTTP01 challenges.
   * This is typically used in conjunction with ingress controllers like
   * ingress-gce, which maintains a 1:1 mapping between external IPs and
   * ingress resources. Only one of `class`, `name` or `ingressClassName` may
   * be specified.
   *
   * @schema IssuerSpecAcmeSolversHttp01Ingress#name
   */
  readonly name?: string;

  /**
   * Optional pod template used to configure the ACME challenge solver pods
   * used for HTTP01 challenges.
   *
   * @schema IssuerSpecAcmeSolversHttp01Ingress#podTemplate
   */
  readonly podTemplate?: IssuerSpecAcmeSolversHttp01IngressPodTemplate;

  /**
   * Optional service type for Kubernetes solver service. Supported values
   * are NodePort or ClusterIP. If unset, defaults to NodePort.
   *
   * @schema IssuerSpecAcmeSolversHttp01Ingress#serviceType
   */
  readonly serviceType?: string;

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01Ingress' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01Ingress(obj: IssuerSpecAcmeSolversHttp01Ingress | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'class': obj.class,
    'ingressClassName': obj.ingressClassName,
    'ingressTemplate': toJson_IssuerSpecAcmeSolversHttp01IngressIngressTemplate(obj.ingressTemplate),
    'name': obj.name,
    'podTemplate': toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplate(obj.podTemplate),
    'serviceType': obj.serviceType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a key in a Secret that contains the App Role secret used
 * to authenticate with Vault.
 * The `key` field must be specified and denotes which entry within the Secret
 * resource is used as the app role secret.
 *
 * @schema IssuerSpecVaultAuthAppRoleSecretRef
 */
export interface IssuerSpecVaultAuthAppRoleSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used.
   * Some instances of this field may be defaulted, in others it may be
   * required.
   *
   * @schema IssuerSpecVaultAuthAppRoleSecretRef#key
   */
  readonly key?: string;

  /**
   * Name of the resource being referred to.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema IssuerSpecVaultAuthAppRoleSecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'IssuerSpecVaultAuthAppRoleSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecVaultAuthAppRoleSecretRef(obj: IssuerSpecVaultAuthAppRoleSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The required Secret field containing a Kubernetes ServiceAccount JWT used
 * for authenticating with Vault. Use of 'ambient credentials' is not
 * supported.
 *
 * @schema IssuerSpecVaultAuthKubernetesSecretRef
 */
export interface IssuerSpecVaultAuthKubernetesSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used.
   * Some instances of this field may be defaulted, in others it may be
   * required.
   *
   * @schema IssuerSpecVaultAuthKubernetesSecretRef#key
   */
  readonly key?: string;

  /**
   * Name of the resource being referred to.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema IssuerSpecVaultAuthKubernetesSecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'IssuerSpecVaultAuthKubernetesSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecVaultAuthKubernetesSecretRef(obj: IssuerSpecVaultAuthKubernetesSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A reference to a service account that will be used to request a bound
 * token (also known as "projected token"). Compared to using "secretRef",
 * using this field means that you don't rely on statically bound tokens. To
 * use this field, you must configure an RBAC rule to let cert-manager
 * request a token.
 *
 * @schema IssuerSpecVaultAuthKubernetesServiceAccountRef
 */
export interface IssuerSpecVaultAuthKubernetesServiceAccountRef {
  /**
   * TokenAudiences is an optional list of extra audiences to include in the token passed to Vault. The default token
   * consisting of the issuer's namespace and name is always included.
   *
   * @schema IssuerSpecVaultAuthKubernetesServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * Name of the ServiceAccount used to request a token.
   *
   * @schema IssuerSpecVaultAuthKubernetesServiceAccountRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'IssuerSpecVaultAuthKubernetesServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecVaultAuthKubernetesServiceAccountRef(obj: IssuerSpecVaultAuthKubernetesServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A reference to a specific 'key' within a Secret resource.
 * In some instances, `key` is a required field.
 *
 * @schema IssuerSpecAcmeSolversDns01AcmeDnsAccountSecretRef
 */
export interface IssuerSpecAcmeSolversDns01AcmeDnsAccountSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used.
   * Some instances of this field may be defaulted, in others it may be
   * required.
   *
   * @schema IssuerSpecAcmeSolversDns01AcmeDnsAccountSecretRef#key
   */
  readonly key?: string;

  /**
   * Name of the resource being referred to.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema IssuerSpecAcmeSolversDns01AcmeDnsAccountSecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversDns01AcmeDnsAccountSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversDns01AcmeDnsAccountSecretRef(obj: IssuerSpecAcmeSolversDns01AcmeDnsAccountSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A reference to a specific 'key' within a Secret resource.
 * In some instances, `key` is a required field.
 *
 * @schema IssuerSpecAcmeSolversDns01AkamaiAccessTokenSecretRef
 */
export interface IssuerSpecAcmeSolversDns01AkamaiAccessTokenSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used.
   * Some instances of this field may be defaulted, in others it may be
   * required.
   *
   * @schema IssuerSpecAcmeSolversDns01AkamaiAccessTokenSecretRef#key
   */
  readonly key?: string;

  /**
   * Name of the resource being referred to.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema IssuerSpecAcmeSolversDns01AkamaiAccessTokenSecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversDns01AkamaiAccessTokenSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversDns01AkamaiAccessTokenSecretRef(obj: IssuerSpecAcmeSolversDns01AkamaiAccessTokenSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A reference to a specific 'key' within a Secret resource.
 * In some instances, `key` is a required field.
 *
 * @schema IssuerSpecAcmeSolversDns01AkamaiClientSecretSecretRef
 */
export interface IssuerSpecAcmeSolversDns01AkamaiClientSecretSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used.
   * Some instances of this field may be defaulted, in others it may be
   * required.
   *
   * @schema IssuerSpecAcmeSolversDns01AkamaiClientSecretSecretRef#key
   */
  readonly key?: string;

  /**
   * Name of the resource being referred to.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema IssuerSpecAcmeSolversDns01AkamaiClientSecretSecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversDns01AkamaiClientSecretSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversDns01AkamaiClientSecretSecretRef(obj: IssuerSpecAcmeSolversDns01AkamaiClientSecretSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A reference to a specific 'key' within a Secret resource.
 * In some instances, `key` is a required field.
 *
 * @schema IssuerSpecAcmeSolversDns01AkamaiClientTokenSecretRef
 */
export interface IssuerSpecAcmeSolversDns01AkamaiClientTokenSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used.
   * Some instances of this field may be defaulted, in others it may be
   * required.
   *
   * @schema IssuerSpecAcmeSolversDns01AkamaiClientTokenSecretRef#key
   */
  readonly key?: string;

  /**
   * Name of the resource being referred to.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema IssuerSpecAcmeSolversDns01AkamaiClientTokenSecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversDns01AkamaiClientTokenSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversDns01AkamaiClientTokenSecretRef(obj: IssuerSpecAcmeSolversDns01AkamaiClientTokenSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Auth: Azure Service Principal:
 * A reference to a Secret containing the password associated with the Service Principal.
 * If set, ClientID and TenantID must also be set.
 *
 * @schema IssuerSpecAcmeSolversDns01AzureDnsClientSecretSecretRef
 */
export interface IssuerSpecAcmeSolversDns01AzureDnsClientSecretSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used.
   * Some instances of this field may be defaulted, in others it may be
   * required.
   *
   * @schema IssuerSpecAcmeSolversDns01AzureDnsClientSecretSecretRef#key
   */
  readonly key?: string;

  /**
   * Name of the resource being referred to.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema IssuerSpecAcmeSolversDns01AzureDnsClientSecretSecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversDns01AzureDnsClientSecretSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversDns01AzureDnsClientSecretSecretRef(obj: IssuerSpecAcmeSolversDns01AzureDnsClientSecretSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * name of the Azure environment (default AzurePublicCloud)
 *
 * @schema IssuerSpecAcmeSolversDns01AzureDnsEnvironment
 */
export enum IssuerSpecAcmeSolversDns01AzureDnsEnvironment {
  /** AzurePublicCloud */
  AZURE_PUBLIC_CLOUD = "AzurePublicCloud",
  /** AzureChinaCloud */
  AZURE_CHINA_CLOUD = "AzureChinaCloud",
  /** AzureGermanCloud */
  AZURE_GERMAN_CLOUD = "AzureGermanCloud",
  /** AzureUSGovernmentCloud */
  AZURE_US_GOVERNMENT_CLOUD = "AzureUSGovernmentCloud",
}

/**
 * Auth: Azure Workload Identity or Azure Managed Service Identity:
 * Settings to enable Azure Workload Identity or Azure Managed Service Identity
 * If set, ClientID, ClientSecret and TenantID must not be set.
 *
 * @schema IssuerSpecAcmeSolversDns01AzureDnsManagedIdentity
 */
export interface IssuerSpecAcmeSolversDns01AzureDnsManagedIdentity {
  /**
   * client ID of the managed identity, can not be used at the same time as resourceID
   *
   * @schema IssuerSpecAcmeSolversDns01AzureDnsManagedIdentity#clientID
   */
  readonly clientId?: string;

  /**
   * resource ID of the managed identity, can not be used at the same time as clientID
   * Cannot be used for Azure Managed Service Identity
   *
   * @schema IssuerSpecAcmeSolversDns01AzureDnsManagedIdentity#resourceID
   */
  readonly resourceId?: string;

  /**
   * tenant ID of the managed identity, can not be used at the same time as resourceID
   *
   * @schema IssuerSpecAcmeSolversDns01AzureDnsManagedIdentity#tenantID
   */
  readonly tenantId?: string;

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversDns01AzureDnsManagedIdentity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversDns01AzureDnsManagedIdentity(obj: IssuerSpecAcmeSolversDns01AzureDnsManagedIdentity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientID': obj.clientId,
    'resourceID': obj.resourceId,
    'tenantID': obj.tenantId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A reference to a specific 'key' within a Secret resource.
 * In some instances, `key` is a required field.
 *
 * @schema IssuerSpecAcmeSolversDns01CloudDnsServiceAccountSecretRef
 */
export interface IssuerSpecAcmeSolversDns01CloudDnsServiceAccountSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used.
   * Some instances of this field may be defaulted, in others it may be
   * required.
   *
   * @schema IssuerSpecAcmeSolversDns01CloudDnsServiceAccountSecretRef#key
   */
  readonly key?: string;

  /**
   * Name of the resource being referred to.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema IssuerSpecAcmeSolversDns01CloudDnsServiceAccountSecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversDns01CloudDnsServiceAccountSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversDns01CloudDnsServiceAccountSecretRef(obj: IssuerSpecAcmeSolversDns01CloudDnsServiceAccountSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * API key to use to authenticate with Cloudflare.
 * Note: using an API token to authenticate is now the recommended method
 * as it allows greater control of permissions.
 *
 * @schema IssuerSpecAcmeSolversDns01CloudflareApiKeySecretRef
 */
export interface IssuerSpecAcmeSolversDns01CloudflareApiKeySecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used.
   * Some instances of this field may be defaulted, in others it may be
   * required.
   *
   * @schema IssuerSpecAcmeSolversDns01CloudflareApiKeySecretRef#key
   */
  readonly key?: string;

  /**
   * Name of the resource being referred to.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema IssuerSpecAcmeSolversDns01CloudflareApiKeySecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversDns01CloudflareApiKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversDns01CloudflareApiKeySecretRef(obj: IssuerSpecAcmeSolversDns01CloudflareApiKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * API token used to authenticate with Cloudflare.
 *
 * @schema IssuerSpecAcmeSolversDns01CloudflareApiTokenSecretRef
 */
export interface IssuerSpecAcmeSolversDns01CloudflareApiTokenSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used.
   * Some instances of this field may be defaulted, in others it may be
   * required.
   *
   * @schema IssuerSpecAcmeSolversDns01CloudflareApiTokenSecretRef#key
   */
  readonly key?: string;

  /**
   * Name of the resource being referred to.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema IssuerSpecAcmeSolversDns01CloudflareApiTokenSecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversDns01CloudflareApiTokenSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversDns01CloudflareApiTokenSecretRef(obj: IssuerSpecAcmeSolversDns01CloudflareApiTokenSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A reference to a specific 'key' within a Secret resource.
 * In some instances, `key` is a required field.
 *
 * @schema IssuerSpecAcmeSolversDns01DigitaloceanTokenSecretRef
 */
export interface IssuerSpecAcmeSolversDns01DigitaloceanTokenSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used.
   * Some instances of this field may be defaulted, in others it may be
   * required.
   *
   * @schema IssuerSpecAcmeSolversDns01DigitaloceanTokenSecretRef#key
   */
  readonly key?: string;

  /**
   * Name of the resource being referred to.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema IssuerSpecAcmeSolversDns01DigitaloceanTokenSecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversDns01DigitaloceanTokenSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversDns01DigitaloceanTokenSecretRef(obj: IssuerSpecAcmeSolversDns01DigitaloceanTokenSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The name of the secret containing the TSIG value.
 * If ``tsigKeyName`` is defined, this field is required.
 *
 * @schema IssuerSpecAcmeSolversDns01Rfc2136TsigSecretSecretRef
 */
export interface IssuerSpecAcmeSolversDns01Rfc2136TsigSecretSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used.
   * Some instances of this field may be defaulted, in others it may be
   * required.
   *
   * @schema IssuerSpecAcmeSolversDns01Rfc2136TsigSecretSecretRef#key
   */
  readonly key?: string;

  /**
   * Name of the resource being referred to.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema IssuerSpecAcmeSolversDns01Rfc2136TsigSecretSecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversDns01Rfc2136TsigSecretSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversDns01Rfc2136TsigSecretSecretRef(obj: IssuerSpecAcmeSolversDns01Rfc2136TsigSecretSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The SecretAccessKey is used for authentication. If set, pull the AWS
 * access key ID from a key within a Kubernetes Secret.
 * Cannot be set when AccessKeyID is set.
 * If neither the Access Key nor Key ID are set, we fall-back to using env
 * vars, shared credentials file or AWS Instance metadata,
 * see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
 *
 * @schema IssuerSpecAcmeSolversDns01Route53AccessKeyIdSecretRef
 */
export interface IssuerSpecAcmeSolversDns01Route53AccessKeyIdSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used.
   * Some instances of this field may be defaulted, in others it may be
   * required.
   *
   * @schema IssuerSpecAcmeSolversDns01Route53AccessKeyIdSecretRef#key
   */
  readonly key?: string;

  /**
   * Name of the resource being referred to.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema IssuerSpecAcmeSolversDns01Route53AccessKeyIdSecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversDns01Route53AccessKeyIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversDns01Route53AccessKeyIdSecretRef(obj: IssuerSpecAcmeSolversDns01Route53AccessKeyIdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Auth configures how cert-manager authenticates.
 *
 * @schema IssuerSpecAcmeSolversDns01Route53Auth
 */
export interface IssuerSpecAcmeSolversDns01Route53Auth {
  /**
   * Kubernetes authenticates with Route53 using AssumeRoleWithWebIdentity
   * by passing a bound ServiceAccount token.
   *
   * @schema IssuerSpecAcmeSolversDns01Route53Auth#kubernetes
   */
  readonly kubernetes: IssuerSpecAcmeSolversDns01Route53AuthKubernetes;

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversDns01Route53Auth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversDns01Route53Auth(obj: IssuerSpecAcmeSolversDns01Route53Auth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kubernetes': toJson_IssuerSpecAcmeSolversDns01Route53AuthKubernetes(obj.kubernetes),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The SecretAccessKey is used for authentication.
 * If neither the Access Key nor Key ID are set, we fall-back to using env
 * vars, shared credentials file or AWS Instance metadata,
 * see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
 *
 * @schema IssuerSpecAcmeSolversDns01Route53SecretAccessKeySecretRef
 */
export interface IssuerSpecAcmeSolversDns01Route53SecretAccessKeySecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used.
   * Some instances of this field may be defaulted, in others it may be
   * required.
   *
   * @schema IssuerSpecAcmeSolversDns01Route53SecretAccessKeySecretRef#key
   */
  readonly key?: string;

  /**
   * Name of the resource being referred to.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema IssuerSpecAcmeSolversDns01Route53SecretAccessKeySecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversDns01Route53SecretAccessKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversDns01Route53SecretAccessKeySecretRef(obj: IssuerSpecAcmeSolversDns01Route53SecretAccessKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ParentReference identifies an API object (usually a Gateway) that can be considered
 * a parent of this resource (usually a route). There are two kinds of parent resources
 * with "Core" support:
 *
 * * Gateway (Gateway conformance profile)
 * * Service (Mesh conformance profile, ClusterIP Services only)
 *
 * This API may be extended in the future to support additional kinds of parent
 * resources.
 *
 * The API object must be valid in the cluster; the Group and Kind must
 * be registered in the cluster for this reference to be valid.
 *
 * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRouteParentRefs
 */
export interface IssuerSpecAcmeSolversHttp01GatewayHttpRouteParentRefs {
  /**
   * Group is the group of the referent.
   * When unspecified, "gateway.networking.k8s.io" is inferred.
   * To set the core API group (such as for a "Service" kind referent),
   * Group must be explicitly set to "" (empty string).
   *
   * Support: Core
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRouteParentRefs#group
   */
  readonly group?: string;

  /**
   * Kind is kind of the referent.
   *
   * There are two kinds of parent resources with "Core" support:
   *
   * * Gateway (Gateway conformance profile)
   * * Service (Mesh conformance profile, ClusterIP Services only)
   *
   * Support for other resources is Implementation-Specific.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRouteParentRefs#kind
   */
  readonly kind?: string;

  /**
   * Name is the name of the referent.
   *
   * Support: Core
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRouteParentRefs#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of the referent. When unspecified, this refers
   * to the local namespace of the Route.
   *
   * Note that there are specific rules for ParentRefs which cross namespace
   * boundaries. Cross-namespace references are only valid if they are explicitly
   * allowed by something in the namespace they are referring to. For example:
   * Gateway has the AllowedRoutes field, and ReferenceGrant provides a
   * generic way to enable any other kind of cross-namespace reference.
   *
   * <gateway:experimental:description>
   * ParentRefs from a Route to a Service in the same namespace are "producer"
   * routes, which apply default routing rules to inbound connections from
   * any namespace to the Service.
   *
   * ParentRefs from a Route to a Service in a different namespace are
   * "consumer" routes, and these routing rules are only applied to outbound
   * connections originating from the same namespace as the Route, for which
   * the intended destination of the connections are a Service targeted as a
   * ParentRef of the Route.
   * </gateway:experimental:description>
   *
   * Support: Core
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRouteParentRefs#namespace
   */
  readonly namespace?: string;

  /**
   * Port is the network port this Route targets. It can be interpreted
   * differently based on the type of parent resource.
   *
   * When the parent resource is a Gateway, this targets all listeners
   * listening on the specified port that also support this kind of Route(and
   * select this Route). It's not recommended to set `Port` unless the
   * networking behaviors specified in a Route must apply to a specific port
   * as opposed to a listener(s) whose port(s) may be changed. When both Port
   * and SectionName are specified, the name and port of the selected listener
   * must match both specified values.
   *
   * <gateway:experimental:description>
   * When the parent resource is a Service, this targets a specific port in the
   * Service spec. When both Port (experimental) and SectionName are specified,
   * the name and port of the selected port must match both specified values.
   * </gateway:experimental:description>
   *
   * Implementations MAY choose to support other parent resources.
   * Implementations supporting other types of parent resources MUST clearly
   * document how/if Port is interpreted.
   *
   * For the purpose of status, an attachment is considered successful as
   * long as the parent resource accepts it partially. For example, Gateway
   * listeners can restrict which Routes can attach to them by Route kind,
   * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
   * from the referencing Route, the Route MUST be considered successfully
   * attached. If no Gateway listeners accept attachment from this Route,
   * the Route MUST be considered detached from the Gateway.
   *
   * Support: Extended
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRouteParentRefs#port
   */
  readonly port?: number;

  /**
   * SectionName is the name of a section within the target resource. In the
   * following resources, SectionName is interpreted as the following:
   *
   * * Gateway: Listener name. When both Port (experimental) and SectionName
   * are specified, the name and port of the selected listener must match
   * both specified values.
   * * Service: Port name. When both Port (experimental) and SectionName
   * are specified, the name and port of the selected listener must match
   * both specified values.
   *
   * Implementations MAY choose to support attaching Routes to other resources.
   * If that is the case, they MUST clearly document how SectionName is
   * interpreted.
   *
   * When unspecified (empty string), this will reference the entire resource.
   * For the purpose of status, an attachment is considered successful if at
   * least one section in the parent resource accepts it. For example, Gateway
   * listeners can restrict which Routes can attach to them by Route kind,
   * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
   * the referencing Route, the Route MUST be considered successfully
   * attached. If no Gateway listeners accept attachment from this Route, the
   * Route MUST be considered detached from the Gateway.
   *
   * Support: Core
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRouteParentRefs#sectionName
   */
  readonly sectionName?: string;

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01GatewayHttpRouteParentRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRouteParentRefs(obj: IssuerSpecAcmeSolversHttp01GatewayHttpRouteParentRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
    'port': obj.port,
    'sectionName': obj.sectionName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Optional pod template used to configure the ACME challenge solver pods
 * used for HTTP01 challenges.
 *
 * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplate
 */
export interface IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplate {
  /**
   * ObjectMeta overrides for the pod used to solve HTTP01 challenges.
   * Only the 'labels' and 'annotations' fields may be set.
   * If labels or annotations overlap with in-built values, the values here
   * will override the in-built values.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplate#metadata
   */
  readonly metadata?: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateMetadata;

  /**
   * PodSpec defines overrides for the HTTP01 challenge solver pod.
   * Check ACMEChallengeSolverHTTP01IngressPodSpec to find out currently supported fields.
   * All other fields will be ignored.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplate#spec
   */
  readonly spec?: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpec;

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplate(obj: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateMetadata(obj.metadata),
    'spec': toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Optional ingress template used to configure the ACME challenge solver
 * ingress used for HTTP01 challenges.
 *
 * @schema IssuerSpecAcmeSolversHttp01IngressIngressTemplate
 */
export interface IssuerSpecAcmeSolversHttp01IngressIngressTemplate {
  /**
   * ObjectMeta overrides for the ingress used to solve HTTP01 challenges.
   * Only the 'labels' and 'annotations' fields may be set.
   * If labels or annotations overlap with in-built values, the values here
   * will override the in-built values.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressIngressTemplate#metadata
   */
  readonly metadata?: IssuerSpecAcmeSolversHttp01IngressIngressTemplateMetadata;

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01IngressIngressTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01IngressIngressTemplate(obj: IssuerSpecAcmeSolversHttp01IngressIngressTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_IssuerSpecAcmeSolversHttp01IngressIngressTemplateMetadata(obj.metadata),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Optional pod template used to configure the ACME challenge solver pods
 * used for HTTP01 challenges.
 *
 * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplate
 */
export interface IssuerSpecAcmeSolversHttp01IngressPodTemplate {
  /**
   * ObjectMeta overrides for the pod used to solve HTTP01 challenges.
   * Only the 'labels' and 'annotations' fields may be set.
   * If labels or annotations overlap with in-built values, the values here
   * will override the in-built values.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplate#metadata
   */
  readonly metadata?: IssuerSpecAcmeSolversHttp01IngressPodTemplateMetadata;

  /**
   * PodSpec defines overrides for the HTTP01 challenge solver pod.
   * Check ACMEChallengeSolverHTTP01IngressPodSpec to find out currently supported fields.
   * All other fields will be ignored.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplate#spec
   */
  readonly spec?: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpec;

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01IngressPodTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplate(obj: IssuerSpecAcmeSolversHttp01IngressPodTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateMetadata(obj.metadata),
    'spec': toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Kubernetes authenticates with Route53 using AssumeRoleWithWebIdentity
 * by passing a bound ServiceAccount token.
 *
 * @schema IssuerSpecAcmeSolversDns01Route53AuthKubernetes
 */
export interface IssuerSpecAcmeSolversDns01Route53AuthKubernetes {
  /**
   * A reference to a service account that will be used to request a bound
   * token (also known as "projected token"). To use this field, you must
   * configure an RBAC rule to let cert-manager request a token.
   *
   * @schema IssuerSpecAcmeSolversDns01Route53AuthKubernetes#serviceAccountRef
   */
  readonly serviceAccountRef: IssuerSpecAcmeSolversDns01Route53AuthKubernetesServiceAccountRef;

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversDns01Route53AuthKubernetes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversDns01Route53AuthKubernetes(obj: IssuerSpecAcmeSolversDns01Route53AuthKubernetes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'serviceAccountRef': toJson_IssuerSpecAcmeSolversDns01Route53AuthKubernetesServiceAccountRef(obj.serviceAccountRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ObjectMeta overrides for the pod used to solve HTTP01 challenges.
 * Only the 'labels' and 'annotations' fields may be set.
 * If labels or annotations overlap with in-built values, the values here
 * will override the in-built values.
 *
 * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateMetadata
 */
export interface IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateMetadata {
  /**
   * Annotations that should be added to the created ACME HTTP01 solver pods.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels that should be added to the created ACME HTTP01 solver pods.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateMetadata#labels
   */
  readonly labels?: { [key: string]: string };

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateMetadata(obj: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PodSpec defines overrides for the HTTP01 challenge solver pod.
 * Check ACMEChallengeSolverHTTP01IngressPodSpec to find out currently supported fields.
 * All other fields will be ignored.
 *
 * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpec
 */
export interface IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpec {
  /**
   * If specified, the pod's scheduling constraints
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpec#affinity
   */
  readonly affinity?: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinity;

  /**
   * If specified, the pod's imagePullSecrets
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpec#imagePullSecrets
   */
  readonly imagePullSecrets?: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecImagePullSecrets[];

  /**
   * NodeSelector is a selector which must be true for the pod to fit on a node.
   * Selector which must match a node's labels for the pod to be scheduled on that node.
   * More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpec#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * If specified, the pod's priorityClassName.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpec#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * If specified, the pod's security context
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpec#securityContext
   */
  readonly securityContext?: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContext;

  /**
   * If specified, the pod's service account
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpec#serviceAccountName
   */
  readonly serviceAccountName?: string;

  /**
   * If specified, the pod's tolerations.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpec#tolerations
   */
  readonly tolerations?: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecTolerations[];

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpec(obj: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'affinity': toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinity(obj.affinity),
    'imagePullSecrets': obj.imagePullSecrets?.map(y => toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecImagePullSecrets(y)),
    'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'priorityClassName': obj.priorityClassName,
    'securityContext': toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContext(obj.securityContext),
    'serviceAccountName': obj.serviceAccountName,
    'tolerations': obj.tolerations?.map(y => toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecTolerations(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ObjectMeta overrides for the ingress used to solve HTTP01 challenges.
 * Only the 'labels' and 'annotations' fields may be set.
 * If labels or annotations overlap with in-built values, the values here
 * will override the in-built values.
 *
 * @schema IssuerSpecAcmeSolversHttp01IngressIngressTemplateMetadata
 */
export interface IssuerSpecAcmeSolversHttp01IngressIngressTemplateMetadata {
  /**
   * Annotations that should be added to the created ACME HTTP01 solver ingress.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressIngressTemplateMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels that should be added to the created ACME HTTP01 solver ingress.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressIngressTemplateMetadata#labels
   */
  readonly labels?: { [key: string]: string };

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01IngressIngressTemplateMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01IngressIngressTemplateMetadata(obj: IssuerSpecAcmeSolversHttp01IngressIngressTemplateMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ObjectMeta overrides for the pod used to solve HTTP01 challenges.
 * Only the 'labels' and 'annotations' fields may be set.
 * If labels or annotations overlap with in-built values, the values here
 * will override the in-built values.
 *
 * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateMetadata
 */
export interface IssuerSpecAcmeSolversHttp01IngressPodTemplateMetadata {
  /**
   * Annotations that should be added to the created ACME HTTP01 solver pods.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels that should be added to the created ACME HTTP01 solver pods.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateMetadata#labels
   */
  readonly labels?: { [key: string]: string };

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01IngressPodTemplateMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateMetadata(obj: IssuerSpecAcmeSolversHttp01IngressPodTemplateMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PodSpec defines overrides for the HTTP01 challenge solver pod.
 * Check ACMEChallengeSolverHTTP01IngressPodSpec to find out currently supported fields.
 * All other fields will be ignored.
 *
 * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpec
 */
export interface IssuerSpecAcmeSolversHttp01IngressPodTemplateSpec {
  /**
   * If specified, the pod's scheduling constraints
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpec#affinity
   */
  readonly affinity?: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinity;

  /**
   * If specified, the pod's imagePullSecrets
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpec#imagePullSecrets
   */
  readonly imagePullSecrets?: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecImagePullSecrets[];

  /**
   * NodeSelector is a selector which must be true for the pod to fit on a node.
   * Selector which must match a node's labels for the pod to be scheduled on that node.
   * More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpec#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * If specified, the pod's priorityClassName.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpec#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * If specified, the pod's security context
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpec#securityContext
   */
  readonly securityContext?: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContext;

  /**
   * If specified, the pod's service account
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpec#serviceAccountName
   */
  readonly serviceAccountName?: string;

  /**
   * If specified, the pod's tolerations.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpec#tolerations
   */
  readonly tolerations?: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecTolerations[];

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01IngressPodTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpec(obj: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'affinity': toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinity(obj.affinity),
    'imagePullSecrets': obj.imagePullSecrets?.map(y => toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecImagePullSecrets(y)),
    'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'priorityClassName': obj.priorityClassName,
    'securityContext': toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContext(obj.securityContext),
    'serviceAccountName': obj.serviceAccountName,
    'tolerations': obj.tolerations?.map(y => toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecTolerations(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A reference to a service account that will be used to request a bound
 * token (also known as "projected token"). To use this field, you must
 * configure an RBAC rule to let cert-manager request a token.
 *
 * @schema IssuerSpecAcmeSolversDns01Route53AuthKubernetesServiceAccountRef
 */
export interface IssuerSpecAcmeSolversDns01Route53AuthKubernetesServiceAccountRef {
  /**
   * TokenAudiences is an optional list of audiences to include in the
   * token passed to AWS. The default token consisting of the issuer's namespace
   * and name is always included.
   * If unset the audience defaults to `sts.amazonaws.com`.
   *
   * @schema IssuerSpecAcmeSolversDns01Route53AuthKubernetesServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * Name of the ServiceAccount used to request a token.
   *
   * @schema IssuerSpecAcmeSolversDns01Route53AuthKubernetesServiceAccountRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversDns01Route53AuthKubernetesServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversDns01Route53AuthKubernetesServiceAccountRef(obj: IssuerSpecAcmeSolversDns01Route53AuthKubernetesServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * If specified, the pod's scheduling constraints
 *
 * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinity
 */
export interface IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinity {
  /**
   * Describes node affinity scheduling rules for the pod.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinity#nodeAffinity
   */
  readonly nodeAffinity?: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinity;

  /**
   * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinity#podAffinity
   */
  readonly podAffinity?: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinity;

  /**
   * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinity;

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinity(obj: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeAffinity': toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinity(obj.nodeAffinity),
    'podAffinity': toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinity(obj.podAffinity),
    'podAntiAffinity': toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinity(obj.podAntiAffinity),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LocalObjectReference contains enough information to let you locate the
 * referenced object inside the same namespace.
 *
 * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecImagePullSecrets
 */
export interface IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecImagePullSecrets {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecImagePullSecrets#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecImagePullSecrets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecImagePullSecrets(obj: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecImagePullSecrets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * If specified, the pod's security context
 *
 * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContext
 */
export interface IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContext {
  /**
   * A special supplemental group that applies to all containers in a pod.
   * Some volume types allow the Kubelet to change the ownership of that volume
   * to be owned by the pod:
   *
   * 1. The owning GID will be the FSGroup
   * 2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
   * 3. The permission bits are OR'd with rw-rw----
   *
   * If unset, the Kubelet will not modify the ownership and permissions of any volume.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * fsGroupChangePolicy defines behavior of changing ownership and permission of the volume
   * before being exposed inside Pod. This field will only apply to
   * volume types which support fsGroup based ownership(and permissions).
   * It will have no effect on ephemeral volume types such as: secret, configmaps
   * and emptydir.
   * Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * The GID to run the entrypoint of the container process.
   * Uses runtime default if unset.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence
   * for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user.
   * If true, the Kubelet will validate the image at runtime to ensure that it
   * does not run as UID 0 (root) and fail to start the container if it does.
   * If unset or false, no such validation will be performed.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process.
   * Defaults to user specified in image metadata if unspecified.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence
   * for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified.
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to all containers.
   * If unspecified, the container runtime will allocate a random SELinux context for each
   * container.  May also be set in SecurityContext.  If set in
   * both SecurityContext and PodSecurityContext, the value specified in SecurityContext
   * takes precedence for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by the containers in this pod.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContext#seccompProfile
   */
  readonly seccompProfile?: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSeccompProfile;

  /**
   * A list of groups applied to the first process run in each container, in addition
   * to the container's primary GID, the fsGroup (if specified), and group memberships
   * defined in the container image for the uid of the container process. If unspecified,
   * no additional groups are added to any container. Note that group memberships
   * defined in the container image for the uid of the container process are still effective,
   * even if they are not included in this list.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported
   * sysctls (by the container runtime) might fail to launch.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContext#sysctls
   */
  readonly sysctls?: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSysctls[];

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContext(obj: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsGroup': obj.fsGroup,
    'fsGroupChangePolicy': obj.fsGroupChangePolicy,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSeccompProfile(obj.seccompProfile),
    'supplementalGroups': obj.supplementalGroups?.map(y => y),
    'sysctls': obj.sysctls?.map(y => toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSysctls(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecTolerations
 */
export interface IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict). Zero and
   * negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecTolerations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecTolerations(obj: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * If specified, the pod's scheduling constraints
 *
 * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinity
 */
export interface IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinity {
  /**
   * Describes node affinity scheduling rules for the pod.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinity#nodeAffinity
   */
  readonly nodeAffinity?: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinity;

  /**
   * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinity#podAffinity
   */
  readonly podAffinity?: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinity;

  /**
   * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinity;

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinity(obj: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeAffinity': toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinity(obj.nodeAffinity),
    'podAffinity': toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinity(obj.podAffinity),
    'podAntiAffinity': toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinity(obj.podAntiAffinity),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LocalObjectReference contains enough information to let you locate the
 * referenced object inside the same namespace.
 *
 * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecImagePullSecrets
 */
export interface IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecImagePullSecrets {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecImagePullSecrets#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecImagePullSecrets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecImagePullSecrets(obj: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecImagePullSecrets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * If specified, the pod's security context
 *
 * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContext
 */
export interface IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContext {
  /**
   * A special supplemental group that applies to all containers in a pod.
   * Some volume types allow the Kubelet to change the ownership of that volume
   * to be owned by the pod:
   *
   * 1. The owning GID will be the FSGroup
   * 2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
   * 3. The permission bits are OR'd with rw-rw----
   *
   * If unset, the Kubelet will not modify the ownership and permissions of any volume.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * fsGroupChangePolicy defines behavior of changing ownership and permission of the volume
   * before being exposed inside Pod. This field will only apply to
   * volume types which support fsGroup based ownership(and permissions).
   * It will have no effect on ephemeral volume types such as: secret, configmaps
   * and emptydir.
   * Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * The GID to run the entrypoint of the container process.
   * Uses runtime default if unset.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence
   * for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user.
   * If true, the Kubelet will validate the image at runtime to ensure that it
   * does not run as UID 0 (root) and fail to start the container if it does.
   * If unset or false, no such validation will be performed.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process.
   * Defaults to user specified in image metadata if unspecified.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence
   * for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified.
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to all containers.
   * If unspecified, the container runtime will allocate a random SELinux context for each
   * container.  May also be set in SecurityContext.  If set in
   * both SecurityContext and PodSecurityContext, the value specified in SecurityContext
   * takes precedence for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by the containers in this pod.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContext#seccompProfile
   */
  readonly seccompProfile?: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSeccompProfile;

  /**
   * A list of groups applied to the first process run in each container, in addition
   * to the container's primary GID, the fsGroup (if specified), and group memberships
   * defined in the container image for the uid of the container process. If unspecified,
   * no additional groups are added to any container. Note that group memberships
   * defined in the container image for the uid of the container process are still effective,
   * even if they are not included in this list.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported
   * sysctls (by the container runtime) might fail to launch.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContext#sysctls
   */
  readonly sysctls?: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSysctls[];

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContext(obj: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsGroup': obj.fsGroup,
    'fsGroupChangePolicy': obj.fsGroupChangePolicy,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSeccompProfile(obj.seccompProfile),
    'supplementalGroups': obj.supplementalGroups?.map(y => y),
    'sysctls': obj.sysctls?.map(y => toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSysctls(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecTolerations
 */
export interface IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict). Zero and
   * negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecTolerations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecTolerations(obj: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Describes node affinity scheduling rules for the pod.
 *
 * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinity
 */
export interface IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node matches the corresponding matchExpressions; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to an update), the system
   * may or may not try to eventually evict the pod from its node.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinity(obj: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj.requiredDuringSchedulingIgnoredDuringExecution),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
 *
 * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinity
 */
export interface IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to a pod label update), the
   * system may or may not try to eventually evict the pod from its node.
   * When there are multiple elements, the lists of nodes corresponding to each
   * podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinity(obj: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
 *
 * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinity
 */
export interface IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the anti-affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling anti-affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the anti-affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the anti-affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to a pod label update), the
   * system may or may not try to eventually evict the pod from its node.
   * When there are multiple elements, the lists of nodes corresponding to each
   * podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinity(obj: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The SELinux context to be applied to all containers.
 * If unspecified, the container runtime will allocate a random SELinux context for each
 * container.  May also be set in SecurityContext.  If set in
 * both SecurityContext and PodSecurityContext, the value specified in SecurityContext
 * takes precedence for that container.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSeLinuxOptions
 */
export interface IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSeLinuxOptions(obj: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The seccomp options to use by the containers in this pod.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSeccompProfile
 */
export interface IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used.
   * The profile must be preconfigured on the node to work.
   * Must be a descending path, relative to the kubelet's configured seccomp profile location.
   * Must be set if type is "Localhost". Must NOT be set for any other type.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied.
   * Valid options are:
   *
   * Localhost - a profile defined in a file on the node should be used.
   * RuntimeDefault - the container runtime default profile should be used.
   * Unconfined - no profile should be applied.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSeccompProfile#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSeccompProfile(obj: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Sysctl defines a kernel parameter to be set
 *
 * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSysctls
 */
export interface IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSysctls {
  /**
   * Name of a property to set
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSysctls#name
   */
  readonly name: string;

  /**
   * Value of a property to set
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSysctls#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSysctls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSysctls(obj: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSysctls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Describes node affinity scheduling rules for the pod.
 *
 * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinity
 */
export interface IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node matches the corresponding matchExpressions; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to an update), the system
   * may or may not try to eventually evict the pod from its node.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinity(obj: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj.requiredDuringSchedulingIgnoredDuringExecution),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
 *
 * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinity
 */
export interface IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to a pod label update), the
   * system may or may not try to eventually evict the pod from its node.
   * When there are multiple elements, the lists of nodes corresponding to each
   * podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinity(obj: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
 *
 * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinity
 */
export interface IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the anti-affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling anti-affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the anti-affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the anti-affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to a pod label update), the
   * system may or may not try to eventually evict the pod from its node.
   * When there are multiple elements, the lists of nodes corresponding to each
   * podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinity(obj: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The SELinux context to be applied to all containers.
 * If unspecified, the container runtime will allocate a random SELinux context for each
 * container.  May also be set in SecurityContext.  If set in
 * both SecurityContext and PodSecurityContext, the value specified in SecurityContext
 * takes precedence for that container.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptions
 */
export interface IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptions(obj: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The seccomp options to use by the containers in this pod.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSeccompProfile
 */
export interface IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used.
   * The profile must be preconfigured on the node to work.
   * Must be a descending path, relative to the kubelet's configured seccomp profile location.
   * Must be set if type is "Localhost". Must NOT be set for any other type.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied.
   * Valid options are:
   *
   * Localhost - a profile defined in a file on the node should be used.
   * RuntimeDefault - the container runtime default profile should be used.
   * Unconfined - no profile should be applied.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSeccompProfile#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSeccompProfile(obj: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Sysctl defines a kernel parameter to be set
 *
 * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSysctls
 */
export interface IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSysctls {
  /**
   * Name of a property to set
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSysctls#name
   */
  readonly name: string;

  /**
   * Value of a property to set
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSysctls#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSysctls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSysctls(obj: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSysctls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * An empty preferred scheduling term matches all objects with implicit weight 0
 * (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
 *
 * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * A node selector term, associated with the corresponding weight.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preference': toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj.preference),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * If the affinity requirements specified by this field are not met at
 * scheduling time, the pod will not be scheduled onto the node.
 * If the affinity requirements specified by this field cease to be met
 * at some point during pod execution (e.g. due to an update), the system
 * may or may not try to eventually evict the pod from its node.
 *
 * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A list of node selector terms. The terms are ORed.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeSelectorTerms': obj.nodeSelectorTerms?.map(y => toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm,
   * in the range 1-100.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podAffinityTerm': toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector
 * relative to the given namespace(s)) that this pod should be
 * co-located (affinity) or not co-located (anti-affinity) with,
 * where co-located is defined as running on a node whose value of
 * the label with key <topologyKey> matches that of any node on which
 * a pod of the set of pods is running
 *
 * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'mismatchLabelKeys': obj.mismatchLabelKeys?.map(y => y),
    'namespaceSelector': toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm,
   * in the range 1-100.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podAffinityTerm': toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector
 * relative to the given namespace(s)) that this pod should be
 * co-located (affinity) or not co-located (anti-affinity) with,
 * where co-located is defined as running on a node whose value of
 * the label with key <topologyKey> matches that of any node on which
 * a pod of the set of pods is running
 *
 * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'mismatchLabelKeys': obj.mismatchLabelKeys?.map(y => y),
    'namespaceSelector': toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * An empty preferred scheduling term matches all objects with implicit weight 0
 * (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
 *
 * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * A node selector term, associated with the corresponding weight.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preference': toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj.preference),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * If the affinity requirements specified by this field are not met at
 * scheduling time, the pod will not be scheduled onto the node.
 * If the affinity requirements specified by this field cease to be met
 * at some point during pod execution (e.g. due to an update), the system
 * may or may not try to eventually evict the pod from its node.
 *
 * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A list of node selector terms. The terms are ORed.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeSelectorTerms': obj.nodeSelectorTerms?.map(y => toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm,
   * in the range 1-100.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podAffinityTerm': toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector
 * relative to the given namespace(s)) that this pod should be
 * co-located (affinity) or not co-located (anti-affinity) with,
 * where co-located is defined as running on a node whose value of
 * the label with key <topologyKey> matches that of any node on which
 * a pod of the set of pods is running
 *
 * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'mismatchLabelKeys': obj.mismatchLabelKeys?.map(y => y),
    'namespaceSelector': toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm,
   * in the range 1-100.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podAffinityTerm': toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector
 * relative to the given namespace(s)) that this pod should be
 * co-located (affinity) or not co-located (anti-affinity) with,
 * where co-located is defined as running on a node whose value of
 * the label with key <topologyKey> matches that of any node on which
 * a pod of the set of pods is running
 *
 * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'mismatchLabelKeys': obj.mismatchLabelKeys?.map(y => y),
    'namespaceSelector': toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector term, associated with the corresponding weight.
 *
 * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A null or empty node selector term matches no objects. The requirements of
 * them are ANDed.
 * The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
 *
 * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(obj: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'mismatchLabelKeys': obj.mismatchLabelKeys?.map(y => y),
    'namespaceSelector': toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'mismatchLabelKeys': obj.mismatchLabelKeys?.map(y => y),
    'namespaceSelector': toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector term, associated with the corresponding weight.
 *
 * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A null or empty node selector term matches no objects. The requirements of
 * them are ANDed.
 * The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
 *
 * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(obj: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'mismatchLabelKeys': obj.mismatchLabelKeys?.map(y => y),
    'namespaceSelector': toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'mismatchLabelKeys': obj.mismatchLabelKeys?.map(y => y),
    'namespaceSelector': toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(obj: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(obj: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(obj: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(obj: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(obj: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(obj: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(obj: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(obj: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

