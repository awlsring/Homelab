// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * ACRAccessToken returns a Azure Container Registry token that can be used for pushing/pulling images. Note: by default it will return an ACR Refresh Token with full access (depending on the identity). This can be scoped down to the repository level using .spec.scope. In case scope is defined it will return an ACR Access Token. 
 See docs: https://github.com/Azure/acr/blob/main/docs/AAD-OAuth.md
 *
 * @schema ACRAccessToken
 */
export class AcrAccessToken extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ACRAccessToken"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'generators.external-secrets.io/v1alpha1',
    kind: 'ACRAccessToken',
  }

  /**
   * Renders a Kubernetes manifest for "ACRAccessToken".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AcrAccessTokenProps = {}): any {
    return {
      ...AcrAccessToken.GVK,
      ...toJson_AcrAccessTokenProps(props),
    };
  }

  /**
   * Defines a "ACRAccessToken" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AcrAccessTokenProps = {}) {
    super(scope, id, {
      ...AcrAccessToken.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...AcrAccessToken.GVK,
      ...toJson_AcrAccessTokenProps(resolved),
    };
  }
}

/**
 * ACRAccessToken returns a Azure Container Registry token that can be used for pushing/pulling images. Note: by default it will return an ACR Refresh Token with full access (depending on the identity). This can be scoped down to the repository level using .spec.scope. In case scope is defined it will return an ACR Access Token.
 * See docs: https://github.com/Azure/acr/blob/main/docs/AAD-OAuth.md
 *
 * @schema ACRAccessToken
 */
export interface AcrAccessTokenProps {
  /**
   * @schema ACRAccessToken#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ACRAccessTokenSpec defines how to generate the access token e.g. how to authenticate and which registry to use. see: https://github.com/Azure/acr/blob/main/docs/AAD-OAuth.md#overview
   *
   * @schema ACRAccessToken#spec
   */
  readonly spec?: AcrAccessTokenSpec;

}

/**
 * Converts an object of type 'AcrAccessTokenProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AcrAccessTokenProps(obj: AcrAccessTokenProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AcrAccessTokenSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ACRAccessTokenSpec defines how to generate the access token e.g. how to authenticate and which registry to use. see: https://github.com/Azure/acr/blob/main/docs/AAD-OAuth.md#overview
 *
 * @schema AcrAccessTokenSpec
 */
export interface AcrAccessTokenSpec {
  /**
   * @schema AcrAccessTokenSpec#auth
   */
  readonly auth: AcrAccessTokenSpecAuth;

  /**
   * EnvironmentType specifies the Azure cloud environment endpoints to use for connecting and authenticating with Azure. By default it points to the public cloud AAD endpoint. The following endpoints are available, also see here: https://github.com/Azure/go-autorest/blob/main/autorest/azure/environments.go#L152 PublicCloud, USGovernmentCloud, ChinaCloud, GermanCloud
   *
   * @schema AcrAccessTokenSpec#environmentType
   */
  readonly environmentType?: AcrAccessTokenSpecEnvironmentType;

  /**
   * the domain name of the ACR registry e.g. foobarexample.azurecr.io
   *
   * @schema AcrAccessTokenSpec#registry
   */
  readonly registry: string;

  /**
   * Define the scope for the access token, e.g. pull/push access for a repository. if not provided it will return a refresh token that has full scope. Note: you need to pin it down to the repository level, there is no wildcard available.
   * examples: repository:my-repository:pull,push repository:my-repository:pull
   * see docs for details: https://docs.docker.com/registry/spec/auth/scope/
   *
   * @schema AcrAccessTokenSpec#scope
   */
  readonly scope?: string;

  /**
   * TenantID configures the Azure Tenant to send requests to. Required for ServicePrincipal auth type.
   *
   * @schema AcrAccessTokenSpec#tenantId
   */
  readonly tenantId?: string;

}

/**
 * Converts an object of type 'AcrAccessTokenSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AcrAccessTokenSpec(obj: AcrAccessTokenSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_AcrAccessTokenSpecAuth(obj.auth),
    'environmentType': obj.environmentType,
    'registry': obj.registry,
    'scope': obj.scope,
    'tenantId': obj.tenantId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AcrAccessTokenSpecAuth
 */
export interface AcrAccessTokenSpecAuth {
  /**
   * ManagedIdentity uses Azure Managed Identity to authenticate with Azure.
   *
   * @schema AcrAccessTokenSpecAuth#managedIdentity
   */
  readonly managedIdentity?: AcrAccessTokenSpecAuthManagedIdentity;

  /**
   * ServicePrincipal uses Azure Service Principal credentials to authenticate with Azure.
   *
   * @schema AcrAccessTokenSpecAuth#servicePrincipal
   */
  readonly servicePrincipal?: AcrAccessTokenSpecAuthServicePrincipal;

  /**
   * WorkloadIdentity uses Azure Workload Identity to authenticate with Azure.
   *
   * @schema AcrAccessTokenSpecAuth#workloadIdentity
   */
  readonly workloadIdentity?: AcrAccessTokenSpecAuthWorkloadIdentity;

}

/**
 * Converts an object of type 'AcrAccessTokenSpecAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AcrAccessTokenSpecAuth(obj: AcrAccessTokenSpecAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'managedIdentity': toJson_AcrAccessTokenSpecAuthManagedIdentity(obj.managedIdentity),
    'servicePrincipal': toJson_AcrAccessTokenSpecAuthServicePrincipal(obj.servicePrincipal),
    'workloadIdentity': toJson_AcrAccessTokenSpecAuthWorkloadIdentity(obj.workloadIdentity),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvironmentType specifies the Azure cloud environment endpoints to use for connecting and authenticating with Azure. By default it points to the public cloud AAD endpoint. The following endpoints are available, also see here: https://github.com/Azure/go-autorest/blob/main/autorest/azure/environments.go#L152 PublicCloud, USGovernmentCloud, ChinaCloud, GermanCloud
 *
 * @schema AcrAccessTokenSpecEnvironmentType
 */
export enum AcrAccessTokenSpecEnvironmentType {
  /** PublicCloud */
  PUBLIC_CLOUD = "PublicCloud",
  /** USGovernmentCloud */
  US_GOVERNMENT_CLOUD = "USGovernmentCloud",
  /** ChinaCloud */
  CHINA_CLOUD = "ChinaCloud",
  /** GermanCloud */
  GERMAN_CLOUD = "GermanCloud",
}

/**
 * ManagedIdentity uses Azure Managed Identity to authenticate with Azure.
 *
 * @schema AcrAccessTokenSpecAuthManagedIdentity
 */
export interface AcrAccessTokenSpecAuthManagedIdentity {
  /**
   * If multiple Managed Identity is assigned to the pod, you can select the one to be used
   *
   * @schema AcrAccessTokenSpecAuthManagedIdentity#identityId
   */
  readonly identityId?: string;

}

/**
 * Converts an object of type 'AcrAccessTokenSpecAuthManagedIdentity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AcrAccessTokenSpecAuthManagedIdentity(obj: AcrAccessTokenSpecAuthManagedIdentity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'identityId': obj.identityId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ServicePrincipal uses Azure Service Principal credentials to authenticate with Azure.
 *
 * @schema AcrAccessTokenSpecAuthServicePrincipal
 */
export interface AcrAccessTokenSpecAuthServicePrincipal {
  /**
   * Configuration used to authenticate with Azure using static credentials stored in a Kind=Secret.
   *
   * @schema AcrAccessTokenSpecAuthServicePrincipal#secretRef
   */
  readonly secretRef: AcrAccessTokenSpecAuthServicePrincipalSecretRef;

}

/**
 * Converts an object of type 'AcrAccessTokenSpecAuthServicePrincipal' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AcrAccessTokenSpecAuthServicePrincipal(obj: AcrAccessTokenSpecAuthServicePrincipal | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_AcrAccessTokenSpecAuthServicePrincipalSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WorkloadIdentity uses Azure Workload Identity to authenticate with Azure.
 *
 * @schema AcrAccessTokenSpecAuthWorkloadIdentity
 */
export interface AcrAccessTokenSpecAuthWorkloadIdentity {
  /**
   * ServiceAccountRef specified the service account that should be used when authenticating with WorkloadIdentity.
   *
   * @schema AcrAccessTokenSpecAuthWorkloadIdentity#serviceAccountRef
   */
  readonly serviceAccountRef?: AcrAccessTokenSpecAuthWorkloadIdentityServiceAccountRef;

}

/**
 * Converts an object of type 'AcrAccessTokenSpecAuthWorkloadIdentity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AcrAccessTokenSpecAuthWorkloadIdentity(obj: AcrAccessTokenSpecAuthWorkloadIdentity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'serviceAccountRef': toJson_AcrAccessTokenSpecAuthWorkloadIdentityServiceAccountRef(obj.serviceAccountRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configuration used to authenticate with Azure using static credentials stored in a Kind=Secret.
 *
 * @schema AcrAccessTokenSpecAuthServicePrincipalSecretRef
 */
export interface AcrAccessTokenSpecAuthServicePrincipalSecretRef {
  /**
   * The Azure clientId of the service principle used for authentication.
   *
   * @schema AcrAccessTokenSpecAuthServicePrincipalSecretRef#clientId
   */
  readonly clientId?: AcrAccessTokenSpecAuthServicePrincipalSecretRefClientId;

  /**
   * The Azure ClientSecret of the service principle used for authentication.
   *
   * @schema AcrAccessTokenSpecAuthServicePrincipalSecretRef#clientSecret
   */
  readonly clientSecret?: AcrAccessTokenSpecAuthServicePrincipalSecretRefClientSecret;

}

/**
 * Converts an object of type 'AcrAccessTokenSpecAuthServicePrincipalSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AcrAccessTokenSpecAuthServicePrincipalSecretRef(obj: AcrAccessTokenSpecAuthServicePrincipalSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientId': toJson_AcrAccessTokenSpecAuthServicePrincipalSecretRefClientId(obj.clientId),
    'clientSecret': toJson_AcrAccessTokenSpecAuthServicePrincipalSecretRefClientSecret(obj.clientSecret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ServiceAccountRef specified the service account that should be used when authenticating with WorkloadIdentity.
 *
 * @schema AcrAccessTokenSpecAuthWorkloadIdentityServiceAccountRef
 */
export interface AcrAccessTokenSpecAuthWorkloadIdentityServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
   *
   * @schema AcrAccessTokenSpecAuthWorkloadIdentityServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema AcrAccessTokenSpecAuthWorkloadIdentityServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema AcrAccessTokenSpecAuthWorkloadIdentityServiceAccountRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'AcrAccessTokenSpecAuthWorkloadIdentityServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AcrAccessTokenSpecAuthWorkloadIdentityServiceAccountRef(obj: AcrAccessTokenSpecAuthWorkloadIdentityServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Azure clientId of the service principle used for authentication.
 *
 * @schema AcrAccessTokenSpecAuthServicePrincipalSecretRefClientId
 */
export interface AcrAccessTokenSpecAuthServicePrincipalSecretRefClientId {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema AcrAccessTokenSpecAuthServicePrincipalSecretRefClientId#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema AcrAccessTokenSpecAuthServicePrincipalSecretRefClientId#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema AcrAccessTokenSpecAuthServicePrincipalSecretRefClientId#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'AcrAccessTokenSpecAuthServicePrincipalSecretRefClientId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AcrAccessTokenSpecAuthServicePrincipalSecretRefClientId(obj: AcrAccessTokenSpecAuthServicePrincipalSecretRefClientId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Azure ClientSecret of the service principle used for authentication.
 *
 * @schema AcrAccessTokenSpecAuthServicePrincipalSecretRefClientSecret
 */
export interface AcrAccessTokenSpecAuthServicePrincipalSecretRefClientSecret {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema AcrAccessTokenSpecAuthServicePrincipalSecretRefClientSecret#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema AcrAccessTokenSpecAuthServicePrincipalSecretRefClientSecret#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema AcrAccessTokenSpecAuthServicePrincipalSecretRefClientSecret#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'AcrAccessTokenSpecAuthServicePrincipalSecretRefClientSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AcrAccessTokenSpecAuthServicePrincipalSecretRefClientSecret(obj: AcrAccessTokenSpecAuthServicePrincipalSecretRefClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * ECRAuthorizationTokenSpec uses the GetAuthorizationToken API to retrieve an authorization token. The authorization token is valid for 12 hours. The authorizationToken returned is a base64 encoded string that can be decoded and used in a docker login command to authenticate to a registry. For more information, see Registry authentication (https://docs.aws.amazon.com/AmazonECR/latest/userguide/Registries.html#registry_auth) in the Amazon Elastic Container Registry User Guide.
 *
 * @schema ECRAuthorizationToken
 */
export class EcrAuthorizationToken extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ECRAuthorizationToken"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'generators.external-secrets.io/v1alpha1',
    kind: 'ECRAuthorizationToken',
  }

  /**
   * Renders a Kubernetes manifest for "ECRAuthorizationToken".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: EcrAuthorizationTokenProps = {}): any {
    return {
      ...EcrAuthorizationToken.GVK,
      ...toJson_EcrAuthorizationTokenProps(props),
    };
  }

  /**
   * Defines a "ECRAuthorizationToken" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: EcrAuthorizationTokenProps = {}) {
    super(scope, id, {
      ...EcrAuthorizationToken.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...EcrAuthorizationToken.GVK,
      ...toJson_EcrAuthorizationTokenProps(resolved),
    };
  }
}

/**
 * ECRAuthorizationTokenSpec uses the GetAuthorizationToken API to retrieve an authorization token. The authorization token is valid for 12 hours. The authorizationToken returned is a base64 encoded string that can be decoded and used in a docker login command to authenticate to a registry. For more information, see Registry authentication (https://docs.aws.amazon.com/AmazonECR/latest/userguide/Registries.html#registry_auth) in the Amazon Elastic Container Registry User Guide.
 *
 * @schema ECRAuthorizationToken
 */
export interface EcrAuthorizationTokenProps {
  /**
   * @schema ECRAuthorizationToken#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema ECRAuthorizationToken#spec
   */
  readonly spec?: EcrAuthorizationTokenSpec;

}

/**
 * Converts an object of type 'EcrAuthorizationTokenProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EcrAuthorizationTokenProps(obj: EcrAuthorizationTokenProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_EcrAuthorizationTokenSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EcrAuthorizationTokenSpec
 */
export interface EcrAuthorizationTokenSpec {
  /**
   * Auth defines how to authenticate with AWS
   *
   * @schema EcrAuthorizationTokenSpec#auth
   */
  readonly auth?: EcrAuthorizationTokenSpecAuth;

  /**
   * Region specifies the region to operate in.
   *
   * @schema EcrAuthorizationTokenSpec#region
   */
  readonly region: string;

  /**
   * You can assume a role before making calls to the desired AWS service.
   *
   * @schema EcrAuthorizationTokenSpec#role
   */
  readonly role?: string;

}

/**
 * Converts an object of type 'EcrAuthorizationTokenSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EcrAuthorizationTokenSpec(obj: EcrAuthorizationTokenSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_EcrAuthorizationTokenSpecAuth(obj.auth),
    'region': obj.region,
    'role': obj.role,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Auth defines how to authenticate with AWS
 *
 * @schema EcrAuthorizationTokenSpecAuth
 */
export interface EcrAuthorizationTokenSpecAuth {
  /**
   * Authenticate against AWS using service account tokens.
   *
   * @schema EcrAuthorizationTokenSpecAuth#jwt
   */
  readonly jwt?: EcrAuthorizationTokenSpecAuthJwt;

  /**
   * AWSAuthSecretRef holds secret references for AWS credentials both AccessKeyID and SecretAccessKey must be defined in order to properly authenticate.
   *
   * @schema EcrAuthorizationTokenSpecAuth#secretRef
   */
  readonly secretRef?: EcrAuthorizationTokenSpecAuthSecretRef;

}

/**
 * Converts an object of type 'EcrAuthorizationTokenSpecAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EcrAuthorizationTokenSpecAuth(obj: EcrAuthorizationTokenSpecAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'jwt': toJson_EcrAuthorizationTokenSpecAuthJwt(obj.jwt),
    'secretRef': toJson_EcrAuthorizationTokenSpecAuthSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Authenticate against AWS using service account tokens.
 *
 * @schema EcrAuthorizationTokenSpecAuthJwt
 */
export interface EcrAuthorizationTokenSpecAuthJwt {
  /**
   * A reference to a ServiceAccount resource.
   *
   * @schema EcrAuthorizationTokenSpecAuthJwt#serviceAccountRef
   */
  readonly serviceAccountRef?: EcrAuthorizationTokenSpecAuthJwtServiceAccountRef;

}

/**
 * Converts an object of type 'EcrAuthorizationTokenSpecAuthJwt' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EcrAuthorizationTokenSpecAuthJwt(obj: EcrAuthorizationTokenSpecAuthJwt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'serviceAccountRef': toJson_EcrAuthorizationTokenSpecAuthJwtServiceAccountRef(obj.serviceAccountRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AWSAuthSecretRef holds secret references for AWS credentials both AccessKeyID and SecretAccessKey must be defined in order to properly authenticate.
 *
 * @schema EcrAuthorizationTokenSpecAuthSecretRef
 */
export interface EcrAuthorizationTokenSpecAuthSecretRef {
  /**
   * The AccessKeyID is used for authentication
   *
   * @schema EcrAuthorizationTokenSpecAuthSecretRef#accessKeyIDSecretRef
   */
  readonly accessKeyIdSecretRef?: EcrAuthorizationTokenSpecAuthSecretRefAccessKeyIdSecretRef;

  /**
   * The SecretAccessKey is used for authentication
   *
   * @schema EcrAuthorizationTokenSpecAuthSecretRef#secretAccessKeySecretRef
   */
  readonly secretAccessKeySecretRef?: EcrAuthorizationTokenSpecAuthSecretRefSecretAccessKeySecretRef;

  /**
   * The SessionToken used for authentication This must be defined if AccessKeyID and SecretAccessKey are temporary credentials see: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_use-resources.html
   *
   * @schema EcrAuthorizationTokenSpecAuthSecretRef#sessionTokenSecretRef
   */
  readonly sessionTokenSecretRef?: EcrAuthorizationTokenSpecAuthSecretRefSessionTokenSecretRef;

}

/**
 * Converts an object of type 'EcrAuthorizationTokenSpecAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EcrAuthorizationTokenSpecAuthSecretRef(obj: EcrAuthorizationTokenSpecAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessKeyIDSecretRef': toJson_EcrAuthorizationTokenSpecAuthSecretRefAccessKeyIdSecretRef(obj.accessKeyIdSecretRef),
    'secretAccessKeySecretRef': toJson_EcrAuthorizationTokenSpecAuthSecretRefSecretAccessKeySecretRef(obj.secretAccessKeySecretRef),
    'sessionTokenSecretRef': toJson_EcrAuthorizationTokenSpecAuthSecretRefSessionTokenSecretRef(obj.sessionTokenSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A reference to a ServiceAccount resource.
 *
 * @schema EcrAuthorizationTokenSpecAuthJwtServiceAccountRef
 */
export interface EcrAuthorizationTokenSpecAuthJwtServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
   *
   * @schema EcrAuthorizationTokenSpecAuthJwtServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema EcrAuthorizationTokenSpecAuthJwtServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema EcrAuthorizationTokenSpecAuthJwtServiceAccountRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'EcrAuthorizationTokenSpecAuthJwtServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EcrAuthorizationTokenSpecAuthJwtServiceAccountRef(obj: EcrAuthorizationTokenSpecAuthJwtServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The AccessKeyID is used for authentication
 *
 * @schema EcrAuthorizationTokenSpecAuthSecretRefAccessKeyIdSecretRef
 */
export interface EcrAuthorizationTokenSpecAuthSecretRefAccessKeyIdSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema EcrAuthorizationTokenSpecAuthSecretRefAccessKeyIdSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema EcrAuthorizationTokenSpecAuthSecretRefAccessKeyIdSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema EcrAuthorizationTokenSpecAuthSecretRefAccessKeyIdSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'EcrAuthorizationTokenSpecAuthSecretRefAccessKeyIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EcrAuthorizationTokenSpecAuthSecretRefAccessKeyIdSecretRef(obj: EcrAuthorizationTokenSpecAuthSecretRefAccessKeyIdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The SecretAccessKey is used for authentication
 *
 * @schema EcrAuthorizationTokenSpecAuthSecretRefSecretAccessKeySecretRef
 */
export interface EcrAuthorizationTokenSpecAuthSecretRefSecretAccessKeySecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema EcrAuthorizationTokenSpecAuthSecretRefSecretAccessKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema EcrAuthorizationTokenSpecAuthSecretRefSecretAccessKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema EcrAuthorizationTokenSpecAuthSecretRefSecretAccessKeySecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'EcrAuthorizationTokenSpecAuthSecretRefSecretAccessKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EcrAuthorizationTokenSpecAuthSecretRefSecretAccessKeySecretRef(obj: EcrAuthorizationTokenSpecAuthSecretRefSecretAccessKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The SessionToken used for authentication This must be defined if AccessKeyID and SecretAccessKey are temporary credentials see: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_use-resources.html
 *
 * @schema EcrAuthorizationTokenSpecAuthSecretRefSessionTokenSecretRef
 */
export interface EcrAuthorizationTokenSpecAuthSecretRefSessionTokenSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema EcrAuthorizationTokenSpecAuthSecretRefSessionTokenSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema EcrAuthorizationTokenSpecAuthSecretRefSessionTokenSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema EcrAuthorizationTokenSpecAuthSecretRefSessionTokenSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'EcrAuthorizationTokenSpecAuthSecretRefSessionTokenSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EcrAuthorizationTokenSpecAuthSecretRefSessionTokenSecretRef(obj: EcrAuthorizationTokenSpecAuthSecretRefSessionTokenSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * Fake generator is used for testing. It lets you define a static set of credentials that is always returned.
 *
 * @schema Fake
 */
export class Fake extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Fake"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'generators.external-secrets.io/v1alpha1',
    kind: 'Fake',
  }

  /**
   * Renders a Kubernetes manifest for "Fake".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: FakeProps = {}): any {
    return {
      ...Fake.GVK,
      ...toJson_FakeProps(props),
    };
  }

  /**
   * Defines a "Fake" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: FakeProps = {}) {
    super(scope, id, {
      ...Fake.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Fake.GVK,
      ...toJson_FakeProps(resolved),
    };
  }
}

/**
 * Fake generator is used for testing. It lets you define a static set of credentials that is always returned.
 *
 * @schema Fake
 */
export interface FakeProps {
  /**
   * @schema Fake#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * FakeSpec contains the static data.
   *
   * @schema Fake#spec
   */
  readonly spec?: FakeSpec;

}

/**
 * Converts an object of type 'FakeProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FakeProps(obj: FakeProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_FakeSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FakeSpec contains the static data.
 *
 * @schema FakeSpec
 */
export interface FakeSpec {
  /**
   * Used to select the correct ESO controller (think: ingress.ingressClassName) The ESO controller is instantiated with a specific controller name and filters VDS based on this property
   *
   * @schema FakeSpec#controller
   */
  readonly controller?: string;

  /**
   * Data defines the static data returned by this generator.
   *
   * @schema FakeSpec#data
   */
  readonly data?: { [key: string]: string };

}

/**
 * Converts an object of type 'FakeSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FakeSpec(obj: FakeSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'controller': obj.controller,
    'data': ((obj.data) === undefined) ? undefined : (Object.entries(obj.data).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * GCRAccessToken generates an GCP access token that can be used to authenticate with GCR.
 *
 * @schema GCRAccessToken
 */
export class GcrAccessToken extends ApiObject {
  /**
   * Returns the apiVersion and kind for "GCRAccessToken"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'generators.external-secrets.io/v1alpha1',
    kind: 'GCRAccessToken',
  }

  /**
   * Renders a Kubernetes manifest for "GCRAccessToken".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: GcrAccessTokenProps = {}): any {
    return {
      ...GcrAccessToken.GVK,
      ...toJson_GcrAccessTokenProps(props),
    };
  }

  /**
   * Defines a "GCRAccessToken" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: GcrAccessTokenProps = {}) {
    super(scope, id, {
      ...GcrAccessToken.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...GcrAccessToken.GVK,
      ...toJson_GcrAccessTokenProps(resolved),
    };
  }
}

/**
 * GCRAccessToken generates an GCP access token that can be used to authenticate with GCR.
 *
 * @schema GCRAccessToken
 */
export interface GcrAccessTokenProps {
  /**
   * @schema GCRAccessToken#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema GCRAccessToken#spec
   */
  readonly spec?: GcrAccessTokenSpec;

}

/**
 * Converts an object of type 'GcrAccessTokenProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GcrAccessTokenProps(obj: GcrAccessTokenProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_GcrAccessTokenSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GcrAccessTokenSpec
 */
export interface GcrAccessTokenSpec {
  /**
   * Auth defines the means for authenticating with GCP
   *
   * @schema GcrAccessTokenSpec#auth
   */
  readonly auth: GcrAccessTokenSpecAuth;

  /**
   * ProjectID defines which project to use to authenticate with
   *
   * @schema GcrAccessTokenSpec#projectID
   */
  readonly projectId: string;

}

/**
 * Converts an object of type 'GcrAccessTokenSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GcrAccessTokenSpec(obj: GcrAccessTokenSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_GcrAccessTokenSpecAuth(obj.auth),
    'projectID': obj.projectId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Auth defines the means for authenticating with GCP
 *
 * @schema GcrAccessTokenSpecAuth
 */
export interface GcrAccessTokenSpecAuth {
  /**
   * @schema GcrAccessTokenSpecAuth#secretRef
   */
  readonly secretRef?: GcrAccessTokenSpecAuthSecretRef;

  /**
   * @schema GcrAccessTokenSpecAuth#workloadIdentity
   */
  readonly workloadIdentity?: GcrAccessTokenSpecAuthWorkloadIdentity;

}

/**
 * Converts an object of type 'GcrAccessTokenSpecAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GcrAccessTokenSpecAuth(obj: GcrAccessTokenSpecAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_GcrAccessTokenSpecAuthSecretRef(obj.secretRef),
    'workloadIdentity': toJson_GcrAccessTokenSpecAuthWorkloadIdentity(obj.workloadIdentity),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GcrAccessTokenSpecAuthSecretRef
 */
export interface GcrAccessTokenSpecAuthSecretRef {
  /**
   * The SecretAccessKey is used for authentication
   *
   * @schema GcrAccessTokenSpecAuthSecretRef#secretAccessKeySecretRef
   */
  readonly secretAccessKeySecretRef?: GcrAccessTokenSpecAuthSecretRefSecretAccessKeySecretRef;

}

/**
 * Converts an object of type 'GcrAccessTokenSpecAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GcrAccessTokenSpecAuthSecretRef(obj: GcrAccessTokenSpecAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretAccessKeySecretRef': toJson_GcrAccessTokenSpecAuthSecretRefSecretAccessKeySecretRef(obj.secretAccessKeySecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GcrAccessTokenSpecAuthWorkloadIdentity
 */
export interface GcrAccessTokenSpecAuthWorkloadIdentity {
  /**
   * @schema GcrAccessTokenSpecAuthWorkloadIdentity#clusterLocation
   */
  readonly clusterLocation: string;

  /**
   * @schema GcrAccessTokenSpecAuthWorkloadIdentity#clusterName
   */
  readonly clusterName: string;

  /**
   * @schema GcrAccessTokenSpecAuthWorkloadIdentity#clusterProjectID
   */
  readonly clusterProjectId?: string;

  /**
   * A reference to a ServiceAccount resource.
   *
   * @schema GcrAccessTokenSpecAuthWorkloadIdentity#serviceAccountRef
   */
  readonly serviceAccountRef: GcrAccessTokenSpecAuthWorkloadIdentityServiceAccountRef;

}

/**
 * Converts an object of type 'GcrAccessTokenSpecAuthWorkloadIdentity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GcrAccessTokenSpecAuthWorkloadIdentity(obj: GcrAccessTokenSpecAuthWorkloadIdentity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterLocation': obj.clusterLocation,
    'clusterName': obj.clusterName,
    'clusterProjectID': obj.clusterProjectId,
    'serviceAccountRef': toJson_GcrAccessTokenSpecAuthWorkloadIdentityServiceAccountRef(obj.serviceAccountRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The SecretAccessKey is used for authentication
 *
 * @schema GcrAccessTokenSpecAuthSecretRefSecretAccessKeySecretRef
 */
export interface GcrAccessTokenSpecAuthSecretRefSecretAccessKeySecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema GcrAccessTokenSpecAuthSecretRefSecretAccessKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema GcrAccessTokenSpecAuthSecretRefSecretAccessKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema GcrAccessTokenSpecAuthSecretRefSecretAccessKeySecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'GcrAccessTokenSpecAuthSecretRefSecretAccessKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GcrAccessTokenSpecAuthSecretRefSecretAccessKeySecretRef(obj: GcrAccessTokenSpecAuthSecretRefSecretAccessKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A reference to a ServiceAccount resource.
 *
 * @schema GcrAccessTokenSpecAuthWorkloadIdentityServiceAccountRef
 */
export interface GcrAccessTokenSpecAuthWorkloadIdentityServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
   *
   * @schema GcrAccessTokenSpecAuthWorkloadIdentityServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema GcrAccessTokenSpecAuthWorkloadIdentityServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema GcrAccessTokenSpecAuthWorkloadIdentityServiceAccountRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'GcrAccessTokenSpecAuthWorkloadIdentityServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GcrAccessTokenSpecAuthWorkloadIdentityServiceAccountRef(obj: GcrAccessTokenSpecAuthWorkloadIdentityServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * Password generates a random password based on the configuration parameters in spec. You can specify the length, characterset and other attributes.
 *
 * @schema Password
 */
export class Password extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Password"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'generators.external-secrets.io/v1alpha1',
    kind: 'Password',
  }

  /**
   * Renders a Kubernetes manifest for "Password".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: PasswordProps = {}): any {
    return {
      ...Password.GVK,
      ...toJson_PasswordProps(props),
    };
  }

  /**
   * Defines a "Password" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: PasswordProps = {}) {
    super(scope, id, {
      ...Password.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Password.GVK,
      ...toJson_PasswordProps(resolved),
    };
  }
}

/**
 * Password generates a random password based on the configuration parameters in spec. You can specify the length, characterset and other attributes.
 *
 * @schema Password
 */
export interface PasswordProps {
  /**
   * @schema Password#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * PasswordSpec controls the behavior of the password generator.
   *
   * @schema Password#spec
   */
  readonly spec?: PasswordSpec;

}

/**
 * Converts an object of type 'PasswordProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PasswordProps(obj: PasswordProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_PasswordSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PasswordSpec controls the behavior of the password generator.
 *
 * @schema PasswordSpec
 */
export interface PasswordSpec {
  /**
   * set AllowRepeat to true to allow repeating characters.
   *
   * @schema PasswordSpec#allowRepeat
   */
  readonly allowRepeat: boolean;

  /**
   * Digits specifies the number of digits in the generated password. If omitted it defaults to 25% of the length of the password
   *
   * @schema PasswordSpec#digits
   */
  readonly digits?: number;

  /**
   * Length of the password to be generated. Defaults to 24
   *
   * @default 24
   * @schema PasswordSpec#length
   */
  readonly length: number;

  /**
   * Set NoUpper to disable uppercase characters
   *
   * @schema PasswordSpec#noUpper
   */
  readonly noUpper: boolean;

  /**
   * SymbolCharacters specifies the special characters that should be used in the generated password.
   *
   * @schema PasswordSpec#symbolCharacters
   */
  readonly symbolCharacters?: string;

  /**
   * Symbols specifies the number of symbol characters in the generated password. If omitted it defaults to 25% of the length of the password
   *
   * @schema PasswordSpec#symbols
   */
  readonly symbols?: number;

}

/**
 * Converts an object of type 'PasswordSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PasswordSpec(obj: PasswordSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowRepeat': obj.allowRepeat,
    'digits': obj.digits,
    'length': obj.length,
    'noUpper': obj.noUpper,
    'symbolCharacters': obj.symbolCharacters,
    'symbols': obj.symbols,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema VaultDynamicSecret
 */
export class VaultDynamicSecret extends ApiObject {
  /**
   * Returns the apiVersion and kind for "VaultDynamicSecret"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'generators.external-secrets.io/v1alpha1',
    kind: 'VaultDynamicSecret',
  }

  /**
   * Renders a Kubernetes manifest for "VaultDynamicSecret".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: VaultDynamicSecretProps = {}): any {
    return {
      ...VaultDynamicSecret.GVK,
      ...toJson_VaultDynamicSecretProps(props),
    };
  }

  /**
   * Defines a "VaultDynamicSecret" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: VaultDynamicSecretProps = {}) {
    super(scope, id, {
      ...VaultDynamicSecret.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...VaultDynamicSecret.GVK,
      ...toJson_VaultDynamicSecretProps(resolved),
    };
  }
}

/**
 * @schema VaultDynamicSecret
 */
export interface VaultDynamicSecretProps {
  /**
   * @schema VaultDynamicSecret#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema VaultDynamicSecret#spec
   */
  readonly spec?: VaultDynamicSecretSpec;

}

/**
 * Converts an object of type 'VaultDynamicSecretProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultDynamicSecretProps(obj: VaultDynamicSecretProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_VaultDynamicSecretSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VaultDynamicSecretSpec
 */
export interface VaultDynamicSecretSpec {
  /**
   * Used to select the correct ESO controller (think: ingress.ingressClassName) The ESO controller is instantiated with a specific controller name and filters VDS based on this property
   *
   * @schema VaultDynamicSecretSpec#controller
   */
  readonly controller?: string;

  /**
   * Vault API method to use (GET/POST/other)
   *
   * @schema VaultDynamicSecretSpec#method
   */
  readonly method?: string;

  /**
   * Parameters to pass to Vault write (for non-GET methods)
   *
   * @schema VaultDynamicSecretSpec#parameters
   */
  readonly parameters?: any;

  /**
   * Vault path to obtain the dynamic secret from
   *
   * @schema VaultDynamicSecretSpec#path
   */
  readonly path: string;

  /**
   * Vault provider common spec
   *
   * @schema VaultDynamicSecretSpec#provider
   */
  readonly provider: VaultDynamicSecretSpecProvider;

  /**
   * Result type defines which data is returned from the generator. By default it is the "data" section of the Vault API response. When using e.g. /auth/token/create the "data" section is empty but the "auth" section contains the generated token. Please refer to the vault docs regarding the result data structure.
   *
   * @schema VaultDynamicSecretSpec#resultType
   */
  readonly resultType?: VaultDynamicSecretSpecResultType;

}

/**
 * Converts an object of type 'VaultDynamicSecretSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultDynamicSecretSpec(obj: VaultDynamicSecretSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'controller': obj.controller,
    'method': obj.method,
    'parameters': obj.parameters,
    'path': obj.path,
    'provider': toJson_VaultDynamicSecretSpecProvider(obj.provider),
    'resultType': obj.resultType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Vault provider common spec
 *
 * @schema VaultDynamicSecretSpecProvider
 */
export interface VaultDynamicSecretSpecProvider {
  /**
   * Auth configures how secret-manager authenticates with the Vault server.
   *
   * @schema VaultDynamicSecretSpecProvider#auth
   */
  readonly auth: VaultDynamicSecretSpecProviderAuth;

  /**
   * PEM encoded CA bundle used to validate Vault server certificate. Only used if the Server URL is using HTTPS protocol. This parameter is ignored for plain HTTP protocol connection. If not set the system root certificates are used to validate the TLS connection.
   *
   * @schema VaultDynamicSecretSpecProvider#caBundle
   */
  readonly caBundle?: string;

  /**
   * The provider for the CA bundle to use to validate Vault server certificate.
   *
   * @schema VaultDynamicSecretSpecProvider#caProvider
   */
  readonly caProvider?: VaultDynamicSecretSpecProviderCaProvider;

  /**
   * ForwardInconsistent tells Vault to forward read-after-write requests to the Vault leader instead of simply retrying within a loop. This can increase performance if the option is enabled serverside. https://www.vaultproject.io/docs/configuration/replication#allow_forwarding_via_header
   *
   * @schema VaultDynamicSecretSpecProvider#forwardInconsistent
   */
  readonly forwardInconsistent?: boolean;

  /**
   * Name of the vault namespace. Namespaces is a set of features within Vault Enterprise that allows Vault environments to support Secure Multi-tenancy. e.g: "ns1". More about namespaces can be found here https://www.vaultproject.io/docs/enterprise/namespaces
   *
   * @schema VaultDynamicSecretSpecProvider#namespace
   */
  readonly namespace?: string;

  /**
   * Path is the mount path of the Vault KV backend endpoint, e.g: "secret". The v2 KV secret engine version specific "/data" path suffix for fetching secrets from Vault is optional and will be appended if not present in specified path.
   *
   * @schema VaultDynamicSecretSpecProvider#path
   */
  readonly path?: string;

  /**
   * ReadYourWrites ensures isolated read-after-write semantics by providing discovered cluster replication states in each request. More information about eventual consistency in Vault can be found here https://www.vaultproject.io/docs/enterprise/consistency
   *
   * @schema VaultDynamicSecretSpecProvider#readYourWrites
   */
  readonly readYourWrites?: boolean;

  /**
   * Server is the connection address for the Vault server, e.g: "https://vault.example.com:8200".
   *
   * @schema VaultDynamicSecretSpecProvider#server
   */
  readonly server: string;

  /**
   * Version is the Vault KV secret engine version. This can be either "v1" or "v2". Version defaults to "v2".
   *
   * @schema VaultDynamicSecretSpecProvider#version
   */
  readonly version?: VaultDynamicSecretSpecProviderVersion;

}

/**
 * Converts an object of type 'VaultDynamicSecretSpecProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultDynamicSecretSpecProvider(obj: VaultDynamicSecretSpecProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_VaultDynamicSecretSpecProviderAuth(obj.auth),
    'caBundle': obj.caBundle,
    'caProvider': toJson_VaultDynamicSecretSpecProviderCaProvider(obj.caProvider),
    'forwardInconsistent': obj.forwardInconsistent,
    'namespace': obj.namespace,
    'path': obj.path,
    'readYourWrites': obj.readYourWrites,
    'server': obj.server,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Result type defines which data is returned from the generator. By default it is the "data" section of the Vault API response. When using e.g. /auth/token/create the "data" section is empty but the "auth" section contains the generated token. Please refer to the vault docs regarding the result data structure.
 *
 * @schema VaultDynamicSecretSpecResultType
 */
export enum VaultDynamicSecretSpecResultType {
  /** Data */
  DATA = "Data",
  /** Auth */
  AUTH = "Auth",
}

/**
 * Auth configures how secret-manager authenticates with the Vault server.
 *
 * @schema VaultDynamicSecretSpecProviderAuth
 */
export interface VaultDynamicSecretSpecProviderAuth {
  /**
   * AppRole authenticates with Vault using the App Role auth mechanism, with the role and secret stored in a Kubernetes Secret resource.
   *
   * @schema VaultDynamicSecretSpecProviderAuth#appRole
   */
  readonly appRole?: VaultDynamicSecretSpecProviderAuthAppRole;

  /**
   * Cert authenticates with TLS Certificates by passing client certificate, private key and ca certificate Cert authentication method
   *
   * @schema VaultDynamicSecretSpecProviderAuth#cert
   */
  readonly cert?: VaultDynamicSecretSpecProviderAuthCert;

  /**
   * Iam authenticates with vault by passing a special AWS request signed with AWS IAM credentials AWS IAM authentication method
   *
   * @schema VaultDynamicSecretSpecProviderAuth#iam
   */
  readonly iam?: VaultDynamicSecretSpecProviderAuthIam;

  /**
   * Jwt authenticates with Vault by passing role and JWT token using the JWT/OIDC authentication method
   *
   * @schema VaultDynamicSecretSpecProviderAuth#jwt
   */
  readonly jwt?: VaultDynamicSecretSpecProviderAuthJwt;

  /**
   * Kubernetes authenticates with Vault by passing the ServiceAccount token stored in the named Secret resource to the Vault server.
   *
   * @schema VaultDynamicSecretSpecProviderAuth#kubernetes
   */
  readonly kubernetes?: VaultDynamicSecretSpecProviderAuthKubernetes;

  /**
   * Ldap authenticates with Vault by passing username/password pair using the LDAP authentication method
   *
   * @schema VaultDynamicSecretSpecProviderAuth#ldap
   */
  readonly ldap?: VaultDynamicSecretSpecProviderAuthLdap;

  /**
   * TokenSecretRef authenticates with Vault by presenting a token.
   *
   * @schema VaultDynamicSecretSpecProviderAuth#tokenSecretRef
   */
  readonly tokenSecretRef?: VaultDynamicSecretSpecProviderAuthTokenSecretRef;

  /**
   * UserPass authenticates with Vault by passing username/password pair
   *
   * @schema VaultDynamicSecretSpecProviderAuth#userPass
   */
  readonly userPass?: VaultDynamicSecretSpecProviderAuthUserPass;

}

/**
 * Converts an object of type 'VaultDynamicSecretSpecProviderAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultDynamicSecretSpecProviderAuth(obj: VaultDynamicSecretSpecProviderAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'appRole': toJson_VaultDynamicSecretSpecProviderAuthAppRole(obj.appRole),
    'cert': toJson_VaultDynamicSecretSpecProviderAuthCert(obj.cert),
    'iam': toJson_VaultDynamicSecretSpecProviderAuthIam(obj.iam),
    'jwt': toJson_VaultDynamicSecretSpecProviderAuthJwt(obj.jwt),
    'kubernetes': toJson_VaultDynamicSecretSpecProviderAuthKubernetes(obj.kubernetes),
    'ldap': toJson_VaultDynamicSecretSpecProviderAuthLdap(obj.ldap),
    'tokenSecretRef': toJson_VaultDynamicSecretSpecProviderAuthTokenSecretRef(obj.tokenSecretRef),
    'userPass': toJson_VaultDynamicSecretSpecProviderAuthUserPass(obj.userPass),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The provider for the CA bundle to use to validate Vault server certificate.
 *
 * @schema VaultDynamicSecretSpecProviderCaProvider
 */
export interface VaultDynamicSecretSpecProviderCaProvider {
  /**
   * The key where the CA certificate can be found in the Secret or ConfigMap.
   *
   * @schema VaultDynamicSecretSpecProviderCaProvider#key
   */
  readonly key?: string;

  /**
   * The name of the object located at the provider type.
   *
   * @schema VaultDynamicSecretSpecProviderCaProvider#name
   */
  readonly name: string;

  /**
   * The namespace the Provider type is in. Can only be defined when used in a ClusterSecretStore.
   *
   * @schema VaultDynamicSecretSpecProviderCaProvider#namespace
   */
  readonly namespace?: string;

  /**
   * The type of provider to use such as "Secret", or "ConfigMap".
   *
   * @schema VaultDynamicSecretSpecProviderCaProvider#type
   */
  readonly type: VaultDynamicSecretSpecProviderCaProviderType;

}

/**
 * Converts an object of type 'VaultDynamicSecretSpecProviderCaProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultDynamicSecretSpecProviderCaProvider(obj: VaultDynamicSecretSpecProviderCaProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Version is the Vault KV secret engine version. This can be either "v1" or "v2". Version defaults to "v2".
 *
 * @schema VaultDynamicSecretSpecProviderVersion
 */
export enum VaultDynamicSecretSpecProviderVersion {
  /** v1 */
  V1 = "v1",
  /** v2 */
  V2 = "v2",
}

/**
 * AppRole authenticates with Vault using the App Role auth mechanism, with the role and secret stored in a Kubernetes Secret resource.
 *
 * @schema VaultDynamicSecretSpecProviderAuthAppRole
 */
export interface VaultDynamicSecretSpecProviderAuthAppRole {
  /**
   * Path where the App Role authentication backend is mounted in Vault, e.g: "approle"
   *
   * @schema VaultDynamicSecretSpecProviderAuthAppRole#path
   */
  readonly path: string;

  /**
   * RoleID configured in the App Role authentication backend when setting up the authentication backend in Vault.
   *
   * @schema VaultDynamicSecretSpecProviderAuthAppRole#roleId
   */
  readonly roleId?: string;

  /**
   * Reference to a key in a Secret that contains the App Role ID used to authenticate with Vault. The `key` field must be specified and denotes which entry within the Secret resource is used as the app role id.
   *
   * @schema VaultDynamicSecretSpecProviderAuthAppRole#roleRef
   */
  readonly roleRef?: VaultDynamicSecretSpecProviderAuthAppRoleRoleRef;

  /**
   * Reference to a key in a Secret that contains the App Role secret used to authenticate with Vault. The `key` field must be specified and denotes which entry within the Secret resource is used as the app role secret.
   *
   * @schema VaultDynamicSecretSpecProviderAuthAppRole#secretRef
   */
  readonly secretRef: VaultDynamicSecretSpecProviderAuthAppRoleSecretRef;

}

/**
 * Converts an object of type 'VaultDynamicSecretSpecProviderAuthAppRole' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultDynamicSecretSpecProviderAuthAppRole(obj: VaultDynamicSecretSpecProviderAuthAppRole | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'roleId': obj.roleId,
    'roleRef': toJson_VaultDynamicSecretSpecProviderAuthAppRoleRoleRef(obj.roleRef),
    'secretRef': toJson_VaultDynamicSecretSpecProviderAuthAppRoleSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Cert authenticates with TLS Certificates by passing client certificate, private key and ca certificate Cert authentication method
 *
 * @schema VaultDynamicSecretSpecProviderAuthCert
 */
export interface VaultDynamicSecretSpecProviderAuthCert {
  /**
   * ClientCert is a certificate to authenticate using the Cert Vault authentication method
   *
   * @schema VaultDynamicSecretSpecProviderAuthCert#clientCert
   */
  readonly clientCert?: VaultDynamicSecretSpecProviderAuthCertClientCert;

  /**
   * SecretRef to a key in a Secret resource containing client private key to authenticate with Vault using the Cert authentication method
   *
   * @schema VaultDynamicSecretSpecProviderAuthCert#secretRef
   */
  readonly secretRef?: VaultDynamicSecretSpecProviderAuthCertSecretRef;

}

/**
 * Converts an object of type 'VaultDynamicSecretSpecProviderAuthCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultDynamicSecretSpecProviderAuthCert(obj: VaultDynamicSecretSpecProviderAuthCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientCert': toJson_VaultDynamicSecretSpecProviderAuthCertClientCert(obj.clientCert),
    'secretRef': toJson_VaultDynamicSecretSpecProviderAuthCertSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Iam authenticates with vault by passing a special AWS request signed with AWS IAM credentials AWS IAM authentication method
 *
 * @schema VaultDynamicSecretSpecProviderAuthIam
 */
export interface VaultDynamicSecretSpecProviderAuthIam {
  /**
   * AWS External ID set on assumed IAM roles
   *
   * @schema VaultDynamicSecretSpecProviderAuthIam#externalID
   */
  readonly externalId?: string;

  /**
   * Specify a service account with IRSA enabled
   *
   * @schema VaultDynamicSecretSpecProviderAuthIam#jwt
   */
  readonly jwt?: VaultDynamicSecretSpecProviderAuthIamJwt;

  /**
   * Path where the AWS auth method is enabled in Vault, e.g: "aws"
   *
   * @schema VaultDynamicSecretSpecProviderAuthIam#path
   */
  readonly path?: string;

  /**
   * AWS region
   *
   * @schema VaultDynamicSecretSpecProviderAuthIam#region
   */
  readonly region?: string;

  /**
   * This is the AWS role to be assumed before talking to vault
   *
   * @schema VaultDynamicSecretSpecProviderAuthIam#role
   */
  readonly role?: string;

  /**
   * Specify credentials in a Secret object
   *
   * @schema VaultDynamicSecretSpecProviderAuthIam#secretRef
   */
  readonly secretRef?: VaultDynamicSecretSpecProviderAuthIamSecretRef;

  /**
   * X-Vault-AWS-IAM-Server-ID is an additional header used by Vault IAM auth method to mitigate against different types of replay attacks. More details here: https://developer.hashicorp.com/vault/docs/auth/aws
   *
   * @schema VaultDynamicSecretSpecProviderAuthIam#vaultAwsIamServerID
   */
  readonly vaultAwsIamServerId?: string;

  /**
   * Vault Role. In vault, a role describes an identity with a set of permissions, groups, or policies you want to attach a user of the secrets engine
   *
   * @schema VaultDynamicSecretSpecProviderAuthIam#vaultRole
   */
  readonly vaultRole: string;

}

/**
 * Converts an object of type 'VaultDynamicSecretSpecProviderAuthIam' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultDynamicSecretSpecProviderAuthIam(obj: VaultDynamicSecretSpecProviderAuthIam | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'externalID': obj.externalId,
    'jwt': toJson_VaultDynamicSecretSpecProviderAuthIamJwt(obj.jwt),
    'path': obj.path,
    'region': obj.region,
    'role': obj.role,
    'secretRef': toJson_VaultDynamicSecretSpecProviderAuthIamSecretRef(obj.secretRef),
    'vaultAwsIamServerID': obj.vaultAwsIamServerId,
    'vaultRole': obj.vaultRole,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Jwt authenticates with Vault by passing role and JWT token using the JWT/OIDC authentication method
 *
 * @schema VaultDynamicSecretSpecProviderAuthJwt
 */
export interface VaultDynamicSecretSpecProviderAuthJwt {
  /**
   * Optional ServiceAccountToken specifies the Kubernetes service account for which to request a token for with the `TokenRequest` API.
   *
   * @schema VaultDynamicSecretSpecProviderAuthJwt#kubernetesServiceAccountToken
   */
  readonly kubernetesServiceAccountToken?: VaultDynamicSecretSpecProviderAuthJwtKubernetesServiceAccountToken;

  /**
   * Path where the JWT authentication backend is mounted in Vault, e.g: "jwt"
   *
   * @schema VaultDynamicSecretSpecProviderAuthJwt#path
   */
  readonly path: string;

  /**
   * Role is a JWT role to authenticate using the JWT/OIDC Vault authentication method
   *
   * @schema VaultDynamicSecretSpecProviderAuthJwt#role
   */
  readonly role?: string;

  /**
   * Optional SecretRef that refers to a key in a Secret resource containing JWT token to authenticate with Vault using the JWT/OIDC authentication method.
   *
   * @schema VaultDynamicSecretSpecProviderAuthJwt#secretRef
   */
  readonly secretRef?: VaultDynamicSecretSpecProviderAuthJwtSecretRef;

}

/**
 * Converts an object of type 'VaultDynamicSecretSpecProviderAuthJwt' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultDynamicSecretSpecProviderAuthJwt(obj: VaultDynamicSecretSpecProviderAuthJwt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kubernetesServiceAccountToken': toJson_VaultDynamicSecretSpecProviderAuthJwtKubernetesServiceAccountToken(obj.kubernetesServiceAccountToken),
    'path': obj.path,
    'role': obj.role,
    'secretRef': toJson_VaultDynamicSecretSpecProviderAuthJwtSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Kubernetes authenticates with Vault by passing the ServiceAccount token stored in the named Secret resource to the Vault server.
 *
 * @schema VaultDynamicSecretSpecProviderAuthKubernetes
 */
export interface VaultDynamicSecretSpecProviderAuthKubernetes {
  /**
   * Path where the Kubernetes authentication backend is mounted in Vault, e.g: "kubernetes"
   *
   * @schema VaultDynamicSecretSpecProviderAuthKubernetes#mountPath
   */
  readonly mountPath: string;

  /**
   * A required field containing the Vault Role to assume. A Role binds a Kubernetes ServiceAccount with a set of Vault policies.
   *
   * @schema VaultDynamicSecretSpecProviderAuthKubernetes#role
   */
  readonly role: string;

  /**
   * Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Vault. If a name is specified without a key, `token` is the default. If one is not specified, the one bound to the controller will be used.
   *
   * @schema VaultDynamicSecretSpecProviderAuthKubernetes#secretRef
   */
  readonly secretRef?: VaultDynamicSecretSpecProviderAuthKubernetesSecretRef;

  /**
   * Optional service account field containing the name of a kubernetes ServiceAccount. If the service account is specified, the service account secret token JWT will be used for authenticating with Vault. If the service account selector is not supplied, the secretRef will be used instead.
   *
   * @schema VaultDynamicSecretSpecProviderAuthKubernetes#serviceAccountRef
   */
  readonly serviceAccountRef?: VaultDynamicSecretSpecProviderAuthKubernetesServiceAccountRef;

}

/**
 * Converts an object of type 'VaultDynamicSecretSpecProviderAuthKubernetes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultDynamicSecretSpecProviderAuthKubernetes(obj: VaultDynamicSecretSpecProviderAuthKubernetes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'role': obj.role,
    'secretRef': toJson_VaultDynamicSecretSpecProviderAuthKubernetesSecretRef(obj.secretRef),
    'serviceAccountRef': toJson_VaultDynamicSecretSpecProviderAuthKubernetesServiceAccountRef(obj.serviceAccountRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Ldap authenticates with Vault by passing username/password pair using the LDAP authentication method
 *
 * @schema VaultDynamicSecretSpecProviderAuthLdap
 */
export interface VaultDynamicSecretSpecProviderAuthLdap {
  /**
   * Path where the LDAP authentication backend is mounted in Vault, e.g: "ldap"
   *
   * @schema VaultDynamicSecretSpecProviderAuthLdap#path
   */
  readonly path: string;

  /**
   * SecretRef to a key in a Secret resource containing password for the LDAP user used to authenticate with Vault using the LDAP authentication method
   *
   * @schema VaultDynamicSecretSpecProviderAuthLdap#secretRef
   */
  readonly secretRef?: VaultDynamicSecretSpecProviderAuthLdapSecretRef;

  /**
   * Username is a LDAP user name used to authenticate using the LDAP Vault authentication method
   *
   * @schema VaultDynamicSecretSpecProviderAuthLdap#username
   */
  readonly username: string;

}

/**
 * Converts an object of type 'VaultDynamicSecretSpecProviderAuthLdap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultDynamicSecretSpecProviderAuthLdap(obj: VaultDynamicSecretSpecProviderAuthLdap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'secretRef': toJson_VaultDynamicSecretSpecProviderAuthLdapSecretRef(obj.secretRef),
    'username': obj.username,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TokenSecretRef authenticates with Vault by presenting a token.
 *
 * @schema VaultDynamicSecretSpecProviderAuthTokenSecretRef
 */
export interface VaultDynamicSecretSpecProviderAuthTokenSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema VaultDynamicSecretSpecProviderAuthTokenSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema VaultDynamicSecretSpecProviderAuthTokenSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema VaultDynamicSecretSpecProviderAuthTokenSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'VaultDynamicSecretSpecProviderAuthTokenSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultDynamicSecretSpecProviderAuthTokenSecretRef(obj: VaultDynamicSecretSpecProviderAuthTokenSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UserPass authenticates with Vault by passing username/password pair
 *
 * @schema VaultDynamicSecretSpecProviderAuthUserPass
 */
export interface VaultDynamicSecretSpecProviderAuthUserPass {
  /**
   * Path where the UserPassword authentication backend is mounted in Vault, e.g: "user"
   *
   * @schema VaultDynamicSecretSpecProviderAuthUserPass#path
   */
  readonly path: string;

  /**
   * SecretRef to a key in a Secret resource containing password for the user used to authenticate with Vault using the UserPass authentication method
   *
   * @schema VaultDynamicSecretSpecProviderAuthUserPass#secretRef
   */
  readonly secretRef?: VaultDynamicSecretSpecProviderAuthUserPassSecretRef;

  /**
   * Username is a user name used to authenticate using the UserPass Vault authentication method
   *
   * @schema VaultDynamicSecretSpecProviderAuthUserPass#username
   */
  readonly username: string;

}

/**
 * Converts an object of type 'VaultDynamicSecretSpecProviderAuthUserPass' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultDynamicSecretSpecProviderAuthUserPass(obj: VaultDynamicSecretSpecProviderAuthUserPass | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'secretRef': toJson_VaultDynamicSecretSpecProviderAuthUserPassSecretRef(obj.secretRef),
    'username': obj.username,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The type of provider to use such as "Secret", or "ConfigMap".
 *
 * @schema VaultDynamicSecretSpecProviderCaProviderType
 */
export enum VaultDynamicSecretSpecProviderCaProviderType {
  /** Secret */
  SECRET = "Secret",
  /** ConfigMap */
  CONFIG_MAP = "ConfigMap",
}

/**
 * Reference to a key in a Secret that contains the App Role ID used to authenticate with Vault. The `key` field must be specified and denotes which entry within the Secret resource is used as the app role id.
 *
 * @schema VaultDynamicSecretSpecProviderAuthAppRoleRoleRef
 */
export interface VaultDynamicSecretSpecProviderAuthAppRoleRoleRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema VaultDynamicSecretSpecProviderAuthAppRoleRoleRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema VaultDynamicSecretSpecProviderAuthAppRoleRoleRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema VaultDynamicSecretSpecProviderAuthAppRoleRoleRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'VaultDynamicSecretSpecProviderAuthAppRoleRoleRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultDynamicSecretSpecProviderAuthAppRoleRoleRef(obj: VaultDynamicSecretSpecProviderAuthAppRoleRoleRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a key in a Secret that contains the App Role secret used to authenticate with Vault. The `key` field must be specified and denotes which entry within the Secret resource is used as the app role secret.
 *
 * @schema VaultDynamicSecretSpecProviderAuthAppRoleSecretRef
 */
export interface VaultDynamicSecretSpecProviderAuthAppRoleSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema VaultDynamicSecretSpecProviderAuthAppRoleSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema VaultDynamicSecretSpecProviderAuthAppRoleSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema VaultDynamicSecretSpecProviderAuthAppRoleSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'VaultDynamicSecretSpecProviderAuthAppRoleSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultDynamicSecretSpecProviderAuthAppRoleSecretRef(obj: VaultDynamicSecretSpecProviderAuthAppRoleSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ClientCert is a certificate to authenticate using the Cert Vault authentication method
 *
 * @schema VaultDynamicSecretSpecProviderAuthCertClientCert
 */
export interface VaultDynamicSecretSpecProviderAuthCertClientCert {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema VaultDynamicSecretSpecProviderAuthCertClientCert#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema VaultDynamicSecretSpecProviderAuthCertClientCert#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema VaultDynamicSecretSpecProviderAuthCertClientCert#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'VaultDynamicSecretSpecProviderAuthCertClientCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultDynamicSecretSpecProviderAuthCertClientCert(obj: VaultDynamicSecretSpecProviderAuthCertClientCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretRef to a key in a Secret resource containing client private key to authenticate with Vault using the Cert authentication method
 *
 * @schema VaultDynamicSecretSpecProviderAuthCertSecretRef
 */
export interface VaultDynamicSecretSpecProviderAuthCertSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema VaultDynamicSecretSpecProviderAuthCertSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema VaultDynamicSecretSpecProviderAuthCertSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema VaultDynamicSecretSpecProviderAuthCertSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'VaultDynamicSecretSpecProviderAuthCertSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultDynamicSecretSpecProviderAuthCertSecretRef(obj: VaultDynamicSecretSpecProviderAuthCertSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specify a service account with IRSA enabled
 *
 * @schema VaultDynamicSecretSpecProviderAuthIamJwt
 */
export interface VaultDynamicSecretSpecProviderAuthIamJwt {
  /**
   * A reference to a ServiceAccount resource.
   *
   * @schema VaultDynamicSecretSpecProviderAuthIamJwt#serviceAccountRef
   */
  readonly serviceAccountRef?: VaultDynamicSecretSpecProviderAuthIamJwtServiceAccountRef;

}

/**
 * Converts an object of type 'VaultDynamicSecretSpecProviderAuthIamJwt' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultDynamicSecretSpecProviderAuthIamJwt(obj: VaultDynamicSecretSpecProviderAuthIamJwt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'serviceAccountRef': toJson_VaultDynamicSecretSpecProviderAuthIamJwtServiceAccountRef(obj.serviceAccountRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specify credentials in a Secret object
 *
 * @schema VaultDynamicSecretSpecProviderAuthIamSecretRef
 */
export interface VaultDynamicSecretSpecProviderAuthIamSecretRef {
  /**
   * The AccessKeyID is used for authentication
   *
   * @schema VaultDynamicSecretSpecProviderAuthIamSecretRef#accessKeyIDSecretRef
   */
  readonly accessKeyIdSecretRef?: VaultDynamicSecretSpecProviderAuthIamSecretRefAccessKeyIdSecretRef;

  /**
   * The SecretAccessKey is used for authentication
   *
   * @schema VaultDynamicSecretSpecProviderAuthIamSecretRef#secretAccessKeySecretRef
   */
  readonly secretAccessKeySecretRef?: VaultDynamicSecretSpecProviderAuthIamSecretRefSecretAccessKeySecretRef;

  /**
   * The SessionToken used for authentication This must be defined if AccessKeyID and SecretAccessKey are temporary credentials see: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_use-resources.html
   *
   * @schema VaultDynamicSecretSpecProviderAuthIamSecretRef#sessionTokenSecretRef
   */
  readonly sessionTokenSecretRef?: VaultDynamicSecretSpecProviderAuthIamSecretRefSessionTokenSecretRef;

}

/**
 * Converts an object of type 'VaultDynamicSecretSpecProviderAuthIamSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultDynamicSecretSpecProviderAuthIamSecretRef(obj: VaultDynamicSecretSpecProviderAuthIamSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessKeyIDSecretRef': toJson_VaultDynamicSecretSpecProviderAuthIamSecretRefAccessKeyIdSecretRef(obj.accessKeyIdSecretRef),
    'secretAccessKeySecretRef': toJson_VaultDynamicSecretSpecProviderAuthIamSecretRefSecretAccessKeySecretRef(obj.secretAccessKeySecretRef),
    'sessionTokenSecretRef': toJson_VaultDynamicSecretSpecProviderAuthIamSecretRefSessionTokenSecretRef(obj.sessionTokenSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Optional ServiceAccountToken specifies the Kubernetes service account for which to request a token for with the `TokenRequest` API.
 *
 * @schema VaultDynamicSecretSpecProviderAuthJwtKubernetesServiceAccountToken
 */
export interface VaultDynamicSecretSpecProviderAuthJwtKubernetesServiceAccountToken {
  /**
   * Optional audiences field that will be used to request a temporary Kubernetes service account token for the service account referenced by `serviceAccountRef`. Defaults to a single audience `vault` it not specified. Deprecated: use serviceAccountRef.Audiences instead
   *
   * @default a single audience `vault` it not specified. Deprecated: use serviceAccountRef.Audiences instead
   * @schema VaultDynamicSecretSpecProviderAuthJwtKubernetesServiceAccountToken#audiences
   */
  readonly audiences?: string[];

  /**
   * Optional expiration time in seconds that will be used to request a temporary Kubernetes service account token for the service account referenced by `serviceAccountRef`. Deprecated: this will be removed in the future. Defaults to 10 minutes.
   *
   * @default 10 minutes.
   * @schema VaultDynamicSecretSpecProviderAuthJwtKubernetesServiceAccountToken#expirationSeconds
   */
  readonly expirationSeconds?: number;

  /**
   * Service account field containing the name of a kubernetes ServiceAccount.
   *
   * @schema VaultDynamicSecretSpecProviderAuthJwtKubernetesServiceAccountToken#serviceAccountRef
   */
  readonly serviceAccountRef: VaultDynamicSecretSpecProviderAuthJwtKubernetesServiceAccountTokenServiceAccountRef;

}

/**
 * Converts an object of type 'VaultDynamicSecretSpecProviderAuthJwtKubernetesServiceAccountToken' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultDynamicSecretSpecProviderAuthJwtKubernetesServiceAccountToken(obj: VaultDynamicSecretSpecProviderAuthJwtKubernetesServiceAccountToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'expirationSeconds': obj.expirationSeconds,
    'serviceAccountRef': toJson_VaultDynamicSecretSpecProviderAuthJwtKubernetesServiceAccountTokenServiceAccountRef(obj.serviceAccountRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Optional SecretRef that refers to a key in a Secret resource containing JWT token to authenticate with Vault using the JWT/OIDC authentication method.
 *
 * @schema VaultDynamicSecretSpecProviderAuthJwtSecretRef
 */
export interface VaultDynamicSecretSpecProviderAuthJwtSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema VaultDynamicSecretSpecProviderAuthJwtSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema VaultDynamicSecretSpecProviderAuthJwtSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema VaultDynamicSecretSpecProviderAuthJwtSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'VaultDynamicSecretSpecProviderAuthJwtSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultDynamicSecretSpecProviderAuthJwtSecretRef(obj: VaultDynamicSecretSpecProviderAuthJwtSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Vault. If a name is specified without a key, `token` is the default. If one is not specified, the one bound to the controller will be used.
 *
 * @schema VaultDynamicSecretSpecProviderAuthKubernetesSecretRef
 */
export interface VaultDynamicSecretSpecProviderAuthKubernetesSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema VaultDynamicSecretSpecProviderAuthKubernetesSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema VaultDynamicSecretSpecProviderAuthKubernetesSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema VaultDynamicSecretSpecProviderAuthKubernetesSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'VaultDynamicSecretSpecProviderAuthKubernetesSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultDynamicSecretSpecProviderAuthKubernetesSecretRef(obj: VaultDynamicSecretSpecProviderAuthKubernetesSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Optional service account field containing the name of a kubernetes ServiceAccount. If the service account is specified, the service account secret token JWT will be used for authenticating with Vault. If the service account selector is not supplied, the secretRef will be used instead.
 *
 * @schema VaultDynamicSecretSpecProviderAuthKubernetesServiceAccountRef
 */
export interface VaultDynamicSecretSpecProviderAuthKubernetesServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
   *
   * @schema VaultDynamicSecretSpecProviderAuthKubernetesServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema VaultDynamicSecretSpecProviderAuthKubernetesServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema VaultDynamicSecretSpecProviderAuthKubernetesServiceAccountRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'VaultDynamicSecretSpecProviderAuthKubernetesServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultDynamicSecretSpecProviderAuthKubernetesServiceAccountRef(obj: VaultDynamicSecretSpecProviderAuthKubernetesServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretRef to a key in a Secret resource containing password for the LDAP user used to authenticate with Vault using the LDAP authentication method
 *
 * @schema VaultDynamicSecretSpecProviderAuthLdapSecretRef
 */
export interface VaultDynamicSecretSpecProviderAuthLdapSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema VaultDynamicSecretSpecProviderAuthLdapSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema VaultDynamicSecretSpecProviderAuthLdapSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema VaultDynamicSecretSpecProviderAuthLdapSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'VaultDynamicSecretSpecProviderAuthLdapSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultDynamicSecretSpecProviderAuthLdapSecretRef(obj: VaultDynamicSecretSpecProviderAuthLdapSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretRef to a key in a Secret resource containing password for the user used to authenticate with Vault using the UserPass authentication method
 *
 * @schema VaultDynamicSecretSpecProviderAuthUserPassSecretRef
 */
export interface VaultDynamicSecretSpecProviderAuthUserPassSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema VaultDynamicSecretSpecProviderAuthUserPassSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema VaultDynamicSecretSpecProviderAuthUserPassSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema VaultDynamicSecretSpecProviderAuthUserPassSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'VaultDynamicSecretSpecProviderAuthUserPassSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultDynamicSecretSpecProviderAuthUserPassSecretRef(obj: VaultDynamicSecretSpecProviderAuthUserPassSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A reference to a ServiceAccount resource.
 *
 * @schema VaultDynamicSecretSpecProviderAuthIamJwtServiceAccountRef
 */
export interface VaultDynamicSecretSpecProviderAuthIamJwtServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
   *
   * @schema VaultDynamicSecretSpecProviderAuthIamJwtServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema VaultDynamicSecretSpecProviderAuthIamJwtServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema VaultDynamicSecretSpecProviderAuthIamJwtServiceAccountRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'VaultDynamicSecretSpecProviderAuthIamJwtServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultDynamicSecretSpecProviderAuthIamJwtServiceAccountRef(obj: VaultDynamicSecretSpecProviderAuthIamJwtServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The AccessKeyID is used for authentication
 *
 * @schema VaultDynamicSecretSpecProviderAuthIamSecretRefAccessKeyIdSecretRef
 */
export interface VaultDynamicSecretSpecProviderAuthIamSecretRefAccessKeyIdSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema VaultDynamicSecretSpecProviderAuthIamSecretRefAccessKeyIdSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema VaultDynamicSecretSpecProviderAuthIamSecretRefAccessKeyIdSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema VaultDynamicSecretSpecProviderAuthIamSecretRefAccessKeyIdSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'VaultDynamicSecretSpecProviderAuthIamSecretRefAccessKeyIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultDynamicSecretSpecProviderAuthIamSecretRefAccessKeyIdSecretRef(obj: VaultDynamicSecretSpecProviderAuthIamSecretRefAccessKeyIdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The SecretAccessKey is used for authentication
 *
 * @schema VaultDynamicSecretSpecProviderAuthIamSecretRefSecretAccessKeySecretRef
 */
export interface VaultDynamicSecretSpecProviderAuthIamSecretRefSecretAccessKeySecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema VaultDynamicSecretSpecProviderAuthIamSecretRefSecretAccessKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema VaultDynamicSecretSpecProviderAuthIamSecretRefSecretAccessKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema VaultDynamicSecretSpecProviderAuthIamSecretRefSecretAccessKeySecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'VaultDynamicSecretSpecProviderAuthIamSecretRefSecretAccessKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultDynamicSecretSpecProviderAuthIamSecretRefSecretAccessKeySecretRef(obj: VaultDynamicSecretSpecProviderAuthIamSecretRefSecretAccessKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The SessionToken used for authentication This must be defined if AccessKeyID and SecretAccessKey are temporary credentials see: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_use-resources.html
 *
 * @schema VaultDynamicSecretSpecProviderAuthIamSecretRefSessionTokenSecretRef
 */
export interface VaultDynamicSecretSpecProviderAuthIamSecretRefSessionTokenSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema VaultDynamicSecretSpecProviderAuthIamSecretRefSessionTokenSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema VaultDynamicSecretSpecProviderAuthIamSecretRefSessionTokenSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema VaultDynamicSecretSpecProviderAuthIamSecretRefSessionTokenSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'VaultDynamicSecretSpecProviderAuthIamSecretRefSessionTokenSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultDynamicSecretSpecProviderAuthIamSecretRefSessionTokenSecretRef(obj: VaultDynamicSecretSpecProviderAuthIamSecretRefSessionTokenSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Service account field containing the name of a kubernetes ServiceAccount.
 *
 * @schema VaultDynamicSecretSpecProviderAuthJwtKubernetesServiceAccountTokenServiceAccountRef
 */
export interface VaultDynamicSecretSpecProviderAuthJwtKubernetesServiceAccountTokenServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
   *
   * @schema VaultDynamicSecretSpecProviderAuthJwtKubernetesServiceAccountTokenServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema VaultDynamicSecretSpecProviderAuthJwtKubernetesServiceAccountTokenServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema VaultDynamicSecretSpecProviderAuthJwtKubernetesServiceAccountTokenServiceAccountRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'VaultDynamicSecretSpecProviderAuthJwtKubernetesServiceAccountTokenServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VaultDynamicSecretSpecProviderAuthJwtKubernetesServiceAccountTokenServiceAccountRef(obj: VaultDynamicSecretSpecProviderAuthJwtKubernetesServiceAccountTokenServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

