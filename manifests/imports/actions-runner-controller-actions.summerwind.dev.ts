// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * HorizontalRunnerAutoscaler is the Schema for the horizontalrunnerautoscaler API
 *
 * @schema HorizontalRunnerAutoscaler
 */
export class HorizontalRunnerAutoscaler extends ApiObject {
  /**
   * Returns the apiVersion and kind for "HorizontalRunnerAutoscaler"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'actions.summerwind.dev/v1alpha1',
    kind: 'HorizontalRunnerAutoscaler',
  }

  /**
   * Renders a Kubernetes manifest for "HorizontalRunnerAutoscaler".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: HorizontalRunnerAutoscalerProps = {}): any {
    return {
      ...HorizontalRunnerAutoscaler.GVK,
      ...toJson_HorizontalRunnerAutoscalerProps(props),
    };
  }

  /**
   * Defines a "HorizontalRunnerAutoscaler" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: HorizontalRunnerAutoscalerProps = {}) {
    super(scope, id, {
      ...HorizontalRunnerAutoscaler.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...HorizontalRunnerAutoscaler.GVK,
      ...toJson_HorizontalRunnerAutoscalerProps(resolved),
    };
  }
}

/**
 * HorizontalRunnerAutoscaler is the Schema for the horizontalrunnerautoscaler API
 *
 * @schema HorizontalRunnerAutoscaler
 */
export interface HorizontalRunnerAutoscalerProps {
  /**
   * @schema HorizontalRunnerAutoscaler#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * HorizontalRunnerAutoscalerSpec defines the desired state of HorizontalRunnerAutoscaler
   *
   * @schema HorizontalRunnerAutoscaler#spec
   */
  readonly spec?: HorizontalRunnerAutoscalerSpec;

}

/**
 * Converts an object of type 'HorizontalRunnerAutoscalerProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HorizontalRunnerAutoscalerProps(obj: HorizontalRunnerAutoscalerProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_HorizontalRunnerAutoscalerSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HorizontalRunnerAutoscalerSpec defines the desired state of HorizontalRunnerAutoscaler
 *
 * @schema HorizontalRunnerAutoscalerSpec
 */
export interface HorizontalRunnerAutoscalerSpec {
  /**
   * @schema HorizontalRunnerAutoscalerSpec#capacityReservations
   */
  readonly capacityReservations?: HorizontalRunnerAutoscalerSpecCapacityReservations[];

  /**
   * MaxReplicas is the maximum number of replicas the deployment is allowed to scale
   *
   * @schema HorizontalRunnerAutoscalerSpec#maxReplicas
   */
  readonly maxReplicas?: number;

  /**
   * Metrics is the collection of various metric targets to calculate desired number of runners
   *
   * @schema HorizontalRunnerAutoscalerSpec#metrics
   */
  readonly metrics?: HorizontalRunnerAutoscalerSpecMetrics[];

  /**
   * MinReplicas is the minimum number of replicas the deployment is allowed to scale
   *
   * @schema HorizontalRunnerAutoscalerSpec#minReplicas
   */
  readonly minReplicas?: number;

  /**
   * ScaleDownDelaySecondsAfterScaleUp is the approximate delay for a scale down followed by a scale up Used to prevent flapping (down->up->down->... loop)
   *
   * @schema HorizontalRunnerAutoscalerSpec#scaleDownDelaySecondsAfterScaleOut
   */
  readonly scaleDownDelaySecondsAfterScaleOut?: number;

  /**
   * ScaleTargetRef sis the reference to scaled resource like RunnerDeployment
   *
   * @schema HorizontalRunnerAutoscalerSpec#scaleTargetRef
   */
  readonly scaleTargetRef?: HorizontalRunnerAutoscalerSpecScaleTargetRef;

  /**
   * ScaleUpTriggers is an experimental feature to increase the desired replicas by 1 on each webhook requested received by the webhookBasedAutoscaler.
   * This feature requires you to also enable and deploy the webhookBasedAutoscaler onto your cluster.
   * Note that the added runners remain until the next sync period at least, and they may or may not be used by GitHub Actions depending on the timing. They are intended to be used to gain "resource slack" immediately after you receive a webhook from GitHub, so that you can loosely expect MinReplicas runners to be always available.
   *
   * @schema HorizontalRunnerAutoscalerSpec#scaleUpTriggers
   */
  readonly scaleUpTriggers?: HorizontalRunnerAutoscalerSpecScaleUpTriggers[];

  /**
   * ScheduledOverrides is the list of ScheduledOverride. It can be used to override a few fields of HorizontalRunnerAutoscalerSpec on schedule. The earlier a scheduled override is, the higher it is prioritized.
   *
   * @schema HorizontalRunnerAutoscalerSpec#scheduledOverrides
   */
  readonly scheduledOverrides?: HorizontalRunnerAutoscalerSpecScheduledOverrides[];

}

/**
 * Converts an object of type 'HorizontalRunnerAutoscalerSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HorizontalRunnerAutoscalerSpec(obj: HorizontalRunnerAutoscalerSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'capacityReservations': obj.capacityReservations?.map(y => toJson_HorizontalRunnerAutoscalerSpecCapacityReservations(y)),
    'maxReplicas': obj.maxReplicas,
    'metrics': obj.metrics?.map(y => toJson_HorizontalRunnerAutoscalerSpecMetrics(y)),
    'minReplicas': obj.minReplicas,
    'scaleDownDelaySecondsAfterScaleOut': obj.scaleDownDelaySecondsAfterScaleOut,
    'scaleTargetRef': toJson_HorizontalRunnerAutoscalerSpecScaleTargetRef(obj.scaleTargetRef),
    'scaleUpTriggers': obj.scaleUpTriggers?.map(y => toJson_HorizontalRunnerAutoscalerSpecScaleUpTriggers(y)),
    'scheduledOverrides': obj.scheduledOverrides?.map(y => toJson_HorizontalRunnerAutoscalerSpecScheduledOverrides(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CapacityReservation specifies the number of replicas temporarily added to the scale target until ExpirationTime.
 *
 * @schema HorizontalRunnerAutoscalerSpecCapacityReservations
 */
export interface HorizontalRunnerAutoscalerSpecCapacityReservations {
  /**
   * @schema HorizontalRunnerAutoscalerSpecCapacityReservations#effectiveTime
   */
  readonly effectiveTime?: Date;

  /**
   * @schema HorizontalRunnerAutoscalerSpecCapacityReservations#expirationTime
   */
  readonly expirationTime?: Date;

  /**
   * @schema HorizontalRunnerAutoscalerSpecCapacityReservations#name
   */
  readonly name?: string;

  /**
   * @schema HorizontalRunnerAutoscalerSpecCapacityReservations#replicas
   */
  readonly replicas?: number;

}

/**
 * Converts an object of type 'HorizontalRunnerAutoscalerSpecCapacityReservations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HorizontalRunnerAutoscalerSpecCapacityReservations(obj: HorizontalRunnerAutoscalerSpecCapacityReservations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effectiveTime': obj.effectiveTime?.toISOString(),
    'expirationTime': obj.expirationTime?.toISOString(),
    'name': obj.name,
    'replicas': obj.replicas,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema HorizontalRunnerAutoscalerSpecMetrics
 */
export interface HorizontalRunnerAutoscalerSpecMetrics {
  /**
   * RepositoryNames is the list of repository names to be used for calculating the metric. For example, a repository name is the REPO part of `github.com/USER/REPO`.
   *
   * @schema HorizontalRunnerAutoscalerSpecMetrics#repositoryNames
   */
  readonly repositoryNames?: string[];

  /**
   * ScaleDownAdjustment is the number of runners removed on scale-down. You can only specify either ScaleDownFactor or ScaleDownAdjustment.
   *
   * @schema HorizontalRunnerAutoscalerSpecMetrics#scaleDownAdjustment
   */
  readonly scaleDownAdjustment?: number;

  /**
   * ScaleDownFactor is the multiplicative factor applied to the current number of runners used to determine how many pods should be removed.
   *
   * @schema HorizontalRunnerAutoscalerSpecMetrics#scaleDownFactor
   */
  readonly scaleDownFactor?: string;

  /**
   * ScaleDownThreshold is the percentage of busy runners less than which will trigger the hpa to scale the runners down.
   *
   * @schema HorizontalRunnerAutoscalerSpecMetrics#scaleDownThreshold
   */
  readonly scaleDownThreshold?: string;

  /**
   * ScaleUpAdjustment is the number of runners added on scale-up. You can only specify either ScaleUpFactor or ScaleUpAdjustment.
   *
   * @schema HorizontalRunnerAutoscalerSpecMetrics#scaleUpAdjustment
   */
  readonly scaleUpAdjustment?: number;

  /**
   * ScaleUpFactor is the multiplicative factor applied to the current number of runners used to determine how many pods should be added.
   *
   * @schema HorizontalRunnerAutoscalerSpecMetrics#scaleUpFactor
   */
  readonly scaleUpFactor?: string;

  /**
   * ScaleUpThreshold is the percentage of busy runners greater than which will trigger the hpa to scale runners up.
   *
   * @schema HorizontalRunnerAutoscalerSpecMetrics#scaleUpThreshold
   */
  readonly scaleUpThreshold?: string;

  /**
   * Type is the type of metric to be used for autoscaling. The only supported Type is TotalNumberOfQueuedAndInProgressWorkflowRuns
   *
   * @schema HorizontalRunnerAutoscalerSpecMetrics#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'HorizontalRunnerAutoscalerSpecMetrics' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HorizontalRunnerAutoscalerSpecMetrics(obj: HorizontalRunnerAutoscalerSpecMetrics | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'repositoryNames': obj.repositoryNames?.map(y => y),
    'scaleDownAdjustment': obj.scaleDownAdjustment,
    'scaleDownFactor': obj.scaleDownFactor,
    'scaleDownThreshold': obj.scaleDownThreshold,
    'scaleUpAdjustment': obj.scaleUpAdjustment,
    'scaleUpFactor': obj.scaleUpFactor,
    'scaleUpThreshold': obj.scaleUpThreshold,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ScaleTargetRef sis the reference to scaled resource like RunnerDeployment
 *
 * @schema HorizontalRunnerAutoscalerSpecScaleTargetRef
 */
export interface HorizontalRunnerAutoscalerSpecScaleTargetRef {
  /**
   * Kind is the type of resource being referenced
   *
   * @schema HorizontalRunnerAutoscalerSpecScaleTargetRef#kind
   */
  readonly kind?: HorizontalRunnerAutoscalerSpecScaleTargetRefKind;

  /**
   * Name is the name of resource being referenced
   *
   * @schema HorizontalRunnerAutoscalerSpecScaleTargetRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'HorizontalRunnerAutoscalerSpecScaleTargetRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HorizontalRunnerAutoscalerSpecScaleTargetRef(obj: HorizontalRunnerAutoscalerSpecScaleTargetRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema HorizontalRunnerAutoscalerSpecScaleUpTriggers
 */
export interface HorizontalRunnerAutoscalerSpecScaleUpTriggers {
  /**
   * @schema HorizontalRunnerAutoscalerSpecScaleUpTriggers#amount
   */
  readonly amount?: number;

  /**
   * @schema HorizontalRunnerAutoscalerSpecScaleUpTriggers#duration
   */
  readonly duration?: string;

  /**
   * @schema HorizontalRunnerAutoscalerSpecScaleUpTriggers#githubEvent
   */
  readonly githubEvent?: HorizontalRunnerAutoscalerSpecScaleUpTriggersGithubEvent;

}

/**
 * Converts an object of type 'HorizontalRunnerAutoscalerSpecScaleUpTriggers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HorizontalRunnerAutoscalerSpecScaleUpTriggers(obj: HorizontalRunnerAutoscalerSpecScaleUpTriggers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'amount': obj.amount,
    'duration': obj.duration,
    'githubEvent': toJson_HorizontalRunnerAutoscalerSpecScaleUpTriggersGithubEvent(obj.githubEvent),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ScheduledOverride can be used to override a few fields of HorizontalRunnerAutoscalerSpec on schedule. A schedule can optionally be recurring, so that the correspoding override happens every day, week, month, or year.
 *
 * @schema HorizontalRunnerAutoscalerSpecScheduledOverrides
 */
export interface HorizontalRunnerAutoscalerSpecScheduledOverrides {
  /**
   * EndTime is the time at which the first override ends.
   *
   * @schema HorizontalRunnerAutoscalerSpecScheduledOverrides#endTime
   */
  readonly endTime: Date;

  /**
   * MinReplicas is the number of runners while overriding. If omitted, it doesn't override minReplicas.
   *
   * @schema HorizontalRunnerAutoscalerSpecScheduledOverrides#minReplicas
   */
  readonly minReplicas?: number;

  /**
   * @schema HorizontalRunnerAutoscalerSpecScheduledOverrides#recurrenceRule
   */
  readonly recurrenceRule?: HorizontalRunnerAutoscalerSpecScheduledOverridesRecurrenceRule;

  /**
   * StartTime is the time at which the first override starts.
   *
   * @schema HorizontalRunnerAutoscalerSpecScheduledOverrides#startTime
   */
  readonly startTime: Date;

}

/**
 * Converts an object of type 'HorizontalRunnerAutoscalerSpecScheduledOverrides' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HorizontalRunnerAutoscalerSpecScheduledOverrides(obj: HorizontalRunnerAutoscalerSpecScheduledOverrides | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'endTime': obj.endTime?.toISOString(),
    'minReplicas': obj.minReplicas,
    'recurrenceRule': toJson_HorizontalRunnerAutoscalerSpecScheduledOverridesRecurrenceRule(obj.recurrenceRule),
    'startTime': obj.startTime?.toISOString(),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Kind is the type of resource being referenced
 *
 * @schema HorizontalRunnerAutoscalerSpecScaleTargetRefKind
 */
export enum HorizontalRunnerAutoscalerSpecScaleTargetRefKind {
  /** RunnerDeployment */
  RUNNER_DEPLOYMENT = 'RunnerDeployment',
  /** RunnerSet */
  RUNNER_SET = 'RunnerSet',
}

/**
 * @schema HorizontalRunnerAutoscalerSpecScaleUpTriggersGithubEvent
 */
export interface HorizontalRunnerAutoscalerSpecScaleUpTriggersGithubEvent {
  /**
   * https://docs.github.com/en/actions/reference/events-that-trigger-workflows#check_run
   *
   * @schema HorizontalRunnerAutoscalerSpecScaleUpTriggersGithubEvent#checkRun
   */
  readonly checkRun?: HorizontalRunnerAutoscalerSpecScaleUpTriggersGithubEventCheckRun;

  /**
   * https://docs.github.com/en/actions/reference/events-that-trigger-workflows#pull_request
   *
   * @schema HorizontalRunnerAutoscalerSpecScaleUpTriggersGithubEvent#pullRequest
   */
  readonly pullRequest?: HorizontalRunnerAutoscalerSpecScaleUpTriggersGithubEventPullRequest;

  /**
   * PushSpec is the condition for triggering scale-up on push event Also see https://docs.github.com/en/actions/reference/events-that-trigger-workflows#push
   *
   * @schema HorizontalRunnerAutoscalerSpecScaleUpTriggersGithubEvent#push
   */
  readonly push?: any;

}

/**
 * Converts an object of type 'HorizontalRunnerAutoscalerSpecScaleUpTriggersGithubEvent' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HorizontalRunnerAutoscalerSpecScaleUpTriggersGithubEvent(obj: HorizontalRunnerAutoscalerSpecScaleUpTriggersGithubEvent | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'checkRun': toJson_HorizontalRunnerAutoscalerSpecScaleUpTriggersGithubEventCheckRun(obj.checkRun),
    'pullRequest': toJson_HorizontalRunnerAutoscalerSpecScaleUpTriggersGithubEventPullRequest(obj.pullRequest),
    'push': obj.push,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema HorizontalRunnerAutoscalerSpecScheduledOverridesRecurrenceRule
 */
export interface HorizontalRunnerAutoscalerSpecScheduledOverridesRecurrenceRule {
  /**
   * Frequency is the name of a predefined interval of each recurrence. The valid values are "Daily", "Weekly", "Monthly", and "Yearly". If empty, the corresponding override happens only once.
   *
   * @schema HorizontalRunnerAutoscalerSpecScheduledOverridesRecurrenceRule#frequency
   */
  readonly frequency?: HorizontalRunnerAutoscalerSpecScheduledOverridesRecurrenceRuleFrequency;

  /**
   * UntilTime is the time of the final recurrence. If empty, the schedule recurs forever.
   *
   * @schema HorizontalRunnerAutoscalerSpecScheduledOverridesRecurrenceRule#untilTime
   */
  readonly untilTime?: Date;

}

/**
 * Converts an object of type 'HorizontalRunnerAutoscalerSpecScheduledOverridesRecurrenceRule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HorizontalRunnerAutoscalerSpecScheduledOverridesRecurrenceRule(obj: HorizontalRunnerAutoscalerSpecScheduledOverridesRecurrenceRule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'frequency': obj.frequency,
    'untilTime': obj.untilTime?.toISOString(),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * https://docs.github.com/en/actions/reference/events-that-trigger-workflows#check_run
 *
 * @schema HorizontalRunnerAutoscalerSpecScaleUpTriggersGithubEventCheckRun
 */
export interface HorizontalRunnerAutoscalerSpecScaleUpTriggersGithubEventCheckRun {
  /**
   * Names is a list of GitHub Actions glob patterns. Any check_run event whose name matches one of patterns in the list can trigger autoscaling. Note that check_run name seem to equal to the job name you've defined in your actions workflow yaml file. So it is very likely that you can utilize this to trigger depending on the job.
   *
   * @schema HorizontalRunnerAutoscalerSpecScaleUpTriggersGithubEventCheckRun#names
   */
  readonly names?: string[];

  /**
   * Repositories is a list of GitHub repositories. Any check_run event whose repository matches one of repositories in the list can trigger autoscaling.
   *
   * @schema HorizontalRunnerAutoscalerSpecScaleUpTriggersGithubEventCheckRun#repositories
   */
  readonly repositories?: string[];

  /**
   * @schema HorizontalRunnerAutoscalerSpecScaleUpTriggersGithubEventCheckRun#status
   */
  readonly status?: string;

  /**
   * @schema HorizontalRunnerAutoscalerSpecScaleUpTriggersGithubEventCheckRun#types
   */
  readonly types?: string[];

}

/**
 * Converts an object of type 'HorizontalRunnerAutoscalerSpecScaleUpTriggersGithubEventCheckRun' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HorizontalRunnerAutoscalerSpecScaleUpTriggersGithubEventCheckRun(obj: HorizontalRunnerAutoscalerSpecScaleUpTriggersGithubEventCheckRun | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'names': obj.names?.map(y => y),
    'repositories': obj.repositories?.map(y => y),
    'status': obj.status,
    'types': obj.types?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * https://docs.github.com/en/actions/reference/events-that-trigger-workflows#pull_request
 *
 * @schema HorizontalRunnerAutoscalerSpecScaleUpTriggersGithubEventPullRequest
 */
export interface HorizontalRunnerAutoscalerSpecScaleUpTriggersGithubEventPullRequest {
  /**
   * @schema HorizontalRunnerAutoscalerSpecScaleUpTriggersGithubEventPullRequest#branches
   */
  readonly branches?: string[];

  /**
   * @schema HorizontalRunnerAutoscalerSpecScaleUpTriggersGithubEventPullRequest#types
   */
  readonly types?: string[];

}

/**
 * Converts an object of type 'HorizontalRunnerAutoscalerSpecScaleUpTriggersGithubEventPullRequest' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HorizontalRunnerAutoscalerSpecScaleUpTriggersGithubEventPullRequest(obj: HorizontalRunnerAutoscalerSpecScaleUpTriggersGithubEventPullRequest | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'branches': obj.branches?.map(y => y),
    'types': obj.types?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Frequency is the name of a predefined interval of each recurrence. The valid values are "Daily", "Weekly", "Monthly", and "Yearly". If empty, the corresponding override happens only once.
 *
 * @schema HorizontalRunnerAutoscalerSpecScheduledOverridesRecurrenceRuleFrequency
 */
export enum HorizontalRunnerAutoscalerSpecScheduledOverridesRecurrenceRuleFrequency {
  /** Daily */
  DAILY = 'Daily',
  /** Weekly */
  WEEKLY = 'Weekly',
  /** Monthly */
  MONTHLY = 'Monthly',
  /** Yearly */
  YEARLY = 'Yearly',
}


/**
 * Runner is the Schema for the runners API
 *
 * @schema Runner
 */
export class Runner extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Runner"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'actions.summerwind.dev/v1alpha1',
    kind: 'Runner',
  }

  /**
   * Renders a Kubernetes manifest for "Runner".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: RunnerProps = {}): any {
    return {
      ...Runner.GVK,
      ...toJson_RunnerProps(props),
    };
  }

  /**
   * Defines a "Runner" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: RunnerProps = {}) {
    super(scope, id, {
      ...Runner.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Runner.GVK,
      ...toJson_RunnerProps(resolved),
    };
  }
}

/**
 * Runner is the Schema for the runners API
 *
 * @schema Runner
 */
export interface RunnerProps {
  /**
   * @schema Runner#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * RunnerSpec defines the desired state of Runner
   *
   * @schema Runner#spec
   */
  readonly spec?: RunnerSpec;

}

/**
 * Converts an object of type 'RunnerProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerProps(obj: RunnerProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_RunnerSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RunnerSpec defines the desired state of Runner
 *
 * @schema RunnerSpec
 */
export interface RunnerSpec {
  /**
   * Affinity is a group of affinity scheduling rules.
   *
   * @schema RunnerSpec#affinity
   */
  readonly affinity?: RunnerSpecAffinity;

  /**
   * @schema RunnerSpec#automountServiceAccountToken
   */
  readonly automountServiceAccountToken?: boolean;

  /**
   * @schema RunnerSpec#containers
   */
  readonly containers?: RunnerSpecContainers[];

  /**
   * @schema RunnerSpec#dnsConfig
   */
  readonly dnsConfig?: RunnerSpecDnsConfig[];

  /**
   * @schema RunnerSpec#dockerEnabled
   */
  readonly dockerEnabled?: boolean;

  /**
   * @schema RunnerSpec#dockerEnv
   */
  readonly dockerEnv?: RunnerSpecDockerEnv[];

  /**
   * @schema RunnerSpec#dockerMTU
   */
  readonly dockerMtu?: number;

  /**
   * @schema RunnerSpec#dockerRegistryMirror
   */
  readonly dockerRegistryMirror?: string;

  /**
   * @schema RunnerSpec#dockerVolumeMounts
   */
  readonly dockerVolumeMounts?: RunnerSpecDockerVolumeMounts[];

  /**
   * ResourceRequirements describes the compute resource requirements.
   *
   * @schema RunnerSpec#dockerdContainerResources
   */
  readonly dockerdContainerResources?: RunnerSpecDockerdContainerResources;

  /**
   * @schema RunnerSpec#dockerdWithinRunnerContainer
   */
  readonly dockerdWithinRunnerContainer?: boolean;

  /**
   * @schema RunnerSpec#enableServiceLinks
   */
  readonly enableServiceLinks?: boolean;

  /**
   * @schema RunnerSpec#enterprise
   */
  readonly enterprise?: string;

  /**
   * @schema RunnerSpec#env
   */
  readonly env?: RunnerSpecEnv[];

  /**
   * @schema RunnerSpec#envFrom
   */
  readonly envFrom?: RunnerSpecEnvFrom[];

  /**
   * @schema RunnerSpec#ephemeral
   */
  readonly ephemeral?: boolean;

  /**
   * @schema RunnerSpec#ephemeralContainers
   */
  readonly ephemeralContainers?: RunnerSpecEphemeralContainers[];

  /**
   * @schema RunnerSpec#group
   */
  readonly group?: string;

  /**
   * @schema RunnerSpec#hostAliases
   */
  readonly hostAliases?: RunnerSpecHostAliases[];

  /**
   * @schema RunnerSpec#image
   */
  readonly image?: string;

  /**
   * PullPolicy describes a policy for if/when to pull a container image
   *
   * @schema RunnerSpec#imagePullPolicy
   */
  readonly imagePullPolicy?: string;

  /**
   * @schema RunnerSpec#imagePullSecrets
   */
  readonly imagePullSecrets?: RunnerSpecImagePullSecrets[];

  /**
   * @schema RunnerSpec#initContainers
   */
  readonly initContainers?: RunnerSpecInitContainers[];

  /**
   * @schema RunnerSpec#labels
   */
  readonly labels?: string[];

  /**
   * @schema RunnerSpec#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * @schema RunnerSpec#organization
   */
  readonly organization?: string;

  /**
   * @schema RunnerSpec#repository
   */
  readonly repository?: string;

  /**
   * ResourceRequirements describes the compute resource requirements.
   *
   * @schema RunnerSpec#resources
   */
  readonly resources?: RunnerSpecResources;

  /**
   * RuntimeClassName is the container runtime configuration that containers should run under. More info: https://kubernetes.io/docs/concepts/containers/runtime-class
   *
   * @schema RunnerSpec#runtimeClassName
   */
  readonly runtimeClassName?: string;

  /**
   * PodSecurityContext holds pod-level security attributes and common container settings. Some fields are also present in container.securityContext.  Field values of container.securityContext take precedence over field values of PodSecurityContext.
   *
   * @schema RunnerSpec#securityContext
   */
  readonly securityContext?: RunnerSpecSecurityContext;

  /**
   * @schema RunnerSpec#serviceAccountName
   */
  readonly serviceAccountName?: string;

  /**
   * @schema RunnerSpec#sidecarContainers
   */
  readonly sidecarContainers?: RunnerSpecSidecarContainers[];

  /**
   * @schema RunnerSpec#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * @schema RunnerSpec#tolerations
   */
  readonly tolerations?: RunnerSpecTolerations[];

  /**
   * @schema RunnerSpec#topologySpreadConstraint
   */
  readonly topologySpreadConstraint?: RunnerSpecTopologySpreadConstraint[];

  /**
   * @schema RunnerSpec#volumeMounts
   */
  readonly volumeMounts?: RunnerSpecVolumeMounts[];

  /**
   * @schema RunnerSpec#volumeSizeLimit
   */
  readonly volumeSizeLimit?: RunnerSpecVolumeSizeLimit;

  /**
   * @schema RunnerSpec#volumeStorageMedium
   */
  readonly volumeStorageMedium?: string;

  /**
   * @schema RunnerSpec#volumes
   */
  readonly volumes?: RunnerSpecVolumes[];

  /**
   * @schema RunnerSpec#workDir
   */
  readonly workDir?: string;

}

/**
 * Converts an object of type 'RunnerSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpec(obj: RunnerSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'affinity': toJson_RunnerSpecAffinity(obj.affinity),
    'automountServiceAccountToken': obj.automountServiceAccountToken,
    'containers': obj.containers?.map(y => toJson_RunnerSpecContainers(y)),
    'dnsConfig': obj.dnsConfig?.map(y => toJson_RunnerSpecDnsConfig(y)),
    'dockerEnabled': obj.dockerEnabled,
    'dockerEnv': obj.dockerEnv?.map(y => toJson_RunnerSpecDockerEnv(y)),
    'dockerMTU': obj.dockerMtu,
    'dockerRegistryMirror': obj.dockerRegistryMirror,
    'dockerVolumeMounts': obj.dockerVolumeMounts?.map(y => toJson_RunnerSpecDockerVolumeMounts(y)),
    'dockerdContainerResources': toJson_RunnerSpecDockerdContainerResources(obj.dockerdContainerResources),
    'dockerdWithinRunnerContainer': obj.dockerdWithinRunnerContainer,
    'enableServiceLinks': obj.enableServiceLinks,
    'enterprise': obj.enterprise,
    'env': obj.env?.map(y => toJson_RunnerSpecEnv(y)),
    'envFrom': obj.envFrom?.map(y => toJson_RunnerSpecEnvFrom(y)),
    'ephemeral': obj.ephemeral,
    'ephemeralContainers': obj.ephemeralContainers?.map(y => toJson_RunnerSpecEphemeralContainers(y)),
    'group': obj.group,
    'hostAliases': obj.hostAliases?.map(y => toJson_RunnerSpecHostAliases(y)),
    'image': obj.image,
    'imagePullPolicy': obj.imagePullPolicy,
    'imagePullSecrets': obj.imagePullSecrets?.map(y => toJson_RunnerSpecImagePullSecrets(y)),
    'initContainers': obj.initContainers?.map(y => toJson_RunnerSpecInitContainers(y)),
    'labels': obj.labels?.map(y => y),
    'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'organization': obj.organization,
    'repository': obj.repository,
    'resources': toJson_RunnerSpecResources(obj.resources),
    'runtimeClassName': obj.runtimeClassName,
    'securityContext': toJson_RunnerSpecSecurityContext(obj.securityContext),
    'serviceAccountName': obj.serviceAccountName,
    'sidecarContainers': obj.sidecarContainers?.map(y => toJson_RunnerSpecSidecarContainers(y)),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'tolerations': obj.tolerations?.map(y => toJson_RunnerSpecTolerations(y)),
    'topologySpreadConstraint': obj.topologySpreadConstraint?.map(y => toJson_RunnerSpecTopologySpreadConstraint(y)),
    'volumeMounts': obj.volumeMounts?.map(y => toJson_RunnerSpecVolumeMounts(y)),
    'volumeSizeLimit': obj.volumeSizeLimit?.value,
    'volumeStorageMedium': obj.volumeStorageMedium,
    'volumes': obj.volumes?.map(y => toJson_RunnerSpecVolumes(y)),
    'workDir': obj.workDir,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Affinity is a group of affinity scheduling rules.
 *
 * @schema RunnerSpecAffinity
 */
export interface RunnerSpecAffinity {
  /**
   * Describes node affinity scheduling rules for the pod.
   *
   * @schema RunnerSpecAffinity#nodeAffinity
   */
  readonly nodeAffinity?: RunnerSpecAffinityNodeAffinity;

  /**
   * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
   *
   * @schema RunnerSpecAffinity#podAffinity
   */
  readonly podAffinity?: RunnerSpecAffinityPodAffinity;

  /**
   * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
   *
   * @schema RunnerSpecAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: RunnerSpecAffinityPodAntiAffinity;

}

/**
 * Converts an object of type 'RunnerSpecAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecAffinity(obj: RunnerSpecAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeAffinity': toJson_RunnerSpecAffinityNodeAffinity(obj.nodeAffinity),
    'podAffinity': toJson_RunnerSpecAffinityPodAffinity(obj.podAffinity),
    'podAntiAffinity': toJson_RunnerSpecAffinityPodAntiAffinity(obj.podAntiAffinity),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A single application container that you want to run within a pod.
 *
 * @schema RunnerSpecContainers
 */
export interface RunnerSpecContainers {
  /**
   * Arguments to the entrypoint. The docker image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema RunnerSpecContainers#args
   */
  readonly args?: string[];

  /**
   * Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema RunnerSpecContainers#command
   */
  readonly command?: string[];

  /**
   * List of environment variables to set in the container. Cannot be updated.
   *
   * @schema RunnerSpecContainers#env
   */
  readonly env?: RunnerSpecContainersEnv[];

  /**
   * List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
   *
   * @schema RunnerSpecContainers#envFrom
   */
  readonly envFrom?: RunnerSpecContainersEnvFrom[];

  /**
   * Docker image name. More info: https://kubernetes.io/docs/concepts/containers/images This field is optional to allow higher level config management to default or override container images in workload controllers like Deployments and StatefulSets.
   *
   * @schema RunnerSpecContainers#image
   */
  readonly image?: string;

  /**
   * Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   *
   * @default Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   * @schema RunnerSpecContainers#imagePullPolicy
   */
  readonly imagePullPolicy?: string;

  /**
   * Actions that the management system should take in response to container lifecycle events. Cannot be updated.
   *
   * @schema RunnerSpecContainers#lifecycle
   */
  readonly lifecycle?: RunnerSpecContainersLifecycle;

  /**
   * Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerSpecContainers#livenessProbe
   */
  readonly livenessProbe?: RunnerSpecContainersLivenessProbe;

  /**
   * Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.
   *
   * @schema RunnerSpecContainers#name
   */
  readonly name: string;

  /**
   * List of ports to expose from the container. Exposing a port here gives the system additional information about the network connections a container uses, but is primarily informational. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default "0.0.0.0" address inside a container will be accessible from the network. Cannot be updated.
   *
   * @schema RunnerSpecContainers#ports
   */
  readonly ports?: RunnerSpecContainersPorts[];

  /**
   * Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerSpecContainers#readinessProbe
   */
  readonly readinessProbe?: RunnerSpecContainersReadinessProbe;

  /**
   * Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema RunnerSpecContainers#resources
   */
  readonly resources?: RunnerSpecContainersResources;

  /**
   * SecurityContext defines the security options the container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
   *
   * @schema RunnerSpecContainers#securityContext
   */
  readonly securityContext?: RunnerSpecContainersSecurityContext;

  /**
   * StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerSpecContainers#startupProbe
   */
  readonly startupProbe?: RunnerSpecContainersStartupProbe;

  /**
   * Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF. Default is false.
   *
   * @default false.
   * @schema RunnerSpecContainers#stdin
   */
  readonly stdin?: boolean;

  /**
   * Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false
   *
   * @default false
   * @schema RunnerSpecContainers#stdinOnce
   */
  readonly stdinOnce?: boolean;

  /**
   * Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Will be truncated by the node if greater than 4096 bytes. The total message length across all containers will be limited to 12kb. Defaults to /dev/termination-log. Cannot be updated.
   *
   * @default dev/termination-log. Cannot be updated.
   * @schema RunnerSpecContainers#terminationMessagePath
   */
  readonly terminationMessagePath?: string;

  /**
   * Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.
   *
   * @default File. Cannot be updated.
   * @schema RunnerSpecContainers#terminationMessagePolicy
   */
  readonly terminationMessagePolicy?: string;

  /**
   * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true. Default is false.
   *
   * @default false.
   * @schema RunnerSpecContainers#tty
   */
  readonly tty?: boolean;

  /**
   * volumeDevices is the list of block devices to be used by the container.
   *
   * @schema RunnerSpecContainers#volumeDevices
   */
  readonly volumeDevices?: RunnerSpecContainersVolumeDevices[];

  /**
   * Pod volumes to mount into the container's filesystem. Cannot be updated.
   *
   * @schema RunnerSpecContainers#volumeMounts
   */
  readonly volumeMounts?: RunnerSpecContainersVolumeMounts[];

  /**
   * Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.
   *
   * @schema RunnerSpecContainers#workingDir
   */
  readonly workingDir?: string;

}

/**
 * Converts an object of type 'RunnerSpecContainers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecContainers(obj: RunnerSpecContainers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'args': obj.args?.map(y => y),
    'command': obj.command?.map(y => y),
    'env': obj.env?.map(y => toJson_RunnerSpecContainersEnv(y)),
    'envFrom': obj.envFrom?.map(y => toJson_RunnerSpecContainersEnvFrom(y)),
    'image': obj.image,
    'imagePullPolicy': obj.imagePullPolicy,
    'lifecycle': toJson_RunnerSpecContainersLifecycle(obj.lifecycle),
    'livenessProbe': toJson_RunnerSpecContainersLivenessProbe(obj.livenessProbe),
    'name': obj.name,
    'ports': obj.ports?.map(y => toJson_RunnerSpecContainersPorts(y)),
    'readinessProbe': toJson_RunnerSpecContainersReadinessProbe(obj.readinessProbe),
    'resources': toJson_RunnerSpecContainersResources(obj.resources),
    'securityContext': toJson_RunnerSpecContainersSecurityContext(obj.securityContext),
    'startupProbe': toJson_RunnerSpecContainersStartupProbe(obj.startupProbe),
    'stdin': obj.stdin,
    'stdinOnce': obj.stdinOnce,
    'terminationMessagePath': obj.terminationMessagePath,
    'terminationMessagePolicy': obj.terminationMessagePolicy,
    'tty': obj.tty,
    'volumeDevices': obj.volumeDevices?.map(y => toJson_RunnerSpecContainersVolumeDevices(y)),
    'volumeMounts': obj.volumeMounts?.map(y => toJson_RunnerSpecContainersVolumeMounts(y)),
    'workingDir': obj.workingDir,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PodDNSConfig defines the DNS parameters of a pod in addition to those generated from DNSPolicy.
 *
 * @schema RunnerSpecDnsConfig
 */
export interface RunnerSpecDnsConfig {
  /**
   * A list of DNS name server IP addresses. This will be appended to the base nameservers generated from DNSPolicy. Duplicated nameservers will be removed.
   *
   * @schema RunnerSpecDnsConfig#nameservers
   */
  readonly nameservers?: string[];

  /**
   * A list of DNS resolver options. This will be merged with the base options generated from DNSPolicy. Duplicated entries will be removed. Resolution options given in Options will override those that appear in the base DNSPolicy.
   *
   * @schema RunnerSpecDnsConfig#options
   */
  readonly options?: RunnerSpecDnsConfigOptions[];

  /**
   * A list of DNS search domains for host-name lookup. This will be appended to the base search paths generated from DNSPolicy. Duplicated search paths will be removed.
   *
   * @schema RunnerSpecDnsConfig#searches
   */
  readonly searches?: string[];

}

/**
 * Converts an object of type 'RunnerSpecDnsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecDnsConfig(obj: RunnerSpecDnsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nameservers': obj.nameservers?.map(y => y),
    'options': obj.options?.map(y => toJson_RunnerSpecDnsConfigOptions(y)),
    'searches': obj.searches?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema RunnerSpecDockerEnv
 */
export interface RunnerSpecDockerEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema RunnerSpecDockerEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded using the previously defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
   *
   * @default .
   * @schema RunnerSpecDockerEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema RunnerSpecDockerEnv#valueFrom
   */
  readonly valueFrom?: RunnerSpecDockerEnvValueFrom;

}

/**
 * Converts an object of type 'RunnerSpecDockerEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecDockerEnv(obj: RunnerSpecDockerEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
    'valueFrom': toJson_RunnerSpecDockerEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema RunnerSpecDockerVolumeMounts
 */
export interface RunnerSpecDockerVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must not contain ':'.
   *
   * @schema RunnerSpecDockerVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. This field is beta in 1.10.
   *
   * @schema RunnerSpecDockerVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema RunnerSpecDockerVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.
   *
   * @default false.
   * @schema RunnerSpecDockerVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema RunnerSpecDockerVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment. Defaults to "" (volume's root). SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root). SubPathExpr and SubPath are mutually exclusive.
   * @schema RunnerSpecDockerVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;

}

/**
 * Converts an object of type 'RunnerSpecDockerVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecDockerVolumeMounts(obj: RunnerSpecDockerVolumeMounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'mountPropagation': obj.mountPropagation,
    'name': obj.name,
    'readOnly': obj.readOnly,
    'subPath': obj.subPath,
    'subPathExpr': obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceRequirements describes the compute resource requirements.
 *
 * @schema RunnerSpecDockerdContainerResources
 */
export interface RunnerSpecDockerdContainerResources {
  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema RunnerSpecDockerdContainerResources#limits
   */
  readonly limits?: { [key: string]: RunnerSpecDockerdContainerResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema RunnerSpecDockerdContainerResources#requests
   */
  readonly requests?: { [key: string]: RunnerSpecDockerdContainerResourcesRequests };

}

/**
 * Converts an object of type 'RunnerSpecDockerdContainerResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecDockerdContainerResources(obj: RunnerSpecDockerdContainerResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema RunnerSpecEnv
 */
export interface RunnerSpecEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema RunnerSpecEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded using the previously defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
   *
   * @default .
   * @schema RunnerSpecEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema RunnerSpecEnv#valueFrom
   */
  readonly valueFrom?: RunnerSpecEnvValueFrom;

}

/**
 * Converts an object of type 'RunnerSpecEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecEnv(obj: RunnerSpecEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
    'valueFrom': toJson_RunnerSpecEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema RunnerSpecEnvFrom
 */
export interface RunnerSpecEnvFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema RunnerSpecEnvFrom#configMapRef
   */
  readonly configMapRef?: RunnerSpecEnvFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema RunnerSpecEnvFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema RunnerSpecEnvFrom#secretRef
   */
  readonly secretRef?: RunnerSpecEnvFromSecretRef;

}

/**
 * Converts an object of type 'RunnerSpecEnvFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecEnvFrom(obj: RunnerSpecEnvFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapRef': toJson_RunnerSpecEnvFromConfigMapRef(obj.configMapRef),
    'prefix': obj.prefix,
    'secretRef': toJson_RunnerSpecEnvFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * An EphemeralContainer is a temporary container that you may add to an existing Pod for user-initiated activities such as debugging. Ephemeral containers have no resource or scheduling guarantees, and they will not be restarted when they exit or when a Pod is removed or restarted. The kubelet may evict a Pod if an ephemeral container causes the Pod to exceed its resource allocation.
 * To add an ephemeral container, use the ephemeralcontainers subresource of an existing Pod. Ephemeral containers may not be removed or restarted.
 * This is a beta feature available on clusters that haven't disabled the EphemeralContainers feature gate.
 *
 * @schema RunnerSpecEphemeralContainers
 */
export interface RunnerSpecEphemeralContainers {
  /**
   * Arguments to the entrypoint. The docker image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema RunnerSpecEphemeralContainers#args
   */
  readonly args?: string[];

  /**
   * Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema RunnerSpecEphemeralContainers#command
   */
  readonly command?: string[];

  /**
   * List of environment variables to set in the container. Cannot be updated.
   *
   * @schema RunnerSpecEphemeralContainers#env
   */
  readonly env?: RunnerSpecEphemeralContainersEnv[];

  /**
   * List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
   *
   * @schema RunnerSpecEphemeralContainers#envFrom
   */
  readonly envFrom?: RunnerSpecEphemeralContainersEnvFrom[];

  /**
   * Docker image name. More info: https://kubernetes.io/docs/concepts/containers/images
   *
   * @schema RunnerSpecEphemeralContainers#image
   */
  readonly image?: string;

  /**
   * Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   *
   * @default Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   * @schema RunnerSpecEphemeralContainers#imagePullPolicy
   */
  readonly imagePullPolicy?: string;

  /**
   * Lifecycle is not allowed for ephemeral containers.
   *
   * @schema RunnerSpecEphemeralContainers#lifecycle
   */
  readonly lifecycle?: RunnerSpecEphemeralContainersLifecycle;

  /**
   * Probes are not allowed for ephemeral containers.
   *
   * @schema RunnerSpecEphemeralContainers#livenessProbe
   */
  readonly livenessProbe?: RunnerSpecEphemeralContainersLivenessProbe;

  /**
   * Name of the ephemeral container specified as a DNS_LABEL. This name must be unique among all containers, init containers and ephemeral containers.
   *
   * @schema RunnerSpecEphemeralContainers#name
   */
  readonly name: string;

  /**
   * Ports are not allowed for ephemeral containers.
   *
   * @schema RunnerSpecEphemeralContainers#ports
   */
  readonly ports?: RunnerSpecEphemeralContainersPorts[];

  /**
   * Probes are not allowed for ephemeral containers.
   *
   * @schema RunnerSpecEphemeralContainers#readinessProbe
   */
  readonly readinessProbe?: RunnerSpecEphemeralContainersReadinessProbe;

  /**
   * Resources are not allowed for ephemeral containers. Ephemeral containers use spare resources already allocated to the pod.
   *
   * @schema RunnerSpecEphemeralContainers#resources
   */
  readonly resources?: RunnerSpecEphemeralContainersResources;

  /**
   * Optional: SecurityContext defines the security options the ephemeral container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
   *
   * @schema RunnerSpecEphemeralContainers#securityContext
   */
  readonly securityContext?: RunnerSpecEphemeralContainersSecurityContext;

  /**
   * Probes are not allowed for ephemeral containers.
   *
   * @schema RunnerSpecEphemeralContainers#startupProbe
   */
  readonly startupProbe?: RunnerSpecEphemeralContainersStartupProbe;

  /**
   * Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF. Default is false.
   *
   * @default false.
   * @schema RunnerSpecEphemeralContainers#stdin
   */
  readonly stdin?: boolean;

  /**
   * Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false
   *
   * @default false
   * @schema RunnerSpecEphemeralContainers#stdinOnce
   */
  readonly stdinOnce?: boolean;

  /**
   * If set, the name of the container from PodSpec that this ephemeral container targets. The ephemeral container will be run in the namespaces (IPC, PID, etc) of this container. If not set then the ephemeral container uses the namespaces configured in the Pod spec.
   * The container runtime must implement support for this feature. If the runtime does not support namespace targeting then the result of setting this field is undefined.
   *
   * @schema RunnerSpecEphemeralContainers#targetContainerName
   */
  readonly targetContainerName?: string;

  /**
   * Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Will be truncated by the node if greater than 4096 bytes. The total message length across all containers will be limited to 12kb. Defaults to /dev/termination-log. Cannot be updated.
   *
   * @default dev/termination-log. Cannot be updated.
   * @schema RunnerSpecEphemeralContainers#terminationMessagePath
   */
  readonly terminationMessagePath?: string;

  /**
   * Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.
   *
   * @default File. Cannot be updated.
   * @schema RunnerSpecEphemeralContainers#terminationMessagePolicy
   */
  readonly terminationMessagePolicy?: string;

  /**
   * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true. Default is false.
   *
   * @default false.
   * @schema RunnerSpecEphemeralContainers#tty
   */
  readonly tty?: boolean;

  /**
   * volumeDevices is the list of block devices to be used by the container.
   *
   * @schema RunnerSpecEphemeralContainers#volumeDevices
   */
  readonly volumeDevices?: RunnerSpecEphemeralContainersVolumeDevices[];

  /**
   * Pod volumes to mount into the container's filesystem. Subpath mounts are not allowed for ephemeral containers. Cannot be updated.
   *
   * @schema RunnerSpecEphemeralContainers#volumeMounts
   */
  readonly volumeMounts?: RunnerSpecEphemeralContainersVolumeMounts[];

  /**
   * Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.
   *
   * @schema RunnerSpecEphemeralContainers#workingDir
   */
  readonly workingDir?: string;

}

/**
 * Converts an object of type 'RunnerSpecEphemeralContainers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecEphemeralContainers(obj: RunnerSpecEphemeralContainers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'args': obj.args?.map(y => y),
    'command': obj.command?.map(y => y),
    'env': obj.env?.map(y => toJson_RunnerSpecEphemeralContainersEnv(y)),
    'envFrom': obj.envFrom?.map(y => toJson_RunnerSpecEphemeralContainersEnvFrom(y)),
    'image': obj.image,
    'imagePullPolicy': obj.imagePullPolicy,
    'lifecycle': toJson_RunnerSpecEphemeralContainersLifecycle(obj.lifecycle),
    'livenessProbe': toJson_RunnerSpecEphemeralContainersLivenessProbe(obj.livenessProbe),
    'name': obj.name,
    'ports': obj.ports?.map(y => toJson_RunnerSpecEphemeralContainersPorts(y)),
    'readinessProbe': toJson_RunnerSpecEphemeralContainersReadinessProbe(obj.readinessProbe),
    'resources': toJson_RunnerSpecEphemeralContainersResources(obj.resources),
    'securityContext': toJson_RunnerSpecEphemeralContainersSecurityContext(obj.securityContext),
    'startupProbe': toJson_RunnerSpecEphemeralContainersStartupProbe(obj.startupProbe),
    'stdin': obj.stdin,
    'stdinOnce': obj.stdinOnce,
    'targetContainerName': obj.targetContainerName,
    'terminationMessagePath': obj.terminationMessagePath,
    'terminationMessagePolicy': obj.terminationMessagePolicy,
    'tty': obj.tty,
    'volumeDevices': obj.volumeDevices?.map(y => toJson_RunnerSpecEphemeralContainersVolumeDevices(y)),
    'volumeMounts': obj.volumeMounts?.map(y => toJson_RunnerSpecEphemeralContainersVolumeMounts(y)),
    'workingDir': obj.workingDir,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod's hosts file.
 *
 * @schema RunnerSpecHostAliases
 */
export interface RunnerSpecHostAliases {
  /**
   * Hostnames for the above IP address.
   *
   * @schema RunnerSpecHostAliases#hostnames
   */
  readonly hostnames?: string[];

  /**
   * IP address of the host file entry.
   *
   * @schema RunnerSpecHostAliases#ip
   */
  readonly ip?: string;

}

/**
 * Converts an object of type 'RunnerSpecHostAliases' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecHostAliases(obj: RunnerSpecHostAliases | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostnames': obj.hostnames?.map(y => y),
    'ip': obj.ip,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
 *
 * @schema RunnerSpecImagePullSecrets
 */
export interface RunnerSpecImagePullSecrets {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerSpecImagePullSecrets#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'RunnerSpecImagePullSecrets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecImagePullSecrets(obj: RunnerSpecImagePullSecrets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A single application container that you want to run within a pod.
 *
 * @schema RunnerSpecInitContainers
 */
export interface RunnerSpecInitContainers {
  /**
   * Arguments to the entrypoint. The docker image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema RunnerSpecInitContainers#args
   */
  readonly args?: string[];

  /**
   * Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema RunnerSpecInitContainers#command
   */
  readonly command?: string[];

  /**
   * List of environment variables to set in the container. Cannot be updated.
   *
   * @schema RunnerSpecInitContainers#env
   */
  readonly env?: RunnerSpecInitContainersEnv[];

  /**
   * List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
   *
   * @schema RunnerSpecInitContainers#envFrom
   */
  readonly envFrom?: RunnerSpecInitContainersEnvFrom[];

  /**
   * Docker image name. More info: https://kubernetes.io/docs/concepts/containers/images This field is optional to allow higher level config management to default or override container images in workload controllers like Deployments and StatefulSets.
   *
   * @schema RunnerSpecInitContainers#image
   */
  readonly image?: string;

  /**
   * Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   *
   * @default Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   * @schema RunnerSpecInitContainers#imagePullPolicy
   */
  readonly imagePullPolicy?: string;

  /**
   * Actions that the management system should take in response to container lifecycle events. Cannot be updated.
   *
   * @schema RunnerSpecInitContainers#lifecycle
   */
  readonly lifecycle?: RunnerSpecInitContainersLifecycle;

  /**
   * Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerSpecInitContainers#livenessProbe
   */
  readonly livenessProbe?: RunnerSpecInitContainersLivenessProbe;

  /**
   * Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.
   *
   * @schema RunnerSpecInitContainers#name
   */
  readonly name: string;

  /**
   * List of ports to expose from the container. Exposing a port here gives the system additional information about the network connections a container uses, but is primarily informational. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default "0.0.0.0" address inside a container will be accessible from the network. Cannot be updated.
   *
   * @schema RunnerSpecInitContainers#ports
   */
  readonly ports?: RunnerSpecInitContainersPorts[];

  /**
   * Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerSpecInitContainers#readinessProbe
   */
  readonly readinessProbe?: RunnerSpecInitContainersReadinessProbe;

  /**
   * Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema RunnerSpecInitContainers#resources
   */
  readonly resources?: RunnerSpecInitContainersResources;

  /**
   * SecurityContext defines the security options the container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
   *
   * @schema RunnerSpecInitContainers#securityContext
   */
  readonly securityContext?: RunnerSpecInitContainersSecurityContext;

  /**
   * StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerSpecInitContainers#startupProbe
   */
  readonly startupProbe?: RunnerSpecInitContainersStartupProbe;

  /**
   * Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF. Default is false.
   *
   * @default false.
   * @schema RunnerSpecInitContainers#stdin
   */
  readonly stdin?: boolean;

  /**
   * Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false
   *
   * @default false
   * @schema RunnerSpecInitContainers#stdinOnce
   */
  readonly stdinOnce?: boolean;

  /**
   * Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Will be truncated by the node if greater than 4096 bytes. The total message length across all containers will be limited to 12kb. Defaults to /dev/termination-log. Cannot be updated.
   *
   * @default dev/termination-log. Cannot be updated.
   * @schema RunnerSpecInitContainers#terminationMessagePath
   */
  readonly terminationMessagePath?: string;

  /**
   * Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.
   *
   * @default File. Cannot be updated.
   * @schema RunnerSpecInitContainers#terminationMessagePolicy
   */
  readonly terminationMessagePolicy?: string;

  /**
   * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true. Default is false.
   *
   * @default false.
   * @schema RunnerSpecInitContainers#tty
   */
  readonly tty?: boolean;

  /**
   * volumeDevices is the list of block devices to be used by the container.
   *
   * @schema RunnerSpecInitContainers#volumeDevices
   */
  readonly volumeDevices?: RunnerSpecInitContainersVolumeDevices[];

  /**
   * Pod volumes to mount into the container's filesystem. Cannot be updated.
   *
   * @schema RunnerSpecInitContainers#volumeMounts
   */
  readonly volumeMounts?: RunnerSpecInitContainersVolumeMounts[];

  /**
   * Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.
   *
   * @schema RunnerSpecInitContainers#workingDir
   */
  readonly workingDir?: string;

}

/**
 * Converts an object of type 'RunnerSpecInitContainers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecInitContainers(obj: RunnerSpecInitContainers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'args': obj.args?.map(y => y),
    'command': obj.command?.map(y => y),
    'env': obj.env?.map(y => toJson_RunnerSpecInitContainersEnv(y)),
    'envFrom': obj.envFrom?.map(y => toJson_RunnerSpecInitContainersEnvFrom(y)),
    'image': obj.image,
    'imagePullPolicy': obj.imagePullPolicy,
    'lifecycle': toJson_RunnerSpecInitContainersLifecycle(obj.lifecycle),
    'livenessProbe': toJson_RunnerSpecInitContainersLivenessProbe(obj.livenessProbe),
    'name': obj.name,
    'ports': obj.ports?.map(y => toJson_RunnerSpecInitContainersPorts(y)),
    'readinessProbe': toJson_RunnerSpecInitContainersReadinessProbe(obj.readinessProbe),
    'resources': toJson_RunnerSpecInitContainersResources(obj.resources),
    'securityContext': toJson_RunnerSpecInitContainersSecurityContext(obj.securityContext),
    'startupProbe': toJson_RunnerSpecInitContainersStartupProbe(obj.startupProbe),
    'stdin': obj.stdin,
    'stdinOnce': obj.stdinOnce,
    'terminationMessagePath': obj.terminationMessagePath,
    'terminationMessagePolicy': obj.terminationMessagePolicy,
    'tty': obj.tty,
    'volumeDevices': obj.volumeDevices?.map(y => toJson_RunnerSpecInitContainersVolumeDevices(y)),
    'volumeMounts': obj.volumeMounts?.map(y => toJson_RunnerSpecInitContainersVolumeMounts(y)),
    'workingDir': obj.workingDir,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceRequirements describes the compute resource requirements.
 *
 * @schema RunnerSpecResources
 */
export interface RunnerSpecResources {
  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema RunnerSpecResources#limits
   */
  readonly limits?: { [key: string]: RunnerSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema RunnerSpecResources#requests
   */
  readonly requests?: { [key: string]: RunnerSpecResourcesRequests };

}

/**
 * Converts an object of type 'RunnerSpecResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecResources(obj: RunnerSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PodSecurityContext holds pod-level security attributes and common container settings. Some fields are also present in container.securityContext.  Field values of container.securityContext take precedence over field values of PodSecurityContext.
 *
 * @schema RunnerSpecSecurityContext
 */
export interface RunnerSpecSecurityContext {
  /**
   * A special supplemental group that applies to all containers in a pod. Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod:
   * 1. The owning GID will be the FSGroup 2. The setgid bit is set (new files created in the volume will be owned by FSGroup) 3. The permission bits are OR'd with rw-rw----
   * If unset, the Kubelet will not modify the ownership and permissions of any volume. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerSpecSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * fsGroupChangePolicy defines behavior of changing ownership and permission of the volume before being exposed inside Pod. This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir. Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerSpecSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerSpecSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema RunnerSpecSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   * @schema RunnerSpecSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerSpecSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: RunnerSpecSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerSpecSecurityContext#seccompProfile
   */
  readonly seccompProfile?: RunnerSpecSecurityContextSeccompProfile;

  /**
   * A list of groups applied to the first process run in each container, in addition to the container's primary GID.  If unspecified, no groups will be added to any container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerSpecSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported sysctls (by the container runtime) might fail to launch. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerSpecSecurityContext#sysctls
   */
  readonly sysctls?: RunnerSpecSecurityContextSysctls[];

  /**
   * The Windows specific settings applied to all containers. If unspecified, the options within a container's SecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema RunnerSpecSecurityContext#windowsOptions
   */
  readonly windowsOptions?: RunnerSpecSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'RunnerSpecSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecSecurityContext(obj: RunnerSpecSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsGroup': obj.fsGroup,
    'fsGroupChangePolicy': obj.fsGroupChangePolicy,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_RunnerSpecSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_RunnerSpecSecurityContextSeccompProfile(obj.seccompProfile),
    'supplementalGroups': obj.supplementalGroups?.map(y => y),
    'sysctls': obj.sysctls?.map(y => toJson_RunnerSpecSecurityContextSysctls(y)),
    'windowsOptions': toJson_RunnerSpecSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A single application container that you want to run within a pod.
 *
 * @schema RunnerSpecSidecarContainers
 */
export interface RunnerSpecSidecarContainers {
  /**
   * Arguments to the entrypoint. The docker image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema RunnerSpecSidecarContainers#args
   */
  readonly args?: string[];

  /**
   * Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema RunnerSpecSidecarContainers#command
   */
  readonly command?: string[];

  /**
   * List of environment variables to set in the container. Cannot be updated.
   *
   * @schema RunnerSpecSidecarContainers#env
   */
  readonly env?: RunnerSpecSidecarContainersEnv[];

  /**
   * List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
   *
   * @schema RunnerSpecSidecarContainers#envFrom
   */
  readonly envFrom?: RunnerSpecSidecarContainersEnvFrom[];

  /**
   * Docker image name. More info: https://kubernetes.io/docs/concepts/containers/images This field is optional to allow higher level config management to default or override container images in workload controllers like Deployments and StatefulSets.
   *
   * @schema RunnerSpecSidecarContainers#image
   */
  readonly image?: string;

  /**
   * Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   *
   * @default Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   * @schema RunnerSpecSidecarContainers#imagePullPolicy
   */
  readonly imagePullPolicy?: string;

  /**
   * Actions that the management system should take in response to container lifecycle events. Cannot be updated.
   *
   * @schema RunnerSpecSidecarContainers#lifecycle
   */
  readonly lifecycle?: RunnerSpecSidecarContainersLifecycle;

  /**
   * Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerSpecSidecarContainers#livenessProbe
   */
  readonly livenessProbe?: RunnerSpecSidecarContainersLivenessProbe;

  /**
   * Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.
   *
   * @schema RunnerSpecSidecarContainers#name
   */
  readonly name: string;

  /**
   * List of ports to expose from the container. Exposing a port here gives the system additional information about the network connections a container uses, but is primarily informational. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default "0.0.0.0" address inside a container will be accessible from the network. Cannot be updated.
   *
   * @schema RunnerSpecSidecarContainers#ports
   */
  readonly ports?: RunnerSpecSidecarContainersPorts[];

  /**
   * Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerSpecSidecarContainers#readinessProbe
   */
  readonly readinessProbe?: RunnerSpecSidecarContainersReadinessProbe;

  /**
   * Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema RunnerSpecSidecarContainers#resources
   */
  readonly resources?: RunnerSpecSidecarContainersResources;

  /**
   * SecurityContext defines the security options the container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
   *
   * @schema RunnerSpecSidecarContainers#securityContext
   */
  readonly securityContext?: RunnerSpecSidecarContainersSecurityContext;

  /**
   * StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerSpecSidecarContainers#startupProbe
   */
  readonly startupProbe?: RunnerSpecSidecarContainersStartupProbe;

  /**
   * Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF. Default is false.
   *
   * @default false.
   * @schema RunnerSpecSidecarContainers#stdin
   */
  readonly stdin?: boolean;

  /**
   * Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false
   *
   * @default false
   * @schema RunnerSpecSidecarContainers#stdinOnce
   */
  readonly stdinOnce?: boolean;

  /**
   * Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Will be truncated by the node if greater than 4096 bytes. The total message length across all containers will be limited to 12kb. Defaults to /dev/termination-log. Cannot be updated.
   *
   * @default dev/termination-log. Cannot be updated.
   * @schema RunnerSpecSidecarContainers#terminationMessagePath
   */
  readonly terminationMessagePath?: string;

  /**
   * Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.
   *
   * @default File. Cannot be updated.
   * @schema RunnerSpecSidecarContainers#terminationMessagePolicy
   */
  readonly terminationMessagePolicy?: string;

  /**
   * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true. Default is false.
   *
   * @default false.
   * @schema RunnerSpecSidecarContainers#tty
   */
  readonly tty?: boolean;

  /**
   * volumeDevices is the list of block devices to be used by the container.
   *
   * @schema RunnerSpecSidecarContainers#volumeDevices
   */
  readonly volumeDevices?: RunnerSpecSidecarContainersVolumeDevices[];

  /**
   * Pod volumes to mount into the container's filesystem. Cannot be updated.
   *
   * @schema RunnerSpecSidecarContainers#volumeMounts
   */
  readonly volumeMounts?: RunnerSpecSidecarContainersVolumeMounts[];

  /**
   * Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.
   *
   * @schema RunnerSpecSidecarContainers#workingDir
   */
  readonly workingDir?: string;

}

/**
 * Converts an object of type 'RunnerSpecSidecarContainers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecSidecarContainers(obj: RunnerSpecSidecarContainers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'args': obj.args?.map(y => y),
    'command': obj.command?.map(y => y),
    'env': obj.env?.map(y => toJson_RunnerSpecSidecarContainersEnv(y)),
    'envFrom': obj.envFrom?.map(y => toJson_RunnerSpecSidecarContainersEnvFrom(y)),
    'image': obj.image,
    'imagePullPolicy': obj.imagePullPolicy,
    'lifecycle': toJson_RunnerSpecSidecarContainersLifecycle(obj.lifecycle),
    'livenessProbe': toJson_RunnerSpecSidecarContainersLivenessProbe(obj.livenessProbe),
    'name': obj.name,
    'ports': obj.ports?.map(y => toJson_RunnerSpecSidecarContainersPorts(y)),
    'readinessProbe': toJson_RunnerSpecSidecarContainersReadinessProbe(obj.readinessProbe),
    'resources': toJson_RunnerSpecSidecarContainersResources(obj.resources),
    'securityContext': toJson_RunnerSpecSidecarContainersSecurityContext(obj.securityContext),
    'startupProbe': toJson_RunnerSpecSidecarContainersStartupProbe(obj.startupProbe),
    'stdin': obj.stdin,
    'stdinOnce': obj.stdinOnce,
    'terminationMessagePath': obj.terminationMessagePath,
    'terminationMessagePolicy': obj.terminationMessagePolicy,
    'tty': obj.tty,
    'volumeDevices': obj.volumeDevices?.map(y => toJson_RunnerSpecSidecarContainersVolumeDevices(y)),
    'volumeMounts': obj.volumeMounts?.map(y => toJson_RunnerSpecSidecarContainersVolumeMounts(y)),
    'workingDir': obj.workingDir,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema RunnerSpecTolerations
 */
export interface RunnerSpecTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema RunnerSpecTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema RunnerSpecTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
   *
   * @default Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
   * @schema RunnerSpecTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema RunnerSpecTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema RunnerSpecTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'RunnerSpecTolerations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecTolerations(obj: RunnerSpecTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TopologySpreadConstraint specifies how to spread matching pods among the given topology.
 *
 * @schema RunnerSpecTopologySpreadConstraint
 */
export interface RunnerSpecTopologySpreadConstraint {
  /**
   * LabelSelector is used to find matching pods. Pods that match this label selector are counted to determine the number of pods in their corresponding topology domain.
   *
   * @schema RunnerSpecTopologySpreadConstraint#labelSelector
   */
  readonly labelSelector?: RunnerSpecTopologySpreadConstraintLabelSelector;

  /**
   * MaxSkew describes the degree to which pods may be unevenly distributed. When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted difference between the number of matching pods in the target topology and the global minimum. For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same labelSelector spread as 1/1/0: | zone1 | zone2 | zone3 | |   P   |   P   |       | - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 1/1/1; scheduling it onto zone1(zone2) would make the ActualSkew(2-0) on zone1(zone2) violate MaxSkew(1). - if MaxSkew is 2, incoming pod can be scheduled onto any zone. When `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher precedence to topologies that satisfy it. It's a required field. Default value is 1 and 0 is not allowed.
   *
   * @schema RunnerSpecTopologySpreadConstraint#maxSkew
   */
  readonly maxSkew: number;

  /**
   * TopologyKey is the key of node labels. Nodes that have a label with this key and identical values are considered to be in the same topology. We consider each <key, value> as a "bucket", and try to put balanced number of pods into each bucket. It's a required field.
   *
   * @schema RunnerSpecTopologySpreadConstraint#topologyKey
   */
  readonly topologyKey: string;

  /**
   * WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy the spread constraint. - DoNotSchedule (default) tells the scheduler not to schedule it. - ScheduleAnyway tells the scheduler to schedule the pod in any location,   but giving higher precedence to topologies that would help reduce the   skew. A constraint is considered "Unsatisfiable" for an incoming pod if and only if every possible node assignment for that pod would violate "MaxSkew" on some topology. For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same labelSelector spread as 3/1/1: | zone1 | zone2 | zone3 | | P P P |   P   |   P   | If WhenUnsatisfiable is set to DoNotSchedule, incoming pod can only be scheduled to zone2(zone3) to become 3/2/1(3/1/2) as ActualSkew(2-1) on zone2(zone3) satisfies MaxSkew(1). In other words, the cluster can still be imbalanced, but scheduler won't make it *more* imbalanced. It's a required field.
   *
   * @schema RunnerSpecTopologySpreadConstraint#whenUnsatisfiable
   */
  readonly whenUnsatisfiable: string;

}

/**
 * Converts an object of type 'RunnerSpecTopologySpreadConstraint' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecTopologySpreadConstraint(obj: RunnerSpecTopologySpreadConstraint | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_RunnerSpecTopologySpreadConstraintLabelSelector(obj.labelSelector),
    'maxSkew': obj.maxSkew,
    'topologyKey': obj.topologyKey,
    'whenUnsatisfiable': obj.whenUnsatisfiable,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema RunnerSpecVolumeMounts
 */
export interface RunnerSpecVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must not contain ':'.
   *
   * @schema RunnerSpecVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. This field is beta in 1.10.
   *
   * @schema RunnerSpecVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema RunnerSpecVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.
   *
   * @default false.
   * @schema RunnerSpecVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema RunnerSpecVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment. Defaults to "" (volume's root). SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root). SubPathExpr and SubPath are mutually exclusive.
   * @schema RunnerSpecVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;

}

/**
 * Converts an object of type 'RunnerSpecVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecVolumeMounts(obj: RunnerSpecVolumeMounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'mountPropagation': obj.mountPropagation,
    'name': obj.name,
    'readOnly': obj.readOnly,
    'subPath': obj.subPath,
    'subPathExpr': obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RunnerSpecVolumeSizeLimit
 */
export class RunnerSpecVolumeSizeLimit {
  public static fromNumber(value: number): RunnerSpecVolumeSizeLimit {
    return new RunnerSpecVolumeSizeLimit(value);
  }
  public static fromString(value: string): RunnerSpecVolumeSizeLimit {
    return new RunnerSpecVolumeSizeLimit(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Volume represents a named volume in a pod that may be accessed by any container in the pod.
 *
 * @schema RunnerSpecVolumes
 */
export interface RunnerSpecVolumes {
  /**
   * AWSElasticBlockStore represents an AWS Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema RunnerSpecVolumes#awsElasticBlockStore
   */
  readonly awsElasticBlockStore?: RunnerSpecVolumesAwsElasticBlockStore;

  /**
   * AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
   *
   * @schema RunnerSpecVolumes#azureDisk
   */
  readonly azureDisk?: RunnerSpecVolumesAzureDisk;

  /**
   * AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
   *
   * @schema RunnerSpecVolumes#azureFile
   */
  readonly azureFile?: RunnerSpecVolumesAzureFile;

  /**
   * CephFS represents a Ceph FS mount on the host that shares a pod's lifetime
   *
   * @schema RunnerSpecVolumes#cephfs
   */
  readonly cephfs?: RunnerSpecVolumesCephfs;

  /**
   * Cinder represents a cinder volume attached and mounted on kubelets host machine. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema RunnerSpecVolumes#cinder
   */
  readonly cinder?: RunnerSpecVolumesCinder;

  /**
   * ConfigMap represents a configMap that should populate this volume
   *
   * @schema RunnerSpecVolumes#configMap
   */
  readonly configMap?: RunnerSpecVolumesConfigMap;

  /**
   * CSI (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers (Beta feature).
   *
   * @schema RunnerSpecVolumes#csi
   */
  readonly csi?: RunnerSpecVolumesCsi;

  /**
   * DownwardAPI represents downward API about the pod that should populate this volume
   *
   * @schema RunnerSpecVolumes#downwardAPI
   */
  readonly downwardApi?: RunnerSpecVolumesDownwardApi;

  /**
   * EmptyDir represents a temporary directory that shares a pod's lifetime. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema RunnerSpecVolumes#emptyDir
   */
  readonly emptyDir?: RunnerSpecVolumesEmptyDir;

  /**
   * Ephemeral represents a volume that is handled by a cluster storage driver. The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts, and deleted when the pod is removed.
   * Use this if: a) the volume is only needed while the pod runs, b) features of normal volumes like restoring from snapshot or capacity    tracking are needed, c) the storage driver is specified through a storage class, and d) the storage driver supports dynamic volume provisioning through    a PersistentVolumeClaim (see EphemeralVolumeSource for more    information on the connection between this volume type    and PersistentVolumeClaim).
   * Use PersistentVolumeClaim or one of the vendor-specific APIs for volumes that persist for longer than the lifecycle of an individual pod.
   * Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to be used that way - see the documentation of the driver for more information.
   * A pod can use both types of ephemeral volumes and persistent volumes at the same time.
   *
   * @schema RunnerSpecVolumes#ephemeral
   */
  readonly ephemeral?: RunnerSpecVolumesEphemeral;

  /**
   * FC represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
   *
   * @schema RunnerSpecVolumes#fc
   */
  readonly fc?: RunnerSpecVolumesFc;

  /**
   * FlexVolume represents a generic volume resource that is provisioned/attached using an exec based plugin.
   *
   * @schema RunnerSpecVolumes#flexVolume
   */
  readonly flexVolume?: RunnerSpecVolumesFlexVolume;

  /**
   * Flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running
   *
   * @schema RunnerSpecVolumes#flocker
   */
  readonly flocker?: RunnerSpecVolumesFlocker;

  /**
   * GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema RunnerSpecVolumes#gcePersistentDisk
   */
  readonly gcePersistentDisk?: RunnerSpecVolumesGcePersistentDisk;

  /**
   * GitRepo represents a git repository at a particular revision. DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir into the Pod's container.
   *
   * @schema RunnerSpecVolumes#gitRepo
   */
  readonly gitRepo?: RunnerSpecVolumesGitRepo;

  /**
   * Glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/glusterfs/README.md
   *
   * @schema RunnerSpecVolumes#glusterfs
   */
  readonly glusterfs?: RunnerSpecVolumesGlusterfs;

  /**
   * HostPath represents a pre-existing file or directory on the host machine that is directly exposed to the container. This is generally used for system agents or other privileged things that are allowed to see the host machine. Most containers will NOT need this. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath --- TODO(jonesdl) We need to restrict who can use host directory mounts and who can/can not mount host directories as read/write.
   *
   * @schema RunnerSpecVolumes#hostPath
   */
  readonly hostPath?: RunnerSpecVolumesHostPath;

  /**
   * ISCSI represents an ISCSI Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://examples.k8s.io/volumes/iscsi/README.md
   *
   * @schema RunnerSpecVolumes#iscsi
   */
  readonly iscsi?: RunnerSpecVolumesIscsi;

  /**
   * Volume's name. Must be a DNS_LABEL and unique within the pod. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema RunnerSpecVolumes#name
   */
  readonly name: string;

  /**
   * NFS represents an NFS mount on the host that shares a pod's lifetime More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema RunnerSpecVolumes#nfs
   */
  readonly nfs?: RunnerSpecVolumesNfs;

  /**
   * PersistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in the same namespace. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema RunnerSpecVolumes#persistentVolumeClaim
   */
  readonly persistentVolumeClaim?: RunnerSpecVolumesPersistentVolumeClaim;

  /**
   * PhotonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
   *
   * @schema RunnerSpecVolumes#photonPersistentDisk
   */
  readonly photonPersistentDisk?: RunnerSpecVolumesPhotonPersistentDisk;

  /**
   * PortworxVolume represents a portworx volume attached and mounted on kubelets host machine
   *
   * @schema RunnerSpecVolumes#portworxVolume
   */
  readonly portworxVolume?: RunnerSpecVolumesPortworxVolume;

  /**
   * Items for all in one resources secrets, configmaps, and downward API
   *
   * @schema RunnerSpecVolumes#projected
   */
  readonly projected?: RunnerSpecVolumesProjected;

  /**
   * Quobyte represents a Quobyte mount on the host that shares a pod's lifetime
   *
   * @schema RunnerSpecVolumes#quobyte
   */
  readonly quobyte?: RunnerSpecVolumesQuobyte;

  /**
   * RBD represents a Rados Block Device mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/rbd/README.md
   *
   * @schema RunnerSpecVolumes#rbd
   */
  readonly rbd?: RunnerSpecVolumesRbd;

  /**
   * ScaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
   *
   * @schema RunnerSpecVolumes#scaleIO
   */
  readonly scaleIo?: RunnerSpecVolumesScaleIo;

  /**
   * Secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   *
   * @schema RunnerSpecVolumes#secret
   */
  readonly secret?: RunnerSpecVolumesSecret;

  /**
   * StorageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
   *
   * @schema RunnerSpecVolumes#storageos
   */
  readonly storageos?: RunnerSpecVolumesStorageos;

  /**
   * VsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
   *
   * @schema RunnerSpecVolumes#vsphereVolume
   */
  readonly vsphereVolume?: RunnerSpecVolumesVsphereVolume;

}

/**
 * Converts an object of type 'RunnerSpecVolumes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecVolumes(obj: RunnerSpecVolumes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'awsElasticBlockStore': toJson_RunnerSpecVolumesAwsElasticBlockStore(obj.awsElasticBlockStore),
    'azureDisk': toJson_RunnerSpecVolumesAzureDisk(obj.azureDisk),
    'azureFile': toJson_RunnerSpecVolumesAzureFile(obj.azureFile),
    'cephfs': toJson_RunnerSpecVolumesCephfs(obj.cephfs),
    'cinder': toJson_RunnerSpecVolumesCinder(obj.cinder),
    'configMap': toJson_RunnerSpecVolumesConfigMap(obj.configMap),
    'csi': toJson_RunnerSpecVolumesCsi(obj.csi),
    'downwardAPI': toJson_RunnerSpecVolumesDownwardApi(obj.downwardApi),
    'emptyDir': toJson_RunnerSpecVolumesEmptyDir(obj.emptyDir),
    'ephemeral': toJson_RunnerSpecVolumesEphemeral(obj.ephemeral),
    'fc': toJson_RunnerSpecVolumesFc(obj.fc),
    'flexVolume': toJson_RunnerSpecVolumesFlexVolume(obj.flexVolume),
    'flocker': toJson_RunnerSpecVolumesFlocker(obj.flocker),
    'gcePersistentDisk': toJson_RunnerSpecVolumesGcePersistentDisk(obj.gcePersistentDisk),
    'gitRepo': toJson_RunnerSpecVolumesGitRepo(obj.gitRepo),
    'glusterfs': toJson_RunnerSpecVolumesGlusterfs(obj.glusterfs),
    'hostPath': toJson_RunnerSpecVolumesHostPath(obj.hostPath),
    'iscsi': toJson_RunnerSpecVolumesIscsi(obj.iscsi),
    'name': obj.name,
    'nfs': toJson_RunnerSpecVolumesNfs(obj.nfs),
    'persistentVolumeClaim': toJson_RunnerSpecVolumesPersistentVolumeClaim(obj.persistentVolumeClaim),
    'photonPersistentDisk': toJson_RunnerSpecVolumesPhotonPersistentDisk(obj.photonPersistentDisk),
    'portworxVolume': toJson_RunnerSpecVolumesPortworxVolume(obj.portworxVolume),
    'projected': toJson_RunnerSpecVolumesProjected(obj.projected),
    'quobyte': toJson_RunnerSpecVolumesQuobyte(obj.quobyte),
    'rbd': toJson_RunnerSpecVolumesRbd(obj.rbd),
    'scaleIO': toJson_RunnerSpecVolumesScaleIo(obj.scaleIo),
    'secret': toJson_RunnerSpecVolumesSecret(obj.secret),
    'storageos': toJson_RunnerSpecVolumesStorageos(obj.storageos),
    'vsphereVolume': toJson_RunnerSpecVolumesVsphereVolume(obj.vsphereVolume),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Describes node affinity scheduling rules for the pod.
 *
 * @schema RunnerSpecAffinityNodeAffinity
 */
export interface RunnerSpecAffinityNodeAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the most preferred.
   *
   * @schema RunnerSpecAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: RunnerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node.
   *
   * @schema RunnerSpecAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: RunnerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;

}

/**
 * Converts an object of type 'RunnerSpecAffinityNodeAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecAffinityNodeAffinity(obj: RunnerSpecAffinityNodeAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_RunnerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': toJson_RunnerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj.requiredDuringSchedulingIgnoredDuringExecution),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
 *
 * @schema RunnerSpecAffinityPodAffinity
 */
export interface RunnerSpecAffinityPodAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
   *
   * @schema RunnerSpecAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: RunnerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema RunnerSpecAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: RunnerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'RunnerSpecAffinityPodAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecAffinityPodAffinity(obj: RunnerSpecAffinityPodAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_RunnerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_RunnerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
 *
 * @schema RunnerSpecAffinityPodAntiAffinity
 */
export interface RunnerSpecAffinityPodAntiAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
   *
   * @schema RunnerSpecAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: RunnerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema RunnerSpecAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: RunnerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'RunnerSpecAffinityPodAntiAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecAffinityPodAntiAffinity(obj: RunnerSpecAffinityPodAntiAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_RunnerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_RunnerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema RunnerSpecContainersEnv
 */
export interface RunnerSpecContainersEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema RunnerSpecContainersEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded using the previously defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
   *
   * @default .
   * @schema RunnerSpecContainersEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema RunnerSpecContainersEnv#valueFrom
   */
  readonly valueFrom?: RunnerSpecContainersEnvValueFrom;

}

/**
 * Converts an object of type 'RunnerSpecContainersEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecContainersEnv(obj: RunnerSpecContainersEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
    'valueFrom': toJson_RunnerSpecContainersEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema RunnerSpecContainersEnvFrom
 */
export interface RunnerSpecContainersEnvFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema RunnerSpecContainersEnvFrom#configMapRef
   */
  readonly configMapRef?: RunnerSpecContainersEnvFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema RunnerSpecContainersEnvFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema RunnerSpecContainersEnvFrom#secretRef
   */
  readonly secretRef?: RunnerSpecContainersEnvFromSecretRef;

}

/**
 * Converts an object of type 'RunnerSpecContainersEnvFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecContainersEnvFrom(obj: RunnerSpecContainersEnvFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapRef': toJson_RunnerSpecContainersEnvFromConfigMapRef(obj.configMapRef),
    'prefix': obj.prefix,
    'secretRef': toJson_RunnerSpecContainersEnvFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Actions that the management system should take in response to container lifecycle events. Cannot be updated.
 *
 * @schema RunnerSpecContainersLifecycle
 */
export interface RunnerSpecContainersLifecycle {
  /**
   * PostStart is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema RunnerSpecContainersLifecycle#postStart
   */
  readonly postStart?: RunnerSpecContainersLifecyclePostStart;

  /**
   * PreStop is called immediately before a container is terminated due to an API request or management event such as liveness/startup probe failure, preemption, resource contention, etc. The handler is not called if the container crashes or exits. The Pod's termination grace period countdown begins before the PreStop hook is executed. Regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period (unless delayed by finalizers). Other management of the container blocks until the hook completes or until the termination grace period is reached. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema RunnerSpecContainersLifecycle#preStop
   */
  readonly preStop?: RunnerSpecContainersLifecyclePreStop;

}

/**
 * Converts an object of type 'RunnerSpecContainersLifecycle' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecContainersLifecycle(obj: RunnerSpecContainersLifecycle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'postStart': toJson_RunnerSpecContainersLifecyclePostStart(obj.postStart),
    'preStop': toJson_RunnerSpecContainersLifecyclePreStop(obj.preStop),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema RunnerSpecContainersLivenessProbe
 */
export interface RunnerSpecContainersLivenessProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema RunnerSpecContainersLivenessProbe#exec
   */
  readonly exec?: RunnerSpecContainersLivenessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema RunnerSpecContainersLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
   *
   * @schema RunnerSpecContainersLivenessProbe#grpc
   */
  readonly grpc?: RunnerSpecContainersLivenessProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema RunnerSpecContainersLivenessProbe#httpGet
   */
  readonly httpGet?: RunnerSpecContainersLivenessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerSpecContainersLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema RunnerSpecContainersLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema RunnerSpecContainersLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema RunnerSpecContainersLivenessProbe#tcpSocket
   */
  readonly tcpSocket?: RunnerSpecContainersLivenessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema RunnerSpecContainersLivenessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema RunnerSpecContainersLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'RunnerSpecContainersLivenessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecContainersLivenessProbe(obj: RunnerSpecContainersLivenessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_RunnerSpecContainersLivenessProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_RunnerSpecContainersLivenessProbeGrpc(obj.grpc),
    'httpGet': toJson_RunnerSpecContainersLivenessProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_RunnerSpecContainersLivenessProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ContainerPort represents a network port in a single container.
 *
 * @schema RunnerSpecContainersPorts
 */
export interface RunnerSpecContainersPorts {
  /**
   * Number of port to expose on the pod's IP address. This must be a valid port number, 0 < x < 65536.
   *
   * @schema RunnerSpecContainersPorts#containerPort
   */
  readonly containerPort: number;

  /**
   * What host IP to bind the external port to.
   *
   * @schema RunnerSpecContainersPorts#hostIP
   */
  readonly hostIp?: string;

  /**
   * Number of port to expose on the host. If specified, this must be a valid port number, 0 < x < 65536. If HostNetwork is specified, this must match ContainerPort. Most containers do not need this.
   *
   * @schema RunnerSpecContainersPorts#hostPort
   */
  readonly hostPort?: number;

  /**
   * If specified, this must be an IANA_SVC_NAME and unique within the pod. Each named port in a pod must have a unique name. Name for the port that can be referred to by services.
   *
   * @schema RunnerSpecContainersPorts#name
   */
  readonly name?: string;

  /**
   * Protocol for port. Must be UDP, TCP, or SCTP. Defaults to "TCP".
   *
   * @default TCP".
   * @schema RunnerSpecContainersPorts#protocol
   */
  readonly protocol?: string;

}

/**
 * Converts an object of type 'RunnerSpecContainersPorts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecContainersPorts(obj: RunnerSpecContainersPorts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerPort': obj.containerPort,
    'hostIP': obj.hostIp,
    'hostPort': obj.hostPort,
    'name': obj.name,
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema RunnerSpecContainersReadinessProbe
 */
export interface RunnerSpecContainersReadinessProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema RunnerSpecContainersReadinessProbe#exec
   */
  readonly exec?: RunnerSpecContainersReadinessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema RunnerSpecContainersReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
   *
   * @schema RunnerSpecContainersReadinessProbe#grpc
   */
  readonly grpc?: RunnerSpecContainersReadinessProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema RunnerSpecContainersReadinessProbe#httpGet
   */
  readonly httpGet?: RunnerSpecContainersReadinessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerSpecContainersReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema RunnerSpecContainersReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema RunnerSpecContainersReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema RunnerSpecContainersReadinessProbe#tcpSocket
   */
  readonly tcpSocket?: RunnerSpecContainersReadinessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema RunnerSpecContainersReadinessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema RunnerSpecContainersReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'RunnerSpecContainersReadinessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecContainersReadinessProbe(obj: RunnerSpecContainersReadinessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_RunnerSpecContainersReadinessProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_RunnerSpecContainersReadinessProbeGrpc(obj.grpc),
    'httpGet': toJson_RunnerSpecContainersReadinessProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_RunnerSpecContainersReadinessProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
 *
 * @schema RunnerSpecContainersResources
 */
export interface RunnerSpecContainersResources {
  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema RunnerSpecContainersResources#limits
   */
  readonly limits?: { [key: string]: RunnerSpecContainersResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema RunnerSpecContainersResources#requests
   */
  readonly requests?: { [key: string]: RunnerSpecContainersResourcesRequests };

}

/**
 * Converts an object of type 'RunnerSpecContainersResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecContainersResources(obj: RunnerSpecContainersResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecurityContext defines the security options the container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
 *
 * @schema RunnerSpecContainersSecurityContext
 */
export interface RunnerSpecContainersSecurityContext {
  /**
   * AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process. This bool directly controls if the no_new_privs flag will be set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP_SYS_ADMIN Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerSpecContainersSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
   * @schema RunnerSpecContainersSecurityContext#capabilities
   */
  readonly capabilities?: RunnerSpecContainersSecurityContextCapabilities;

  /**
   * Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. Defaults to false. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false. Note that this field cannot be set when spec.os.name is windows.
   * @schema RunnerSpecContainersSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * procMount denotes the type of proc mount to use for the containers. The default is DefaultProcMount which uses the container runtime defaults for readonly paths and masked paths. This requires the ProcMountType feature flag to be enabled. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerSpecContainersSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * Whether this container has a read-only root filesystem. Default is false. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false. Note that this field cannot be set when spec.os.name is windows.
   * @schema RunnerSpecContainersSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerSpecContainersSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema RunnerSpecContainersSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   * @schema RunnerSpecContainersSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerSpecContainersSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: RunnerSpecContainersSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by this container. If seccomp options are provided at both the pod & container level, the container options override the pod options. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerSpecContainersSecurityContext#seccompProfile
   */
  readonly seccompProfile?: RunnerSpecContainersSecurityContextSeccompProfile;

  /**
   * The Windows specific settings applied to all containers. If unspecified, the options from the PodSecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema RunnerSpecContainersSecurityContext#windowsOptions
   */
  readonly windowsOptions?: RunnerSpecContainersSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'RunnerSpecContainersSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecContainersSecurityContext(obj: RunnerSpecContainersSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowPrivilegeEscalation': obj.allowPrivilegeEscalation,
    'capabilities': toJson_RunnerSpecContainersSecurityContextCapabilities(obj.capabilities),
    'privileged': obj.privileged,
    'procMount': obj.procMount,
    'readOnlyRootFilesystem': obj.readOnlyRootFilesystem,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_RunnerSpecContainersSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_RunnerSpecContainersSecurityContextSeccompProfile(obj.seccompProfile),
    'windowsOptions': toJson_RunnerSpecContainersSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema RunnerSpecContainersStartupProbe
 */
export interface RunnerSpecContainersStartupProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema RunnerSpecContainersStartupProbe#exec
   */
  readonly exec?: RunnerSpecContainersStartupProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema RunnerSpecContainersStartupProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
   *
   * @schema RunnerSpecContainersStartupProbe#grpc
   */
  readonly grpc?: RunnerSpecContainersStartupProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema RunnerSpecContainersStartupProbe#httpGet
   */
  readonly httpGet?: RunnerSpecContainersStartupProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerSpecContainersStartupProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema RunnerSpecContainersStartupProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema RunnerSpecContainersStartupProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema RunnerSpecContainersStartupProbe#tcpSocket
   */
  readonly tcpSocket?: RunnerSpecContainersStartupProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema RunnerSpecContainersStartupProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema RunnerSpecContainersStartupProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'RunnerSpecContainersStartupProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecContainersStartupProbe(obj: RunnerSpecContainersStartupProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_RunnerSpecContainersStartupProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_RunnerSpecContainersStartupProbeGrpc(obj.grpc),
    'httpGet': toJson_RunnerSpecContainersStartupProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_RunnerSpecContainersStartupProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * volumeDevice describes a mapping of a raw block device within a container.
 *
 * @schema RunnerSpecContainersVolumeDevices
 */
export interface RunnerSpecContainersVolumeDevices {
  /**
   * devicePath is the path inside of the container that the device will be mapped to.
   *
   * @schema RunnerSpecContainersVolumeDevices#devicePath
   */
  readonly devicePath: string;

  /**
   * name must match the name of a persistentVolumeClaim in the pod
   *
   * @schema RunnerSpecContainersVolumeDevices#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RunnerSpecContainersVolumeDevices' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecContainersVolumeDevices(obj: RunnerSpecContainersVolumeDevices | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'devicePath': obj.devicePath,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema RunnerSpecContainersVolumeMounts
 */
export interface RunnerSpecContainersVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must not contain ':'.
   *
   * @schema RunnerSpecContainersVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. This field is beta in 1.10.
   *
   * @schema RunnerSpecContainersVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema RunnerSpecContainersVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.
   *
   * @default false.
   * @schema RunnerSpecContainersVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema RunnerSpecContainersVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment. Defaults to "" (volume's root). SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root). SubPathExpr and SubPath are mutually exclusive.
   * @schema RunnerSpecContainersVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;

}

/**
 * Converts an object of type 'RunnerSpecContainersVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecContainersVolumeMounts(obj: RunnerSpecContainersVolumeMounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'mountPropagation': obj.mountPropagation,
    'name': obj.name,
    'readOnly': obj.readOnly,
    'subPath': obj.subPath,
    'subPathExpr': obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PodDNSConfigOption defines DNS resolver options of a pod.
 *
 * @schema RunnerSpecDnsConfigOptions
 */
export interface RunnerSpecDnsConfigOptions {
  /**
   * Required.
   *
   * @schema RunnerSpecDnsConfigOptions#name
   */
  readonly name?: string;

  /**
   * @schema RunnerSpecDnsConfigOptions#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'RunnerSpecDnsConfigOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecDnsConfigOptions(obj: RunnerSpecDnsConfigOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema RunnerSpecDockerEnvValueFrom
 */
export interface RunnerSpecDockerEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema RunnerSpecDockerEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: RunnerSpecDockerEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema RunnerSpecDockerEnvValueFrom#fieldRef
   */
  readonly fieldRef?: RunnerSpecDockerEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema RunnerSpecDockerEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: RunnerSpecDockerEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema RunnerSpecDockerEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: RunnerSpecDockerEnvValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'RunnerSpecDockerEnvValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecDockerEnvValueFrom(obj: RunnerSpecDockerEnvValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_RunnerSpecDockerEnvValueFromConfigMapKeyRef(obj.configMapKeyRef),
    'fieldRef': toJson_RunnerSpecDockerEnvValueFromFieldRef(obj.fieldRef),
    'resourceFieldRef': toJson_RunnerSpecDockerEnvValueFromResourceFieldRef(obj.resourceFieldRef),
    'secretKeyRef': toJson_RunnerSpecDockerEnvValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RunnerSpecDockerdContainerResourcesLimits
 */
export class RunnerSpecDockerdContainerResourcesLimits {
  public static fromNumber(value: number): RunnerSpecDockerdContainerResourcesLimits {
    return new RunnerSpecDockerdContainerResourcesLimits(value);
  }
  public static fromString(value: string): RunnerSpecDockerdContainerResourcesLimits {
    return new RunnerSpecDockerdContainerResourcesLimits(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * @schema RunnerSpecDockerdContainerResourcesRequests
 */
export class RunnerSpecDockerdContainerResourcesRequests {
  public static fromNumber(value: number): RunnerSpecDockerdContainerResourcesRequests {
    return new RunnerSpecDockerdContainerResourcesRequests(value);
  }
  public static fromString(value: string): RunnerSpecDockerdContainerResourcesRequests {
    return new RunnerSpecDockerdContainerResourcesRequests(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema RunnerSpecEnvValueFrom
 */
export interface RunnerSpecEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema RunnerSpecEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: RunnerSpecEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema RunnerSpecEnvValueFrom#fieldRef
   */
  readonly fieldRef?: RunnerSpecEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema RunnerSpecEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: RunnerSpecEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema RunnerSpecEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: RunnerSpecEnvValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'RunnerSpecEnvValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecEnvValueFrom(obj: RunnerSpecEnvValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_RunnerSpecEnvValueFromConfigMapKeyRef(obj.configMapKeyRef),
    'fieldRef': toJson_RunnerSpecEnvValueFromFieldRef(obj.fieldRef),
    'resourceFieldRef': toJson_RunnerSpecEnvValueFromResourceFieldRef(obj.resourceFieldRef),
    'secretKeyRef': toJson_RunnerSpecEnvValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema RunnerSpecEnvFromConfigMapRef
 */
export interface RunnerSpecEnvFromConfigMapRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerSpecEnvFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema RunnerSpecEnvFromConfigMapRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerSpecEnvFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecEnvFromConfigMapRef(obj: RunnerSpecEnvFromConfigMapRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Secret to select from
 *
 * @schema RunnerSpecEnvFromSecretRef
 */
export interface RunnerSpecEnvFromSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerSpecEnvFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema RunnerSpecEnvFromSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerSpecEnvFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecEnvFromSecretRef(obj: RunnerSpecEnvFromSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema RunnerSpecEphemeralContainersEnv
 */
export interface RunnerSpecEphemeralContainersEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema RunnerSpecEphemeralContainersEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded using the previously defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
   *
   * @default .
   * @schema RunnerSpecEphemeralContainersEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema RunnerSpecEphemeralContainersEnv#valueFrom
   */
  readonly valueFrom?: RunnerSpecEphemeralContainersEnvValueFrom;

}

/**
 * Converts an object of type 'RunnerSpecEphemeralContainersEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecEphemeralContainersEnv(obj: RunnerSpecEphemeralContainersEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
    'valueFrom': toJson_RunnerSpecEphemeralContainersEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema RunnerSpecEphemeralContainersEnvFrom
 */
export interface RunnerSpecEphemeralContainersEnvFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema RunnerSpecEphemeralContainersEnvFrom#configMapRef
   */
  readonly configMapRef?: RunnerSpecEphemeralContainersEnvFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema RunnerSpecEphemeralContainersEnvFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema RunnerSpecEphemeralContainersEnvFrom#secretRef
   */
  readonly secretRef?: RunnerSpecEphemeralContainersEnvFromSecretRef;

}

/**
 * Converts an object of type 'RunnerSpecEphemeralContainersEnvFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecEphemeralContainersEnvFrom(obj: RunnerSpecEphemeralContainersEnvFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapRef': toJson_RunnerSpecEphemeralContainersEnvFromConfigMapRef(obj.configMapRef),
    'prefix': obj.prefix,
    'secretRef': toJson_RunnerSpecEphemeralContainersEnvFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Lifecycle is not allowed for ephemeral containers.
 *
 * @schema RunnerSpecEphemeralContainersLifecycle
 */
export interface RunnerSpecEphemeralContainersLifecycle {
  /**
   * PostStart is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema RunnerSpecEphemeralContainersLifecycle#postStart
   */
  readonly postStart?: RunnerSpecEphemeralContainersLifecyclePostStart;

  /**
   * PreStop is called immediately before a container is terminated due to an API request or management event such as liveness/startup probe failure, preemption, resource contention, etc. The handler is not called if the container crashes or exits. The Pod's termination grace period countdown begins before the PreStop hook is executed. Regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period (unless delayed by finalizers). Other management of the container blocks until the hook completes or until the termination grace period is reached. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema RunnerSpecEphemeralContainersLifecycle#preStop
   */
  readonly preStop?: RunnerSpecEphemeralContainersLifecyclePreStop;

}

/**
 * Converts an object of type 'RunnerSpecEphemeralContainersLifecycle' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecEphemeralContainersLifecycle(obj: RunnerSpecEphemeralContainersLifecycle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'postStart': toJson_RunnerSpecEphemeralContainersLifecyclePostStart(obj.postStart),
    'preStop': toJson_RunnerSpecEphemeralContainersLifecyclePreStop(obj.preStop),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Probes are not allowed for ephemeral containers.
 *
 * @schema RunnerSpecEphemeralContainersLivenessProbe
 */
export interface RunnerSpecEphemeralContainersLivenessProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema RunnerSpecEphemeralContainersLivenessProbe#exec
   */
  readonly exec?: RunnerSpecEphemeralContainersLivenessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema RunnerSpecEphemeralContainersLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
   *
   * @schema RunnerSpecEphemeralContainersLivenessProbe#grpc
   */
  readonly grpc?: RunnerSpecEphemeralContainersLivenessProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema RunnerSpecEphemeralContainersLivenessProbe#httpGet
   */
  readonly httpGet?: RunnerSpecEphemeralContainersLivenessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerSpecEphemeralContainersLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema RunnerSpecEphemeralContainersLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema RunnerSpecEphemeralContainersLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema RunnerSpecEphemeralContainersLivenessProbe#tcpSocket
   */
  readonly tcpSocket?: RunnerSpecEphemeralContainersLivenessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema RunnerSpecEphemeralContainersLivenessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema RunnerSpecEphemeralContainersLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'RunnerSpecEphemeralContainersLivenessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecEphemeralContainersLivenessProbe(obj: RunnerSpecEphemeralContainersLivenessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_RunnerSpecEphemeralContainersLivenessProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_RunnerSpecEphemeralContainersLivenessProbeGrpc(obj.grpc),
    'httpGet': toJson_RunnerSpecEphemeralContainersLivenessProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_RunnerSpecEphemeralContainersLivenessProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ContainerPort represents a network port in a single container.
 *
 * @schema RunnerSpecEphemeralContainersPorts
 */
export interface RunnerSpecEphemeralContainersPorts {
  /**
   * Number of port to expose on the pod's IP address. This must be a valid port number, 0 < x < 65536.
   *
   * @schema RunnerSpecEphemeralContainersPorts#containerPort
   */
  readonly containerPort: number;

  /**
   * What host IP to bind the external port to.
   *
   * @schema RunnerSpecEphemeralContainersPorts#hostIP
   */
  readonly hostIp?: string;

  /**
   * Number of port to expose on the host. If specified, this must be a valid port number, 0 < x < 65536. If HostNetwork is specified, this must match ContainerPort. Most containers do not need this.
   *
   * @schema RunnerSpecEphemeralContainersPorts#hostPort
   */
  readonly hostPort?: number;

  /**
   * If specified, this must be an IANA_SVC_NAME and unique within the pod. Each named port in a pod must have a unique name. Name for the port that can be referred to by services.
   *
   * @schema RunnerSpecEphemeralContainersPorts#name
   */
  readonly name?: string;

  /**
   * Protocol for port. Must be UDP, TCP, or SCTP. Defaults to "TCP".
   *
   * @default TCP".
   * @schema RunnerSpecEphemeralContainersPorts#protocol
   */
  readonly protocol?: string;

}

/**
 * Converts an object of type 'RunnerSpecEphemeralContainersPorts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecEphemeralContainersPorts(obj: RunnerSpecEphemeralContainersPorts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerPort': obj.containerPort,
    'hostIP': obj.hostIp,
    'hostPort': obj.hostPort,
    'name': obj.name,
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Probes are not allowed for ephemeral containers.
 *
 * @schema RunnerSpecEphemeralContainersReadinessProbe
 */
export interface RunnerSpecEphemeralContainersReadinessProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema RunnerSpecEphemeralContainersReadinessProbe#exec
   */
  readonly exec?: RunnerSpecEphemeralContainersReadinessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema RunnerSpecEphemeralContainersReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
   *
   * @schema RunnerSpecEphemeralContainersReadinessProbe#grpc
   */
  readonly grpc?: RunnerSpecEphemeralContainersReadinessProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema RunnerSpecEphemeralContainersReadinessProbe#httpGet
   */
  readonly httpGet?: RunnerSpecEphemeralContainersReadinessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerSpecEphemeralContainersReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema RunnerSpecEphemeralContainersReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema RunnerSpecEphemeralContainersReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema RunnerSpecEphemeralContainersReadinessProbe#tcpSocket
   */
  readonly tcpSocket?: RunnerSpecEphemeralContainersReadinessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema RunnerSpecEphemeralContainersReadinessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema RunnerSpecEphemeralContainersReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'RunnerSpecEphemeralContainersReadinessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecEphemeralContainersReadinessProbe(obj: RunnerSpecEphemeralContainersReadinessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_RunnerSpecEphemeralContainersReadinessProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_RunnerSpecEphemeralContainersReadinessProbeGrpc(obj.grpc),
    'httpGet': toJson_RunnerSpecEphemeralContainersReadinessProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_RunnerSpecEphemeralContainersReadinessProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resources are not allowed for ephemeral containers. Ephemeral containers use spare resources already allocated to the pod.
 *
 * @schema RunnerSpecEphemeralContainersResources
 */
export interface RunnerSpecEphemeralContainersResources {
  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema RunnerSpecEphemeralContainersResources#limits
   */
  readonly limits?: { [key: string]: RunnerSpecEphemeralContainersResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema RunnerSpecEphemeralContainersResources#requests
   */
  readonly requests?: { [key: string]: RunnerSpecEphemeralContainersResourcesRequests };

}

/**
 * Converts an object of type 'RunnerSpecEphemeralContainersResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecEphemeralContainersResources(obj: RunnerSpecEphemeralContainersResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Optional: SecurityContext defines the security options the ephemeral container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
 *
 * @schema RunnerSpecEphemeralContainersSecurityContext
 */
export interface RunnerSpecEphemeralContainersSecurityContext {
  /**
   * AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process. This bool directly controls if the no_new_privs flag will be set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP_SYS_ADMIN Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerSpecEphemeralContainersSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
   * @schema RunnerSpecEphemeralContainersSecurityContext#capabilities
   */
  readonly capabilities?: RunnerSpecEphemeralContainersSecurityContextCapabilities;

  /**
   * Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. Defaults to false. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false. Note that this field cannot be set when spec.os.name is windows.
   * @schema RunnerSpecEphemeralContainersSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * procMount denotes the type of proc mount to use for the containers. The default is DefaultProcMount which uses the container runtime defaults for readonly paths and masked paths. This requires the ProcMountType feature flag to be enabled. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerSpecEphemeralContainersSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * Whether this container has a read-only root filesystem. Default is false. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false. Note that this field cannot be set when spec.os.name is windows.
   * @schema RunnerSpecEphemeralContainersSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerSpecEphemeralContainersSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema RunnerSpecEphemeralContainersSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   * @schema RunnerSpecEphemeralContainersSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerSpecEphemeralContainersSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: RunnerSpecEphemeralContainersSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by this container. If seccomp options are provided at both the pod & container level, the container options override the pod options. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerSpecEphemeralContainersSecurityContext#seccompProfile
   */
  readonly seccompProfile?: RunnerSpecEphemeralContainersSecurityContextSeccompProfile;

  /**
   * The Windows specific settings applied to all containers. If unspecified, the options from the PodSecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema RunnerSpecEphemeralContainersSecurityContext#windowsOptions
   */
  readonly windowsOptions?: RunnerSpecEphemeralContainersSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'RunnerSpecEphemeralContainersSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecEphemeralContainersSecurityContext(obj: RunnerSpecEphemeralContainersSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowPrivilegeEscalation': obj.allowPrivilegeEscalation,
    'capabilities': toJson_RunnerSpecEphemeralContainersSecurityContextCapabilities(obj.capabilities),
    'privileged': obj.privileged,
    'procMount': obj.procMount,
    'readOnlyRootFilesystem': obj.readOnlyRootFilesystem,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_RunnerSpecEphemeralContainersSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_RunnerSpecEphemeralContainersSecurityContextSeccompProfile(obj.seccompProfile),
    'windowsOptions': toJson_RunnerSpecEphemeralContainersSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Probes are not allowed for ephemeral containers.
 *
 * @schema RunnerSpecEphemeralContainersStartupProbe
 */
export interface RunnerSpecEphemeralContainersStartupProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema RunnerSpecEphemeralContainersStartupProbe#exec
   */
  readonly exec?: RunnerSpecEphemeralContainersStartupProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema RunnerSpecEphemeralContainersStartupProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
   *
   * @schema RunnerSpecEphemeralContainersStartupProbe#grpc
   */
  readonly grpc?: RunnerSpecEphemeralContainersStartupProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema RunnerSpecEphemeralContainersStartupProbe#httpGet
   */
  readonly httpGet?: RunnerSpecEphemeralContainersStartupProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerSpecEphemeralContainersStartupProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema RunnerSpecEphemeralContainersStartupProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema RunnerSpecEphemeralContainersStartupProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema RunnerSpecEphemeralContainersStartupProbe#tcpSocket
   */
  readonly tcpSocket?: RunnerSpecEphemeralContainersStartupProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema RunnerSpecEphemeralContainersStartupProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema RunnerSpecEphemeralContainersStartupProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'RunnerSpecEphemeralContainersStartupProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecEphemeralContainersStartupProbe(obj: RunnerSpecEphemeralContainersStartupProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_RunnerSpecEphemeralContainersStartupProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_RunnerSpecEphemeralContainersStartupProbeGrpc(obj.grpc),
    'httpGet': toJson_RunnerSpecEphemeralContainersStartupProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_RunnerSpecEphemeralContainersStartupProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * volumeDevice describes a mapping of a raw block device within a container.
 *
 * @schema RunnerSpecEphemeralContainersVolumeDevices
 */
export interface RunnerSpecEphemeralContainersVolumeDevices {
  /**
   * devicePath is the path inside of the container that the device will be mapped to.
   *
   * @schema RunnerSpecEphemeralContainersVolumeDevices#devicePath
   */
  readonly devicePath: string;

  /**
   * name must match the name of a persistentVolumeClaim in the pod
   *
   * @schema RunnerSpecEphemeralContainersVolumeDevices#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RunnerSpecEphemeralContainersVolumeDevices' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecEphemeralContainersVolumeDevices(obj: RunnerSpecEphemeralContainersVolumeDevices | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'devicePath': obj.devicePath,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema RunnerSpecEphemeralContainersVolumeMounts
 */
export interface RunnerSpecEphemeralContainersVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must not contain ':'.
   *
   * @schema RunnerSpecEphemeralContainersVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. This field is beta in 1.10.
   *
   * @schema RunnerSpecEphemeralContainersVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema RunnerSpecEphemeralContainersVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.
   *
   * @default false.
   * @schema RunnerSpecEphemeralContainersVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema RunnerSpecEphemeralContainersVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment. Defaults to "" (volume's root). SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root). SubPathExpr and SubPath are mutually exclusive.
   * @schema RunnerSpecEphemeralContainersVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;

}

/**
 * Converts an object of type 'RunnerSpecEphemeralContainersVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecEphemeralContainersVolumeMounts(obj: RunnerSpecEphemeralContainersVolumeMounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'mountPropagation': obj.mountPropagation,
    'name': obj.name,
    'readOnly': obj.readOnly,
    'subPath': obj.subPath,
    'subPathExpr': obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema RunnerSpecInitContainersEnv
 */
export interface RunnerSpecInitContainersEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema RunnerSpecInitContainersEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded using the previously defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
   *
   * @default .
   * @schema RunnerSpecInitContainersEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema RunnerSpecInitContainersEnv#valueFrom
   */
  readonly valueFrom?: RunnerSpecInitContainersEnvValueFrom;

}

/**
 * Converts an object of type 'RunnerSpecInitContainersEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecInitContainersEnv(obj: RunnerSpecInitContainersEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
    'valueFrom': toJson_RunnerSpecInitContainersEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema RunnerSpecInitContainersEnvFrom
 */
export interface RunnerSpecInitContainersEnvFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema RunnerSpecInitContainersEnvFrom#configMapRef
   */
  readonly configMapRef?: RunnerSpecInitContainersEnvFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema RunnerSpecInitContainersEnvFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema RunnerSpecInitContainersEnvFrom#secretRef
   */
  readonly secretRef?: RunnerSpecInitContainersEnvFromSecretRef;

}

/**
 * Converts an object of type 'RunnerSpecInitContainersEnvFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecInitContainersEnvFrom(obj: RunnerSpecInitContainersEnvFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapRef': toJson_RunnerSpecInitContainersEnvFromConfigMapRef(obj.configMapRef),
    'prefix': obj.prefix,
    'secretRef': toJson_RunnerSpecInitContainersEnvFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Actions that the management system should take in response to container lifecycle events. Cannot be updated.
 *
 * @schema RunnerSpecInitContainersLifecycle
 */
export interface RunnerSpecInitContainersLifecycle {
  /**
   * PostStart is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema RunnerSpecInitContainersLifecycle#postStart
   */
  readonly postStart?: RunnerSpecInitContainersLifecyclePostStart;

  /**
   * PreStop is called immediately before a container is terminated due to an API request or management event such as liveness/startup probe failure, preemption, resource contention, etc. The handler is not called if the container crashes or exits. The Pod's termination grace period countdown begins before the PreStop hook is executed. Regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period (unless delayed by finalizers). Other management of the container blocks until the hook completes or until the termination grace period is reached. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema RunnerSpecInitContainersLifecycle#preStop
   */
  readonly preStop?: RunnerSpecInitContainersLifecyclePreStop;

}

/**
 * Converts an object of type 'RunnerSpecInitContainersLifecycle' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecInitContainersLifecycle(obj: RunnerSpecInitContainersLifecycle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'postStart': toJson_RunnerSpecInitContainersLifecyclePostStart(obj.postStart),
    'preStop': toJson_RunnerSpecInitContainersLifecyclePreStop(obj.preStop),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema RunnerSpecInitContainersLivenessProbe
 */
export interface RunnerSpecInitContainersLivenessProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema RunnerSpecInitContainersLivenessProbe#exec
   */
  readonly exec?: RunnerSpecInitContainersLivenessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema RunnerSpecInitContainersLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
   *
   * @schema RunnerSpecInitContainersLivenessProbe#grpc
   */
  readonly grpc?: RunnerSpecInitContainersLivenessProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema RunnerSpecInitContainersLivenessProbe#httpGet
   */
  readonly httpGet?: RunnerSpecInitContainersLivenessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerSpecInitContainersLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema RunnerSpecInitContainersLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema RunnerSpecInitContainersLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema RunnerSpecInitContainersLivenessProbe#tcpSocket
   */
  readonly tcpSocket?: RunnerSpecInitContainersLivenessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema RunnerSpecInitContainersLivenessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema RunnerSpecInitContainersLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'RunnerSpecInitContainersLivenessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecInitContainersLivenessProbe(obj: RunnerSpecInitContainersLivenessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_RunnerSpecInitContainersLivenessProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_RunnerSpecInitContainersLivenessProbeGrpc(obj.grpc),
    'httpGet': toJson_RunnerSpecInitContainersLivenessProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_RunnerSpecInitContainersLivenessProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ContainerPort represents a network port in a single container.
 *
 * @schema RunnerSpecInitContainersPorts
 */
export interface RunnerSpecInitContainersPorts {
  /**
   * Number of port to expose on the pod's IP address. This must be a valid port number, 0 < x < 65536.
   *
   * @schema RunnerSpecInitContainersPorts#containerPort
   */
  readonly containerPort: number;

  /**
   * What host IP to bind the external port to.
   *
   * @schema RunnerSpecInitContainersPorts#hostIP
   */
  readonly hostIp?: string;

  /**
   * Number of port to expose on the host. If specified, this must be a valid port number, 0 < x < 65536. If HostNetwork is specified, this must match ContainerPort. Most containers do not need this.
   *
   * @schema RunnerSpecInitContainersPorts#hostPort
   */
  readonly hostPort?: number;

  /**
   * If specified, this must be an IANA_SVC_NAME and unique within the pod. Each named port in a pod must have a unique name. Name for the port that can be referred to by services.
   *
   * @schema RunnerSpecInitContainersPorts#name
   */
  readonly name?: string;

  /**
   * Protocol for port. Must be UDP, TCP, or SCTP. Defaults to "TCP".
   *
   * @default TCP".
   * @schema RunnerSpecInitContainersPorts#protocol
   */
  readonly protocol?: string;

}

/**
 * Converts an object of type 'RunnerSpecInitContainersPorts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecInitContainersPorts(obj: RunnerSpecInitContainersPorts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerPort': obj.containerPort,
    'hostIP': obj.hostIp,
    'hostPort': obj.hostPort,
    'name': obj.name,
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema RunnerSpecInitContainersReadinessProbe
 */
export interface RunnerSpecInitContainersReadinessProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema RunnerSpecInitContainersReadinessProbe#exec
   */
  readonly exec?: RunnerSpecInitContainersReadinessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema RunnerSpecInitContainersReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
   *
   * @schema RunnerSpecInitContainersReadinessProbe#grpc
   */
  readonly grpc?: RunnerSpecInitContainersReadinessProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema RunnerSpecInitContainersReadinessProbe#httpGet
   */
  readonly httpGet?: RunnerSpecInitContainersReadinessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerSpecInitContainersReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema RunnerSpecInitContainersReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema RunnerSpecInitContainersReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema RunnerSpecInitContainersReadinessProbe#tcpSocket
   */
  readonly tcpSocket?: RunnerSpecInitContainersReadinessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema RunnerSpecInitContainersReadinessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema RunnerSpecInitContainersReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'RunnerSpecInitContainersReadinessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecInitContainersReadinessProbe(obj: RunnerSpecInitContainersReadinessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_RunnerSpecInitContainersReadinessProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_RunnerSpecInitContainersReadinessProbeGrpc(obj.grpc),
    'httpGet': toJson_RunnerSpecInitContainersReadinessProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_RunnerSpecInitContainersReadinessProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
 *
 * @schema RunnerSpecInitContainersResources
 */
export interface RunnerSpecInitContainersResources {
  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema RunnerSpecInitContainersResources#limits
   */
  readonly limits?: { [key: string]: RunnerSpecInitContainersResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema RunnerSpecInitContainersResources#requests
   */
  readonly requests?: { [key: string]: RunnerSpecInitContainersResourcesRequests };

}

/**
 * Converts an object of type 'RunnerSpecInitContainersResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecInitContainersResources(obj: RunnerSpecInitContainersResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecurityContext defines the security options the container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
 *
 * @schema RunnerSpecInitContainersSecurityContext
 */
export interface RunnerSpecInitContainersSecurityContext {
  /**
   * AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process. This bool directly controls if the no_new_privs flag will be set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP_SYS_ADMIN Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerSpecInitContainersSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
   * @schema RunnerSpecInitContainersSecurityContext#capabilities
   */
  readonly capabilities?: RunnerSpecInitContainersSecurityContextCapabilities;

  /**
   * Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. Defaults to false. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false. Note that this field cannot be set when spec.os.name is windows.
   * @schema RunnerSpecInitContainersSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * procMount denotes the type of proc mount to use for the containers. The default is DefaultProcMount which uses the container runtime defaults for readonly paths and masked paths. This requires the ProcMountType feature flag to be enabled. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerSpecInitContainersSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * Whether this container has a read-only root filesystem. Default is false. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false. Note that this field cannot be set when spec.os.name is windows.
   * @schema RunnerSpecInitContainersSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerSpecInitContainersSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema RunnerSpecInitContainersSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   * @schema RunnerSpecInitContainersSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerSpecInitContainersSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: RunnerSpecInitContainersSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by this container. If seccomp options are provided at both the pod & container level, the container options override the pod options. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerSpecInitContainersSecurityContext#seccompProfile
   */
  readonly seccompProfile?: RunnerSpecInitContainersSecurityContextSeccompProfile;

  /**
   * The Windows specific settings applied to all containers. If unspecified, the options from the PodSecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema RunnerSpecInitContainersSecurityContext#windowsOptions
   */
  readonly windowsOptions?: RunnerSpecInitContainersSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'RunnerSpecInitContainersSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecInitContainersSecurityContext(obj: RunnerSpecInitContainersSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowPrivilegeEscalation': obj.allowPrivilegeEscalation,
    'capabilities': toJson_RunnerSpecInitContainersSecurityContextCapabilities(obj.capabilities),
    'privileged': obj.privileged,
    'procMount': obj.procMount,
    'readOnlyRootFilesystem': obj.readOnlyRootFilesystem,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_RunnerSpecInitContainersSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_RunnerSpecInitContainersSecurityContextSeccompProfile(obj.seccompProfile),
    'windowsOptions': toJson_RunnerSpecInitContainersSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema RunnerSpecInitContainersStartupProbe
 */
export interface RunnerSpecInitContainersStartupProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema RunnerSpecInitContainersStartupProbe#exec
   */
  readonly exec?: RunnerSpecInitContainersStartupProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema RunnerSpecInitContainersStartupProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
   *
   * @schema RunnerSpecInitContainersStartupProbe#grpc
   */
  readonly grpc?: RunnerSpecInitContainersStartupProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema RunnerSpecInitContainersStartupProbe#httpGet
   */
  readonly httpGet?: RunnerSpecInitContainersStartupProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerSpecInitContainersStartupProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema RunnerSpecInitContainersStartupProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema RunnerSpecInitContainersStartupProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema RunnerSpecInitContainersStartupProbe#tcpSocket
   */
  readonly tcpSocket?: RunnerSpecInitContainersStartupProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema RunnerSpecInitContainersStartupProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema RunnerSpecInitContainersStartupProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'RunnerSpecInitContainersStartupProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecInitContainersStartupProbe(obj: RunnerSpecInitContainersStartupProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_RunnerSpecInitContainersStartupProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_RunnerSpecInitContainersStartupProbeGrpc(obj.grpc),
    'httpGet': toJson_RunnerSpecInitContainersStartupProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_RunnerSpecInitContainersStartupProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * volumeDevice describes a mapping of a raw block device within a container.
 *
 * @schema RunnerSpecInitContainersVolumeDevices
 */
export interface RunnerSpecInitContainersVolumeDevices {
  /**
   * devicePath is the path inside of the container that the device will be mapped to.
   *
   * @schema RunnerSpecInitContainersVolumeDevices#devicePath
   */
  readonly devicePath: string;

  /**
   * name must match the name of a persistentVolumeClaim in the pod
   *
   * @schema RunnerSpecInitContainersVolumeDevices#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RunnerSpecInitContainersVolumeDevices' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecInitContainersVolumeDevices(obj: RunnerSpecInitContainersVolumeDevices | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'devicePath': obj.devicePath,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema RunnerSpecInitContainersVolumeMounts
 */
export interface RunnerSpecInitContainersVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must not contain ':'.
   *
   * @schema RunnerSpecInitContainersVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. This field is beta in 1.10.
   *
   * @schema RunnerSpecInitContainersVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema RunnerSpecInitContainersVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.
   *
   * @default false.
   * @schema RunnerSpecInitContainersVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema RunnerSpecInitContainersVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment. Defaults to "" (volume's root). SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root). SubPathExpr and SubPath are mutually exclusive.
   * @schema RunnerSpecInitContainersVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;

}

/**
 * Converts an object of type 'RunnerSpecInitContainersVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecInitContainersVolumeMounts(obj: RunnerSpecInitContainersVolumeMounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'mountPropagation': obj.mountPropagation,
    'name': obj.name,
    'readOnly': obj.readOnly,
    'subPath': obj.subPath,
    'subPathExpr': obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RunnerSpecResourcesLimits
 */
export class RunnerSpecResourcesLimits {
  public static fromNumber(value: number): RunnerSpecResourcesLimits {
    return new RunnerSpecResourcesLimits(value);
  }
  public static fromString(value: string): RunnerSpecResourcesLimits {
    return new RunnerSpecResourcesLimits(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * @schema RunnerSpecResourcesRequests
 */
export class RunnerSpecResourcesRequests {
  public static fromNumber(value: number): RunnerSpecResourcesRequests {
    return new RunnerSpecResourcesRequests(value);
  }
  public static fromString(value: string): RunnerSpecResourcesRequests {
    return new RunnerSpecResourcesRequests(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema RunnerSpecSecurityContextSeLinuxOptions
 */
export interface RunnerSpecSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema RunnerSpecSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema RunnerSpecSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema RunnerSpecSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema RunnerSpecSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'RunnerSpecSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecSecurityContextSeLinuxOptions(obj: RunnerSpecSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema RunnerSpecSecurityContextSeccompProfile
 */
export interface RunnerSpecSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Must be a descending path, relative to the kubelet's configured seccomp profile location. Must only be set if type is "Localhost".
   *
   * @schema RunnerSpecSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied. Valid options are:
   * Localhost - a profile defined in a file on the node should be used. RuntimeDefault - the container runtime default profile should be used. Unconfined - no profile should be applied.
   *
   * @schema RunnerSpecSecurityContextSeccompProfile#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'RunnerSpecSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecSecurityContextSeccompProfile(obj: RunnerSpecSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Sysctl defines a kernel parameter to be set
 *
 * @schema RunnerSpecSecurityContextSysctls
 */
export interface RunnerSpecSecurityContextSysctls {
  /**
   * Name of a property to set
   *
   * @schema RunnerSpecSecurityContextSysctls#name
   */
  readonly name: string;

  /**
   * Value of a property to set
   *
   * @schema RunnerSpecSecurityContextSysctls#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerSpecSecurityContextSysctls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecSecurityContextSysctls(obj: RunnerSpecSecurityContextSysctls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Windows specific settings applied to all containers. If unspecified, the options within a container's SecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema RunnerSpecSecurityContextWindowsOptions
 */
export interface RunnerSpecSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema RunnerSpecSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema RunnerSpecSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container. This field is alpha-level and will only be honored by components that enable the WindowsHostProcessContainers feature flag. Setting this field without the feature flag will result in errors when validating the Pod. All of a Pod's containers must have the same effective HostProcess value (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).  In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema RunnerSpecSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process. Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * @schema RunnerSpecSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'RunnerSpecSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecSecurityContextWindowsOptions(obj: RunnerSpecSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema RunnerSpecSidecarContainersEnv
 */
export interface RunnerSpecSidecarContainersEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema RunnerSpecSidecarContainersEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded using the previously defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
   *
   * @default .
   * @schema RunnerSpecSidecarContainersEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema RunnerSpecSidecarContainersEnv#valueFrom
   */
  readonly valueFrom?: RunnerSpecSidecarContainersEnvValueFrom;

}

/**
 * Converts an object of type 'RunnerSpecSidecarContainersEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecSidecarContainersEnv(obj: RunnerSpecSidecarContainersEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
    'valueFrom': toJson_RunnerSpecSidecarContainersEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema RunnerSpecSidecarContainersEnvFrom
 */
export interface RunnerSpecSidecarContainersEnvFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema RunnerSpecSidecarContainersEnvFrom#configMapRef
   */
  readonly configMapRef?: RunnerSpecSidecarContainersEnvFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema RunnerSpecSidecarContainersEnvFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema RunnerSpecSidecarContainersEnvFrom#secretRef
   */
  readonly secretRef?: RunnerSpecSidecarContainersEnvFromSecretRef;

}

/**
 * Converts an object of type 'RunnerSpecSidecarContainersEnvFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecSidecarContainersEnvFrom(obj: RunnerSpecSidecarContainersEnvFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapRef': toJson_RunnerSpecSidecarContainersEnvFromConfigMapRef(obj.configMapRef),
    'prefix': obj.prefix,
    'secretRef': toJson_RunnerSpecSidecarContainersEnvFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Actions that the management system should take in response to container lifecycle events. Cannot be updated.
 *
 * @schema RunnerSpecSidecarContainersLifecycle
 */
export interface RunnerSpecSidecarContainersLifecycle {
  /**
   * PostStart is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema RunnerSpecSidecarContainersLifecycle#postStart
   */
  readonly postStart?: RunnerSpecSidecarContainersLifecyclePostStart;

  /**
   * PreStop is called immediately before a container is terminated due to an API request or management event such as liveness/startup probe failure, preemption, resource contention, etc. The handler is not called if the container crashes or exits. The Pod's termination grace period countdown begins before the PreStop hook is executed. Regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period (unless delayed by finalizers). Other management of the container blocks until the hook completes or until the termination grace period is reached. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema RunnerSpecSidecarContainersLifecycle#preStop
   */
  readonly preStop?: RunnerSpecSidecarContainersLifecyclePreStop;

}

/**
 * Converts an object of type 'RunnerSpecSidecarContainersLifecycle' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecSidecarContainersLifecycle(obj: RunnerSpecSidecarContainersLifecycle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'postStart': toJson_RunnerSpecSidecarContainersLifecyclePostStart(obj.postStart),
    'preStop': toJson_RunnerSpecSidecarContainersLifecyclePreStop(obj.preStop),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema RunnerSpecSidecarContainersLivenessProbe
 */
export interface RunnerSpecSidecarContainersLivenessProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema RunnerSpecSidecarContainersLivenessProbe#exec
   */
  readonly exec?: RunnerSpecSidecarContainersLivenessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema RunnerSpecSidecarContainersLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
   *
   * @schema RunnerSpecSidecarContainersLivenessProbe#grpc
   */
  readonly grpc?: RunnerSpecSidecarContainersLivenessProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema RunnerSpecSidecarContainersLivenessProbe#httpGet
   */
  readonly httpGet?: RunnerSpecSidecarContainersLivenessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerSpecSidecarContainersLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema RunnerSpecSidecarContainersLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema RunnerSpecSidecarContainersLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema RunnerSpecSidecarContainersLivenessProbe#tcpSocket
   */
  readonly tcpSocket?: RunnerSpecSidecarContainersLivenessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema RunnerSpecSidecarContainersLivenessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema RunnerSpecSidecarContainersLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'RunnerSpecSidecarContainersLivenessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecSidecarContainersLivenessProbe(obj: RunnerSpecSidecarContainersLivenessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_RunnerSpecSidecarContainersLivenessProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_RunnerSpecSidecarContainersLivenessProbeGrpc(obj.grpc),
    'httpGet': toJson_RunnerSpecSidecarContainersLivenessProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_RunnerSpecSidecarContainersLivenessProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ContainerPort represents a network port in a single container.
 *
 * @schema RunnerSpecSidecarContainersPorts
 */
export interface RunnerSpecSidecarContainersPorts {
  /**
   * Number of port to expose on the pod's IP address. This must be a valid port number, 0 < x < 65536.
   *
   * @schema RunnerSpecSidecarContainersPorts#containerPort
   */
  readonly containerPort: number;

  /**
   * What host IP to bind the external port to.
   *
   * @schema RunnerSpecSidecarContainersPorts#hostIP
   */
  readonly hostIp?: string;

  /**
   * Number of port to expose on the host. If specified, this must be a valid port number, 0 < x < 65536. If HostNetwork is specified, this must match ContainerPort. Most containers do not need this.
   *
   * @schema RunnerSpecSidecarContainersPorts#hostPort
   */
  readonly hostPort?: number;

  /**
   * If specified, this must be an IANA_SVC_NAME and unique within the pod. Each named port in a pod must have a unique name. Name for the port that can be referred to by services.
   *
   * @schema RunnerSpecSidecarContainersPorts#name
   */
  readonly name?: string;

  /**
   * Protocol for port. Must be UDP, TCP, or SCTP. Defaults to "TCP".
   *
   * @default TCP".
   * @schema RunnerSpecSidecarContainersPorts#protocol
   */
  readonly protocol?: string;

}

/**
 * Converts an object of type 'RunnerSpecSidecarContainersPorts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecSidecarContainersPorts(obj: RunnerSpecSidecarContainersPorts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerPort': obj.containerPort,
    'hostIP': obj.hostIp,
    'hostPort': obj.hostPort,
    'name': obj.name,
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema RunnerSpecSidecarContainersReadinessProbe
 */
export interface RunnerSpecSidecarContainersReadinessProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema RunnerSpecSidecarContainersReadinessProbe#exec
   */
  readonly exec?: RunnerSpecSidecarContainersReadinessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema RunnerSpecSidecarContainersReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
   *
   * @schema RunnerSpecSidecarContainersReadinessProbe#grpc
   */
  readonly grpc?: RunnerSpecSidecarContainersReadinessProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema RunnerSpecSidecarContainersReadinessProbe#httpGet
   */
  readonly httpGet?: RunnerSpecSidecarContainersReadinessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerSpecSidecarContainersReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema RunnerSpecSidecarContainersReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema RunnerSpecSidecarContainersReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema RunnerSpecSidecarContainersReadinessProbe#tcpSocket
   */
  readonly tcpSocket?: RunnerSpecSidecarContainersReadinessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema RunnerSpecSidecarContainersReadinessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema RunnerSpecSidecarContainersReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'RunnerSpecSidecarContainersReadinessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecSidecarContainersReadinessProbe(obj: RunnerSpecSidecarContainersReadinessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_RunnerSpecSidecarContainersReadinessProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_RunnerSpecSidecarContainersReadinessProbeGrpc(obj.grpc),
    'httpGet': toJson_RunnerSpecSidecarContainersReadinessProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_RunnerSpecSidecarContainersReadinessProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
 *
 * @schema RunnerSpecSidecarContainersResources
 */
export interface RunnerSpecSidecarContainersResources {
  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema RunnerSpecSidecarContainersResources#limits
   */
  readonly limits?: { [key: string]: RunnerSpecSidecarContainersResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema RunnerSpecSidecarContainersResources#requests
   */
  readonly requests?: { [key: string]: RunnerSpecSidecarContainersResourcesRequests };

}

/**
 * Converts an object of type 'RunnerSpecSidecarContainersResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecSidecarContainersResources(obj: RunnerSpecSidecarContainersResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecurityContext defines the security options the container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
 *
 * @schema RunnerSpecSidecarContainersSecurityContext
 */
export interface RunnerSpecSidecarContainersSecurityContext {
  /**
   * AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process. This bool directly controls if the no_new_privs flag will be set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP_SYS_ADMIN Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerSpecSidecarContainersSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
   * @schema RunnerSpecSidecarContainersSecurityContext#capabilities
   */
  readonly capabilities?: RunnerSpecSidecarContainersSecurityContextCapabilities;

  /**
   * Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. Defaults to false. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false. Note that this field cannot be set when spec.os.name is windows.
   * @schema RunnerSpecSidecarContainersSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * procMount denotes the type of proc mount to use for the containers. The default is DefaultProcMount which uses the container runtime defaults for readonly paths and masked paths. This requires the ProcMountType feature flag to be enabled. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerSpecSidecarContainersSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * Whether this container has a read-only root filesystem. Default is false. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false. Note that this field cannot be set when spec.os.name is windows.
   * @schema RunnerSpecSidecarContainersSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerSpecSidecarContainersSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema RunnerSpecSidecarContainersSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   * @schema RunnerSpecSidecarContainersSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerSpecSidecarContainersSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: RunnerSpecSidecarContainersSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by this container. If seccomp options are provided at both the pod & container level, the container options override the pod options. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerSpecSidecarContainersSecurityContext#seccompProfile
   */
  readonly seccompProfile?: RunnerSpecSidecarContainersSecurityContextSeccompProfile;

  /**
   * The Windows specific settings applied to all containers. If unspecified, the options from the PodSecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema RunnerSpecSidecarContainersSecurityContext#windowsOptions
   */
  readonly windowsOptions?: RunnerSpecSidecarContainersSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'RunnerSpecSidecarContainersSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecSidecarContainersSecurityContext(obj: RunnerSpecSidecarContainersSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowPrivilegeEscalation': obj.allowPrivilegeEscalation,
    'capabilities': toJson_RunnerSpecSidecarContainersSecurityContextCapabilities(obj.capabilities),
    'privileged': obj.privileged,
    'procMount': obj.procMount,
    'readOnlyRootFilesystem': obj.readOnlyRootFilesystem,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_RunnerSpecSidecarContainersSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_RunnerSpecSidecarContainersSecurityContextSeccompProfile(obj.seccompProfile),
    'windowsOptions': toJson_RunnerSpecSidecarContainersSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema RunnerSpecSidecarContainersStartupProbe
 */
export interface RunnerSpecSidecarContainersStartupProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema RunnerSpecSidecarContainersStartupProbe#exec
   */
  readonly exec?: RunnerSpecSidecarContainersStartupProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema RunnerSpecSidecarContainersStartupProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
   *
   * @schema RunnerSpecSidecarContainersStartupProbe#grpc
   */
  readonly grpc?: RunnerSpecSidecarContainersStartupProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema RunnerSpecSidecarContainersStartupProbe#httpGet
   */
  readonly httpGet?: RunnerSpecSidecarContainersStartupProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerSpecSidecarContainersStartupProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema RunnerSpecSidecarContainersStartupProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema RunnerSpecSidecarContainersStartupProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema RunnerSpecSidecarContainersStartupProbe#tcpSocket
   */
  readonly tcpSocket?: RunnerSpecSidecarContainersStartupProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema RunnerSpecSidecarContainersStartupProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema RunnerSpecSidecarContainersStartupProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'RunnerSpecSidecarContainersStartupProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecSidecarContainersStartupProbe(obj: RunnerSpecSidecarContainersStartupProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_RunnerSpecSidecarContainersStartupProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_RunnerSpecSidecarContainersStartupProbeGrpc(obj.grpc),
    'httpGet': toJson_RunnerSpecSidecarContainersStartupProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_RunnerSpecSidecarContainersStartupProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * volumeDevice describes a mapping of a raw block device within a container.
 *
 * @schema RunnerSpecSidecarContainersVolumeDevices
 */
export interface RunnerSpecSidecarContainersVolumeDevices {
  /**
   * devicePath is the path inside of the container that the device will be mapped to.
   *
   * @schema RunnerSpecSidecarContainersVolumeDevices#devicePath
   */
  readonly devicePath: string;

  /**
   * name must match the name of a persistentVolumeClaim in the pod
   *
   * @schema RunnerSpecSidecarContainersVolumeDevices#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RunnerSpecSidecarContainersVolumeDevices' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecSidecarContainersVolumeDevices(obj: RunnerSpecSidecarContainersVolumeDevices | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'devicePath': obj.devicePath,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema RunnerSpecSidecarContainersVolumeMounts
 */
export interface RunnerSpecSidecarContainersVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must not contain ':'.
   *
   * @schema RunnerSpecSidecarContainersVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. This field is beta in 1.10.
   *
   * @schema RunnerSpecSidecarContainersVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema RunnerSpecSidecarContainersVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.
   *
   * @default false.
   * @schema RunnerSpecSidecarContainersVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema RunnerSpecSidecarContainersVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment. Defaults to "" (volume's root). SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root). SubPathExpr and SubPath are mutually exclusive.
   * @schema RunnerSpecSidecarContainersVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;

}

/**
 * Converts an object of type 'RunnerSpecSidecarContainersVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecSidecarContainersVolumeMounts(obj: RunnerSpecSidecarContainersVolumeMounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'mountPropagation': obj.mountPropagation,
    'name': obj.name,
    'readOnly': obj.readOnly,
    'subPath': obj.subPath,
    'subPathExpr': obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LabelSelector is used to find matching pods. Pods that match this label selector are counted to determine the number of pods in their corresponding topology domain.
 *
 * @schema RunnerSpecTopologySpreadConstraintLabelSelector
 */
export interface RunnerSpecTopologySpreadConstraintLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema RunnerSpecTopologySpreadConstraintLabelSelector#matchExpressions
   */
  readonly matchExpressions?: RunnerSpecTopologySpreadConstraintLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema RunnerSpecTopologySpreadConstraintLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'RunnerSpecTopologySpreadConstraintLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecTopologySpreadConstraintLabelSelector(obj: RunnerSpecTopologySpreadConstraintLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_RunnerSpecTopologySpreadConstraintLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AWSElasticBlockStore represents an AWS Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
 *
 * @schema RunnerSpecVolumesAwsElasticBlockStore
 */
export interface RunnerSpecVolumesAwsElasticBlockStore {
  /**
   * Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema RunnerSpecVolumesAwsElasticBlockStore#fsType
   */
  readonly fsType?: string;

  /**
   * The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as "1". Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
   *
   * @schema RunnerSpecVolumesAwsElasticBlockStore#partition
   */
  readonly partition?: number;

  /**
   * Specify "true" to force and set the ReadOnly property in VolumeMounts to "true". If omitted, the default is "false". More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema RunnerSpecVolumesAwsElasticBlockStore#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema RunnerSpecVolumesAwsElasticBlockStore#volumeID
   */
  readonly volumeId: string;

}

/**
 * Converts an object of type 'RunnerSpecVolumesAwsElasticBlockStore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecVolumesAwsElasticBlockStore(obj: RunnerSpecVolumesAwsElasticBlockStore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'partition': obj.partition,
    'readOnly': obj.readOnly,
    'volumeID': obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
 *
 * @schema RunnerSpecVolumesAzureDisk
 */
export interface RunnerSpecVolumesAzureDisk {
  /**
   * Host Caching mode: None, Read Only, Read Write.
   *
   * @schema RunnerSpecVolumesAzureDisk#cachingMode
   */
  readonly cachingMode?: string;

  /**
   * The Name of the data disk in the blob storage
   *
   * @schema RunnerSpecVolumesAzureDisk#diskName
   */
  readonly diskName: string;

  /**
   * The URI the data disk in the blob storage
   *
   * @schema RunnerSpecVolumesAzureDisk#diskURI
   */
  readonly diskUri: string;

  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema RunnerSpecVolumesAzureDisk#fsType
   */
  readonly fsType?: string;

  /**
   * Expected values Shared: multiple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared
   *
   * @schema RunnerSpecVolumesAzureDisk#kind
   */
  readonly kind?: string;

  /**
   * Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema RunnerSpecVolumesAzureDisk#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * Converts an object of type 'RunnerSpecVolumesAzureDisk' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecVolumesAzureDisk(obj: RunnerSpecVolumesAzureDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cachingMode': obj.cachingMode,
    'diskName': obj.diskName,
    'diskURI': obj.diskUri,
    'fsType': obj.fsType,
    'kind': obj.kind,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
 *
 * @schema RunnerSpecVolumesAzureFile
 */
export interface RunnerSpecVolumesAzureFile {
  /**
   * Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema RunnerSpecVolumesAzureFile#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * the name of secret that contains Azure Storage Account Name and Key
   *
   * @schema RunnerSpecVolumesAzureFile#secretName
   */
  readonly secretName: string;

  /**
   * Share Name
   *
   * @schema RunnerSpecVolumesAzureFile#shareName
   */
  readonly shareName: string;

}

/**
 * Converts an object of type 'RunnerSpecVolumesAzureFile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecVolumesAzureFile(obj: RunnerSpecVolumesAzureFile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'readOnly': obj.readOnly,
    'secretName': obj.secretName,
    'shareName': obj.shareName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CephFS represents a Ceph FS mount on the host that shares a pod's lifetime
 *
 * @schema RunnerSpecVolumesCephfs
 */
export interface RunnerSpecVolumesCephfs {
  /**
   * Required: Monitors is a collection of Ceph monitors More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema RunnerSpecVolumesCephfs#monitors
   */
  readonly monitors: string[];

  /**
   * Optional: Used as the mounted root, rather than the full Ceph tree, default is /
   *
   * @schema RunnerSpecVolumesCephfs#path
   */
  readonly path?: string;

  /**
   * Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   * @schema RunnerSpecVolumesCephfs#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema RunnerSpecVolumesCephfs#secretFile
   */
  readonly secretFile?: string;

  /**
   * Optional: SecretRef is reference to the authentication secret for User, default is empty. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema RunnerSpecVolumesCephfs#secretRef
   */
  readonly secretRef?: RunnerSpecVolumesCephfsSecretRef;

  /**
   * Optional: User is the rados user name, default is admin More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema RunnerSpecVolumesCephfs#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'RunnerSpecVolumesCephfs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecVolumesCephfs(obj: RunnerSpecVolumesCephfs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'monitors': obj.monitors?.map(y => y),
    'path': obj.path,
    'readOnly': obj.readOnly,
    'secretFile': obj.secretFile,
    'secretRef': toJson_RunnerSpecVolumesCephfsSecretRef(obj.secretRef),
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Cinder represents a cinder volume attached and mounted on kubelets host machine. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
 *
 * @schema RunnerSpecVolumesCinder
 */
export interface RunnerSpecVolumesCinder {
  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema RunnerSpecVolumesCinder#fsType
   */
  readonly fsType?: string;

  /**
   * Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   * @schema RunnerSpecVolumesCinder#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Optional: points to a secret object containing parameters used to connect to OpenStack.
   *
   * @schema RunnerSpecVolumesCinder#secretRef
   */
  readonly secretRef?: RunnerSpecVolumesCinderSecretRef;

  /**
   * volume id used to identify the volume in cinder. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema RunnerSpecVolumesCinder#volumeID
   */
  readonly volumeId: string;

}

/**
 * Converts an object of type 'RunnerSpecVolumesCinder' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecVolumesCinder(obj: RunnerSpecVolumesCinder | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'readOnly': obj.readOnly,
    'secretRef': toJson_RunnerSpecVolumesCinderSecretRef(obj.secretRef),
    'volumeID': obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap represents a configMap that should populate this volume
 *
 * @schema RunnerSpecVolumesConfigMap
 */
export interface RunnerSpecVolumesConfigMap {
  /**
   * Optional: mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   * @schema RunnerSpecVolumesConfigMap#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema RunnerSpecVolumesConfigMap#items
   */
  readonly items?: RunnerSpecVolumesConfigMapItems[];

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerSpecVolumesConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its keys must be defined
   *
   * @schema RunnerSpecVolumesConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerSpecVolumesConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecVolumesConfigMap(obj: RunnerSpecVolumesConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_RunnerSpecVolumesConfigMapItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CSI (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers (Beta feature).
 *
 * @schema RunnerSpecVolumesCsi
 */
export interface RunnerSpecVolumesCsi {
  /**
   * Driver is the name of the CSI driver that handles this volume. Consult with your admin for the correct name as registered in the cluster.
   *
   * @schema RunnerSpecVolumesCsi#driver
   */
  readonly driver: string;

  /**
   * Filesystem type to mount. Ex. "ext4", "xfs", "ntfs". If not provided, the empty value is passed to the associated CSI driver which will determine the default filesystem to apply.
   *
   * @schema RunnerSpecVolumesCsi#fsType
   */
  readonly fsType?: string;

  /**
   * NodePublishSecretRef is a reference to the secret object containing sensitive information to pass to the CSI driver to complete the CSI NodePublishVolume and NodeUnpublishVolume calls. This field is optional, and  may be empty if no secret is required. If the secret object contains more than one secret, all secret references are passed.
   *
   * @schema RunnerSpecVolumesCsi#nodePublishSecretRef
   */
  readonly nodePublishSecretRef?: RunnerSpecVolumesCsiNodePublishSecretRef;

  /**
   * Specifies a read-only configuration for the volume. Defaults to false (read/write).
   *
   * @default false (read/write).
   * @schema RunnerSpecVolumesCsi#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * VolumeAttributes stores driver-specific properties that are passed to the CSI driver. Consult your driver's documentation for supported values.
   *
   * @schema RunnerSpecVolumesCsi#volumeAttributes
   */
  readonly volumeAttributes?: { [key: string]: string };

}

/**
 * Converts an object of type 'RunnerSpecVolumesCsi' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecVolumesCsi(obj: RunnerSpecVolumesCsi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'driver': obj.driver,
    'fsType': obj.fsType,
    'nodePublishSecretRef': toJson_RunnerSpecVolumesCsiNodePublishSecretRef(obj.nodePublishSecretRef),
    'readOnly': obj.readOnly,
    'volumeAttributes': ((obj.volumeAttributes) === undefined) ? undefined : (Object.entries(obj.volumeAttributes).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DownwardAPI represents downward API about the pod that should populate this volume
 *
 * @schema RunnerSpecVolumesDownwardApi
 */
export interface RunnerSpecVolumesDownwardApi {
  /**
   * Optional: mode bits to use on created files by default. Must be a Optional: mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   * @schema RunnerSpecVolumesDownwardApi#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * Items is a list of downward API volume file
   *
   * @schema RunnerSpecVolumesDownwardApi#items
   */
  readonly items?: RunnerSpecVolumesDownwardApiItems[];

}

/**
 * Converts an object of type 'RunnerSpecVolumesDownwardApi' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecVolumesDownwardApi(obj: RunnerSpecVolumesDownwardApi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_RunnerSpecVolumesDownwardApiItems(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EmptyDir represents a temporary directory that shares a pod's lifetime. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
 *
 * @schema RunnerSpecVolumesEmptyDir
 */
export interface RunnerSpecVolumesEmptyDir {
  /**
   * What type of storage medium should back this directory. The default is "" which means to use the node's default medium. Must be an empty string (default) or Memory. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema RunnerSpecVolumesEmptyDir#medium
   */
  readonly medium?: string;

  /**
   * Total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. The default is nil which means that the limit is undefined. More info: http://kubernetes.io/docs/user-guide/volumes#emptydir
   *
   * @schema RunnerSpecVolumesEmptyDir#sizeLimit
   */
  readonly sizeLimit?: RunnerSpecVolumesEmptyDirSizeLimit;

}

/**
 * Converts an object of type 'RunnerSpecVolumesEmptyDir' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecVolumesEmptyDir(obj: RunnerSpecVolumesEmptyDir | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'medium': obj.medium,
    'sizeLimit': obj.sizeLimit?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Ephemeral represents a volume that is handled by a cluster storage driver. The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts, and deleted when the pod is removed.
 * Use this if: a) the volume is only needed while the pod runs, b) features of normal volumes like restoring from snapshot or capacity    tracking are needed, c) the storage driver is specified through a storage class, and d) the storage driver supports dynamic volume provisioning through    a PersistentVolumeClaim (see EphemeralVolumeSource for more    information on the connection between this volume type    and PersistentVolumeClaim).
 * Use PersistentVolumeClaim or one of the vendor-specific APIs for volumes that persist for longer than the lifecycle of an individual pod.
 * Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to be used that way - see the documentation of the driver for more information.
 * A pod can use both types of ephemeral volumes and persistent volumes at the same time.
 *
 * @schema RunnerSpecVolumesEphemeral
 */
export interface RunnerSpecVolumesEphemeral {
  /**
   * Will be used to create a stand-alone PVC to provision the volume. The pod in which this EphemeralVolumeSource is embedded will be the owner of the PVC, i.e. the PVC will be deleted together with the pod.  The name of the PVC will be `<pod name>-<volume name>` where `<volume name>` is the name from the `PodSpec.Volumes` array entry. Pod validation will reject the pod if the concatenated name is not valid for a PVC (for example, too long).
   * An existing PVC with that name that is not owned by the pod will *not* be used for the pod to avoid using an unrelated volume by mistake. Starting the pod is then blocked until the unrelated PVC is removed. If such a pre-created PVC is meant to be used by the pod, the PVC has to updated with an owner reference to the pod once the pod exists. Normally this should not be necessary, but it may be useful when manually reconstructing a broken cluster.
   * This field is read-only and no changes will be made by Kubernetes to the PVC after it has been created.
   * Required, must not be nil.
   *
   * @schema RunnerSpecVolumesEphemeral#volumeClaimTemplate
   */
  readonly volumeClaimTemplate?: RunnerSpecVolumesEphemeralVolumeClaimTemplate;

}

/**
 * Converts an object of type 'RunnerSpecVolumesEphemeral' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecVolumesEphemeral(obj: RunnerSpecVolumesEphemeral | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'volumeClaimTemplate': toJson_RunnerSpecVolumesEphemeralVolumeClaimTemplate(obj.volumeClaimTemplate),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FC represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
 *
 * @schema RunnerSpecVolumesFc
 */
export interface RunnerSpecVolumesFc {
  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema RunnerSpecVolumesFc#fsType
   */
  readonly fsType?: string;

  /**
   * Optional: FC target lun number
   *
   * @schema RunnerSpecVolumesFc#lun
   */
  readonly lun?: number;

  /**
   * Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema RunnerSpecVolumesFc#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Optional: FC target worldwide names (WWNs)
   *
   * @schema RunnerSpecVolumesFc#targetWWNs
   */
  readonly targetWwNs?: string[];

  /**
   * Optional: FC volume world wide identifiers (wwids) Either wwids or combination of targetWWNs and lun must be set, but not both simultaneously.
   *
   * @schema RunnerSpecVolumesFc#wwids
   */
  readonly wwids?: string[];

}

/**
 * Converts an object of type 'RunnerSpecVolumesFc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecVolumesFc(obj: RunnerSpecVolumesFc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'lun': obj.lun,
    'readOnly': obj.readOnly,
    'targetWWNs': obj.targetWwNs?.map(y => y),
    'wwids': obj.wwids?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FlexVolume represents a generic volume resource that is provisioned/attached using an exec based plugin.
 *
 * @schema RunnerSpecVolumesFlexVolume
 */
export interface RunnerSpecVolumesFlexVolume {
  /**
   * Driver is the name of the driver to use for this volume.
   *
   * @schema RunnerSpecVolumesFlexVolume#driver
   */
  readonly driver: string;

  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
   *
   * @schema RunnerSpecVolumesFlexVolume#fsType
   */
  readonly fsType?: string;

  /**
   * Optional: Extra command options if any.
   *
   * @schema RunnerSpecVolumesFlexVolume#options
   */
  readonly options?: { [key: string]: string };

  /**
   * Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema RunnerSpecVolumesFlexVolume#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Optional: SecretRef is reference to the secret object containing sensitive information to pass to the plugin scripts. This may be empty if no secret object is specified. If the secret object contains more than one secret, all secrets are passed to the plugin scripts.
   *
   * @schema RunnerSpecVolumesFlexVolume#secretRef
   */
  readonly secretRef?: RunnerSpecVolumesFlexVolumeSecretRef;

}

/**
 * Converts an object of type 'RunnerSpecVolumesFlexVolume' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecVolumesFlexVolume(obj: RunnerSpecVolumesFlexVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'driver': obj.driver,
    'fsType': obj.fsType,
    'options': ((obj.options) === undefined) ? undefined : (Object.entries(obj.options).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'readOnly': obj.readOnly,
    'secretRef': toJson_RunnerSpecVolumesFlexVolumeSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running
 *
 * @schema RunnerSpecVolumesFlocker
 */
export interface RunnerSpecVolumesFlocker {
  /**
   * Name of the dataset stored as metadata -> name on the dataset for Flocker should be considered as deprecated
   *
   * @schema RunnerSpecVolumesFlocker#datasetName
   */
  readonly datasetName?: string;

  /**
   * UUID of the dataset. This is unique identifier of a Flocker dataset
   *
   * @schema RunnerSpecVolumesFlocker#datasetUUID
   */
  readonly datasetUuid?: string;

}

/**
 * Converts an object of type 'RunnerSpecVolumesFlocker' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecVolumesFlocker(obj: RunnerSpecVolumesFlocker | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'datasetName': obj.datasetName,
    'datasetUUID': obj.datasetUuid,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
 *
 * @schema RunnerSpecVolumesGcePersistentDisk
 */
export interface RunnerSpecVolumesGcePersistentDisk {
  /**
   * Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema RunnerSpecVolumesGcePersistentDisk#fsType
   */
  readonly fsType?: string;

  /**
   * The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as "1". Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty). More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema RunnerSpecVolumesGcePersistentDisk#partition
   */
  readonly partition?: number;

  /**
   * Unique name of the PD resource in GCE. Used to identify the disk in GCE. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema RunnerSpecVolumesGcePersistentDisk#pdName
   */
  readonly pdName: string;

  /**
   * ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @default false. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   * @schema RunnerSpecVolumesGcePersistentDisk#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * Converts an object of type 'RunnerSpecVolumesGcePersistentDisk' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecVolumesGcePersistentDisk(obj: RunnerSpecVolumesGcePersistentDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'partition': obj.partition,
    'pdName': obj.pdName,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GitRepo represents a git repository at a particular revision. DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir into the Pod's container.
 *
 * @schema RunnerSpecVolumesGitRepo
 */
export interface RunnerSpecVolumesGitRepo {
  /**
   * Target directory name. Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the git repository.  Otherwise, if specified, the volume will contain the git repository in the subdirectory with the given name.
   *
   * @schema RunnerSpecVolumesGitRepo#directory
   */
  readonly directory?: string;

  /**
   * Repository URL
   *
   * @schema RunnerSpecVolumesGitRepo#repository
   */
  readonly repository: string;

  /**
   * Commit hash for the specified revision.
   *
   * @schema RunnerSpecVolumesGitRepo#revision
   */
  readonly revision?: string;

}

/**
 * Converts an object of type 'RunnerSpecVolumesGitRepo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecVolumesGitRepo(obj: RunnerSpecVolumesGitRepo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'directory': obj.directory,
    'repository': obj.repository,
    'revision': obj.revision,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/glusterfs/README.md
 *
 * @schema RunnerSpecVolumesGlusterfs
 */
export interface RunnerSpecVolumesGlusterfs {
  /**
   * EndpointsName is the endpoint name that details Glusterfs topology. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @schema RunnerSpecVolumesGlusterfs#endpoints
   */
  readonly endpoints: string;

  /**
   * Path is the Glusterfs volume path. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @schema RunnerSpecVolumesGlusterfs#path
   */
  readonly path: string;

  /**
   * ReadOnly here will force the Glusterfs volume to be mounted with read-only permissions. Defaults to false. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @default false. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   * @schema RunnerSpecVolumesGlusterfs#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * Converts an object of type 'RunnerSpecVolumesGlusterfs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecVolumesGlusterfs(obj: RunnerSpecVolumesGlusterfs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'endpoints': obj.endpoints,
    'path': obj.path,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HostPath represents a pre-existing file or directory on the host machine that is directly exposed to the container. This is generally used for system agents or other privileged things that are allowed to see the host machine. Most containers will NOT need this. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath --- TODO(jonesdl) We need to restrict who can use host directory mounts and who can/can not mount host directories as read/write.
 *
 * @schema RunnerSpecVolumesHostPath
 */
export interface RunnerSpecVolumesHostPath {
  /**
   * Path of the directory on the host. If the path is a symlink, it will follow the link to the real path. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @schema RunnerSpecVolumesHostPath#path
   */
  readonly path: string;

  /**
   * Type for HostPath Volume Defaults to "" More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @default More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   * @schema RunnerSpecVolumesHostPath#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RunnerSpecVolumesHostPath' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecVolumesHostPath(obj: RunnerSpecVolumesHostPath | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ISCSI represents an ISCSI Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://examples.k8s.io/volumes/iscsi/README.md
 *
 * @schema RunnerSpecVolumesIscsi
 */
export interface RunnerSpecVolumesIscsi {
  /**
   * whether support iSCSI Discovery CHAP authentication
   *
   * @schema RunnerSpecVolumesIscsi#chapAuthDiscovery
   */
  readonly chapAuthDiscovery?: boolean;

  /**
   * whether support iSCSI Session CHAP authentication
   *
   * @schema RunnerSpecVolumesIscsi#chapAuthSession
   */
  readonly chapAuthSession?: boolean;

  /**
   * Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema RunnerSpecVolumesIscsi#fsType
   */
  readonly fsType?: string;

  /**
   * Custom iSCSI Initiator Name. If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface <target portal>:<volume name> will be created for the connection.
   *
   * @schema RunnerSpecVolumesIscsi#initiatorName
   */
  readonly initiatorName?: string;

  /**
   * Target iSCSI Qualified Name.
   *
   * @schema RunnerSpecVolumesIscsi#iqn
   */
  readonly iqn: string;

  /**
   * iSCSI Interface Name that uses an iSCSI transport. Defaults to 'default' (tcp).
   *
   * @default default' (tcp).
   * @schema RunnerSpecVolumesIscsi#iscsiInterface
   */
  readonly iscsiInterface?: string;

  /**
   * iSCSI Target Lun number.
   *
   * @schema RunnerSpecVolumesIscsi#lun
   */
  readonly lun: number;

  /**
   * iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port is other than default (typically TCP ports 860 and 3260).
   *
   * @schema RunnerSpecVolumesIscsi#portals
   */
  readonly portals?: string[];

  /**
   * ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false.
   *
   * @default false.
   * @schema RunnerSpecVolumesIscsi#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * CHAP Secret for iSCSI target and initiator authentication
   *
   * @schema RunnerSpecVolumesIscsi#secretRef
   */
  readonly secretRef?: RunnerSpecVolumesIscsiSecretRef;

  /**
   * iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port is other than default (typically TCP ports 860 and 3260).
   *
   * @schema RunnerSpecVolumesIscsi#targetPortal
   */
  readonly targetPortal: string;

}

/**
 * Converts an object of type 'RunnerSpecVolumesIscsi' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecVolumesIscsi(obj: RunnerSpecVolumesIscsi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'chapAuthDiscovery': obj.chapAuthDiscovery,
    'chapAuthSession': obj.chapAuthSession,
    'fsType': obj.fsType,
    'initiatorName': obj.initiatorName,
    'iqn': obj.iqn,
    'iscsiInterface': obj.iscsiInterface,
    'lun': obj.lun,
    'portals': obj.portals?.map(y => y),
    'readOnly': obj.readOnly,
    'secretRef': toJson_RunnerSpecVolumesIscsiSecretRef(obj.secretRef),
    'targetPortal': obj.targetPortal,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NFS represents an NFS mount on the host that shares a pod's lifetime More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
 *
 * @schema RunnerSpecVolumesNfs
 */
export interface RunnerSpecVolumesNfs {
  /**
   * Path that is exported by the NFS server. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema RunnerSpecVolumesNfs#path
   */
  readonly path: string;

  /**
   * ReadOnly here will force the NFS export to be mounted with read-only permissions. Defaults to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @default false. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   * @schema RunnerSpecVolumesNfs#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Server is the hostname or IP address of the NFS server. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema RunnerSpecVolumesNfs#server
   */
  readonly server: string;

}

/**
 * Converts an object of type 'RunnerSpecVolumesNfs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecVolumesNfs(obj: RunnerSpecVolumesNfs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'readOnly': obj.readOnly,
    'server': obj.server,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PersistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in the same namespace. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
 *
 * @schema RunnerSpecVolumesPersistentVolumeClaim
 */
export interface RunnerSpecVolumesPersistentVolumeClaim {
  /**
   * ClaimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema RunnerSpecVolumesPersistentVolumeClaim#claimName
   */
  readonly claimName: string;

  /**
   * Will force the ReadOnly setting in VolumeMounts. Default false.
   *
   * @schema RunnerSpecVolumesPersistentVolumeClaim#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * Converts an object of type 'RunnerSpecVolumesPersistentVolumeClaim' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecVolumesPersistentVolumeClaim(obj: RunnerSpecVolumesPersistentVolumeClaim | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claimName': obj.claimName,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PhotonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
 *
 * @schema RunnerSpecVolumesPhotonPersistentDisk
 */
export interface RunnerSpecVolumesPhotonPersistentDisk {
  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema RunnerSpecVolumesPhotonPersistentDisk#fsType
   */
  readonly fsType?: string;

  /**
   * ID that identifies Photon Controller persistent disk
   *
   * @schema RunnerSpecVolumesPhotonPersistentDisk#pdID
   */
  readonly pdId: string;

}

/**
 * Converts an object of type 'RunnerSpecVolumesPhotonPersistentDisk' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecVolumesPhotonPersistentDisk(obj: RunnerSpecVolumesPhotonPersistentDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'pdID': obj.pdId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PortworxVolume represents a portworx volume attached and mounted on kubelets host machine
 *
 * @schema RunnerSpecVolumesPortworxVolume
 */
export interface RunnerSpecVolumesPortworxVolume {
  /**
   * FSType represents the filesystem type to mount Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema RunnerSpecVolumesPortworxVolume#fsType
   */
  readonly fsType?: string;

  /**
   * Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema RunnerSpecVolumesPortworxVolume#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * VolumeID uniquely identifies a Portworx volume
   *
   * @schema RunnerSpecVolumesPortworxVolume#volumeID
   */
  readonly volumeId: string;

}

/**
 * Converts an object of type 'RunnerSpecVolumesPortworxVolume' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecVolumesPortworxVolume(obj: RunnerSpecVolumesPortworxVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'readOnly': obj.readOnly,
    'volumeID': obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Items for all in one resources secrets, configmaps, and downward API
 *
 * @schema RunnerSpecVolumesProjected
 */
export interface RunnerSpecVolumesProjected {
  /**
   * Mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema RunnerSpecVolumesProjected#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * list of volume projections
   *
   * @schema RunnerSpecVolumesProjected#sources
   */
  readonly sources?: RunnerSpecVolumesProjectedSources[];

}

/**
 * Converts an object of type 'RunnerSpecVolumesProjected' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecVolumesProjected(obj: RunnerSpecVolumesProjected | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'sources': obj.sources?.map(y => toJson_RunnerSpecVolumesProjectedSources(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Quobyte represents a Quobyte mount on the host that shares a pod's lifetime
 *
 * @schema RunnerSpecVolumesQuobyte
 */
export interface RunnerSpecVolumesQuobyte {
  /**
   * Group to map volume access to Default is no group
   *
   * @default no group
   * @schema RunnerSpecVolumesQuobyte#group
   */
  readonly group?: string;

  /**
   * ReadOnly here will force the Quobyte volume to be mounted with read-only permissions. Defaults to false.
   *
   * @default false.
   * @schema RunnerSpecVolumesQuobyte#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Registry represents a single or multiple Quobyte Registry services specified as a string as host:port pair (multiple entries are separated with commas) which acts as the central registry for volumes
   *
   * @schema RunnerSpecVolumesQuobyte#registry
   */
  readonly registry: string;

  /**
   * Tenant owning the given Quobyte volume in the Backend Used with dynamically provisioned Quobyte volumes, value is set by the plugin
   *
   * @schema RunnerSpecVolumesQuobyte#tenant
   */
  readonly tenant?: string;

  /**
   * User to map volume access to Defaults to serivceaccount user
   *
   * @default serivceaccount user
   * @schema RunnerSpecVolumesQuobyte#user
   */
  readonly user?: string;

  /**
   * Volume is a string that references an already created Quobyte volume by name.
   *
   * @schema RunnerSpecVolumesQuobyte#volume
   */
  readonly volume: string;

}

/**
 * Converts an object of type 'RunnerSpecVolumesQuobyte' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecVolumesQuobyte(obj: RunnerSpecVolumesQuobyte | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'readOnly': obj.readOnly,
    'registry': obj.registry,
    'tenant': obj.tenant,
    'user': obj.user,
    'volume': obj.volume,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RBD represents a Rados Block Device mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/rbd/README.md
 *
 * @schema RunnerSpecVolumesRbd
 */
export interface RunnerSpecVolumesRbd {
  /**
   * Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema RunnerSpecVolumesRbd#fsType
   */
  readonly fsType?: string;

  /**
   * The rados image name. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @schema RunnerSpecVolumesRbd#image
   */
  readonly image: string;

  /**
   * Keyring is the path to key ring for RBDUser. Default is /etc/ceph/keyring. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default etc/ceph/keyring. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema RunnerSpecVolumesRbd#keyring
   */
  readonly keyring?: string;

  /**
   * A collection of Ceph monitors. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @schema RunnerSpecVolumesRbd#monitors
   */
  readonly monitors: string[];

  /**
   * The rados pool name. Default is rbd. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default rbd. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema RunnerSpecVolumesRbd#pool
   */
  readonly pool?: string;

  /**
   * ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default false. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema RunnerSpecVolumesRbd#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * SecretRef is name of the authentication secret for RBDUser. If provided overrides keyring. Default is nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema RunnerSpecVolumesRbd#secretRef
   */
  readonly secretRef?: RunnerSpecVolumesRbdSecretRef;

  /**
   * The rados user name. Default is admin. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default admin. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema RunnerSpecVolumesRbd#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'RunnerSpecVolumesRbd' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecVolumesRbd(obj: RunnerSpecVolumesRbd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'image': obj.image,
    'keyring': obj.keyring,
    'monitors': obj.monitors?.map(y => y),
    'pool': obj.pool,
    'readOnly': obj.readOnly,
    'secretRef': toJson_RunnerSpecVolumesRbdSecretRef(obj.secretRef),
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ScaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
 *
 * @schema RunnerSpecVolumesScaleIo
 */
export interface RunnerSpecVolumesScaleIo {
  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Default is "xfs".
   *
   * @default xfs".
   * @schema RunnerSpecVolumesScaleIo#fsType
   */
  readonly fsType?: string;

  /**
   * The host address of the ScaleIO API Gateway.
   *
   * @schema RunnerSpecVolumesScaleIo#gateway
   */
  readonly gateway: string;

  /**
   * The name of the ScaleIO Protection Domain for the configured storage.
   *
   * @schema RunnerSpecVolumesScaleIo#protectionDomain
   */
  readonly protectionDomain?: string;

  /**
   * Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema RunnerSpecVolumesScaleIo#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * SecretRef references to the secret for ScaleIO user and other sensitive information. If this is not provided, Login operation will fail.
   *
   * @schema RunnerSpecVolumesScaleIo#secretRef
   */
  readonly secretRef: RunnerSpecVolumesScaleIoSecretRef;

  /**
   * Flag to enable/disable SSL communication with Gateway, default false
   *
   * @schema RunnerSpecVolumesScaleIo#sslEnabled
   */
  readonly sslEnabled?: boolean;

  /**
   * Indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned. Default is ThinProvisioned.
   *
   * @default ThinProvisioned.
   * @schema RunnerSpecVolumesScaleIo#storageMode
   */
  readonly storageMode?: string;

  /**
   * The ScaleIO Storage Pool associated with the protection domain.
   *
   * @schema RunnerSpecVolumesScaleIo#storagePool
   */
  readonly storagePool?: string;

  /**
   * The name of the storage system as configured in ScaleIO.
   *
   * @schema RunnerSpecVolumesScaleIo#system
   */
  readonly system: string;

  /**
   * The name of a volume already created in the ScaleIO system that is associated with this volume source.
   *
   * @schema RunnerSpecVolumesScaleIo#volumeName
   */
  readonly volumeName?: string;

}

/**
 * Converts an object of type 'RunnerSpecVolumesScaleIo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecVolumesScaleIo(obj: RunnerSpecVolumesScaleIo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'gateway': obj.gateway,
    'protectionDomain': obj.protectionDomain,
    'readOnly': obj.readOnly,
    'secretRef': toJson_RunnerSpecVolumesScaleIoSecretRef(obj.secretRef),
    'sslEnabled': obj.sslEnabled,
    'storageMode': obj.storageMode,
    'storagePool': obj.storagePool,
    'system': obj.system,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
 *
 * @schema RunnerSpecVolumesSecret
 */
export interface RunnerSpecVolumesSecret {
  /**
   * Optional: mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   * @schema RunnerSpecVolumesSecret#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema RunnerSpecVolumesSecret#items
   */
  readonly items?: RunnerSpecVolumesSecretItems[];

  /**
   * Specify whether the Secret or its keys must be defined
   *
   * @schema RunnerSpecVolumesSecret#optional
   */
  readonly optional?: boolean;

  /**
   * Name of the secret in the pod's namespace to use. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   *
   * @schema RunnerSpecVolumesSecret#secretName
   */
  readonly secretName?: string;

}

/**
 * Converts an object of type 'RunnerSpecVolumesSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecVolumesSecret(obj: RunnerSpecVolumesSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_RunnerSpecVolumesSecretItems(y)),
    'optional': obj.optional,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * StorageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
 *
 * @schema RunnerSpecVolumesStorageos
 */
export interface RunnerSpecVolumesStorageos {
  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema RunnerSpecVolumesStorageos#fsType
   */
  readonly fsType?: string;

  /**
   * Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema RunnerSpecVolumesStorageos#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * SecretRef specifies the secret to use for obtaining the StorageOS API credentials.  If not specified, default values will be attempted.
   *
   * @schema RunnerSpecVolumesStorageos#secretRef
   */
  readonly secretRef?: RunnerSpecVolumesStorageosSecretRef;

  /**
   * VolumeName is the human-readable name of the StorageOS volume.  Volume names are only unique within a namespace.
   *
   * @schema RunnerSpecVolumesStorageos#volumeName
   */
  readonly volumeName?: string;

  /**
   * VolumeNamespace specifies the scope of the volume within StorageOS.  If no namespace is specified then the Pod's namespace will be used.  This allows the Kubernetes name scoping to be mirrored within StorageOS for tighter integration. Set VolumeName to any name to override the default behaviour. Set to "default" if you are not using namespaces within StorageOS. Namespaces that do not pre-exist within StorageOS will be created.
   *
   * @schema RunnerSpecVolumesStorageos#volumeNamespace
   */
  readonly volumeNamespace?: string;

}

/**
 * Converts an object of type 'RunnerSpecVolumesStorageos' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecVolumesStorageos(obj: RunnerSpecVolumesStorageos | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'readOnly': obj.readOnly,
    'secretRef': toJson_RunnerSpecVolumesStorageosSecretRef(obj.secretRef),
    'volumeName': obj.volumeName,
    'volumeNamespace': obj.volumeNamespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
 *
 * @schema RunnerSpecVolumesVsphereVolume
 */
export interface RunnerSpecVolumesVsphereVolume {
  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema RunnerSpecVolumesVsphereVolume#fsType
   */
  readonly fsType?: string;

  /**
   * Storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.
   *
   * @schema RunnerSpecVolumesVsphereVolume#storagePolicyID
   */
  readonly storagePolicyId?: string;

  /**
   * Storage Policy Based Management (SPBM) profile name.
   *
   * @schema RunnerSpecVolumesVsphereVolume#storagePolicyName
   */
  readonly storagePolicyName?: string;

  /**
   * Path that identifies vSphere volume vmdk
   *
   * @schema RunnerSpecVolumesVsphereVolume#volumePath
   */
  readonly volumePath: string;

}

/**
 * Converts an object of type 'RunnerSpecVolumesVsphereVolume' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecVolumesVsphereVolume(obj: RunnerSpecVolumesVsphereVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'storagePolicyID': obj.storagePolicyId,
    'storagePolicyName': obj.storagePolicyName,
    'volumePath': obj.volumePath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * An empty preferred scheduling term matches all objects with implicit weight 0 (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
 *
 * @schema RunnerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface RunnerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * A node selector term, associated with the corresponding weight.
   *
   * @schema RunnerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference: RunnerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
   *
   * @schema RunnerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;

}

/**
 * Converts an object of type 'RunnerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: RunnerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preference': toJson_RunnerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj.preference),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node.
 *
 * @schema RunnerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface RunnerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A list of node selector terms. The terms are ORed.
   *
   * @schema RunnerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms: RunnerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];

}

/**
 * Converts an object of type 'RunnerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: RunnerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeSelectorTerms': obj.nodeSelectorTerms?.map(y => toJson_RunnerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema RunnerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface RunnerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema RunnerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm: RunnerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
   *
   * @schema RunnerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;

}

/**
 * Converts an object of type 'RunnerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: RunnerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podAffinityTerm': toJson_RunnerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running
 *
 * @schema RunnerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface RunnerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   *
   * @schema RunnerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: RunnerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces. This field is beta-level and is only honored when PodAffinityNamespaceSelector feature is enabled.
   *
   * @schema RunnerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: RunnerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means "this pod's namespace"
   *
   * @schema RunnerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
   *
   * @schema RunnerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'RunnerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: RunnerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_RunnerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_RunnerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema RunnerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface RunnerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema RunnerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm: RunnerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
   *
   * @schema RunnerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;

}

/**
 * Converts an object of type 'RunnerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: RunnerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podAffinityTerm': toJson_RunnerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running
 *
 * @schema RunnerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface RunnerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   *
   * @schema RunnerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: RunnerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces. This field is beta-level and is only honored when PodAffinityNamespaceSelector feature is enabled.
   *
   * @schema RunnerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: RunnerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means "this pod's namespace"
   *
   * @schema RunnerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
   *
   * @schema RunnerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'RunnerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: RunnerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_RunnerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_RunnerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema RunnerSpecContainersEnvValueFrom
 */
export interface RunnerSpecContainersEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema RunnerSpecContainersEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: RunnerSpecContainersEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema RunnerSpecContainersEnvValueFrom#fieldRef
   */
  readonly fieldRef?: RunnerSpecContainersEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema RunnerSpecContainersEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: RunnerSpecContainersEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema RunnerSpecContainersEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: RunnerSpecContainersEnvValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'RunnerSpecContainersEnvValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecContainersEnvValueFrom(obj: RunnerSpecContainersEnvValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_RunnerSpecContainersEnvValueFromConfigMapKeyRef(obj.configMapKeyRef),
    'fieldRef': toJson_RunnerSpecContainersEnvValueFromFieldRef(obj.fieldRef),
    'resourceFieldRef': toJson_RunnerSpecContainersEnvValueFromResourceFieldRef(obj.resourceFieldRef),
    'secretKeyRef': toJson_RunnerSpecContainersEnvValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema RunnerSpecContainersEnvFromConfigMapRef
 */
export interface RunnerSpecContainersEnvFromConfigMapRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerSpecContainersEnvFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema RunnerSpecContainersEnvFromConfigMapRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerSpecContainersEnvFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecContainersEnvFromConfigMapRef(obj: RunnerSpecContainersEnvFromConfigMapRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Secret to select from
 *
 * @schema RunnerSpecContainersEnvFromSecretRef
 */
export interface RunnerSpecContainersEnvFromSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerSpecContainersEnvFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema RunnerSpecContainersEnvFromSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerSpecContainersEnvFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecContainersEnvFromSecretRef(obj: RunnerSpecContainersEnvFromSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PostStart is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema RunnerSpecContainersLifecyclePostStart
 */
export interface RunnerSpecContainersLifecyclePostStart {
  /**
   * Exec specifies the action to take.
   *
   * @schema RunnerSpecContainersLifecyclePostStart#exec
   */
  readonly exec?: RunnerSpecContainersLifecyclePostStartExec;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema RunnerSpecContainersLifecyclePostStart#httpGet
   */
  readonly httpGet?: RunnerSpecContainersLifecyclePostStartHttpGet;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
   *
   * @schema RunnerSpecContainersLifecyclePostStart#tcpSocket
   */
  readonly tcpSocket?: RunnerSpecContainersLifecyclePostStartTcpSocket;

}

/**
 * Converts an object of type 'RunnerSpecContainersLifecyclePostStart' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecContainersLifecyclePostStart(obj: RunnerSpecContainersLifecyclePostStart | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_RunnerSpecContainersLifecyclePostStartExec(obj.exec),
    'httpGet': toJson_RunnerSpecContainersLifecyclePostStartHttpGet(obj.httpGet),
    'tcpSocket': toJson_RunnerSpecContainersLifecyclePostStartTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PreStop is called immediately before a container is terminated due to an API request or management event such as liveness/startup probe failure, preemption, resource contention, etc. The handler is not called if the container crashes or exits. The Pod's termination grace period countdown begins before the PreStop hook is executed. Regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period (unless delayed by finalizers). Other management of the container blocks until the hook completes or until the termination grace period is reached. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema RunnerSpecContainersLifecyclePreStop
 */
export interface RunnerSpecContainersLifecyclePreStop {
  /**
   * Exec specifies the action to take.
   *
   * @schema RunnerSpecContainersLifecyclePreStop#exec
   */
  readonly exec?: RunnerSpecContainersLifecyclePreStopExec;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema RunnerSpecContainersLifecyclePreStop#httpGet
   */
  readonly httpGet?: RunnerSpecContainersLifecyclePreStopHttpGet;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
   *
   * @schema RunnerSpecContainersLifecyclePreStop#tcpSocket
   */
  readonly tcpSocket?: RunnerSpecContainersLifecyclePreStopTcpSocket;

}

/**
 * Converts an object of type 'RunnerSpecContainersLifecyclePreStop' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecContainersLifecyclePreStop(obj: RunnerSpecContainersLifecyclePreStop | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_RunnerSpecContainersLifecyclePreStopExec(obj.exec),
    'httpGet': toJson_RunnerSpecContainersLifecyclePreStopHttpGet(obj.httpGet),
    'tcpSocket': toJson_RunnerSpecContainersLifecyclePreStopTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema RunnerSpecContainersLivenessProbeExec
 */
export interface RunnerSpecContainersLivenessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RunnerSpecContainersLivenessProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'RunnerSpecContainersLivenessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecContainersLivenessProbeExec(obj: RunnerSpecContainersLivenessProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
 *
 * @schema RunnerSpecContainersLivenessProbeGrpc
 */
export interface RunnerSpecContainersLivenessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema RunnerSpecContainersLivenessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema RunnerSpecContainersLivenessProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'RunnerSpecContainersLivenessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecContainersLivenessProbeGrpc(obj: RunnerSpecContainersLivenessProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema RunnerSpecContainersLivenessProbeHttpGet
 */
export interface RunnerSpecContainersLivenessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RunnerSpecContainersLivenessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RunnerSpecContainersLivenessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: RunnerSpecContainersLivenessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RunnerSpecContainersLivenessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerSpecContainersLivenessProbeHttpGet#port
   */
  readonly port: RunnerSpecContainersLivenessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RunnerSpecContainersLivenessProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RunnerSpecContainersLivenessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecContainersLivenessProbeHttpGet(obj: RunnerSpecContainersLivenessProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_RunnerSpecContainersLivenessProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema RunnerSpecContainersLivenessProbeTcpSocket
 */
export interface RunnerSpecContainersLivenessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RunnerSpecContainersLivenessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerSpecContainersLivenessProbeTcpSocket#port
   */
  readonly port: RunnerSpecContainersLivenessProbeTcpSocketPort;

}

/**
 * Converts an object of type 'RunnerSpecContainersLivenessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecContainersLivenessProbeTcpSocket(obj: RunnerSpecContainersLivenessProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema RunnerSpecContainersReadinessProbeExec
 */
export interface RunnerSpecContainersReadinessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RunnerSpecContainersReadinessProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'RunnerSpecContainersReadinessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecContainersReadinessProbeExec(obj: RunnerSpecContainersReadinessProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
 *
 * @schema RunnerSpecContainersReadinessProbeGrpc
 */
export interface RunnerSpecContainersReadinessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema RunnerSpecContainersReadinessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema RunnerSpecContainersReadinessProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'RunnerSpecContainersReadinessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecContainersReadinessProbeGrpc(obj: RunnerSpecContainersReadinessProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema RunnerSpecContainersReadinessProbeHttpGet
 */
export interface RunnerSpecContainersReadinessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RunnerSpecContainersReadinessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RunnerSpecContainersReadinessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: RunnerSpecContainersReadinessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RunnerSpecContainersReadinessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerSpecContainersReadinessProbeHttpGet#port
   */
  readonly port: RunnerSpecContainersReadinessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RunnerSpecContainersReadinessProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RunnerSpecContainersReadinessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecContainersReadinessProbeHttpGet(obj: RunnerSpecContainersReadinessProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_RunnerSpecContainersReadinessProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema RunnerSpecContainersReadinessProbeTcpSocket
 */
export interface RunnerSpecContainersReadinessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RunnerSpecContainersReadinessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerSpecContainersReadinessProbeTcpSocket#port
   */
  readonly port: RunnerSpecContainersReadinessProbeTcpSocketPort;

}

/**
 * Converts an object of type 'RunnerSpecContainersReadinessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecContainersReadinessProbeTcpSocket(obj: RunnerSpecContainersReadinessProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RunnerSpecContainersResourcesLimits
 */
export class RunnerSpecContainersResourcesLimits {
  public static fromNumber(value: number): RunnerSpecContainersResourcesLimits {
    return new RunnerSpecContainersResourcesLimits(value);
  }
  public static fromString(value: string): RunnerSpecContainersResourcesLimits {
    return new RunnerSpecContainersResourcesLimits(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * @schema RunnerSpecContainersResourcesRequests
 */
export class RunnerSpecContainersResourcesRequests {
  public static fromNumber(value: number): RunnerSpecContainersResourcesRequests {
    return new RunnerSpecContainersResourcesRequests(value);
  }
  public static fromString(value: string): RunnerSpecContainersResourcesRequests {
    return new RunnerSpecContainersResourcesRequests(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
 *
 * @default the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
 * @schema RunnerSpecContainersSecurityContextCapabilities
 */
export interface RunnerSpecContainersSecurityContextCapabilities {
  /**
   * Added capabilities
   *
   * @schema RunnerSpecContainersSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * Removed capabilities
   *
   * @schema RunnerSpecContainersSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * Converts an object of type 'RunnerSpecContainersSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecContainersSecurityContextCapabilities(obj: RunnerSpecContainersSecurityContextCapabilities | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': obj.add?.map(y => y),
    'drop': obj.drop?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema RunnerSpecContainersSecurityContextSeLinuxOptions
 */
export interface RunnerSpecContainersSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema RunnerSpecContainersSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema RunnerSpecContainersSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema RunnerSpecContainersSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema RunnerSpecContainersSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'RunnerSpecContainersSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecContainersSecurityContextSeLinuxOptions(obj: RunnerSpecContainersSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The seccomp options to use by this container. If seccomp options are provided at both the pod & container level, the container options override the pod options. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema RunnerSpecContainersSecurityContextSeccompProfile
 */
export interface RunnerSpecContainersSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Must be a descending path, relative to the kubelet's configured seccomp profile location. Must only be set if type is "Localhost".
   *
   * @schema RunnerSpecContainersSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied. Valid options are:
   * Localhost - a profile defined in a file on the node should be used. RuntimeDefault - the container runtime default profile should be used. Unconfined - no profile should be applied.
   *
   * @schema RunnerSpecContainersSecurityContextSeccompProfile#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'RunnerSpecContainersSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecContainersSecurityContextSeccompProfile(obj: RunnerSpecContainersSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Windows specific settings applied to all containers. If unspecified, the options from the PodSecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema RunnerSpecContainersSecurityContextWindowsOptions
 */
export interface RunnerSpecContainersSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema RunnerSpecContainersSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema RunnerSpecContainersSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container. This field is alpha-level and will only be honored by components that enable the WindowsHostProcessContainers feature flag. Setting this field without the feature flag will result in errors when validating the Pod. All of a Pod's containers must have the same effective HostProcess value (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).  In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema RunnerSpecContainersSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process. Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * @schema RunnerSpecContainersSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'RunnerSpecContainersSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecContainersSecurityContextWindowsOptions(obj: RunnerSpecContainersSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema RunnerSpecContainersStartupProbeExec
 */
export interface RunnerSpecContainersStartupProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RunnerSpecContainersStartupProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'RunnerSpecContainersStartupProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecContainersStartupProbeExec(obj: RunnerSpecContainersStartupProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
 *
 * @schema RunnerSpecContainersStartupProbeGrpc
 */
export interface RunnerSpecContainersStartupProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema RunnerSpecContainersStartupProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema RunnerSpecContainersStartupProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'RunnerSpecContainersStartupProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecContainersStartupProbeGrpc(obj: RunnerSpecContainersStartupProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema RunnerSpecContainersStartupProbeHttpGet
 */
export interface RunnerSpecContainersStartupProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RunnerSpecContainersStartupProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RunnerSpecContainersStartupProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: RunnerSpecContainersStartupProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RunnerSpecContainersStartupProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerSpecContainersStartupProbeHttpGet#port
   */
  readonly port: RunnerSpecContainersStartupProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RunnerSpecContainersStartupProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RunnerSpecContainersStartupProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecContainersStartupProbeHttpGet(obj: RunnerSpecContainersStartupProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_RunnerSpecContainersStartupProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema RunnerSpecContainersStartupProbeTcpSocket
 */
export interface RunnerSpecContainersStartupProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RunnerSpecContainersStartupProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerSpecContainersStartupProbeTcpSocket#port
   */
  readonly port: RunnerSpecContainersStartupProbeTcpSocketPort;

}

/**
 * Converts an object of type 'RunnerSpecContainersStartupProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecContainersStartupProbeTcpSocket(obj: RunnerSpecContainersStartupProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a ConfigMap.
 *
 * @schema RunnerSpecDockerEnvValueFromConfigMapKeyRef
 */
export interface RunnerSpecDockerEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema RunnerSpecDockerEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerSpecDockerEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema RunnerSpecDockerEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerSpecDockerEnvValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecDockerEnvValueFromConfigMapKeyRef(obj: RunnerSpecDockerEnvValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema RunnerSpecDockerEnvValueFromFieldRef
 */
export interface RunnerSpecDockerEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema RunnerSpecDockerEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema RunnerSpecDockerEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'RunnerSpecDockerEnvValueFromFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecDockerEnvValueFromFieldRef(obj: RunnerSpecDockerEnvValueFromFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema RunnerSpecDockerEnvValueFromResourceFieldRef
 */
export interface RunnerSpecDockerEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema RunnerSpecDockerEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema RunnerSpecDockerEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: RunnerSpecDockerEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema RunnerSpecDockerEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'RunnerSpecDockerEnvValueFromResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecDockerEnvValueFromResourceFieldRef(obj: RunnerSpecDockerEnvValueFromResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema RunnerSpecDockerEnvValueFromSecretKeyRef
 */
export interface RunnerSpecDockerEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema RunnerSpecDockerEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerSpecDockerEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema RunnerSpecDockerEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerSpecDockerEnvValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecDockerEnvValueFromSecretKeyRef(obj: RunnerSpecDockerEnvValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a ConfigMap.
 *
 * @schema RunnerSpecEnvValueFromConfigMapKeyRef
 */
export interface RunnerSpecEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema RunnerSpecEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerSpecEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema RunnerSpecEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerSpecEnvValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecEnvValueFromConfigMapKeyRef(obj: RunnerSpecEnvValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema RunnerSpecEnvValueFromFieldRef
 */
export interface RunnerSpecEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema RunnerSpecEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema RunnerSpecEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'RunnerSpecEnvValueFromFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecEnvValueFromFieldRef(obj: RunnerSpecEnvValueFromFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema RunnerSpecEnvValueFromResourceFieldRef
 */
export interface RunnerSpecEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema RunnerSpecEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema RunnerSpecEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: RunnerSpecEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema RunnerSpecEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'RunnerSpecEnvValueFromResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecEnvValueFromResourceFieldRef(obj: RunnerSpecEnvValueFromResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema RunnerSpecEnvValueFromSecretKeyRef
 */
export interface RunnerSpecEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema RunnerSpecEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerSpecEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema RunnerSpecEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerSpecEnvValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecEnvValueFromSecretKeyRef(obj: RunnerSpecEnvValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema RunnerSpecEphemeralContainersEnvValueFrom
 */
export interface RunnerSpecEphemeralContainersEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema RunnerSpecEphemeralContainersEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: RunnerSpecEphemeralContainersEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema RunnerSpecEphemeralContainersEnvValueFrom#fieldRef
   */
  readonly fieldRef?: RunnerSpecEphemeralContainersEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema RunnerSpecEphemeralContainersEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: RunnerSpecEphemeralContainersEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema RunnerSpecEphemeralContainersEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: RunnerSpecEphemeralContainersEnvValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'RunnerSpecEphemeralContainersEnvValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecEphemeralContainersEnvValueFrom(obj: RunnerSpecEphemeralContainersEnvValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_RunnerSpecEphemeralContainersEnvValueFromConfigMapKeyRef(obj.configMapKeyRef),
    'fieldRef': toJson_RunnerSpecEphemeralContainersEnvValueFromFieldRef(obj.fieldRef),
    'resourceFieldRef': toJson_RunnerSpecEphemeralContainersEnvValueFromResourceFieldRef(obj.resourceFieldRef),
    'secretKeyRef': toJson_RunnerSpecEphemeralContainersEnvValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema RunnerSpecEphemeralContainersEnvFromConfigMapRef
 */
export interface RunnerSpecEphemeralContainersEnvFromConfigMapRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerSpecEphemeralContainersEnvFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema RunnerSpecEphemeralContainersEnvFromConfigMapRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerSpecEphemeralContainersEnvFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecEphemeralContainersEnvFromConfigMapRef(obj: RunnerSpecEphemeralContainersEnvFromConfigMapRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Secret to select from
 *
 * @schema RunnerSpecEphemeralContainersEnvFromSecretRef
 */
export interface RunnerSpecEphemeralContainersEnvFromSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerSpecEphemeralContainersEnvFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema RunnerSpecEphemeralContainersEnvFromSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerSpecEphemeralContainersEnvFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecEphemeralContainersEnvFromSecretRef(obj: RunnerSpecEphemeralContainersEnvFromSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PostStart is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema RunnerSpecEphemeralContainersLifecyclePostStart
 */
export interface RunnerSpecEphemeralContainersLifecyclePostStart {
  /**
   * Exec specifies the action to take.
   *
   * @schema RunnerSpecEphemeralContainersLifecyclePostStart#exec
   */
  readonly exec?: RunnerSpecEphemeralContainersLifecyclePostStartExec;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema RunnerSpecEphemeralContainersLifecyclePostStart#httpGet
   */
  readonly httpGet?: RunnerSpecEphemeralContainersLifecyclePostStartHttpGet;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
   *
   * @schema RunnerSpecEphemeralContainersLifecyclePostStart#tcpSocket
   */
  readonly tcpSocket?: RunnerSpecEphemeralContainersLifecyclePostStartTcpSocket;

}

/**
 * Converts an object of type 'RunnerSpecEphemeralContainersLifecyclePostStart' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecEphemeralContainersLifecyclePostStart(obj: RunnerSpecEphemeralContainersLifecyclePostStart | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_RunnerSpecEphemeralContainersLifecyclePostStartExec(obj.exec),
    'httpGet': toJson_RunnerSpecEphemeralContainersLifecyclePostStartHttpGet(obj.httpGet),
    'tcpSocket': toJson_RunnerSpecEphemeralContainersLifecyclePostStartTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PreStop is called immediately before a container is terminated due to an API request or management event such as liveness/startup probe failure, preemption, resource contention, etc. The handler is not called if the container crashes or exits. The Pod's termination grace period countdown begins before the PreStop hook is executed. Regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period (unless delayed by finalizers). Other management of the container blocks until the hook completes or until the termination grace period is reached. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema RunnerSpecEphemeralContainersLifecyclePreStop
 */
export interface RunnerSpecEphemeralContainersLifecyclePreStop {
  /**
   * Exec specifies the action to take.
   *
   * @schema RunnerSpecEphemeralContainersLifecyclePreStop#exec
   */
  readonly exec?: RunnerSpecEphemeralContainersLifecyclePreStopExec;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema RunnerSpecEphemeralContainersLifecyclePreStop#httpGet
   */
  readonly httpGet?: RunnerSpecEphemeralContainersLifecyclePreStopHttpGet;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
   *
   * @schema RunnerSpecEphemeralContainersLifecyclePreStop#tcpSocket
   */
  readonly tcpSocket?: RunnerSpecEphemeralContainersLifecyclePreStopTcpSocket;

}

/**
 * Converts an object of type 'RunnerSpecEphemeralContainersLifecyclePreStop' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecEphemeralContainersLifecyclePreStop(obj: RunnerSpecEphemeralContainersLifecyclePreStop | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_RunnerSpecEphemeralContainersLifecyclePreStopExec(obj.exec),
    'httpGet': toJson_RunnerSpecEphemeralContainersLifecyclePreStopHttpGet(obj.httpGet),
    'tcpSocket': toJson_RunnerSpecEphemeralContainersLifecyclePreStopTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema RunnerSpecEphemeralContainersLivenessProbeExec
 */
export interface RunnerSpecEphemeralContainersLivenessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RunnerSpecEphemeralContainersLivenessProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'RunnerSpecEphemeralContainersLivenessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecEphemeralContainersLivenessProbeExec(obj: RunnerSpecEphemeralContainersLivenessProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
 *
 * @schema RunnerSpecEphemeralContainersLivenessProbeGrpc
 */
export interface RunnerSpecEphemeralContainersLivenessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema RunnerSpecEphemeralContainersLivenessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema RunnerSpecEphemeralContainersLivenessProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'RunnerSpecEphemeralContainersLivenessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecEphemeralContainersLivenessProbeGrpc(obj: RunnerSpecEphemeralContainersLivenessProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema RunnerSpecEphemeralContainersLivenessProbeHttpGet
 */
export interface RunnerSpecEphemeralContainersLivenessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RunnerSpecEphemeralContainersLivenessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RunnerSpecEphemeralContainersLivenessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: RunnerSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RunnerSpecEphemeralContainersLivenessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerSpecEphemeralContainersLivenessProbeHttpGet#port
   */
  readonly port: RunnerSpecEphemeralContainersLivenessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RunnerSpecEphemeralContainersLivenessProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RunnerSpecEphemeralContainersLivenessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecEphemeralContainersLivenessProbeHttpGet(obj: RunnerSpecEphemeralContainersLivenessProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_RunnerSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema RunnerSpecEphemeralContainersLivenessProbeTcpSocket
 */
export interface RunnerSpecEphemeralContainersLivenessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RunnerSpecEphemeralContainersLivenessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerSpecEphemeralContainersLivenessProbeTcpSocket#port
   */
  readonly port: RunnerSpecEphemeralContainersLivenessProbeTcpSocketPort;

}

/**
 * Converts an object of type 'RunnerSpecEphemeralContainersLivenessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecEphemeralContainersLivenessProbeTcpSocket(obj: RunnerSpecEphemeralContainersLivenessProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema RunnerSpecEphemeralContainersReadinessProbeExec
 */
export interface RunnerSpecEphemeralContainersReadinessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RunnerSpecEphemeralContainersReadinessProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'RunnerSpecEphemeralContainersReadinessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecEphemeralContainersReadinessProbeExec(obj: RunnerSpecEphemeralContainersReadinessProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
 *
 * @schema RunnerSpecEphemeralContainersReadinessProbeGrpc
 */
export interface RunnerSpecEphemeralContainersReadinessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema RunnerSpecEphemeralContainersReadinessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema RunnerSpecEphemeralContainersReadinessProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'RunnerSpecEphemeralContainersReadinessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecEphemeralContainersReadinessProbeGrpc(obj: RunnerSpecEphemeralContainersReadinessProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema RunnerSpecEphemeralContainersReadinessProbeHttpGet
 */
export interface RunnerSpecEphemeralContainersReadinessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RunnerSpecEphemeralContainersReadinessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RunnerSpecEphemeralContainersReadinessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: RunnerSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RunnerSpecEphemeralContainersReadinessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerSpecEphemeralContainersReadinessProbeHttpGet#port
   */
  readonly port: RunnerSpecEphemeralContainersReadinessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RunnerSpecEphemeralContainersReadinessProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RunnerSpecEphemeralContainersReadinessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecEphemeralContainersReadinessProbeHttpGet(obj: RunnerSpecEphemeralContainersReadinessProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_RunnerSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema RunnerSpecEphemeralContainersReadinessProbeTcpSocket
 */
export interface RunnerSpecEphemeralContainersReadinessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RunnerSpecEphemeralContainersReadinessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerSpecEphemeralContainersReadinessProbeTcpSocket#port
   */
  readonly port: RunnerSpecEphemeralContainersReadinessProbeTcpSocketPort;

}

/**
 * Converts an object of type 'RunnerSpecEphemeralContainersReadinessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecEphemeralContainersReadinessProbeTcpSocket(obj: RunnerSpecEphemeralContainersReadinessProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RunnerSpecEphemeralContainersResourcesLimits
 */
export class RunnerSpecEphemeralContainersResourcesLimits {
  public static fromNumber(value: number): RunnerSpecEphemeralContainersResourcesLimits {
    return new RunnerSpecEphemeralContainersResourcesLimits(value);
  }
  public static fromString(value: string): RunnerSpecEphemeralContainersResourcesLimits {
    return new RunnerSpecEphemeralContainersResourcesLimits(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * @schema RunnerSpecEphemeralContainersResourcesRequests
 */
export class RunnerSpecEphemeralContainersResourcesRequests {
  public static fromNumber(value: number): RunnerSpecEphemeralContainersResourcesRequests {
    return new RunnerSpecEphemeralContainersResourcesRequests(value);
  }
  public static fromString(value: string): RunnerSpecEphemeralContainersResourcesRequests {
    return new RunnerSpecEphemeralContainersResourcesRequests(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
 *
 * @default the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
 * @schema RunnerSpecEphemeralContainersSecurityContextCapabilities
 */
export interface RunnerSpecEphemeralContainersSecurityContextCapabilities {
  /**
   * Added capabilities
   *
   * @schema RunnerSpecEphemeralContainersSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * Removed capabilities
   *
   * @schema RunnerSpecEphemeralContainersSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * Converts an object of type 'RunnerSpecEphemeralContainersSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecEphemeralContainersSecurityContextCapabilities(obj: RunnerSpecEphemeralContainersSecurityContextCapabilities | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': obj.add?.map(y => y),
    'drop': obj.drop?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema RunnerSpecEphemeralContainersSecurityContextSeLinuxOptions
 */
export interface RunnerSpecEphemeralContainersSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema RunnerSpecEphemeralContainersSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema RunnerSpecEphemeralContainersSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema RunnerSpecEphemeralContainersSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema RunnerSpecEphemeralContainersSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'RunnerSpecEphemeralContainersSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecEphemeralContainersSecurityContextSeLinuxOptions(obj: RunnerSpecEphemeralContainersSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The seccomp options to use by this container. If seccomp options are provided at both the pod & container level, the container options override the pod options. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema RunnerSpecEphemeralContainersSecurityContextSeccompProfile
 */
export interface RunnerSpecEphemeralContainersSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Must be a descending path, relative to the kubelet's configured seccomp profile location. Must only be set if type is "Localhost".
   *
   * @schema RunnerSpecEphemeralContainersSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied. Valid options are:
   * Localhost - a profile defined in a file on the node should be used. RuntimeDefault - the container runtime default profile should be used. Unconfined - no profile should be applied.
   *
   * @schema RunnerSpecEphemeralContainersSecurityContextSeccompProfile#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'RunnerSpecEphemeralContainersSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecEphemeralContainersSecurityContextSeccompProfile(obj: RunnerSpecEphemeralContainersSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Windows specific settings applied to all containers. If unspecified, the options from the PodSecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema RunnerSpecEphemeralContainersSecurityContextWindowsOptions
 */
export interface RunnerSpecEphemeralContainersSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema RunnerSpecEphemeralContainersSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema RunnerSpecEphemeralContainersSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container. This field is alpha-level and will only be honored by components that enable the WindowsHostProcessContainers feature flag. Setting this field without the feature flag will result in errors when validating the Pod. All of a Pod's containers must have the same effective HostProcess value (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).  In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema RunnerSpecEphemeralContainersSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process. Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * @schema RunnerSpecEphemeralContainersSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'RunnerSpecEphemeralContainersSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecEphemeralContainersSecurityContextWindowsOptions(obj: RunnerSpecEphemeralContainersSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema RunnerSpecEphemeralContainersStartupProbeExec
 */
export interface RunnerSpecEphemeralContainersStartupProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RunnerSpecEphemeralContainersStartupProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'RunnerSpecEphemeralContainersStartupProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecEphemeralContainersStartupProbeExec(obj: RunnerSpecEphemeralContainersStartupProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
 *
 * @schema RunnerSpecEphemeralContainersStartupProbeGrpc
 */
export interface RunnerSpecEphemeralContainersStartupProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema RunnerSpecEphemeralContainersStartupProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema RunnerSpecEphemeralContainersStartupProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'RunnerSpecEphemeralContainersStartupProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecEphemeralContainersStartupProbeGrpc(obj: RunnerSpecEphemeralContainersStartupProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema RunnerSpecEphemeralContainersStartupProbeHttpGet
 */
export interface RunnerSpecEphemeralContainersStartupProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RunnerSpecEphemeralContainersStartupProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RunnerSpecEphemeralContainersStartupProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: RunnerSpecEphemeralContainersStartupProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RunnerSpecEphemeralContainersStartupProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerSpecEphemeralContainersStartupProbeHttpGet#port
   */
  readonly port: RunnerSpecEphemeralContainersStartupProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RunnerSpecEphemeralContainersStartupProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RunnerSpecEphemeralContainersStartupProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecEphemeralContainersStartupProbeHttpGet(obj: RunnerSpecEphemeralContainersStartupProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_RunnerSpecEphemeralContainersStartupProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema RunnerSpecEphemeralContainersStartupProbeTcpSocket
 */
export interface RunnerSpecEphemeralContainersStartupProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RunnerSpecEphemeralContainersStartupProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerSpecEphemeralContainersStartupProbeTcpSocket#port
   */
  readonly port: RunnerSpecEphemeralContainersStartupProbeTcpSocketPort;

}

/**
 * Converts an object of type 'RunnerSpecEphemeralContainersStartupProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecEphemeralContainersStartupProbeTcpSocket(obj: RunnerSpecEphemeralContainersStartupProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema RunnerSpecInitContainersEnvValueFrom
 */
export interface RunnerSpecInitContainersEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema RunnerSpecInitContainersEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: RunnerSpecInitContainersEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema RunnerSpecInitContainersEnvValueFrom#fieldRef
   */
  readonly fieldRef?: RunnerSpecInitContainersEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema RunnerSpecInitContainersEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: RunnerSpecInitContainersEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema RunnerSpecInitContainersEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: RunnerSpecInitContainersEnvValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'RunnerSpecInitContainersEnvValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecInitContainersEnvValueFrom(obj: RunnerSpecInitContainersEnvValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_RunnerSpecInitContainersEnvValueFromConfigMapKeyRef(obj.configMapKeyRef),
    'fieldRef': toJson_RunnerSpecInitContainersEnvValueFromFieldRef(obj.fieldRef),
    'resourceFieldRef': toJson_RunnerSpecInitContainersEnvValueFromResourceFieldRef(obj.resourceFieldRef),
    'secretKeyRef': toJson_RunnerSpecInitContainersEnvValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema RunnerSpecInitContainersEnvFromConfigMapRef
 */
export interface RunnerSpecInitContainersEnvFromConfigMapRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerSpecInitContainersEnvFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema RunnerSpecInitContainersEnvFromConfigMapRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerSpecInitContainersEnvFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecInitContainersEnvFromConfigMapRef(obj: RunnerSpecInitContainersEnvFromConfigMapRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Secret to select from
 *
 * @schema RunnerSpecInitContainersEnvFromSecretRef
 */
export interface RunnerSpecInitContainersEnvFromSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerSpecInitContainersEnvFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema RunnerSpecInitContainersEnvFromSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerSpecInitContainersEnvFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecInitContainersEnvFromSecretRef(obj: RunnerSpecInitContainersEnvFromSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PostStart is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema RunnerSpecInitContainersLifecyclePostStart
 */
export interface RunnerSpecInitContainersLifecyclePostStart {
  /**
   * Exec specifies the action to take.
   *
   * @schema RunnerSpecInitContainersLifecyclePostStart#exec
   */
  readonly exec?: RunnerSpecInitContainersLifecyclePostStartExec;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema RunnerSpecInitContainersLifecyclePostStart#httpGet
   */
  readonly httpGet?: RunnerSpecInitContainersLifecyclePostStartHttpGet;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
   *
   * @schema RunnerSpecInitContainersLifecyclePostStart#tcpSocket
   */
  readonly tcpSocket?: RunnerSpecInitContainersLifecyclePostStartTcpSocket;

}

/**
 * Converts an object of type 'RunnerSpecInitContainersLifecyclePostStart' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecInitContainersLifecyclePostStart(obj: RunnerSpecInitContainersLifecyclePostStart | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_RunnerSpecInitContainersLifecyclePostStartExec(obj.exec),
    'httpGet': toJson_RunnerSpecInitContainersLifecyclePostStartHttpGet(obj.httpGet),
    'tcpSocket': toJson_RunnerSpecInitContainersLifecyclePostStartTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PreStop is called immediately before a container is terminated due to an API request or management event such as liveness/startup probe failure, preemption, resource contention, etc. The handler is not called if the container crashes or exits. The Pod's termination grace period countdown begins before the PreStop hook is executed. Regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period (unless delayed by finalizers). Other management of the container blocks until the hook completes or until the termination grace period is reached. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema RunnerSpecInitContainersLifecyclePreStop
 */
export interface RunnerSpecInitContainersLifecyclePreStop {
  /**
   * Exec specifies the action to take.
   *
   * @schema RunnerSpecInitContainersLifecyclePreStop#exec
   */
  readonly exec?: RunnerSpecInitContainersLifecyclePreStopExec;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema RunnerSpecInitContainersLifecyclePreStop#httpGet
   */
  readonly httpGet?: RunnerSpecInitContainersLifecyclePreStopHttpGet;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
   *
   * @schema RunnerSpecInitContainersLifecyclePreStop#tcpSocket
   */
  readonly tcpSocket?: RunnerSpecInitContainersLifecyclePreStopTcpSocket;

}

/**
 * Converts an object of type 'RunnerSpecInitContainersLifecyclePreStop' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecInitContainersLifecyclePreStop(obj: RunnerSpecInitContainersLifecyclePreStop | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_RunnerSpecInitContainersLifecyclePreStopExec(obj.exec),
    'httpGet': toJson_RunnerSpecInitContainersLifecyclePreStopHttpGet(obj.httpGet),
    'tcpSocket': toJson_RunnerSpecInitContainersLifecyclePreStopTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema RunnerSpecInitContainersLivenessProbeExec
 */
export interface RunnerSpecInitContainersLivenessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RunnerSpecInitContainersLivenessProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'RunnerSpecInitContainersLivenessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecInitContainersLivenessProbeExec(obj: RunnerSpecInitContainersLivenessProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
 *
 * @schema RunnerSpecInitContainersLivenessProbeGrpc
 */
export interface RunnerSpecInitContainersLivenessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema RunnerSpecInitContainersLivenessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema RunnerSpecInitContainersLivenessProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'RunnerSpecInitContainersLivenessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecInitContainersLivenessProbeGrpc(obj: RunnerSpecInitContainersLivenessProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema RunnerSpecInitContainersLivenessProbeHttpGet
 */
export interface RunnerSpecInitContainersLivenessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RunnerSpecInitContainersLivenessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RunnerSpecInitContainersLivenessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: RunnerSpecInitContainersLivenessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RunnerSpecInitContainersLivenessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerSpecInitContainersLivenessProbeHttpGet#port
   */
  readonly port: RunnerSpecInitContainersLivenessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RunnerSpecInitContainersLivenessProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RunnerSpecInitContainersLivenessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecInitContainersLivenessProbeHttpGet(obj: RunnerSpecInitContainersLivenessProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_RunnerSpecInitContainersLivenessProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema RunnerSpecInitContainersLivenessProbeTcpSocket
 */
export interface RunnerSpecInitContainersLivenessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RunnerSpecInitContainersLivenessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerSpecInitContainersLivenessProbeTcpSocket#port
   */
  readonly port: RunnerSpecInitContainersLivenessProbeTcpSocketPort;

}

/**
 * Converts an object of type 'RunnerSpecInitContainersLivenessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecInitContainersLivenessProbeTcpSocket(obj: RunnerSpecInitContainersLivenessProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema RunnerSpecInitContainersReadinessProbeExec
 */
export interface RunnerSpecInitContainersReadinessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RunnerSpecInitContainersReadinessProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'RunnerSpecInitContainersReadinessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecInitContainersReadinessProbeExec(obj: RunnerSpecInitContainersReadinessProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
 *
 * @schema RunnerSpecInitContainersReadinessProbeGrpc
 */
export interface RunnerSpecInitContainersReadinessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema RunnerSpecInitContainersReadinessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema RunnerSpecInitContainersReadinessProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'RunnerSpecInitContainersReadinessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecInitContainersReadinessProbeGrpc(obj: RunnerSpecInitContainersReadinessProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema RunnerSpecInitContainersReadinessProbeHttpGet
 */
export interface RunnerSpecInitContainersReadinessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RunnerSpecInitContainersReadinessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RunnerSpecInitContainersReadinessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: RunnerSpecInitContainersReadinessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RunnerSpecInitContainersReadinessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerSpecInitContainersReadinessProbeHttpGet#port
   */
  readonly port: RunnerSpecInitContainersReadinessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RunnerSpecInitContainersReadinessProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RunnerSpecInitContainersReadinessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecInitContainersReadinessProbeHttpGet(obj: RunnerSpecInitContainersReadinessProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_RunnerSpecInitContainersReadinessProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema RunnerSpecInitContainersReadinessProbeTcpSocket
 */
export interface RunnerSpecInitContainersReadinessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RunnerSpecInitContainersReadinessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerSpecInitContainersReadinessProbeTcpSocket#port
   */
  readonly port: RunnerSpecInitContainersReadinessProbeTcpSocketPort;

}

/**
 * Converts an object of type 'RunnerSpecInitContainersReadinessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecInitContainersReadinessProbeTcpSocket(obj: RunnerSpecInitContainersReadinessProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RunnerSpecInitContainersResourcesLimits
 */
export class RunnerSpecInitContainersResourcesLimits {
  public static fromNumber(value: number): RunnerSpecInitContainersResourcesLimits {
    return new RunnerSpecInitContainersResourcesLimits(value);
  }
  public static fromString(value: string): RunnerSpecInitContainersResourcesLimits {
    return new RunnerSpecInitContainersResourcesLimits(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * @schema RunnerSpecInitContainersResourcesRequests
 */
export class RunnerSpecInitContainersResourcesRequests {
  public static fromNumber(value: number): RunnerSpecInitContainersResourcesRequests {
    return new RunnerSpecInitContainersResourcesRequests(value);
  }
  public static fromString(value: string): RunnerSpecInitContainersResourcesRequests {
    return new RunnerSpecInitContainersResourcesRequests(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
 *
 * @default the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
 * @schema RunnerSpecInitContainersSecurityContextCapabilities
 */
export interface RunnerSpecInitContainersSecurityContextCapabilities {
  /**
   * Added capabilities
   *
   * @schema RunnerSpecInitContainersSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * Removed capabilities
   *
   * @schema RunnerSpecInitContainersSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * Converts an object of type 'RunnerSpecInitContainersSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecInitContainersSecurityContextCapabilities(obj: RunnerSpecInitContainersSecurityContextCapabilities | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': obj.add?.map(y => y),
    'drop': obj.drop?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema RunnerSpecInitContainersSecurityContextSeLinuxOptions
 */
export interface RunnerSpecInitContainersSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema RunnerSpecInitContainersSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema RunnerSpecInitContainersSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema RunnerSpecInitContainersSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema RunnerSpecInitContainersSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'RunnerSpecInitContainersSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecInitContainersSecurityContextSeLinuxOptions(obj: RunnerSpecInitContainersSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The seccomp options to use by this container. If seccomp options are provided at both the pod & container level, the container options override the pod options. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema RunnerSpecInitContainersSecurityContextSeccompProfile
 */
export interface RunnerSpecInitContainersSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Must be a descending path, relative to the kubelet's configured seccomp profile location. Must only be set if type is "Localhost".
   *
   * @schema RunnerSpecInitContainersSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied. Valid options are:
   * Localhost - a profile defined in a file on the node should be used. RuntimeDefault - the container runtime default profile should be used. Unconfined - no profile should be applied.
   *
   * @schema RunnerSpecInitContainersSecurityContextSeccompProfile#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'RunnerSpecInitContainersSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecInitContainersSecurityContextSeccompProfile(obj: RunnerSpecInitContainersSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Windows specific settings applied to all containers. If unspecified, the options from the PodSecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema RunnerSpecInitContainersSecurityContextWindowsOptions
 */
export interface RunnerSpecInitContainersSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema RunnerSpecInitContainersSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema RunnerSpecInitContainersSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container. This field is alpha-level and will only be honored by components that enable the WindowsHostProcessContainers feature flag. Setting this field without the feature flag will result in errors when validating the Pod. All of a Pod's containers must have the same effective HostProcess value (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).  In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema RunnerSpecInitContainersSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process. Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * @schema RunnerSpecInitContainersSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'RunnerSpecInitContainersSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecInitContainersSecurityContextWindowsOptions(obj: RunnerSpecInitContainersSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema RunnerSpecInitContainersStartupProbeExec
 */
export interface RunnerSpecInitContainersStartupProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RunnerSpecInitContainersStartupProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'RunnerSpecInitContainersStartupProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecInitContainersStartupProbeExec(obj: RunnerSpecInitContainersStartupProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
 *
 * @schema RunnerSpecInitContainersStartupProbeGrpc
 */
export interface RunnerSpecInitContainersStartupProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema RunnerSpecInitContainersStartupProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema RunnerSpecInitContainersStartupProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'RunnerSpecInitContainersStartupProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecInitContainersStartupProbeGrpc(obj: RunnerSpecInitContainersStartupProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema RunnerSpecInitContainersStartupProbeHttpGet
 */
export interface RunnerSpecInitContainersStartupProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RunnerSpecInitContainersStartupProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RunnerSpecInitContainersStartupProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: RunnerSpecInitContainersStartupProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RunnerSpecInitContainersStartupProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerSpecInitContainersStartupProbeHttpGet#port
   */
  readonly port: RunnerSpecInitContainersStartupProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RunnerSpecInitContainersStartupProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RunnerSpecInitContainersStartupProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecInitContainersStartupProbeHttpGet(obj: RunnerSpecInitContainersStartupProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_RunnerSpecInitContainersStartupProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema RunnerSpecInitContainersStartupProbeTcpSocket
 */
export interface RunnerSpecInitContainersStartupProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RunnerSpecInitContainersStartupProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerSpecInitContainersStartupProbeTcpSocket#port
   */
  readonly port: RunnerSpecInitContainersStartupProbeTcpSocketPort;

}

/**
 * Converts an object of type 'RunnerSpecInitContainersStartupProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecInitContainersStartupProbeTcpSocket(obj: RunnerSpecInitContainersStartupProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema RunnerSpecSidecarContainersEnvValueFrom
 */
export interface RunnerSpecSidecarContainersEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema RunnerSpecSidecarContainersEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: RunnerSpecSidecarContainersEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema RunnerSpecSidecarContainersEnvValueFrom#fieldRef
   */
  readonly fieldRef?: RunnerSpecSidecarContainersEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema RunnerSpecSidecarContainersEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: RunnerSpecSidecarContainersEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema RunnerSpecSidecarContainersEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: RunnerSpecSidecarContainersEnvValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'RunnerSpecSidecarContainersEnvValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecSidecarContainersEnvValueFrom(obj: RunnerSpecSidecarContainersEnvValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_RunnerSpecSidecarContainersEnvValueFromConfigMapKeyRef(obj.configMapKeyRef),
    'fieldRef': toJson_RunnerSpecSidecarContainersEnvValueFromFieldRef(obj.fieldRef),
    'resourceFieldRef': toJson_RunnerSpecSidecarContainersEnvValueFromResourceFieldRef(obj.resourceFieldRef),
    'secretKeyRef': toJson_RunnerSpecSidecarContainersEnvValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema RunnerSpecSidecarContainersEnvFromConfigMapRef
 */
export interface RunnerSpecSidecarContainersEnvFromConfigMapRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerSpecSidecarContainersEnvFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema RunnerSpecSidecarContainersEnvFromConfigMapRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerSpecSidecarContainersEnvFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecSidecarContainersEnvFromConfigMapRef(obj: RunnerSpecSidecarContainersEnvFromConfigMapRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Secret to select from
 *
 * @schema RunnerSpecSidecarContainersEnvFromSecretRef
 */
export interface RunnerSpecSidecarContainersEnvFromSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerSpecSidecarContainersEnvFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema RunnerSpecSidecarContainersEnvFromSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerSpecSidecarContainersEnvFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecSidecarContainersEnvFromSecretRef(obj: RunnerSpecSidecarContainersEnvFromSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PostStart is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema RunnerSpecSidecarContainersLifecyclePostStart
 */
export interface RunnerSpecSidecarContainersLifecyclePostStart {
  /**
   * Exec specifies the action to take.
   *
   * @schema RunnerSpecSidecarContainersLifecyclePostStart#exec
   */
  readonly exec?: RunnerSpecSidecarContainersLifecyclePostStartExec;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema RunnerSpecSidecarContainersLifecyclePostStart#httpGet
   */
  readonly httpGet?: RunnerSpecSidecarContainersLifecyclePostStartHttpGet;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
   *
   * @schema RunnerSpecSidecarContainersLifecyclePostStart#tcpSocket
   */
  readonly tcpSocket?: RunnerSpecSidecarContainersLifecyclePostStartTcpSocket;

}

/**
 * Converts an object of type 'RunnerSpecSidecarContainersLifecyclePostStart' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecSidecarContainersLifecyclePostStart(obj: RunnerSpecSidecarContainersLifecyclePostStart | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_RunnerSpecSidecarContainersLifecyclePostStartExec(obj.exec),
    'httpGet': toJson_RunnerSpecSidecarContainersLifecyclePostStartHttpGet(obj.httpGet),
    'tcpSocket': toJson_RunnerSpecSidecarContainersLifecyclePostStartTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PreStop is called immediately before a container is terminated due to an API request or management event such as liveness/startup probe failure, preemption, resource contention, etc. The handler is not called if the container crashes or exits. The Pod's termination grace period countdown begins before the PreStop hook is executed. Regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period (unless delayed by finalizers). Other management of the container blocks until the hook completes or until the termination grace period is reached. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema RunnerSpecSidecarContainersLifecyclePreStop
 */
export interface RunnerSpecSidecarContainersLifecyclePreStop {
  /**
   * Exec specifies the action to take.
   *
   * @schema RunnerSpecSidecarContainersLifecyclePreStop#exec
   */
  readonly exec?: RunnerSpecSidecarContainersLifecyclePreStopExec;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema RunnerSpecSidecarContainersLifecyclePreStop#httpGet
   */
  readonly httpGet?: RunnerSpecSidecarContainersLifecyclePreStopHttpGet;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
   *
   * @schema RunnerSpecSidecarContainersLifecyclePreStop#tcpSocket
   */
  readonly tcpSocket?: RunnerSpecSidecarContainersLifecyclePreStopTcpSocket;

}

/**
 * Converts an object of type 'RunnerSpecSidecarContainersLifecyclePreStop' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecSidecarContainersLifecyclePreStop(obj: RunnerSpecSidecarContainersLifecyclePreStop | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_RunnerSpecSidecarContainersLifecyclePreStopExec(obj.exec),
    'httpGet': toJson_RunnerSpecSidecarContainersLifecyclePreStopHttpGet(obj.httpGet),
    'tcpSocket': toJson_RunnerSpecSidecarContainersLifecyclePreStopTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema RunnerSpecSidecarContainersLivenessProbeExec
 */
export interface RunnerSpecSidecarContainersLivenessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RunnerSpecSidecarContainersLivenessProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'RunnerSpecSidecarContainersLivenessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecSidecarContainersLivenessProbeExec(obj: RunnerSpecSidecarContainersLivenessProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
 *
 * @schema RunnerSpecSidecarContainersLivenessProbeGrpc
 */
export interface RunnerSpecSidecarContainersLivenessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema RunnerSpecSidecarContainersLivenessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema RunnerSpecSidecarContainersLivenessProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'RunnerSpecSidecarContainersLivenessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecSidecarContainersLivenessProbeGrpc(obj: RunnerSpecSidecarContainersLivenessProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema RunnerSpecSidecarContainersLivenessProbeHttpGet
 */
export interface RunnerSpecSidecarContainersLivenessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RunnerSpecSidecarContainersLivenessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RunnerSpecSidecarContainersLivenessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: RunnerSpecSidecarContainersLivenessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RunnerSpecSidecarContainersLivenessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerSpecSidecarContainersLivenessProbeHttpGet#port
   */
  readonly port: RunnerSpecSidecarContainersLivenessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RunnerSpecSidecarContainersLivenessProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RunnerSpecSidecarContainersLivenessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecSidecarContainersLivenessProbeHttpGet(obj: RunnerSpecSidecarContainersLivenessProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_RunnerSpecSidecarContainersLivenessProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema RunnerSpecSidecarContainersLivenessProbeTcpSocket
 */
export interface RunnerSpecSidecarContainersLivenessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RunnerSpecSidecarContainersLivenessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerSpecSidecarContainersLivenessProbeTcpSocket#port
   */
  readonly port: RunnerSpecSidecarContainersLivenessProbeTcpSocketPort;

}

/**
 * Converts an object of type 'RunnerSpecSidecarContainersLivenessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecSidecarContainersLivenessProbeTcpSocket(obj: RunnerSpecSidecarContainersLivenessProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema RunnerSpecSidecarContainersReadinessProbeExec
 */
export interface RunnerSpecSidecarContainersReadinessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RunnerSpecSidecarContainersReadinessProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'RunnerSpecSidecarContainersReadinessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecSidecarContainersReadinessProbeExec(obj: RunnerSpecSidecarContainersReadinessProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
 *
 * @schema RunnerSpecSidecarContainersReadinessProbeGrpc
 */
export interface RunnerSpecSidecarContainersReadinessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema RunnerSpecSidecarContainersReadinessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema RunnerSpecSidecarContainersReadinessProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'RunnerSpecSidecarContainersReadinessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecSidecarContainersReadinessProbeGrpc(obj: RunnerSpecSidecarContainersReadinessProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema RunnerSpecSidecarContainersReadinessProbeHttpGet
 */
export interface RunnerSpecSidecarContainersReadinessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RunnerSpecSidecarContainersReadinessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RunnerSpecSidecarContainersReadinessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: RunnerSpecSidecarContainersReadinessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RunnerSpecSidecarContainersReadinessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerSpecSidecarContainersReadinessProbeHttpGet#port
   */
  readonly port: RunnerSpecSidecarContainersReadinessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RunnerSpecSidecarContainersReadinessProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RunnerSpecSidecarContainersReadinessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecSidecarContainersReadinessProbeHttpGet(obj: RunnerSpecSidecarContainersReadinessProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_RunnerSpecSidecarContainersReadinessProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema RunnerSpecSidecarContainersReadinessProbeTcpSocket
 */
export interface RunnerSpecSidecarContainersReadinessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RunnerSpecSidecarContainersReadinessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerSpecSidecarContainersReadinessProbeTcpSocket#port
   */
  readonly port: RunnerSpecSidecarContainersReadinessProbeTcpSocketPort;

}

/**
 * Converts an object of type 'RunnerSpecSidecarContainersReadinessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecSidecarContainersReadinessProbeTcpSocket(obj: RunnerSpecSidecarContainersReadinessProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RunnerSpecSidecarContainersResourcesLimits
 */
export class RunnerSpecSidecarContainersResourcesLimits {
  public static fromNumber(value: number): RunnerSpecSidecarContainersResourcesLimits {
    return new RunnerSpecSidecarContainersResourcesLimits(value);
  }
  public static fromString(value: string): RunnerSpecSidecarContainersResourcesLimits {
    return new RunnerSpecSidecarContainersResourcesLimits(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * @schema RunnerSpecSidecarContainersResourcesRequests
 */
export class RunnerSpecSidecarContainersResourcesRequests {
  public static fromNumber(value: number): RunnerSpecSidecarContainersResourcesRequests {
    return new RunnerSpecSidecarContainersResourcesRequests(value);
  }
  public static fromString(value: string): RunnerSpecSidecarContainersResourcesRequests {
    return new RunnerSpecSidecarContainersResourcesRequests(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
 *
 * @default the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
 * @schema RunnerSpecSidecarContainersSecurityContextCapabilities
 */
export interface RunnerSpecSidecarContainersSecurityContextCapabilities {
  /**
   * Added capabilities
   *
   * @schema RunnerSpecSidecarContainersSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * Removed capabilities
   *
   * @schema RunnerSpecSidecarContainersSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * Converts an object of type 'RunnerSpecSidecarContainersSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecSidecarContainersSecurityContextCapabilities(obj: RunnerSpecSidecarContainersSecurityContextCapabilities | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': obj.add?.map(y => y),
    'drop': obj.drop?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema RunnerSpecSidecarContainersSecurityContextSeLinuxOptions
 */
export interface RunnerSpecSidecarContainersSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema RunnerSpecSidecarContainersSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema RunnerSpecSidecarContainersSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema RunnerSpecSidecarContainersSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema RunnerSpecSidecarContainersSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'RunnerSpecSidecarContainersSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecSidecarContainersSecurityContextSeLinuxOptions(obj: RunnerSpecSidecarContainersSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The seccomp options to use by this container. If seccomp options are provided at both the pod & container level, the container options override the pod options. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema RunnerSpecSidecarContainersSecurityContextSeccompProfile
 */
export interface RunnerSpecSidecarContainersSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Must be a descending path, relative to the kubelet's configured seccomp profile location. Must only be set if type is "Localhost".
   *
   * @schema RunnerSpecSidecarContainersSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied. Valid options are:
   * Localhost - a profile defined in a file on the node should be used. RuntimeDefault - the container runtime default profile should be used. Unconfined - no profile should be applied.
   *
   * @schema RunnerSpecSidecarContainersSecurityContextSeccompProfile#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'RunnerSpecSidecarContainersSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecSidecarContainersSecurityContextSeccompProfile(obj: RunnerSpecSidecarContainersSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Windows specific settings applied to all containers. If unspecified, the options from the PodSecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema RunnerSpecSidecarContainersSecurityContextWindowsOptions
 */
export interface RunnerSpecSidecarContainersSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema RunnerSpecSidecarContainersSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema RunnerSpecSidecarContainersSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container. This field is alpha-level and will only be honored by components that enable the WindowsHostProcessContainers feature flag. Setting this field without the feature flag will result in errors when validating the Pod. All of a Pod's containers must have the same effective HostProcess value (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).  In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema RunnerSpecSidecarContainersSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process. Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * @schema RunnerSpecSidecarContainersSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'RunnerSpecSidecarContainersSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecSidecarContainersSecurityContextWindowsOptions(obj: RunnerSpecSidecarContainersSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema RunnerSpecSidecarContainersStartupProbeExec
 */
export interface RunnerSpecSidecarContainersStartupProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RunnerSpecSidecarContainersStartupProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'RunnerSpecSidecarContainersStartupProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecSidecarContainersStartupProbeExec(obj: RunnerSpecSidecarContainersStartupProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
 *
 * @schema RunnerSpecSidecarContainersStartupProbeGrpc
 */
export interface RunnerSpecSidecarContainersStartupProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema RunnerSpecSidecarContainersStartupProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema RunnerSpecSidecarContainersStartupProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'RunnerSpecSidecarContainersStartupProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecSidecarContainersStartupProbeGrpc(obj: RunnerSpecSidecarContainersStartupProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema RunnerSpecSidecarContainersStartupProbeHttpGet
 */
export interface RunnerSpecSidecarContainersStartupProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RunnerSpecSidecarContainersStartupProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RunnerSpecSidecarContainersStartupProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: RunnerSpecSidecarContainersStartupProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RunnerSpecSidecarContainersStartupProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerSpecSidecarContainersStartupProbeHttpGet#port
   */
  readonly port: RunnerSpecSidecarContainersStartupProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RunnerSpecSidecarContainersStartupProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RunnerSpecSidecarContainersStartupProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecSidecarContainersStartupProbeHttpGet(obj: RunnerSpecSidecarContainersStartupProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_RunnerSpecSidecarContainersStartupProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema RunnerSpecSidecarContainersStartupProbeTcpSocket
 */
export interface RunnerSpecSidecarContainersStartupProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RunnerSpecSidecarContainersStartupProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerSpecSidecarContainersStartupProbeTcpSocket#port
   */
  readonly port: RunnerSpecSidecarContainersStartupProbeTcpSocketPort;

}

/**
 * Converts an object of type 'RunnerSpecSidecarContainersStartupProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecSidecarContainersStartupProbeTcpSocket(obj: RunnerSpecSidecarContainersStartupProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema RunnerSpecTopologySpreadConstraintLabelSelectorMatchExpressions
 */
export interface RunnerSpecTopologySpreadConstraintLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema RunnerSpecTopologySpreadConstraintLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema RunnerSpecTopologySpreadConstraintLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema RunnerSpecTopologySpreadConstraintLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'RunnerSpecTopologySpreadConstraintLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecTopologySpreadConstraintLabelSelectorMatchExpressions(obj: RunnerSpecTopologySpreadConstraintLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Optional: SecretRef is reference to the authentication secret for User, default is empty. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
 *
 * @schema RunnerSpecVolumesCephfsSecretRef
 */
export interface RunnerSpecVolumesCephfsSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerSpecVolumesCephfsSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'RunnerSpecVolumesCephfsSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecVolumesCephfsSecretRef(obj: RunnerSpecVolumesCephfsSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Optional: points to a secret object containing parameters used to connect to OpenStack.
 *
 * @schema RunnerSpecVolumesCinderSecretRef
 */
export interface RunnerSpecVolumesCinderSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerSpecVolumesCinderSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'RunnerSpecVolumesCinderSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecVolumesCinderSecretRef(obj: RunnerSpecVolumesCinderSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema RunnerSpecVolumesConfigMapItems
 */
export interface RunnerSpecVolumesConfigMapItems {
  /**
   * The key to project.
   *
   * @schema RunnerSpecVolumesConfigMapItems#key
   */
  readonly key: string;

  /**
   * Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema RunnerSpecVolumesConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema RunnerSpecVolumesConfigMapItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'RunnerSpecVolumesConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecVolumesConfigMapItems(obj: RunnerSpecVolumesConfigMapItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NodePublishSecretRef is a reference to the secret object containing sensitive information to pass to the CSI driver to complete the CSI NodePublishVolume and NodeUnpublishVolume calls. This field is optional, and  may be empty if no secret is required. If the secret object contains more than one secret, all secret references are passed.
 *
 * @schema RunnerSpecVolumesCsiNodePublishSecretRef
 */
export interface RunnerSpecVolumesCsiNodePublishSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerSpecVolumesCsiNodePublishSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'RunnerSpecVolumesCsiNodePublishSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecVolumesCsiNodePublishSecretRef(obj: RunnerSpecVolumesCsiNodePublishSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DownwardAPIVolumeFile represents information to create the file containing the pod field
 *
 * @schema RunnerSpecVolumesDownwardApiItems
 */
export interface RunnerSpecVolumesDownwardApiItems {
  /**
   * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
   *
   * @schema RunnerSpecVolumesDownwardApiItems#fieldRef
   */
  readonly fieldRef?: RunnerSpecVolumesDownwardApiItemsFieldRef;

  /**
   * Optional: mode bits used to set permissions on this file, must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema RunnerSpecVolumesDownwardApiItems#mode
   */
  readonly mode?: number;

  /**
   * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
   *
   * @schema RunnerSpecVolumesDownwardApiItems#path
   */
  readonly path: string;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
   *
   * @schema RunnerSpecVolumesDownwardApiItems#resourceFieldRef
   */
  readonly resourceFieldRef?: RunnerSpecVolumesDownwardApiItemsResourceFieldRef;

}

/**
 * Converts an object of type 'RunnerSpecVolumesDownwardApiItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecVolumesDownwardApiItems(obj: RunnerSpecVolumesDownwardApiItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fieldRef': toJson_RunnerSpecVolumesDownwardApiItemsFieldRef(obj.fieldRef),
    'mode': obj.mode,
    'path': obj.path,
    'resourceFieldRef': toJson_RunnerSpecVolumesDownwardApiItemsResourceFieldRef(obj.resourceFieldRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. The default is nil which means that the limit is undefined. More info: http://kubernetes.io/docs/user-guide/volumes#emptydir
 *
 * @schema RunnerSpecVolumesEmptyDirSizeLimit
 */
export class RunnerSpecVolumesEmptyDirSizeLimit {
  public static fromNumber(value: number): RunnerSpecVolumesEmptyDirSizeLimit {
    return new RunnerSpecVolumesEmptyDirSizeLimit(value);
  }
  public static fromString(value: string): RunnerSpecVolumesEmptyDirSizeLimit {
    return new RunnerSpecVolumesEmptyDirSizeLimit(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Will be used to create a stand-alone PVC to provision the volume. The pod in which this EphemeralVolumeSource is embedded will be the owner of the PVC, i.e. the PVC will be deleted together with the pod.  The name of the PVC will be `<pod name>-<volume name>` where `<volume name>` is the name from the `PodSpec.Volumes` array entry. Pod validation will reject the pod if the concatenated name is not valid for a PVC (for example, too long).
 * An existing PVC with that name that is not owned by the pod will *not* be used for the pod to avoid using an unrelated volume by mistake. Starting the pod is then blocked until the unrelated PVC is removed. If such a pre-created PVC is meant to be used by the pod, the PVC has to updated with an owner reference to the pod once the pod exists. Normally this should not be necessary, but it may be useful when manually reconstructing a broken cluster.
 * This field is read-only and no changes will be made by Kubernetes to the PVC after it has been created.
 * Required, must not be nil.
 *
 * @schema RunnerSpecVolumesEphemeralVolumeClaimTemplate
 */
export interface RunnerSpecVolumesEphemeralVolumeClaimTemplate {
  /**
   * May contain labels and annotations that will be copied into the PVC when creating it. No other fields are allowed and will be rejected during validation.
   *
   * @schema RunnerSpecVolumesEphemeralVolumeClaimTemplate#metadata
   */
  readonly metadata?: RunnerSpecVolumesEphemeralVolumeClaimTemplateMetadata;

  /**
   * The specification for the PersistentVolumeClaim. The entire content is copied unchanged into the PVC that gets created from this template. The same fields as in a PersistentVolumeClaim are also valid here.
   *
   * @schema RunnerSpecVolumesEphemeralVolumeClaimTemplate#spec
   */
  readonly spec: RunnerSpecVolumesEphemeralVolumeClaimTemplateSpec;

}

/**
 * Converts an object of type 'RunnerSpecVolumesEphemeralVolumeClaimTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecVolumesEphemeralVolumeClaimTemplate(obj: RunnerSpecVolumesEphemeralVolumeClaimTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_RunnerSpecVolumesEphemeralVolumeClaimTemplateMetadata(obj.metadata),
    'spec': toJson_RunnerSpecVolumesEphemeralVolumeClaimTemplateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Optional: SecretRef is reference to the secret object containing sensitive information to pass to the plugin scripts. This may be empty if no secret object is specified. If the secret object contains more than one secret, all secrets are passed to the plugin scripts.
 *
 * @schema RunnerSpecVolumesFlexVolumeSecretRef
 */
export interface RunnerSpecVolumesFlexVolumeSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerSpecVolumesFlexVolumeSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'RunnerSpecVolumesFlexVolumeSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecVolumesFlexVolumeSecretRef(obj: RunnerSpecVolumesFlexVolumeSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CHAP Secret for iSCSI target and initiator authentication
 *
 * @schema RunnerSpecVolumesIscsiSecretRef
 */
export interface RunnerSpecVolumesIscsiSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerSpecVolumesIscsiSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'RunnerSpecVolumesIscsiSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecVolumesIscsiSecretRef(obj: RunnerSpecVolumesIscsiSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Projection that may be projected along with other supported volume types
 *
 * @schema RunnerSpecVolumesProjectedSources
 */
export interface RunnerSpecVolumesProjectedSources {
  /**
   * information about the configMap data to project
   *
   * @schema RunnerSpecVolumesProjectedSources#configMap
   */
  readonly configMap?: RunnerSpecVolumesProjectedSourcesConfigMap;

  /**
   * information about the downwardAPI data to project
   *
   * @schema RunnerSpecVolumesProjectedSources#downwardAPI
   */
  readonly downwardApi?: RunnerSpecVolumesProjectedSourcesDownwardApi;

  /**
   * information about the secret data to project
   *
   * @schema RunnerSpecVolumesProjectedSources#secret
   */
  readonly secret?: RunnerSpecVolumesProjectedSourcesSecret;

  /**
   * information about the serviceAccountToken data to project
   *
   * @schema RunnerSpecVolumesProjectedSources#serviceAccountToken
   */
  readonly serviceAccountToken?: RunnerSpecVolumesProjectedSourcesServiceAccountToken;

}

/**
 * Converts an object of type 'RunnerSpecVolumesProjectedSources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecVolumesProjectedSources(obj: RunnerSpecVolumesProjectedSources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_RunnerSpecVolumesProjectedSourcesConfigMap(obj.configMap),
    'downwardAPI': toJson_RunnerSpecVolumesProjectedSourcesDownwardApi(obj.downwardApi),
    'secret': toJson_RunnerSpecVolumesProjectedSourcesSecret(obj.secret),
    'serviceAccountToken': toJson_RunnerSpecVolumesProjectedSourcesServiceAccountToken(obj.serviceAccountToken),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretRef is name of the authentication secret for RBDUser. If provided overrides keyring. Default is nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
 *
 * @default nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
 * @schema RunnerSpecVolumesRbdSecretRef
 */
export interface RunnerSpecVolumesRbdSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerSpecVolumesRbdSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'RunnerSpecVolumesRbdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecVolumesRbdSecretRef(obj: RunnerSpecVolumesRbdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretRef references to the secret for ScaleIO user and other sensitive information. If this is not provided, Login operation will fail.
 *
 * @schema RunnerSpecVolumesScaleIoSecretRef
 */
export interface RunnerSpecVolumesScaleIoSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerSpecVolumesScaleIoSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'RunnerSpecVolumesScaleIoSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecVolumesScaleIoSecretRef(obj: RunnerSpecVolumesScaleIoSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema RunnerSpecVolumesSecretItems
 */
export interface RunnerSpecVolumesSecretItems {
  /**
   * The key to project.
   *
   * @schema RunnerSpecVolumesSecretItems#key
   */
  readonly key: string;

  /**
   * Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema RunnerSpecVolumesSecretItems#mode
   */
  readonly mode?: number;

  /**
   * The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema RunnerSpecVolumesSecretItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'RunnerSpecVolumesSecretItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecVolumesSecretItems(obj: RunnerSpecVolumesSecretItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretRef specifies the secret to use for obtaining the StorageOS API credentials.  If not specified, default values will be attempted.
 *
 * @schema RunnerSpecVolumesStorageosSecretRef
 */
export interface RunnerSpecVolumesStorageosSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerSpecVolumesStorageosSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'RunnerSpecVolumesStorageosSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecVolumesStorageosSecretRef(obj: RunnerSpecVolumesStorageosSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector term, associated with the corresponding weight.
 *
 * @schema RunnerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface RunnerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema RunnerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: RunnerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema RunnerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: RunnerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];

}

/**
 * Converts an object of type 'RunnerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj: RunnerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_RunnerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_RunnerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A null or empty node selector term matches no objects. The requirements of them are ANDed. The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
 *
 * @schema RunnerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface RunnerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema RunnerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: RunnerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema RunnerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: RunnerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];

}

/**
 * Converts an object of type 'RunnerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(obj: RunnerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_RunnerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_RunnerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema RunnerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface RunnerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   *
   * @schema RunnerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: RunnerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces. This field is beta-level and is only honored when PodAffinityNamespaceSelector feature is enabled.
   *
   * @schema RunnerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: RunnerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means "this pod's namespace"
   *
   * @schema RunnerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
   *
   * @schema RunnerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'RunnerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: RunnerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_RunnerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_RunnerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 *
 * @schema RunnerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface RunnerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema RunnerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: RunnerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema RunnerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'RunnerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: RunnerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_RunnerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces. This field is beta-level and is only honored when PodAffinityNamespaceSelector feature is enabled.
 *
 * @schema RunnerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface RunnerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema RunnerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: RunnerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema RunnerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'RunnerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: RunnerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_RunnerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema RunnerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface RunnerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   *
   * @schema RunnerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: RunnerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces. This field is beta-level and is only honored when PodAffinityNamespaceSelector feature is enabled.
   *
   * @schema RunnerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: RunnerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means "this pod's namespace"
   *
   * @schema RunnerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
   *
   * @schema RunnerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'RunnerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: RunnerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_RunnerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_RunnerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 *
 * @schema RunnerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface RunnerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema RunnerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: RunnerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema RunnerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'RunnerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: RunnerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_RunnerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces. This field is beta-level and is only honored when PodAffinityNamespaceSelector feature is enabled.
 *
 * @schema RunnerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface RunnerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema RunnerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: RunnerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema RunnerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'RunnerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: RunnerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_RunnerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a ConfigMap.
 *
 * @schema RunnerSpecContainersEnvValueFromConfigMapKeyRef
 */
export interface RunnerSpecContainersEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema RunnerSpecContainersEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerSpecContainersEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema RunnerSpecContainersEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerSpecContainersEnvValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecContainersEnvValueFromConfigMapKeyRef(obj: RunnerSpecContainersEnvValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema RunnerSpecContainersEnvValueFromFieldRef
 */
export interface RunnerSpecContainersEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema RunnerSpecContainersEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema RunnerSpecContainersEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'RunnerSpecContainersEnvValueFromFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecContainersEnvValueFromFieldRef(obj: RunnerSpecContainersEnvValueFromFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema RunnerSpecContainersEnvValueFromResourceFieldRef
 */
export interface RunnerSpecContainersEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema RunnerSpecContainersEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema RunnerSpecContainersEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: RunnerSpecContainersEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema RunnerSpecContainersEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'RunnerSpecContainersEnvValueFromResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecContainersEnvValueFromResourceFieldRef(obj: RunnerSpecContainersEnvValueFromResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema RunnerSpecContainersEnvValueFromSecretKeyRef
 */
export interface RunnerSpecContainersEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema RunnerSpecContainersEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerSpecContainersEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema RunnerSpecContainersEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerSpecContainersEnvValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecContainersEnvValueFromSecretKeyRef(obj: RunnerSpecContainersEnvValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema RunnerSpecContainersLifecyclePostStartExec
 */
export interface RunnerSpecContainersLifecyclePostStartExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RunnerSpecContainersLifecyclePostStartExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'RunnerSpecContainersLifecyclePostStartExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecContainersLifecyclePostStartExec(obj: RunnerSpecContainersLifecyclePostStartExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema RunnerSpecContainersLifecyclePostStartHttpGet
 */
export interface RunnerSpecContainersLifecyclePostStartHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RunnerSpecContainersLifecyclePostStartHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RunnerSpecContainersLifecyclePostStartHttpGet#httpHeaders
   */
  readonly httpHeaders?: RunnerSpecContainersLifecyclePostStartHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RunnerSpecContainersLifecyclePostStartHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerSpecContainersLifecyclePostStartHttpGet#port
   */
  readonly port: RunnerSpecContainersLifecyclePostStartHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RunnerSpecContainersLifecyclePostStartHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RunnerSpecContainersLifecyclePostStartHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecContainersLifecyclePostStartHttpGet(obj: RunnerSpecContainersLifecyclePostStartHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_RunnerSpecContainersLifecyclePostStartHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
 *
 * @schema RunnerSpecContainersLifecyclePostStartTcpSocket
 */
export interface RunnerSpecContainersLifecyclePostStartTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RunnerSpecContainersLifecyclePostStartTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerSpecContainersLifecyclePostStartTcpSocket#port
   */
  readonly port: RunnerSpecContainersLifecyclePostStartTcpSocketPort;

}

/**
 * Converts an object of type 'RunnerSpecContainersLifecyclePostStartTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecContainersLifecyclePostStartTcpSocket(obj: RunnerSpecContainersLifecyclePostStartTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema RunnerSpecContainersLifecyclePreStopExec
 */
export interface RunnerSpecContainersLifecyclePreStopExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RunnerSpecContainersLifecyclePreStopExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'RunnerSpecContainersLifecyclePreStopExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecContainersLifecyclePreStopExec(obj: RunnerSpecContainersLifecyclePreStopExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema RunnerSpecContainersLifecyclePreStopHttpGet
 */
export interface RunnerSpecContainersLifecyclePreStopHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RunnerSpecContainersLifecyclePreStopHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RunnerSpecContainersLifecyclePreStopHttpGet#httpHeaders
   */
  readonly httpHeaders?: RunnerSpecContainersLifecyclePreStopHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RunnerSpecContainersLifecyclePreStopHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerSpecContainersLifecyclePreStopHttpGet#port
   */
  readonly port: RunnerSpecContainersLifecyclePreStopHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RunnerSpecContainersLifecyclePreStopHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RunnerSpecContainersLifecyclePreStopHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecContainersLifecyclePreStopHttpGet(obj: RunnerSpecContainersLifecyclePreStopHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_RunnerSpecContainersLifecyclePreStopHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
 *
 * @schema RunnerSpecContainersLifecyclePreStopTcpSocket
 */
export interface RunnerSpecContainersLifecyclePreStopTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RunnerSpecContainersLifecyclePreStopTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerSpecContainersLifecyclePreStopTcpSocket#port
   */
  readonly port: RunnerSpecContainersLifecyclePreStopTcpSocketPort;

}

/**
 * Converts an object of type 'RunnerSpecContainersLifecyclePreStopTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecContainersLifecyclePreStopTcpSocket(obj: RunnerSpecContainersLifecyclePreStopTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RunnerSpecContainersLivenessProbeHttpGetHttpHeaders
 */
export interface RunnerSpecContainersLivenessProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RunnerSpecContainersLivenessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RunnerSpecContainersLivenessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerSpecContainersLivenessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecContainersLivenessProbeHttpGetHttpHeaders(obj: RunnerSpecContainersLivenessProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerSpecContainersLivenessProbeHttpGetPort
 */
export class RunnerSpecContainersLivenessProbeHttpGetPort {
  public static fromNumber(value: number): RunnerSpecContainersLivenessProbeHttpGetPort {
    return new RunnerSpecContainersLivenessProbeHttpGetPort(value);
  }
  public static fromString(value: string): RunnerSpecContainersLivenessProbeHttpGetPort {
    return new RunnerSpecContainersLivenessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerSpecContainersLivenessProbeTcpSocketPort
 */
export class RunnerSpecContainersLivenessProbeTcpSocketPort {
  public static fromNumber(value: number): RunnerSpecContainersLivenessProbeTcpSocketPort {
    return new RunnerSpecContainersLivenessProbeTcpSocketPort(value);
  }
  public static fromString(value: string): RunnerSpecContainersLivenessProbeTcpSocketPort {
    return new RunnerSpecContainersLivenessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RunnerSpecContainersReadinessProbeHttpGetHttpHeaders
 */
export interface RunnerSpecContainersReadinessProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RunnerSpecContainersReadinessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RunnerSpecContainersReadinessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerSpecContainersReadinessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecContainersReadinessProbeHttpGetHttpHeaders(obj: RunnerSpecContainersReadinessProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerSpecContainersReadinessProbeHttpGetPort
 */
export class RunnerSpecContainersReadinessProbeHttpGetPort {
  public static fromNumber(value: number): RunnerSpecContainersReadinessProbeHttpGetPort {
    return new RunnerSpecContainersReadinessProbeHttpGetPort(value);
  }
  public static fromString(value: string): RunnerSpecContainersReadinessProbeHttpGetPort {
    return new RunnerSpecContainersReadinessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerSpecContainersReadinessProbeTcpSocketPort
 */
export class RunnerSpecContainersReadinessProbeTcpSocketPort {
  public static fromNumber(value: number): RunnerSpecContainersReadinessProbeTcpSocketPort {
    return new RunnerSpecContainersReadinessProbeTcpSocketPort(value);
  }
  public static fromString(value: string): RunnerSpecContainersReadinessProbeTcpSocketPort {
    return new RunnerSpecContainersReadinessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RunnerSpecContainersStartupProbeHttpGetHttpHeaders
 */
export interface RunnerSpecContainersStartupProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RunnerSpecContainersStartupProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RunnerSpecContainersStartupProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerSpecContainersStartupProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecContainersStartupProbeHttpGetHttpHeaders(obj: RunnerSpecContainersStartupProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerSpecContainersStartupProbeHttpGetPort
 */
export class RunnerSpecContainersStartupProbeHttpGetPort {
  public static fromNumber(value: number): RunnerSpecContainersStartupProbeHttpGetPort {
    return new RunnerSpecContainersStartupProbeHttpGetPort(value);
  }
  public static fromString(value: string): RunnerSpecContainersStartupProbeHttpGetPort {
    return new RunnerSpecContainersStartupProbeHttpGetPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerSpecContainersStartupProbeTcpSocketPort
 */
export class RunnerSpecContainersStartupProbeTcpSocketPort {
  public static fromNumber(value: number): RunnerSpecContainersStartupProbeTcpSocketPort {
    return new RunnerSpecContainersStartupProbeTcpSocketPort(value);
  }
  public static fromString(value: string): RunnerSpecContainersStartupProbeTcpSocketPort {
    return new RunnerSpecContainersStartupProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema RunnerSpecDockerEnvValueFromResourceFieldRefDivisor
 */
export class RunnerSpecDockerEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(value: number): RunnerSpecDockerEnvValueFromResourceFieldRefDivisor {
    return new RunnerSpecDockerEnvValueFromResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): RunnerSpecDockerEnvValueFromResourceFieldRefDivisor {
    return new RunnerSpecDockerEnvValueFromResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema RunnerSpecEnvValueFromResourceFieldRefDivisor
 */
export class RunnerSpecEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(value: number): RunnerSpecEnvValueFromResourceFieldRefDivisor {
    return new RunnerSpecEnvValueFromResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): RunnerSpecEnvValueFromResourceFieldRefDivisor {
    return new RunnerSpecEnvValueFromResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Selects a key of a ConfigMap.
 *
 * @schema RunnerSpecEphemeralContainersEnvValueFromConfigMapKeyRef
 */
export interface RunnerSpecEphemeralContainersEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema RunnerSpecEphemeralContainersEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerSpecEphemeralContainersEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema RunnerSpecEphemeralContainersEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerSpecEphemeralContainersEnvValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecEphemeralContainersEnvValueFromConfigMapKeyRef(obj: RunnerSpecEphemeralContainersEnvValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema RunnerSpecEphemeralContainersEnvValueFromFieldRef
 */
export interface RunnerSpecEphemeralContainersEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema RunnerSpecEphemeralContainersEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema RunnerSpecEphemeralContainersEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'RunnerSpecEphemeralContainersEnvValueFromFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecEphemeralContainersEnvValueFromFieldRef(obj: RunnerSpecEphemeralContainersEnvValueFromFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema RunnerSpecEphemeralContainersEnvValueFromResourceFieldRef
 */
export interface RunnerSpecEphemeralContainersEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema RunnerSpecEphemeralContainersEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema RunnerSpecEphemeralContainersEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: RunnerSpecEphemeralContainersEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema RunnerSpecEphemeralContainersEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'RunnerSpecEphemeralContainersEnvValueFromResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecEphemeralContainersEnvValueFromResourceFieldRef(obj: RunnerSpecEphemeralContainersEnvValueFromResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema RunnerSpecEphemeralContainersEnvValueFromSecretKeyRef
 */
export interface RunnerSpecEphemeralContainersEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema RunnerSpecEphemeralContainersEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerSpecEphemeralContainersEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema RunnerSpecEphemeralContainersEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerSpecEphemeralContainersEnvValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecEphemeralContainersEnvValueFromSecretKeyRef(obj: RunnerSpecEphemeralContainersEnvValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema RunnerSpecEphemeralContainersLifecyclePostStartExec
 */
export interface RunnerSpecEphemeralContainersLifecyclePostStartExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RunnerSpecEphemeralContainersLifecyclePostStartExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'RunnerSpecEphemeralContainersLifecyclePostStartExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecEphemeralContainersLifecyclePostStartExec(obj: RunnerSpecEphemeralContainersLifecyclePostStartExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema RunnerSpecEphemeralContainersLifecyclePostStartHttpGet
 */
export interface RunnerSpecEphemeralContainersLifecyclePostStartHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RunnerSpecEphemeralContainersLifecyclePostStartHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RunnerSpecEphemeralContainersLifecyclePostStartHttpGet#httpHeaders
   */
  readonly httpHeaders?: RunnerSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RunnerSpecEphemeralContainersLifecyclePostStartHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerSpecEphemeralContainersLifecyclePostStartHttpGet#port
   */
  readonly port: RunnerSpecEphemeralContainersLifecyclePostStartHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RunnerSpecEphemeralContainersLifecyclePostStartHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RunnerSpecEphemeralContainersLifecyclePostStartHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecEphemeralContainersLifecyclePostStartHttpGet(obj: RunnerSpecEphemeralContainersLifecyclePostStartHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_RunnerSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
 *
 * @schema RunnerSpecEphemeralContainersLifecyclePostStartTcpSocket
 */
export interface RunnerSpecEphemeralContainersLifecyclePostStartTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RunnerSpecEphemeralContainersLifecyclePostStartTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerSpecEphemeralContainersLifecyclePostStartTcpSocket#port
   */
  readonly port: RunnerSpecEphemeralContainersLifecyclePostStartTcpSocketPort;

}

/**
 * Converts an object of type 'RunnerSpecEphemeralContainersLifecyclePostStartTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecEphemeralContainersLifecyclePostStartTcpSocket(obj: RunnerSpecEphemeralContainersLifecyclePostStartTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema RunnerSpecEphemeralContainersLifecyclePreStopExec
 */
export interface RunnerSpecEphemeralContainersLifecyclePreStopExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RunnerSpecEphemeralContainersLifecyclePreStopExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'RunnerSpecEphemeralContainersLifecyclePreStopExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecEphemeralContainersLifecyclePreStopExec(obj: RunnerSpecEphemeralContainersLifecyclePreStopExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema RunnerSpecEphemeralContainersLifecyclePreStopHttpGet
 */
export interface RunnerSpecEphemeralContainersLifecyclePreStopHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RunnerSpecEphemeralContainersLifecyclePreStopHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RunnerSpecEphemeralContainersLifecyclePreStopHttpGet#httpHeaders
   */
  readonly httpHeaders?: RunnerSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RunnerSpecEphemeralContainersLifecyclePreStopHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerSpecEphemeralContainersLifecyclePreStopHttpGet#port
   */
  readonly port: RunnerSpecEphemeralContainersLifecyclePreStopHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RunnerSpecEphemeralContainersLifecyclePreStopHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RunnerSpecEphemeralContainersLifecyclePreStopHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecEphemeralContainersLifecyclePreStopHttpGet(obj: RunnerSpecEphemeralContainersLifecyclePreStopHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_RunnerSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
 *
 * @schema RunnerSpecEphemeralContainersLifecyclePreStopTcpSocket
 */
export interface RunnerSpecEphemeralContainersLifecyclePreStopTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RunnerSpecEphemeralContainersLifecyclePreStopTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerSpecEphemeralContainersLifecyclePreStopTcpSocket#port
   */
  readonly port: RunnerSpecEphemeralContainersLifecyclePreStopTcpSocketPort;

}

/**
 * Converts an object of type 'RunnerSpecEphemeralContainersLifecyclePreStopTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecEphemeralContainersLifecyclePreStopTcpSocket(obj: RunnerSpecEphemeralContainersLifecyclePreStopTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RunnerSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders
 */
export interface RunnerSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RunnerSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RunnerSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders(obj: RunnerSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerSpecEphemeralContainersLivenessProbeHttpGetPort
 */
export class RunnerSpecEphemeralContainersLivenessProbeHttpGetPort {
  public static fromNumber(value: number): RunnerSpecEphemeralContainersLivenessProbeHttpGetPort {
    return new RunnerSpecEphemeralContainersLivenessProbeHttpGetPort(value);
  }
  public static fromString(value: string): RunnerSpecEphemeralContainersLivenessProbeHttpGetPort {
    return new RunnerSpecEphemeralContainersLivenessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerSpecEphemeralContainersLivenessProbeTcpSocketPort
 */
export class RunnerSpecEphemeralContainersLivenessProbeTcpSocketPort {
  public static fromNumber(value: number): RunnerSpecEphemeralContainersLivenessProbeTcpSocketPort {
    return new RunnerSpecEphemeralContainersLivenessProbeTcpSocketPort(value);
  }
  public static fromString(value: string): RunnerSpecEphemeralContainersLivenessProbeTcpSocketPort {
    return new RunnerSpecEphemeralContainersLivenessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RunnerSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders
 */
export interface RunnerSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RunnerSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RunnerSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders(obj: RunnerSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerSpecEphemeralContainersReadinessProbeHttpGetPort
 */
export class RunnerSpecEphemeralContainersReadinessProbeHttpGetPort {
  public static fromNumber(value: number): RunnerSpecEphemeralContainersReadinessProbeHttpGetPort {
    return new RunnerSpecEphemeralContainersReadinessProbeHttpGetPort(value);
  }
  public static fromString(value: string): RunnerSpecEphemeralContainersReadinessProbeHttpGetPort {
    return new RunnerSpecEphemeralContainersReadinessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerSpecEphemeralContainersReadinessProbeTcpSocketPort
 */
export class RunnerSpecEphemeralContainersReadinessProbeTcpSocketPort {
  public static fromNumber(value: number): RunnerSpecEphemeralContainersReadinessProbeTcpSocketPort {
    return new RunnerSpecEphemeralContainersReadinessProbeTcpSocketPort(value);
  }
  public static fromString(value: string): RunnerSpecEphemeralContainersReadinessProbeTcpSocketPort {
    return new RunnerSpecEphemeralContainersReadinessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RunnerSpecEphemeralContainersStartupProbeHttpGetHttpHeaders
 */
export interface RunnerSpecEphemeralContainersStartupProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RunnerSpecEphemeralContainersStartupProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RunnerSpecEphemeralContainersStartupProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerSpecEphemeralContainersStartupProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecEphemeralContainersStartupProbeHttpGetHttpHeaders(obj: RunnerSpecEphemeralContainersStartupProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerSpecEphemeralContainersStartupProbeHttpGetPort
 */
export class RunnerSpecEphemeralContainersStartupProbeHttpGetPort {
  public static fromNumber(value: number): RunnerSpecEphemeralContainersStartupProbeHttpGetPort {
    return new RunnerSpecEphemeralContainersStartupProbeHttpGetPort(value);
  }
  public static fromString(value: string): RunnerSpecEphemeralContainersStartupProbeHttpGetPort {
    return new RunnerSpecEphemeralContainersStartupProbeHttpGetPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerSpecEphemeralContainersStartupProbeTcpSocketPort
 */
export class RunnerSpecEphemeralContainersStartupProbeTcpSocketPort {
  public static fromNumber(value: number): RunnerSpecEphemeralContainersStartupProbeTcpSocketPort {
    return new RunnerSpecEphemeralContainersStartupProbeTcpSocketPort(value);
  }
  public static fromString(value: string): RunnerSpecEphemeralContainersStartupProbeTcpSocketPort {
    return new RunnerSpecEphemeralContainersStartupProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Selects a key of a ConfigMap.
 *
 * @schema RunnerSpecInitContainersEnvValueFromConfigMapKeyRef
 */
export interface RunnerSpecInitContainersEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema RunnerSpecInitContainersEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerSpecInitContainersEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema RunnerSpecInitContainersEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerSpecInitContainersEnvValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecInitContainersEnvValueFromConfigMapKeyRef(obj: RunnerSpecInitContainersEnvValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema RunnerSpecInitContainersEnvValueFromFieldRef
 */
export interface RunnerSpecInitContainersEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema RunnerSpecInitContainersEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema RunnerSpecInitContainersEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'RunnerSpecInitContainersEnvValueFromFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecInitContainersEnvValueFromFieldRef(obj: RunnerSpecInitContainersEnvValueFromFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema RunnerSpecInitContainersEnvValueFromResourceFieldRef
 */
export interface RunnerSpecInitContainersEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema RunnerSpecInitContainersEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema RunnerSpecInitContainersEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: RunnerSpecInitContainersEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema RunnerSpecInitContainersEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'RunnerSpecInitContainersEnvValueFromResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecInitContainersEnvValueFromResourceFieldRef(obj: RunnerSpecInitContainersEnvValueFromResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema RunnerSpecInitContainersEnvValueFromSecretKeyRef
 */
export interface RunnerSpecInitContainersEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema RunnerSpecInitContainersEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerSpecInitContainersEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema RunnerSpecInitContainersEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerSpecInitContainersEnvValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecInitContainersEnvValueFromSecretKeyRef(obj: RunnerSpecInitContainersEnvValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema RunnerSpecInitContainersLifecyclePostStartExec
 */
export interface RunnerSpecInitContainersLifecyclePostStartExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RunnerSpecInitContainersLifecyclePostStartExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'RunnerSpecInitContainersLifecyclePostStartExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecInitContainersLifecyclePostStartExec(obj: RunnerSpecInitContainersLifecyclePostStartExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema RunnerSpecInitContainersLifecyclePostStartHttpGet
 */
export interface RunnerSpecInitContainersLifecyclePostStartHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RunnerSpecInitContainersLifecyclePostStartHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RunnerSpecInitContainersLifecyclePostStartHttpGet#httpHeaders
   */
  readonly httpHeaders?: RunnerSpecInitContainersLifecyclePostStartHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RunnerSpecInitContainersLifecyclePostStartHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerSpecInitContainersLifecyclePostStartHttpGet#port
   */
  readonly port: RunnerSpecInitContainersLifecyclePostStartHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RunnerSpecInitContainersLifecyclePostStartHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RunnerSpecInitContainersLifecyclePostStartHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecInitContainersLifecyclePostStartHttpGet(obj: RunnerSpecInitContainersLifecyclePostStartHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_RunnerSpecInitContainersLifecyclePostStartHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
 *
 * @schema RunnerSpecInitContainersLifecyclePostStartTcpSocket
 */
export interface RunnerSpecInitContainersLifecyclePostStartTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RunnerSpecInitContainersLifecyclePostStartTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerSpecInitContainersLifecyclePostStartTcpSocket#port
   */
  readonly port: RunnerSpecInitContainersLifecyclePostStartTcpSocketPort;

}

/**
 * Converts an object of type 'RunnerSpecInitContainersLifecyclePostStartTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecInitContainersLifecyclePostStartTcpSocket(obj: RunnerSpecInitContainersLifecyclePostStartTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema RunnerSpecInitContainersLifecyclePreStopExec
 */
export interface RunnerSpecInitContainersLifecyclePreStopExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RunnerSpecInitContainersLifecyclePreStopExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'RunnerSpecInitContainersLifecyclePreStopExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecInitContainersLifecyclePreStopExec(obj: RunnerSpecInitContainersLifecyclePreStopExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema RunnerSpecInitContainersLifecyclePreStopHttpGet
 */
export interface RunnerSpecInitContainersLifecyclePreStopHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RunnerSpecInitContainersLifecyclePreStopHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RunnerSpecInitContainersLifecyclePreStopHttpGet#httpHeaders
   */
  readonly httpHeaders?: RunnerSpecInitContainersLifecyclePreStopHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RunnerSpecInitContainersLifecyclePreStopHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerSpecInitContainersLifecyclePreStopHttpGet#port
   */
  readonly port: RunnerSpecInitContainersLifecyclePreStopHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RunnerSpecInitContainersLifecyclePreStopHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RunnerSpecInitContainersLifecyclePreStopHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecInitContainersLifecyclePreStopHttpGet(obj: RunnerSpecInitContainersLifecyclePreStopHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_RunnerSpecInitContainersLifecyclePreStopHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
 *
 * @schema RunnerSpecInitContainersLifecyclePreStopTcpSocket
 */
export interface RunnerSpecInitContainersLifecyclePreStopTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RunnerSpecInitContainersLifecyclePreStopTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerSpecInitContainersLifecyclePreStopTcpSocket#port
   */
  readonly port: RunnerSpecInitContainersLifecyclePreStopTcpSocketPort;

}

/**
 * Converts an object of type 'RunnerSpecInitContainersLifecyclePreStopTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecInitContainersLifecyclePreStopTcpSocket(obj: RunnerSpecInitContainersLifecyclePreStopTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RunnerSpecInitContainersLivenessProbeHttpGetHttpHeaders
 */
export interface RunnerSpecInitContainersLivenessProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RunnerSpecInitContainersLivenessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RunnerSpecInitContainersLivenessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerSpecInitContainersLivenessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecInitContainersLivenessProbeHttpGetHttpHeaders(obj: RunnerSpecInitContainersLivenessProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerSpecInitContainersLivenessProbeHttpGetPort
 */
export class RunnerSpecInitContainersLivenessProbeHttpGetPort {
  public static fromNumber(value: number): RunnerSpecInitContainersLivenessProbeHttpGetPort {
    return new RunnerSpecInitContainersLivenessProbeHttpGetPort(value);
  }
  public static fromString(value: string): RunnerSpecInitContainersLivenessProbeHttpGetPort {
    return new RunnerSpecInitContainersLivenessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerSpecInitContainersLivenessProbeTcpSocketPort
 */
export class RunnerSpecInitContainersLivenessProbeTcpSocketPort {
  public static fromNumber(value: number): RunnerSpecInitContainersLivenessProbeTcpSocketPort {
    return new RunnerSpecInitContainersLivenessProbeTcpSocketPort(value);
  }
  public static fromString(value: string): RunnerSpecInitContainersLivenessProbeTcpSocketPort {
    return new RunnerSpecInitContainersLivenessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RunnerSpecInitContainersReadinessProbeHttpGetHttpHeaders
 */
export interface RunnerSpecInitContainersReadinessProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RunnerSpecInitContainersReadinessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RunnerSpecInitContainersReadinessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerSpecInitContainersReadinessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecInitContainersReadinessProbeHttpGetHttpHeaders(obj: RunnerSpecInitContainersReadinessProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerSpecInitContainersReadinessProbeHttpGetPort
 */
export class RunnerSpecInitContainersReadinessProbeHttpGetPort {
  public static fromNumber(value: number): RunnerSpecInitContainersReadinessProbeHttpGetPort {
    return new RunnerSpecInitContainersReadinessProbeHttpGetPort(value);
  }
  public static fromString(value: string): RunnerSpecInitContainersReadinessProbeHttpGetPort {
    return new RunnerSpecInitContainersReadinessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerSpecInitContainersReadinessProbeTcpSocketPort
 */
export class RunnerSpecInitContainersReadinessProbeTcpSocketPort {
  public static fromNumber(value: number): RunnerSpecInitContainersReadinessProbeTcpSocketPort {
    return new RunnerSpecInitContainersReadinessProbeTcpSocketPort(value);
  }
  public static fromString(value: string): RunnerSpecInitContainersReadinessProbeTcpSocketPort {
    return new RunnerSpecInitContainersReadinessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RunnerSpecInitContainersStartupProbeHttpGetHttpHeaders
 */
export interface RunnerSpecInitContainersStartupProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RunnerSpecInitContainersStartupProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RunnerSpecInitContainersStartupProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerSpecInitContainersStartupProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecInitContainersStartupProbeHttpGetHttpHeaders(obj: RunnerSpecInitContainersStartupProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerSpecInitContainersStartupProbeHttpGetPort
 */
export class RunnerSpecInitContainersStartupProbeHttpGetPort {
  public static fromNumber(value: number): RunnerSpecInitContainersStartupProbeHttpGetPort {
    return new RunnerSpecInitContainersStartupProbeHttpGetPort(value);
  }
  public static fromString(value: string): RunnerSpecInitContainersStartupProbeHttpGetPort {
    return new RunnerSpecInitContainersStartupProbeHttpGetPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerSpecInitContainersStartupProbeTcpSocketPort
 */
export class RunnerSpecInitContainersStartupProbeTcpSocketPort {
  public static fromNumber(value: number): RunnerSpecInitContainersStartupProbeTcpSocketPort {
    return new RunnerSpecInitContainersStartupProbeTcpSocketPort(value);
  }
  public static fromString(value: string): RunnerSpecInitContainersStartupProbeTcpSocketPort {
    return new RunnerSpecInitContainersStartupProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Selects a key of a ConfigMap.
 *
 * @schema RunnerSpecSidecarContainersEnvValueFromConfigMapKeyRef
 */
export interface RunnerSpecSidecarContainersEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema RunnerSpecSidecarContainersEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerSpecSidecarContainersEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema RunnerSpecSidecarContainersEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerSpecSidecarContainersEnvValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecSidecarContainersEnvValueFromConfigMapKeyRef(obj: RunnerSpecSidecarContainersEnvValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema RunnerSpecSidecarContainersEnvValueFromFieldRef
 */
export interface RunnerSpecSidecarContainersEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema RunnerSpecSidecarContainersEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema RunnerSpecSidecarContainersEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'RunnerSpecSidecarContainersEnvValueFromFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecSidecarContainersEnvValueFromFieldRef(obj: RunnerSpecSidecarContainersEnvValueFromFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema RunnerSpecSidecarContainersEnvValueFromResourceFieldRef
 */
export interface RunnerSpecSidecarContainersEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema RunnerSpecSidecarContainersEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema RunnerSpecSidecarContainersEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: RunnerSpecSidecarContainersEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema RunnerSpecSidecarContainersEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'RunnerSpecSidecarContainersEnvValueFromResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecSidecarContainersEnvValueFromResourceFieldRef(obj: RunnerSpecSidecarContainersEnvValueFromResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema RunnerSpecSidecarContainersEnvValueFromSecretKeyRef
 */
export interface RunnerSpecSidecarContainersEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema RunnerSpecSidecarContainersEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerSpecSidecarContainersEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema RunnerSpecSidecarContainersEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerSpecSidecarContainersEnvValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecSidecarContainersEnvValueFromSecretKeyRef(obj: RunnerSpecSidecarContainersEnvValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema RunnerSpecSidecarContainersLifecyclePostStartExec
 */
export interface RunnerSpecSidecarContainersLifecyclePostStartExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RunnerSpecSidecarContainersLifecyclePostStartExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'RunnerSpecSidecarContainersLifecyclePostStartExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecSidecarContainersLifecyclePostStartExec(obj: RunnerSpecSidecarContainersLifecyclePostStartExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema RunnerSpecSidecarContainersLifecyclePostStartHttpGet
 */
export interface RunnerSpecSidecarContainersLifecyclePostStartHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RunnerSpecSidecarContainersLifecyclePostStartHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RunnerSpecSidecarContainersLifecyclePostStartHttpGet#httpHeaders
   */
  readonly httpHeaders?: RunnerSpecSidecarContainersLifecyclePostStartHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RunnerSpecSidecarContainersLifecyclePostStartHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerSpecSidecarContainersLifecyclePostStartHttpGet#port
   */
  readonly port: RunnerSpecSidecarContainersLifecyclePostStartHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RunnerSpecSidecarContainersLifecyclePostStartHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RunnerSpecSidecarContainersLifecyclePostStartHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecSidecarContainersLifecyclePostStartHttpGet(obj: RunnerSpecSidecarContainersLifecyclePostStartHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_RunnerSpecSidecarContainersLifecyclePostStartHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
 *
 * @schema RunnerSpecSidecarContainersLifecyclePostStartTcpSocket
 */
export interface RunnerSpecSidecarContainersLifecyclePostStartTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RunnerSpecSidecarContainersLifecyclePostStartTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerSpecSidecarContainersLifecyclePostStartTcpSocket#port
   */
  readonly port: RunnerSpecSidecarContainersLifecyclePostStartTcpSocketPort;

}

/**
 * Converts an object of type 'RunnerSpecSidecarContainersLifecyclePostStartTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecSidecarContainersLifecyclePostStartTcpSocket(obj: RunnerSpecSidecarContainersLifecyclePostStartTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema RunnerSpecSidecarContainersLifecyclePreStopExec
 */
export interface RunnerSpecSidecarContainersLifecyclePreStopExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RunnerSpecSidecarContainersLifecyclePreStopExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'RunnerSpecSidecarContainersLifecyclePreStopExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecSidecarContainersLifecyclePreStopExec(obj: RunnerSpecSidecarContainersLifecyclePreStopExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema RunnerSpecSidecarContainersLifecyclePreStopHttpGet
 */
export interface RunnerSpecSidecarContainersLifecyclePreStopHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RunnerSpecSidecarContainersLifecyclePreStopHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RunnerSpecSidecarContainersLifecyclePreStopHttpGet#httpHeaders
   */
  readonly httpHeaders?: RunnerSpecSidecarContainersLifecyclePreStopHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RunnerSpecSidecarContainersLifecyclePreStopHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerSpecSidecarContainersLifecyclePreStopHttpGet#port
   */
  readonly port: RunnerSpecSidecarContainersLifecyclePreStopHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RunnerSpecSidecarContainersLifecyclePreStopHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RunnerSpecSidecarContainersLifecyclePreStopHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecSidecarContainersLifecyclePreStopHttpGet(obj: RunnerSpecSidecarContainersLifecyclePreStopHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_RunnerSpecSidecarContainersLifecyclePreStopHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
 *
 * @schema RunnerSpecSidecarContainersLifecyclePreStopTcpSocket
 */
export interface RunnerSpecSidecarContainersLifecyclePreStopTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RunnerSpecSidecarContainersLifecyclePreStopTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerSpecSidecarContainersLifecyclePreStopTcpSocket#port
   */
  readonly port: RunnerSpecSidecarContainersLifecyclePreStopTcpSocketPort;

}

/**
 * Converts an object of type 'RunnerSpecSidecarContainersLifecyclePreStopTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecSidecarContainersLifecyclePreStopTcpSocket(obj: RunnerSpecSidecarContainersLifecyclePreStopTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RunnerSpecSidecarContainersLivenessProbeHttpGetHttpHeaders
 */
export interface RunnerSpecSidecarContainersLivenessProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RunnerSpecSidecarContainersLivenessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RunnerSpecSidecarContainersLivenessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerSpecSidecarContainersLivenessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecSidecarContainersLivenessProbeHttpGetHttpHeaders(obj: RunnerSpecSidecarContainersLivenessProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerSpecSidecarContainersLivenessProbeHttpGetPort
 */
export class RunnerSpecSidecarContainersLivenessProbeHttpGetPort {
  public static fromNumber(value: number): RunnerSpecSidecarContainersLivenessProbeHttpGetPort {
    return new RunnerSpecSidecarContainersLivenessProbeHttpGetPort(value);
  }
  public static fromString(value: string): RunnerSpecSidecarContainersLivenessProbeHttpGetPort {
    return new RunnerSpecSidecarContainersLivenessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerSpecSidecarContainersLivenessProbeTcpSocketPort
 */
export class RunnerSpecSidecarContainersLivenessProbeTcpSocketPort {
  public static fromNumber(value: number): RunnerSpecSidecarContainersLivenessProbeTcpSocketPort {
    return new RunnerSpecSidecarContainersLivenessProbeTcpSocketPort(value);
  }
  public static fromString(value: string): RunnerSpecSidecarContainersLivenessProbeTcpSocketPort {
    return new RunnerSpecSidecarContainersLivenessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RunnerSpecSidecarContainersReadinessProbeHttpGetHttpHeaders
 */
export interface RunnerSpecSidecarContainersReadinessProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RunnerSpecSidecarContainersReadinessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RunnerSpecSidecarContainersReadinessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerSpecSidecarContainersReadinessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecSidecarContainersReadinessProbeHttpGetHttpHeaders(obj: RunnerSpecSidecarContainersReadinessProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerSpecSidecarContainersReadinessProbeHttpGetPort
 */
export class RunnerSpecSidecarContainersReadinessProbeHttpGetPort {
  public static fromNumber(value: number): RunnerSpecSidecarContainersReadinessProbeHttpGetPort {
    return new RunnerSpecSidecarContainersReadinessProbeHttpGetPort(value);
  }
  public static fromString(value: string): RunnerSpecSidecarContainersReadinessProbeHttpGetPort {
    return new RunnerSpecSidecarContainersReadinessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerSpecSidecarContainersReadinessProbeTcpSocketPort
 */
export class RunnerSpecSidecarContainersReadinessProbeTcpSocketPort {
  public static fromNumber(value: number): RunnerSpecSidecarContainersReadinessProbeTcpSocketPort {
    return new RunnerSpecSidecarContainersReadinessProbeTcpSocketPort(value);
  }
  public static fromString(value: string): RunnerSpecSidecarContainersReadinessProbeTcpSocketPort {
    return new RunnerSpecSidecarContainersReadinessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RunnerSpecSidecarContainersStartupProbeHttpGetHttpHeaders
 */
export interface RunnerSpecSidecarContainersStartupProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RunnerSpecSidecarContainersStartupProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RunnerSpecSidecarContainersStartupProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerSpecSidecarContainersStartupProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecSidecarContainersStartupProbeHttpGetHttpHeaders(obj: RunnerSpecSidecarContainersStartupProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerSpecSidecarContainersStartupProbeHttpGetPort
 */
export class RunnerSpecSidecarContainersStartupProbeHttpGetPort {
  public static fromNumber(value: number): RunnerSpecSidecarContainersStartupProbeHttpGetPort {
    return new RunnerSpecSidecarContainersStartupProbeHttpGetPort(value);
  }
  public static fromString(value: string): RunnerSpecSidecarContainersStartupProbeHttpGetPort {
    return new RunnerSpecSidecarContainersStartupProbeHttpGetPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerSpecSidecarContainersStartupProbeTcpSocketPort
 */
export class RunnerSpecSidecarContainersStartupProbeTcpSocketPort {
  public static fromNumber(value: number): RunnerSpecSidecarContainersStartupProbeTcpSocketPort {
    return new RunnerSpecSidecarContainersStartupProbeTcpSocketPort(value);
  }
  public static fromString(value: string): RunnerSpecSidecarContainersStartupProbeTcpSocketPort {
    return new RunnerSpecSidecarContainersStartupProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
 *
 * @schema RunnerSpecVolumesDownwardApiItemsFieldRef
 */
export interface RunnerSpecVolumesDownwardApiItemsFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema RunnerSpecVolumesDownwardApiItemsFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema RunnerSpecVolumesDownwardApiItemsFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'RunnerSpecVolumesDownwardApiItemsFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecVolumesDownwardApiItemsFieldRef(obj: RunnerSpecVolumesDownwardApiItemsFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
 *
 * @schema RunnerSpecVolumesDownwardApiItemsResourceFieldRef
 */
export interface RunnerSpecVolumesDownwardApiItemsResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema RunnerSpecVolumesDownwardApiItemsResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema RunnerSpecVolumesDownwardApiItemsResourceFieldRef#divisor
   */
  readonly divisor?: RunnerSpecVolumesDownwardApiItemsResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema RunnerSpecVolumesDownwardApiItemsResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'RunnerSpecVolumesDownwardApiItemsResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecVolumesDownwardApiItemsResourceFieldRef(obj: RunnerSpecVolumesDownwardApiItemsResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * May contain labels and annotations that will be copied into the PVC when creating it. No other fields are allowed and will be rejected during validation.
 *
 * @schema RunnerSpecVolumesEphemeralVolumeClaimTemplateMetadata
 */
export interface RunnerSpecVolumesEphemeralVolumeClaimTemplateMetadata {
  /**
   * @schema RunnerSpecVolumesEphemeralVolumeClaimTemplateMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * @schema RunnerSpecVolumesEphemeralVolumeClaimTemplateMetadata#finalizers
   */
  readonly finalizers?: string[];

  /**
   * @schema RunnerSpecVolumesEphemeralVolumeClaimTemplateMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * @schema RunnerSpecVolumesEphemeralVolumeClaimTemplateMetadata#name
   */
  readonly name?: string;

  /**
   * @schema RunnerSpecVolumesEphemeralVolumeClaimTemplateMetadata#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'RunnerSpecVolumesEphemeralVolumeClaimTemplateMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecVolumesEphemeralVolumeClaimTemplateMetadata(obj: RunnerSpecVolumesEphemeralVolumeClaimTemplateMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'finalizers': obj.finalizers?.map(y => y),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The specification for the PersistentVolumeClaim. The entire content is copied unchanged into the PVC that gets created from this template. The same fields as in a PersistentVolumeClaim are also valid here.
 *
 * @schema RunnerSpecVolumesEphemeralVolumeClaimTemplateSpec
 */
export interface RunnerSpecVolumesEphemeralVolumeClaimTemplateSpec {
  /**
   * AccessModes contains the desired access modes the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema RunnerSpecVolumesEphemeralVolumeClaimTemplateSpec#accessModes
   */
  readonly accessModes?: string[];

  /**
   * This field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. If the AnyVolumeDataSource feature gate is enabled, this field will always have the same contents as the DataSourceRef field.
   *
   * @schema RunnerSpecVolumesEphemeralVolumeClaimTemplateSpec#dataSource
   */
  readonly dataSource?: RunnerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource;

  /**
   * Specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any local object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the DataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, both fields (DataSource and DataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. There are two important differences between DataSource and DataSourceRef: * While DataSource only allows two specific types of objects, DataSourceRef   allows any non-core object, as well as PersistentVolumeClaim objects. * While DataSource ignores disallowed values (dropping them), DataSourceRef   preserves all values, and generates an error if a disallowed value is   specified. (Alpha) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
   *
   * @schema RunnerSpecVolumesEphemeralVolumeClaimTemplateSpec#dataSourceRef
   */
  readonly dataSourceRef?: RunnerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef;

  /**
   * Resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
   *
   * @schema RunnerSpecVolumesEphemeralVolumeClaimTemplateSpec#resources
   */
  readonly resources?: RunnerSpecVolumesEphemeralVolumeClaimTemplateSpecResources;

  /**
   * A label query over volumes to consider for binding.
   *
   * @schema RunnerSpecVolumesEphemeralVolumeClaimTemplateSpec#selector
   */
  readonly selector?: RunnerSpecVolumesEphemeralVolumeClaimTemplateSpecSelector;

  /**
   * Name of the StorageClass required by the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   *
   * @schema RunnerSpecVolumesEphemeralVolumeClaimTemplateSpec#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim spec.
   *
   * @schema RunnerSpecVolumesEphemeralVolumeClaimTemplateSpec#volumeMode
   */
  readonly volumeMode?: string;

  /**
   * VolumeName is the binding reference to the PersistentVolume backing this claim.
   *
   * @schema RunnerSpecVolumesEphemeralVolumeClaimTemplateSpec#volumeName
   */
  readonly volumeName?: string;

}

/**
 * Converts an object of type 'RunnerSpecVolumesEphemeralVolumeClaimTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecVolumesEphemeralVolumeClaimTemplateSpec(obj: RunnerSpecVolumesEphemeralVolumeClaimTemplateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessModes': obj.accessModes?.map(y => y),
    'dataSource': toJson_RunnerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource(obj.dataSource),
    'dataSourceRef': toJson_RunnerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef(obj.dataSourceRef),
    'resources': toJson_RunnerSpecVolumesEphemeralVolumeClaimTemplateSpecResources(obj.resources),
    'selector': toJson_RunnerSpecVolumesEphemeralVolumeClaimTemplateSpecSelector(obj.selector),
    'storageClassName': obj.storageClassName,
    'volumeMode': obj.volumeMode,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * information about the configMap data to project
 *
 * @schema RunnerSpecVolumesProjectedSourcesConfigMap
 */
export interface RunnerSpecVolumesProjectedSourcesConfigMap {
  /**
   * If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema RunnerSpecVolumesProjectedSourcesConfigMap#items
   */
  readonly items?: RunnerSpecVolumesProjectedSourcesConfigMapItems[];

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerSpecVolumesProjectedSourcesConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its keys must be defined
   *
   * @schema RunnerSpecVolumesProjectedSourcesConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerSpecVolumesProjectedSourcesConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecVolumesProjectedSourcesConfigMap(obj: RunnerSpecVolumesProjectedSourcesConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_RunnerSpecVolumesProjectedSourcesConfigMapItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * information about the downwardAPI data to project
 *
 * @schema RunnerSpecVolumesProjectedSourcesDownwardApi
 */
export interface RunnerSpecVolumesProjectedSourcesDownwardApi {
  /**
   * Items is a list of DownwardAPIVolume file
   *
   * @schema RunnerSpecVolumesProjectedSourcesDownwardApi#items
   */
  readonly items?: RunnerSpecVolumesProjectedSourcesDownwardApiItems[];

}

/**
 * Converts an object of type 'RunnerSpecVolumesProjectedSourcesDownwardApi' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecVolumesProjectedSourcesDownwardApi(obj: RunnerSpecVolumesProjectedSourcesDownwardApi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_RunnerSpecVolumesProjectedSourcesDownwardApiItems(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * information about the secret data to project
 *
 * @schema RunnerSpecVolumesProjectedSourcesSecret
 */
export interface RunnerSpecVolumesProjectedSourcesSecret {
  /**
   * If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema RunnerSpecVolumesProjectedSourcesSecret#items
   */
  readonly items?: RunnerSpecVolumesProjectedSourcesSecretItems[];

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerSpecVolumesProjectedSourcesSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema RunnerSpecVolumesProjectedSourcesSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerSpecVolumesProjectedSourcesSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecVolumesProjectedSourcesSecret(obj: RunnerSpecVolumesProjectedSourcesSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_RunnerSpecVolumesProjectedSourcesSecretItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * information about the serviceAccountToken data to project
 *
 * @schema RunnerSpecVolumesProjectedSourcesServiceAccountToken
 */
export interface RunnerSpecVolumesProjectedSourcesServiceAccountToken {
  /**
   * Audience is the intended audience of the token. A recipient of a token must identify itself with an identifier specified in the audience of the token, and otherwise should reject the token. The audience defaults to the identifier of the apiserver.
   *
   * @schema RunnerSpecVolumesProjectedSourcesServiceAccountToken#audience
   */
  readonly audience?: string;

  /**
   * ExpirationSeconds is the requested duration of validity of the service account token. As the token approaches expiration, the kubelet volume plugin will proactively rotate the service account token. The kubelet will start trying to rotate the token if the token is older than 80 percent of its time to live or if the token is older than 24 hours.Defaults to 1 hour and must be at least 10 minutes.
   *
   * @default 1 hour and must be at least 10 minutes.
   * @schema RunnerSpecVolumesProjectedSourcesServiceAccountToken#expirationSeconds
   */
  readonly expirationSeconds?: number;

  /**
   * Path is the path relative to the mount point of the file to project the token into.
   *
   * @schema RunnerSpecVolumesProjectedSourcesServiceAccountToken#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'RunnerSpecVolumesProjectedSourcesServiceAccountToken' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecVolumesProjectedSourcesServiceAccountToken(obj: RunnerSpecVolumesProjectedSourcesServiceAccountToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audience': obj.audience,
    'expirationSeconds': obj.expirationSeconds,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema RunnerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface RunnerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema RunnerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema RunnerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
   *
   * @schema RunnerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'RunnerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(obj: RunnerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema RunnerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface RunnerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema RunnerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema RunnerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
   *
   * @schema RunnerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'RunnerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(obj: RunnerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema RunnerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface RunnerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema RunnerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema RunnerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
   *
   * @schema RunnerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'RunnerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(obj: RunnerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema RunnerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface RunnerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema RunnerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema RunnerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
   *
   * @schema RunnerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'RunnerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(obj: RunnerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 *
 * @schema RunnerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface RunnerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema RunnerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: RunnerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema RunnerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'RunnerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: RunnerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_RunnerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces. This field is beta-level and is only honored when PodAffinityNamespaceSelector feature is enabled.
 *
 * @schema RunnerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface RunnerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema RunnerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: RunnerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema RunnerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'RunnerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: RunnerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_RunnerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema RunnerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface RunnerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema RunnerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema RunnerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema RunnerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'RunnerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: RunnerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema RunnerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface RunnerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema RunnerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema RunnerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema RunnerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'RunnerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: RunnerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 *
 * @schema RunnerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface RunnerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema RunnerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: RunnerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema RunnerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'RunnerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: RunnerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_RunnerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces. This field is beta-level and is only honored when PodAffinityNamespaceSelector feature is enabled.
 *
 * @schema RunnerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface RunnerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema RunnerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: RunnerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema RunnerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'RunnerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: RunnerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_RunnerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema RunnerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface RunnerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema RunnerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema RunnerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema RunnerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'RunnerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: RunnerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema RunnerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface RunnerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema RunnerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema RunnerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema RunnerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'RunnerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: RunnerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema RunnerSpecContainersEnvValueFromResourceFieldRefDivisor
 */
export class RunnerSpecContainersEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(value: number): RunnerSpecContainersEnvValueFromResourceFieldRefDivisor {
    return new RunnerSpecContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): RunnerSpecContainersEnvValueFromResourceFieldRefDivisor {
    return new RunnerSpecContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RunnerSpecContainersLifecyclePostStartHttpGetHttpHeaders
 */
export interface RunnerSpecContainersLifecyclePostStartHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RunnerSpecContainersLifecyclePostStartHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RunnerSpecContainersLifecyclePostStartHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerSpecContainersLifecyclePostStartHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecContainersLifecyclePostStartHttpGetHttpHeaders(obj: RunnerSpecContainersLifecyclePostStartHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerSpecContainersLifecyclePostStartHttpGetPort
 */
export class RunnerSpecContainersLifecyclePostStartHttpGetPort {
  public static fromNumber(value: number): RunnerSpecContainersLifecyclePostStartHttpGetPort {
    return new RunnerSpecContainersLifecyclePostStartHttpGetPort(value);
  }
  public static fromString(value: string): RunnerSpecContainersLifecyclePostStartHttpGetPort {
    return new RunnerSpecContainersLifecyclePostStartHttpGetPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerSpecContainersLifecyclePostStartTcpSocketPort
 */
export class RunnerSpecContainersLifecyclePostStartTcpSocketPort {
  public static fromNumber(value: number): RunnerSpecContainersLifecyclePostStartTcpSocketPort {
    return new RunnerSpecContainersLifecyclePostStartTcpSocketPort(value);
  }
  public static fromString(value: string): RunnerSpecContainersLifecyclePostStartTcpSocketPort {
    return new RunnerSpecContainersLifecyclePostStartTcpSocketPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RunnerSpecContainersLifecyclePreStopHttpGetHttpHeaders
 */
export interface RunnerSpecContainersLifecyclePreStopHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RunnerSpecContainersLifecyclePreStopHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RunnerSpecContainersLifecyclePreStopHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerSpecContainersLifecyclePreStopHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecContainersLifecyclePreStopHttpGetHttpHeaders(obj: RunnerSpecContainersLifecyclePreStopHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerSpecContainersLifecyclePreStopHttpGetPort
 */
export class RunnerSpecContainersLifecyclePreStopHttpGetPort {
  public static fromNumber(value: number): RunnerSpecContainersLifecyclePreStopHttpGetPort {
    return new RunnerSpecContainersLifecyclePreStopHttpGetPort(value);
  }
  public static fromString(value: string): RunnerSpecContainersLifecyclePreStopHttpGetPort {
    return new RunnerSpecContainersLifecyclePreStopHttpGetPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerSpecContainersLifecyclePreStopTcpSocketPort
 */
export class RunnerSpecContainersLifecyclePreStopTcpSocketPort {
  public static fromNumber(value: number): RunnerSpecContainersLifecyclePreStopTcpSocketPort {
    return new RunnerSpecContainersLifecyclePreStopTcpSocketPort(value);
  }
  public static fromString(value: string): RunnerSpecContainersLifecyclePreStopTcpSocketPort {
    return new RunnerSpecContainersLifecyclePreStopTcpSocketPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema RunnerSpecEphemeralContainersEnvValueFromResourceFieldRefDivisor
 */
export class RunnerSpecEphemeralContainersEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(value: number): RunnerSpecEphemeralContainersEnvValueFromResourceFieldRefDivisor {
    return new RunnerSpecEphemeralContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): RunnerSpecEphemeralContainersEnvValueFromResourceFieldRefDivisor {
    return new RunnerSpecEphemeralContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RunnerSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders
 */
export interface RunnerSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RunnerSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RunnerSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders(obj: RunnerSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerSpecEphemeralContainersLifecyclePostStartHttpGetPort
 */
export class RunnerSpecEphemeralContainersLifecyclePostStartHttpGetPort {
  public static fromNumber(value: number): RunnerSpecEphemeralContainersLifecyclePostStartHttpGetPort {
    return new RunnerSpecEphemeralContainersLifecyclePostStartHttpGetPort(value);
  }
  public static fromString(value: string): RunnerSpecEphemeralContainersLifecyclePostStartHttpGetPort {
    return new RunnerSpecEphemeralContainersLifecyclePostStartHttpGetPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerSpecEphemeralContainersLifecyclePostStartTcpSocketPort
 */
export class RunnerSpecEphemeralContainersLifecyclePostStartTcpSocketPort {
  public static fromNumber(value: number): RunnerSpecEphemeralContainersLifecyclePostStartTcpSocketPort {
    return new RunnerSpecEphemeralContainersLifecyclePostStartTcpSocketPort(value);
  }
  public static fromString(value: string): RunnerSpecEphemeralContainersLifecyclePostStartTcpSocketPort {
    return new RunnerSpecEphemeralContainersLifecyclePostStartTcpSocketPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RunnerSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders
 */
export interface RunnerSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RunnerSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RunnerSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders(obj: RunnerSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerSpecEphemeralContainersLifecyclePreStopHttpGetPort
 */
export class RunnerSpecEphemeralContainersLifecyclePreStopHttpGetPort {
  public static fromNumber(value: number): RunnerSpecEphemeralContainersLifecyclePreStopHttpGetPort {
    return new RunnerSpecEphemeralContainersLifecyclePreStopHttpGetPort(value);
  }
  public static fromString(value: string): RunnerSpecEphemeralContainersLifecyclePreStopHttpGetPort {
    return new RunnerSpecEphemeralContainersLifecyclePreStopHttpGetPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerSpecEphemeralContainersLifecyclePreStopTcpSocketPort
 */
export class RunnerSpecEphemeralContainersLifecyclePreStopTcpSocketPort {
  public static fromNumber(value: number): RunnerSpecEphemeralContainersLifecyclePreStopTcpSocketPort {
    return new RunnerSpecEphemeralContainersLifecyclePreStopTcpSocketPort(value);
  }
  public static fromString(value: string): RunnerSpecEphemeralContainersLifecyclePreStopTcpSocketPort {
    return new RunnerSpecEphemeralContainersLifecyclePreStopTcpSocketPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema RunnerSpecInitContainersEnvValueFromResourceFieldRefDivisor
 */
export class RunnerSpecInitContainersEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(value: number): RunnerSpecInitContainersEnvValueFromResourceFieldRefDivisor {
    return new RunnerSpecInitContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): RunnerSpecInitContainersEnvValueFromResourceFieldRefDivisor {
    return new RunnerSpecInitContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RunnerSpecInitContainersLifecyclePostStartHttpGetHttpHeaders
 */
export interface RunnerSpecInitContainersLifecyclePostStartHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RunnerSpecInitContainersLifecyclePostStartHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RunnerSpecInitContainersLifecyclePostStartHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerSpecInitContainersLifecyclePostStartHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecInitContainersLifecyclePostStartHttpGetHttpHeaders(obj: RunnerSpecInitContainersLifecyclePostStartHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerSpecInitContainersLifecyclePostStartHttpGetPort
 */
export class RunnerSpecInitContainersLifecyclePostStartHttpGetPort {
  public static fromNumber(value: number): RunnerSpecInitContainersLifecyclePostStartHttpGetPort {
    return new RunnerSpecInitContainersLifecyclePostStartHttpGetPort(value);
  }
  public static fromString(value: string): RunnerSpecInitContainersLifecyclePostStartHttpGetPort {
    return new RunnerSpecInitContainersLifecyclePostStartHttpGetPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerSpecInitContainersLifecyclePostStartTcpSocketPort
 */
export class RunnerSpecInitContainersLifecyclePostStartTcpSocketPort {
  public static fromNumber(value: number): RunnerSpecInitContainersLifecyclePostStartTcpSocketPort {
    return new RunnerSpecInitContainersLifecyclePostStartTcpSocketPort(value);
  }
  public static fromString(value: string): RunnerSpecInitContainersLifecyclePostStartTcpSocketPort {
    return new RunnerSpecInitContainersLifecyclePostStartTcpSocketPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RunnerSpecInitContainersLifecyclePreStopHttpGetHttpHeaders
 */
export interface RunnerSpecInitContainersLifecyclePreStopHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RunnerSpecInitContainersLifecyclePreStopHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RunnerSpecInitContainersLifecyclePreStopHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerSpecInitContainersLifecyclePreStopHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecInitContainersLifecyclePreStopHttpGetHttpHeaders(obj: RunnerSpecInitContainersLifecyclePreStopHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerSpecInitContainersLifecyclePreStopHttpGetPort
 */
export class RunnerSpecInitContainersLifecyclePreStopHttpGetPort {
  public static fromNumber(value: number): RunnerSpecInitContainersLifecyclePreStopHttpGetPort {
    return new RunnerSpecInitContainersLifecyclePreStopHttpGetPort(value);
  }
  public static fromString(value: string): RunnerSpecInitContainersLifecyclePreStopHttpGetPort {
    return new RunnerSpecInitContainersLifecyclePreStopHttpGetPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerSpecInitContainersLifecyclePreStopTcpSocketPort
 */
export class RunnerSpecInitContainersLifecyclePreStopTcpSocketPort {
  public static fromNumber(value: number): RunnerSpecInitContainersLifecyclePreStopTcpSocketPort {
    return new RunnerSpecInitContainersLifecyclePreStopTcpSocketPort(value);
  }
  public static fromString(value: string): RunnerSpecInitContainersLifecyclePreStopTcpSocketPort {
    return new RunnerSpecInitContainersLifecyclePreStopTcpSocketPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema RunnerSpecSidecarContainersEnvValueFromResourceFieldRefDivisor
 */
export class RunnerSpecSidecarContainersEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(value: number): RunnerSpecSidecarContainersEnvValueFromResourceFieldRefDivisor {
    return new RunnerSpecSidecarContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): RunnerSpecSidecarContainersEnvValueFromResourceFieldRefDivisor {
    return new RunnerSpecSidecarContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RunnerSpecSidecarContainersLifecyclePostStartHttpGetHttpHeaders
 */
export interface RunnerSpecSidecarContainersLifecyclePostStartHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RunnerSpecSidecarContainersLifecyclePostStartHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RunnerSpecSidecarContainersLifecyclePostStartHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerSpecSidecarContainersLifecyclePostStartHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecSidecarContainersLifecyclePostStartHttpGetHttpHeaders(obj: RunnerSpecSidecarContainersLifecyclePostStartHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerSpecSidecarContainersLifecyclePostStartHttpGetPort
 */
export class RunnerSpecSidecarContainersLifecyclePostStartHttpGetPort {
  public static fromNumber(value: number): RunnerSpecSidecarContainersLifecyclePostStartHttpGetPort {
    return new RunnerSpecSidecarContainersLifecyclePostStartHttpGetPort(value);
  }
  public static fromString(value: string): RunnerSpecSidecarContainersLifecyclePostStartHttpGetPort {
    return new RunnerSpecSidecarContainersLifecyclePostStartHttpGetPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerSpecSidecarContainersLifecyclePostStartTcpSocketPort
 */
export class RunnerSpecSidecarContainersLifecyclePostStartTcpSocketPort {
  public static fromNumber(value: number): RunnerSpecSidecarContainersLifecyclePostStartTcpSocketPort {
    return new RunnerSpecSidecarContainersLifecyclePostStartTcpSocketPort(value);
  }
  public static fromString(value: string): RunnerSpecSidecarContainersLifecyclePostStartTcpSocketPort {
    return new RunnerSpecSidecarContainersLifecyclePostStartTcpSocketPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RunnerSpecSidecarContainersLifecyclePreStopHttpGetHttpHeaders
 */
export interface RunnerSpecSidecarContainersLifecyclePreStopHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RunnerSpecSidecarContainersLifecyclePreStopHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RunnerSpecSidecarContainersLifecyclePreStopHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerSpecSidecarContainersLifecyclePreStopHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecSidecarContainersLifecyclePreStopHttpGetHttpHeaders(obj: RunnerSpecSidecarContainersLifecyclePreStopHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerSpecSidecarContainersLifecyclePreStopHttpGetPort
 */
export class RunnerSpecSidecarContainersLifecyclePreStopHttpGetPort {
  public static fromNumber(value: number): RunnerSpecSidecarContainersLifecyclePreStopHttpGetPort {
    return new RunnerSpecSidecarContainersLifecyclePreStopHttpGetPort(value);
  }
  public static fromString(value: string): RunnerSpecSidecarContainersLifecyclePreStopHttpGetPort {
    return new RunnerSpecSidecarContainersLifecyclePreStopHttpGetPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerSpecSidecarContainersLifecyclePreStopTcpSocketPort
 */
export class RunnerSpecSidecarContainersLifecyclePreStopTcpSocketPort {
  public static fromNumber(value: number): RunnerSpecSidecarContainersLifecyclePreStopTcpSocketPort {
    return new RunnerSpecSidecarContainersLifecyclePreStopTcpSocketPort(value);
  }
  public static fromString(value: string): RunnerSpecSidecarContainersLifecyclePreStopTcpSocketPort {
    return new RunnerSpecSidecarContainersLifecyclePreStopTcpSocketPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema RunnerSpecVolumesDownwardApiItemsResourceFieldRefDivisor
 */
export class RunnerSpecVolumesDownwardApiItemsResourceFieldRefDivisor {
  public static fromNumber(value: number): RunnerSpecVolumesDownwardApiItemsResourceFieldRefDivisor {
    return new RunnerSpecVolumesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): RunnerSpecVolumesDownwardApiItemsResourceFieldRefDivisor {
    return new RunnerSpecVolumesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * This field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. If the AnyVolumeDataSource feature gate is enabled, this field will always have the same contents as the DataSourceRef field.
 *
 * @schema RunnerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource
 */
export interface RunnerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource {
  /**
   * APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
   *
   * @schema RunnerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema RunnerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema RunnerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RunnerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource(obj: RunnerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any local object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the DataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, both fields (DataSource and DataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. There are two important differences between DataSource and DataSourceRef: * While DataSource only allows two specific types of objects, DataSourceRef   allows any non-core object, as well as PersistentVolumeClaim objects. * While DataSource ignores disallowed values (dropping them), DataSourceRef   preserves all values, and generates an error if a disallowed value is   specified. (Alpha) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
 *
 * @schema RunnerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef
 */
export interface RunnerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef {
  /**
   * APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
   *
   * @schema RunnerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema RunnerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema RunnerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RunnerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef(obj: RunnerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
 *
 * @schema RunnerSpecVolumesEphemeralVolumeClaimTemplateSpecResources
 */
export interface RunnerSpecVolumesEphemeralVolumeClaimTemplateSpecResources {
  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema RunnerSpecVolumesEphemeralVolumeClaimTemplateSpecResources#limits
   */
  readonly limits?: { [key: string]: RunnerSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema RunnerSpecVolumesEphemeralVolumeClaimTemplateSpecResources#requests
   */
  readonly requests?: { [key: string]: RunnerSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests };

}

/**
 * Converts an object of type 'RunnerSpecVolumesEphemeralVolumeClaimTemplateSpecResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecVolumesEphemeralVolumeClaimTemplateSpecResources(obj: RunnerSpecVolumesEphemeralVolumeClaimTemplateSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over volumes to consider for binding.
 *
 * @schema RunnerSpecVolumesEphemeralVolumeClaimTemplateSpecSelector
 */
export interface RunnerSpecVolumesEphemeralVolumeClaimTemplateSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema RunnerSpecVolumesEphemeralVolumeClaimTemplateSpecSelector#matchExpressions
   */
  readonly matchExpressions?: RunnerSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema RunnerSpecVolumesEphemeralVolumeClaimTemplateSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'RunnerSpecVolumesEphemeralVolumeClaimTemplateSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecVolumesEphemeralVolumeClaimTemplateSpecSelector(obj: RunnerSpecVolumesEphemeralVolumeClaimTemplateSpecSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_RunnerSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema RunnerSpecVolumesProjectedSourcesConfigMapItems
 */
export interface RunnerSpecVolumesProjectedSourcesConfigMapItems {
  /**
   * The key to project.
   *
   * @schema RunnerSpecVolumesProjectedSourcesConfigMapItems#key
   */
  readonly key: string;

  /**
   * Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema RunnerSpecVolumesProjectedSourcesConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema RunnerSpecVolumesProjectedSourcesConfigMapItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'RunnerSpecVolumesProjectedSourcesConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecVolumesProjectedSourcesConfigMapItems(obj: RunnerSpecVolumesProjectedSourcesConfigMapItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DownwardAPIVolumeFile represents information to create the file containing the pod field
 *
 * @schema RunnerSpecVolumesProjectedSourcesDownwardApiItems
 */
export interface RunnerSpecVolumesProjectedSourcesDownwardApiItems {
  /**
   * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
   *
   * @schema RunnerSpecVolumesProjectedSourcesDownwardApiItems#fieldRef
   */
  readonly fieldRef?: RunnerSpecVolumesProjectedSourcesDownwardApiItemsFieldRef;

  /**
   * Optional: mode bits used to set permissions on this file, must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema RunnerSpecVolumesProjectedSourcesDownwardApiItems#mode
   */
  readonly mode?: number;

  /**
   * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
   *
   * @schema RunnerSpecVolumesProjectedSourcesDownwardApiItems#path
   */
  readonly path: string;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
   *
   * @schema RunnerSpecVolumesProjectedSourcesDownwardApiItems#resourceFieldRef
   */
  readonly resourceFieldRef?: RunnerSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef;

}

/**
 * Converts an object of type 'RunnerSpecVolumesProjectedSourcesDownwardApiItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecVolumesProjectedSourcesDownwardApiItems(obj: RunnerSpecVolumesProjectedSourcesDownwardApiItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fieldRef': toJson_RunnerSpecVolumesProjectedSourcesDownwardApiItemsFieldRef(obj.fieldRef),
    'mode': obj.mode,
    'path': obj.path,
    'resourceFieldRef': toJson_RunnerSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef(obj.resourceFieldRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema RunnerSpecVolumesProjectedSourcesSecretItems
 */
export interface RunnerSpecVolumesProjectedSourcesSecretItems {
  /**
   * The key to project.
   *
   * @schema RunnerSpecVolumesProjectedSourcesSecretItems#key
   */
  readonly key: string;

  /**
   * Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema RunnerSpecVolumesProjectedSourcesSecretItems#mode
   */
  readonly mode?: number;

  /**
   * The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema RunnerSpecVolumesProjectedSourcesSecretItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'RunnerSpecVolumesProjectedSourcesSecretItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecVolumesProjectedSourcesSecretItems(obj: RunnerSpecVolumesProjectedSourcesSecretItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema RunnerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface RunnerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema RunnerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema RunnerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema RunnerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'RunnerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: RunnerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema RunnerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface RunnerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema RunnerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema RunnerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema RunnerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'RunnerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: RunnerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema RunnerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface RunnerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema RunnerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema RunnerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema RunnerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'RunnerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: RunnerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema RunnerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface RunnerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema RunnerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema RunnerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema RunnerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'RunnerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: RunnerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RunnerSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits
 */
export class RunnerSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
  public static fromNumber(value: number): RunnerSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new RunnerSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits(value);
  }
  public static fromString(value: string): RunnerSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new RunnerSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * @schema RunnerSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests
 */
export class RunnerSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
  public static fromNumber(value: number): RunnerSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new RunnerSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests(value);
  }
  public static fromString(value: string): RunnerSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new RunnerSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema RunnerSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions
 */
export interface RunnerSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema RunnerSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema RunnerSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema RunnerSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'RunnerSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(obj: RunnerSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
 *
 * @schema RunnerSpecVolumesProjectedSourcesDownwardApiItemsFieldRef
 */
export interface RunnerSpecVolumesProjectedSourcesDownwardApiItemsFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema RunnerSpecVolumesProjectedSourcesDownwardApiItemsFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema RunnerSpecVolumesProjectedSourcesDownwardApiItemsFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'RunnerSpecVolumesProjectedSourcesDownwardApiItemsFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecVolumesProjectedSourcesDownwardApiItemsFieldRef(obj: RunnerSpecVolumesProjectedSourcesDownwardApiItemsFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
 *
 * @schema RunnerSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef
 */
export interface RunnerSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema RunnerSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema RunnerSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#divisor
   */
  readonly divisor?: RunnerSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema RunnerSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'RunnerSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef(obj: RunnerSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema RunnerSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor
 */
export class RunnerSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
  public static fromNumber(value: number): RunnerSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
    return new RunnerSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): RunnerSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
    return new RunnerSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: any) {
  }
}


/**
 * RunnerDeployment is the Schema for the runnerdeployments API
 *
 * @schema RunnerDeployment
 */
export class RunnerDeployment extends ApiObject {
  /**
   * Returns the apiVersion and kind for "RunnerDeployment"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'actions.summerwind.dev/v1alpha1',
    kind: 'RunnerDeployment',
  }

  /**
   * Renders a Kubernetes manifest for "RunnerDeployment".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: RunnerDeploymentProps = {}): any {
    return {
      ...RunnerDeployment.GVK,
      ...toJson_RunnerDeploymentProps(props),
    };
  }

  /**
   * Defines a "RunnerDeployment" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: RunnerDeploymentProps = {}) {
    super(scope, id, {
      ...RunnerDeployment.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...RunnerDeployment.GVK,
      ...toJson_RunnerDeploymentProps(resolved),
    };
  }
}

/**
 * RunnerDeployment is the Schema for the runnerdeployments API
 *
 * @schema RunnerDeployment
 */
export interface RunnerDeploymentProps {
  /**
   * @schema RunnerDeployment#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * RunnerDeploymentSpec defines the desired state of RunnerDeployment
   *
   * @schema RunnerDeployment#spec
   */
  readonly spec?: RunnerDeploymentSpec;

}

/**
 * Converts an object of type 'RunnerDeploymentProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentProps(obj: RunnerDeploymentProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_RunnerDeploymentSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RunnerDeploymentSpec defines the desired state of RunnerDeployment
 *
 * @schema RunnerDeploymentSpec
 */
export interface RunnerDeploymentSpec {
  /**
   * EffectiveTime is the time the upstream controller requested to sync Replicas. It is usually populated by the webhook-based autoscaler via HRA. The value is inherited to RunnerRepicaSet(s) and used to prevent ephemeral runners from unnecessarily recreated.
   *
   * @schema RunnerDeploymentSpec#effectiveTime
   */
  readonly effectiveTime?: Date;

  /**
   * @schema RunnerDeploymentSpec#replicas
   */
  readonly replicas?: number;

  /**
   * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
   *
   * @schema RunnerDeploymentSpec#selector
   */
  readonly selector?: RunnerDeploymentSpecSelector;

  /**
   * @schema RunnerDeploymentSpec#template
   */
  readonly template: RunnerDeploymentSpecTemplate;

}

/**
 * Converts an object of type 'RunnerDeploymentSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpec(obj: RunnerDeploymentSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effectiveTime': obj.effectiveTime?.toISOString(),
    'replicas': obj.replicas,
    'selector': toJson_RunnerDeploymentSpecSelector(obj.selector),
    'template': toJson_RunnerDeploymentSpecTemplate(obj.template),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
 *
 * @schema RunnerDeploymentSpecSelector
 */
export interface RunnerDeploymentSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema RunnerDeploymentSpecSelector#matchExpressions
   */
  readonly matchExpressions?: RunnerDeploymentSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema RunnerDeploymentSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'RunnerDeploymentSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecSelector(obj: RunnerDeploymentSpecSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_RunnerDeploymentSpecSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RunnerDeploymentSpecTemplate
 */
export interface RunnerDeploymentSpecTemplate {
  /**
   * @schema RunnerDeploymentSpecTemplate#metadata
   */
  readonly metadata?: RunnerDeploymentSpecTemplateMetadata;

  /**
   * RunnerSpec defines the desired state of Runner
   *
   * @schema RunnerDeploymentSpecTemplate#spec
   */
  readonly spec?: RunnerDeploymentSpecTemplateSpec;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplate(obj: RunnerDeploymentSpecTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_RunnerDeploymentSpecTemplateMetadata(obj.metadata),
    'spec': toJson_RunnerDeploymentSpecTemplateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema RunnerDeploymentSpecSelectorMatchExpressions
 */
export interface RunnerDeploymentSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema RunnerDeploymentSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema RunnerDeploymentSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema RunnerDeploymentSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'RunnerDeploymentSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecSelectorMatchExpressions(obj: RunnerDeploymentSpecSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RunnerDeploymentSpecTemplateMetadata
 */
export interface RunnerDeploymentSpecTemplateMetadata {
  /**
   * @schema RunnerDeploymentSpecTemplateMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * @schema RunnerDeploymentSpecTemplateMetadata#finalizers
   */
  readonly finalizers?: string[];

  /**
   * @schema RunnerDeploymentSpecTemplateMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * @schema RunnerDeploymentSpecTemplateMetadata#name
   */
  readonly name?: string;

  /**
   * @schema RunnerDeploymentSpecTemplateMetadata#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateMetadata(obj: RunnerDeploymentSpecTemplateMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'finalizers': obj.finalizers?.map(y => y),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RunnerSpec defines the desired state of Runner
 *
 * @schema RunnerDeploymentSpecTemplateSpec
 */
export interface RunnerDeploymentSpecTemplateSpec {
  /**
   * Affinity is a group of affinity scheduling rules.
   *
   * @schema RunnerDeploymentSpecTemplateSpec#affinity
   */
  readonly affinity?: RunnerDeploymentSpecTemplateSpecAffinity;

  /**
   * @schema RunnerDeploymentSpecTemplateSpec#automountServiceAccountToken
   */
  readonly automountServiceAccountToken?: boolean;

  /**
   * @schema RunnerDeploymentSpecTemplateSpec#containers
   */
  readonly containers?: RunnerDeploymentSpecTemplateSpecContainers[];

  /**
   * @schema RunnerDeploymentSpecTemplateSpec#dnsConfig
   */
  readonly dnsConfig?: RunnerDeploymentSpecTemplateSpecDnsConfig[];

  /**
   * @schema RunnerDeploymentSpecTemplateSpec#dockerEnabled
   */
  readonly dockerEnabled?: boolean;

  /**
   * @schema RunnerDeploymentSpecTemplateSpec#dockerEnv
   */
  readonly dockerEnv?: RunnerDeploymentSpecTemplateSpecDockerEnv[];

  /**
   * @schema RunnerDeploymentSpecTemplateSpec#dockerMTU
   */
  readonly dockerMtu?: number;

  /**
   * @schema RunnerDeploymentSpecTemplateSpec#dockerRegistryMirror
   */
  readonly dockerRegistryMirror?: string;

  /**
   * @schema RunnerDeploymentSpecTemplateSpec#dockerVolumeMounts
   */
  readonly dockerVolumeMounts?: RunnerDeploymentSpecTemplateSpecDockerVolumeMounts[];

  /**
   * ResourceRequirements describes the compute resource requirements.
   *
   * @schema RunnerDeploymentSpecTemplateSpec#dockerdContainerResources
   */
  readonly dockerdContainerResources?: RunnerDeploymentSpecTemplateSpecDockerdContainerResources;

  /**
   * @schema RunnerDeploymentSpecTemplateSpec#dockerdWithinRunnerContainer
   */
  readonly dockerdWithinRunnerContainer?: boolean;

  /**
   * @schema RunnerDeploymentSpecTemplateSpec#enableServiceLinks
   */
  readonly enableServiceLinks?: boolean;

  /**
   * @schema RunnerDeploymentSpecTemplateSpec#enterprise
   */
  readonly enterprise?: string;

  /**
   * @schema RunnerDeploymentSpecTemplateSpec#env
   */
  readonly env?: RunnerDeploymentSpecTemplateSpecEnv[];

  /**
   * @schema RunnerDeploymentSpecTemplateSpec#envFrom
   */
  readonly envFrom?: RunnerDeploymentSpecTemplateSpecEnvFrom[];

  /**
   * @schema RunnerDeploymentSpecTemplateSpec#ephemeral
   */
  readonly ephemeral?: boolean;

  /**
   * @schema RunnerDeploymentSpecTemplateSpec#ephemeralContainers
   */
  readonly ephemeralContainers?: RunnerDeploymentSpecTemplateSpecEphemeralContainers[];

  /**
   * @schema RunnerDeploymentSpecTemplateSpec#group
   */
  readonly group?: string;

  /**
   * @schema RunnerDeploymentSpecTemplateSpec#hostAliases
   */
  readonly hostAliases?: RunnerDeploymentSpecTemplateSpecHostAliases[];

  /**
   * @schema RunnerDeploymentSpecTemplateSpec#image
   */
  readonly image?: string;

  /**
   * PullPolicy describes a policy for if/when to pull a container image
   *
   * @schema RunnerDeploymentSpecTemplateSpec#imagePullPolicy
   */
  readonly imagePullPolicy?: string;

  /**
   * @schema RunnerDeploymentSpecTemplateSpec#imagePullSecrets
   */
  readonly imagePullSecrets?: RunnerDeploymentSpecTemplateSpecImagePullSecrets[];

  /**
   * @schema RunnerDeploymentSpecTemplateSpec#initContainers
   */
  readonly initContainers?: RunnerDeploymentSpecTemplateSpecInitContainers[];

  /**
   * @schema RunnerDeploymentSpecTemplateSpec#labels
   */
  readonly labels?: string[];

  /**
   * @schema RunnerDeploymentSpecTemplateSpec#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * @schema RunnerDeploymentSpecTemplateSpec#organization
   */
  readonly organization?: string;

  /**
   * @schema RunnerDeploymentSpecTemplateSpec#repository
   */
  readonly repository?: string;

  /**
   * ResourceRequirements describes the compute resource requirements.
   *
   * @schema RunnerDeploymentSpecTemplateSpec#resources
   */
  readonly resources?: RunnerDeploymentSpecTemplateSpecResources;

  /**
   * RuntimeClassName is the container runtime configuration that containers should run under. More info: https://kubernetes.io/docs/concepts/containers/runtime-class
   *
   * @schema RunnerDeploymentSpecTemplateSpec#runtimeClassName
   */
  readonly runtimeClassName?: string;

  /**
   * PodSecurityContext holds pod-level security attributes and common container settings. Some fields are also present in container.securityContext.  Field values of container.securityContext take precedence over field values of PodSecurityContext.
   *
   * @schema RunnerDeploymentSpecTemplateSpec#securityContext
   */
  readonly securityContext?: RunnerDeploymentSpecTemplateSpecSecurityContext;

  /**
   * @schema RunnerDeploymentSpecTemplateSpec#serviceAccountName
   */
  readonly serviceAccountName?: string;

  /**
   * @schema RunnerDeploymentSpecTemplateSpec#sidecarContainers
   */
  readonly sidecarContainers?: RunnerDeploymentSpecTemplateSpecSidecarContainers[];

  /**
   * @schema RunnerDeploymentSpecTemplateSpec#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * @schema RunnerDeploymentSpecTemplateSpec#tolerations
   */
  readonly tolerations?: RunnerDeploymentSpecTemplateSpecTolerations[];

  /**
   * @schema RunnerDeploymentSpecTemplateSpec#topologySpreadConstraint
   */
  readonly topologySpreadConstraint?: RunnerDeploymentSpecTemplateSpecTopologySpreadConstraint[];

  /**
   * @schema RunnerDeploymentSpecTemplateSpec#volumeMounts
   */
  readonly volumeMounts?: RunnerDeploymentSpecTemplateSpecVolumeMounts[];

  /**
   * @schema RunnerDeploymentSpecTemplateSpec#volumeSizeLimit
   */
  readonly volumeSizeLimit?: RunnerDeploymentSpecTemplateSpecVolumeSizeLimit;

  /**
   * @schema RunnerDeploymentSpecTemplateSpec#volumeStorageMedium
   */
  readonly volumeStorageMedium?: string;

  /**
   * @schema RunnerDeploymentSpecTemplateSpec#volumes
   */
  readonly volumes?: RunnerDeploymentSpecTemplateSpecVolumes[];

  /**
   * @schema RunnerDeploymentSpecTemplateSpec#workDir
   */
  readonly workDir?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpec(obj: RunnerDeploymentSpecTemplateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'affinity': toJson_RunnerDeploymentSpecTemplateSpecAffinity(obj.affinity),
    'automountServiceAccountToken': obj.automountServiceAccountToken,
    'containers': obj.containers?.map(y => toJson_RunnerDeploymentSpecTemplateSpecContainers(y)),
    'dnsConfig': obj.dnsConfig?.map(y => toJson_RunnerDeploymentSpecTemplateSpecDnsConfig(y)),
    'dockerEnabled': obj.dockerEnabled,
    'dockerEnv': obj.dockerEnv?.map(y => toJson_RunnerDeploymentSpecTemplateSpecDockerEnv(y)),
    'dockerMTU': obj.dockerMtu,
    'dockerRegistryMirror': obj.dockerRegistryMirror,
    'dockerVolumeMounts': obj.dockerVolumeMounts?.map(y => toJson_RunnerDeploymentSpecTemplateSpecDockerVolumeMounts(y)),
    'dockerdContainerResources': toJson_RunnerDeploymentSpecTemplateSpecDockerdContainerResources(obj.dockerdContainerResources),
    'dockerdWithinRunnerContainer': obj.dockerdWithinRunnerContainer,
    'enableServiceLinks': obj.enableServiceLinks,
    'enterprise': obj.enterprise,
    'env': obj.env?.map(y => toJson_RunnerDeploymentSpecTemplateSpecEnv(y)),
    'envFrom': obj.envFrom?.map(y => toJson_RunnerDeploymentSpecTemplateSpecEnvFrom(y)),
    'ephemeral': obj.ephemeral,
    'ephemeralContainers': obj.ephemeralContainers?.map(y => toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainers(y)),
    'group': obj.group,
    'hostAliases': obj.hostAliases?.map(y => toJson_RunnerDeploymentSpecTemplateSpecHostAliases(y)),
    'image': obj.image,
    'imagePullPolicy': obj.imagePullPolicy,
    'imagePullSecrets': obj.imagePullSecrets?.map(y => toJson_RunnerDeploymentSpecTemplateSpecImagePullSecrets(y)),
    'initContainers': obj.initContainers?.map(y => toJson_RunnerDeploymentSpecTemplateSpecInitContainers(y)),
    'labels': obj.labels?.map(y => y),
    'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'organization': obj.organization,
    'repository': obj.repository,
    'resources': toJson_RunnerDeploymentSpecTemplateSpecResources(obj.resources),
    'runtimeClassName': obj.runtimeClassName,
    'securityContext': toJson_RunnerDeploymentSpecTemplateSpecSecurityContext(obj.securityContext),
    'serviceAccountName': obj.serviceAccountName,
    'sidecarContainers': obj.sidecarContainers?.map(y => toJson_RunnerDeploymentSpecTemplateSpecSidecarContainers(y)),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'tolerations': obj.tolerations?.map(y => toJson_RunnerDeploymentSpecTemplateSpecTolerations(y)),
    'topologySpreadConstraint': obj.topologySpreadConstraint?.map(y => toJson_RunnerDeploymentSpecTemplateSpecTopologySpreadConstraint(y)),
    'volumeMounts': obj.volumeMounts?.map(y => toJson_RunnerDeploymentSpecTemplateSpecVolumeMounts(y)),
    'volumeSizeLimit': obj.volumeSizeLimit?.value,
    'volumeStorageMedium': obj.volumeStorageMedium,
    'volumes': obj.volumes?.map(y => toJson_RunnerDeploymentSpecTemplateSpecVolumes(y)),
    'workDir': obj.workDir,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Affinity is a group of affinity scheduling rules.
 *
 * @schema RunnerDeploymentSpecTemplateSpecAffinity
 */
export interface RunnerDeploymentSpecTemplateSpecAffinity {
  /**
   * Describes node affinity scheduling rules for the pod.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinity#nodeAffinity
   */
  readonly nodeAffinity?: RunnerDeploymentSpecTemplateSpecAffinityNodeAffinity;

  /**
   * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinity#podAffinity
   */
  readonly podAffinity?: RunnerDeploymentSpecTemplateSpecAffinityPodAffinity;

  /**
   * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinity;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecAffinity(obj: RunnerDeploymentSpecTemplateSpecAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeAffinity': toJson_RunnerDeploymentSpecTemplateSpecAffinityNodeAffinity(obj.nodeAffinity),
    'podAffinity': toJson_RunnerDeploymentSpecTemplateSpecAffinityPodAffinity(obj.podAffinity),
    'podAntiAffinity': toJson_RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinity(obj.podAntiAffinity),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A single application container that you want to run within a pod.
 *
 * @schema RunnerDeploymentSpecTemplateSpecContainers
 */
export interface RunnerDeploymentSpecTemplateSpecContainers {
  /**
   * Arguments to the entrypoint. The docker image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainers#args
   */
  readonly args?: string[];

  /**
   * Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainers#command
   */
  readonly command?: string[];

  /**
   * List of environment variables to set in the container. Cannot be updated.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainers#env
   */
  readonly env?: RunnerDeploymentSpecTemplateSpecContainersEnv[];

  /**
   * List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainers#envFrom
   */
  readonly envFrom?: RunnerDeploymentSpecTemplateSpecContainersEnvFrom[];

  /**
   * Docker image name. More info: https://kubernetes.io/docs/concepts/containers/images This field is optional to allow higher level config management to default or override container images in workload controllers like Deployments and StatefulSets.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainers#image
   */
  readonly image?: string;

  /**
   * Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   *
   * @default Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   * @schema RunnerDeploymentSpecTemplateSpecContainers#imagePullPolicy
   */
  readonly imagePullPolicy?: string;

  /**
   * Actions that the management system should take in response to container lifecycle events. Cannot be updated.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainers#lifecycle
   */
  readonly lifecycle?: RunnerDeploymentSpecTemplateSpecContainersLifecycle;

  /**
   * Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainers#livenessProbe
   */
  readonly livenessProbe?: RunnerDeploymentSpecTemplateSpecContainersLivenessProbe;

  /**
   * Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainers#name
   */
  readonly name: string;

  /**
   * List of ports to expose from the container. Exposing a port here gives the system additional information about the network connections a container uses, but is primarily informational. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default "0.0.0.0" address inside a container will be accessible from the network. Cannot be updated.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainers#ports
   */
  readonly ports?: RunnerDeploymentSpecTemplateSpecContainersPorts[];

  /**
   * Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainers#readinessProbe
   */
  readonly readinessProbe?: RunnerDeploymentSpecTemplateSpecContainersReadinessProbe;

  /**
   * Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainers#resources
   */
  readonly resources?: RunnerDeploymentSpecTemplateSpecContainersResources;

  /**
   * SecurityContext defines the security options the container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainers#securityContext
   */
  readonly securityContext?: RunnerDeploymentSpecTemplateSpecContainersSecurityContext;

  /**
   * StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainers#startupProbe
   */
  readonly startupProbe?: RunnerDeploymentSpecTemplateSpecContainersStartupProbe;

  /**
   * Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF. Default is false.
   *
   * @default false.
   * @schema RunnerDeploymentSpecTemplateSpecContainers#stdin
   */
  readonly stdin?: boolean;

  /**
   * Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false
   *
   * @default false
   * @schema RunnerDeploymentSpecTemplateSpecContainers#stdinOnce
   */
  readonly stdinOnce?: boolean;

  /**
   * Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Will be truncated by the node if greater than 4096 bytes. The total message length across all containers will be limited to 12kb. Defaults to /dev/termination-log. Cannot be updated.
   *
   * @default dev/termination-log. Cannot be updated.
   * @schema RunnerDeploymentSpecTemplateSpecContainers#terminationMessagePath
   */
  readonly terminationMessagePath?: string;

  /**
   * Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.
   *
   * @default File. Cannot be updated.
   * @schema RunnerDeploymentSpecTemplateSpecContainers#terminationMessagePolicy
   */
  readonly terminationMessagePolicy?: string;

  /**
   * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true. Default is false.
   *
   * @default false.
   * @schema RunnerDeploymentSpecTemplateSpecContainers#tty
   */
  readonly tty?: boolean;

  /**
   * volumeDevices is the list of block devices to be used by the container.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainers#volumeDevices
   */
  readonly volumeDevices?: RunnerDeploymentSpecTemplateSpecContainersVolumeDevices[];

  /**
   * Pod volumes to mount into the container's filesystem. Cannot be updated.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainers#volumeMounts
   */
  readonly volumeMounts?: RunnerDeploymentSpecTemplateSpecContainersVolumeMounts[];

  /**
   * Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainers#workingDir
   */
  readonly workingDir?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecContainers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecContainers(obj: RunnerDeploymentSpecTemplateSpecContainers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'args': obj.args?.map(y => y),
    'command': obj.command?.map(y => y),
    'env': obj.env?.map(y => toJson_RunnerDeploymentSpecTemplateSpecContainersEnv(y)),
    'envFrom': obj.envFrom?.map(y => toJson_RunnerDeploymentSpecTemplateSpecContainersEnvFrom(y)),
    'image': obj.image,
    'imagePullPolicy': obj.imagePullPolicy,
    'lifecycle': toJson_RunnerDeploymentSpecTemplateSpecContainersLifecycle(obj.lifecycle),
    'livenessProbe': toJson_RunnerDeploymentSpecTemplateSpecContainersLivenessProbe(obj.livenessProbe),
    'name': obj.name,
    'ports': obj.ports?.map(y => toJson_RunnerDeploymentSpecTemplateSpecContainersPorts(y)),
    'readinessProbe': toJson_RunnerDeploymentSpecTemplateSpecContainersReadinessProbe(obj.readinessProbe),
    'resources': toJson_RunnerDeploymentSpecTemplateSpecContainersResources(obj.resources),
    'securityContext': toJson_RunnerDeploymentSpecTemplateSpecContainersSecurityContext(obj.securityContext),
    'startupProbe': toJson_RunnerDeploymentSpecTemplateSpecContainersStartupProbe(obj.startupProbe),
    'stdin': obj.stdin,
    'stdinOnce': obj.stdinOnce,
    'terminationMessagePath': obj.terminationMessagePath,
    'terminationMessagePolicy': obj.terminationMessagePolicy,
    'tty': obj.tty,
    'volumeDevices': obj.volumeDevices?.map(y => toJson_RunnerDeploymentSpecTemplateSpecContainersVolumeDevices(y)),
    'volumeMounts': obj.volumeMounts?.map(y => toJson_RunnerDeploymentSpecTemplateSpecContainersVolumeMounts(y)),
    'workingDir': obj.workingDir,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PodDNSConfig defines the DNS parameters of a pod in addition to those generated from DNSPolicy.
 *
 * @schema RunnerDeploymentSpecTemplateSpecDnsConfig
 */
export interface RunnerDeploymentSpecTemplateSpecDnsConfig {
  /**
   * A list of DNS name server IP addresses. This will be appended to the base nameservers generated from DNSPolicy. Duplicated nameservers will be removed.
   *
   * @schema RunnerDeploymentSpecTemplateSpecDnsConfig#nameservers
   */
  readonly nameservers?: string[];

  /**
   * A list of DNS resolver options. This will be merged with the base options generated from DNSPolicy. Duplicated entries will be removed. Resolution options given in Options will override those that appear in the base DNSPolicy.
   *
   * @schema RunnerDeploymentSpecTemplateSpecDnsConfig#options
   */
  readonly options?: RunnerDeploymentSpecTemplateSpecDnsConfigOptions[];

  /**
   * A list of DNS search domains for host-name lookup. This will be appended to the base search paths generated from DNSPolicy. Duplicated search paths will be removed.
   *
   * @schema RunnerDeploymentSpecTemplateSpecDnsConfig#searches
   */
  readonly searches?: string[];

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecDnsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecDnsConfig(obj: RunnerDeploymentSpecTemplateSpecDnsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nameservers': obj.nameservers?.map(y => y),
    'options': obj.options?.map(y => toJson_RunnerDeploymentSpecTemplateSpecDnsConfigOptions(y)),
    'searches': obj.searches?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema RunnerDeploymentSpecTemplateSpecDockerEnv
 */
export interface RunnerDeploymentSpecTemplateSpecDockerEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema RunnerDeploymentSpecTemplateSpecDockerEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded using the previously defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
   *
   * @default .
   * @schema RunnerDeploymentSpecTemplateSpecDockerEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema RunnerDeploymentSpecTemplateSpecDockerEnv#valueFrom
   */
  readonly valueFrom?: RunnerDeploymentSpecTemplateSpecDockerEnvValueFrom;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecDockerEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecDockerEnv(obj: RunnerDeploymentSpecTemplateSpecDockerEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
    'valueFrom': toJson_RunnerDeploymentSpecTemplateSpecDockerEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema RunnerDeploymentSpecTemplateSpecDockerVolumeMounts
 */
export interface RunnerDeploymentSpecTemplateSpecDockerVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must not contain ':'.
   *
   * @schema RunnerDeploymentSpecTemplateSpecDockerVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. This field is beta in 1.10.
   *
   * @schema RunnerDeploymentSpecTemplateSpecDockerVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema RunnerDeploymentSpecTemplateSpecDockerVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.
   *
   * @default false.
   * @schema RunnerDeploymentSpecTemplateSpecDockerVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema RunnerDeploymentSpecTemplateSpecDockerVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment. Defaults to "" (volume's root). SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root). SubPathExpr and SubPath are mutually exclusive.
   * @schema RunnerDeploymentSpecTemplateSpecDockerVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecDockerVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecDockerVolumeMounts(obj: RunnerDeploymentSpecTemplateSpecDockerVolumeMounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'mountPropagation': obj.mountPropagation,
    'name': obj.name,
    'readOnly': obj.readOnly,
    'subPath': obj.subPath,
    'subPathExpr': obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceRequirements describes the compute resource requirements.
 *
 * @schema RunnerDeploymentSpecTemplateSpecDockerdContainerResources
 */
export interface RunnerDeploymentSpecTemplateSpecDockerdContainerResources {
  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema RunnerDeploymentSpecTemplateSpecDockerdContainerResources#limits
   */
  readonly limits?: { [key: string]: RunnerDeploymentSpecTemplateSpecDockerdContainerResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema RunnerDeploymentSpecTemplateSpecDockerdContainerResources#requests
   */
  readonly requests?: { [key: string]: RunnerDeploymentSpecTemplateSpecDockerdContainerResourcesRequests };

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecDockerdContainerResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecDockerdContainerResources(obj: RunnerDeploymentSpecTemplateSpecDockerdContainerResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema RunnerDeploymentSpecTemplateSpecEnv
 */
export interface RunnerDeploymentSpecTemplateSpecEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded using the previously defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
   *
   * @default .
   * @schema RunnerDeploymentSpecTemplateSpecEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEnv#valueFrom
   */
  readonly valueFrom?: RunnerDeploymentSpecTemplateSpecEnvValueFrom;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecEnv(obj: RunnerDeploymentSpecTemplateSpecEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
    'valueFrom': toJson_RunnerDeploymentSpecTemplateSpecEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema RunnerDeploymentSpecTemplateSpecEnvFrom
 */
export interface RunnerDeploymentSpecTemplateSpecEnvFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema RunnerDeploymentSpecTemplateSpecEnvFrom#configMapRef
   */
  readonly configMapRef?: RunnerDeploymentSpecTemplateSpecEnvFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEnvFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema RunnerDeploymentSpecTemplateSpecEnvFrom#secretRef
   */
  readonly secretRef?: RunnerDeploymentSpecTemplateSpecEnvFromSecretRef;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecEnvFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecEnvFrom(obj: RunnerDeploymentSpecTemplateSpecEnvFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapRef': toJson_RunnerDeploymentSpecTemplateSpecEnvFromConfigMapRef(obj.configMapRef),
    'prefix': obj.prefix,
    'secretRef': toJson_RunnerDeploymentSpecTemplateSpecEnvFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * An EphemeralContainer is a temporary container that you may add to an existing Pod for user-initiated activities such as debugging. Ephemeral containers have no resource or scheduling guarantees, and they will not be restarted when they exit or when a Pod is removed or restarted. The kubelet may evict a Pod if an ephemeral container causes the Pod to exceed its resource allocation.
 * To add an ephemeral container, use the ephemeralcontainers subresource of an existing Pod. Ephemeral containers may not be removed or restarted.
 * This is a beta feature available on clusters that haven't disabled the EphemeralContainers feature gate.
 *
 * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainers
 */
export interface RunnerDeploymentSpecTemplateSpecEphemeralContainers {
  /**
   * Arguments to the entrypoint. The docker image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainers#args
   */
  readonly args?: string[];

  /**
   * Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainers#command
   */
  readonly command?: string[];

  /**
   * List of environment variables to set in the container. Cannot be updated.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainers#env
   */
  readonly env?: RunnerDeploymentSpecTemplateSpecEphemeralContainersEnv[];

  /**
   * List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainers#envFrom
   */
  readonly envFrom?: RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvFrom[];

  /**
   * Docker image name. More info: https://kubernetes.io/docs/concepts/containers/images
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainers#image
   */
  readonly image?: string;

  /**
   * Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   *
   * @default Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainers#imagePullPolicy
   */
  readonly imagePullPolicy?: string;

  /**
   * Lifecycle is not allowed for ephemeral containers.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainers#lifecycle
   */
  readonly lifecycle?: RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecycle;

  /**
   * Probes are not allowed for ephemeral containers.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainers#livenessProbe
   */
  readonly livenessProbe?: RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbe;

  /**
   * Name of the ephemeral container specified as a DNS_LABEL. This name must be unique among all containers, init containers and ephemeral containers.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainers#name
   */
  readonly name: string;

  /**
   * Ports are not allowed for ephemeral containers.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainers#ports
   */
  readonly ports?: RunnerDeploymentSpecTemplateSpecEphemeralContainersPorts[];

  /**
   * Probes are not allowed for ephemeral containers.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainers#readinessProbe
   */
  readonly readinessProbe?: RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbe;

  /**
   * Resources are not allowed for ephemeral containers. Ephemeral containers use spare resources already allocated to the pod.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainers#resources
   */
  readonly resources?: RunnerDeploymentSpecTemplateSpecEphemeralContainersResources;

  /**
   * Optional: SecurityContext defines the security options the ephemeral container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainers#securityContext
   */
  readonly securityContext?: RunnerDeploymentSpecTemplateSpecEphemeralContainersSecurityContext;

  /**
   * Probes are not allowed for ephemeral containers.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainers#startupProbe
   */
  readonly startupProbe?: RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbe;

  /**
   * Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF. Default is false.
   *
   * @default false.
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainers#stdin
   */
  readonly stdin?: boolean;

  /**
   * Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false
   *
   * @default false
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainers#stdinOnce
   */
  readonly stdinOnce?: boolean;

  /**
   * If set, the name of the container from PodSpec that this ephemeral container targets. The ephemeral container will be run in the namespaces (IPC, PID, etc) of this container. If not set then the ephemeral container uses the namespaces configured in the Pod spec.
   * The container runtime must implement support for this feature. If the runtime does not support namespace targeting then the result of setting this field is undefined.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainers#targetContainerName
   */
  readonly targetContainerName?: string;

  /**
   * Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Will be truncated by the node if greater than 4096 bytes. The total message length across all containers will be limited to 12kb. Defaults to /dev/termination-log. Cannot be updated.
   *
   * @default dev/termination-log. Cannot be updated.
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainers#terminationMessagePath
   */
  readonly terminationMessagePath?: string;

  /**
   * Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.
   *
   * @default File. Cannot be updated.
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainers#terminationMessagePolicy
   */
  readonly terminationMessagePolicy?: string;

  /**
   * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true. Default is false.
   *
   * @default false.
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainers#tty
   */
  readonly tty?: boolean;

  /**
   * volumeDevices is the list of block devices to be used by the container.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainers#volumeDevices
   */
  readonly volumeDevices?: RunnerDeploymentSpecTemplateSpecEphemeralContainersVolumeDevices[];

  /**
   * Pod volumes to mount into the container's filesystem. Subpath mounts are not allowed for ephemeral containers. Cannot be updated.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainers#volumeMounts
   */
  readonly volumeMounts?: RunnerDeploymentSpecTemplateSpecEphemeralContainersVolumeMounts[];

  /**
   * Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainers#workingDir
   */
  readonly workingDir?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecEphemeralContainers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainers(obj: RunnerDeploymentSpecTemplateSpecEphemeralContainers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'args': obj.args?.map(y => y),
    'command': obj.command?.map(y => y),
    'env': obj.env?.map(y => toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersEnv(y)),
    'envFrom': obj.envFrom?.map(y => toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvFrom(y)),
    'image': obj.image,
    'imagePullPolicy': obj.imagePullPolicy,
    'lifecycle': toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecycle(obj.lifecycle),
    'livenessProbe': toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbe(obj.livenessProbe),
    'name': obj.name,
    'ports': obj.ports?.map(y => toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersPorts(y)),
    'readinessProbe': toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbe(obj.readinessProbe),
    'resources': toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersResources(obj.resources),
    'securityContext': toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersSecurityContext(obj.securityContext),
    'startupProbe': toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbe(obj.startupProbe),
    'stdin': obj.stdin,
    'stdinOnce': obj.stdinOnce,
    'targetContainerName': obj.targetContainerName,
    'terminationMessagePath': obj.terminationMessagePath,
    'terminationMessagePolicy': obj.terminationMessagePolicy,
    'tty': obj.tty,
    'volumeDevices': obj.volumeDevices?.map(y => toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersVolumeDevices(y)),
    'volumeMounts': obj.volumeMounts?.map(y => toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersVolumeMounts(y)),
    'workingDir': obj.workingDir,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod's hosts file.
 *
 * @schema RunnerDeploymentSpecTemplateSpecHostAliases
 */
export interface RunnerDeploymentSpecTemplateSpecHostAliases {
  /**
   * Hostnames for the above IP address.
   *
   * @schema RunnerDeploymentSpecTemplateSpecHostAliases#hostnames
   */
  readonly hostnames?: string[];

  /**
   * IP address of the host file entry.
   *
   * @schema RunnerDeploymentSpecTemplateSpecHostAliases#ip
   */
  readonly ip?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecHostAliases' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecHostAliases(obj: RunnerDeploymentSpecTemplateSpecHostAliases | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostnames': obj.hostnames?.map(y => y),
    'ip': obj.ip,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
 *
 * @schema RunnerDeploymentSpecTemplateSpecImagePullSecrets
 */
export interface RunnerDeploymentSpecTemplateSpecImagePullSecrets {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerDeploymentSpecTemplateSpecImagePullSecrets#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecImagePullSecrets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecImagePullSecrets(obj: RunnerDeploymentSpecTemplateSpecImagePullSecrets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A single application container that you want to run within a pod.
 *
 * @schema RunnerDeploymentSpecTemplateSpecInitContainers
 */
export interface RunnerDeploymentSpecTemplateSpecInitContainers {
  /**
   * Arguments to the entrypoint. The docker image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainers#args
   */
  readonly args?: string[];

  /**
   * Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainers#command
   */
  readonly command?: string[];

  /**
   * List of environment variables to set in the container. Cannot be updated.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainers#env
   */
  readonly env?: RunnerDeploymentSpecTemplateSpecInitContainersEnv[];

  /**
   * List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainers#envFrom
   */
  readonly envFrom?: RunnerDeploymentSpecTemplateSpecInitContainersEnvFrom[];

  /**
   * Docker image name. More info: https://kubernetes.io/docs/concepts/containers/images This field is optional to allow higher level config management to default or override container images in workload controllers like Deployments and StatefulSets.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainers#image
   */
  readonly image?: string;

  /**
   * Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   *
   * @default Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   * @schema RunnerDeploymentSpecTemplateSpecInitContainers#imagePullPolicy
   */
  readonly imagePullPolicy?: string;

  /**
   * Actions that the management system should take in response to container lifecycle events. Cannot be updated.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainers#lifecycle
   */
  readonly lifecycle?: RunnerDeploymentSpecTemplateSpecInitContainersLifecycle;

  /**
   * Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainers#livenessProbe
   */
  readonly livenessProbe?: RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbe;

  /**
   * Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainers#name
   */
  readonly name: string;

  /**
   * List of ports to expose from the container. Exposing a port here gives the system additional information about the network connections a container uses, but is primarily informational. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default "0.0.0.0" address inside a container will be accessible from the network. Cannot be updated.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainers#ports
   */
  readonly ports?: RunnerDeploymentSpecTemplateSpecInitContainersPorts[];

  /**
   * Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainers#readinessProbe
   */
  readonly readinessProbe?: RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbe;

  /**
   * Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainers#resources
   */
  readonly resources?: RunnerDeploymentSpecTemplateSpecInitContainersResources;

  /**
   * SecurityContext defines the security options the container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainers#securityContext
   */
  readonly securityContext?: RunnerDeploymentSpecTemplateSpecInitContainersSecurityContext;

  /**
   * StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainers#startupProbe
   */
  readonly startupProbe?: RunnerDeploymentSpecTemplateSpecInitContainersStartupProbe;

  /**
   * Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF. Default is false.
   *
   * @default false.
   * @schema RunnerDeploymentSpecTemplateSpecInitContainers#stdin
   */
  readonly stdin?: boolean;

  /**
   * Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false
   *
   * @default false
   * @schema RunnerDeploymentSpecTemplateSpecInitContainers#stdinOnce
   */
  readonly stdinOnce?: boolean;

  /**
   * Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Will be truncated by the node if greater than 4096 bytes. The total message length across all containers will be limited to 12kb. Defaults to /dev/termination-log. Cannot be updated.
   *
   * @default dev/termination-log. Cannot be updated.
   * @schema RunnerDeploymentSpecTemplateSpecInitContainers#terminationMessagePath
   */
  readonly terminationMessagePath?: string;

  /**
   * Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.
   *
   * @default File. Cannot be updated.
   * @schema RunnerDeploymentSpecTemplateSpecInitContainers#terminationMessagePolicy
   */
  readonly terminationMessagePolicy?: string;

  /**
   * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true. Default is false.
   *
   * @default false.
   * @schema RunnerDeploymentSpecTemplateSpecInitContainers#tty
   */
  readonly tty?: boolean;

  /**
   * volumeDevices is the list of block devices to be used by the container.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainers#volumeDevices
   */
  readonly volumeDevices?: RunnerDeploymentSpecTemplateSpecInitContainersVolumeDevices[];

  /**
   * Pod volumes to mount into the container's filesystem. Cannot be updated.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainers#volumeMounts
   */
  readonly volumeMounts?: RunnerDeploymentSpecTemplateSpecInitContainersVolumeMounts[];

  /**
   * Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainers#workingDir
   */
  readonly workingDir?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecInitContainers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecInitContainers(obj: RunnerDeploymentSpecTemplateSpecInitContainers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'args': obj.args?.map(y => y),
    'command': obj.command?.map(y => y),
    'env': obj.env?.map(y => toJson_RunnerDeploymentSpecTemplateSpecInitContainersEnv(y)),
    'envFrom': obj.envFrom?.map(y => toJson_RunnerDeploymentSpecTemplateSpecInitContainersEnvFrom(y)),
    'image': obj.image,
    'imagePullPolicy': obj.imagePullPolicy,
    'lifecycle': toJson_RunnerDeploymentSpecTemplateSpecInitContainersLifecycle(obj.lifecycle),
    'livenessProbe': toJson_RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbe(obj.livenessProbe),
    'name': obj.name,
    'ports': obj.ports?.map(y => toJson_RunnerDeploymentSpecTemplateSpecInitContainersPorts(y)),
    'readinessProbe': toJson_RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbe(obj.readinessProbe),
    'resources': toJson_RunnerDeploymentSpecTemplateSpecInitContainersResources(obj.resources),
    'securityContext': toJson_RunnerDeploymentSpecTemplateSpecInitContainersSecurityContext(obj.securityContext),
    'startupProbe': toJson_RunnerDeploymentSpecTemplateSpecInitContainersStartupProbe(obj.startupProbe),
    'stdin': obj.stdin,
    'stdinOnce': obj.stdinOnce,
    'terminationMessagePath': obj.terminationMessagePath,
    'terminationMessagePolicy': obj.terminationMessagePolicy,
    'tty': obj.tty,
    'volumeDevices': obj.volumeDevices?.map(y => toJson_RunnerDeploymentSpecTemplateSpecInitContainersVolumeDevices(y)),
    'volumeMounts': obj.volumeMounts?.map(y => toJson_RunnerDeploymentSpecTemplateSpecInitContainersVolumeMounts(y)),
    'workingDir': obj.workingDir,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceRequirements describes the compute resource requirements.
 *
 * @schema RunnerDeploymentSpecTemplateSpecResources
 */
export interface RunnerDeploymentSpecTemplateSpecResources {
  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema RunnerDeploymentSpecTemplateSpecResources#limits
   */
  readonly limits?: { [key: string]: RunnerDeploymentSpecTemplateSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema RunnerDeploymentSpecTemplateSpecResources#requests
   */
  readonly requests?: { [key: string]: RunnerDeploymentSpecTemplateSpecResourcesRequests };

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecResources(obj: RunnerDeploymentSpecTemplateSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PodSecurityContext holds pod-level security attributes and common container settings. Some fields are also present in container.securityContext.  Field values of container.securityContext take precedence over field values of PodSecurityContext.
 *
 * @schema RunnerDeploymentSpecTemplateSpecSecurityContext
 */
export interface RunnerDeploymentSpecTemplateSpecSecurityContext {
  /**
   * A special supplemental group that applies to all containers in a pod. Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod:
   * 1. The owning GID will be the FSGroup 2. The setgid bit is set (new files created in the volume will be owned by FSGroup) 3. The permission bits are OR'd with rw-rw----
   * If unset, the Kubelet will not modify the ownership and permissions of any volume. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * fsGroupChangePolicy defines behavior of changing ownership and permission of the volume before being exposed inside Pod. This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir. Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   * @schema RunnerDeploymentSpecTemplateSpecSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: RunnerDeploymentSpecTemplateSpecSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSecurityContext#seccompProfile
   */
  readonly seccompProfile?: RunnerDeploymentSpecTemplateSpecSecurityContextSeccompProfile;

  /**
   * A list of groups applied to the first process run in each container, in addition to the container's primary GID.  If unspecified, no groups will be added to any container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported sysctls (by the container runtime) might fail to launch. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSecurityContext#sysctls
   */
  readonly sysctls?: RunnerDeploymentSpecTemplateSpecSecurityContextSysctls[];

  /**
   * The Windows specific settings applied to all containers. If unspecified, the options within a container's SecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSecurityContext#windowsOptions
   */
  readonly windowsOptions?: RunnerDeploymentSpecTemplateSpecSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecSecurityContext(obj: RunnerDeploymentSpecTemplateSpecSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsGroup': obj.fsGroup,
    'fsGroupChangePolicy': obj.fsGroupChangePolicy,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_RunnerDeploymentSpecTemplateSpecSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_RunnerDeploymentSpecTemplateSpecSecurityContextSeccompProfile(obj.seccompProfile),
    'supplementalGroups': obj.supplementalGroups?.map(y => y),
    'sysctls': obj.sysctls?.map(y => toJson_RunnerDeploymentSpecTemplateSpecSecurityContextSysctls(y)),
    'windowsOptions': toJson_RunnerDeploymentSpecTemplateSpecSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A single application container that you want to run within a pod.
 *
 * @schema RunnerDeploymentSpecTemplateSpecSidecarContainers
 */
export interface RunnerDeploymentSpecTemplateSpecSidecarContainers {
  /**
   * Arguments to the entrypoint. The docker image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainers#args
   */
  readonly args?: string[];

  /**
   * Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainers#command
   */
  readonly command?: string[];

  /**
   * List of environment variables to set in the container. Cannot be updated.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainers#env
   */
  readonly env?: RunnerDeploymentSpecTemplateSpecSidecarContainersEnv[];

  /**
   * List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainers#envFrom
   */
  readonly envFrom?: RunnerDeploymentSpecTemplateSpecSidecarContainersEnvFrom[];

  /**
   * Docker image name. More info: https://kubernetes.io/docs/concepts/containers/images This field is optional to allow higher level config management to default or override container images in workload controllers like Deployments and StatefulSets.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainers#image
   */
  readonly image?: string;

  /**
   * Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   *
   * @default Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainers#imagePullPolicy
   */
  readonly imagePullPolicy?: string;

  /**
   * Actions that the management system should take in response to container lifecycle events. Cannot be updated.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainers#lifecycle
   */
  readonly lifecycle?: RunnerDeploymentSpecTemplateSpecSidecarContainersLifecycle;

  /**
   * Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainers#livenessProbe
   */
  readonly livenessProbe?: RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbe;

  /**
   * Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainers#name
   */
  readonly name: string;

  /**
   * List of ports to expose from the container. Exposing a port here gives the system additional information about the network connections a container uses, but is primarily informational. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default "0.0.0.0" address inside a container will be accessible from the network. Cannot be updated.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainers#ports
   */
  readonly ports?: RunnerDeploymentSpecTemplateSpecSidecarContainersPorts[];

  /**
   * Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainers#readinessProbe
   */
  readonly readinessProbe?: RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbe;

  /**
   * Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainers#resources
   */
  readonly resources?: RunnerDeploymentSpecTemplateSpecSidecarContainersResources;

  /**
   * SecurityContext defines the security options the container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainers#securityContext
   */
  readonly securityContext?: RunnerDeploymentSpecTemplateSpecSidecarContainersSecurityContext;

  /**
   * StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainers#startupProbe
   */
  readonly startupProbe?: RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbe;

  /**
   * Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF. Default is false.
   *
   * @default false.
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainers#stdin
   */
  readonly stdin?: boolean;

  /**
   * Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false
   *
   * @default false
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainers#stdinOnce
   */
  readonly stdinOnce?: boolean;

  /**
   * Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Will be truncated by the node if greater than 4096 bytes. The total message length across all containers will be limited to 12kb. Defaults to /dev/termination-log. Cannot be updated.
   *
   * @default dev/termination-log. Cannot be updated.
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainers#terminationMessagePath
   */
  readonly terminationMessagePath?: string;

  /**
   * Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.
   *
   * @default File. Cannot be updated.
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainers#terminationMessagePolicy
   */
  readonly terminationMessagePolicy?: string;

  /**
   * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true. Default is false.
   *
   * @default false.
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainers#tty
   */
  readonly tty?: boolean;

  /**
   * volumeDevices is the list of block devices to be used by the container.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainers#volumeDevices
   */
  readonly volumeDevices?: RunnerDeploymentSpecTemplateSpecSidecarContainersVolumeDevices[];

  /**
   * Pod volumes to mount into the container's filesystem. Cannot be updated.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainers#volumeMounts
   */
  readonly volumeMounts?: RunnerDeploymentSpecTemplateSpecSidecarContainersVolumeMounts[];

  /**
   * Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainers#workingDir
   */
  readonly workingDir?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecSidecarContainers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecSidecarContainers(obj: RunnerDeploymentSpecTemplateSpecSidecarContainers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'args': obj.args?.map(y => y),
    'command': obj.command?.map(y => y),
    'env': obj.env?.map(y => toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersEnv(y)),
    'envFrom': obj.envFrom?.map(y => toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersEnvFrom(y)),
    'image': obj.image,
    'imagePullPolicy': obj.imagePullPolicy,
    'lifecycle': toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersLifecycle(obj.lifecycle),
    'livenessProbe': toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbe(obj.livenessProbe),
    'name': obj.name,
    'ports': obj.ports?.map(y => toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersPorts(y)),
    'readinessProbe': toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbe(obj.readinessProbe),
    'resources': toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersResources(obj.resources),
    'securityContext': toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersSecurityContext(obj.securityContext),
    'startupProbe': toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbe(obj.startupProbe),
    'stdin': obj.stdin,
    'stdinOnce': obj.stdinOnce,
    'terminationMessagePath': obj.terminationMessagePath,
    'terminationMessagePolicy': obj.terminationMessagePolicy,
    'tty': obj.tty,
    'volumeDevices': obj.volumeDevices?.map(y => toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersVolumeDevices(y)),
    'volumeMounts': obj.volumeMounts?.map(y => toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersVolumeMounts(y)),
    'workingDir': obj.workingDir,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema RunnerDeploymentSpecTemplateSpecTolerations
 */
export interface RunnerDeploymentSpecTemplateSpecTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema RunnerDeploymentSpecTemplateSpecTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema RunnerDeploymentSpecTemplateSpecTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
   *
   * @default Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
   * @schema RunnerDeploymentSpecTemplateSpecTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema RunnerDeploymentSpecTemplateSpecTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema RunnerDeploymentSpecTemplateSpecTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecTolerations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecTolerations(obj: RunnerDeploymentSpecTemplateSpecTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TopologySpreadConstraint specifies how to spread matching pods among the given topology.
 *
 * @schema RunnerDeploymentSpecTemplateSpecTopologySpreadConstraint
 */
export interface RunnerDeploymentSpecTemplateSpecTopologySpreadConstraint {
  /**
   * LabelSelector is used to find matching pods. Pods that match this label selector are counted to determine the number of pods in their corresponding topology domain.
   *
   * @schema RunnerDeploymentSpecTemplateSpecTopologySpreadConstraint#labelSelector
   */
  readonly labelSelector?: RunnerDeploymentSpecTemplateSpecTopologySpreadConstraintLabelSelector;

  /**
   * MaxSkew describes the degree to which pods may be unevenly distributed. When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted difference between the number of matching pods in the target topology and the global minimum. For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same labelSelector spread as 1/1/0: | zone1 | zone2 | zone3 | |   P   |   P   |       | - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 1/1/1; scheduling it onto zone1(zone2) would make the ActualSkew(2-0) on zone1(zone2) violate MaxSkew(1). - if MaxSkew is 2, incoming pod can be scheduled onto any zone. When `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher precedence to topologies that satisfy it. It's a required field. Default value is 1 and 0 is not allowed.
   *
   * @schema RunnerDeploymentSpecTemplateSpecTopologySpreadConstraint#maxSkew
   */
  readonly maxSkew: number;

  /**
   * TopologyKey is the key of node labels. Nodes that have a label with this key and identical values are considered to be in the same topology. We consider each <key, value> as a "bucket", and try to put balanced number of pods into each bucket. It's a required field.
   *
   * @schema RunnerDeploymentSpecTemplateSpecTopologySpreadConstraint#topologyKey
   */
  readonly topologyKey: string;

  /**
   * WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy the spread constraint. - DoNotSchedule (default) tells the scheduler not to schedule it. - ScheduleAnyway tells the scheduler to schedule the pod in any location,   but giving higher precedence to topologies that would help reduce the   skew. A constraint is considered "Unsatisfiable" for an incoming pod if and only if every possible node assignment for that pod would violate "MaxSkew" on some topology. For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same labelSelector spread as 3/1/1: | zone1 | zone2 | zone3 | | P P P |   P   |   P   | If WhenUnsatisfiable is set to DoNotSchedule, incoming pod can only be scheduled to zone2(zone3) to become 3/2/1(3/1/2) as ActualSkew(2-1) on zone2(zone3) satisfies MaxSkew(1). In other words, the cluster can still be imbalanced, but scheduler won't make it *more* imbalanced. It's a required field.
   *
   * @schema RunnerDeploymentSpecTemplateSpecTopologySpreadConstraint#whenUnsatisfiable
   */
  readonly whenUnsatisfiable: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecTopologySpreadConstraint' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecTopologySpreadConstraint(obj: RunnerDeploymentSpecTemplateSpecTopologySpreadConstraint | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_RunnerDeploymentSpecTemplateSpecTopologySpreadConstraintLabelSelector(obj.labelSelector),
    'maxSkew': obj.maxSkew,
    'topologyKey': obj.topologyKey,
    'whenUnsatisfiable': obj.whenUnsatisfiable,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema RunnerDeploymentSpecTemplateSpecVolumeMounts
 */
export interface RunnerDeploymentSpecTemplateSpecVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must not contain ':'.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. This field is beta in 1.10.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.
   *
   * @default false.
   * @schema RunnerDeploymentSpecTemplateSpecVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema RunnerDeploymentSpecTemplateSpecVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment. Defaults to "" (volume's root). SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root). SubPathExpr and SubPath are mutually exclusive.
   * @schema RunnerDeploymentSpecTemplateSpecVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecVolumeMounts(obj: RunnerDeploymentSpecTemplateSpecVolumeMounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'mountPropagation': obj.mountPropagation,
    'name': obj.name,
    'readOnly': obj.readOnly,
    'subPath': obj.subPath,
    'subPathExpr': obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RunnerDeploymentSpecTemplateSpecVolumeSizeLimit
 */
export class RunnerDeploymentSpecTemplateSpecVolumeSizeLimit {
  public static fromNumber(value: number): RunnerDeploymentSpecTemplateSpecVolumeSizeLimit {
    return new RunnerDeploymentSpecTemplateSpecVolumeSizeLimit(value);
  }
  public static fromString(value: string): RunnerDeploymentSpecTemplateSpecVolumeSizeLimit {
    return new RunnerDeploymentSpecTemplateSpecVolumeSizeLimit(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Volume represents a named volume in a pod that may be accessed by any container in the pod.
 *
 * @schema RunnerDeploymentSpecTemplateSpecVolumes
 */
export interface RunnerDeploymentSpecTemplateSpecVolumes {
  /**
   * AWSElasticBlockStore represents an AWS Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumes#awsElasticBlockStore
   */
  readonly awsElasticBlockStore?: RunnerDeploymentSpecTemplateSpecVolumesAwsElasticBlockStore;

  /**
   * AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumes#azureDisk
   */
  readonly azureDisk?: RunnerDeploymentSpecTemplateSpecVolumesAzureDisk;

  /**
   * AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumes#azureFile
   */
  readonly azureFile?: RunnerDeploymentSpecTemplateSpecVolumesAzureFile;

  /**
   * CephFS represents a Ceph FS mount on the host that shares a pod's lifetime
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumes#cephfs
   */
  readonly cephfs?: RunnerDeploymentSpecTemplateSpecVolumesCephfs;

  /**
   * Cinder represents a cinder volume attached and mounted on kubelets host machine. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumes#cinder
   */
  readonly cinder?: RunnerDeploymentSpecTemplateSpecVolumesCinder;

  /**
   * ConfigMap represents a configMap that should populate this volume
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumes#configMap
   */
  readonly configMap?: RunnerDeploymentSpecTemplateSpecVolumesConfigMap;

  /**
   * CSI (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers (Beta feature).
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumes#csi
   */
  readonly csi?: RunnerDeploymentSpecTemplateSpecVolumesCsi;

  /**
   * DownwardAPI represents downward API about the pod that should populate this volume
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumes#downwardAPI
   */
  readonly downwardApi?: RunnerDeploymentSpecTemplateSpecVolumesDownwardApi;

  /**
   * EmptyDir represents a temporary directory that shares a pod's lifetime. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumes#emptyDir
   */
  readonly emptyDir?: RunnerDeploymentSpecTemplateSpecVolumesEmptyDir;

  /**
   * Ephemeral represents a volume that is handled by a cluster storage driver. The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts, and deleted when the pod is removed.
   * Use this if: a) the volume is only needed while the pod runs, b) features of normal volumes like restoring from snapshot or capacity    tracking are needed, c) the storage driver is specified through a storage class, and d) the storage driver supports dynamic volume provisioning through    a PersistentVolumeClaim (see EphemeralVolumeSource for more    information on the connection between this volume type    and PersistentVolumeClaim).
   * Use PersistentVolumeClaim or one of the vendor-specific APIs for volumes that persist for longer than the lifecycle of an individual pod.
   * Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to be used that way - see the documentation of the driver for more information.
   * A pod can use both types of ephemeral volumes and persistent volumes at the same time.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumes#ephemeral
   */
  readonly ephemeral?: RunnerDeploymentSpecTemplateSpecVolumesEphemeral;

  /**
   * FC represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumes#fc
   */
  readonly fc?: RunnerDeploymentSpecTemplateSpecVolumesFc;

  /**
   * FlexVolume represents a generic volume resource that is provisioned/attached using an exec based plugin.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumes#flexVolume
   */
  readonly flexVolume?: RunnerDeploymentSpecTemplateSpecVolumesFlexVolume;

  /**
   * Flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumes#flocker
   */
  readonly flocker?: RunnerDeploymentSpecTemplateSpecVolumesFlocker;

  /**
   * GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumes#gcePersistentDisk
   */
  readonly gcePersistentDisk?: RunnerDeploymentSpecTemplateSpecVolumesGcePersistentDisk;

  /**
   * GitRepo represents a git repository at a particular revision. DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir into the Pod's container.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumes#gitRepo
   */
  readonly gitRepo?: RunnerDeploymentSpecTemplateSpecVolumesGitRepo;

  /**
   * Glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/glusterfs/README.md
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumes#glusterfs
   */
  readonly glusterfs?: RunnerDeploymentSpecTemplateSpecVolumesGlusterfs;

  /**
   * HostPath represents a pre-existing file or directory on the host machine that is directly exposed to the container. This is generally used for system agents or other privileged things that are allowed to see the host machine. Most containers will NOT need this. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath --- TODO(jonesdl) We need to restrict who can use host directory mounts and who can/can not mount host directories as read/write.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumes#hostPath
   */
  readonly hostPath?: RunnerDeploymentSpecTemplateSpecVolumesHostPath;

  /**
   * ISCSI represents an ISCSI Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://examples.k8s.io/volumes/iscsi/README.md
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumes#iscsi
   */
  readonly iscsi?: RunnerDeploymentSpecTemplateSpecVolumesIscsi;

  /**
   * Volume's name. Must be a DNS_LABEL and unique within the pod. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumes#name
   */
  readonly name: string;

  /**
   * NFS represents an NFS mount on the host that shares a pod's lifetime More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumes#nfs
   */
  readonly nfs?: RunnerDeploymentSpecTemplateSpecVolumesNfs;

  /**
   * PersistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in the same namespace. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumes#persistentVolumeClaim
   */
  readonly persistentVolumeClaim?: RunnerDeploymentSpecTemplateSpecVolumesPersistentVolumeClaim;

  /**
   * PhotonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumes#photonPersistentDisk
   */
  readonly photonPersistentDisk?: RunnerDeploymentSpecTemplateSpecVolumesPhotonPersistentDisk;

  /**
   * PortworxVolume represents a portworx volume attached and mounted on kubelets host machine
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumes#portworxVolume
   */
  readonly portworxVolume?: RunnerDeploymentSpecTemplateSpecVolumesPortworxVolume;

  /**
   * Items for all in one resources secrets, configmaps, and downward API
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumes#projected
   */
  readonly projected?: RunnerDeploymentSpecTemplateSpecVolumesProjected;

  /**
   * Quobyte represents a Quobyte mount on the host that shares a pod's lifetime
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumes#quobyte
   */
  readonly quobyte?: RunnerDeploymentSpecTemplateSpecVolumesQuobyte;

  /**
   * RBD represents a Rados Block Device mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/rbd/README.md
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumes#rbd
   */
  readonly rbd?: RunnerDeploymentSpecTemplateSpecVolumesRbd;

  /**
   * ScaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumes#scaleIO
   */
  readonly scaleIo?: RunnerDeploymentSpecTemplateSpecVolumesScaleIo;

  /**
   * Secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumes#secret
   */
  readonly secret?: RunnerDeploymentSpecTemplateSpecVolumesSecret;

  /**
   * StorageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumes#storageos
   */
  readonly storageos?: RunnerDeploymentSpecTemplateSpecVolumesStorageos;

  /**
   * VsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumes#vsphereVolume
   */
  readonly vsphereVolume?: RunnerDeploymentSpecTemplateSpecVolumesVsphereVolume;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecVolumes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecVolumes(obj: RunnerDeploymentSpecTemplateSpecVolumes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'awsElasticBlockStore': toJson_RunnerDeploymentSpecTemplateSpecVolumesAwsElasticBlockStore(obj.awsElasticBlockStore),
    'azureDisk': toJson_RunnerDeploymentSpecTemplateSpecVolumesAzureDisk(obj.azureDisk),
    'azureFile': toJson_RunnerDeploymentSpecTemplateSpecVolumesAzureFile(obj.azureFile),
    'cephfs': toJson_RunnerDeploymentSpecTemplateSpecVolumesCephfs(obj.cephfs),
    'cinder': toJson_RunnerDeploymentSpecTemplateSpecVolumesCinder(obj.cinder),
    'configMap': toJson_RunnerDeploymentSpecTemplateSpecVolumesConfigMap(obj.configMap),
    'csi': toJson_RunnerDeploymentSpecTemplateSpecVolumesCsi(obj.csi),
    'downwardAPI': toJson_RunnerDeploymentSpecTemplateSpecVolumesDownwardApi(obj.downwardApi),
    'emptyDir': toJson_RunnerDeploymentSpecTemplateSpecVolumesEmptyDir(obj.emptyDir),
    'ephemeral': toJson_RunnerDeploymentSpecTemplateSpecVolumesEphemeral(obj.ephemeral),
    'fc': toJson_RunnerDeploymentSpecTemplateSpecVolumesFc(obj.fc),
    'flexVolume': toJson_RunnerDeploymentSpecTemplateSpecVolumesFlexVolume(obj.flexVolume),
    'flocker': toJson_RunnerDeploymentSpecTemplateSpecVolumesFlocker(obj.flocker),
    'gcePersistentDisk': toJson_RunnerDeploymentSpecTemplateSpecVolumesGcePersistentDisk(obj.gcePersistentDisk),
    'gitRepo': toJson_RunnerDeploymentSpecTemplateSpecVolumesGitRepo(obj.gitRepo),
    'glusterfs': toJson_RunnerDeploymentSpecTemplateSpecVolumesGlusterfs(obj.glusterfs),
    'hostPath': toJson_RunnerDeploymentSpecTemplateSpecVolumesHostPath(obj.hostPath),
    'iscsi': toJson_RunnerDeploymentSpecTemplateSpecVolumesIscsi(obj.iscsi),
    'name': obj.name,
    'nfs': toJson_RunnerDeploymentSpecTemplateSpecVolumesNfs(obj.nfs),
    'persistentVolumeClaim': toJson_RunnerDeploymentSpecTemplateSpecVolumesPersistentVolumeClaim(obj.persistentVolumeClaim),
    'photonPersistentDisk': toJson_RunnerDeploymentSpecTemplateSpecVolumesPhotonPersistentDisk(obj.photonPersistentDisk),
    'portworxVolume': toJson_RunnerDeploymentSpecTemplateSpecVolumesPortworxVolume(obj.portworxVolume),
    'projected': toJson_RunnerDeploymentSpecTemplateSpecVolumesProjected(obj.projected),
    'quobyte': toJson_RunnerDeploymentSpecTemplateSpecVolumesQuobyte(obj.quobyte),
    'rbd': toJson_RunnerDeploymentSpecTemplateSpecVolumesRbd(obj.rbd),
    'scaleIO': toJson_RunnerDeploymentSpecTemplateSpecVolumesScaleIo(obj.scaleIo),
    'secret': toJson_RunnerDeploymentSpecTemplateSpecVolumesSecret(obj.secret),
    'storageos': toJson_RunnerDeploymentSpecTemplateSpecVolumesStorageos(obj.storageos),
    'vsphereVolume': toJson_RunnerDeploymentSpecTemplateSpecVolumesVsphereVolume(obj.vsphereVolume),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Describes node affinity scheduling rules for the pod.
 *
 * @schema RunnerDeploymentSpecTemplateSpecAffinityNodeAffinity
 */
export interface RunnerDeploymentSpecTemplateSpecAffinityNodeAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the most preferred.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: RunnerDeploymentSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: RunnerDeploymentSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecAffinityNodeAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecAffinityNodeAffinity(obj: RunnerDeploymentSpecTemplateSpecAffinityNodeAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_RunnerDeploymentSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': toJson_RunnerDeploymentSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj.requiredDuringSchedulingIgnoredDuringExecution),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
 *
 * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAffinity
 */
export interface RunnerDeploymentSpecTemplateSpecAffinityPodAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: RunnerDeploymentSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: RunnerDeploymentSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecAffinityPodAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecAffinityPodAffinity(obj: RunnerDeploymentSpecTemplateSpecAffinityPodAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_RunnerDeploymentSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_RunnerDeploymentSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
 *
 * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinity
 */
export interface RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinity(obj: RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema RunnerDeploymentSpecTemplateSpecContainersEnv
 */
export interface RunnerDeploymentSpecTemplateSpecContainersEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded using the previously defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
   *
   * @default .
   * @schema RunnerDeploymentSpecTemplateSpecContainersEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersEnv#valueFrom
   */
  readonly valueFrom?: RunnerDeploymentSpecTemplateSpecContainersEnvValueFrom;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecContainersEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecContainersEnv(obj: RunnerDeploymentSpecTemplateSpecContainersEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
    'valueFrom': toJson_RunnerDeploymentSpecTemplateSpecContainersEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema RunnerDeploymentSpecTemplateSpecContainersEnvFrom
 */
export interface RunnerDeploymentSpecTemplateSpecContainersEnvFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersEnvFrom#configMapRef
   */
  readonly configMapRef?: RunnerDeploymentSpecTemplateSpecContainersEnvFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersEnvFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersEnvFrom#secretRef
   */
  readonly secretRef?: RunnerDeploymentSpecTemplateSpecContainersEnvFromSecretRef;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecContainersEnvFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecContainersEnvFrom(obj: RunnerDeploymentSpecTemplateSpecContainersEnvFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapRef': toJson_RunnerDeploymentSpecTemplateSpecContainersEnvFromConfigMapRef(obj.configMapRef),
    'prefix': obj.prefix,
    'secretRef': toJson_RunnerDeploymentSpecTemplateSpecContainersEnvFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Actions that the management system should take in response to container lifecycle events. Cannot be updated.
 *
 * @schema RunnerDeploymentSpecTemplateSpecContainersLifecycle
 */
export interface RunnerDeploymentSpecTemplateSpecContainersLifecycle {
  /**
   * PostStart is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersLifecycle#postStart
   */
  readonly postStart?: RunnerDeploymentSpecTemplateSpecContainersLifecyclePostStart;

  /**
   * PreStop is called immediately before a container is terminated due to an API request or management event such as liveness/startup probe failure, preemption, resource contention, etc. The handler is not called if the container crashes or exits. The Pod's termination grace period countdown begins before the PreStop hook is executed. Regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period (unless delayed by finalizers). Other management of the container blocks until the hook completes or until the termination grace period is reached. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersLifecycle#preStop
   */
  readonly preStop?: RunnerDeploymentSpecTemplateSpecContainersLifecyclePreStop;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecContainersLifecycle' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecContainersLifecycle(obj: RunnerDeploymentSpecTemplateSpecContainersLifecycle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'postStart': toJson_RunnerDeploymentSpecTemplateSpecContainersLifecyclePostStart(obj.postStart),
    'preStop': toJson_RunnerDeploymentSpecTemplateSpecContainersLifecyclePreStop(obj.preStop),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema RunnerDeploymentSpecTemplateSpecContainersLivenessProbe
 */
export interface RunnerDeploymentSpecTemplateSpecContainersLivenessProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersLivenessProbe#exec
   */
  readonly exec?: RunnerDeploymentSpecTemplateSpecContainersLivenessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema RunnerDeploymentSpecTemplateSpecContainersLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersLivenessProbe#grpc
   */
  readonly grpc?: RunnerDeploymentSpecTemplateSpecContainersLivenessProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersLivenessProbe#httpGet
   */
  readonly httpGet?: RunnerDeploymentSpecTemplateSpecContainersLivenessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema RunnerDeploymentSpecTemplateSpecContainersLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema RunnerDeploymentSpecTemplateSpecContainersLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersLivenessProbe#tcpSocket
   */
  readonly tcpSocket?: RunnerDeploymentSpecTemplateSpecContainersLivenessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersLivenessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema RunnerDeploymentSpecTemplateSpecContainersLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecContainersLivenessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecContainersLivenessProbe(obj: RunnerDeploymentSpecTemplateSpecContainersLivenessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_RunnerDeploymentSpecTemplateSpecContainersLivenessProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_RunnerDeploymentSpecTemplateSpecContainersLivenessProbeGrpc(obj.grpc),
    'httpGet': toJson_RunnerDeploymentSpecTemplateSpecContainersLivenessProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_RunnerDeploymentSpecTemplateSpecContainersLivenessProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ContainerPort represents a network port in a single container.
 *
 * @schema RunnerDeploymentSpecTemplateSpecContainersPorts
 */
export interface RunnerDeploymentSpecTemplateSpecContainersPorts {
  /**
   * Number of port to expose on the pod's IP address. This must be a valid port number, 0 < x < 65536.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersPorts#containerPort
   */
  readonly containerPort: number;

  /**
   * What host IP to bind the external port to.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersPorts#hostIP
   */
  readonly hostIp?: string;

  /**
   * Number of port to expose on the host. If specified, this must be a valid port number, 0 < x < 65536. If HostNetwork is specified, this must match ContainerPort. Most containers do not need this.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersPorts#hostPort
   */
  readonly hostPort?: number;

  /**
   * If specified, this must be an IANA_SVC_NAME and unique within the pod. Each named port in a pod must have a unique name. Name for the port that can be referred to by services.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersPorts#name
   */
  readonly name?: string;

  /**
   * Protocol for port. Must be UDP, TCP, or SCTP. Defaults to "TCP".
   *
   * @default TCP".
   * @schema RunnerDeploymentSpecTemplateSpecContainersPorts#protocol
   */
  readonly protocol?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecContainersPorts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecContainersPorts(obj: RunnerDeploymentSpecTemplateSpecContainersPorts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerPort': obj.containerPort,
    'hostIP': obj.hostIp,
    'hostPort': obj.hostPort,
    'name': obj.name,
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema RunnerDeploymentSpecTemplateSpecContainersReadinessProbe
 */
export interface RunnerDeploymentSpecTemplateSpecContainersReadinessProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersReadinessProbe#exec
   */
  readonly exec?: RunnerDeploymentSpecTemplateSpecContainersReadinessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema RunnerDeploymentSpecTemplateSpecContainersReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersReadinessProbe#grpc
   */
  readonly grpc?: RunnerDeploymentSpecTemplateSpecContainersReadinessProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersReadinessProbe#httpGet
   */
  readonly httpGet?: RunnerDeploymentSpecTemplateSpecContainersReadinessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema RunnerDeploymentSpecTemplateSpecContainersReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema RunnerDeploymentSpecTemplateSpecContainersReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersReadinessProbe#tcpSocket
   */
  readonly tcpSocket?: RunnerDeploymentSpecTemplateSpecContainersReadinessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersReadinessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema RunnerDeploymentSpecTemplateSpecContainersReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecContainersReadinessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecContainersReadinessProbe(obj: RunnerDeploymentSpecTemplateSpecContainersReadinessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_RunnerDeploymentSpecTemplateSpecContainersReadinessProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_RunnerDeploymentSpecTemplateSpecContainersReadinessProbeGrpc(obj.grpc),
    'httpGet': toJson_RunnerDeploymentSpecTemplateSpecContainersReadinessProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_RunnerDeploymentSpecTemplateSpecContainersReadinessProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
 *
 * @schema RunnerDeploymentSpecTemplateSpecContainersResources
 */
export interface RunnerDeploymentSpecTemplateSpecContainersResources {
  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersResources#limits
   */
  readonly limits?: { [key: string]: RunnerDeploymentSpecTemplateSpecContainersResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersResources#requests
   */
  readonly requests?: { [key: string]: RunnerDeploymentSpecTemplateSpecContainersResourcesRequests };

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecContainersResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecContainersResources(obj: RunnerDeploymentSpecTemplateSpecContainersResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecurityContext defines the security options the container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
 *
 * @schema RunnerDeploymentSpecTemplateSpecContainersSecurityContext
 */
export interface RunnerDeploymentSpecTemplateSpecContainersSecurityContext {
  /**
   * AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process. This bool directly controls if the no_new_privs flag will be set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP_SYS_ADMIN Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
   * @schema RunnerDeploymentSpecTemplateSpecContainersSecurityContext#capabilities
   */
  readonly capabilities?: RunnerDeploymentSpecTemplateSpecContainersSecurityContextCapabilities;

  /**
   * Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. Defaults to false. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false. Note that this field cannot be set when spec.os.name is windows.
   * @schema RunnerDeploymentSpecTemplateSpecContainersSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * procMount denotes the type of proc mount to use for the containers. The default is DefaultProcMount which uses the container runtime defaults for readonly paths and masked paths. This requires the ProcMountType feature flag to be enabled. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * Whether this container has a read-only root filesystem. Default is false. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false. Note that this field cannot be set when spec.os.name is windows.
   * @schema RunnerDeploymentSpecTemplateSpecContainersSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   * @schema RunnerDeploymentSpecTemplateSpecContainersSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: RunnerDeploymentSpecTemplateSpecContainersSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by this container. If seccomp options are provided at both the pod & container level, the container options override the pod options. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersSecurityContext#seccompProfile
   */
  readonly seccompProfile?: RunnerDeploymentSpecTemplateSpecContainersSecurityContextSeccompProfile;

  /**
   * The Windows specific settings applied to all containers. If unspecified, the options from the PodSecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersSecurityContext#windowsOptions
   */
  readonly windowsOptions?: RunnerDeploymentSpecTemplateSpecContainersSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecContainersSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecContainersSecurityContext(obj: RunnerDeploymentSpecTemplateSpecContainersSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowPrivilegeEscalation': obj.allowPrivilegeEscalation,
    'capabilities': toJson_RunnerDeploymentSpecTemplateSpecContainersSecurityContextCapabilities(obj.capabilities),
    'privileged': obj.privileged,
    'procMount': obj.procMount,
    'readOnlyRootFilesystem': obj.readOnlyRootFilesystem,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_RunnerDeploymentSpecTemplateSpecContainersSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_RunnerDeploymentSpecTemplateSpecContainersSecurityContextSeccompProfile(obj.seccompProfile),
    'windowsOptions': toJson_RunnerDeploymentSpecTemplateSpecContainersSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema RunnerDeploymentSpecTemplateSpecContainersStartupProbe
 */
export interface RunnerDeploymentSpecTemplateSpecContainersStartupProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersStartupProbe#exec
   */
  readonly exec?: RunnerDeploymentSpecTemplateSpecContainersStartupProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema RunnerDeploymentSpecTemplateSpecContainersStartupProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersStartupProbe#grpc
   */
  readonly grpc?: RunnerDeploymentSpecTemplateSpecContainersStartupProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersStartupProbe#httpGet
   */
  readonly httpGet?: RunnerDeploymentSpecTemplateSpecContainersStartupProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersStartupProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema RunnerDeploymentSpecTemplateSpecContainersStartupProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema RunnerDeploymentSpecTemplateSpecContainersStartupProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersStartupProbe#tcpSocket
   */
  readonly tcpSocket?: RunnerDeploymentSpecTemplateSpecContainersStartupProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersStartupProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema RunnerDeploymentSpecTemplateSpecContainersStartupProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecContainersStartupProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecContainersStartupProbe(obj: RunnerDeploymentSpecTemplateSpecContainersStartupProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_RunnerDeploymentSpecTemplateSpecContainersStartupProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_RunnerDeploymentSpecTemplateSpecContainersStartupProbeGrpc(obj.grpc),
    'httpGet': toJson_RunnerDeploymentSpecTemplateSpecContainersStartupProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_RunnerDeploymentSpecTemplateSpecContainersStartupProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * volumeDevice describes a mapping of a raw block device within a container.
 *
 * @schema RunnerDeploymentSpecTemplateSpecContainersVolumeDevices
 */
export interface RunnerDeploymentSpecTemplateSpecContainersVolumeDevices {
  /**
   * devicePath is the path inside of the container that the device will be mapped to.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersVolumeDevices#devicePath
   */
  readonly devicePath: string;

  /**
   * name must match the name of a persistentVolumeClaim in the pod
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersVolumeDevices#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecContainersVolumeDevices' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecContainersVolumeDevices(obj: RunnerDeploymentSpecTemplateSpecContainersVolumeDevices | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'devicePath': obj.devicePath,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema RunnerDeploymentSpecTemplateSpecContainersVolumeMounts
 */
export interface RunnerDeploymentSpecTemplateSpecContainersVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must not contain ':'.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. This field is beta in 1.10.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.
   *
   * @default false.
   * @schema RunnerDeploymentSpecTemplateSpecContainersVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema RunnerDeploymentSpecTemplateSpecContainersVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment. Defaults to "" (volume's root). SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root). SubPathExpr and SubPath are mutually exclusive.
   * @schema RunnerDeploymentSpecTemplateSpecContainersVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecContainersVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecContainersVolumeMounts(obj: RunnerDeploymentSpecTemplateSpecContainersVolumeMounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'mountPropagation': obj.mountPropagation,
    'name': obj.name,
    'readOnly': obj.readOnly,
    'subPath': obj.subPath,
    'subPathExpr': obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PodDNSConfigOption defines DNS resolver options of a pod.
 *
 * @schema RunnerDeploymentSpecTemplateSpecDnsConfigOptions
 */
export interface RunnerDeploymentSpecTemplateSpecDnsConfigOptions {
  /**
   * Required.
   *
   * @schema RunnerDeploymentSpecTemplateSpecDnsConfigOptions#name
   */
  readonly name?: string;

  /**
   * @schema RunnerDeploymentSpecTemplateSpecDnsConfigOptions#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecDnsConfigOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecDnsConfigOptions(obj: RunnerDeploymentSpecTemplateSpecDnsConfigOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema RunnerDeploymentSpecTemplateSpecDockerEnvValueFrom
 */
export interface RunnerDeploymentSpecTemplateSpecDockerEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema RunnerDeploymentSpecTemplateSpecDockerEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: RunnerDeploymentSpecTemplateSpecDockerEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema RunnerDeploymentSpecTemplateSpecDockerEnvValueFrom#fieldRef
   */
  readonly fieldRef?: RunnerDeploymentSpecTemplateSpecDockerEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema RunnerDeploymentSpecTemplateSpecDockerEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: RunnerDeploymentSpecTemplateSpecDockerEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema RunnerDeploymentSpecTemplateSpecDockerEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: RunnerDeploymentSpecTemplateSpecDockerEnvValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecDockerEnvValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecDockerEnvValueFrom(obj: RunnerDeploymentSpecTemplateSpecDockerEnvValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_RunnerDeploymentSpecTemplateSpecDockerEnvValueFromConfigMapKeyRef(obj.configMapKeyRef),
    'fieldRef': toJson_RunnerDeploymentSpecTemplateSpecDockerEnvValueFromFieldRef(obj.fieldRef),
    'resourceFieldRef': toJson_RunnerDeploymentSpecTemplateSpecDockerEnvValueFromResourceFieldRef(obj.resourceFieldRef),
    'secretKeyRef': toJson_RunnerDeploymentSpecTemplateSpecDockerEnvValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RunnerDeploymentSpecTemplateSpecDockerdContainerResourcesLimits
 */
export class RunnerDeploymentSpecTemplateSpecDockerdContainerResourcesLimits {
  public static fromNumber(value: number): RunnerDeploymentSpecTemplateSpecDockerdContainerResourcesLimits {
    return new RunnerDeploymentSpecTemplateSpecDockerdContainerResourcesLimits(value);
  }
  public static fromString(value: string): RunnerDeploymentSpecTemplateSpecDockerdContainerResourcesLimits {
    return new RunnerDeploymentSpecTemplateSpecDockerdContainerResourcesLimits(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * @schema RunnerDeploymentSpecTemplateSpecDockerdContainerResourcesRequests
 */
export class RunnerDeploymentSpecTemplateSpecDockerdContainerResourcesRequests {
  public static fromNumber(value: number): RunnerDeploymentSpecTemplateSpecDockerdContainerResourcesRequests {
    return new RunnerDeploymentSpecTemplateSpecDockerdContainerResourcesRequests(value);
  }
  public static fromString(value: string): RunnerDeploymentSpecTemplateSpecDockerdContainerResourcesRequests {
    return new RunnerDeploymentSpecTemplateSpecDockerdContainerResourcesRequests(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema RunnerDeploymentSpecTemplateSpecEnvValueFrom
 */
export interface RunnerDeploymentSpecTemplateSpecEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: RunnerDeploymentSpecTemplateSpecEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEnvValueFrom#fieldRef
   */
  readonly fieldRef?: RunnerDeploymentSpecTemplateSpecEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: RunnerDeploymentSpecTemplateSpecEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema RunnerDeploymentSpecTemplateSpecEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: RunnerDeploymentSpecTemplateSpecEnvValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecEnvValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecEnvValueFrom(obj: RunnerDeploymentSpecTemplateSpecEnvValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_RunnerDeploymentSpecTemplateSpecEnvValueFromConfigMapKeyRef(obj.configMapKeyRef),
    'fieldRef': toJson_RunnerDeploymentSpecTemplateSpecEnvValueFromFieldRef(obj.fieldRef),
    'resourceFieldRef': toJson_RunnerDeploymentSpecTemplateSpecEnvValueFromResourceFieldRef(obj.resourceFieldRef),
    'secretKeyRef': toJson_RunnerDeploymentSpecTemplateSpecEnvValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema RunnerDeploymentSpecTemplateSpecEnvFromConfigMapRef
 */
export interface RunnerDeploymentSpecTemplateSpecEnvFromConfigMapRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerDeploymentSpecTemplateSpecEnvFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema RunnerDeploymentSpecTemplateSpecEnvFromConfigMapRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecEnvFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecEnvFromConfigMapRef(obj: RunnerDeploymentSpecTemplateSpecEnvFromConfigMapRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Secret to select from
 *
 * @schema RunnerDeploymentSpecTemplateSpecEnvFromSecretRef
 */
export interface RunnerDeploymentSpecTemplateSpecEnvFromSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerDeploymentSpecTemplateSpecEnvFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema RunnerDeploymentSpecTemplateSpecEnvFromSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecEnvFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecEnvFromSecretRef(obj: RunnerDeploymentSpecTemplateSpecEnvFromSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersEnv
 */
export interface RunnerDeploymentSpecTemplateSpecEphemeralContainersEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded using the previously defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
   *
   * @default .
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersEnv#valueFrom
   */
  readonly valueFrom?: RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvValueFrom;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecEphemeralContainersEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersEnv(obj: RunnerDeploymentSpecTemplateSpecEphemeralContainersEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
    'valueFrom': toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvFrom
 */
export interface RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvFrom#configMapRef
   */
  readonly configMapRef?: RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvFrom#secretRef
   */
  readonly secretRef?: RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvFromSecretRef;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvFrom(obj: RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapRef': toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvFromConfigMapRef(obj.configMapRef),
    'prefix': obj.prefix,
    'secretRef': toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Lifecycle is not allowed for ephemeral containers.
 *
 * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecycle
 */
export interface RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecycle {
  /**
   * PostStart is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecycle#postStart
   */
  readonly postStart?: RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStart;

  /**
   * PreStop is called immediately before a container is terminated due to an API request or management event such as liveness/startup probe failure, preemption, resource contention, etc. The handler is not called if the container crashes or exits. The Pod's termination grace period countdown begins before the PreStop hook is executed. Regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period (unless delayed by finalizers). Other management of the container blocks until the hook completes or until the termination grace period is reached. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecycle#preStop
   */
  readonly preStop?: RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStop;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecycle' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecycle(obj: RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecycle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'postStart': toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStart(obj.postStart),
    'preStop': toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStop(obj.preStop),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Probes are not allowed for ephemeral containers.
 *
 * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbe
 */
export interface RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbe#exec
   */
  readonly exec?: RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbe#grpc
   */
  readonly grpc?: RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbe#httpGet
   */
  readonly httpGet?: RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbe#tcpSocket
   */
  readonly tcpSocket?: RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbe(obj: RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeGrpc(obj.grpc),
    'httpGet': toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ContainerPort represents a network port in a single container.
 *
 * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersPorts
 */
export interface RunnerDeploymentSpecTemplateSpecEphemeralContainersPorts {
  /**
   * Number of port to expose on the pod's IP address. This must be a valid port number, 0 < x < 65536.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersPorts#containerPort
   */
  readonly containerPort: number;

  /**
   * What host IP to bind the external port to.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersPorts#hostIP
   */
  readonly hostIp?: string;

  /**
   * Number of port to expose on the host. If specified, this must be a valid port number, 0 < x < 65536. If HostNetwork is specified, this must match ContainerPort. Most containers do not need this.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersPorts#hostPort
   */
  readonly hostPort?: number;

  /**
   * If specified, this must be an IANA_SVC_NAME and unique within the pod. Each named port in a pod must have a unique name. Name for the port that can be referred to by services.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersPorts#name
   */
  readonly name?: string;

  /**
   * Protocol for port. Must be UDP, TCP, or SCTP. Defaults to "TCP".
   *
   * @default TCP".
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersPorts#protocol
   */
  readonly protocol?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecEphemeralContainersPorts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersPorts(obj: RunnerDeploymentSpecTemplateSpecEphemeralContainersPorts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerPort': obj.containerPort,
    'hostIP': obj.hostIp,
    'hostPort': obj.hostPort,
    'name': obj.name,
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Probes are not allowed for ephemeral containers.
 *
 * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbe
 */
export interface RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbe#exec
   */
  readonly exec?: RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbe#grpc
   */
  readonly grpc?: RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbe#httpGet
   */
  readonly httpGet?: RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbe#tcpSocket
   */
  readonly tcpSocket?: RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbe(obj: RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeGrpc(obj.grpc),
    'httpGet': toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resources are not allowed for ephemeral containers. Ephemeral containers use spare resources already allocated to the pod.
 *
 * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersResources
 */
export interface RunnerDeploymentSpecTemplateSpecEphemeralContainersResources {
  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersResources#limits
   */
  readonly limits?: { [key: string]: RunnerDeploymentSpecTemplateSpecEphemeralContainersResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersResources#requests
   */
  readonly requests?: { [key: string]: RunnerDeploymentSpecTemplateSpecEphemeralContainersResourcesRequests };

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecEphemeralContainersResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersResources(obj: RunnerDeploymentSpecTemplateSpecEphemeralContainersResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Optional: SecurityContext defines the security options the ephemeral container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
 *
 * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersSecurityContext
 */
export interface RunnerDeploymentSpecTemplateSpecEphemeralContainersSecurityContext {
  /**
   * AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process. This bool directly controls if the no_new_privs flag will be set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP_SYS_ADMIN Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersSecurityContext#capabilities
   */
  readonly capabilities?: RunnerDeploymentSpecTemplateSpecEphemeralContainersSecurityContextCapabilities;

  /**
   * Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. Defaults to false. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false. Note that this field cannot be set when spec.os.name is windows.
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * procMount denotes the type of proc mount to use for the containers. The default is DefaultProcMount which uses the container runtime defaults for readonly paths and masked paths. This requires the ProcMountType feature flag to be enabled. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * Whether this container has a read-only root filesystem. Default is false. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false. Note that this field cannot be set when spec.os.name is windows.
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: RunnerDeploymentSpecTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by this container. If seccomp options are provided at both the pod & container level, the container options override the pod options. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersSecurityContext#seccompProfile
   */
  readonly seccompProfile?: RunnerDeploymentSpecTemplateSpecEphemeralContainersSecurityContextSeccompProfile;

  /**
   * The Windows specific settings applied to all containers. If unspecified, the options from the PodSecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersSecurityContext#windowsOptions
   */
  readonly windowsOptions?: RunnerDeploymentSpecTemplateSpecEphemeralContainersSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecEphemeralContainersSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersSecurityContext(obj: RunnerDeploymentSpecTemplateSpecEphemeralContainersSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowPrivilegeEscalation': obj.allowPrivilegeEscalation,
    'capabilities': toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersSecurityContextCapabilities(obj.capabilities),
    'privileged': obj.privileged,
    'procMount': obj.procMount,
    'readOnlyRootFilesystem': obj.readOnlyRootFilesystem,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersSecurityContextSeccompProfile(obj.seccompProfile),
    'windowsOptions': toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Probes are not allowed for ephemeral containers.
 *
 * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbe
 */
export interface RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbe#exec
   */
  readonly exec?: RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbe#grpc
   */
  readonly grpc?: RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbe#httpGet
   */
  readonly httpGet?: RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbe#tcpSocket
   */
  readonly tcpSocket?: RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbe(obj: RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeGrpc(obj.grpc),
    'httpGet': toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * volumeDevice describes a mapping of a raw block device within a container.
 *
 * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersVolumeDevices
 */
export interface RunnerDeploymentSpecTemplateSpecEphemeralContainersVolumeDevices {
  /**
   * devicePath is the path inside of the container that the device will be mapped to.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersVolumeDevices#devicePath
   */
  readonly devicePath: string;

  /**
   * name must match the name of a persistentVolumeClaim in the pod
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersVolumeDevices#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecEphemeralContainersVolumeDevices' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersVolumeDevices(obj: RunnerDeploymentSpecTemplateSpecEphemeralContainersVolumeDevices | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'devicePath': obj.devicePath,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersVolumeMounts
 */
export interface RunnerDeploymentSpecTemplateSpecEphemeralContainersVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must not contain ':'.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. This field is beta in 1.10.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.
   *
   * @default false.
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment. Defaults to "" (volume's root). SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root). SubPathExpr and SubPath are mutually exclusive.
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecEphemeralContainersVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersVolumeMounts(obj: RunnerDeploymentSpecTemplateSpecEphemeralContainersVolumeMounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'mountPropagation': obj.mountPropagation,
    'name': obj.name,
    'readOnly': obj.readOnly,
    'subPath': obj.subPath,
    'subPathExpr': obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema RunnerDeploymentSpecTemplateSpecInitContainersEnv
 */
export interface RunnerDeploymentSpecTemplateSpecInitContainersEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded using the previously defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
   *
   * @default .
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersEnv#valueFrom
   */
  readonly valueFrom?: RunnerDeploymentSpecTemplateSpecInitContainersEnvValueFrom;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecInitContainersEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecInitContainersEnv(obj: RunnerDeploymentSpecTemplateSpecInitContainersEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
    'valueFrom': toJson_RunnerDeploymentSpecTemplateSpecInitContainersEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema RunnerDeploymentSpecTemplateSpecInitContainersEnvFrom
 */
export interface RunnerDeploymentSpecTemplateSpecInitContainersEnvFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersEnvFrom#configMapRef
   */
  readonly configMapRef?: RunnerDeploymentSpecTemplateSpecInitContainersEnvFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersEnvFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersEnvFrom#secretRef
   */
  readonly secretRef?: RunnerDeploymentSpecTemplateSpecInitContainersEnvFromSecretRef;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecInitContainersEnvFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecInitContainersEnvFrom(obj: RunnerDeploymentSpecTemplateSpecInitContainersEnvFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapRef': toJson_RunnerDeploymentSpecTemplateSpecInitContainersEnvFromConfigMapRef(obj.configMapRef),
    'prefix': obj.prefix,
    'secretRef': toJson_RunnerDeploymentSpecTemplateSpecInitContainersEnvFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Actions that the management system should take in response to container lifecycle events. Cannot be updated.
 *
 * @schema RunnerDeploymentSpecTemplateSpecInitContainersLifecycle
 */
export interface RunnerDeploymentSpecTemplateSpecInitContainersLifecycle {
  /**
   * PostStart is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersLifecycle#postStart
   */
  readonly postStart?: RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePostStart;

  /**
   * PreStop is called immediately before a container is terminated due to an API request or management event such as liveness/startup probe failure, preemption, resource contention, etc. The handler is not called if the container crashes or exits. The Pod's termination grace period countdown begins before the PreStop hook is executed. Regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period (unless delayed by finalizers). Other management of the container blocks until the hook completes or until the termination grace period is reached. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersLifecycle#preStop
   */
  readonly preStop?: RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePreStop;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecInitContainersLifecycle' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecInitContainersLifecycle(obj: RunnerDeploymentSpecTemplateSpecInitContainersLifecycle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'postStart': toJson_RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePostStart(obj.postStart),
    'preStop': toJson_RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePreStop(obj.preStop),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbe
 */
export interface RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbe#exec
   */
  readonly exec?: RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbe#grpc
   */
  readonly grpc?: RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbe#httpGet
   */
  readonly httpGet?: RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbe#tcpSocket
   */
  readonly tcpSocket?: RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbe(obj: RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbeGrpc(obj.grpc),
    'httpGet': toJson_RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ContainerPort represents a network port in a single container.
 *
 * @schema RunnerDeploymentSpecTemplateSpecInitContainersPorts
 */
export interface RunnerDeploymentSpecTemplateSpecInitContainersPorts {
  /**
   * Number of port to expose on the pod's IP address. This must be a valid port number, 0 < x < 65536.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersPorts#containerPort
   */
  readonly containerPort: number;

  /**
   * What host IP to bind the external port to.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersPorts#hostIP
   */
  readonly hostIp?: string;

  /**
   * Number of port to expose on the host. If specified, this must be a valid port number, 0 < x < 65536. If HostNetwork is specified, this must match ContainerPort. Most containers do not need this.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersPorts#hostPort
   */
  readonly hostPort?: number;

  /**
   * If specified, this must be an IANA_SVC_NAME and unique within the pod. Each named port in a pod must have a unique name. Name for the port that can be referred to by services.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersPorts#name
   */
  readonly name?: string;

  /**
   * Protocol for port. Must be UDP, TCP, or SCTP. Defaults to "TCP".
   *
   * @default TCP".
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersPorts#protocol
   */
  readonly protocol?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecInitContainersPorts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecInitContainersPorts(obj: RunnerDeploymentSpecTemplateSpecInitContainersPorts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerPort': obj.containerPort,
    'hostIP': obj.hostIp,
    'hostPort': obj.hostPort,
    'name': obj.name,
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbe
 */
export interface RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbe#exec
   */
  readonly exec?: RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbe#grpc
   */
  readonly grpc?: RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbe#httpGet
   */
  readonly httpGet?: RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbe#tcpSocket
   */
  readonly tcpSocket?: RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbe(obj: RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbeGrpc(obj.grpc),
    'httpGet': toJson_RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
 *
 * @schema RunnerDeploymentSpecTemplateSpecInitContainersResources
 */
export interface RunnerDeploymentSpecTemplateSpecInitContainersResources {
  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersResources#limits
   */
  readonly limits?: { [key: string]: RunnerDeploymentSpecTemplateSpecInitContainersResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersResources#requests
   */
  readonly requests?: { [key: string]: RunnerDeploymentSpecTemplateSpecInitContainersResourcesRequests };

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecInitContainersResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecInitContainersResources(obj: RunnerDeploymentSpecTemplateSpecInitContainersResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecurityContext defines the security options the container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
 *
 * @schema RunnerDeploymentSpecTemplateSpecInitContainersSecurityContext
 */
export interface RunnerDeploymentSpecTemplateSpecInitContainersSecurityContext {
  /**
   * AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process. This bool directly controls if the no_new_privs flag will be set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP_SYS_ADMIN Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersSecurityContext#capabilities
   */
  readonly capabilities?: RunnerDeploymentSpecTemplateSpecInitContainersSecurityContextCapabilities;

  /**
   * Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. Defaults to false. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false. Note that this field cannot be set when spec.os.name is windows.
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * procMount denotes the type of proc mount to use for the containers. The default is DefaultProcMount which uses the container runtime defaults for readonly paths and masked paths. This requires the ProcMountType feature flag to be enabled. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * Whether this container has a read-only root filesystem. Default is false. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false. Note that this field cannot be set when spec.os.name is windows.
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: RunnerDeploymentSpecTemplateSpecInitContainersSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by this container. If seccomp options are provided at both the pod & container level, the container options override the pod options. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersSecurityContext#seccompProfile
   */
  readonly seccompProfile?: RunnerDeploymentSpecTemplateSpecInitContainersSecurityContextSeccompProfile;

  /**
   * The Windows specific settings applied to all containers. If unspecified, the options from the PodSecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersSecurityContext#windowsOptions
   */
  readonly windowsOptions?: RunnerDeploymentSpecTemplateSpecInitContainersSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecInitContainersSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecInitContainersSecurityContext(obj: RunnerDeploymentSpecTemplateSpecInitContainersSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowPrivilegeEscalation': obj.allowPrivilegeEscalation,
    'capabilities': toJson_RunnerDeploymentSpecTemplateSpecInitContainersSecurityContextCapabilities(obj.capabilities),
    'privileged': obj.privileged,
    'procMount': obj.procMount,
    'readOnlyRootFilesystem': obj.readOnlyRootFilesystem,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_RunnerDeploymentSpecTemplateSpecInitContainersSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_RunnerDeploymentSpecTemplateSpecInitContainersSecurityContextSeccompProfile(obj.seccompProfile),
    'windowsOptions': toJson_RunnerDeploymentSpecTemplateSpecInitContainersSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema RunnerDeploymentSpecTemplateSpecInitContainersStartupProbe
 */
export interface RunnerDeploymentSpecTemplateSpecInitContainersStartupProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersStartupProbe#exec
   */
  readonly exec?: RunnerDeploymentSpecTemplateSpecInitContainersStartupProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersStartupProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersStartupProbe#grpc
   */
  readonly grpc?: RunnerDeploymentSpecTemplateSpecInitContainersStartupProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersStartupProbe#httpGet
   */
  readonly httpGet?: RunnerDeploymentSpecTemplateSpecInitContainersStartupProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersStartupProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersStartupProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersStartupProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersStartupProbe#tcpSocket
   */
  readonly tcpSocket?: RunnerDeploymentSpecTemplateSpecInitContainersStartupProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersStartupProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersStartupProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecInitContainersStartupProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecInitContainersStartupProbe(obj: RunnerDeploymentSpecTemplateSpecInitContainersStartupProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_RunnerDeploymentSpecTemplateSpecInitContainersStartupProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_RunnerDeploymentSpecTemplateSpecInitContainersStartupProbeGrpc(obj.grpc),
    'httpGet': toJson_RunnerDeploymentSpecTemplateSpecInitContainersStartupProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_RunnerDeploymentSpecTemplateSpecInitContainersStartupProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * volumeDevice describes a mapping of a raw block device within a container.
 *
 * @schema RunnerDeploymentSpecTemplateSpecInitContainersVolumeDevices
 */
export interface RunnerDeploymentSpecTemplateSpecInitContainersVolumeDevices {
  /**
   * devicePath is the path inside of the container that the device will be mapped to.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersVolumeDevices#devicePath
   */
  readonly devicePath: string;

  /**
   * name must match the name of a persistentVolumeClaim in the pod
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersVolumeDevices#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecInitContainersVolumeDevices' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecInitContainersVolumeDevices(obj: RunnerDeploymentSpecTemplateSpecInitContainersVolumeDevices | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'devicePath': obj.devicePath,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema RunnerDeploymentSpecTemplateSpecInitContainersVolumeMounts
 */
export interface RunnerDeploymentSpecTemplateSpecInitContainersVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must not contain ':'.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. This field is beta in 1.10.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.
   *
   * @default false.
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment. Defaults to "" (volume's root). SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root). SubPathExpr and SubPath are mutually exclusive.
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecInitContainersVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecInitContainersVolumeMounts(obj: RunnerDeploymentSpecTemplateSpecInitContainersVolumeMounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'mountPropagation': obj.mountPropagation,
    'name': obj.name,
    'readOnly': obj.readOnly,
    'subPath': obj.subPath,
    'subPathExpr': obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RunnerDeploymentSpecTemplateSpecResourcesLimits
 */
export class RunnerDeploymentSpecTemplateSpecResourcesLimits {
  public static fromNumber(value: number): RunnerDeploymentSpecTemplateSpecResourcesLimits {
    return new RunnerDeploymentSpecTemplateSpecResourcesLimits(value);
  }
  public static fromString(value: string): RunnerDeploymentSpecTemplateSpecResourcesLimits {
    return new RunnerDeploymentSpecTemplateSpecResourcesLimits(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * @schema RunnerDeploymentSpecTemplateSpecResourcesRequests
 */
export class RunnerDeploymentSpecTemplateSpecResourcesRequests {
  public static fromNumber(value: number): RunnerDeploymentSpecTemplateSpecResourcesRequests {
    return new RunnerDeploymentSpecTemplateSpecResourcesRequests(value);
  }
  public static fromString(value: string): RunnerDeploymentSpecTemplateSpecResourcesRequests {
    return new RunnerDeploymentSpecTemplateSpecResourcesRequests(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema RunnerDeploymentSpecTemplateSpecSecurityContextSeLinuxOptions
 */
export interface RunnerDeploymentSpecTemplateSpecSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecSecurityContextSeLinuxOptions(obj: RunnerDeploymentSpecTemplateSpecSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema RunnerDeploymentSpecTemplateSpecSecurityContextSeccompProfile
 */
export interface RunnerDeploymentSpecTemplateSpecSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Must be a descending path, relative to the kubelet's configured seccomp profile location. Must only be set if type is "Localhost".
   *
   * @schema RunnerDeploymentSpecTemplateSpecSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied. Valid options are:
   * Localhost - a profile defined in a file on the node should be used. RuntimeDefault - the container runtime default profile should be used. Unconfined - no profile should be applied.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSecurityContextSeccompProfile#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecSecurityContextSeccompProfile(obj: RunnerDeploymentSpecTemplateSpecSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Sysctl defines a kernel parameter to be set
 *
 * @schema RunnerDeploymentSpecTemplateSpecSecurityContextSysctls
 */
export interface RunnerDeploymentSpecTemplateSpecSecurityContextSysctls {
  /**
   * Name of a property to set
   *
   * @schema RunnerDeploymentSpecTemplateSpecSecurityContextSysctls#name
   */
  readonly name: string;

  /**
   * Value of a property to set
   *
   * @schema RunnerDeploymentSpecTemplateSpecSecurityContextSysctls#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecSecurityContextSysctls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecSecurityContextSysctls(obj: RunnerDeploymentSpecTemplateSpecSecurityContextSysctls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Windows specific settings applied to all containers. If unspecified, the options within a container's SecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema RunnerDeploymentSpecTemplateSpecSecurityContextWindowsOptions
 */
export interface RunnerDeploymentSpecTemplateSpecSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container. This field is alpha-level and will only be honored by components that enable the WindowsHostProcessContainers feature flag. Setting this field without the feature flag will result in errors when validating the Pod. All of a Pod's containers must have the same effective HostProcess value (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).  In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process. Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * @schema RunnerDeploymentSpecTemplateSpecSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecSecurityContextWindowsOptions(obj: RunnerDeploymentSpecTemplateSpecSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersEnv
 */
export interface RunnerDeploymentSpecTemplateSpecSidecarContainersEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded using the previously defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
   *
   * @default .
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersEnv#valueFrom
   */
  readonly valueFrom?: RunnerDeploymentSpecTemplateSpecSidecarContainersEnvValueFrom;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecSidecarContainersEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersEnv(obj: RunnerDeploymentSpecTemplateSpecSidecarContainersEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
    'valueFrom': toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersEnvFrom
 */
export interface RunnerDeploymentSpecTemplateSpecSidecarContainersEnvFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersEnvFrom#configMapRef
   */
  readonly configMapRef?: RunnerDeploymentSpecTemplateSpecSidecarContainersEnvFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersEnvFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersEnvFrom#secretRef
   */
  readonly secretRef?: RunnerDeploymentSpecTemplateSpecSidecarContainersEnvFromSecretRef;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecSidecarContainersEnvFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersEnvFrom(obj: RunnerDeploymentSpecTemplateSpecSidecarContainersEnvFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapRef': toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersEnvFromConfigMapRef(obj.configMapRef),
    'prefix': obj.prefix,
    'secretRef': toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersEnvFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Actions that the management system should take in response to container lifecycle events. Cannot be updated.
 *
 * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersLifecycle
 */
export interface RunnerDeploymentSpecTemplateSpecSidecarContainersLifecycle {
  /**
   * PostStart is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersLifecycle#postStart
   */
  readonly postStart?: RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePostStart;

  /**
   * PreStop is called immediately before a container is terminated due to an API request or management event such as liveness/startup probe failure, preemption, resource contention, etc. The handler is not called if the container crashes or exits. The Pod's termination grace period countdown begins before the PreStop hook is executed. Regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period (unless delayed by finalizers). Other management of the container blocks until the hook completes or until the termination grace period is reached. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersLifecycle#preStop
   */
  readonly preStop?: RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePreStop;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecSidecarContainersLifecycle' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersLifecycle(obj: RunnerDeploymentSpecTemplateSpecSidecarContainersLifecycle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'postStart': toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePostStart(obj.postStart),
    'preStop': toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePreStop(obj.preStop),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbe
 */
export interface RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbe#exec
   */
  readonly exec?: RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbe#grpc
   */
  readonly grpc?: RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbe#httpGet
   */
  readonly httpGet?: RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbe#tcpSocket
   */
  readonly tcpSocket?: RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbe(obj: RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbeGrpc(obj.grpc),
    'httpGet': toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ContainerPort represents a network port in a single container.
 *
 * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersPorts
 */
export interface RunnerDeploymentSpecTemplateSpecSidecarContainersPorts {
  /**
   * Number of port to expose on the pod's IP address. This must be a valid port number, 0 < x < 65536.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersPorts#containerPort
   */
  readonly containerPort: number;

  /**
   * What host IP to bind the external port to.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersPorts#hostIP
   */
  readonly hostIp?: string;

  /**
   * Number of port to expose on the host. If specified, this must be a valid port number, 0 < x < 65536. If HostNetwork is specified, this must match ContainerPort. Most containers do not need this.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersPorts#hostPort
   */
  readonly hostPort?: number;

  /**
   * If specified, this must be an IANA_SVC_NAME and unique within the pod. Each named port in a pod must have a unique name. Name for the port that can be referred to by services.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersPorts#name
   */
  readonly name?: string;

  /**
   * Protocol for port. Must be UDP, TCP, or SCTP. Defaults to "TCP".
   *
   * @default TCP".
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersPorts#protocol
   */
  readonly protocol?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecSidecarContainersPorts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersPorts(obj: RunnerDeploymentSpecTemplateSpecSidecarContainersPorts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerPort': obj.containerPort,
    'hostIP': obj.hostIp,
    'hostPort': obj.hostPort,
    'name': obj.name,
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbe
 */
export interface RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbe#exec
   */
  readonly exec?: RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbe#grpc
   */
  readonly grpc?: RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbe#httpGet
   */
  readonly httpGet?: RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbe#tcpSocket
   */
  readonly tcpSocket?: RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbe(obj: RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbeGrpc(obj.grpc),
    'httpGet': toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
 *
 * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersResources
 */
export interface RunnerDeploymentSpecTemplateSpecSidecarContainersResources {
  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersResources#limits
   */
  readonly limits?: { [key: string]: RunnerDeploymentSpecTemplateSpecSidecarContainersResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersResources#requests
   */
  readonly requests?: { [key: string]: RunnerDeploymentSpecTemplateSpecSidecarContainersResourcesRequests };

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecSidecarContainersResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersResources(obj: RunnerDeploymentSpecTemplateSpecSidecarContainersResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecurityContext defines the security options the container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
 *
 * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersSecurityContext
 */
export interface RunnerDeploymentSpecTemplateSpecSidecarContainersSecurityContext {
  /**
   * AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process. This bool directly controls if the no_new_privs flag will be set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP_SYS_ADMIN Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersSecurityContext#capabilities
   */
  readonly capabilities?: RunnerDeploymentSpecTemplateSpecSidecarContainersSecurityContextCapabilities;

  /**
   * Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. Defaults to false. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false. Note that this field cannot be set when spec.os.name is windows.
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * procMount denotes the type of proc mount to use for the containers. The default is DefaultProcMount which uses the container runtime defaults for readonly paths and masked paths. This requires the ProcMountType feature flag to be enabled. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * Whether this container has a read-only root filesystem. Default is false. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false. Note that this field cannot be set when spec.os.name is windows.
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: RunnerDeploymentSpecTemplateSpecSidecarContainersSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by this container. If seccomp options are provided at both the pod & container level, the container options override the pod options. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersSecurityContext#seccompProfile
   */
  readonly seccompProfile?: RunnerDeploymentSpecTemplateSpecSidecarContainersSecurityContextSeccompProfile;

  /**
   * The Windows specific settings applied to all containers. If unspecified, the options from the PodSecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersSecurityContext#windowsOptions
   */
  readonly windowsOptions?: RunnerDeploymentSpecTemplateSpecSidecarContainersSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecSidecarContainersSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersSecurityContext(obj: RunnerDeploymentSpecTemplateSpecSidecarContainersSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowPrivilegeEscalation': obj.allowPrivilegeEscalation,
    'capabilities': toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersSecurityContextCapabilities(obj.capabilities),
    'privileged': obj.privileged,
    'procMount': obj.procMount,
    'readOnlyRootFilesystem': obj.readOnlyRootFilesystem,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersSecurityContextSeccompProfile(obj.seccompProfile),
    'windowsOptions': toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbe
 */
export interface RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbe#exec
   */
  readonly exec?: RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbe#grpc
   */
  readonly grpc?: RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbe#httpGet
   */
  readonly httpGet?: RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbe#tcpSocket
   */
  readonly tcpSocket?: RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbe(obj: RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbeGrpc(obj.grpc),
    'httpGet': toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * volumeDevice describes a mapping of a raw block device within a container.
 *
 * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersVolumeDevices
 */
export interface RunnerDeploymentSpecTemplateSpecSidecarContainersVolumeDevices {
  /**
   * devicePath is the path inside of the container that the device will be mapped to.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersVolumeDevices#devicePath
   */
  readonly devicePath: string;

  /**
   * name must match the name of a persistentVolumeClaim in the pod
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersVolumeDevices#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecSidecarContainersVolumeDevices' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersVolumeDevices(obj: RunnerDeploymentSpecTemplateSpecSidecarContainersVolumeDevices | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'devicePath': obj.devicePath,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersVolumeMounts
 */
export interface RunnerDeploymentSpecTemplateSpecSidecarContainersVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must not contain ':'.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. This field is beta in 1.10.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.
   *
   * @default false.
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment. Defaults to "" (volume's root). SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root). SubPathExpr and SubPath are mutually exclusive.
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecSidecarContainersVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersVolumeMounts(obj: RunnerDeploymentSpecTemplateSpecSidecarContainersVolumeMounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'mountPropagation': obj.mountPropagation,
    'name': obj.name,
    'readOnly': obj.readOnly,
    'subPath': obj.subPath,
    'subPathExpr': obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LabelSelector is used to find matching pods. Pods that match this label selector are counted to determine the number of pods in their corresponding topology domain.
 *
 * @schema RunnerDeploymentSpecTemplateSpecTopologySpreadConstraintLabelSelector
 */
export interface RunnerDeploymentSpecTemplateSpecTopologySpreadConstraintLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema RunnerDeploymentSpecTemplateSpecTopologySpreadConstraintLabelSelector#matchExpressions
   */
  readonly matchExpressions?: RunnerDeploymentSpecTemplateSpecTopologySpreadConstraintLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema RunnerDeploymentSpecTemplateSpecTopologySpreadConstraintLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecTopologySpreadConstraintLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecTopologySpreadConstraintLabelSelector(obj: RunnerDeploymentSpecTemplateSpecTopologySpreadConstraintLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_RunnerDeploymentSpecTemplateSpecTopologySpreadConstraintLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AWSElasticBlockStore represents an AWS Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
 *
 * @schema RunnerDeploymentSpecTemplateSpecVolumesAwsElasticBlockStore
 */
export interface RunnerDeploymentSpecTemplateSpecVolumesAwsElasticBlockStore {
  /**
   * Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesAwsElasticBlockStore#fsType
   */
  readonly fsType?: string;

  /**
   * The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as "1". Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesAwsElasticBlockStore#partition
   */
  readonly partition?: number;

  /**
   * Specify "true" to force and set the ReadOnly property in VolumeMounts to "true". If omitted, the default is "false". More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesAwsElasticBlockStore#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesAwsElasticBlockStore#volumeID
   */
  readonly volumeId: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecVolumesAwsElasticBlockStore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecVolumesAwsElasticBlockStore(obj: RunnerDeploymentSpecTemplateSpecVolumesAwsElasticBlockStore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'partition': obj.partition,
    'readOnly': obj.readOnly,
    'volumeID': obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
 *
 * @schema RunnerDeploymentSpecTemplateSpecVolumesAzureDisk
 */
export interface RunnerDeploymentSpecTemplateSpecVolumesAzureDisk {
  /**
   * Host Caching mode: None, Read Only, Read Write.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesAzureDisk#cachingMode
   */
  readonly cachingMode?: string;

  /**
   * The Name of the data disk in the blob storage
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesAzureDisk#diskName
   */
  readonly diskName: string;

  /**
   * The URI the data disk in the blob storage
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesAzureDisk#diskURI
   */
  readonly diskUri: string;

  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesAzureDisk#fsType
   */
  readonly fsType?: string;

  /**
   * Expected values Shared: multiple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesAzureDisk#kind
   */
  readonly kind?: string;

  /**
   * Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema RunnerDeploymentSpecTemplateSpecVolumesAzureDisk#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecVolumesAzureDisk' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecVolumesAzureDisk(obj: RunnerDeploymentSpecTemplateSpecVolumesAzureDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cachingMode': obj.cachingMode,
    'diskName': obj.diskName,
    'diskURI': obj.diskUri,
    'fsType': obj.fsType,
    'kind': obj.kind,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
 *
 * @schema RunnerDeploymentSpecTemplateSpecVolumesAzureFile
 */
export interface RunnerDeploymentSpecTemplateSpecVolumesAzureFile {
  /**
   * Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema RunnerDeploymentSpecTemplateSpecVolumesAzureFile#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * the name of secret that contains Azure Storage Account Name and Key
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesAzureFile#secretName
   */
  readonly secretName: string;

  /**
   * Share Name
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesAzureFile#shareName
   */
  readonly shareName: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecVolumesAzureFile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecVolumesAzureFile(obj: RunnerDeploymentSpecTemplateSpecVolumesAzureFile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'readOnly': obj.readOnly,
    'secretName': obj.secretName,
    'shareName': obj.shareName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CephFS represents a Ceph FS mount on the host that shares a pod's lifetime
 *
 * @schema RunnerDeploymentSpecTemplateSpecVolumesCephfs
 */
export interface RunnerDeploymentSpecTemplateSpecVolumesCephfs {
  /**
   * Required: Monitors is a collection of Ceph monitors More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesCephfs#monitors
   */
  readonly monitors: string[];

  /**
   * Optional: Used as the mounted root, rather than the full Ceph tree, default is /
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesCephfs#path
   */
  readonly path?: string;

  /**
   * Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   * @schema RunnerDeploymentSpecTemplateSpecVolumesCephfs#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesCephfs#secretFile
   */
  readonly secretFile?: string;

  /**
   * Optional: SecretRef is reference to the authentication secret for User, default is empty. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesCephfs#secretRef
   */
  readonly secretRef?: RunnerDeploymentSpecTemplateSpecVolumesCephfsSecretRef;

  /**
   * Optional: User is the rados user name, default is admin More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesCephfs#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecVolumesCephfs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecVolumesCephfs(obj: RunnerDeploymentSpecTemplateSpecVolumesCephfs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'monitors': obj.monitors?.map(y => y),
    'path': obj.path,
    'readOnly': obj.readOnly,
    'secretFile': obj.secretFile,
    'secretRef': toJson_RunnerDeploymentSpecTemplateSpecVolumesCephfsSecretRef(obj.secretRef),
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Cinder represents a cinder volume attached and mounted on kubelets host machine. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
 *
 * @schema RunnerDeploymentSpecTemplateSpecVolumesCinder
 */
export interface RunnerDeploymentSpecTemplateSpecVolumesCinder {
  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesCinder#fsType
   */
  readonly fsType?: string;

  /**
   * Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   * @schema RunnerDeploymentSpecTemplateSpecVolumesCinder#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Optional: points to a secret object containing parameters used to connect to OpenStack.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesCinder#secretRef
   */
  readonly secretRef?: RunnerDeploymentSpecTemplateSpecVolumesCinderSecretRef;

  /**
   * volume id used to identify the volume in cinder. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesCinder#volumeID
   */
  readonly volumeId: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecVolumesCinder' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecVolumesCinder(obj: RunnerDeploymentSpecTemplateSpecVolumesCinder | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'readOnly': obj.readOnly,
    'secretRef': toJson_RunnerDeploymentSpecTemplateSpecVolumesCinderSecretRef(obj.secretRef),
    'volumeID': obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap represents a configMap that should populate this volume
 *
 * @schema RunnerDeploymentSpecTemplateSpecVolumesConfigMap
 */
export interface RunnerDeploymentSpecTemplateSpecVolumesConfigMap {
  /**
   * Optional: mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   * @schema RunnerDeploymentSpecTemplateSpecVolumesConfigMap#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesConfigMap#items
   */
  readonly items?: RunnerDeploymentSpecTemplateSpecVolumesConfigMapItems[];

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its keys must be defined
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecVolumesConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecVolumesConfigMap(obj: RunnerDeploymentSpecTemplateSpecVolumesConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_RunnerDeploymentSpecTemplateSpecVolumesConfigMapItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CSI (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers (Beta feature).
 *
 * @schema RunnerDeploymentSpecTemplateSpecVolumesCsi
 */
export interface RunnerDeploymentSpecTemplateSpecVolumesCsi {
  /**
   * Driver is the name of the CSI driver that handles this volume. Consult with your admin for the correct name as registered in the cluster.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesCsi#driver
   */
  readonly driver: string;

  /**
   * Filesystem type to mount. Ex. "ext4", "xfs", "ntfs". If not provided, the empty value is passed to the associated CSI driver which will determine the default filesystem to apply.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesCsi#fsType
   */
  readonly fsType?: string;

  /**
   * NodePublishSecretRef is a reference to the secret object containing sensitive information to pass to the CSI driver to complete the CSI NodePublishVolume and NodeUnpublishVolume calls. This field is optional, and  may be empty if no secret is required. If the secret object contains more than one secret, all secret references are passed.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesCsi#nodePublishSecretRef
   */
  readonly nodePublishSecretRef?: RunnerDeploymentSpecTemplateSpecVolumesCsiNodePublishSecretRef;

  /**
   * Specifies a read-only configuration for the volume. Defaults to false (read/write).
   *
   * @default false (read/write).
   * @schema RunnerDeploymentSpecTemplateSpecVolumesCsi#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * VolumeAttributes stores driver-specific properties that are passed to the CSI driver. Consult your driver's documentation for supported values.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesCsi#volumeAttributes
   */
  readonly volumeAttributes?: { [key: string]: string };

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecVolumesCsi' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecVolumesCsi(obj: RunnerDeploymentSpecTemplateSpecVolumesCsi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'driver': obj.driver,
    'fsType': obj.fsType,
    'nodePublishSecretRef': toJson_RunnerDeploymentSpecTemplateSpecVolumesCsiNodePublishSecretRef(obj.nodePublishSecretRef),
    'readOnly': obj.readOnly,
    'volumeAttributes': ((obj.volumeAttributes) === undefined) ? undefined : (Object.entries(obj.volumeAttributes).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DownwardAPI represents downward API about the pod that should populate this volume
 *
 * @schema RunnerDeploymentSpecTemplateSpecVolumesDownwardApi
 */
export interface RunnerDeploymentSpecTemplateSpecVolumesDownwardApi {
  /**
   * Optional: mode bits to use on created files by default. Must be a Optional: mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   * @schema RunnerDeploymentSpecTemplateSpecVolumesDownwardApi#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * Items is a list of downward API volume file
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesDownwardApi#items
   */
  readonly items?: RunnerDeploymentSpecTemplateSpecVolumesDownwardApiItems[];

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecVolumesDownwardApi' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecVolumesDownwardApi(obj: RunnerDeploymentSpecTemplateSpecVolumesDownwardApi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_RunnerDeploymentSpecTemplateSpecVolumesDownwardApiItems(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EmptyDir represents a temporary directory that shares a pod's lifetime. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
 *
 * @schema RunnerDeploymentSpecTemplateSpecVolumesEmptyDir
 */
export interface RunnerDeploymentSpecTemplateSpecVolumesEmptyDir {
  /**
   * What type of storage medium should back this directory. The default is "" which means to use the node's default medium. Must be an empty string (default) or Memory. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesEmptyDir#medium
   */
  readonly medium?: string;

  /**
   * Total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. The default is nil which means that the limit is undefined. More info: http://kubernetes.io/docs/user-guide/volumes#emptydir
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesEmptyDir#sizeLimit
   */
  readonly sizeLimit?: RunnerDeploymentSpecTemplateSpecVolumesEmptyDirSizeLimit;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecVolumesEmptyDir' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecVolumesEmptyDir(obj: RunnerDeploymentSpecTemplateSpecVolumesEmptyDir | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'medium': obj.medium,
    'sizeLimit': obj.sizeLimit?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Ephemeral represents a volume that is handled by a cluster storage driver. The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts, and deleted when the pod is removed.
 * Use this if: a) the volume is only needed while the pod runs, b) features of normal volumes like restoring from snapshot or capacity    tracking are needed, c) the storage driver is specified through a storage class, and d) the storage driver supports dynamic volume provisioning through    a PersistentVolumeClaim (see EphemeralVolumeSource for more    information on the connection between this volume type    and PersistentVolumeClaim).
 * Use PersistentVolumeClaim or one of the vendor-specific APIs for volumes that persist for longer than the lifecycle of an individual pod.
 * Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to be used that way - see the documentation of the driver for more information.
 * A pod can use both types of ephemeral volumes and persistent volumes at the same time.
 *
 * @schema RunnerDeploymentSpecTemplateSpecVolumesEphemeral
 */
export interface RunnerDeploymentSpecTemplateSpecVolumesEphemeral {
  /**
   * Will be used to create a stand-alone PVC to provision the volume. The pod in which this EphemeralVolumeSource is embedded will be the owner of the PVC, i.e. the PVC will be deleted together with the pod.  The name of the PVC will be `<pod name>-<volume name>` where `<volume name>` is the name from the `PodSpec.Volumes` array entry. Pod validation will reject the pod if the concatenated name is not valid for a PVC (for example, too long).
   * An existing PVC with that name that is not owned by the pod will *not* be used for the pod to avoid using an unrelated volume by mistake. Starting the pod is then blocked until the unrelated PVC is removed. If such a pre-created PVC is meant to be used by the pod, the PVC has to updated with an owner reference to the pod once the pod exists. Normally this should not be necessary, but it may be useful when manually reconstructing a broken cluster.
   * This field is read-only and no changes will be made by Kubernetes to the PVC after it has been created.
   * Required, must not be nil.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesEphemeral#volumeClaimTemplate
   */
  readonly volumeClaimTemplate?: RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplate;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecVolumesEphemeral' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecVolumesEphemeral(obj: RunnerDeploymentSpecTemplateSpecVolumesEphemeral | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'volumeClaimTemplate': toJson_RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplate(obj.volumeClaimTemplate),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FC represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
 *
 * @schema RunnerDeploymentSpecTemplateSpecVolumesFc
 */
export interface RunnerDeploymentSpecTemplateSpecVolumesFc {
  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesFc#fsType
   */
  readonly fsType?: string;

  /**
   * Optional: FC target lun number
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesFc#lun
   */
  readonly lun?: number;

  /**
   * Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema RunnerDeploymentSpecTemplateSpecVolumesFc#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Optional: FC target worldwide names (WWNs)
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesFc#targetWWNs
   */
  readonly targetWwNs?: string[];

  /**
   * Optional: FC volume world wide identifiers (wwids) Either wwids or combination of targetWWNs and lun must be set, but not both simultaneously.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesFc#wwids
   */
  readonly wwids?: string[];

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecVolumesFc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecVolumesFc(obj: RunnerDeploymentSpecTemplateSpecVolumesFc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'lun': obj.lun,
    'readOnly': obj.readOnly,
    'targetWWNs': obj.targetWwNs?.map(y => y),
    'wwids': obj.wwids?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FlexVolume represents a generic volume resource that is provisioned/attached using an exec based plugin.
 *
 * @schema RunnerDeploymentSpecTemplateSpecVolumesFlexVolume
 */
export interface RunnerDeploymentSpecTemplateSpecVolumesFlexVolume {
  /**
   * Driver is the name of the driver to use for this volume.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesFlexVolume#driver
   */
  readonly driver: string;

  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesFlexVolume#fsType
   */
  readonly fsType?: string;

  /**
   * Optional: Extra command options if any.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesFlexVolume#options
   */
  readonly options?: { [key: string]: string };

  /**
   * Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema RunnerDeploymentSpecTemplateSpecVolumesFlexVolume#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Optional: SecretRef is reference to the secret object containing sensitive information to pass to the plugin scripts. This may be empty if no secret object is specified. If the secret object contains more than one secret, all secrets are passed to the plugin scripts.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesFlexVolume#secretRef
   */
  readonly secretRef?: RunnerDeploymentSpecTemplateSpecVolumesFlexVolumeSecretRef;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecVolumesFlexVolume' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecVolumesFlexVolume(obj: RunnerDeploymentSpecTemplateSpecVolumesFlexVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'driver': obj.driver,
    'fsType': obj.fsType,
    'options': ((obj.options) === undefined) ? undefined : (Object.entries(obj.options).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'readOnly': obj.readOnly,
    'secretRef': toJson_RunnerDeploymentSpecTemplateSpecVolumesFlexVolumeSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running
 *
 * @schema RunnerDeploymentSpecTemplateSpecVolumesFlocker
 */
export interface RunnerDeploymentSpecTemplateSpecVolumesFlocker {
  /**
   * Name of the dataset stored as metadata -> name on the dataset for Flocker should be considered as deprecated
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesFlocker#datasetName
   */
  readonly datasetName?: string;

  /**
   * UUID of the dataset. This is unique identifier of a Flocker dataset
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesFlocker#datasetUUID
   */
  readonly datasetUuid?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecVolumesFlocker' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecVolumesFlocker(obj: RunnerDeploymentSpecTemplateSpecVolumesFlocker | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'datasetName': obj.datasetName,
    'datasetUUID': obj.datasetUuid,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
 *
 * @schema RunnerDeploymentSpecTemplateSpecVolumesGcePersistentDisk
 */
export interface RunnerDeploymentSpecTemplateSpecVolumesGcePersistentDisk {
  /**
   * Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesGcePersistentDisk#fsType
   */
  readonly fsType?: string;

  /**
   * The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as "1". Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty). More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesGcePersistentDisk#partition
   */
  readonly partition?: number;

  /**
   * Unique name of the PD resource in GCE. Used to identify the disk in GCE. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesGcePersistentDisk#pdName
   */
  readonly pdName: string;

  /**
   * ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @default false. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   * @schema RunnerDeploymentSpecTemplateSpecVolumesGcePersistentDisk#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecVolumesGcePersistentDisk' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecVolumesGcePersistentDisk(obj: RunnerDeploymentSpecTemplateSpecVolumesGcePersistentDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'partition': obj.partition,
    'pdName': obj.pdName,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GitRepo represents a git repository at a particular revision. DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir into the Pod's container.
 *
 * @schema RunnerDeploymentSpecTemplateSpecVolumesGitRepo
 */
export interface RunnerDeploymentSpecTemplateSpecVolumesGitRepo {
  /**
   * Target directory name. Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the git repository.  Otherwise, if specified, the volume will contain the git repository in the subdirectory with the given name.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesGitRepo#directory
   */
  readonly directory?: string;

  /**
   * Repository URL
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesGitRepo#repository
   */
  readonly repository: string;

  /**
   * Commit hash for the specified revision.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesGitRepo#revision
   */
  readonly revision?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecVolumesGitRepo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecVolumesGitRepo(obj: RunnerDeploymentSpecTemplateSpecVolumesGitRepo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'directory': obj.directory,
    'repository': obj.repository,
    'revision': obj.revision,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/glusterfs/README.md
 *
 * @schema RunnerDeploymentSpecTemplateSpecVolumesGlusterfs
 */
export interface RunnerDeploymentSpecTemplateSpecVolumesGlusterfs {
  /**
   * EndpointsName is the endpoint name that details Glusterfs topology. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesGlusterfs#endpoints
   */
  readonly endpoints: string;

  /**
   * Path is the Glusterfs volume path. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesGlusterfs#path
   */
  readonly path: string;

  /**
   * ReadOnly here will force the Glusterfs volume to be mounted with read-only permissions. Defaults to false. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @default false. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   * @schema RunnerDeploymentSpecTemplateSpecVolumesGlusterfs#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecVolumesGlusterfs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecVolumesGlusterfs(obj: RunnerDeploymentSpecTemplateSpecVolumesGlusterfs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'endpoints': obj.endpoints,
    'path': obj.path,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HostPath represents a pre-existing file or directory on the host machine that is directly exposed to the container. This is generally used for system agents or other privileged things that are allowed to see the host machine. Most containers will NOT need this. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath --- TODO(jonesdl) We need to restrict who can use host directory mounts and who can/can not mount host directories as read/write.
 *
 * @schema RunnerDeploymentSpecTemplateSpecVolumesHostPath
 */
export interface RunnerDeploymentSpecTemplateSpecVolumesHostPath {
  /**
   * Path of the directory on the host. If the path is a symlink, it will follow the link to the real path. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesHostPath#path
   */
  readonly path: string;

  /**
   * Type for HostPath Volume Defaults to "" More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @default More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   * @schema RunnerDeploymentSpecTemplateSpecVolumesHostPath#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecVolumesHostPath' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecVolumesHostPath(obj: RunnerDeploymentSpecTemplateSpecVolumesHostPath | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ISCSI represents an ISCSI Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://examples.k8s.io/volumes/iscsi/README.md
 *
 * @schema RunnerDeploymentSpecTemplateSpecVolumesIscsi
 */
export interface RunnerDeploymentSpecTemplateSpecVolumesIscsi {
  /**
   * whether support iSCSI Discovery CHAP authentication
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesIscsi#chapAuthDiscovery
   */
  readonly chapAuthDiscovery?: boolean;

  /**
   * whether support iSCSI Session CHAP authentication
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesIscsi#chapAuthSession
   */
  readonly chapAuthSession?: boolean;

  /**
   * Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesIscsi#fsType
   */
  readonly fsType?: string;

  /**
   * Custom iSCSI Initiator Name. If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface <target portal>:<volume name> will be created for the connection.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesIscsi#initiatorName
   */
  readonly initiatorName?: string;

  /**
   * Target iSCSI Qualified Name.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesIscsi#iqn
   */
  readonly iqn: string;

  /**
   * iSCSI Interface Name that uses an iSCSI transport. Defaults to 'default' (tcp).
   *
   * @default default' (tcp).
   * @schema RunnerDeploymentSpecTemplateSpecVolumesIscsi#iscsiInterface
   */
  readonly iscsiInterface?: string;

  /**
   * iSCSI Target Lun number.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesIscsi#lun
   */
  readonly lun: number;

  /**
   * iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port is other than default (typically TCP ports 860 and 3260).
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesIscsi#portals
   */
  readonly portals?: string[];

  /**
   * ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false.
   *
   * @default false.
   * @schema RunnerDeploymentSpecTemplateSpecVolumesIscsi#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * CHAP Secret for iSCSI target and initiator authentication
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesIscsi#secretRef
   */
  readonly secretRef?: RunnerDeploymentSpecTemplateSpecVolumesIscsiSecretRef;

  /**
   * iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port is other than default (typically TCP ports 860 and 3260).
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesIscsi#targetPortal
   */
  readonly targetPortal: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecVolumesIscsi' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecVolumesIscsi(obj: RunnerDeploymentSpecTemplateSpecVolumesIscsi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'chapAuthDiscovery': obj.chapAuthDiscovery,
    'chapAuthSession': obj.chapAuthSession,
    'fsType': obj.fsType,
    'initiatorName': obj.initiatorName,
    'iqn': obj.iqn,
    'iscsiInterface': obj.iscsiInterface,
    'lun': obj.lun,
    'portals': obj.portals?.map(y => y),
    'readOnly': obj.readOnly,
    'secretRef': toJson_RunnerDeploymentSpecTemplateSpecVolumesIscsiSecretRef(obj.secretRef),
    'targetPortal': obj.targetPortal,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NFS represents an NFS mount on the host that shares a pod's lifetime More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
 *
 * @schema RunnerDeploymentSpecTemplateSpecVolumesNfs
 */
export interface RunnerDeploymentSpecTemplateSpecVolumesNfs {
  /**
   * Path that is exported by the NFS server. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesNfs#path
   */
  readonly path: string;

  /**
   * ReadOnly here will force the NFS export to be mounted with read-only permissions. Defaults to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @default false. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   * @schema RunnerDeploymentSpecTemplateSpecVolumesNfs#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Server is the hostname or IP address of the NFS server. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesNfs#server
   */
  readonly server: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecVolumesNfs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecVolumesNfs(obj: RunnerDeploymentSpecTemplateSpecVolumesNfs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'readOnly': obj.readOnly,
    'server': obj.server,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PersistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in the same namespace. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
 *
 * @schema RunnerDeploymentSpecTemplateSpecVolumesPersistentVolumeClaim
 */
export interface RunnerDeploymentSpecTemplateSpecVolumesPersistentVolumeClaim {
  /**
   * ClaimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesPersistentVolumeClaim#claimName
   */
  readonly claimName: string;

  /**
   * Will force the ReadOnly setting in VolumeMounts. Default false.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesPersistentVolumeClaim#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecVolumesPersistentVolumeClaim' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecVolumesPersistentVolumeClaim(obj: RunnerDeploymentSpecTemplateSpecVolumesPersistentVolumeClaim | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claimName': obj.claimName,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PhotonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
 *
 * @schema RunnerDeploymentSpecTemplateSpecVolumesPhotonPersistentDisk
 */
export interface RunnerDeploymentSpecTemplateSpecVolumesPhotonPersistentDisk {
  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesPhotonPersistentDisk#fsType
   */
  readonly fsType?: string;

  /**
   * ID that identifies Photon Controller persistent disk
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesPhotonPersistentDisk#pdID
   */
  readonly pdId: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecVolumesPhotonPersistentDisk' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecVolumesPhotonPersistentDisk(obj: RunnerDeploymentSpecTemplateSpecVolumesPhotonPersistentDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'pdID': obj.pdId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PortworxVolume represents a portworx volume attached and mounted on kubelets host machine
 *
 * @schema RunnerDeploymentSpecTemplateSpecVolumesPortworxVolume
 */
export interface RunnerDeploymentSpecTemplateSpecVolumesPortworxVolume {
  /**
   * FSType represents the filesystem type to mount Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesPortworxVolume#fsType
   */
  readonly fsType?: string;

  /**
   * Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema RunnerDeploymentSpecTemplateSpecVolumesPortworxVolume#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * VolumeID uniquely identifies a Portworx volume
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesPortworxVolume#volumeID
   */
  readonly volumeId: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecVolumesPortworxVolume' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecVolumesPortworxVolume(obj: RunnerDeploymentSpecTemplateSpecVolumesPortworxVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'readOnly': obj.readOnly,
    'volumeID': obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Items for all in one resources secrets, configmaps, and downward API
 *
 * @schema RunnerDeploymentSpecTemplateSpecVolumesProjected
 */
export interface RunnerDeploymentSpecTemplateSpecVolumesProjected {
  /**
   * Mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesProjected#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * list of volume projections
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesProjected#sources
   */
  readonly sources?: RunnerDeploymentSpecTemplateSpecVolumesProjectedSources[];

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecVolumesProjected' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecVolumesProjected(obj: RunnerDeploymentSpecTemplateSpecVolumesProjected | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'sources': obj.sources?.map(y => toJson_RunnerDeploymentSpecTemplateSpecVolumesProjectedSources(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Quobyte represents a Quobyte mount on the host that shares a pod's lifetime
 *
 * @schema RunnerDeploymentSpecTemplateSpecVolumesQuobyte
 */
export interface RunnerDeploymentSpecTemplateSpecVolumesQuobyte {
  /**
   * Group to map volume access to Default is no group
   *
   * @default no group
   * @schema RunnerDeploymentSpecTemplateSpecVolumesQuobyte#group
   */
  readonly group?: string;

  /**
   * ReadOnly here will force the Quobyte volume to be mounted with read-only permissions. Defaults to false.
   *
   * @default false.
   * @schema RunnerDeploymentSpecTemplateSpecVolumesQuobyte#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Registry represents a single or multiple Quobyte Registry services specified as a string as host:port pair (multiple entries are separated with commas) which acts as the central registry for volumes
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesQuobyte#registry
   */
  readonly registry: string;

  /**
   * Tenant owning the given Quobyte volume in the Backend Used with dynamically provisioned Quobyte volumes, value is set by the plugin
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesQuobyte#tenant
   */
  readonly tenant?: string;

  /**
   * User to map volume access to Defaults to serivceaccount user
   *
   * @default serivceaccount user
   * @schema RunnerDeploymentSpecTemplateSpecVolumesQuobyte#user
   */
  readonly user?: string;

  /**
   * Volume is a string that references an already created Quobyte volume by name.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesQuobyte#volume
   */
  readonly volume: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecVolumesQuobyte' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecVolumesQuobyte(obj: RunnerDeploymentSpecTemplateSpecVolumesQuobyte | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'readOnly': obj.readOnly,
    'registry': obj.registry,
    'tenant': obj.tenant,
    'user': obj.user,
    'volume': obj.volume,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RBD represents a Rados Block Device mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/rbd/README.md
 *
 * @schema RunnerDeploymentSpecTemplateSpecVolumesRbd
 */
export interface RunnerDeploymentSpecTemplateSpecVolumesRbd {
  /**
   * Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesRbd#fsType
   */
  readonly fsType?: string;

  /**
   * The rados image name. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesRbd#image
   */
  readonly image: string;

  /**
   * Keyring is the path to key ring for RBDUser. Default is /etc/ceph/keyring. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default etc/ceph/keyring. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema RunnerDeploymentSpecTemplateSpecVolumesRbd#keyring
   */
  readonly keyring?: string;

  /**
   * A collection of Ceph monitors. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesRbd#monitors
   */
  readonly monitors: string[];

  /**
   * The rados pool name. Default is rbd. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default rbd. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema RunnerDeploymentSpecTemplateSpecVolumesRbd#pool
   */
  readonly pool?: string;

  /**
   * ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default false. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema RunnerDeploymentSpecTemplateSpecVolumesRbd#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * SecretRef is name of the authentication secret for RBDUser. If provided overrides keyring. Default is nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema RunnerDeploymentSpecTemplateSpecVolumesRbd#secretRef
   */
  readonly secretRef?: RunnerDeploymentSpecTemplateSpecVolumesRbdSecretRef;

  /**
   * The rados user name. Default is admin. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default admin. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema RunnerDeploymentSpecTemplateSpecVolumesRbd#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecVolumesRbd' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecVolumesRbd(obj: RunnerDeploymentSpecTemplateSpecVolumesRbd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'image': obj.image,
    'keyring': obj.keyring,
    'monitors': obj.monitors?.map(y => y),
    'pool': obj.pool,
    'readOnly': obj.readOnly,
    'secretRef': toJson_RunnerDeploymentSpecTemplateSpecVolumesRbdSecretRef(obj.secretRef),
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ScaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
 *
 * @schema RunnerDeploymentSpecTemplateSpecVolumesScaleIo
 */
export interface RunnerDeploymentSpecTemplateSpecVolumesScaleIo {
  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Default is "xfs".
   *
   * @default xfs".
   * @schema RunnerDeploymentSpecTemplateSpecVolumesScaleIo#fsType
   */
  readonly fsType?: string;

  /**
   * The host address of the ScaleIO API Gateway.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesScaleIo#gateway
   */
  readonly gateway: string;

  /**
   * The name of the ScaleIO Protection Domain for the configured storage.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesScaleIo#protectionDomain
   */
  readonly protectionDomain?: string;

  /**
   * Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema RunnerDeploymentSpecTemplateSpecVolumesScaleIo#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * SecretRef references to the secret for ScaleIO user and other sensitive information. If this is not provided, Login operation will fail.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesScaleIo#secretRef
   */
  readonly secretRef: RunnerDeploymentSpecTemplateSpecVolumesScaleIoSecretRef;

  /**
   * Flag to enable/disable SSL communication with Gateway, default false
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesScaleIo#sslEnabled
   */
  readonly sslEnabled?: boolean;

  /**
   * Indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned. Default is ThinProvisioned.
   *
   * @default ThinProvisioned.
   * @schema RunnerDeploymentSpecTemplateSpecVolumesScaleIo#storageMode
   */
  readonly storageMode?: string;

  /**
   * The ScaleIO Storage Pool associated with the protection domain.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesScaleIo#storagePool
   */
  readonly storagePool?: string;

  /**
   * The name of the storage system as configured in ScaleIO.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesScaleIo#system
   */
  readonly system: string;

  /**
   * The name of a volume already created in the ScaleIO system that is associated with this volume source.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesScaleIo#volumeName
   */
  readonly volumeName?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecVolumesScaleIo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecVolumesScaleIo(obj: RunnerDeploymentSpecTemplateSpecVolumesScaleIo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'gateway': obj.gateway,
    'protectionDomain': obj.protectionDomain,
    'readOnly': obj.readOnly,
    'secretRef': toJson_RunnerDeploymentSpecTemplateSpecVolumesScaleIoSecretRef(obj.secretRef),
    'sslEnabled': obj.sslEnabled,
    'storageMode': obj.storageMode,
    'storagePool': obj.storagePool,
    'system': obj.system,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
 *
 * @schema RunnerDeploymentSpecTemplateSpecVolumesSecret
 */
export interface RunnerDeploymentSpecTemplateSpecVolumesSecret {
  /**
   * Optional: mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   * @schema RunnerDeploymentSpecTemplateSpecVolumesSecret#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesSecret#items
   */
  readonly items?: RunnerDeploymentSpecTemplateSpecVolumesSecretItems[];

  /**
   * Specify whether the Secret or its keys must be defined
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesSecret#optional
   */
  readonly optional?: boolean;

  /**
   * Name of the secret in the pod's namespace to use. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesSecret#secretName
   */
  readonly secretName?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecVolumesSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecVolumesSecret(obj: RunnerDeploymentSpecTemplateSpecVolumesSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_RunnerDeploymentSpecTemplateSpecVolumesSecretItems(y)),
    'optional': obj.optional,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * StorageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
 *
 * @schema RunnerDeploymentSpecTemplateSpecVolumesStorageos
 */
export interface RunnerDeploymentSpecTemplateSpecVolumesStorageos {
  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesStorageos#fsType
   */
  readonly fsType?: string;

  /**
   * Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema RunnerDeploymentSpecTemplateSpecVolumesStorageos#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * SecretRef specifies the secret to use for obtaining the StorageOS API credentials.  If not specified, default values will be attempted.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesStorageos#secretRef
   */
  readonly secretRef?: RunnerDeploymentSpecTemplateSpecVolumesStorageosSecretRef;

  /**
   * VolumeName is the human-readable name of the StorageOS volume.  Volume names are only unique within a namespace.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesStorageos#volumeName
   */
  readonly volumeName?: string;

  /**
   * VolumeNamespace specifies the scope of the volume within StorageOS.  If no namespace is specified then the Pod's namespace will be used.  This allows the Kubernetes name scoping to be mirrored within StorageOS for tighter integration. Set VolumeName to any name to override the default behaviour. Set to "default" if you are not using namespaces within StorageOS. Namespaces that do not pre-exist within StorageOS will be created.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesStorageos#volumeNamespace
   */
  readonly volumeNamespace?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecVolumesStorageos' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecVolumesStorageos(obj: RunnerDeploymentSpecTemplateSpecVolumesStorageos | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'readOnly': obj.readOnly,
    'secretRef': toJson_RunnerDeploymentSpecTemplateSpecVolumesStorageosSecretRef(obj.secretRef),
    'volumeName': obj.volumeName,
    'volumeNamespace': obj.volumeNamespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
 *
 * @schema RunnerDeploymentSpecTemplateSpecVolumesVsphereVolume
 */
export interface RunnerDeploymentSpecTemplateSpecVolumesVsphereVolume {
  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesVsphereVolume#fsType
   */
  readonly fsType?: string;

  /**
   * Storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesVsphereVolume#storagePolicyID
   */
  readonly storagePolicyId?: string;

  /**
   * Storage Policy Based Management (SPBM) profile name.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesVsphereVolume#storagePolicyName
   */
  readonly storagePolicyName?: string;

  /**
   * Path that identifies vSphere volume vmdk
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesVsphereVolume#volumePath
   */
  readonly volumePath: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecVolumesVsphereVolume' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecVolumesVsphereVolume(obj: RunnerDeploymentSpecTemplateSpecVolumesVsphereVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'storagePolicyID': obj.storagePolicyId,
    'storagePolicyName': obj.storagePolicyName,
    'volumePath': obj.volumePath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * An empty preferred scheduling term matches all objects with implicit weight 0 (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
 *
 * @schema RunnerDeploymentSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface RunnerDeploymentSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * A node selector term, associated with the corresponding weight.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference: RunnerDeploymentSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: RunnerDeploymentSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preference': toJson_RunnerDeploymentSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj.preference),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node.
 *
 * @schema RunnerDeploymentSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface RunnerDeploymentSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A list of node selector terms. The terms are ORed.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms: RunnerDeploymentSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: RunnerDeploymentSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeSelectorTerms': obj.nodeSelectorTerms?.map(y => toJson_RunnerDeploymentSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface RunnerDeploymentSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm: RunnerDeploymentSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: RunnerDeploymentSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podAffinityTerm': toJson_RunnerDeploymentSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running
 *
 * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface RunnerDeploymentSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: RunnerDeploymentSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces. This field is beta-level and is only honored when PodAffinityNamespaceSelector feature is enabled.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: RunnerDeploymentSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means "this pod's namespace"
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: RunnerDeploymentSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_RunnerDeploymentSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_RunnerDeploymentSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm: RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podAffinityTerm': toJson_RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running
 *
 * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces. This field is beta-level and is only honored when PodAffinityNamespaceSelector feature is enabled.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means "this pod's namespace"
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema RunnerDeploymentSpecTemplateSpecContainersEnvValueFrom
 */
export interface RunnerDeploymentSpecTemplateSpecContainersEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: RunnerDeploymentSpecTemplateSpecContainersEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersEnvValueFrom#fieldRef
   */
  readonly fieldRef?: RunnerDeploymentSpecTemplateSpecContainersEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: RunnerDeploymentSpecTemplateSpecContainersEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: RunnerDeploymentSpecTemplateSpecContainersEnvValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecContainersEnvValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecContainersEnvValueFrom(obj: RunnerDeploymentSpecTemplateSpecContainersEnvValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_RunnerDeploymentSpecTemplateSpecContainersEnvValueFromConfigMapKeyRef(obj.configMapKeyRef),
    'fieldRef': toJson_RunnerDeploymentSpecTemplateSpecContainersEnvValueFromFieldRef(obj.fieldRef),
    'resourceFieldRef': toJson_RunnerDeploymentSpecTemplateSpecContainersEnvValueFromResourceFieldRef(obj.resourceFieldRef),
    'secretKeyRef': toJson_RunnerDeploymentSpecTemplateSpecContainersEnvValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema RunnerDeploymentSpecTemplateSpecContainersEnvFromConfigMapRef
 */
export interface RunnerDeploymentSpecTemplateSpecContainersEnvFromConfigMapRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersEnvFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersEnvFromConfigMapRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecContainersEnvFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecContainersEnvFromConfigMapRef(obj: RunnerDeploymentSpecTemplateSpecContainersEnvFromConfigMapRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Secret to select from
 *
 * @schema RunnerDeploymentSpecTemplateSpecContainersEnvFromSecretRef
 */
export interface RunnerDeploymentSpecTemplateSpecContainersEnvFromSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersEnvFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersEnvFromSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecContainersEnvFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecContainersEnvFromSecretRef(obj: RunnerDeploymentSpecTemplateSpecContainersEnvFromSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PostStart is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema RunnerDeploymentSpecTemplateSpecContainersLifecyclePostStart
 */
export interface RunnerDeploymentSpecTemplateSpecContainersLifecyclePostStart {
  /**
   * Exec specifies the action to take.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersLifecyclePostStart#exec
   */
  readonly exec?: RunnerDeploymentSpecTemplateSpecContainersLifecyclePostStartExec;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersLifecyclePostStart#httpGet
   */
  readonly httpGet?: RunnerDeploymentSpecTemplateSpecContainersLifecyclePostStartHttpGet;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersLifecyclePostStart#tcpSocket
   */
  readonly tcpSocket?: RunnerDeploymentSpecTemplateSpecContainersLifecyclePostStartTcpSocket;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecContainersLifecyclePostStart' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecContainersLifecyclePostStart(obj: RunnerDeploymentSpecTemplateSpecContainersLifecyclePostStart | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_RunnerDeploymentSpecTemplateSpecContainersLifecyclePostStartExec(obj.exec),
    'httpGet': toJson_RunnerDeploymentSpecTemplateSpecContainersLifecyclePostStartHttpGet(obj.httpGet),
    'tcpSocket': toJson_RunnerDeploymentSpecTemplateSpecContainersLifecyclePostStartTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PreStop is called immediately before a container is terminated due to an API request or management event such as liveness/startup probe failure, preemption, resource contention, etc. The handler is not called if the container crashes or exits. The Pod's termination grace period countdown begins before the PreStop hook is executed. Regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period (unless delayed by finalizers). Other management of the container blocks until the hook completes or until the termination grace period is reached. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema RunnerDeploymentSpecTemplateSpecContainersLifecyclePreStop
 */
export interface RunnerDeploymentSpecTemplateSpecContainersLifecyclePreStop {
  /**
   * Exec specifies the action to take.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersLifecyclePreStop#exec
   */
  readonly exec?: RunnerDeploymentSpecTemplateSpecContainersLifecyclePreStopExec;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersLifecyclePreStop#httpGet
   */
  readonly httpGet?: RunnerDeploymentSpecTemplateSpecContainersLifecyclePreStopHttpGet;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersLifecyclePreStop#tcpSocket
   */
  readonly tcpSocket?: RunnerDeploymentSpecTemplateSpecContainersLifecyclePreStopTcpSocket;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecContainersLifecyclePreStop' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecContainersLifecyclePreStop(obj: RunnerDeploymentSpecTemplateSpecContainersLifecyclePreStop | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_RunnerDeploymentSpecTemplateSpecContainersLifecyclePreStopExec(obj.exec),
    'httpGet': toJson_RunnerDeploymentSpecTemplateSpecContainersLifecyclePreStopHttpGet(obj.httpGet),
    'tcpSocket': toJson_RunnerDeploymentSpecTemplateSpecContainersLifecyclePreStopTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema RunnerDeploymentSpecTemplateSpecContainersLivenessProbeExec
 */
export interface RunnerDeploymentSpecTemplateSpecContainersLivenessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersLivenessProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecContainersLivenessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecContainersLivenessProbeExec(obj: RunnerDeploymentSpecTemplateSpecContainersLivenessProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
 *
 * @schema RunnerDeploymentSpecTemplateSpecContainersLivenessProbeGrpc
 */
export interface RunnerDeploymentSpecTemplateSpecContainersLivenessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersLivenessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersLivenessProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecContainersLivenessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecContainersLivenessProbeGrpc(obj: RunnerDeploymentSpecTemplateSpecContainersLivenessProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema RunnerDeploymentSpecTemplateSpecContainersLivenessProbeHttpGet
 */
export interface RunnerDeploymentSpecTemplateSpecContainersLivenessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersLivenessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersLivenessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: RunnerDeploymentSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersLivenessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersLivenessProbeHttpGet#port
   */
  readonly port: RunnerDeploymentSpecTemplateSpecContainersLivenessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RunnerDeploymentSpecTemplateSpecContainersLivenessProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecContainersLivenessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecContainersLivenessProbeHttpGet(obj: RunnerDeploymentSpecTemplateSpecContainersLivenessProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_RunnerDeploymentSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema RunnerDeploymentSpecTemplateSpecContainersLivenessProbeTcpSocket
 */
export interface RunnerDeploymentSpecTemplateSpecContainersLivenessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersLivenessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersLivenessProbeTcpSocket#port
   */
  readonly port: RunnerDeploymentSpecTemplateSpecContainersLivenessProbeTcpSocketPort;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecContainersLivenessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecContainersLivenessProbeTcpSocket(obj: RunnerDeploymentSpecTemplateSpecContainersLivenessProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema RunnerDeploymentSpecTemplateSpecContainersReadinessProbeExec
 */
export interface RunnerDeploymentSpecTemplateSpecContainersReadinessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersReadinessProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecContainersReadinessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecContainersReadinessProbeExec(obj: RunnerDeploymentSpecTemplateSpecContainersReadinessProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
 *
 * @schema RunnerDeploymentSpecTemplateSpecContainersReadinessProbeGrpc
 */
export interface RunnerDeploymentSpecTemplateSpecContainersReadinessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersReadinessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersReadinessProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecContainersReadinessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecContainersReadinessProbeGrpc(obj: RunnerDeploymentSpecTemplateSpecContainersReadinessProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema RunnerDeploymentSpecTemplateSpecContainersReadinessProbeHttpGet
 */
export interface RunnerDeploymentSpecTemplateSpecContainersReadinessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersReadinessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersReadinessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: RunnerDeploymentSpecTemplateSpecContainersReadinessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersReadinessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersReadinessProbeHttpGet#port
   */
  readonly port: RunnerDeploymentSpecTemplateSpecContainersReadinessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RunnerDeploymentSpecTemplateSpecContainersReadinessProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecContainersReadinessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecContainersReadinessProbeHttpGet(obj: RunnerDeploymentSpecTemplateSpecContainersReadinessProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_RunnerDeploymentSpecTemplateSpecContainersReadinessProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema RunnerDeploymentSpecTemplateSpecContainersReadinessProbeTcpSocket
 */
export interface RunnerDeploymentSpecTemplateSpecContainersReadinessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersReadinessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersReadinessProbeTcpSocket#port
   */
  readonly port: RunnerDeploymentSpecTemplateSpecContainersReadinessProbeTcpSocketPort;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecContainersReadinessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecContainersReadinessProbeTcpSocket(obj: RunnerDeploymentSpecTemplateSpecContainersReadinessProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RunnerDeploymentSpecTemplateSpecContainersResourcesLimits
 */
export class RunnerDeploymentSpecTemplateSpecContainersResourcesLimits {
  public static fromNumber(value: number): RunnerDeploymentSpecTemplateSpecContainersResourcesLimits {
    return new RunnerDeploymentSpecTemplateSpecContainersResourcesLimits(value);
  }
  public static fromString(value: string): RunnerDeploymentSpecTemplateSpecContainersResourcesLimits {
    return new RunnerDeploymentSpecTemplateSpecContainersResourcesLimits(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * @schema RunnerDeploymentSpecTemplateSpecContainersResourcesRequests
 */
export class RunnerDeploymentSpecTemplateSpecContainersResourcesRequests {
  public static fromNumber(value: number): RunnerDeploymentSpecTemplateSpecContainersResourcesRequests {
    return new RunnerDeploymentSpecTemplateSpecContainersResourcesRequests(value);
  }
  public static fromString(value: string): RunnerDeploymentSpecTemplateSpecContainersResourcesRequests {
    return new RunnerDeploymentSpecTemplateSpecContainersResourcesRequests(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
 *
 * @default the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
 * @schema RunnerDeploymentSpecTemplateSpecContainersSecurityContextCapabilities
 */
export interface RunnerDeploymentSpecTemplateSpecContainersSecurityContextCapabilities {
  /**
   * Added capabilities
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * Removed capabilities
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecContainersSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecContainersSecurityContextCapabilities(obj: RunnerDeploymentSpecTemplateSpecContainersSecurityContextCapabilities | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': obj.add?.map(y => y),
    'drop': obj.drop?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema RunnerDeploymentSpecTemplateSpecContainersSecurityContextSeLinuxOptions
 */
export interface RunnerDeploymentSpecTemplateSpecContainersSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecContainersSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecContainersSecurityContextSeLinuxOptions(obj: RunnerDeploymentSpecTemplateSpecContainersSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The seccomp options to use by this container. If seccomp options are provided at both the pod & container level, the container options override the pod options. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema RunnerDeploymentSpecTemplateSpecContainersSecurityContextSeccompProfile
 */
export interface RunnerDeploymentSpecTemplateSpecContainersSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Must be a descending path, relative to the kubelet's configured seccomp profile location. Must only be set if type is "Localhost".
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied. Valid options are:
   * Localhost - a profile defined in a file on the node should be used. RuntimeDefault - the container runtime default profile should be used. Unconfined - no profile should be applied.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersSecurityContextSeccompProfile#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecContainersSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecContainersSecurityContextSeccompProfile(obj: RunnerDeploymentSpecTemplateSpecContainersSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Windows specific settings applied to all containers. If unspecified, the options from the PodSecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema RunnerDeploymentSpecTemplateSpecContainersSecurityContextWindowsOptions
 */
export interface RunnerDeploymentSpecTemplateSpecContainersSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container. This field is alpha-level and will only be honored by components that enable the WindowsHostProcessContainers feature flag. Setting this field without the feature flag will result in errors when validating the Pod. All of a Pod's containers must have the same effective HostProcess value (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).  In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process. Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * @schema RunnerDeploymentSpecTemplateSpecContainersSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecContainersSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecContainersSecurityContextWindowsOptions(obj: RunnerDeploymentSpecTemplateSpecContainersSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema RunnerDeploymentSpecTemplateSpecContainersStartupProbeExec
 */
export interface RunnerDeploymentSpecTemplateSpecContainersStartupProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersStartupProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecContainersStartupProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecContainersStartupProbeExec(obj: RunnerDeploymentSpecTemplateSpecContainersStartupProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
 *
 * @schema RunnerDeploymentSpecTemplateSpecContainersStartupProbeGrpc
 */
export interface RunnerDeploymentSpecTemplateSpecContainersStartupProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersStartupProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersStartupProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecContainersStartupProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecContainersStartupProbeGrpc(obj: RunnerDeploymentSpecTemplateSpecContainersStartupProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema RunnerDeploymentSpecTemplateSpecContainersStartupProbeHttpGet
 */
export interface RunnerDeploymentSpecTemplateSpecContainersStartupProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersStartupProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersStartupProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: RunnerDeploymentSpecTemplateSpecContainersStartupProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersStartupProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersStartupProbeHttpGet#port
   */
  readonly port: RunnerDeploymentSpecTemplateSpecContainersStartupProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RunnerDeploymentSpecTemplateSpecContainersStartupProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecContainersStartupProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecContainersStartupProbeHttpGet(obj: RunnerDeploymentSpecTemplateSpecContainersStartupProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_RunnerDeploymentSpecTemplateSpecContainersStartupProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema RunnerDeploymentSpecTemplateSpecContainersStartupProbeTcpSocket
 */
export interface RunnerDeploymentSpecTemplateSpecContainersStartupProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersStartupProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersStartupProbeTcpSocket#port
   */
  readonly port: RunnerDeploymentSpecTemplateSpecContainersStartupProbeTcpSocketPort;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecContainersStartupProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecContainersStartupProbeTcpSocket(obj: RunnerDeploymentSpecTemplateSpecContainersStartupProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a ConfigMap.
 *
 * @schema RunnerDeploymentSpecTemplateSpecDockerEnvValueFromConfigMapKeyRef
 */
export interface RunnerDeploymentSpecTemplateSpecDockerEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema RunnerDeploymentSpecTemplateSpecDockerEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerDeploymentSpecTemplateSpecDockerEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema RunnerDeploymentSpecTemplateSpecDockerEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecDockerEnvValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecDockerEnvValueFromConfigMapKeyRef(obj: RunnerDeploymentSpecTemplateSpecDockerEnvValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema RunnerDeploymentSpecTemplateSpecDockerEnvValueFromFieldRef
 */
export interface RunnerDeploymentSpecTemplateSpecDockerEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema RunnerDeploymentSpecTemplateSpecDockerEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema RunnerDeploymentSpecTemplateSpecDockerEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecDockerEnvValueFromFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecDockerEnvValueFromFieldRef(obj: RunnerDeploymentSpecTemplateSpecDockerEnvValueFromFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema RunnerDeploymentSpecTemplateSpecDockerEnvValueFromResourceFieldRef
 */
export interface RunnerDeploymentSpecTemplateSpecDockerEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema RunnerDeploymentSpecTemplateSpecDockerEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema RunnerDeploymentSpecTemplateSpecDockerEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: RunnerDeploymentSpecTemplateSpecDockerEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema RunnerDeploymentSpecTemplateSpecDockerEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecDockerEnvValueFromResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecDockerEnvValueFromResourceFieldRef(obj: RunnerDeploymentSpecTemplateSpecDockerEnvValueFromResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema RunnerDeploymentSpecTemplateSpecDockerEnvValueFromSecretKeyRef
 */
export interface RunnerDeploymentSpecTemplateSpecDockerEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema RunnerDeploymentSpecTemplateSpecDockerEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerDeploymentSpecTemplateSpecDockerEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema RunnerDeploymentSpecTemplateSpecDockerEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecDockerEnvValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecDockerEnvValueFromSecretKeyRef(obj: RunnerDeploymentSpecTemplateSpecDockerEnvValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a ConfigMap.
 *
 * @schema RunnerDeploymentSpecTemplateSpecEnvValueFromConfigMapKeyRef
 */
export interface RunnerDeploymentSpecTemplateSpecEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerDeploymentSpecTemplateSpecEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema RunnerDeploymentSpecTemplateSpecEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecEnvValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecEnvValueFromConfigMapKeyRef(obj: RunnerDeploymentSpecTemplateSpecEnvValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema RunnerDeploymentSpecTemplateSpecEnvValueFromFieldRef
 */
export interface RunnerDeploymentSpecTemplateSpecEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema RunnerDeploymentSpecTemplateSpecEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecEnvValueFromFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecEnvValueFromFieldRef(obj: RunnerDeploymentSpecTemplateSpecEnvValueFromFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema RunnerDeploymentSpecTemplateSpecEnvValueFromResourceFieldRef
 */
export interface RunnerDeploymentSpecTemplateSpecEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema RunnerDeploymentSpecTemplateSpecEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema RunnerDeploymentSpecTemplateSpecEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: RunnerDeploymentSpecTemplateSpecEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema RunnerDeploymentSpecTemplateSpecEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecEnvValueFromResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecEnvValueFromResourceFieldRef(obj: RunnerDeploymentSpecTemplateSpecEnvValueFromResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema RunnerDeploymentSpecTemplateSpecEnvValueFromSecretKeyRef
 */
export interface RunnerDeploymentSpecTemplateSpecEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerDeploymentSpecTemplateSpecEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema RunnerDeploymentSpecTemplateSpecEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecEnvValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecEnvValueFromSecretKeyRef(obj: RunnerDeploymentSpecTemplateSpecEnvValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvValueFrom
 */
export interface RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvValueFrom#fieldRef
   */
  readonly fieldRef?: RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvValueFrom(obj: RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvValueFromConfigMapKeyRef(obj.configMapKeyRef),
    'fieldRef': toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvValueFromFieldRef(obj.fieldRef),
    'resourceFieldRef': toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRef(obj.resourceFieldRef),
    'secretKeyRef': toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvFromConfigMapRef
 */
export interface RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvFromConfigMapRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvFromConfigMapRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvFromConfigMapRef(obj: RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvFromConfigMapRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Secret to select from
 *
 * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvFromSecretRef
 */
export interface RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvFromSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvFromSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvFromSecretRef(obj: RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvFromSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PostStart is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStart
 */
export interface RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStart {
  /**
   * Exec specifies the action to take.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStart#exec
   */
  readonly exec?: RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStartExec;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStart#httpGet
   */
  readonly httpGet?: RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGet;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStart#tcpSocket
   */
  readonly tcpSocket?: RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocket;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStart' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStart(obj: RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStart | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStartExec(obj.exec),
    'httpGet': toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGet(obj.httpGet),
    'tcpSocket': toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PreStop is called immediately before a container is terminated due to an API request or management event such as liveness/startup probe failure, preemption, resource contention, etc. The handler is not called if the container crashes or exits. The Pod's termination grace period countdown begins before the PreStop hook is executed. Regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period (unless delayed by finalizers). Other management of the container blocks until the hook completes or until the termination grace period is reached. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStop
 */
export interface RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStop {
  /**
   * Exec specifies the action to take.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStop#exec
   */
  readonly exec?: RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStopExec;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStop#httpGet
   */
  readonly httpGet?: RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGet;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStop#tcpSocket
   */
  readonly tcpSocket?: RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocket;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStop' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStop(obj: RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStop | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStopExec(obj.exec),
    'httpGet': toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGet(obj.httpGet),
    'tcpSocket': toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeExec
 */
export interface RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeExec(obj: RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
 *
 * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeGrpc
 */
export interface RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeGrpc(obj: RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeHttpGet
 */
export interface RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeHttpGet#port
   */
  readonly port: RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeHttpGet(obj: RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocket
 */
export interface RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocket#port
   */
  readonly port: RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocketPort;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocket(obj: RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeExec
 */
export interface RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeExec(obj: RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
 *
 * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeGrpc
 */
export interface RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeGrpc(obj: RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeHttpGet
 */
export interface RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeHttpGet#port
   */
  readonly port: RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeHttpGet(obj: RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocket
 */
export interface RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocket#port
   */
  readonly port: RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocketPort;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocket(obj: RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersResourcesLimits
 */
export class RunnerDeploymentSpecTemplateSpecEphemeralContainersResourcesLimits {
  public static fromNumber(value: number): RunnerDeploymentSpecTemplateSpecEphemeralContainersResourcesLimits {
    return new RunnerDeploymentSpecTemplateSpecEphemeralContainersResourcesLimits(value);
  }
  public static fromString(value: string): RunnerDeploymentSpecTemplateSpecEphemeralContainersResourcesLimits {
    return new RunnerDeploymentSpecTemplateSpecEphemeralContainersResourcesLimits(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersResourcesRequests
 */
export class RunnerDeploymentSpecTemplateSpecEphemeralContainersResourcesRequests {
  public static fromNumber(value: number): RunnerDeploymentSpecTemplateSpecEphemeralContainersResourcesRequests {
    return new RunnerDeploymentSpecTemplateSpecEphemeralContainersResourcesRequests(value);
  }
  public static fromString(value: string): RunnerDeploymentSpecTemplateSpecEphemeralContainersResourcesRequests {
    return new RunnerDeploymentSpecTemplateSpecEphemeralContainersResourcesRequests(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
 *
 * @default the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
 * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersSecurityContextCapabilities
 */
export interface RunnerDeploymentSpecTemplateSpecEphemeralContainersSecurityContextCapabilities {
  /**
   * Added capabilities
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * Removed capabilities
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecEphemeralContainersSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersSecurityContextCapabilities(obj: RunnerDeploymentSpecTemplateSpecEphemeralContainersSecurityContextCapabilities | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': obj.add?.map(y => y),
    'drop': obj.drop?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions
 */
export interface RunnerDeploymentSpecTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions(obj: RunnerDeploymentSpecTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The seccomp options to use by this container. If seccomp options are provided at both the pod & container level, the container options override the pod options. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersSecurityContextSeccompProfile
 */
export interface RunnerDeploymentSpecTemplateSpecEphemeralContainersSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Must be a descending path, relative to the kubelet's configured seccomp profile location. Must only be set if type is "Localhost".
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied. Valid options are:
   * Localhost - a profile defined in a file on the node should be used. RuntimeDefault - the container runtime default profile should be used. Unconfined - no profile should be applied.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersSecurityContextSeccompProfile#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecEphemeralContainersSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersSecurityContextSeccompProfile(obj: RunnerDeploymentSpecTemplateSpecEphemeralContainersSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Windows specific settings applied to all containers. If unspecified, the options from the PodSecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersSecurityContextWindowsOptions
 */
export interface RunnerDeploymentSpecTemplateSpecEphemeralContainersSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container. This field is alpha-level and will only be honored by components that enable the WindowsHostProcessContainers feature flag. Setting this field without the feature flag will result in errors when validating the Pod. All of a Pod's containers must have the same effective HostProcess value (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).  In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process. Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecEphemeralContainersSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersSecurityContextWindowsOptions(obj: RunnerDeploymentSpecTemplateSpecEphemeralContainersSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeExec
 */
export interface RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeExec(obj: RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
 *
 * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeGrpc
 */
export interface RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeGrpc(obj: RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeHttpGet
 */
export interface RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeHttpGet#port
   */
  readonly port: RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeHttpGet(obj: RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeTcpSocket
 */
export interface RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeTcpSocket#port
   */
  readonly port: RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeTcpSocketPort;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeTcpSocket(obj: RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema RunnerDeploymentSpecTemplateSpecInitContainersEnvValueFrom
 */
export interface RunnerDeploymentSpecTemplateSpecInitContainersEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: RunnerDeploymentSpecTemplateSpecInitContainersEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersEnvValueFrom#fieldRef
   */
  readonly fieldRef?: RunnerDeploymentSpecTemplateSpecInitContainersEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: RunnerDeploymentSpecTemplateSpecInitContainersEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: RunnerDeploymentSpecTemplateSpecInitContainersEnvValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecInitContainersEnvValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecInitContainersEnvValueFrom(obj: RunnerDeploymentSpecTemplateSpecInitContainersEnvValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_RunnerDeploymentSpecTemplateSpecInitContainersEnvValueFromConfigMapKeyRef(obj.configMapKeyRef),
    'fieldRef': toJson_RunnerDeploymentSpecTemplateSpecInitContainersEnvValueFromFieldRef(obj.fieldRef),
    'resourceFieldRef': toJson_RunnerDeploymentSpecTemplateSpecInitContainersEnvValueFromResourceFieldRef(obj.resourceFieldRef),
    'secretKeyRef': toJson_RunnerDeploymentSpecTemplateSpecInitContainersEnvValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema RunnerDeploymentSpecTemplateSpecInitContainersEnvFromConfigMapRef
 */
export interface RunnerDeploymentSpecTemplateSpecInitContainersEnvFromConfigMapRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersEnvFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersEnvFromConfigMapRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecInitContainersEnvFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecInitContainersEnvFromConfigMapRef(obj: RunnerDeploymentSpecTemplateSpecInitContainersEnvFromConfigMapRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Secret to select from
 *
 * @schema RunnerDeploymentSpecTemplateSpecInitContainersEnvFromSecretRef
 */
export interface RunnerDeploymentSpecTemplateSpecInitContainersEnvFromSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersEnvFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersEnvFromSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecInitContainersEnvFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecInitContainersEnvFromSecretRef(obj: RunnerDeploymentSpecTemplateSpecInitContainersEnvFromSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PostStart is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePostStart
 */
export interface RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePostStart {
  /**
   * Exec specifies the action to take.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePostStart#exec
   */
  readonly exec?: RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePostStartExec;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePostStart#httpGet
   */
  readonly httpGet?: RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePostStartHttpGet;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePostStart#tcpSocket
   */
  readonly tcpSocket?: RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePostStartTcpSocket;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePostStart' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePostStart(obj: RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePostStart | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePostStartExec(obj.exec),
    'httpGet': toJson_RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePostStartHttpGet(obj.httpGet),
    'tcpSocket': toJson_RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePostStartTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PreStop is called immediately before a container is terminated due to an API request or management event such as liveness/startup probe failure, preemption, resource contention, etc. The handler is not called if the container crashes or exits. The Pod's termination grace period countdown begins before the PreStop hook is executed. Regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period (unless delayed by finalizers). Other management of the container blocks until the hook completes or until the termination grace period is reached. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePreStop
 */
export interface RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePreStop {
  /**
   * Exec specifies the action to take.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePreStop#exec
   */
  readonly exec?: RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePreStopExec;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePreStop#httpGet
   */
  readonly httpGet?: RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePreStopHttpGet;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePreStop#tcpSocket
   */
  readonly tcpSocket?: RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePreStopTcpSocket;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePreStop' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePreStop(obj: RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePreStop | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePreStopExec(obj.exec),
    'httpGet': toJson_RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePreStopHttpGet(obj.httpGet),
    'tcpSocket': toJson_RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePreStopTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbeExec
 */
export interface RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbeExec(obj: RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
 *
 * @schema RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbeGrpc
 */
export interface RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbeGrpc(obj: RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbeHttpGet
 */
export interface RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbeHttpGet#port
   */
  readonly port: RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbeHttpGet(obj: RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbeTcpSocket
 */
export interface RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbeTcpSocket#port
   */
  readonly port: RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbeTcpSocketPort;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbeTcpSocket(obj: RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbeExec
 */
export interface RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbeExec(obj: RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
 *
 * @schema RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbeGrpc
 */
export interface RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbeGrpc(obj: RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbeHttpGet
 */
export interface RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbeHttpGet#port
   */
  readonly port: RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbeHttpGet(obj: RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbeTcpSocket
 */
export interface RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbeTcpSocket#port
   */
  readonly port: RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbeTcpSocketPort;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbeTcpSocket(obj: RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RunnerDeploymentSpecTemplateSpecInitContainersResourcesLimits
 */
export class RunnerDeploymentSpecTemplateSpecInitContainersResourcesLimits {
  public static fromNumber(value: number): RunnerDeploymentSpecTemplateSpecInitContainersResourcesLimits {
    return new RunnerDeploymentSpecTemplateSpecInitContainersResourcesLimits(value);
  }
  public static fromString(value: string): RunnerDeploymentSpecTemplateSpecInitContainersResourcesLimits {
    return new RunnerDeploymentSpecTemplateSpecInitContainersResourcesLimits(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * @schema RunnerDeploymentSpecTemplateSpecInitContainersResourcesRequests
 */
export class RunnerDeploymentSpecTemplateSpecInitContainersResourcesRequests {
  public static fromNumber(value: number): RunnerDeploymentSpecTemplateSpecInitContainersResourcesRequests {
    return new RunnerDeploymentSpecTemplateSpecInitContainersResourcesRequests(value);
  }
  public static fromString(value: string): RunnerDeploymentSpecTemplateSpecInitContainersResourcesRequests {
    return new RunnerDeploymentSpecTemplateSpecInitContainersResourcesRequests(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
 *
 * @default the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
 * @schema RunnerDeploymentSpecTemplateSpecInitContainersSecurityContextCapabilities
 */
export interface RunnerDeploymentSpecTemplateSpecInitContainersSecurityContextCapabilities {
  /**
   * Added capabilities
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * Removed capabilities
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecInitContainersSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecInitContainersSecurityContextCapabilities(obj: RunnerDeploymentSpecTemplateSpecInitContainersSecurityContextCapabilities | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': obj.add?.map(y => y),
    'drop': obj.drop?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema RunnerDeploymentSpecTemplateSpecInitContainersSecurityContextSeLinuxOptions
 */
export interface RunnerDeploymentSpecTemplateSpecInitContainersSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecInitContainersSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecInitContainersSecurityContextSeLinuxOptions(obj: RunnerDeploymentSpecTemplateSpecInitContainersSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The seccomp options to use by this container. If seccomp options are provided at both the pod & container level, the container options override the pod options. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema RunnerDeploymentSpecTemplateSpecInitContainersSecurityContextSeccompProfile
 */
export interface RunnerDeploymentSpecTemplateSpecInitContainersSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Must be a descending path, relative to the kubelet's configured seccomp profile location. Must only be set if type is "Localhost".
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied. Valid options are:
   * Localhost - a profile defined in a file on the node should be used. RuntimeDefault - the container runtime default profile should be used. Unconfined - no profile should be applied.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersSecurityContextSeccompProfile#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecInitContainersSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecInitContainersSecurityContextSeccompProfile(obj: RunnerDeploymentSpecTemplateSpecInitContainersSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Windows specific settings applied to all containers. If unspecified, the options from the PodSecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema RunnerDeploymentSpecTemplateSpecInitContainersSecurityContextWindowsOptions
 */
export interface RunnerDeploymentSpecTemplateSpecInitContainersSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container. This field is alpha-level and will only be honored by components that enable the WindowsHostProcessContainers feature flag. Setting this field without the feature flag will result in errors when validating the Pod. All of a Pod's containers must have the same effective HostProcess value (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).  In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process. Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecInitContainersSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecInitContainersSecurityContextWindowsOptions(obj: RunnerDeploymentSpecTemplateSpecInitContainersSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema RunnerDeploymentSpecTemplateSpecInitContainersStartupProbeExec
 */
export interface RunnerDeploymentSpecTemplateSpecInitContainersStartupProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersStartupProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecInitContainersStartupProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecInitContainersStartupProbeExec(obj: RunnerDeploymentSpecTemplateSpecInitContainersStartupProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
 *
 * @schema RunnerDeploymentSpecTemplateSpecInitContainersStartupProbeGrpc
 */
export interface RunnerDeploymentSpecTemplateSpecInitContainersStartupProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersStartupProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersStartupProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecInitContainersStartupProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecInitContainersStartupProbeGrpc(obj: RunnerDeploymentSpecTemplateSpecInitContainersStartupProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema RunnerDeploymentSpecTemplateSpecInitContainersStartupProbeHttpGet
 */
export interface RunnerDeploymentSpecTemplateSpecInitContainersStartupProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersStartupProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersStartupProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: RunnerDeploymentSpecTemplateSpecInitContainersStartupProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersStartupProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersStartupProbeHttpGet#port
   */
  readonly port: RunnerDeploymentSpecTemplateSpecInitContainersStartupProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersStartupProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecInitContainersStartupProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecInitContainersStartupProbeHttpGet(obj: RunnerDeploymentSpecTemplateSpecInitContainersStartupProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_RunnerDeploymentSpecTemplateSpecInitContainersStartupProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema RunnerDeploymentSpecTemplateSpecInitContainersStartupProbeTcpSocket
 */
export interface RunnerDeploymentSpecTemplateSpecInitContainersStartupProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersStartupProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersStartupProbeTcpSocket#port
   */
  readonly port: RunnerDeploymentSpecTemplateSpecInitContainersStartupProbeTcpSocketPort;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecInitContainersStartupProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecInitContainersStartupProbeTcpSocket(obj: RunnerDeploymentSpecTemplateSpecInitContainersStartupProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersEnvValueFrom
 */
export interface RunnerDeploymentSpecTemplateSpecSidecarContainersEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: RunnerDeploymentSpecTemplateSpecSidecarContainersEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersEnvValueFrom#fieldRef
   */
  readonly fieldRef?: RunnerDeploymentSpecTemplateSpecSidecarContainersEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: RunnerDeploymentSpecTemplateSpecSidecarContainersEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: RunnerDeploymentSpecTemplateSpecSidecarContainersEnvValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecSidecarContainersEnvValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersEnvValueFrom(obj: RunnerDeploymentSpecTemplateSpecSidecarContainersEnvValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersEnvValueFromConfigMapKeyRef(obj.configMapKeyRef),
    'fieldRef': toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersEnvValueFromFieldRef(obj.fieldRef),
    'resourceFieldRef': toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersEnvValueFromResourceFieldRef(obj.resourceFieldRef),
    'secretKeyRef': toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersEnvValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersEnvFromConfigMapRef
 */
export interface RunnerDeploymentSpecTemplateSpecSidecarContainersEnvFromConfigMapRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersEnvFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersEnvFromConfigMapRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecSidecarContainersEnvFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersEnvFromConfigMapRef(obj: RunnerDeploymentSpecTemplateSpecSidecarContainersEnvFromConfigMapRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Secret to select from
 *
 * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersEnvFromSecretRef
 */
export interface RunnerDeploymentSpecTemplateSpecSidecarContainersEnvFromSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersEnvFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersEnvFromSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecSidecarContainersEnvFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersEnvFromSecretRef(obj: RunnerDeploymentSpecTemplateSpecSidecarContainersEnvFromSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PostStart is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePostStart
 */
export interface RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePostStart {
  /**
   * Exec specifies the action to take.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePostStart#exec
   */
  readonly exec?: RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePostStartExec;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePostStart#httpGet
   */
  readonly httpGet?: RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePostStartHttpGet;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePostStart#tcpSocket
   */
  readonly tcpSocket?: RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePostStartTcpSocket;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePostStart' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePostStart(obj: RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePostStart | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePostStartExec(obj.exec),
    'httpGet': toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePostStartHttpGet(obj.httpGet),
    'tcpSocket': toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePostStartTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PreStop is called immediately before a container is terminated due to an API request or management event such as liveness/startup probe failure, preemption, resource contention, etc. The handler is not called if the container crashes or exits. The Pod's termination grace period countdown begins before the PreStop hook is executed. Regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period (unless delayed by finalizers). Other management of the container blocks until the hook completes or until the termination grace period is reached. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePreStop
 */
export interface RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePreStop {
  /**
   * Exec specifies the action to take.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePreStop#exec
   */
  readonly exec?: RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePreStopExec;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePreStop#httpGet
   */
  readonly httpGet?: RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePreStopHttpGet;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePreStop#tcpSocket
   */
  readonly tcpSocket?: RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePreStopTcpSocket;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePreStop' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePreStop(obj: RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePreStop | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePreStopExec(obj.exec),
    'httpGet': toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePreStopHttpGet(obj.httpGet),
    'tcpSocket': toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePreStopTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbeExec
 */
export interface RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbeExec(obj: RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
 *
 * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbeGrpc
 */
export interface RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbeGrpc(obj: RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbeHttpGet
 */
export interface RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbeHttpGet#port
   */
  readonly port: RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbeHttpGet(obj: RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbeTcpSocket
 */
export interface RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbeTcpSocket#port
   */
  readonly port: RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbeTcpSocketPort;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbeTcpSocket(obj: RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbeExec
 */
export interface RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbeExec(obj: RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
 *
 * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbeGrpc
 */
export interface RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbeGrpc(obj: RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbeHttpGet
 */
export interface RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbeHttpGet#port
   */
  readonly port: RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbeHttpGet(obj: RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbeTcpSocket
 */
export interface RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbeTcpSocket#port
   */
  readonly port: RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbeTcpSocketPort;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbeTcpSocket(obj: RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersResourcesLimits
 */
export class RunnerDeploymentSpecTemplateSpecSidecarContainersResourcesLimits {
  public static fromNumber(value: number): RunnerDeploymentSpecTemplateSpecSidecarContainersResourcesLimits {
    return new RunnerDeploymentSpecTemplateSpecSidecarContainersResourcesLimits(value);
  }
  public static fromString(value: string): RunnerDeploymentSpecTemplateSpecSidecarContainersResourcesLimits {
    return new RunnerDeploymentSpecTemplateSpecSidecarContainersResourcesLimits(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersResourcesRequests
 */
export class RunnerDeploymentSpecTemplateSpecSidecarContainersResourcesRequests {
  public static fromNumber(value: number): RunnerDeploymentSpecTemplateSpecSidecarContainersResourcesRequests {
    return new RunnerDeploymentSpecTemplateSpecSidecarContainersResourcesRequests(value);
  }
  public static fromString(value: string): RunnerDeploymentSpecTemplateSpecSidecarContainersResourcesRequests {
    return new RunnerDeploymentSpecTemplateSpecSidecarContainersResourcesRequests(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
 *
 * @default the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
 * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersSecurityContextCapabilities
 */
export interface RunnerDeploymentSpecTemplateSpecSidecarContainersSecurityContextCapabilities {
  /**
   * Added capabilities
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * Removed capabilities
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecSidecarContainersSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersSecurityContextCapabilities(obj: RunnerDeploymentSpecTemplateSpecSidecarContainersSecurityContextCapabilities | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': obj.add?.map(y => y),
    'drop': obj.drop?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersSecurityContextSeLinuxOptions
 */
export interface RunnerDeploymentSpecTemplateSpecSidecarContainersSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecSidecarContainersSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersSecurityContextSeLinuxOptions(obj: RunnerDeploymentSpecTemplateSpecSidecarContainersSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The seccomp options to use by this container. If seccomp options are provided at both the pod & container level, the container options override the pod options. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersSecurityContextSeccompProfile
 */
export interface RunnerDeploymentSpecTemplateSpecSidecarContainersSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Must be a descending path, relative to the kubelet's configured seccomp profile location. Must only be set if type is "Localhost".
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied. Valid options are:
   * Localhost - a profile defined in a file on the node should be used. RuntimeDefault - the container runtime default profile should be used. Unconfined - no profile should be applied.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersSecurityContextSeccompProfile#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecSidecarContainersSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersSecurityContextSeccompProfile(obj: RunnerDeploymentSpecTemplateSpecSidecarContainersSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Windows specific settings applied to all containers. If unspecified, the options from the PodSecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersSecurityContextWindowsOptions
 */
export interface RunnerDeploymentSpecTemplateSpecSidecarContainersSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container. This field is alpha-level and will only be honored by components that enable the WindowsHostProcessContainers feature flag. Setting this field without the feature flag will result in errors when validating the Pod. All of a Pod's containers must have the same effective HostProcess value (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).  In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process. Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecSidecarContainersSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersSecurityContextWindowsOptions(obj: RunnerDeploymentSpecTemplateSpecSidecarContainersSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbeExec
 */
export interface RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbeExec(obj: RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
 *
 * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbeGrpc
 */
export interface RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbeGrpc(obj: RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbeHttpGet
 */
export interface RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbeHttpGet#port
   */
  readonly port: RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbeHttpGet(obj: RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbeTcpSocket
 */
export interface RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbeTcpSocket#port
   */
  readonly port: RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbeTcpSocketPort;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbeTcpSocket(obj: RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema RunnerDeploymentSpecTemplateSpecTopologySpreadConstraintLabelSelectorMatchExpressions
 */
export interface RunnerDeploymentSpecTemplateSpecTopologySpreadConstraintLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema RunnerDeploymentSpecTemplateSpecTopologySpreadConstraintLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema RunnerDeploymentSpecTemplateSpecTopologySpreadConstraintLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema RunnerDeploymentSpecTemplateSpecTopologySpreadConstraintLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecTopologySpreadConstraintLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecTopologySpreadConstraintLabelSelectorMatchExpressions(obj: RunnerDeploymentSpecTemplateSpecTopologySpreadConstraintLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Optional: SecretRef is reference to the authentication secret for User, default is empty. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
 *
 * @schema RunnerDeploymentSpecTemplateSpecVolumesCephfsSecretRef
 */
export interface RunnerDeploymentSpecTemplateSpecVolumesCephfsSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesCephfsSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecVolumesCephfsSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecVolumesCephfsSecretRef(obj: RunnerDeploymentSpecTemplateSpecVolumesCephfsSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Optional: points to a secret object containing parameters used to connect to OpenStack.
 *
 * @schema RunnerDeploymentSpecTemplateSpecVolumesCinderSecretRef
 */
export interface RunnerDeploymentSpecTemplateSpecVolumesCinderSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesCinderSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecVolumesCinderSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecVolumesCinderSecretRef(obj: RunnerDeploymentSpecTemplateSpecVolumesCinderSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema RunnerDeploymentSpecTemplateSpecVolumesConfigMapItems
 */
export interface RunnerDeploymentSpecTemplateSpecVolumesConfigMapItems {
  /**
   * The key to project.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesConfigMapItems#key
   */
  readonly key: string;

  /**
   * Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesConfigMapItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecVolumesConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecVolumesConfigMapItems(obj: RunnerDeploymentSpecTemplateSpecVolumesConfigMapItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NodePublishSecretRef is a reference to the secret object containing sensitive information to pass to the CSI driver to complete the CSI NodePublishVolume and NodeUnpublishVolume calls. This field is optional, and  may be empty if no secret is required. If the secret object contains more than one secret, all secret references are passed.
 *
 * @schema RunnerDeploymentSpecTemplateSpecVolumesCsiNodePublishSecretRef
 */
export interface RunnerDeploymentSpecTemplateSpecVolumesCsiNodePublishSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesCsiNodePublishSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecVolumesCsiNodePublishSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecVolumesCsiNodePublishSecretRef(obj: RunnerDeploymentSpecTemplateSpecVolumesCsiNodePublishSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DownwardAPIVolumeFile represents information to create the file containing the pod field
 *
 * @schema RunnerDeploymentSpecTemplateSpecVolumesDownwardApiItems
 */
export interface RunnerDeploymentSpecTemplateSpecVolumesDownwardApiItems {
  /**
   * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesDownwardApiItems#fieldRef
   */
  readonly fieldRef?: RunnerDeploymentSpecTemplateSpecVolumesDownwardApiItemsFieldRef;

  /**
   * Optional: mode bits used to set permissions on this file, must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesDownwardApiItems#mode
   */
  readonly mode?: number;

  /**
   * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesDownwardApiItems#path
   */
  readonly path: string;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesDownwardApiItems#resourceFieldRef
   */
  readonly resourceFieldRef?: RunnerDeploymentSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRef;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecVolumesDownwardApiItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecVolumesDownwardApiItems(obj: RunnerDeploymentSpecTemplateSpecVolumesDownwardApiItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fieldRef': toJson_RunnerDeploymentSpecTemplateSpecVolumesDownwardApiItemsFieldRef(obj.fieldRef),
    'mode': obj.mode,
    'path': obj.path,
    'resourceFieldRef': toJson_RunnerDeploymentSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRef(obj.resourceFieldRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. The default is nil which means that the limit is undefined. More info: http://kubernetes.io/docs/user-guide/volumes#emptydir
 *
 * @schema RunnerDeploymentSpecTemplateSpecVolumesEmptyDirSizeLimit
 */
export class RunnerDeploymentSpecTemplateSpecVolumesEmptyDirSizeLimit {
  public static fromNumber(value: number): RunnerDeploymentSpecTemplateSpecVolumesEmptyDirSizeLimit {
    return new RunnerDeploymentSpecTemplateSpecVolumesEmptyDirSizeLimit(value);
  }
  public static fromString(value: string): RunnerDeploymentSpecTemplateSpecVolumesEmptyDirSizeLimit {
    return new RunnerDeploymentSpecTemplateSpecVolumesEmptyDirSizeLimit(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Will be used to create a stand-alone PVC to provision the volume. The pod in which this EphemeralVolumeSource is embedded will be the owner of the PVC, i.e. the PVC will be deleted together with the pod.  The name of the PVC will be `<pod name>-<volume name>` where `<volume name>` is the name from the `PodSpec.Volumes` array entry. Pod validation will reject the pod if the concatenated name is not valid for a PVC (for example, too long).
 * An existing PVC with that name that is not owned by the pod will *not* be used for the pod to avoid using an unrelated volume by mistake. Starting the pod is then blocked until the unrelated PVC is removed. If such a pre-created PVC is meant to be used by the pod, the PVC has to updated with an owner reference to the pod once the pod exists. Normally this should not be necessary, but it may be useful when manually reconstructing a broken cluster.
 * This field is read-only and no changes will be made by Kubernetes to the PVC after it has been created.
 * Required, must not be nil.
 *
 * @schema RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplate
 */
export interface RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplate {
  /**
   * May contain labels and annotations that will be copied into the PVC when creating it. No other fields are allowed and will be rejected during validation.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplate#metadata
   */
  readonly metadata?: RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateMetadata;

  /**
   * The specification for the PersistentVolumeClaim. The entire content is copied unchanged into the PVC that gets created from this template. The same fields as in a PersistentVolumeClaim are also valid here.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplate#spec
   */
  readonly spec: RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplate(obj: RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateMetadata(obj.metadata),
    'spec': toJson_RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Optional: SecretRef is reference to the secret object containing sensitive information to pass to the plugin scripts. This may be empty if no secret object is specified. If the secret object contains more than one secret, all secrets are passed to the plugin scripts.
 *
 * @schema RunnerDeploymentSpecTemplateSpecVolumesFlexVolumeSecretRef
 */
export interface RunnerDeploymentSpecTemplateSpecVolumesFlexVolumeSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesFlexVolumeSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecVolumesFlexVolumeSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecVolumesFlexVolumeSecretRef(obj: RunnerDeploymentSpecTemplateSpecVolumesFlexVolumeSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CHAP Secret for iSCSI target and initiator authentication
 *
 * @schema RunnerDeploymentSpecTemplateSpecVolumesIscsiSecretRef
 */
export interface RunnerDeploymentSpecTemplateSpecVolumesIscsiSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesIscsiSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecVolumesIscsiSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecVolumesIscsiSecretRef(obj: RunnerDeploymentSpecTemplateSpecVolumesIscsiSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Projection that may be projected along with other supported volume types
 *
 * @schema RunnerDeploymentSpecTemplateSpecVolumesProjectedSources
 */
export interface RunnerDeploymentSpecTemplateSpecVolumesProjectedSources {
  /**
   * information about the configMap data to project
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesProjectedSources#configMap
   */
  readonly configMap?: RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesConfigMap;

  /**
   * information about the downwardAPI data to project
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesProjectedSources#downwardAPI
   */
  readonly downwardApi?: RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesDownwardApi;

  /**
   * information about the secret data to project
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesProjectedSources#secret
   */
  readonly secret?: RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesSecret;

  /**
   * information about the serviceAccountToken data to project
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesProjectedSources#serviceAccountToken
   */
  readonly serviceAccountToken?: RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesServiceAccountToken;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecVolumesProjectedSources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecVolumesProjectedSources(obj: RunnerDeploymentSpecTemplateSpecVolumesProjectedSources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesConfigMap(obj.configMap),
    'downwardAPI': toJson_RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesDownwardApi(obj.downwardApi),
    'secret': toJson_RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesSecret(obj.secret),
    'serviceAccountToken': toJson_RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesServiceAccountToken(obj.serviceAccountToken),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretRef is name of the authentication secret for RBDUser. If provided overrides keyring. Default is nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
 *
 * @default nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
 * @schema RunnerDeploymentSpecTemplateSpecVolumesRbdSecretRef
 */
export interface RunnerDeploymentSpecTemplateSpecVolumesRbdSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesRbdSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecVolumesRbdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecVolumesRbdSecretRef(obj: RunnerDeploymentSpecTemplateSpecVolumesRbdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretRef references to the secret for ScaleIO user and other sensitive information. If this is not provided, Login operation will fail.
 *
 * @schema RunnerDeploymentSpecTemplateSpecVolumesScaleIoSecretRef
 */
export interface RunnerDeploymentSpecTemplateSpecVolumesScaleIoSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesScaleIoSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecVolumesScaleIoSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecVolumesScaleIoSecretRef(obj: RunnerDeploymentSpecTemplateSpecVolumesScaleIoSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema RunnerDeploymentSpecTemplateSpecVolumesSecretItems
 */
export interface RunnerDeploymentSpecTemplateSpecVolumesSecretItems {
  /**
   * The key to project.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesSecretItems#key
   */
  readonly key: string;

  /**
   * Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesSecretItems#mode
   */
  readonly mode?: number;

  /**
   * The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesSecretItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecVolumesSecretItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecVolumesSecretItems(obj: RunnerDeploymentSpecTemplateSpecVolumesSecretItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretRef specifies the secret to use for obtaining the StorageOS API credentials.  If not specified, default values will be attempted.
 *
 * @schema RunnerDeploymentSpecTemplateSpecVolumesStorageosSecretRef
 */
export interface RunnerDeploymentSpecTemplateSpecVolumesStorageosSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesStorageosSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecVolumesStorageosSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecVolumesStorageosSecretRef(obj: RunnerDeploymentSpecTemplateSpecVolumesStorageosSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector term, associated with the corresponding weight.
 *
 * @schema RunnerDeploymentSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface RunnerDeploymentSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: RunnerDeploymentSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: RunnerDeploymentSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj: RunnerDeploymentSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_RunnerDeploymentSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_RunnerDeploymentSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A null or empty node selector term matches no objects. The requirements of them are ANDed. The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
 *
 * @schema RunnerDeploymentSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface RunnerDeploymentSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: RunnerDeploymentSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: RunnerDeploymentSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(obj: RunnerDeploymentSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_RunnerDeploymentSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_RunnerDeploymentSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface RunnerDeploymentSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: RunnerDeploymentSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces. This field is beta-level and is only honored when PodAffinityNamespaceSelector feature is enabled.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: RunnerDeploymentSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means "this pod's namespace"
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: RunnerDeploymentSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_RunnerDeploymentSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_RunnerDeploymentSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 *
 * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface RunnerDeploymentSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: RunnerDeploymentSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: RunnerDeploymentSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_RunnerDeploymentSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces. This field is beta-level and is only honored when PodAffinityNamespaceSelector feature is enabled.
 *
 * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface RunnerDeploymentSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: RunnerDeploymentSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: RunnerDeploymentSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_RunnerDeploymentSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces. This field is beta-level and is only honored when PodAffinityNamespaceSelector feature is enabled.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means "this pod's namespace"
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 *
 * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces. This field is beta-level and is only honored when PodAffinityNamespaceSelector feature is enabled.
 *
 * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a ConfigMap.
 *
 * @schema RunnerDeploymentSpecTemplateSpecContainersEnvValueFromConfigMapKeyRef
 */
export interface RunnerDeploymentSpecTemplateSpecContainersEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecContainersEnvValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecContainersEnvValueFromConfigMapKeyRef(obj: RunnerDeploymentSpecTemplateSpecContainersEnvValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema RunnerDeploymentSpecTemplateSpecContainersEnvValueFromFieldRef
 */
export interface RunnerDeploymentSpecTemplateSpecContainersEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecContainersEnvValueFromFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecContainersEnvValueFromFieldRef(obj: RunnerDeploymentSpecTemplateSpecContainersEnvValueFromFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema RunnerDeploymentSpecTemplateSpecContainersEnvValueFromResourceFieldRef
 */
export interface RunnerDeploymentSpecTemplateSpecContainersEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: RunnerDeploymentSpecTemplateSpecContainersEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecContainersEnvValueFromResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecContainersEnvValueFromResourceFieldRef(obj: RunnerDeploymentSpecTemplateSpecContainersEnvValueFromResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema RunnerDeploymentSpecTemplateSpecContainersEnvValueFromSecretKeyRef
 */
export interface RunnerDeploymentSpecTemplateSpecContainersEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecContainersEnvValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecContainersEnvValueFromSecretKeyRef(obj: RunnerDeploymentSpecTemplateSpecContainersEnvValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema RunnerDeploymentSpecTemplateSpecContainersLifecyclePostStartExec
 */
export interface RunnerDeploymentSpecTemplateSpecContainersLifecyclePostStartExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersLifecyclePostStartExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecContainersLifecyclePostStartExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecContainersLifecyclePostStartExec(obj: RunnerDeploymentSpecTemplateSpecContainersLifecyclePostStartExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema RunnerDeploymentSpecTemplateSpecContainersLifecyclePostStartHttpGet
 */
export interface RunnerDeploymentSpecTemplateSpecContainersLifecyclePostStartHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersLifecyclePostStartHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersLifecyclePostStartHttpGet#httpHeaders
   */
  readonly httpHeaders?: RunnerDeploymentSpecTemplateSpecContainersLifecyclePostStartHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersLifecyclePostStartHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersLifecyclePostStartHttpGet#port
   */
  readonly port: RunnerDeploymentSpecTemplateSpecContainersLifecyclePostStartHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RunnerDeploymentSpecTemplateSpecContainersLifecyclePostStartHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecContainersLifecyclePostStartHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecContainersLifecyclePostStartHttpGet(obj: RunnerDeploymentSpecTemplateSpecContainersLifecyclePostStartHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_RunnerDeploymentSpecTemplateSpecContainersLifecyclePostStartHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
 *
 * @schema RunnerDeploymentSpecTemplateSpecContainersLifecyclePostStartTcpSocket
 */
export interface RunnerDeploymentSpecTemplateSpecContainersLifecyclePostStartTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersLifecyclePostStartTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersLifecyclePostStartTcpSocket#port
   */
  readonly port: RunnerDeploymentSpecTemplateSpecContainersLifecyclePostStartTcpSocketPort;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecContainersLifecyclePostStartTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecContainersLifecyclePostStartTcpSocket(obj: RunnerDeploymentSpecTemplateSpecContainersLifecyclePostStartTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema RunnerDeploymentSpecTemplateSpecContainersLifecyclePreStopExec
 */
export interface RunnerDeploymentSpecTemplateSpecContainersLifecyclePreStopExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersLifecyclePreStopExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecContainersLifecyclePreStopExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecContainersLifecyclePreStopExec(obj: RunnerDeploymentSpecTemplateSpecContainersLifecyclePreStopExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema RunnerDeploymentSpecTemplateSpecContainersLifecyclePreStopHttpGet
 */
export interface RunnerDeploymentSpecTemplateSpecContainersLifecyclePreStopHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersLifecyclePreStopHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersLifecyclePreStopHttpGet#httpHeaders
   */
  readonly httpHeaders?: RunnerDeploymentSpecTemplateSpecContainersLifecyclePreStopHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersLifecyclePreStopHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersLifecyclePreStopHttpGet#port
   */
  readonly port: RunnerDeploymentSpecTemplateSpecContainersLifecyclePreStopHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RunnerDeploymentSpecTemplateSpecContainersLifecyclePreStopHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecContainersLifecyclePreStopHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecContainersLifecyclePreStopHttpGet(obj: RunnerDeploymentSpecTemplateSpecContainersLifecyclePreStopHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_RunnerDeploymentSpecTemplateSpecContainersLifecyclePreStopHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
 *
 * @schema RunnerDeploymentSpecTemplateSpecContainersLifecyclePreStopTcpSocket
 */
export interface RunnerDeploymentSpecTemplateSpecContainersLifecyclePreStopTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersLifecyclePreStopTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersLifecyclePreStopTcpSocket#port
   */
  readonly port: RunnerDeploymentSpecTemplateSpecContainersLifecyclePreStopTcpSocketPort;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecContainersLifecyclePreStopTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecContainersLifecyclePreStopTcpSocket(obj: RunnerDeploymentSpecTemplateSpecContainersLifecyclePreStopTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RunnerDeploymentSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeaders
 */
export interface RunnerDeploymentSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeaders(obj: RunnerDeploymentSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerDeploymentSpecTemplateSpecContainersLivenessProbeHttpGetPort
 */
export class RunnerDeploymentSpecTemplateSpecContainersLivenessProbeHttpGetPort {
  public static fromNumber(value: number): RunnerDeploymentSpecTemplateSpecContainersLivenessProbeHttpGetPort {
    return new RunnerDeploymentSpecTemplateSpecContainersLivenessProbeHttpGetPort(value);
  }
  public static fromString(value: string): RunnerDeploymentSpecTemplateSpecContainersLivenessProbeHttpGetPort {
    return new RunnerDeploymentSpecTemplateSpecContainersLivenessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerDeploymentSpecTemplateSpecContainersLivenessProbeTcpSocketPort
 */
export class RunnerDeploymentSpecTemplateSpecContainersLivenessProbeTcpSocketPort {
  public static fromNumber(value: number): RunnerDeploymentSpecTemplateSpecContainersLivenessProbeTcpSocketPort {
    return new RunnerDeploymentSpecTemplateSpecContainersLivenessProbeTcpSocketPort(value);
  }
  public static fromString(value: string): RunnerDeploymentSpecTemplateSpecContainersLivenessProbeTcpSocketPort {
    return new RunnerDeploymentSpecTemplateSpecContainersLivenessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RunnerDeploymentSpecTemplateSpecContainersReadinessProbeHttpGetHttpHeaders
 */
export interface RunnerDeploymentSpecTemplateSpecContainersReadinessProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersReadinessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersReadinessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecContainersReadinessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecContainersReadinessProbeHttpGetHttpHeaders(obj: RunnerDeploymentSpecTemplateSpecContainersReadinessProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerDeploymentSpecTemplateSpecContainersReadinessProbeHttpGetPort
 */
export class RunnerDeploymentSpecTemplateSpecContainersReadinessProbeHttpGetPort {
  public static fromNumber(value: number): RunnerDeploymentSpecTemplateSpecContainersReadinessProbeHttpGetPort {
    return new RunnerDeploymentSpecTemplateSpecContainersReadinessProbeHttpGetPort(value);
  }
  public static fromString(value: string): RunnerDeploymentSpecTemplateSpecContainersReadinessProbeHttpGetPort {
    return new RunnerDeploymentSpecTemplateSpecContainersReadinessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerDeploymentSpecTemplateSpecContainersReadinessProbeTcpSocketPort
 */
export class RunnerDeploymentSpecTemplateSpecContainersReadinessProbeTcpSocketPort {
  public static fromNumber(value: number): RunnerDeploymentSpecTemplateSpecContainersReadinessProbeTcpSocketPort {
    return new RunnerDeploymentSpecTemplateSpecContainersReadinessProbeTcpSocketPort(value);
  }
  public static fromString(value: string): RunnerDeploymentSpecTemplateSpecContainersReadinessProbeTcpSocketPort {
    return new RunnerDeploymentSpecTemplateSpecContainersReadinessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RunnerDeploymentSpecTemplateSpecContainersStartupProbeHttpGetHttpHeaders
 */
export interface RunnerDeploymentSpecTemplateSpecContainersStartupProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersStartupProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersStartupProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecContainersStartupProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecContainersStartupProbeHttpGetHttpHeaders(obj: RunnerDeploymentSpecTemplateSpecContainersStartupProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerDeploymentSpecTemplateSpecContainersStartupProbeHttpGetPort
 */
export class RunnerDeploymentSpecTemplateSpecContainersStartupProbeHttpGetPort {
  public static fromNumber(value: number): RunnerDeploymentSpecTemplateSpecContainersStartupProbeHttpGetPort {
    return new RunnerDeploymentSpecTemplateSpecContainersStartupProbeHttpGetPort(value);
  }
  public static fromString(value: string): RunnerDeploymentSpecTemplateSpecContainersStartupProbeHttpGetPort {
    return new RunnerDeploymentSpecTemplateSpecContainersStartupProbeHttpGetPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerDeploymentSpecTemplateSpecContainersStartupProbeTcpSocketPort
 */
export class RunnerDeploymentSpecTemplateSpecContainersStartupProbeTcpSocketPort {
  public static fromNumber(value: number): RunnerDeploymentSpecTemplateSpecContainersStartupProbeTcpSocketPort {
    return new RunnerDeploymentSpecTemplateSpecContainersStartupProbeTcpSocketPort(value);
  }
  public static fromString(value: string): RunnerDeploymentSpecTemplateSpecContainersStartupProbeTcpSocketPort {
    return new RunnerDeploymentSpecTemplateSpecContainersStartupProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema RunnerDeploymentSpecTemplateSpecDockerEnvValueFromResourceFieldRefDivisor
 */
export class RunnerDeploymentSpecTemplateSpecDockerEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(value: number): RunnerDeploymentSpecTemplateSpecDockerEnvValueFromResourceFieldRefDivisor {
    return new RunnerDeploymentSpecTemplateSpecDockerEnvValueFromResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): RunnerDeploymentSpecTemplateSpecDockerEnvValueFromResourceFieldRefDivisor {
    return new RunnerDeploymentSpecTemplateSpecDockerEnvValueFromResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema RunnerDeploymentSpecTemplateSpecEnvValueFromResourceFieldRefDivisor
 */
export class RunnerDeploymentSpecTemplateSpecEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(value: number): RunnerDeploymentSpecTemplateSpecEnvValueFromResourceFieldRefDivisor {
    return new RunnerDeploymentSpecTemplateSpecEnvValueFromResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): RunnerDeploymentSpecTemplateSpecEnvValueFromResourceFieldRefDivisor {
    return new RunnerDeploymentSpecTemplateSpecEnvValueFromResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Selects a key of a ConfigMap.
 *
 * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvValueFromConfigMapKeyRef
 */
export interface RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvValueFromConfigMapKeyRef(obj: RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvValueFromFieldRef
 */
export interface RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvValueFromFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvValueFromFieldRef(obj: RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvValueFromFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRef
 */
export interface RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRef(obj: RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvValueFromSecretKeyRef
 */
export interface RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvValueFromSecretKeyRef(obj: RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStartExec
 */
export interface RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStartExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStartExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStartExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStartExec(obj: RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStartExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGet
 */
export interface RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGet#httpHeaders
   */
  readonly httpHeaders?: RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGet#port
   */
  readonly port: RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGet(obj: RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
 *
 * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocket
 */
export interface RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocket#port
   */
  readonly port: RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocketPort;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocket(obj: RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStopExec
 */
export interface RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStopExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStopExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStopExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStopExec(obj: RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStopExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGet
 */
export interface RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGet#httpHeaders
   */
  readonly httpHeaders?: RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGet#port
   */
  readonly port: RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGet(obj: RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
 *
 * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocket
 */
export interface RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocket#port
   */
  readonly port: RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocketPort;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocket(obj: RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders
 */
export interface RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders(obj: RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetPort
 */
export class RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetPort {
  public static fromNumber(value: number): RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetPort {
    return new RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetPort(value);
  }
  public static fromString(value: string): RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetPort {
    return new RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocketPort
 */
export class RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocketPort {
  public static fromNumber(value: number): RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocketPort {
    return new RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocketPort(value);
  }
  public static fromString(value: string): RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocketPort {
    return new RunnerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders
 */
export interface RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders(obj: RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetPort
 */
export class RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetPort {
  public static fromNumber(value: number): RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetPort {
    return new RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetPort(value);
  }
  public static fromString(value: string): RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetPort {
    return new RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocketPort
 */
export class RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocketPort {
  public static fromNumber(value: number): RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocketPort {
    return new RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocketPort(value);
  }
  public static fromString(value: string): RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocketPort {
    return new RunnerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeHttpGetHttpHeaders
 */
export interface RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeHttpGetHttpHeaders(obj: RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeHttpGetPort
 */
export class RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeHttpGetPort {
  public static fromNumber(value: number): RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeHttpGetPort {
    return new RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeHttpGetPort(value);
  }
  public static fromString(value: string): RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeHttpGetPort {
    return new RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeHttpGetPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeTcpSocketPort
 */
export class RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeTcpSocketPort {
  public static fromNumber(value: number): RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeTcpSocketPort {
    return new RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeTcpSocketPort(value);
  }
  public static fromString(value: string): RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeTcpSocketPort {
    return new RunnerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Selects a key of a ConfigMap.
 *
 * @schema RunnerDeploymentSpecTemplateSpecInitContainersEnvValueFromConfigMapKeyRef
 */
export interface RunnerDeploymentSpecTemplateSpecInitContainersEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecInitContainersEnvValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecInitContainersEnvValueFromConfigMapKeyRef(obj: RunnerDeploymentSpecTemplateSpecInitContainersEnvValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema RunnerDeploymentSpecTemplateSpecInitContainersEnvValueFromFieldRef
 */
export interface RunnerDeploymentSpecTemplateSpecInitContainersEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecInitContainersEnvValueFromFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecInitContainersEnvValueFromFieldRef(obj: RunnerDeploymentSpecTemplateSpecInitContainersEnvValueFromFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema RunnerDeploymentSpecTemplateSpecInitContainersEnvValueFromResourceFieldRef
 */
export interface RunnerDeploymentSpecTemplateSpecInitContainersEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: RunnerDeploymentSpecTemplateSpecInitContainersEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecInitContainersEnvValueFromResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecInitContainersEnvValueFromResourceFieldRef(obj: RunnerDeploymentSpecTemplateSpecInitContainersEnvValueFromResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema RunnerDeploymentSpecTemplateSpecInitContainersEnvValueFromSecretKeyRef
 */
export interface RunnerDeploymentSpecTemplateSpecInitContainersEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecInitContainersEnvValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecInitContainersEnvValueFromSecretKeyRef(obj: RunnerDeploymentSpecTemplateSpecInitContainersEnvValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePostStartExec
 */
export interface RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePostStartExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePostStartExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePostStartExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePostStartExec(obj: RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePostStartExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePostStartHttpGet
 */
export interface RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePostStartHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePostStartHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePostStartHttpGet#httpHeaders
   */
  readonly httpHeaders?: RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePostStartHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePostStartHttpGet#port
   */
  readonly port: RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePostStartHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePostStartHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePostStartHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePostStartHttpGet(obj: RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePostStartHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
 *
 * @schema RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePostStartTcpSocket
 */
export interface RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePostStartTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePostStartTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePostStartTcpSocket#port
   */
  readonly port: RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePostStartTcpSocketPort;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePostStartTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePostStartTcpSocket(obj: RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePostStartTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePreStopExec
 */
export interface RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePreStopExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePreStopExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePreStopExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePreStopExec(obj: RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePreStopExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePreStopHttpGet
 */
export interface RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePreStopHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePreStopHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePreStopHttpGet#httpHeaders
   */
  readonly httpHeaders?: RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePreStopHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePreStopHttpGet#port
   */
  readonly port: RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePreStopHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePreStopHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePreStopHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePreStopHttpGet(obj: RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePreStopHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
 *
 * @schema RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePreStopTcpSocket
 */
export interface RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePreStopTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePreStopTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePreStopTcpSocket#port
   */
  readonly port: RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePreStopTcpSocketPort;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePreStopTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePreStopTcpSocket(obj: RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePreStopTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders
 */
export interface RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders(obj: RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbeHttpGetPort
 */
export class RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbeHttpGetPort {
  public static fromNumber(value: number): RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbeHttpGetPort {
    return new RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbeHttpGetPort(value);
  }
  public static fromString(value: string): RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbeHttpGetPort {
    return new RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbeTcpSocketPort
 */
export class RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbeTcpSocketPort {
  public static fromNumber(value: number): RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbeTcpSocketPort {
    return new RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbeTcpSocketPort(value);
  }
  public static fromString(value: string): RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbeTcpSocketPort {
    return new RunnerDeploymentSpecTemplateSpecInitContainersLivenessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders
 */
export interface RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders(obj: RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbeHttpGetPort
 */
export class RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbeHttpGetPort {
  public static fromNumber(value: number): RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbeHttpGetPort {
    return new RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbeHttpGetPort(value);
  }
  public static fromString(value: string): RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbeHttpGetPort {
    return new RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbeTcpSocketPort
 */
export class RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbeTcpSocketPort {
  public static fromNumber(value: number): RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbeTcpSocketPort {
    return new RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbeTcpSocketPort(value);
  }
  public static fromString(value: string): RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbeTcpSocketPort {
    return new RunnerDeploymentSpecTemplateSpecInitContainersReadinessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RunnerDeploymentSpecTemplateSpecInitContainersStartupProbeHttpGetHttpHeaders
 */
export interface RunnerDeploymentSpecTemplateSpecInitContainersStartupProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersStartupProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersStartupProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecInitContainersStartupProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecInitContainersStartupProbeHttpGetHttpHeaders(obj: RunnerDeploymentSpecTemplateSpecInitContainersStartupProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerDeploymentSpecTemplateSpecInitContainersStartupProbeHttpGetPort
 */
export class RunnerDeploymentSpecTemplateSpecInitContainersStartupProbeHttpGetPort {
  public static fromNumber(value: number): RunnerDeploymentSpecTemplateSpecInitContainersStartupProbeHttpGetPort {
    return new RunnerDeploymentSpecTemplateSpecInitContainersStartupProbeHttpGetPort(value);
  }
  public static fromString(value: string): RunnerDeploymentSpecTemplateSpecInitContainersStartupProbeHttpGetPort {
    return new RunnerDeploymentSpecTemplateSpecInitContainersStartupProbeHttpGetPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerDeploymentSpecTemplateSpecInitContainersStartupProbeTcpSocketPort
 */
export class RunnerDeploymentSpecTemplateSpecInitContainersStartupProbeTcpSocketPort {
  public static fromNumber(value: number): RunnerDeploymentSpecTemplateSpecInitContainersStartupProbeTcpSocketPort {
    return new RunnerDeploymentSpecTemplateSpecInitContainersStartupProbeTcpSocketPort(value);
  }
  public static fromString(value: string): RunnerDeploymentSpecTemplateSpecInitContainersStartupProbeTcpSocketPort {
    return new RunnerDeploymentSpecTemplateSpecInitContainersStartupProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Selects a key of a ConfigMap.
 *
 * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersEnvValueFromConfigMapKeyRef
 */
export interface RunnerDeploymentSpecTemplateSpecSidecarContainersEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecSidecarContainersEnvValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersEnvValueFromConfigMapKeyRef(obj: RunnerDeploymentSpecTemplateSpecSidecarContainersEnvValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersEnvValueFromFieldRef
 */
export interface RunnerDeploymentSpecTemplateSpecSidecarContainersEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecSidecarContainersEnvValueFromFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersEnvValueFromFieldRef(obj: RunnerDeploymentSpecTemplateSpecSidecarContainersEnvValueFromFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersEnvValueFromResourceFieldRef
 */
export interface RunnerDeploymentSpecTemplateSpecSidecarContainersEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: RunnerDeploymentSpecTemplateSpecSidecarContainersEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecSidecarContainersEnvValueFromResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersEnvValueFromResourceFieldRef(obj: RunnerDeploymentSpecTemplateSpecSidecarContainersEnvValueFromResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersEnvValueFromSecretKeyRef
 */
export interface RunnerDeploymentSpecTemplateSpecSidecarContainersEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecSidecarContainersEnvValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersEnvValueFromSecretKeyRef(obj: RunnerDeploymentSpecTemplateSpecSidecarContainersEnvValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePostStartExec
 */
export interface RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePostStartExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePostStartExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePostStartExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePostStartExec(obj: RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePostStartExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePostStartHttpGet
 */
export interface RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePostStartHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePostStartHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePostStartHttpGet#httpHeaders
   */
  readonly httpHeaders?: RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePostStartHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePostStartHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePostStartHttpGet#port
   */
  readonly port: RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePostStartHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePostStartHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePostStartHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePostStartHttpGet(obj: RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePostStartHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePostStartHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
 *
 * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePostStartTcpSocket
 */
export interface RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePostStartTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePostStartTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePostStartTcpSocket#port
   */
  readonly port: RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePostStartTcpSocketPort;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePostStartTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePostStartTcpSocket(obj: RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePostStartTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePreStopExec
 */
export interface RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePreStopExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePreStopExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePreStopExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePreStopExec(obj: RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePreStopExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePreStopHttpGet
 */
export interface RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePreStopHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePreStopHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePreStopHttpGet#httpHeaders
   */
  readonly httpHeaders?: RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePreStopHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePreStopHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePreStopHttpGet#port
   */
  readonly port: RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePreStopHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePreStopHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePreStopHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePreStopHttpGet(obj: RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePreStopHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePreStopHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
 *
 * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePreStopTcpSocket
 */
export interface RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePreStopTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePreStopTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePreStopTcpSocket#port
   */
  readonly port: RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePreStopTcpSocketPort;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePreStopTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePreStopTcpSocket(obj: RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePreStopTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbeHttpGetHttpHeaders
 */
export interface RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbeHttpGetHttpHeaders(obj: RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbeHttpGetPort
 */
export class RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbeHttpGetPort {
  public static fromNumber(value: number): RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbeHttpGetPort {
    return new RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbeHttpGetPort(value);
  }
  public static fromString(value: string): RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbeHttpGetPort {
    return new RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbeTcpSocketPort
 */
export class RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbeTcpSocketPort {
  public static fromNumber(value: number): RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbeTcpSocketPort {
    return new RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbeTcpSocketPort(value);
  }
  public static fromString(value: string): RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbeTcpSocketPort {
    return new RunnerDeploymentSpecTemplateSpecSidecarContainersLivenessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbeHttpGetHttpHeaders
 */
export interface RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbeHttpGetHttpHeaders(obj: RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbeHttpGetPort
 */
export class RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbeHttpGetPort {
  public static fromNumber(value: number): RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbeHttpGetPort {
    return new RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbeHttpGetPort(value);
  }
  public static fromString(value: string): RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbeHttpGetPort {
    return new RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbeTcpSocketPort
 */
export class RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbeTcpSocketPort {
  public static fromNumber(value: number): RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbeTcpSocketPort {
    return new RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbeTcpSocketPort(value);
  }
  public static fromString(value: string): RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbeTcpSocketPort {
    return new RunnerDeploymentSpecTemplateSpecSidecarContainersReadinessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbeHttpGetHttpHeaders
 */
export interface RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbeHttpGetHttpHeaders(obj: RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbeHttpGetPort
 */
export class RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbeHttpGetPort {
  public static fromNumber(value: number): RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbeHttpGetPort {
    return new RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbeHttpGetPort(value);
  }
  public static fromString(value: string): RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbeHttpGetPort {
    return new RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbeHttpGetPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbeTcpSocketPort
 */
export class RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbeTcpSocketPort {
  public static fromNumber(value: number): RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbeTcpSocketPort {
    return new RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbeTcpSocketPort(value);
  }
  public static fromString(value: string): RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbeTcpSocketPort {
    return new RunnerDeploymentSpecTemplateSpecSidecarContainersStartupProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
 *
 * @schema RunnerDeploymentSpecTemplateSpecVolumesDownwardApiItemsFieldRef
 */
export interface RunnerDeploymentSpecTemplateSpecVolumesDownwardApiItemsFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesDownwardApiItemsFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesDownwardApiItemsFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecVolumesDownwardApiItemsFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecVolumesDownwardApiItemsFieldRef(obj: RunnerDeploymentSpecTemplateSpecVolumesDownwardApiItemsFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
 *
 * @schema RunnerDeploymentSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRef
 */
export interface RunnerDeploymentSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRef#divisor
   */
  readonly divisor?: RunnerDeploymentSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRef(obj: RunnerDeploymentSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * May contain labels and annotations that will be copied into the PVC when creating it. No other fields are allowed and will be rejected during validation.
 *
 * @schema RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateMetadata
 */
export interface RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateMetadata {
  /**
   * @schema RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * @schema RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateMetadata#finalizers
   */
  readonly finalizers?: string[];

  /**
   * @schema RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * @schema RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateMetadata#name
   */
  readonly name?: string;

  /**
   * @schema RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateMetadata#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateMetadata(obj: RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'finalizers': obj.finalizers?.map(y => y),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The specification for the PersistentVolumeClaim. The entire content is copied unchanged into the PVC that gets created from this template. The same fields as in a PersistentVolumeClaim are also valid here.
 *
 * @schema RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec
 */
export interface RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec {
  /**
   * AccessModes contains the desired access modes the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec#accessModes
   */
  readonly accessModes?: string[];

  /**
   * This field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. If the AnyVolumeDataSource feature gate is enabled, this field will always have the same contents as the DataSourceRef field.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec#dataSource
   */
  readonly dataSource?: RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource;

  /**
   * Specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any local object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the DataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, both fields (DataSource and DataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. There are two important differences between DataSource and DataSourceRef: * While DataSource only allows two specific types of objects, DataSourceRef   allows any non-core object, as well as PersistentVolumeClaim objects. * While DataSource ignores disallowed values (dropping them), DataSourceRef   preserves all values, and generates an error if a disallowed value is   specified. (Alpha) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec#dataSourceRef
   */
  readonly dataSourceRef?: RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef;

  /**
   * Resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec#resources
   */
  readonly resources?: RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResources;

  /**
   * A label query over volumes to consider for binding.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec#selector
   */
  readonly selector?: RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelector;

  /**
   * Name of the StorageClass required by the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim spec.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec#volumeMode
   */
  readonly volumeMode?: string;

  /**
   * VolumeName is the binding reference to the PersistentVolume backing this claim.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec#volumeName
   */
  readonly volumeName?: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec(obj: RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessModes': obj.accessModes?.map(y => y),
    'dataSource': toJson_RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource(obj.dataSource),
    'dataSourceRef': toJson_RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef(obj.dataSourceRef),
    'resources': toJson_RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResources(obj.resources),
    'selector': toJson_RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelector(obj.selector),
    'storageClassName': obj.storageClassName,
    'volumeMode': obj.volumeMode,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * information about the configMap data to project
 *
 * @schema RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesConfigMap
 */
export interface RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesConfigMap {
  /**
   * If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesConfigMap#items
   */
  readonly items?: RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesConfigMapItems[];

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its keys must be defined
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesConfigMap(obj: RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesConfigMapItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * information about the downwardAPI data to project
 *
 * @schema RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesDownwardApi
 */
export interface RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesDownwardApi {
  /**
   * Items is a list of DownwardAPIVolume file
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesDownwardApi#items
   */
  readonly items?: RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesDownwardApiItems[];

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesDownwardApi' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesDownwardApi(obj: RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesDownwardApi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesDownwardApiItems(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * information about the secret data to project
 *
 * @schema RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesSecret
 */
export interface RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesSecret {
  /**
   * If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesSecret#items
   */
  readonly items?: RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesSecretItems[];

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesSecret(obj: RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesSecretItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * information about the serviceAccountToken data to project
 *
 * @schema RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesServiceAccountToken
 */
export interface RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesServiceAccountToken {
  /**
   * Audience is the intended audience of the token. A recipient of a token must identify itself with an identifier specified in the audience of the token, and otherwise should reject the token. The audience defaults to the identifier of the apiserver.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesServiceAccountToken#audience
   */
  readonly audience?: string;

  /**
   * ExpirationSeconds is the requested duration of validity of the service account token. As the token approaches expiration, the kubelet volume plugin will proactively rotate the service account token. The kubelet will start trying to rotate the token if the token is older than 80 percent of its time to live or if the token is older than 24 hours.Defaults to 1 hour and must be at least 10 minutes.
   *
   * @default 1 hour and must be at least 10 minutes.
   * @schema RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesServiceAccountToken#expirationSeconds
   */
  readonly expirationSeconds?: number;

  /**
   * Path is the path relative to the mount point of the file to project the token into.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesServiceAccountToken#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesServiceAccountToken' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesServiceAccountToken(obj: RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesServiceAccountToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audience': obj.audience,
    'expirationSeconds': obj.expirationSeconds,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema RunnerDeploymentSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface RunnerDeploymentSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(obj: RunnerDeploymentSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema RunnerDeploymentSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface RunnerDeploymentSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(obj: RunnerDeploymentSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema RunnerDeploymentSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface RunnerDeploymentSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(obj: RunnerDeploymentSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema RunnerDeploymentSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface RunnerDeploymentSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(obj: RunnerDeploymentSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 *
 * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface RunnerDeploymentSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: RunnerDeploymentSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: RunnerDeploymentSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_RunnerDeploymentSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces. This field is beta-level and is only honored when PodAffinityNamespaceSelector feature is enabled.
 *
 * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface RunnerDeploymentSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: RunnerDeploymentSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: RunnerDeploymentSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_RunnerDeploymentSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface RunnerDeploymentSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: RunnerDeploymentSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface RunnerDeploymentSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: RunnerDeploymentSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 *
 * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces. This field is beta-level and is only honored when PodAffinityNamespaceSelector feature is enabled.
 *
 * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema RunnerDeploymentSpecTemplateSpecContainersEnvValueFromResourceFieldRefDivisor
 */
export class RunnerDeploymentSpecTemplateSpecContainersEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(value: number): RunnerDeploymentSpecTemplateSpecContainersEnvValueFromResourceFieldRefDivisor {
    return new RunnerDeploymentSpecTemplateSpecContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): RunnerDeploymentSpecTemplateSpecContainersEnvValueFromResourceFieldRefDivisor {
    return new RunnerDeploymentSpecTemplateSpecContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RunnerDeploymentSpecTemplateSpecContainersLifecyclePostStartHttpGetHttpHeaders
 */
export interface RunnerDeploymentSpecTemplateSpecContainersLifecyclePostStartHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersLifecyclePostStartHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersLifecyclePostStartHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecContainersLifecyclePostStartHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecContainersLifecyclePostStartHttpGetHttpHeaders(obj: RunnerDeploymentSpecTemplateSpecContainersLifecyclePostStartHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerDeploymentSpecTemplateSpecContainersLifecyclePostStartHttpGetPort
 */
export class RunnerDeploymentSpecTemplateSpecContainersLifecyclePostStartHttpGetPort {
  public static fromNumber(value: number): RunnerDeploymentSpecTemplateSpecContainersLifecyclePostStartHttpGetPort {
    return new RunnerDeploymentSpecTemplateSpecContainersLifecyclePostStartHttpGetPort(value);
  }
  public static fromString(value: string): RunnerDeploymentSpecTemplateSpecContainersLifecyclePostStartHttpGetPort {
    return new RunnerDeploymentSpecTemplateSpecContainersLifecyclePostStartHttpGetPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerDeploymentSpecTemplateSpecContainersLifecyclePostStartTcpSocketPort
 */
export class RunnerDeploymentSpecTemplateSpecContainersLifecyclePostStartTcpSocketPort {
  public static fromNumber(value: number): RunnerDeploymentSpecTemplateSpecContainersLifecyclePostStartTcpSocketPort {
    return new RunnerDeploymentSpecTemplateSpecContainersLifecyclePostStartTcpSocketPort(value);
  }
  public static fromString(value: string): RunnerDeploymentSpecTemplateSpecContainersLifecyclePostStartTcpSocketPort {
    return new RunnerDeploymentSpecTemplateSpecContainersLifecyclePostStartTcpSocketPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RunnerDeploymentSpecTemplateSpecContainersLifecyclePreStopHttpGetHttpHeaders
 */
export interface RunnerDeploymentSpecTemplateSpecContainersLifecyclePreStopHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersLifecyclePreStopHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RunnerDeploymentSpecTemplateSpecContainersLifecyclePreStopHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecContainersLifecyclePreStopHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecContainersLifecyclePreStopHttpGetHttpHeaders(obj: RunnerDeploymentSpecTemplateSpecContainersLifecyclePreStopHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerDeploymentSpecTemplateSpecContainersLifecyclePreStopHttpGetPort
 */
export class RunnerDeploymentSpecTemplateSpecContainersLifecyclePreStopHttpGetPort {
  public static fromNumber(value: number): RunnerDeploymentSpecTemplateSpecContainersLifecyclePreStopHttpGetPort {
    return new RunnerDeploymentSpecTemplateSpecContainersLifecyclePreStopHttpGetPort(value);
  }
  public static fromString(value: string): RunnerDeploymentSpecTemplateSpecContainersLifecyclePreStopHttpGetPort {
    return new RunnerDeploymentSpecTemplateSpecContainersLifecyclePreStopHttpGetPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerDeploymentSpecTemplateSpecContainersLifecyclePreStopTcpSocketPort
 */
export class RunnerDeploymentSpecTemplateSpecContainersLifecyclePreStopTcpSocketPort {
  public static fromNumber(value: number): RunnerDeploymentSpecTemplateSpecContainersLifecyclePreStopTcpSocketPort {
    return new RunnerDeploymentSpecTemplateSpecContainersLifecyclePreStopTcpSocketPort(value);
  }
  public static fromString(value: string): RunnerDeploymentSpecTemplateSpecContainersLifecyclePreStopTcpSocketPort {
    return new RunnerDeploymentSpecTemplateSpecContainersLifecyclePreStopTcpSocketPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRefDivisor
 */
export class RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(value: number): RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRefDivisor {
    return new RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRefDivisor {
    return new RunnerDeploymentSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders
 */
export interface RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders(obj: RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetPort
 */
export class RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetPort {
  public static fromNumber(value: number): RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetPort {
    return new RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetPort(value);
  }
  public static fromString(value: string): RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetPort {
    return new RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocketPort
 */
export class RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocketPort {
  public static fromNumber(value: number): RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocketPort {
    return new RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocketPort(value);
  }
  public static fromString(value: string): RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocketPort {
    return new RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocketPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders
 */
export interface RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders(obj: RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetPort
 */
export class RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetPort {
  public static fromNumber(value: number): RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetPort {
    return new RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetPort(value);
  }
  public static fromString(value: string): RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetPort {
    return new RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocketPort
 */
export class RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocketPort {
  public static fromNumber(value: number): RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocketPort {
    return new RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocketPort(value);
  }
  public static fromString(value: string): RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocketPort {
    return new RunnerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocketPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema RunnerDeploymentSpecTemplateSpecInitContainersEnvValueFromResourceFieldRefDivisor
 */
export class RunnerDeploymentSpecTemplateSpecInitContainersEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(value: number): RunnerDeploymentSpecTemplateSpecInitContainersEnvValueFromResourceFieldRefDivisor {
    return new RunnerDeploymentSpecTemplateSpecInitContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): RunnerDeploymentSpecTemplateSpecInitContainersEnvValueFromResourceFieldRefDivisor {
    return new RunnerDeploymentSpecTemplateSpecInitContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders
 */
export interface RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders(obj: RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePostStartHttpGetPort
 */
export class RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePostStartHttpGetPort {
  public static fromNumber(value: number): RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePostStartHttpGetPort {
    return new RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePostStartHttpGetPort(value);
  }
  public static fromString(value: string): RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePostStartHttpGetPort {
    return new RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePostStartHttpGetPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePostStartTcpSocketPort
 */
export class RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePostStartTcpSocketPort {
  public static fromNumber(value: number): RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePostStartTcpSocketPort {
    return new RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePostStartTcpSocketPort(value);
  }
  public static fromString(value: string): RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePostStartTcpSocketPort {
    return new RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePostStartTcpSocketPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders
 */
export interface RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders(obj: RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePreStopHttpGetPort
 */
export class RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePreStopHttpGetPort {
  public static fromNumber(value: number): RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePreStopHttpGetPort {
    return new RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePreStopHttpGetPort(value);
  }
  public static fromString(value: string): RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePreStopHttpGetPort {
    return new RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePreStopHttpGetPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePreStopTcpSocketPort
 */
export class RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePreStopTcpSocketPort {
  public static fromNumber(value: number): RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePreStopTcpSocketPort {
    return new RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePreStopTcpSocketPort(value);
  }
  public static fromString(value: string): RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePreStopTcpSocketPort {
    return new RunnerDeploymentSpecTemplateSpecInitContainersLifecyclePreStopTcpSocketPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersEnvValueFromResourceFieldRefDivisor
 */
export class RunnerDeploymentSpecTemplateSpecSidecarContainersEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(value: number): RunnerDeploymentSpecTemplateSpecSidecarContainersEnvValueFromResourceFieldRefDivisor {
    return new RunnerDeploymentSpecTemplateSpecSidecarContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): RunnerDeploymentSpecTemplateSpecSidecarContainersEnvValueFromResourceFieldRefDivisor {
    return new RunnerDeploymentSpecTemplateSpecSidecarContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePostStartHttpGetHttpHeaders
 */
export interface RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePostStartHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePostStartHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePostStartHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePostStartHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePostStartHttpGetHttpHeaders(obj: RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePostStartHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePostStartHttpGetPort
 */
export class RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePostStartHttpGetPort {
  public static fromNumber(value: number): RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePostStartHttpGetPort {
    return new RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePostStartHttpGetPort(value);
  }
  public static fromString(value: string): RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePostStartHttpGetPort {
    return new RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePostStartHttpGetPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePostStartTcpSocketPort
 */
export class RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePostStartTcpSocketPort {
  public static fromNumber(value: number): RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePostStartTcpSocketPort {
    return new RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePostStartTcpSocketPort(value);
  }
  public static fromString(value: string): RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePostStartTcpSocketPort {
    return new RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePostStartTcpSocketPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePreStopHttpGetHttpHeaders
 */
export interface RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePreStopHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePreStopHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePreStopHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePreStopHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePreStopHttpGetHttpHeaders(obj: RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePreStopHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePreStopHttpGetPort
 */
export class RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePreStopHttpGetPort {
  public static fromNumber(value: number): RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePreStopHttpGetPort {
    return new RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePreStopHttpGetPort(value);
  }
  public static fromString(value: string): RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePreStopHttpGetPort {
    return new RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePreStopHttpGetPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePreStopTcpSocketPort
 */
export class RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePreStopTcpSocketPort {
  public static fromNumber(value: number): RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePreStopTcpSocketPort {
    return new RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePreStopTcpSocketPort(value);
  }
  public static fromString(value: string): RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePreStopTcpSocketPort {
    return new RunnerDeploymentSpecTemplateSpecSidecarContainersLifecyclePreStopTcpSocketPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema RunnerDeploymentSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRefDivisor
 */
export class RunnerDeploymentSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRefDivisor {
  public static fromNumber(value: number): RunnerDeploymentSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRefDivisor {
    return new RunnerDeploymentSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): RunnerDeploymentSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRefDivisor {
    return new RunnerDeploymentSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * This field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. If the AnyVolumeDataSource feature gate is enabled, this field will always have the same contents as the DataSourceRef field.
 *
 * @schema RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource
 */
export interface RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource {
  /**
   * APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource(obj: RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any local object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the DataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, both fields (DataSource and DataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. There are two important differences between DataSource and DataSourceRef: * While DataSource only allows two specific types of objects, DataSourceRef   allows any non-core object, as well as PersistentVolumeClaim objects. * While DataSource ignores disallowed values (dropping them), DataSourceRef   preserves all values, and generates an error if a disallowed value is   specified. (Alpha) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
 *
 * @schema RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef
 */
export interface RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef {
  /**
   * APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef(obj: RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
 *
 * @schema RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResources
 */
export interface RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResources {
  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResources#limits
   */
  readonly limits?: { [key: string]: RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResources#requests
   */
  readonly requests?: { [key: string]: RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests };

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResources(obj: RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over volumes to consider for binding.
 *
 * @schema RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelector
 */
export interface RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelector#matchExpressions
   */
  readonly matchExpressions?: RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelector(obj: RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesConfigMapItems
 */
export interface RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesConfigMapItems {
  /**
   * The key to project.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesConfigMapItems#key
   */
  readonly key: string;

  /**
   * Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesConfigMapItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesConfigMapItems(obj: RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesConfigMapItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DownwardAPIVolumeFile represents information to create the file containing the pod field
 *
 * @schema RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesDownwardApiItems
 */
export interface RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesDownwardApiItems {
  /**
   * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesDownwardApiItems#fieldRef
   */
  readonly fieldRef?: RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsFieldRef;

  /**
   * Optional: mode bits used to set permissions on this file, must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesDownwardApiItems#mode
   */
  readonly mode?: number;

  /**
   * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesDownwardApiItems#path
   */
  readonly path: string;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesDownwardApiItems#resourceFieldRef
   */
  readonly resourceFieldRef?: RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesDownwardApiItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesDownwardApiItems(obj: RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesDownwardApiItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fieldRef': toJson_RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsFieldRef(obj.fieldRef),
    'mode': obj.mode,
    'path': obj.path,
    'resourceFieldRef': toJson_RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef(obj.resourceFieldRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesSecretItems
 */
export interface RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesSecretItems {
  /**
   * The key to project.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesSecretItems#key
   */
  readonly key: string;

  /**
   * Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesSecretItems#mode
   */
  readonly mode?: number;

  /**
   * The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesSecretItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesSecretItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesSecretItems(obj: RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesSecretItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface RunnerDeploymentSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: RunnerDeploymentSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface RunnerDeploymentSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: RunnerDeploymentSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: RunnerDeploymentSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits
 */
export class RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
  public static fromNumber(value: number): RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits(value);
  }
  public static fromString(value: string): RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * @schema RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests
 */
export class RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
  public static fromNumber(value: number): RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests(value);
  }
  public static fromString(value: string): RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions
 */
export interface RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(obj: RunnerDeploymentSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
 *
 * @schema RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsFieldRef
 */
export interface RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsFieldRef(obj: RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
 *
 * @schema RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef
 */
export interface RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#divisor
   */
  readonly divisor?: RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef(obj: RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor
 */
export class RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
  public static fromNumber(value: number): RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
    return new RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
    return new RunnerDeploymentSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: any) {
  }
}


/**
 * RunnerReplicaSet is the Schema for the runnerreplicasets API
 *
 * @schema RunnerReplicaSet
 */
export class RunnerReplicaSet extends ApiObject {
  /**
   * Returns the apiVersion and kind for "RunnerReplicaSet"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'actions.summerwind.dev/v1alpha1',
    kind: 'RunnerReplicaSet',
  }

  /**
   * Renders a Kubernetes manifest for "RunnerReplicaSet".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: RunnerReplicaSetProps = {}): any {
    return {
      ...RunnerReplicaSet.GVK,
      ...toJson_RunnerReplicaSetProps(props),
    };
  }

  /**
   * Defines a "RunnerReplicaSet" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: RunnerReplicaSetProps = {}) {
    super(scope, id, {
      ...RunnerReplicaSet.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...RunnerReplicaSet.GVK,
      ...toJson_RunnerReplicaSetProps(resolved),
    };
  }
}

/**
 * RunnerReplicaSet is the Schema for the runnerreplicasets API
 *
 * @schema RunnerReplicaSet
 */
export interface RunnerReplicaSetProps {
  /**
   * @schema RunnerReplicaSet#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * RunnerReplicaSetSpec defines the desired state of RunnerReplicaSet
   *
   * @schema RunnerReplicaSet#spec
   */
  readonly spec?: RunnerReplicaSetSpec;

}

/**
 * Converts an object of type 'RunnerReplicaSetProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetProps(obj: RunnerReplicaSetProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_RunnerReplicaSetSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RunnerReplicaSetSpec defines the desired state of RunnerReplicaSet
 *
 * @schema RunnerReplicaSetSpec
 */
export interface RunnerReplicaSetSpec {
  /**
   * EffectiveTime is the time the upstream controller requested to sync Replicas. It is usually populated by the webhook-based autoscaler via HRA and RunnerDeployment. The value is used to prevent runnerreplicaset controller from unnecessarily recreating ephemeral runners based on potentially outdated Replicas value.
   *
   * @schema RunnerReplicaSetSpec#effectiveTime
   */
  readonly effectiveTime?: Date;

  /**
   * @schema RunnerReplicaSetSpec#replicas
   */
  readonly replicas?: number;

  /**
   * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
   *
   * @schema RunnerReplicaSetSpec#selector
   */
  readonly selector?: RunnerReplicaSetSpecSelector;

  /**
   * @schema RunnerReplicaSetSpec#template
   */
  readonly template: RunnerReplicaSetSpecTemplate;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpec(obj: RunnerReplicaSetSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effectiveTime': obj.effectiveTime?.toISOString(),
    'replicas': obj.replicas,
    'selector': toJson_RunnerReplicaSetSpecSelector(obj.selector),
    'template': toJson_RunnerReplicaSetSpecTemplate(obj.template),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
 *
 * @schema RunnerReplicaSetSpecSelector
 */
export interface RunnerReplicaSetSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema RunnerReplicaSetSpecSelector#matchExpressions
   */
  readonly matchExpressions?: RunnerReplicaSetSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema RunnerReplicaSetSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecSelector(obj: RunnerReplicaSetSpecSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_RunnerReplicaSetSpecSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RunnerReplicaSetSpecTemplate
 */
export interface RunnerReplicaSetSpecTemplate {
  /**
   * @schema RunnerReplicaSetSpecTemplate#metadata
   */
  readonly metadata?: RunnerReplicaSetSpecTemplateMetadata;

  /**
   * RunnerSpec defines the desired state of Runner
   *
   * @schema RunnerReplicaSetSpecTemplate#spec
   */
  readonly spec?: RunnerReplicaSetSpecTemplateSpec;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplate(obj: RunnerReplicaSetSpecTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_RunnerReplicaSetSpecTemplateMetadata(obj.metadata),
    'spec': toJson_RunnerReplicaSetSpecTemplateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema RunnerReplicaSetSpecSelectorMatchExpressions
 */
export interface RunnerReplicaSetSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema RunnerReplicaSetSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema RunnerReplicaSetSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema RunnerReplicaSetSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecSelectorMatchExpressions(obj: RunnerReplicaSetSpecSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RunnerReplicaSetSpecTemplateMetadata
 */
export interface RunnerReplicaSetSpecTemplateMetadata {
  /**
   * @schema RunnerReplicaSetSpecTemplateMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * @schema RunnerReplicaSetSpecTemplateMetadata#finalizers
   */
  readonly finalizers?: string[];

  /**
   * @schema RunnerReplicaSetSpecTemplateMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * @schema RunnerReplicaSetSpecTemplateMetadata#name
   */
  readonly name?: string;

  /**
   * @schema RunnerReplicaSetSpecTemplateMetadata#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateMetadata(obj: RunnerReplicaSetSpecTemplateMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'finalizers': obj.finalizers?.map(y => y),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RunnerSpec defines the desired state of Runner
 *
 * @schema RunnerReplicaSetSpecTemplateSpec
 */
export interface RunnerReplicaSetSpecTemplateSpec {
  /**
   * Affinity is a group of affinity scheduling rules.
   *
   * @schema RunnerReplicaSetSpecTemplateSpec#affinity
   */
  readonly affinity?: RunnerReplicaSetSpecTemplateSpecAffinity;

  /**
   * @schema RunnerReplicaSetSpecTemplateSpec#automountServiceAccountToken
   */
  readonly automountServiceAccountToken?: boolean;

  /**
   * @schema RunnerReplicaSetSpecTemplateSpec#containers
   */
  readonly containers?: RunnerReplicaSetSpecTemplateSpecContainers[];

  /**
   * @schema RunnerReplicaSetSpecTemplateSpec#dnsConfig
   */
  readonly dnsConfig?: RunnerReplicaSetSpecTemplateSpecDnsConfig[];

  /**
   * @schema RunnerReplicaSetSpecTemplateSpec#dockerEnabled
   */
  readonly dockerEnabled?: boolean;

  /**
   * @schema RunnerReplicaSetSpecTemplateSpec#dockerEnv
   */
  readonly dockerEnv?: RunnerReplicaSetSpecTemplateSpecDockerEnv[];

  /**
   * @schema RunnerReplicaSetSpecTemplateSpec#dockerMTU
   */
  readonly dockerMtu?: number;

  /**
   * @schema RunnerReplicaSetSpecTemplateSpec#dockerRegistryMirror
   */
  readonly dockerRegistryMirror?: string;

  /**
   * @schema RunnerReplicaSetSpecTemplateSpec#dockerVolumeMounts
   */
  readonly dockerVolumeMounts?: RunnerReplicaSetSpecTemplateSpecDockerVolumeMounts[];

  /**
   * ResourceRequirements describes the compute resource requirements.
   *
   * @schema RunnerReplicaSetSpecTemplateSpec#dockerdContainerResources
   */
  readonly dockerdContainerResources?: RunnerReplicaSetSpecTemplateSpecDockerdContainerResources;

  /**
   * @schema RunnerReplicaSetSpecTemplateSpec#dockerdWithinRunnerContainer
   */
  readonly dockerdWithinRunnerContainer?: boolean;

  /**
   * @schema RunnerReplicaSetSpecTemplateSpec#enableServiceLinks
   */
  readonly enableServiceLinks?: boolean;

  /**
   * @schema RunnerReplicaSetSpecTemplateSpec#enterprise
   */
  readonly enterprise?: string;

  /**
   * @schema RunnerReplicaSetSpecTemplateSpec#env
   */
  readonly env?: RunnerReplicaSetSpecTemplateSpecEnv[];

  /**
   * @schema RunnerReplicaSetSpecTemplateSpec#envFrom
   */
  readonly envFrom?: RunnerReplicaSetSpecTemplateSpecEnvFrom[];

  /**
   * @schema RunnerReplicaSetSpecTemplateSpec#ephemeral
   */
  readonly ephemeral?: boolean;

  /**
   * @schema RunnerReplicaSetSpecTemplateSpec#ephemeralContainers
   */
  readonly ephemeralContainers?: RunnerReplicaSetSpecTemplateSpecEphemeralContainers[];

  /**
   * @schema RunnerReplicaSetSpecTemplateSpec#group
   */
  readonly group?: string;

  /**
   * @schema RunnerReplicaSetSpecTemplateSpec#hostAliases
   */
  readonly hostAliases?: RunnerReplicaSetSpecTemplateSpecHostAliases[];

  /**
   * @schema RunnerReplicaSetSpecTemplateSpec#image
   */
  readonly image?: string;

  /**
   * PullPolicy describes a policy for if/when to pull a container image
   *
   * @schema RunnerReplicaSetSpecTemplateSpec#imagePullPolicy
   */
  readonly imagePullPolicy?: string;

  /**
   * @schema RunnerReplicaSetSpecTemplateSpec#imagePullSecrets
   */
  readonly imagePullSecrets?: RunnerReplicaSetSpecTemplateSpecImagePullSecrets[];

  /**
   * @schema RunnerReplicaSetSpecTemplateSpec#initContainers
   */
  readonly initContainers?: RunnerReplicaSetSpecTemplateSpecInitContainers[];

  /**
   * @schema RunnerReplicaSetSpecTemplateSpec#labels
   */
  readonly labels?: string[];

  /**
   * @schema RunnerReplicaSetSpecTemplateSpec#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * @schema RunnerReplicaSetSpecTemplateSpec#organization
   */
  readonly organization?: string;

  /**
   * @schema RunnerReplicaSetSpecTemplateSpec#repository
   */
  readonly repository?: string;

  /**
   * ResourceRequirements describes the compute resource requirements.
   *
   * @schema RunnerReplicaSetSpecTemplateSpec#resources
   */
  readonly resources?: RunnerReplicaSetSpecTemplateSpecResources;

  /**
   * RuntimeClassName is the container runtime configuration that containers should run under. More info: https://kubernetes.io/docs/concepts/containers/runtime-class
   *
   * @schema RunnerReplicaSetSpecTemplateSpec#runtimeClassName
   */
  readonly runtimeClassName?: string;

  /**
   * PodSecurityContext holds pod-level security attributes and common container settings. Some fields are also present in container.securityContext.  Field values of container.securityContext take precedence over field values of PodSecurityContext.
   *
   * @schema RunnerReplicaSetSpecTemplateSpec#securityContext
   */
  readonly securityContext?: RunnerReplicaSetSpecTemplateSpecSecurityContext;

  /**
   * @schema RunnerReplicaSetSpecTemplateSpec#serviceAccountName
   */
  readonly serviceAccountName?: string;

  /**
   * @schema RunnerReplicaSetSpecTemplateSpec#sidecarContainers
   */
  readonly sidecarContainers?: RunnerReplicaSetSpecTemplateSpecSidecarContainers[];

  /**
   * @schema RunnerReplicaSetSpecTemplateSpec#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * @schema RunnerReplicaSetSpecTemplateSpec#tolerations
   */
  readonly tolerations?: RunnerReplicaSetSpecTemplateSpecTolerations[];

  /**
   * @schema RunnerReplicaSetSpecTemplateSpec#topologySpreadConstraint
   */
  readonly topologySpreadConstraint?: RunnerReplicaSetSpecTemplateSpecTopologySpreadConstraint[];

  /**
   * @schema RunnerReplicaSetSpecTemplateSpec#volumeMounts
   */
  readonly volumeMounts?: RunnerReplicaSetSpecTemplateSpecVolumeMounts[];

  /**
   * @schema RunnerReplicaSetSpecTemplateSpec#volumeSizeLimit
   */
  readonly volumeSizeLimit?: RunnerReplicaSetSpecTemplateSpecVolumeSizeLimit;

  /**
   * @schema RunnerReplicaSetSpecTemplateSpec#volumeStorageMedium
   */
  readonly volumeStorageMedium?: string;

  /**
   * @schema RunnerReplicaSetSpecTemplateSpec#volumes
   */
  readonly volumes?: RunnerReplicaSetSpecTemplateSpecVolumes[];

  /**
   * @schema RunnerReplicaSetSpecTemplateSpec#workDir
   */
  readonly workDir?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpec(obj: RunnerReplicaSetSpecTemplateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'affinity': toJson_RunnerReplicaSetSpecTemplateSpecAffinity(obj.affinity),
    'automountServiceAccountToken': obj.automountServiceAccountToken,
    'containers': obj.containers?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecContainers(y)),
    'dnsConfig': obj.dnsConfig?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecDnsConfig(y)),
    'dockerEnabled': obj.dockerEnabled,
    'dockerEnv': obj.dockerEnv?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecDockerEnv(y)),
    'dockerMTU': obj.dockerMtu,
    'dockerRegistryMirror': obj.dockerRegistryMirror,
    'dockerVolumeMounts': obj.dockerVolumeMounts?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecDockerVolumeMounts(y)),
    'dockerdContainerResources': toJson_RunnerReplicaSetSpecTemplateSpecDockerdContainerResources(obj.dockerdContainerResources),
    'dockerdWithinRunnerContainer': obj.dockerdWithinRunnerContainer,
    'enableServiceLinks': obj.enableServiceLinks,
    'enterprise': obj.enterprise,
    'env': obj.env?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecEnv(y)),
    'envFrom': obj.envFrom?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecEnvFrom(y)),
    'ephemeral': obj.ephemeral,
    'ephemeralContainers': obj.ephemeralContainers?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainers(y)),
    'group': obj.group,
    'hostAliases': obj.hostAliases?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecHostAliases(y)),
    'image': obj.image,
    'imagePullPolicy': obj.imagePullPolicy,
    'imagePullSecrets': obj.imagePullSecrets?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecImagePullSecrets(y)),
    'initContainers': obj.initContainers?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecInitContainers(y)),
    'labels': obj.labels?.map(y => y),
    'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'organization': obj.organization,
    'repository': obj.repository,
    'resources': toJson_RunnerReplicaSetSpecTemplateSpecResources(obj.resources),
    'runtimeClassName': obj.runtimeClassName,
    'securityContext': toJson_RunnerReplicaSetSpecTemplateSpecSecurityContext(obj.securityContext),
    'serviceAccountName': obj.serviceAccountName,
    'sidecarContainers': obj.sidecarContainers?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainers(y)),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'tolerations': obj.tolerations?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecTolerations(y)),
    'topologySpreadConstraint': obj.topologySpreadConstraint?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecTopologySpreadConstraint(y)),
    'volumeMounts': obj.volumeMounts?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecVolumeMounts(y)),
    'volumeSizeLimit': obj.volumeSizeLimit?.value,
    'volumeStorageMedium': obj.volumeStorageMedium,
    'volumes': obj.volumes?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecVolumes(y)),
    'workDir': obj.workDir,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Affinity is a group of affinity scheduling rules.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecAffinity
 */
export interface RunnerReplicaSetSpecTemplateSpecAffinity {
  /**
   * Describes node affinity scheduling rules for the pod.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinity#nodeAffinity
   */
  readonly nodeAffinity?: RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinity;

  /**
   * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinity#podAffinity
   */
  readonly podAffinity?: RunnerReplicaSetSpecTemplateSpecAffinityPodAffinity;

  /**
   * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinity;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecAffinity(obj: RunnerReplicaSetSpecTemplateSpecAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeAffinity': toJson_RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinity(obj.nodeAffinity),
    'podAffinity': toJson_RunnerReplicaSetSpecTemplateSpecAffinityPodAffinity(obj.podAffinity),
    'podAntiAffinity': toJson_RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinity(obj.podAntiAffinity),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A single application container that you want to run within a pod.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecContainers
 */
export interface RunnerReplicaSetSpecTemplateSpecContainers {
  /**
   * Arguments to the entrypoint. The docker image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainers#args
   */
  readonly args?: string[];

  /**
   * Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainers#command
   */
  readonly command?: string[];

  /**
   * List of environment variables to set in the container. Cannot be updated.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainers#env
   */
  readonly env?: RunnerReplicaSetSpecTemplateSpecContainersEnv[];

  /**
   * List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainers#envFrom
   */
  readonly envFrom?: RunnerReplicaSetSpecTemplateSpecContainersEnvFrom[];

  /**
   * Docker image name. More info: https://kubernetes.io/docs/concepts/containers/images This field is optional to allow higher level config management to default or override container images in workload controllers like Deployments and StatefulSets.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainers#image
   */
  readonly image?: string;

  /**
   * Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   *
   * @default Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   * @schema RunnerReplicaSetSpecTemplateSpecContainers#imagePullPolicy
   */
  readonly imagePullPolicy?: string;

  /**
   * Actions that the management system should take in response to container lifecycle events. Cannot be updated.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainers#lifecycle
   */
  readonly lifecycle?: RunnerReplicaSetSpecTemplateSpecContainersLifecycle;

  /**
   * Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainers#livenessProbe
   */
  readonly livenessProbe?: RunnerReplicaSetSpecTemplateSpecContainersLivenessProbe;

  /**
   * Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainers#name
   */
  readonly name: string;

  /**
   * List of ports to expose from the container. Exposing a port here gives the system additional information about the network connections a container uses, but is primarily informational. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default "0.0.0.0" address inside a container will be accessible from the network. Cannot be updated.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainers#ports
   */
  readonly ports?: RunnerReplicaSetSpecTemplateSpecContainersPorts[];

  /**
   * Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainers#readinessProbe
   */
  readonly readinessProbe?: RunnerReplicaSetSpecTemplateSpecContainersReadinessProbe;

  /**
   * Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainers#resources
   */
  readonly resources?: RunnerReplicaSetSpecTemplateSpecContainersResources;

  /**
   * SecurityContext defines the security options the container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainers#securityContext
   */
  readonly securityContext?: RunnerReplicaSetSpecTemplateSpecContainersSecurityContext;

  /**
   * StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainers#startupProbe
   */
  readonly startupProbe?: RunnerReplicaSetSpecTemplateSpecContainersStartupProbe;

  /**
   * Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF. Default is false.
   *
   * @default false.
   * @schema RunnerReplicaSetSpecTemplateSpecContainers#stdin
   */
  readonly stdin?: boolean;

  /**
   * Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false
   *
   * @default false
   * @schema RunnerReplicaSetSpecTemplateSpecContainers#stdinOnce
   */
  readonly stdinOnce?: boolean;

  /**
   * Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Will be truncated by the node if greater than 4096 bytes. The total message length across all containers will be limited to 12kb. Defaults to /dev/termination-log. Cannot be updated.
   *
   * @default dev/termination-log. Cannot be updated.
   * @schema RunnerReplicaSetSpecTemplateSpecContainers#terminationMessagePath
   */
  readonly terminationMessagePath?: string;

  /**
   * Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.
   *
   * @default File. Cannot be updated.
   * @schema RunnerReplicaSetSpecTemplateSpecContainers#terminationMessagePolicy
   */
  readonly terminationMessagePolicy?: string;

  /**
   * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true. Default is false.
   *
   * @default false.
   * @schema RunnerReplicaSetSpecTemplateSpecContainers#tty
   */
  readonly tty?: boolean;

  /**
   * volumeDevices is the list of block devices to be used by the container.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainers#volumeDevices
   */
  readonly volumeDevices?: RunnerReplicaSetSpecTemplateSpecContainersVolumeDevices[];

  /**
   * Pod volumes to mount into the container's filesystem. Cannot be updated.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainers#volumeMounts
   */
  readonly volumeMounts?: RunnerReplicaSetSpecTemplateSpecContainersVolumeMounts[];

  /**
   * Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainers#workingDir
   */
  readonly workingDir?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecContainers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecContainers(obj: RunnerReplicaSetSpecTemplateSpecContainers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'args': obj.args?.map(y => y),
    'command': obj.command?.map(y => y),
    'env': obj.env?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecContainersEnv(y)),
    'envFrom': obj.envFrom?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecContainersEnvFrom(y)),
    'image': obj.image,
    'imagePullPolicy': obj.imagePullPolicy,
    'lifecycle': toJson_RunnerReplicaSetSpecTemplateSpecContainersLifecycle(obj.lifecycle),
    'livenessProbe': toJson_RunnerReplicaSetSpecTemplateSpecContainersLivenessProbe(obj.livenessProbe),
    'name': obj.name,
    'ports': obj.ports?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecContainersPorts(y)),
    'readinessProbe': toJson_RunnerReplicaSetSpecTemplateSpecContainersReadinessProbe(obj.readinessProbe),
    'resources': toJson_RunnerReplicaSetSpecTemplateSpecContainersResources(obj.resources),
    'securityContext': toJson_RunnerReplicaSetSpecTemplateSpecContainersSecurityContext(obj.securityContext),
    'startupProbe': toJson_RunnerReplicaSetSpecTemplateSpecContainersStartupProbe(obj.startupProbe),
    'stdin': obj.stdin,
    'stdinOnce': obj.stdinOnce,
    'terminationMessagePath': obj.terminationMessagePath,
    'terminationMessagePolicy': obj.terminationMessagePolicy,
    'tty': obj.tty,
    'volumeDevices': obj.volumeDevices?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecContainersVolumeDevices(y)),
    'volumeMounts': obj.volumeMounts?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecContainersVolumeMounts(y)),
    'workingDir': obj.workingDir,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PodDNSConfig defines the DNS parameters of a pod in addition to those generated from DNSPolicy.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecDnsConfig
 */
export interface RunnerReplicaSetSpecTemplateSpecDnsConfig {
  /**
   * A list of DNS name server IP addresses. This will be appended to the base nameservers generated from DNSPolicy. Duplicated nameservers will be removed.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecDnsConfig#nameservers
   */
  readonly nameservers?: string[];

  /**
   * A list of DNS resolver options. This will be merged with the base options generated from DNSPolicy. Duplicated entries will be removed. Resolution options given in Options will override those that appear in the base DNSPolicy.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecDnsConfig#options
   */
  readonly options?: RunnerReplicaSetSpecTemplateSpecDnsConfigOptions[];

  /**
   * A list of DNS search domains for host-name lookup. This will be appended to the base search paths generated from DNSPolicy. Duplicated search paths will be removed.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecDnsConfig#searches
   */
  readonly searches?: string[];

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecDnsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecDnsConfig(obj: RunnerReplicaSetSpecTemplateSpecDnsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nameservers': obj.nameservers?.map(y => y),
    'options': obj.options?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecDnsConfigOptions(y)),
    'searches': obj.searches?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecDockerEnv
 */
export interface RunnerReplicaSetSpecTemplateSpecDockerEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecDockerEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded using the previously defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
   *
   * @default .
   * @schema RunnerReplicaSetSpecTemplateSpecDockerEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecDockerEnv#valueFrom
   */
  readonly valueFrom?: RunnerReplicaSetSpecTemplateSpecDockerEnvValueFrom;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecDockerEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecDockerEnv(obj: RunnerReplicaSetSpecTemplateSpecDockerEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
    'valueFrom': toJson_RunnerReplicaSetSpecTemplateSpecDockerEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecDockerVolumeMounts
 */
export interface RunnerReplicaSetSpecTemplateSpecDockerVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must not contain ':'.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecDockerVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. This field is beta in 1.10.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecDockerVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecDockerVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.
   *
   * @default false.
   * @schema RunnerReplicaSetSpecTemplateSpecDockerVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema RunnerReplicaSetSpecTemplateSpecDockerVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment. Defaults to "" (volume's root). SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root). SubPathExpr and SubPath are mutually exclusive.
   * @schema RunnerReplicaSetSpecTemplateSpecDockerVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecDockerVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecDockerVolumeMounts(obj: RunnerReplicaSetSpecTemplateSpecDockerVolumeMounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'mountPropagation': obj.mountPropagation,
    'name': obj.name,
    'readOnly': obj.readOnly,
    'subPath': obj.subPath,
    'subPathExpr': obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceRequirements describes the compute resource requirements.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecDockerdContainerResources
 */
export interface RunnerReplicaSetSpecTemplateSpecDockerdContainerResources {
  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema RunnerReplicaSetSpecTemplateSpecDockerdContainerResources#limits
   */
  readonly limits?: { [key: string]: RunnerReplicaSetSpecTemplateSpecDockerdContainerResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema RunnerReplicaSetSpecTemplateSpecDockerdContainerResources#requests
   */
  readonly requests?: { [key: string]: RunnerReplicaSetSpecTemplateSpecDockerdContainerResourcesRequests };

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecDockerdContainerResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecDockerdContainerResources(obj: RunnerReplicaSetSpecTemplateSpecDockerdContainerResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecEnv
 */
export interface RunnerReplicaSetSpecTemplateSpecEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded using the previously defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
   *
   * @default .
   * @schema RunnerReplicaSetSpecTemplateSpecEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEnv#valueFrom
   */
  readonly valueFrom?: RunnerReplicaSetSpecTemplateSpecEnvValueFrom;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecEnv(obj: RunnerReplicaSetSpecTemplateSpecEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
    'valueFrom': toJson_RunnerReplicaSetSpecTemplateSpecEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema RunnerReplicaSetSpecTemplateSpecEnvFrom
 */
export interface RunnerReplicaSetSpecTemplateSpecEnvFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEnvFrom#configMapRef
   */
  readonly configMapRef?: RunnerReplicaSetSpecTemplateSpecEnvFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEnvFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEnvFrom#secretRef
   */
  readonly secretRef?: RunnerReplicaSetSpecTemplateSpecEnvFromSecretRef;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecEnvFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecEnvFrom(obj: RunnerReplicaSetSpecTemplateSpecEnvFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapRef': toJson_RunnerReplicaSetSpecTemplateSpecEnvFromConfigMapRef(obj.configMapRef),
    'prefix': obj.prefix,
    'secretRef': toJson_RunnerReplicaSetSpecTemplateSpecEnvFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * An EphemeralContainer is a temporary container that you may add to an existing Pod for user-initiated activities such as debugging. Ephemeral containers have no resource or scheduling guarantees, and they will not be restarted when they exit or when a Pod is removed or restarted. The kubelet may evict a Pod if an ephemeral container causes the Pod to exceed its resource allocation.
 * To add an ephemeral container, use the ephemeralcontainers subresource of an existing Pod. Ephemeral containers may not be removed or restarted.
 * This is a beta feature available on clusters that haven't disabled the EphemeralContainers feature gate.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainers
 */
export interface RunnerReplicaSetSpecTemplateSpecEphemeralContainers {
  /**
   * Arguments to the entrypoint. The docker image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainers#args
   */
  readonly args?: string[];

  /**
   * Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainers#command
   */
  readonly command?: string[];

  /**
   * List of environment variables to set in the container. Cannot be updated.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainers#env
   */
  readonly env?: RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnv[];

  /**
   * List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainers#envFrom
   */
  readonly envFrom?: RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvFrom[];

  /**
   * Docker image name. More info: https://kubernetes.io/docs/concepts/containers/images
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainers#image
   */
  readonly image?: string;

  /**
   * Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   *
   * @default Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainers#imagePullPolicy
   */
  readonly imagePullPolicy?: string;

  /**
   * Lifecycle is not allowed for ephemeral containers.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainers#lifecycle
   */
  readonly lifecycle?: RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecycle;

  /**
   * Probes are not allowed for ephemeral containers.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainers#livenessProbe
   */
  readonly livenessProbe?: RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbe;

  /**
   * Name of the ephemeral container specified as a DNS_LABEL. This name must be unique among all containers, init containers and ephemeral containers.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainers#name
   */
  readonly name: string;

  /**
   * Ports are not allowed for ephemeral containers.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainers#ports
   */
  readonly ports?: RunnerReplicaSetSpecTemplateSpecEphemeralContainersPorts[];

  /**
   * Probes are not allowed for ephemeral containers.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainers#readinessProbe
   */
  readonly readinessProbe?: RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbe;

  /**
   * Resources are not allowed for ephemeral containers. Ephemeral containers use spare resources already allocated to the pod.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainers#resources
   */
  readonly resources?: RunnerReplicaSetSpecTemplateSpecEphemeralContainersResources;

  /**
   * Optional: SecurityContext defines the security options the ephemeral container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainers#securityContext
   */
  readonly securityContext?: RunnerReplicaSetSpecTemplateSpecEphemeralContainersSecurityContext;

  /**
   * Probes are not allowed for ephemeral containers.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainers#startupProbe
   */
  readonly startupProbe?: RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbe;

  /**
   * Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF. Default is false.
   *
   * @default false.
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainers#stdin
   */
  readonly stdin?: boolean;

  /**
   * Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false
   *
   * @default false
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainers#stdinOnce
   */
  readonly stdinOnce?: boolean;

  /**
   * If set, the name of the container from PodSpec that this ephemeral container targets. The ephemeral container will be run in the namespaces (IPC, PID, etc) of this container. If not set then the ephemeral container uses the namespaces configured in the Pod spec.
   * The container runtime must implement support for this feature. If the runtime does not support namespace targeting then the result of setting this field is undefined.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainers#targetContainerName
   */
  readonly targetContainerName?: string;

  /**
   * Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Will be truncated by the node if greater than 4096 bytes. The total message length across all containers will be limited to 12kb. Defaults to /dev/termination-log. Cannot be updated.
   *
   * @default dev/termination-log. Cannot be updated.
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainers#terminationMessagePath
   */
  readonly terminationMessagePath?: string;

  /**
   * Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.
   *
   * @default File. Cannot be updated.
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainers#terminationMessagePolicy
   */
  readonly terminationMessagePolicy?: string;

  /**
   * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true. Default is false.
   *
   * @default false.
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainers#tty
   */
  readonly tty?: boolean;

  /**
   * volumeDevices is the list of block devices to be used by the container.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainers#volumeDevices
   */
  readonly volumeDevices?: RunnerReplicaSetSpecTemplateSpecEphemeralContainersVolumeDevices[];

  /**
   * Pod volumes to mount into the container's filesystem. Subpath mounts are not allowed for ephemeral containers. Cannot be updated.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainers#volumeMounts
   */
  readonly volumeMounts?: RunnerReplicaSetSpecTemplateSpecEphemeralContainersVolumeMounts[];

  /**
   * Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainers#workingDir
   */
  readonly workingDir?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecEphemeralContainers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainers(obj: RunnerReplicaSetSpecTemplateSpecEphemeralContainers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'args': obj.args?.map(y => y),
    'command': obj.command?.map(y => y),
    'env': obj.env?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnv(y)),
    'envFrom': obj.envFrom?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvFrom(y)),
    'image': obj.image,
    'imagePullPolicy': obj.imagePullPolicy,
    'lifecycle': toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecycle(obj.lifecycle),
    'livenessProbe': toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbe(obj.livenessProbe),
    'name': obj.name,
    'ports': obj.ports?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersPorts(y)),
    'readinessProbe': toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbe(obj.readinessProbe),
    'resources': toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersResources(obj.resources),
    'securityContext': toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersSecurityContext(obj.securityContext),
    'startupProbe': toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbe(obj.startupProbe),
    'stdin': obj.stdin,
    'stdinOnce': obj.stdinOnce,
    'targetContainerName': obj.targetContainerName,
    'terminationMessagePath': obj.terminationMessagePath,
    'terminationMessagePolicy': obj.terminationMessagePolicy,
    'tty': obj.tty,
    'volumeDevices': obj.volumeDevices?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersVolumeDevices(y)),
    'volumeMounts': obj.volumeMounts?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersVolumeMounts(y)),
    'workingDir': obj.workingDir,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod's hosts file.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecHostAliases
 */
export interface RunnerReplicaSetSpecTemplateSpecHostAliases {
  /**
   * Hostnames for the above IP address.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecHostAliases#hostnames
   */
  readonly hostnames?: string[];

  /**
   * IP address of the host file entry.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecHostAliases#ip
   */
  readonly ip?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecHostAliases' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecHostAliases(obj: RunnerReplicaSetSpecTemplateSpecHostAliases | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostnames': obj.hostnames?.map(y => y),
    'ip': obj.ip,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecImagePullSecrets
 */
export interface RunnerReplicaSetSpecTemplateSpecImagePullSecrets {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerReplicaSetSpecTemplateSpecImagePullSecrets#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecImagePullSecrets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecImagePullSecrets(obj: RunnerReplicaSetSpecTemplateSpecImagePullSecrets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A single application container that you want to run within a pod.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecInitContainers
 */
export interface RunnerReplicaSetSpecTemplateSpecInitContainers {
  /**
   * Arguments to the entrypoint. The docker image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainers#args
   */
  readonly args?: string[];

  /**
   * Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainers#command
   */
  readonly command?: string[];

  /**
   * List of environment variables to set in the container. Cannot be updated.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainers#env
   */
  readonly env?: RunnerReplicaSetSpecTemplateSpecInitContainersEnv[];

  /**
   * List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainers#envFrom
   */
  readonly envFrom?: RunnerReplicaSetSpecTemplateSpecInitContainersEnvFrom[];

  /**
   * Docker image name. More info: https://kubernetes.io/docs/concepts/containers/images This field is optional to allow higher level config management to default or override container images in workload controllers like Deployments and StatefulSets.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainers#image
   */
  readonly image?: string;

  /**
   * Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   *
   * @default Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainers#imagePullPolicy
   */
  readonly imagePullPolicy?: string;

  /**
   * Actions that the management system should take in response to container lifecycle events. Cannot be updated.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainers#lifecycle
   */
  readonly lifecycle?: RunnerReplicaSetSpecTemplateSpecInitContainersLifecycle;

  /**
   * Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainers#livenessProbe
   */
  readonly livenessProbe?: RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbe;

  /**
   * Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainers#name
   */
  readonly name: string;

  /**
   * List of ports to expose from the container. Exposing a port here gives the system additional information about the network connections a container uses, but is primarily informational. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default "0.0.0.0" address inside a container will be accessible from the network. Cannot be updated.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainers#ports
   */
  readonly ports?: RunnerReplicaSetSpecTemplateSpecInitContainersPorts[];

  /**
   * Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainers#readinessProbe
   */
  readonly readinessProbe?: RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbe;

  /**
   * Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainers#resources
   */
  readonly resources?: RunnerReplicaSetSpecTemplateSpecInitContainersResources;

  /**
   * SecurityContext defines the security options the container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainers#securityContext
   */
  readonly securityContext?: RunnerReplicaSetSpecTemplateSpecInitContainersSecurityContext;

  /**
   * StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainers#startupProbe
   */
  readonly startupProbe?: RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbe;

  /**
   * Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF. Default is false.
   *
   * @default false.
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainers#stdin
   */
  readonly stdin?: boolean;

  /**
   * Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false
   *
   * @default false
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainers#stdinOnce
   */
  readonly stdinOnce?: boolean;

  /**
   * Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Will be truncated by the node if greater than 4096 bytes. The total message length across all containers will be limited to 12kb. Defaults to /dev/termination-log. Cannot be updated.
   *
   * @default dev/termination-log. Cannot be updated.
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainers#terminationMessagePath
   */
  readonly terminationMessagePath?: string;

  /**
   * Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.
   *
   * @default File. Cannot be updated.
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainers#terminationMessagePolicy
   */
  readonly terminationMessagePolicy?: string;

  /**
   * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true. Default is false.
   *
   * @default false.
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainers#tty
   */
  readonly tty?: boolean;

  /**
   * volumeDevices is the list of block devices to be used by the container.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainers#volumeDevices
   */
  readonly volumeDevices?: RunnerReplicaSetSpecTemplateSpecInitContainersVolumeDevices[];

  /**
   * Pod volumes to mount into the container's filesystem. Cannot be updated.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainers#volumeMounts
   */
  readonly volumeMounts?: RunnerReplicaSetSpecTemplateSpecInitContainersVolumeMounts[];

  /**
   * Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainers#workingDir
   */
  readonly workingDir?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecInitContainers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecInitContainers(obj: RunnerReplicaSetSpecTemplateSpecInitContainers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'args': obj.args?.map(y => y),
    'command': obj.command?.map(y => y),
    'env': obj.env?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecInitContainersEnv(y)),
    'envFrom': obj.envFrom?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecInitContainersEnvFrom(y)),
    'image': obj.image,
    'imagePullPolicy': obj.imagePullPolicy,
    'lifecycle': toJson_RunnerReplicaSetSpecTemplateSpecInitContainersLifecycle(obj.lifecycle),
    'livenessProbe': toJson_RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbe(obj.livenessProbe),
    'name': obj.name,
    'ports': obj.ports?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecInitContainersPorts(y)),
    'readinessProbe': toJson_RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbe(obj.readinessProbe),
    'resources': toJson_RunnerReplicaSetSpecTemplateSpecInitContainersResources(obj.resources),
    'securityContext': toJson_RunnerReplicaSetSpecTemplateSpecInitContainersSecurityContext(obj.securityContext),
    'startupProbe': toJson_RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbe(obj.startupProbe),
    'stdin': obj.stdin,
    'stdinOnce': obj.stdinOnce,
    'terminationMessagePath': obj.terminationMessagePath,
    'terminationMessagePolicy': obj.terminationMessagePolicy,
    'tty': obj.tty,
    'volumeDevices': obj.volumeDevices?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecInitContainersVolumeDevices(y)),
    'volumeMounts': obj.volumeMounts?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecInitContainersVolumeMounts(y)),
    'workingDir': obj.workingDir,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceRequirements describes the compute resource requirements.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecResources
 */
export interface RunnerReplicaSetSpecTemplateSpecResources {
  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema RunnerReplicaSetSpecTemplateSpecResources#limits
   */
  readonly limits?: { [key: string]: RunnerReplicaSetSpecTemplateSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema RunnerReplicaSetSpecTemplateSpecResources#requests
   */
  readonly requests?: { [key: string]: RunnerReplicaSetSpecTemplateSpecResourcesRequests };

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecResources(obj: RunnerReplicaSetSpecTemplateSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PodSecurityContext holds pod-level security attributes and common container settings. Some fields are also present in container.securityContext.  Field values of container.securityContext take precedence over field values of PodSecurityContext.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecSecurityContext
 */
export interface RunnerReplicaSetSpecTemplateSpecSecurityContext {
  /**
   * A special supplemental group that applies to all containers in a pod. Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod:
   * 1. The owning GID will be the FSGroup 2. The setgid bit is set (new files created in the volume will be owned by FSGroup) 3. The permission bits are OR'd with rw-rw----
   * If unset, the Kubelet will not modify the ownership and permissions of any volume. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * fsGroupChangePolicy defines behavior of changing ownership and permission of the volume before being exposed inside Pod. This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir. Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   * @schema RunnerReplicaSetSpecTemplateSpecSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: RunnerReplicaSetSpecTemplateSpecSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSecurityContext#seccompProfile
   */
  readonly seccompProfile?: RunnerReplicaSetSpecTemplateSpecSecurityContextSeccompProfile;

  /**
   * A list of groups applied to the first process run in each container, in addition to the container's primary GID.  If unspecified, no groups will be added to any container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported sysctls (by the container runtime) might fail to launch. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSecurityContext#sysctls
   */
  readonly sysctls?: RunnerReplicaSetSpecTemplateSpecSecurityContextSysctls[];

  /**
   * The Windows specific settings applied to all containers. If unspecified, the options within a container's SecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSecurityContext#windowsOptions
   */
  readonly windowsOptions?: RunnerReplicaSetSpecTemplateSpecSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecSecurityContext(obj: RunnerReplicaSetSpecTemplateSpecSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsGroup': obj.fsGroup,
    'fsGroupChangePolicy': obj.fsGroupChangePolicy,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_RunnerReplicaSetSpecTemplateSpecSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_RunnerReplicaSetSpecTemplateSpecSecurityContextSeccompProfile(obj.seccompProfile),
    'supplementalGroups': obj.supplementalGroups?.map(y => y),
    'sysctls': obj.sysctls?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecSecurityContextSysctls(y)),
    'windowsOptions': toJson_RunnerReplicaSetSpecTemplateSpecSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A single application container that you want to run within a pod.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainers
 */
export interface RunnerReplicaSetSpecTemplateSpecSidecarContainers {
  /**
   * Arguments to the entrypoint. The docker image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainers#args
   */
  readonly args?: string[];

  /**
   * Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainers#command
   */
  readonly command?: string[];

  /**
   * List of environment variables to set in the container. Cannot be updated.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainers#env
   */
  readonly env?: RunnerReplicaSetSpecTemplateSpecSidecarContainersEnv[];

  /**
   * List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainers#envFrom
   */
  readonly envFrom?: RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvFrom[];

  /**
   * Docker image name. More info: https://kubernetes.io/docs/concepts/containers/images This field is optional to allow higher level config management to default or override container images in workload controllers like Deployments and StatefulSets.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainers#image
   */
  readonly image?: string;

  /**
   * Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   *
   * @default Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainers#imagePullPolicy
   */
  readonly imagePullPolicy?: string;

  /**
   * Actions that the management system should take in response to container lifecycle events. Cannot be updated.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainers#lifecycle
   */
  readonly lifecycle?: RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecycle;

  /**
   * Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainers#livenessProbe
   */
  readonly livenessProbe?: RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbe;

  /**
   * Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainers#name
   */
  readonly name: string;

  /**
   * List of ports to expose from the container. Exposing a port here gives the system additional information about the network connections a container uses, but is primarily informational. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default "0.0.0.0" address inside a container will be accessible from the network. Cannot be updated.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainers#ports
   */
  readonly ports?: RunnerReplicaSetSpecTemplateSpecSidecarContainersPorts[];

  /**
   * Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainers#readinessProbe
   */
  readonly readinessProbe?: RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbe;

  /**
   * Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainers#resources
   */
  readonly resources?: RunnerReplicaSetSpecTemplateSpecSidecarContainersResources;

  /**
   * SecurityContext defines the security options the container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainers#securityContext
   */
  readonly securityContext?: RunnerReplicaSetSpecTemplateSpecSidecarContainersSecurityContext;

  /**
   * StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainers#startupProbe
   */
  readonly startupProbe?: RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbe;

  /**
   * Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF. Default is false.
   *
   * @default false.
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainers#stdin
   */
  readonly stdin?: boolean;

  /**
   * Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false
   *
   * @default false
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainers#stdinOnce
   */
  readonly stdinOnce?: boolean;

  /**
   * Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Will be truncated by the node if greater than 4096 bytes. The total message length across all containers will be limited to 12kb. Defaults to /dev/termination-log. Cannot be updated.
   *
   * @default dev/termination-log. Cannot be updated.
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainers#terminationMessagePath
   */
  readonly terminationMessagePath?: string;

  /**
   * Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.
   *
   * @default File. Cannot be updated.
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainers#terminationMessagePolicy
   */
  readonly terminationMessagePolicy?: string;

  /**
   * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true. Default is false.
   *
   * @default false.
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainers#tty
   */
  readonly tty?: boolean;

  /**
   * volumeDevices is the list of block devices to be used by the container.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainers#volumeDevices
   */
  readonly volumeDevices?: RunnerReplicaSetSpecTemplateSpecSidecarContainersVolumeDevices[];

  /**
   * Pod volumes to mount into the container's filesystem. Cannot be updated.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainers#volumeMounts
   */
  readonly volumeMounts?: RunnerReplicaSetSpecTemplateSpecSidecarContainersVolumeMounts[];

  /**
   * Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainers#workingDir
   */
  readonly workingDir?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecSidecarContainers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainers(obj: RunnerReplicaSetSpecTemplateSpecSidecarContainers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'args': obj.args?.map(y => y),
    'command': obj.command?.map(y => y),
    'env': obj.env?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersEnv(y)),
    'envFrom': obj.envFrom?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvFrom(y)),
    'image': obj.image,
    'imagePullPolicy': obj.imagePullPolicy,
    'lifecycle': toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecycle(obj.lifecycle),
    'livenessProbe': toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbe(obj.livenessProbe),
    'name': obj.name,
    'ports': obj.ports?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersPorts(y)),
    'readinessProbe': toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbe(obj.readinessProbe),
    'resources': toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersResources(obj.resources),
    'securityContext': toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersSecurityContext(obj.securityContext),
    'startupProbe': toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbe(obj.startupProbe),
    'stdin': obj.stdin,
    'stdinOnce': obj.stdinOnce,
    'terminationMessagePath': obj.terminationMessagePath,
    'terminationMessagePolicy': obj.terminationMessagePolicy,
    'tty': obj.tty,
    'volumeDevices': obj.volumeDevices?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersVolumeDevices(y)),
    'volumeMounts': obj.volumeMounts?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersVolumeMounts(y)),
    'workingDir': obj.workingDir,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecTolerations
 */
export interface RunnerReplicaSetSpecTemplateSpecTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
   *
   * @default Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
   * @schema RunnerReplicaSetSpecTemplateSpecTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecTolerations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecTolerations(obj: RunnerReplicaSetSpecTemplateSpecTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TopologySpreadConstraint specifies how to spread matching pods among the given topology.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecTopologySpreadConstraint
 */
export interface RunnerReplicaSetSpecTemplateSpecTopologySpreadConstraint {
  /**
   * LabelSelector is used to find matching pods. Pods that match this label selector are counted to determine the number of pods in their corresponding topology domain.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecTopologySpreadConstraint#labelSelector
   */
  readonly labelSelector?: RunnerReplicaSetSpecTemplateSpecTopologySpreadConstraintLabelSelector;

  /**
   * MaxSkew describes the degree to which pods may be unevenly distributed. When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted difference between the number of matching pods in the target topology and the global minimum. For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same labelSelector spread as 1/1/0: | zone1 | zone2 | zone3 | |   P   |   P   |       | - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 1/1/1; scheduling it onto zone1(zone2) would make the ActualSkew(2-0) on zone1(zone2) violate MaxSkew(1). - if MaxSkew is 2, incoming pod can be scheduled onto any zone. When `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher precedence to topologies that satisfy it. It's a required field. Default value is 1 and 0 is not allowed.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecTopologySpreadConstraint#maxSkew
   */
  readonly maxSkew: number;

  /**
   * TopologyKey is the key of node labels. Nodes that have a label with this key and identical values are considered to be in the same topology. We consider each <key, value> as a "bucket", and try to put balanced number of pods into each bucket. It's a required field.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecTopologySpreadConstraint#topologyKey
   */
  readonly topologyKey: string;

  /**
   * WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy the spread constraint. - DoNotSchedule (default) tells the scheduler not to schedule it. - ScheduleAnyway tells the scheduler to schedule the pod in any location,   but giving higher precedence to topologies that would help reduce the   skew. A constraint is considered "Unsatisfiable" for an incoming pod if and only if every possible node assignment for that pod would violate "MaxSkew" on some topology. For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same labelSelector spread as 3/1/1: | zone1 | zone2 | zone3 | | P P P |   P   |   P   | If WhenUnsatisfiable is set to DoNotSchedule, incoming pod can only be scheduled to zone2(zone3) to become 3/2/1(3/1/2) as ActualSkew(2-1) on zone2(zone3) satisfies MaxSkew(1). In other words, the cluster can still be imbalanced, but scheduler won't make it *more* imbalanced. It's a required field.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecTopologySpreadConstraint#whenUnsatisfiable
   */
  readonly whenUnsatisfiable: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecTopologySpreadConstraint' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecTopologySpreadConstraint(obj: RunnerReplicaSetSpecTemplateSpecTopologySpreadConstraint | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_RunnerReplicaSetSpecTemplateSpecTopologySpreadConstraintLabelSelector(obj.labelSelector),
    'maxSkew': obj.maxSkew,
    'topologyKey': obj.topologyKey,
    'whenUnsatisfiable': obj.whenUnsatisfiable,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecVolumeMounts
 */
export interface RunnerReplicaSetSpecTemplateSpecVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must not contain ':'.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. This field is beta in 1.10.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.
   *
   * @default false.
   * @schema RunnerReplicaSetSpecTemplateSpecVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema RunnerReplicaSetSpecTemplateSpecVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment. Defaults to "" (volume's root). SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root). SubPathExpr and SubPath are mutually exclusive.
   * @schema RunnerReplicaSetSpecTemplateSpecVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecVolumeMounts(obj: RunnerReplicaSetSpecTemplateSpecVolumeMounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'mountPropagation': obj.mountPropagation,
    'name': obj.name,
    'readOnly': obj.readOnly,
    'subPath': obj.subPath,
    'subPathExpr': obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RunnerReplicaSetSpecTemplateSpecVolumeSizeLimit
 */
export class RunnerReplicaSetSpecTemplateSpecVolumeSizeLimit {
  public static fromNumber(value: number): RunnerReplicaSetSpecTemplateSpecVolumeSizeLimit {
    return new RunnerReplicaSetSpecTemplateSpecVolumeSizeLimit(value);
  }
  public static fromString(value: string): RunnerReplicaSetSpecTemplateSpecVolumeSizeLimit {
    return new RunnerReplicaSetSpecTemplateSpecVolumeSizeLimit(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Volume represents a named volume in a pod that may be accessed by any container in the pod.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecVolumes
 */
export interface RunnerReplicaSetSpecTemplateSpecVolumes {
  /**
   * AWSElasticBlockStore represents an AWS Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumes#awsElasticBlockStore
   */
  readonly awsElasticBlockStore?: RunnerReplicaSetSpecTemplateSpecVolumesAwsElasticBlockStore;

  /**
   * AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumes#azureDisk
   */
  readonly azureDisk?: RunnerReplicaSetSpecTemplateSpecVolumesAzureDisk;

  /**
   * AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumes#azureFile
   */
  readonly azureFile?: RunnerReplicaSetSpecTemplateSpecVolumesAzureFile;

  /**
   * CephFS represents a Ceph FS mount on the host that shares a pod's lifetime
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumes#cephfs
   */
  readonly cephfs?: RunnerReplicaSetSpecTemplateSpecVolumesCephfs;

  /**
   * Cinder represents a cinder volume attached and mounted on kubelets host machine. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumes#cinder
   */
  readonly cinder?: RunnerReplicaSetSpecTemplateSpecVolumesCinder;

  /**
   * ConfigMap represents a configMap that should populate this volume
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumes#configMap
   */
  readonly configMap?: RunnerReplicaSetSpecTemplateSpecVolumesConfigMap;

  /**
   * CSI (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers (Beta feature).
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumes#csi
   */
  readonly csi?: RunnerReplicaSetSpecTemplateSpecVolumesCsi;

  /**
   * DownwardAPI represents downward API about the pod that should populate this volume
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumes#downwardAPI
   */
  readonly downwardApi?: RunnerReplicaSetSpecTemplateSpecVolumesDownwardApi;

  /**
   * EmptyDir represents a temporary directory that shares a pod's lifetime. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumes#emptyDir
   */
  readonly emptyDir?: RunnerReplicaSetSpecTemplateSpecVolumesEmptyDir;

  /**
   * Ephemeral represents a volume that is handled by a cluster storage driver. The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts, and deleted when the pod is removed.
   * Use this if: a) the volume is only needed while the pod runs, b) features of normal volumes like restoring from snapshot or capacity    tracking are needed, c) the storage driver is specified through a storage class, and d) the storage driver supports dynamic volume provisioning through    a PersistentVolumeClaim (see EphemeralVolumeSource for more    information on the connection between this volume type    and PersistentVolumeClaim).
   * Use PersistentVolumeClaim or one of the vendor-specific APIs for volumes that persist for longer than the lifecycle of an individual pod.
   * Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to be used that way - see the documentation of the driver for more information.
   * A pod can use both types of ephemeral volumes and persistent volumes at the same time.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumes#ephemeral
   */
  readonly ephemeral?: RunnerReplicaSetSpecTemplateSpecVolumesEphemeral;

  /**
   * FC represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumes#fc
   */
  readonly fc?: RunnerReplicaSetSpecTemplateSpecVolumesFc;

  /**
   * FlexVolume represents a generic volume resource that is provisioned/attached using an exec based plugin.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumes#flexVolume
   */
  readonly flexVolume?: RunnerReplicaSetSpecTemplateSpecVolumesFlexVolume;

  /**
   * Flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumes#flocker
   */
  readonly flocker?: RunnerReplicaSetSpecTemplateSpecVolumesFlocker;

  /**
   * GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumes#gcePersistentDisk
   */
  readonly gcePersistentDisk?: RunnerReplicaSetSpecTemplateSpecVolumesGcePersistentDisk;

  /**
   * GitRepo represents a git repository at a particular revision. DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir into the Pod's container.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumes#gitRepo
   */
  readonly gitRepo?: RunnerReplicaSetSpecTemplateSpecVolumesGitRepo;

  /**
   * Glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/glusterfs/README.md
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumes#glusterfs
   */
  readonly glusterfs?: RunnerReplicaSetSpecTemplateSpecVolumesGlusterfs;

  /**
   * HostPath represents a pre-existing file or directory on the host machine that is directly exposed to the container. This is generally used for system agents or other privileged things that are allowed to see the host machine. Most containers will NOT need this. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath --- TODO(jonesdl) We need to restrict who can use host directory mounts and who can/can not mount host directories as read/write.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumes#hostPath
   */
  readonly hostPath?: RunnerReplicaSetSpecTemplateSpecVolumesHostPath;

  /**
   * ISCSI represents an ISCSI Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://examples.k8s.io/volumes/iscsi/README.md
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumes#iscsi
   */
  readonly iscsi?: RunnerReplicaSetSpecTemplateSpecVolumesIscsi;

  /**
   * Volume's name. Must be a DNS_LABEL and unique within the pod. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumes#name
   */
  readonly name: string;

  /**
   * NFS represents an NFS mount on the host that shares a pod's lifetime More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumes#nfs
   */
  readonly nfs?: RunnerReplicaSetSpecTemplateSpecVolumesNfs;

  /**
   * PersistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in the same namespace. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumes#persistentVolumeClaim
   */
  readonly persistentVolumeClaim?: RunnerReplicaSetSpecTemplateSpecVolumesPersistentVolumeClaim;

  /**
   * PhotonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumes#photonPersistentDisk
   */
  readonly photonPersistentDisk?: RunnerReplicaSetSpecTemplateSpecVolumesPhotonPersistentDisk;

  /**
   * PortworxVolume represents a portworx volume attached and mounted on kubelets host machine
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumes#portworxVolume
   */
  readonly portworxVolume?: RunnerReplicaSetSpecTemplateSpecVolumesPortworxVolume;

  /**
   * Items for all in one resources secrets, configmaps, and downward API
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumes#projected
   */
  readonly projected?: RunnerReplicaSetSpecTemplateSpecVolumesProjected;

  /**
   * Quobyte represents a Quobyte mount on the host that shares a pod's lifetime
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumes#quobyte
   */
  readonly quobyte?: RunnerReplicaSetSpecTemplateSpecVolumesQuobyte;

  /**
   * RBD represents a Rados Block Device mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/rbd/README.md
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumes#rbd
   */
  readonly rbd?: RunnerReplicaSetSpecTemplateSpecVolumesRbd;

  /**
   * ScaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumes#scaleIO
   */
  readonly scaleIo?: RunnerReplicaSetSpecTemplateSpecVolumesScaleIo;

  /**
   * Secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumes#secret
   */
  readonly secret?: RunnerReplicaSetSpecTemplateSpecVolumesSecret;

  /**
   * StorageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumes#storageos
   */
  readonly storageos?: RunnerReplicaSetSpecTemplateSpecVolumesStorageos;

  /**
   * VsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumes#vsphereVolume
   */
  readonly vsphereVolume?: RunnerReplicaSetSpecTemplateSpecVolumesVsphereVolume;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecVolumes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecVolumes(obj: RunnerReplicaSetSpecTemplateSpecVolumes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'awsElasticBlockStore': toJson_RunnerReplicaSetSpecTemplateSpecVolumesAwsElasticBlockStore(obj.awsElasticBlockStore),
    'azureDisk': toJson_RunnerReplicaSetSpecTemplateSpecVolumesAzureDisk(obj.azureDisk),
    'azureFile': toJson_RunnerReplicaSetSpecTemplateSpecVolumesAzureFile(obj.azureFile),
    'cephfs': toJson_RunnerReplicaSetSpecTemplateSpecVolumesCephfs(obj.cephfs),
    'cinder': toJson_RunnerReplicaSetSpecTemplateSpecVolumesCinder(obj.cinder),
    'configMap': toJson_RunnerReplicaSetSpecTemplateSpecVolumesConfigMap(obj.configMap),
    'csi': toJson_RunnerReplicaSetSpecTemplateSpecVolumesCsi(obj.csi),
    'downwardAPI': toJson_RunnerReplicaSetSpecTemplateSpecVolumesDownwardApi(obj.downwardApi),
    'emptyDir': toJson_RunnerReplicaSetSpecTemplateSpecVolumesEmptyDir(obj.emptyDir),
    'ephemeral': toJson_RunnerReplicaSetSpecTemplateSpecVolumesEphemeral(obj.ephemeral),
    'fc': toJson_RunnerReplicaSetSpecTemplateSpecVolumesFc(obj.fc),
    'flexVolume': toJson_RunnerReplicaSetSpecTemplateSpecVolumesFlexVolume(obj.flexVolume),
    'flocker': toJson_RunnerReplicaSetSpecTemplateSpecVolumesFlocker(obj.flocker),
    'gcePersistentDisk': toJson_RunnerReplicaSetSpecTemplateSpecVolumesGcePersistentDisk(obj.gcePersistentDisk),
    'gitRepo': toJson_RunnerReplicaSetSpecTemplateSpecVolumesGitRepo(obj.gitRepo),
    'glusterfs': toJson_RunnerReplicaSetSpecTemplateSpecVolumesGlusterfs(obj.glusterfs),
    'hostPath': toJson_RunnerReplicaSetSpecTemplateSpecVolumesHostPath(obj.hostPath),
    'iscsi': toJson_RunnerReplicaSetSpecTemplateSpecVolumesIscsi(obj.iscsi),
    'name': obj.name,
    'nfs': toJson_RunnerReplicaSetSpecTemplateSpecVolumesNfs(obj.nfs),
    'persistentVolumeClaim': toJson_RunnerReplicaSetSpecTemplateSpecVolumesPersistentVolumeClaim(obj.persistentVolumeClaim),
    'photonPersistentDisk': toJson_RunnerReplicaSetSpecTemplateSpecVolumesPhotonPersistentDisk(obj.photonPersistentDisk),
    'portworxVolume': toJson_RunnerReplicaSetSpecTemplateSpecVolumesPortworxVolume(obj.portworxVolume),
    'projected': toJson_RunnerReplicaSetSpecTemplateSpecVolumesProjected(obj.projected),
    'quobyte': toJson_RunnerReplicaSetSpecTemplateSpecVolumesQuobyte(obj.quobyte),
    'rbd': toJson_RunnerReplicaSetSpecTemplateSpecVolumesRbd(obj.rbd),
    'scaleIO': toJson_RunnerReplicaSetSpecTemplateSpecVolumesScaleIo(obj.scaleIo),
    'secret': toJson_RunnerReplicaSetSpecTemplateSpecVolumesSecret(obj.secret),
    'storageos': toJson_RunnerReplicaSetSpecTemplateSpecVolumesStorageos(obj.storageos),
    'vsphereVolume': toJson_RunnerReplicaSetSpecTemplateSpecVolumesVsphereVolume(obj.vsphereVolume),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Describes node affinity scheduling rules for the pod.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinity
 */
export interface RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the most preferred.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinity(obj: RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': toJson_RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj.requiredDuringSchedulingIgnoredDuringExecution),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
 *
 * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAffinity
 */
export interface RunnerReplicaSetSpecTemplateSpecAffinityPodAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecAffinityPodAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecAffinityPodAffinity(obj: RunnerReplicaSetSpecTemplateSpecAffinityPodAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
 *
 * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinity
 */
export interface RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinity(obj: RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecContainersEnv
 */
export interface RunnerReplicaSetSpecTemplateSpecContainersEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded using the previously defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
   *
   * @default .
   * @schema RunnerReplicaSetSpecTemplateSpecContainersEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersEnv#valueFrom
   */
  readonly valueFrom?: RunnerReplicaSetSpecTemplateSpecContainersEnvValueFrom;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecContainersEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecContainersEnv(obj: RunnerReplicaSetSpecTemplateSpecContainersEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
    'valueFrom': toJson_RunnerReplicaSetSpecTemplateSpecContainersEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema RunnerReplicaSetSpecTemplateSpecContainersEnvFrom
 */
export interface RunnerReplicaSetSpecTemplateSpecContainersEnvFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersEnvFrom#configMapRef
   */
  readonly configMapRef?: RunnerReplicaSetSpecTemplateSpecContainersEnvFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersEnvFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersEnvFrom#secretRef
   */
  readonly secretRef?: RunnerReplicaSetSpecTemplateSpecContainersEnvFromSecretRef;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecContainersEnvFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecContainersEnvFrom(obj: RunnerReplicaSetSpecTemplateSpecContainersEnvFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapRef': toJson_RunnerReplicaSetSpecTemplateSpecContainersEnvFromConfigMapRef(obj.configMapRef),
    'prefix': obj.prefix,
    'secretRef': toJson_RunnerReplicaSetSpecTemplateSpecContainersEnvFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Actions that the management system should take in response to container lifecycle events. Cannot be updated.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecContainersLifecycle
 */
export interface RunnerReplicaSetSpecTemplateSpecContainersLifecycle {
  /**
   * PostStart is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersLifecycle#postStart
   */
  readonly postStart?: RunnerReplicaSetSpecTemplateSpecContainersLifecyclePostStart;

  /**
   * PreStop is called immediately before a container is terminated due to an API request or management event such as liveness/startup probe failure, preemption, resource contention, etc. The handler is not called if the container crashes or exits. The Pod's termination grace period countdown begins before the PreStop hook is executed. Regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period (unless delayed by finalizers). Other management of the container blocks until the hook completes or until the termination grace period is reached. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersLifecycle#preStop
   */
  readonly preStop?: RunnerReplicaSetSpecTemplateSpecContainersLifecyclePreStop;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecContainersLifecycle' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecContainersLifecycle(obj: RunnerReplicaSetSpecTemplateSpecContainersLifecycle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'postStart': toJson_RunnerReplicaSetSpecTemplateSpecContainersLifecyclePostStart(obj.postStart),
    'preStop': toJson_RunnerReplicaSetSpecTemplateSpecContainersLifecyclePreStop(obj.preStop),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema RunnerReplicaSetSpecTemplateSpecContainersLivenessProbe
 */
export interface RunnerReplicaSetSpecTemplateSpecContainersLivenessProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersLivenessProbe#exec
   */
  readonly exec?: RunnerReplicaSetSpecTemplateSpecContainersLivenessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema RunnerReplicaSetSpecTemplateSpecContainersLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersLivenessProbe#grpc
   */
  readonly grpc?: RunnerReplicaSetSpecTemplateSpecContainersLivenessProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersLivenessProbe#httpGet
   */
  readonly httpGet?: RunnerReplicaSetSpecTemplateSpecContainersLivenessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema RunnerReplicaSetSpecTemplateSpecContainersLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema RunnerReplicaSetSpecTemplateSpecContainersLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersLivenessProbe#tcpSocket
   */
  readonly tcpSocket?: RunnerReplicaSetSpecTemplateSpecContainersLivenessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersLivenessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema RunnerReplicaSetSpecTemplateSpecContainersLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecContainersLivenessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecContainersLivenessProbe(obj: RunnerReplicaSetSpecTemplateSpecContainersLivenessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_RunnerReplicaSetSpecTemplateSpecContainersLivenessProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_RunnerReplicaSetSpecTemplateSpecContainersLivenessProbeGrpc(obj.grpc),
    'httpGet': toJson_RunnerReplicaSetSpecTemplateSpecContainersLivenessProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_RunnerReplicaSetSpecTemplateSpecContainersLivenessProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ContainerPort represents a network port in a single container.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecContainersPorts
 */
export interface RunnerReplicaSetSpecTemplateSpecContainersPorts {
  /**
   * Number of port to expose on the pod's IP address. This must be a valid port number, 0 < x < 65536.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersPorts#containerPort
   */
  readonly containerPort: number;

  /**
   * What host IP to bind the external port to.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersPorts#hostIP
   */
  readonly hostIp?: string;

  /**
   * Number of port to expose on the host. If specified, this must be a valid port number, 0 < x < 65536. If HostNetwork is specified, this must match ContainerPort. Most containers do not need this.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersPorts#hostPort
   */
  readonly hostPort?: number;

  /**
   * If specified, this must be an IANA_SVC_NAME and unique within the pod. Each named port in a pod must have a unique name. Name for the port that can be referred to by services.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersPorts#name
   */
  readonly name?: string;

  /**
   * Protocol for port. Must be UDP, TCP, or SCTP. Defaults to "TCP".
   *
   * @default TCP".
   * @schema RunnerReplicaSetSpecTemplateSpecContainersPorts#protocol
   */
  readonly protocol?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecContainersPorts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecContainersPorts(obj: RunnerReplicaSetSpecTemplateSpecContainersPorts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerPort': obj.containerPort,
    'hostIP': obj.hostIp,
    'hostPort': obj.hostPort,
    'name': obj.name,
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema RunnerReplicaSetSpecTemplateSpecContainersReadinessProbe
 */
export interface RunnerReplicaSetSpecTemplateSpecContainersReadinessProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersReadinessProbe#exec
   */
  readonly exec?: RunnerReplicaSetSpecTemplateSpecContainersReadinessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema RunnerReplicaSetSpecTemplateSpecContainersReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersReadinessProbe#grpc
   */
  readonly grpc?: RunnerReplicaSetSpecTemplateSpecContainersReadinessProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersReadinessProbe#httpGet
   */
  readonly httpGet?: RunnerReplicaSetSpecTemplateSpecContainersReadinessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema RunnerReplicaSetSpecTemplateSpecContainersReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema RunnerReplicaSetSpecTemplateSpecContainersReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersReadinessProbe#tcpSocket
   */
  readonly tcpSocket?: RunnerReplicaSetSpecTemplateSpecContainersReadinessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersReadinessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema RunnerReplicaSetSpecTemplateSpecContainersReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecContainersReadinessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecContainersReadinessProbe(obj: RunnerReplicaSetSpecTemplateSpecContainersReadinessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_RunnerReplicaSetSpecTemplateSpecContainersReadinessProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_RunnerReplicaSetSpecTemplateSpecContainersReadinessProbeGrpc(obj.grpc),
    'httpGet': toJson_RunnerReplicaSetSpecTemplateSpecContainersReadinessProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_RunnerReplicaSetSpecTemplateSpecContainersReadinessProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
 *
 * @schema RunnerReplicaSetSpecTemplateSpecContainersResources
 */
export interface RunnerReplicaSetSpecTemplateSpecContainersResources {
  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersResources#limits
   */
  readonly limits?: { [key: string]: RunnerReplicaSetSpecTemplateSpecContainersResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersResources#requests
   */
  readonly requests?: { [key: string]: RunnerReplicaSetSpecTemplateSpecContainersResourcesRequests };

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecContainersResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecContainersResources(obj: RunnerReplicaSetSpecTemplateSpecContainersResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecurityContext defines the security options the container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
 *
 * @schema RunnerReplicaSetSpecTemplateSpecContainersSecurityContext
 */
export interface RunnerReplicaSetSpecTemplateSpecContainersSecurityContext {
  /**
   * AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process. This bool directly controls if the no_new_privs flag will be set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP_SYS_ADMIN Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
   * @schema RunnerReplicaSetSpecTemplateSpecContainersSecurityContext#capabilities
   */
  readonly capabilities?: RunnerReplicaSetSpecTemplateSpecContainersSecurityContextCapabilities;

  /**
   * Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. Defaults to false. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false. Note that this field cannot be set when spec.os.name is windows.
   * @schema RunnerReplicaSetSpecTemplateSpecContainersSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * procMount denotes the type of proc mount to use for the containers. The default is DefaultProcMount which uses the container runtime defaults for readonly paths and masked paths. This requires the ProcMountType feature flag to be enabled. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * Whether this container has a read-only root filesystem. Default is false. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false. Note that this field cannot be set when spec.os.name is windows.
   * @schema RunnerReplicaSetSpecTemplateSpecContainersSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   * @schema RunnerReplicaSetSpecTemplateSpecContainersSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: RunnerReplicaSetSpecTemplateSpecContainersSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by this container. If seccomp options are provided at both the pod & container level, the container options override the pod options. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersSecurityContext#seccompProfile
   */
  readonly seccompProfile?: RunnerReplicaSetSpecTemplateSpecContainersSecurityContextSeccompProfile;

  /**
   * The Windows specific settings applied to all containers. If unspecified, the options from the PodSecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersSecurityContext#windowsOptions
   */
  readonly windowsOptions?: RunnerReplicaSetSpecTemplateSpecContainersSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecContainersSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecContainersSecurityContext(obj: RunnerReplicaSetSpecTemplateSpecContainersSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowPrivilegeEscalation': obj.allowPrivilegeEscalation,
    'capabilities': toJson_RunnerReplicaSetSpecTemplateSpecContainersSecurityContextCapabilities(obj.capabilities),
    'privileged': obj.privileged,
    'procMount': obj.procMount,
    'readOnlyRootFilesystem': obj.readOnlyRootFilesystem,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_RunnerReplicaSetSpecTemplateSpecContainersSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_RunnerReplicaSetSpecTemplateSpecContainersSecurityContextSeccompProfile(obj.seccompProfile),
    'windowsOptions': toJson_RunnerReplicaSetSpecTemplateSpecContainersSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema RunnerReplicaSetSpecTemplateSpecContainersStartupProbe
 */
export interface RunnerReplicaSetSpecTemplateSpecContainersStartupProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersStartupProbe#exec
   */
  readonly exec?: RunnerReplicaSetSpecTemplateSpecContainersStartupProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema RunnerReplicaSetSpecTemplateSpecContainersStartupProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersStartupProbe#grpc
   */
  readonly grpc?: RunnerReplicaSetSpecTemplateSpecContainersStartupProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersStartupProbe#httpGet
   */
  readonly httpGet?: RunnerReplicaSetSpecTemplateSpecContainersStartupProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersStartupProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema RunnerReplicaSetSpecTemplateSpecContainersStartupProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema RunnerReplicaSetSpecTemplateSpecContainersStartupProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersStartupProbe#tcpSocket
   */
  readonly tcpSocket?: RunnerReplicaSetSpecTemplateSpecContainersStartupProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersStartupProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema RunnerReplicaSetSpecTemplateSpecContainersStartupProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecContainersStartupProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecContainersStartupProbe(obj: RunnerReplicaSetSpecTemplateSpecContainersStartupProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_RunnerReplicaSetSpecTemplateSpecContainersStartupProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_RunnerReplicaSetSpecTemplateSpecContainersStartupProbeGrpc(obj.grpc),
    'httpGet': toJson_RunnerReplicaSetSpecTemplateSpecContainersStartupProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_RunnerReplicaSetSpecTemplateSpecContainersStartupProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * volumeDevice describes a mapping of a raw block device within a container.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecContainersVolumeDevices
 */
export interface RunnerReplicaSetSpecTemplateSpecContainersVolumeDevices {
  /**
   * devicePath is the path inside of the container that the device will be mapped to.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersVolumeDevices#devicePath
   */
  readonly devicePath: string;

  /**
   * name must match the name of a persistentVolumeClaim in the pod
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersVolumeDevices#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecContainersVolumeDevices' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecContainersVolumeDevices(obj: RunnerReplicaSetSpecTemplateSpecContainersVolumeDevices | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'devicePath': obj.devicePath,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecContainersVolumeMounts
 */
export interface RunnerReplicaSetSpecTemplateSpecContainersVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must not contain ':'.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. This field is beta in 1.10.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.
   *
   * @default false.
   * @schema RunnerReplicaSetSpecTemplateSpecContainersVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema RunnerReplicaSetSpecTemplateSpecContainersVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment. Defaults to "" (volume's root). SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root). SubPathExpr and SubPath are mutually exclusive.
   * @schema RunnerReplicaSetSpecTemplateSpecContainersVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecContainersVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecContainersVolumeMounts(obj: RunnerReplicaSetSpecTemplateSpecContainersVolumeMounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'mountPropagation': obj.mountPropagation,
    'name': obj.name,
    'readOnly': obj.readOnly,
    'subPath': obj.subPath,
    'subPathExpr': obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PodDNSConfigOption defines DNS resolver options of a pod.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecDnsConfigOptions
 */
export interface RunnerReplicaSetSpecTemplateSpecDnsConfigOptions {
  /**
   * Required.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecDnsConfigOptions#name
   */
  readonly name?: string;

  /**
   * @schema RunnerReplicaSetSpecTemplateSpecDnsConfigOptions#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecDnsConfigOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecDnsConfigOptions(obj: RunnerReplicaSetSpecTemplateSpecDnsConfigOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecDockerEnvValueFrom
 */
export interface RunnerReplicaSetSpecTemplateSpecDockerEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecDockerEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: RunnerReplicaSetSpecTemplateSpecDockerEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecDockerEnvValueFrom#fieldRef
   */
  readonly fieldRef?: RunnerReplicaSetSpecTemplateSpecDockerEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecDockerEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: RunnerReplicaSetSpecTemplateSpecDockerEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema RunnerReplicaSetSpecTemplateSpecDockerEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: RunnerReplicaSetSpecTemplateSpecDockerEnvValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecDockerEnvValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecDockerEnvValueFrom(obj: RunnerReplicaSetSpecTemplateSpecDockerEnvValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_RunnerReplicaSetSpecTemplateSpecDockerEnvValueFromConfigMapKeyRef(obj.configMapKeyRef),
    'fieldRef': toJson_RunnerReplicaSetSpecTemplateSpecDockerEnvValueFromFieldRef(obj.fieldRef),
    'resourceFieldRef': toJson_RunnerReplicaSetSpecTemplateSpecDockerEnvValueFromResourceFieldRef(obj.resourceFieldRef),
    'secretKeyRef': toJson_RunnerReplicaSetSpecTemplateSpecDockerEnvValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RunnerReplicaSetSpecTemplateSpecDockerdContainerResourcesLimits
 */
export class RunnerReplicaSetSpecTemplateSpecDockerdContainerResourcesLimits {
  public static fromNumber(value: number): RunnerReplicaSetSpecTemplateSpecDockerdContainerResourcesLimits {
    return new RunnerReplicaSetSpecTemplateSpecDockerdContainerResourcesLimits(value);
  }
  public static fromString(value: string): RunnerReplicaSetSpecTemplateSpecDockerdContainerResourcesLimits {
    return new RunnerReplicaSetSpecTemplateSpecDockerdContainerResourcesLimits(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * @schema RunnerReplicaSetSpecTemplateSpecDockerdContainerResourcesRequests
 */
export class RunnerReplicaSetSpecTemplateSpecDockerdContainerResourcesRequests {
  public static fromNumber(value: number): RunnerReplicaSetSpecTemplateSpecDockerdContainerResourcesRequests {
    return new RunnerReplicaSetSpecTemplateSpecDockerdContainerResourcesRequests(value);
  }
  public static fromString(value: string): RunnerReplicaSetSpecTemplateSpecDockerdContainerResourcesRequests {
    return new RunnerReplicaSetSpecTemplateSpecDockerdContainerResourcesRequests(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecEnvValueFrom
 */
export interface RunnerReplicaSetSpecTemplateSpecEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: RunnerReplicaSetSpecTemplateSpecEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEnvValueFrom#fieldRef
   */
  readonly fieldRef?: RunnerReplicaSetSpecTemplateSpecEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: RunnerReplicaSetSpecTemplateSpecEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: RunnerReplicaSetSpecTemplateSpecEnvValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecEnvValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecEnvValueFrom(obj: RunnerReplicaSetSpecTemplateSpecEnvValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_RunnerReplicaSetSpecTemplateSpecEnvValueFromConfigMapKeyRef(obj.configMapKeyRef),
    'fieldRef': toJson_RunnerReplicaSetSpecTemplateSpecEnvValueFromFieldRef(obj.fieldRef),
    'resourceFieldRef': toJson_RunnerReplicaSetSpecTemplateSpecEnvValueFromResourceFieldRef(obj.resourceFieldRef),
    'secretKeyRef': toJson_RunnerReplicaSetSpecTemplateSpecEnvValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema RunnerReplicaSetSpecTemplateSpecEnvFromConfigMapRef
 */
export interface RunnerReplicaSetSpecTemplateSpecEnvFromConfigMapRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEnvFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEnvFromConfigMapRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecEnvFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecEnvFromConfigMapRef(obj: RunnerReplicaSetSpecTemplateSpecEnvFromConfigMapRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Secret to select from
 *
 * @schema RunnerReplicaSetSpecTemplateSpecEnvFromSecretRef
 */
export interface RunnerReplicaSetSpecTemplateSpecEnvFromSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEnvFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEnvFromSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecEnvFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecEnvFromSecretRef(obj: RunnerReplicaSetSpecTemplateSpecEnvFromSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnv
 */
export interface RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded using the previously defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
   *
   * @default .
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnv#valueFrom
   */
  readonly valueFrom?: RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvValueFrom;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnv(obj: RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
    'valueFrom': toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvFrom
 */
export interface RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvFrom#configMapRef
   */
  readonly configMapRef?: RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvFrom#secretRef
   */
  readonly secretRef?: RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvFromSecretRef;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvFrom(obj: RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapRef': toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvFromConfigMapRef(obj.configMapRef),
    'prefix': obj.prefix,
    'secretRef': toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Lifecycle is not allowed for ephemeral containers.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecycle
 */
export interface RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecycle {
  /**
   * PostStart is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecycle#postStart
   */
  readonly postStart?: RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePostStart;

  /**
   * PreStop is called immediately before a container is terminated due to an API request or management event such as liveness/startup probe failure, preemption, resource contention, etc. The handler is not called if the container crashes or exits. The Pod's termination grace period countdown begins before the PreStop hook is executed. Regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period (unless delayed by finalizers). Other management of the container blocks until the hook completes or until the termination grace period is reached. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecycle#preStop
   */
  readonly preStop?: RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePreStop;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecycle' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecycle(obj: RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecycle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'postStart': toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePostStart(obj.postStart),
    'preStop': toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePreStop(obj.preStop),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Probes are not allowed for ephemeral containers.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbe
 */
export interface RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbe#exec
   */
  readonly exec?: RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbe#grpc
   */
  readonly grpc?: RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbe#httpGet
   */
  readonly httpGet?: RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbe#tcpSocket
   */
  readonly tcpSocket?: RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbe(obj: RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbeGrpc(obj.grpc),
    'httpGet': toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ContainerPort represents a network port in a single container.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersPorts
 */
export interface RunnerReplicaSetSpecTemplateSpecEphemeralContainersPorts {
  /**
   * Number of port to expose on the pod's IP address. This must be a valid port number, 0 < x < 65536.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersPorts#containerPort
   */
  readonly containerPort: number;

  /**
   * What host IP to bind the external port to.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersPorts#hostIP
   */
  readonly hostIp?: string;

  /**
   * Number of port to expose on the host. If specified, this must be a valid port number, 0 < x < 65536. If HostNetwork is specified, this must match ContainerPort. Most containers do not need this.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersPorts#hostPort
   */
  readonly hostPort?: number;

  /**
   * If specified, this must be an IANA_SVC_NAME and unique within the pod. Each named port in a pod must have a unique name. Name for the port that can be referred to by services.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersPorts#name
   */
  readonly name?: string;

  /**
   * Protocol for port. Must be UDP, TCP, or SCTP. Defaults to "TCP".
   *
   * @default TCP".
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersPorts#protocol
   */
  readonly protocol?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecEphemeralContainersPorts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersPorts(obj: RunnerReplicaSetSpecTemplateSpecEphemeralContainersPorts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerPort': obj.containerPort,
    'hostIP': obj.hostIp,
    'hostPort': obj.hostPort,
    'name': obj.name,
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Probes are not allowed for ephemeral containers.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbe
 */
export interface RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbe#exec
   */
  readonly exec?: RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbe#grpc
   */
  readonly grpc?: RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbe#httpGet
   */
  readonly httpGet?: RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbe#tcpSocket
   */
  readonly tcpSocket?: RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbe(obj: RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbeGrpc(obj.grpc),
    'httpGet': toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resources are not allowed for ephemeral containers. Ephemeral containers use spare resources already allocated to the pod.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersResources
 */
export interface RunnerReplicaSetSpecTemplateSpecEphemeralContainersResources {
  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersResources#limits
   */
  readonly limits?: { [key: string]: RunnerReplicaSetSpecTemplateSpecEphemeralContainersResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersResources#requests
   */
  readonly requests?: { [key: string]: RunnerReplicaSetSpecTemplateSpecEphemeralContainersResourcesRequests };

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecEphemeralContainersResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersResources(obj: RunnerReplicaSetSpecTemplateSpecEphemeralContainersResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Optional: SecurityContext defines the security options the ephemeral container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersSecurityContext
 */
export interface RunnerReplicaSetSpecTemplateSpecEphemeralContainersSecurityContext {
  /**
   * AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process. This bool directly controls if the no_new_privs flag will be set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP_SYS_ADMIN Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersSecurityContext#capabilities
   */
  readonly capabilities?: RunnerReplicaSetSpecTemplateSpecEphemeralContainersSecurityContextCapabilities;

  /**
   * Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. Defaults to false. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false. Note that this field cannot be set when spec.os.name is windows.
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * procMount denotes the type of proc mount to use for the containers. The default is DefaultProcMount which uses the container runtime defaults for readonly paths and masked paths. This requires the ProcMountType feature flag to be enabled. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * Whether this container has a read-only root filesystem. Default is false. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false. Note that this field cannot be set when spec.os.name is windows.
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: RunnerReplicaSetSpecTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by this container. If seccomp options are provided at both the pod & container level, the container options override the pod options. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersSecurityContext#seccompProfile
   */
  readonly seccompProfile?: RunnerReplicaSetSpecTemplateSpecEphemeralContainersSecurityContextSeccompProfile;

  /**
   * The Windows specific settings applied to all containers. If unspecified, the options from the PodSecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersSecurityContext#windowsOptions
   */
  readonly windowsOptions?: RunnerReplicaSetSpecTemplateSpecEphemeralContainersSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecEphemeralContainersSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersSecurityContext(obj: RunnerReplicaSetSpecTemplateSpecEphemeralContainersSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowPrivilegeEscalation': obj.allowPrivilegeEscalation,
    'capabilities': toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersSecurityContextCapabilities(obj.capabilities),
    'privileged': obj.privileged,
    'procMount': obj.procMount,
    'readOnlyRootFilesystem': obj.readOnlyRootFilesystem,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersSecurityContextSeccompProfile(obj.seccompProfile),
    'windowsOptions': toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Probes are not allowed for ephemeral containers.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbe
 */
export interface RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbe#exec
   */
  readonly exec?: RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbe#grpc
   */
  readonly grpc?: RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbe#httpGet
   */
  readonly httpGet?: RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbe#tcpSocket
   */
  readonly tcpSocket?: RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbe(obj: RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbeGrpc(obj.grpc),
    'httpGet': toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * volumeDevice describes a mapping of a raw block device within a container.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersVolumeDevices
 */
export interface RunnerReplicaSetSpecTemplateSpecEphemeralContainersVolumeDevices {
  /**
   * devicePath is the path inside of the container that the device will be mapped to.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersVolumeDevices#devicePath
   */
  readonly devicePath: string;

  /**
   * name must match the name of a persistentVolumeClaim in the pod
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersVolumeDevices#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecEphemeralContainersVolumeDevices' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersVolumeDevices(obj: RunnerReplicaSetSpecTemplateSpecEphemeralContainersVolumeDevices | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'devicePath': obj.devicePath,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersVolumeMounts
 */
export interface RunnerReplicaSetSpecTemplateSpecEphemeralContainersVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must not contain ':'.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. This field is beta in 1.10.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.
   *
   * @default false.
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment. Defaults to "" (volume's root). SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root). SubPathExpr and SubPath are mutually exclusive.
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecEphemeralContainersVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersVolumeMounts(obj: RunnerReplicaSetSpecTemplateSpecEphemeralContainersVolumeMounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'mountPropagation': obj.mountPropagation,
    'name': obj.name,
    'readOnly': obj.readOnly,
    'subPath': obj.subPath,
    'subPathExpr': obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecInitContainersEnv
 */
export interface RunnerReplicaSetSpecTemplateSpecInitContainersEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded using the previously defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
   *
   * @default .
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersEnv#valueFrom
   */
  readonly valueFrom?: RunnerReplicaSetSpecTemplateSpecInitContainersEnvValueFrom;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecInitContainersEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecInitContainersEnv(obj: RunnerReplicaSetSpecTemplateSpecInitContainersEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
    'valueFrom': toJson_RunnerReplicaSetSpecTemplateSpecInitContainersEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema RunnerReplicaSetSpecTemplateSpecInitContainersEnvFrom
 */
export interface RunnerReplicaSetSpecTemplateSpecInitContainersEnvFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersEnvFrom#configMapRef
   */
  readonly configMapRef?: RunnerReplicaSetSpecTemplateSpecInitContainersEnvFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersEnvFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersEnvFrom#secretRef
   */
  readonly secretRef?: RunnerReplicaSetSpecTemplateSpecInitContainersEnvFromSecretRef;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecInitContainersEnvFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecInitContainersEnvFrom(obj: RunnerReplicaSetSpecTemplateSpecInitContainersEnvFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapRef': toJson_RunnerReplicaSetSpecTemplateSpecInitContainersEnvFromConfigMapRef(obj.configMapRef),
    'prefix': obj.prefix,
    'secretRef': toJson_RunnerReplicaSetSpecTemplateSpecInitContainersEnvFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Actions that the management system should take in response to container lifecycle events. Cannot be updated.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecInitContainersLifecycle
 */
export interface RunnerReplicaSetSpecTemplateSpecInitContainersLifecycle {
  /**
   * PostStart is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersLifecycle#postStart
   */
  readonly postStart?: RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePostStart;

  /**
   * PreStop is called immediately before a container is terminated due to an API request or management event such as liveness/startup probe failure, preemption, resource contention, etc. The handler is not called if the container crashes or exits. The Pod's termination grace period countdown begins before the PreStop hook is executed. Regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period (unless delayed by finalizers). Other management of the container blocks until the hook completes or until the termination grace period is reached. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersLifecycle#preStop
   */
  readonly preStop?: RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePreStop;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecInitContainersLifecycle' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecInitContainersLifecycle(obj: RunnerReplicaSetSpecTemplateSpecInitContainersLifecycle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'postStart': toJson_RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePostStart(obj.postStart),
    'preStop': toJson_RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePreStop(obj.preStop),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbe
 */
export interface RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbe#exec
   */
  readonly exec?: RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbe#grpc
   */
  readonly grpc?: RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbe#httpGet
   */
  readonly httpGet?: RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbe#tcpSocket
   */
  readonly tcpSocket?: RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbe(obj: RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbeGrpc(obj.grpc),
    'httpGet': toJson_RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ContainerPort represents a network port in a single container.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecInitContainersPorts
 */
export interface RunnerReplicaSetSpecTemplateSpecInitContainersPorts {
  /**
   * Number of port to expose on the pod's IP address. This must be a valid port number, 0 < x < 65536.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersPorts#containerPort
   */
  readonly containerPort: number;

  /**
   * What host IP to bind the external port to.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersPorts#hostIP
   */
  readonly hostIp?: string;

  /**
   * Number of port to expose on the host. If specified, this must be a valid port number, 0 < x < 65536. If HostNetwork is specified, this must match ContainerPort. Most containers do not need this.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersPorts#hostPort
   */
  readonly hostPort?: number;

  /**
   * If specified, this must be an IANA_SVC_NAME and unique within the pod. Each named port in a pod must have a unique name. Name for the port that can be referred to by services.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersPorts#name
   */
  readonly name?: string;

  /**
   * Protocol for port. Must be UDP, TCP, or SCTP. Defaults to "TCP".
   *
   * @default TCP".
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersPorts#protocol
   */
  readonly protocol?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecInitContainersPorts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecInitContainersPorts(obj: RunnerReplicaSetSpecTemplateSpecInitContainersPorts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerPort': obj.containerPort,
    'hostIP': obj.hostIp,
    'hostPort': obj.hostPort,
    'name': obj.name,
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbe
 */
export interface RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbe#exec
   */
  readonly exec?: RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbe#grpc
   */
  readonly grpc?: RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbe#httpGet
   */
  readonly httpGet?: RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbe#tcpSocket
   */
  readonly tcpSocket?: RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbe(obj: RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbeGrpc(obj.grpc),
    'httpGet': toJson_RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
 *
 * @schema RunnerReplicaSetSpecTemplateSpecInitContainersResources
 */
export interface RunnerReplicaSetSpecTemplateSpecInitContainersResources {
  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersResources#limits
   */
  readonly limits?: { [key: string]: RunnerReplicaSetSpecTemplateSpecInitContainersResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersResources#requests
   */
  readonly requests?: { [key: string]: RunnerReplicaSetSpecTemplateSpecInitContainersResourcesRequests };

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecInitContainersResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecInitContainersResources(obj: RunnerReplicaSetSpecTemplateSpecInitContainersResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecurityContext defines the security options the container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
 *
 * @schema RunnerReplicaSetSpecTemplateSpecInitContainersSecurityContext
 */
export interface RunnerReplicaSetSpecTemplateSpecInitContainersSecurityContext {
  /**
   * AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process. This bool directly controls if the no_new_privs flag will be set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP_SYS_ADMIN Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersSecurityContext#capabilities
   */
  readonly capabilities?: RunnerReplicaSetSpecTemplateSpecInitContainersSecurityContextCapabilities;

  /**
   * Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. Defaults to false. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false. Note that this field cannot be set when spec.os.name is windows.
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * procMount denotes the type of proc mount to use for the containers. The default is DefaultProcMount which uses the container runtime defaults for readonly paths and masked paths. This requires the ProcMountType feature flag to be enabled. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * Whether this container has a read-only root filesystem. Default is false. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false. Note that this field cannot be set when spec.os.name is windows.
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: RunnerReplicaSetSpecTemplateSpecInitContainersSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by this container. If seccomp options are provided at both the pod & container level, the container options override the pod options. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersSecurityContext#seccompProfile
   */
  readonly seccompProfile?: RunnerReplicaSetSpecTemplateSpecInitContainersSecurityContextSeccompProfile;

  /**
   * The Windows specific settings applied to all containers. If unspecified, the options from the PodSecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersSecurityContext#windowsOptions
   */
  readonly windowsOptions?: RunnerReplicaSetSpecTemplateSpecInitContainersSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecInitContainersSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecInitContainersSecurityContext(obj: RunnerReplicaSetSpecTemplateSpecInitContainersSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowPrivilegeEscalation': obj.allowPrivilegeEscalation,
    'capabilities': toJson_RunnerReplicaSetSpecTemplateSpecInitContainersSecurityContextCapabilities(obj.capabilities),
    'privileged': obj.privileged,
    'procMount': obj.procMount,
    'readOnlyRootFilesystem': obj.readOnlyRootFilesystem,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_RunnerReplicaSetSpecTemplateSpecInitContainersSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_RunnerReplicaSetSpecTemplateSpecInitContainersSecurityContextSeccompProfile(obj.seccompProfile),
    'windowsOptions': toJson_RunnerReplicaSetSpecTemplateSpecInitContainersSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbe
 */
export interface RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbe#exec
   */
  readonly exec?: RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbe#grpc
   */
  readonly grpc?: RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbe#httpGet
   */
  readonly httpGet?: RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbe#tcpSocket
   */
  readonly tcpSocket?: RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbe(obj: RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbeGrpc(obj.grpc),
    'httpGet': toJson_RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * volumeDevice describes a mapping of a raw block device within a container.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecInitContainersVolumeDevices
 */
export interface RunnerReplicaSetSpecTemplateSpecInitContainersVolumeDevices {
  /**
   * devicePath is the path inside of the container that the device will be mapped to.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersVolumeDevices#devicePath
   */
  readonly devicePath: string;

  /**
   * name must match the name of a persistentVolumeClaim in the pod
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersVolumeDevices#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecInitContainersVolumeDevices' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecInitContainersVolumeDevices(obj: RunnerReplicaSetSpecTemplateSpecInitContainersVolumeDevices | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'devicePath': obj.devicePath,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecInitContainersVolumeMounts
 */
export interface RunnerReplicaSetSpecTemplateSpecInitContainersVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must not contain ':'.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. This field is beta in 1.10.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.
   *
   * @default false.
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment. Defaults to "" (volume's root). SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root). SubPathExpr and SubPath are mutually exclusive.
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecInitContainersVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecInitContainersVolumeMounts(obj: RunnerReplicaSetSpecTemplateSpecInitContainersVolumeMounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'mountPropagation': obj.mountPropagation,
    'name': obj.name,
    'readOnly': obj.readOnly,
    'subPath': obj.subPath,
    'subPathExpr': obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RunnerReplicaSetSpecTemplateSpecResourcesLimits
 */
export class RunnerReplicaSetSpecTemplateSpecResourcesLimits {
  public static fromNumber(value: number): RunnerReplicaSetSpecTemplateSpecResourcesLimits {
    return new RunnerReplicaSetSpecTemplateSpecResourcesLimits(value);
  }
  public static fromString(value: string): RunnerReplicaSetSpecTemplateSpecResourcesLimits {
    return new RunnerReplicaSetSpecTemplateSpecResourcesLimits(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * @schema RunnerReplicaSetSpecTemplateSpecResourcesRequests
 */
export class RunnerReplicaSetSpecTemplateSpecResourcesRequests {
  public static fromNumber(value: number): RunnerReplicaSetSpecTemplateSpecResourcesRequests {
    return new RunnerReplicaSetSpecTemplateSpecResourcesRequests(value);
  }
  public static fromString(value: string): RunnerReplicaSetSpecTemplateSpecResourcesRequests {
    return new RunnerReplicaSetSpecTemplateSpecResourcesRequests(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecSecurityContextSeLinuxOptions
 */
export interface RunnerReplicaSetSpecTemplateSpecSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecSecurityContextSeLinuxOptions(obj: RunnerReplicaSetSpecTemplateSpecSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecSecurityContextSeccompProfile
 */
export interface RunnerReplicaSetSpecTemplateSpecSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Must be a descending path, relative to the kubelet's configured seccomp profile location. Must only be set if type is "Localhost".
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied. Valid options are:
   * Localhost - a profile defined in a file on the node should be used. RuntimeDefault - the container runtime default profile should be used. Unconfined - no profile should be applied.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSecurityContextSeccompProfile#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecSecurityContextSeccompProfile(obj: RunnerReplicaSetSpecTemplateSpecSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Sysctl defines a kernel parameter to be set
 *
 * @schema RunnerReplicaSetSpecTemplateSpecSecurityContextSysctls
 */
export interface RunnerReplicaSetSpecTemplateSpecSecurityContextSysctls {
  /**
   * Name of a property to set
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSecurityContextSysctls#name
   */
  readonly name: string;

  /**
   * Value of a property to set
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSecurityContextSysctls#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecSecurityContextSysctls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecSecurityContextSysctls(obj: RunnerReplicaSetSpecTemplateSpecSecurityContextSysctls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Windows specific settings applied to all containers. If unspecified, the options within a container's SecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecSecurityContextWindowsOptions
 */
export interface RunnerReplicaSetSpecTemplateSpecSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container. This field is alpha-level and will only be honored by components that enable the WindowsHostProcessContainers feature flag. Setting this field without the feature flag will result in errors when validating the Pod. All of a Pod's containers must have the same effective HostProcess value (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).  In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process. Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * @schema RunnerReplicaSetSpecTemplateSpecSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecSecurityContextWindowsOptions(obj: RunnerReplicaSetSpecTemplateSpecSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersEnv
 */
export interface RunnerReplicaSetSpecTemplateSpecSidecarContainersEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded using the previously defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
   *
   * @default .
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersEnv#valueFrom
   */
  readonly valueFrom?: RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvValueFrom;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecSidecarContainersEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersEnv(obj: RunnerReplicaSetSpecTemplateSpecSidecarContainersEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
    'valueFrom': toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvFrom
 */
export interface RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvFrom#configMapRef
   */
  readonly configMapRef?: RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvFrom#secretRef
   */
  readonly secretRef?: RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvFromSecretRef;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvFrom(obj: RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapRef': toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvFromConfigMapRef(obj.configMapRef),
    'prefix': obj.prefix,
    'secretRef': toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Actions that the management system should take in response to container lifecycle events. Cannot be updated.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecycle
 */
export interface RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecycle {
  /**
   * PostStart is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecycle#postStart
   */
  readonly postStart?: RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePostStart;

  /**
   * PreStop is called immediately before a container is terminated due to an API request or management event such as liveness/startup probe failure, preemption, resource contention, etc. The handler is not called if the container crashes or exits. The Pod's termination grace period countdown begins before the PreStop hook is executed. Regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period (unless delayed by finalizers). Other management of the container blocks until the hook completes or until the termination grace period is reached. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecycle#preStop
   */
  readonly preStop?: RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePreStop;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecycle' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecycle(obj: RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecycle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'postStart': toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePostStart(obj.postStart),
    'preStop': toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePreStop(obj.preStop),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbe
 */
export interface RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbe#exec
   */
  readonly exec?: RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbe#grpc
   */
  readonly grpc?: RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbe#httpGet
   */
  readonly httpGet?: RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbe#tcpSocket
   */
  readonly tcpSocket?: RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbe(obj: RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbeGrpc(obj.grpc),
    'httpGet': toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ContainerPort represents a network port in a single container.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersPorts
 */
export interface RunnerReplicaSetSpecTemplateSpecSidecarContainersPorts {
  /**
   * Number of port to expose on the pod's IP address. This must be a valid port number, 0 < x < 65536.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersPorts#containerPort
   */
  readonly containerPort: number;

  /**
   * What host IP to bind the external port to.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersPorts#hostIP
   */
  readonly hostIp?: string;

  /**
   * Number of port to expose on the host. If specified, this must be a valid port number, 0 < x < 65536. If HostNetwork is specified, this must match ContainerPort. Most containers do not need this.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersPorts#hostPort
   */
  readonly hostPort?: number;

  /**
   * If specified, this must be an IANA_SVC_NAME and unique within the pod. Each named port in a pod must have a unique name. Name for the port that can be referred to by services.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersPorts#name
   */
  readonly name?: string;

  /**
   * Protocol for port. Must be UDP, TCP, or SCTP. Defaults to "TCP".
   *
   * @default TCP".
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersPorts#protocol
   */
  readonly protocol?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecSidecarContainersPorts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersPorts(obj: RunnerReplicaSetSpecTemplateSpecSidecarContainersPorts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerPort': obj.containerPort,
    'hostIP': obj.hostIp,
    'hostPort': obj.hostPort,
    'name': obj.name,
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbe
 */
export interface RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbe#exec
   */
  readonly exec?: RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbe#grpc
   */
  readonly grpc?: RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbe#httpGet
   */
  readonly httpGet?: RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbe#tcpSocket
   */
  readonly tcpSocket?: RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbe(obj: RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbeGrpc(obj.grpc),
    'httpGet': toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
 *
 * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersResources
 */
export interface RunnerReplicaSetSpecTemplateSpecSidecarContainersResources {
  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersResources#limits
   */
  readonly limits?: { [key: string]: RunnerReplicaSetSpecTemplateSpecSidecarContainersResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersResources#requests
   */
  readonly requests?: { [key: string]: RunnerReplicaSetSpecTemplateSpecSidecarContainersResourcesRequests };

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecSidecarContainersResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersResources(obj: RunnerReplicaSetSpecTemplateSpecSidecarContainersResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecurityContext defines the security options the container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
 *
 * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersSecurityContext
 */
export interface RunnerReplicaSetSpecTemplateSpecSidecarContainersSecurityContext {
  /**
   * AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process. This bool directly controls if the no_new_privs flag will be set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP_SYS_ADMIN Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersSecurityContext#capabilities
   */
  readonly capabilities?: RunnerReplicaSetSpecTemplateSpecSidecarContainersSecurityContextCapabilities;

  /**
   * Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. Defaults to false. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false. Note that this field cannot be set when spec.os.name is windows.
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * procMount denotes the type of proc mount to use for the containers. The default is DefaultProcMount which uses the container runtime defaults for readonly paths and masked paths. This requires the ProcMountType feature flag to be enabled. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * Whether this container has a read-only root filesystem. Default is false. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false. Note that this field cannot be set when spec.os.name is windows.
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: RunnerReplicaSetSpecTemplateSpecSidecarContainersSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by this container. If seccomp options are provided at both the pod & container level, the container options override the pod options. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersSecurityContext#seccompProfile
   */
  readonly seccompProfile?: RunnerReplicaSetSpecTemplateSpecSidecarContainersSecurityContextSeccompProfile;

  /**
   * The Windows specific settings applied to all containers. If unspecified, the options from the PodSecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersSecurityContext#windowsOptions
   */
  readonly windowsOptions?: RunnerReplicaSetSpecTemplateSpecSidecarContainersSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecSidecarContainersSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersSecurityContext(obj: RunnerReplicaSetSpecTemplateSpecSidecarContainersSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowPrivilegeEscalation': obj.allowPrivilegeEscalation,
    'capabilities': toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersSecurityContextCapabilities(obj.capabilities),
    'privileged': obj.privileged,
    'procMount': obj.procMount,
    'readOnlyRootFilesystem': obj.readOnlyRootFilesystem,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersSecurityContextSeccompProfile(obj.seccompProfile),
    'windowsOptions': toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbe
 */
export interface RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbe#exec
   */
  readonly exec?: RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbe#grpc
   */
  readonly grpc?: RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbe#httpGet
   */
  readonly httpGet?: RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbe#tcpSocket
   */
  readonly tcpSocket?: RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbe(obj: RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbeGrpc(obj.grpc),
    'httpGet': toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * volumeDevice describes a mapping of a raw block device within a container.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersVolumeDevices
 */
export interface RunnerReplicaSetSpecTemplateSpecSidecarContainersVolumeDevices {
  /**
   * devicePath is the path inside of the container that the device will be mapped to.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersVolumeDevices#devicePath
   */
  readonly devicePath: string;

  /**
   * name must match the name of a persistentVolumeClaim in the pod
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersVolumeDevices#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecSidecarContainersVolumeDevices' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersVolumeDevices(obj: RunnerReplicaSetSpecTemplateSpecSidecarContainersVolumeDevices | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'devicePath': obj.devicePath,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersVolumeMounts
 */
export interface RunnerReplicaSetSpecTemplateSpecSidecarContainersVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must not contain ':'.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. This field is beta in 1.10.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.
   *
   * @default false.
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment. Defaults to "" (volume's root). SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root). SubPathExpr and SubPath are mutually exclusive.
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecSidecarContainersVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersVolumeMounts(obj: RunnerReplicaSetSpecTemplateSpecSidecarContainersVolumeMounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'mountPropagation': obj.mountPropagation,
    'name': obj.name,
    'readOnly': obj.readOnly,
    'subPath': obj.subPath,
    'subPathExpr': obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LabelSelector is used to find matching pods. Pods that match this label selector are counted to determine the number of pods in their corresponding topology domain.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecTopologySpreadConstraintLabelSelector
 */
export interface RunnerReplicaSetSpecTemplateSpecTopologySpreadConstraintLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecTopologySpreadConstraintLabelSelector#matchExpressions
   */
  readonly matchExpressions?: RunnerReplicaSetSpecTemplateSpecTopologySpreadConstraintLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecTopologySpreadConstraintLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecTopologySpreadConstraintLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecTopologySpreadConstraintLabelSelector(obj: RunnerReplicaSetSpecTemplateSpecTopologySpreadConstraintLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecTopologySpreadConstraintLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AWSElasticBlockStore represents an AWS Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
 *
 * @schema RunnerReplicaSetSpecTemplateSpecVolumesAwsElasticBlockStore
 */
export interface RunnerReplicaSetSpecTemplateSpecVolumesAwsElasticBlockStore {
  /**
   * Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesAwsElasticBlockStore#fsType
   */
  readonly fsType?: string;

  /**
   * The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as "1". Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesAwsElasticBlockStore#partition
   */
  readonly partition?: number;

  /**
   * Specify "true" to force and set the ReadOnly property in VolumeMounts to "true". If omitted, the default is "false". More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesAwsElasticBlockStore#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesAwsElasticBlockStore#volumeID
   */
  readonly volumeId: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecVolumesAwsElasticBlockStore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecVolumesAwsElasticBlockStore(obj: RunnerReplicaSetSpecTemplateSpecVolumesAwsElasticBlockStore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'partition': obj.partition,
    'readOnly': obj.readOnly,
    'volumeID': obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecVolumesAzureDisk
 */
export interface RunnerReplicaSetSpecTemplateSpecVolumesAzureDisk {
  /**
   * Host Caching mode: None, Read Only, Read Write.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesAzureDisk#cachingMode
   */
  readonly cachingMode?: string;

  /**
   * The Name of the data disk in the blob storage
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesAzureDisk#diskName
   */
  readonly diskName: string;

  /**
   * The URI the data disk in the blob storage
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesAzureDisk#diskURI
   */
  readonly diskUri: string;

  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesAzureDisk#fsType
   */
  readonly fsType?: string;

  /**
   * Expected values Shared: multiple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesAzureDisk#kind
   */
  readonly kind?: string;

  /**
   * Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesAzureDisk#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecVolumesAzureDisk' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecVolumesAzureDisk(obj: RunnerReplicaSetSpecTemplateSpecVolumesAzureDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cachingMode': obj.cachingMode,
    'diskName': obj.diskName,
    'diskURI': obj.diskUri,
    'fsType': obj.fsType,
    'kind': obj.kind,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecVolumesAzureFile
 */
export interface RunnerReplicaSetSpecTemplateSpecVolumesAzureFile {
  /**
   * Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesAzureFile#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * the name of secret that contains Azure Storage Account Name and Key
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesAzureFile#secretName
   */
  readonly secretName: string;

  /**
   * Share Name
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesAzureFile#shareName
   */
  readonly shareName: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecVolumesAzureFile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecVolumesAzureFile(obj: RunnerReplicaSetSpecTemplateSpecVolumesAzureFile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'readOnly': obj.readOnly,
    'secretName': obj.secretName,
    'shareName': obj.shareName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CephFS represents a Ceph FS mount on the host that shares a pod's lifetime
 *
 * @schema RunnerReplicaSetSpecTemplateSpecVolumesCephfs
 */
export interface RunnerReplicaSetSpecTemplateSpecVolumesCephfs {
  /**
   * Required: Monitors is a collection of Ceph monitors More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesCephfs#monitors
   */
  readonly monitors: string[];

  /**
   * Optional: Used as the mounted root, rather than the full Ceph tree, default is /
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesCephfs#path
   */
  readonly path?: string;

  /**
   * Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesCephfs#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesCephfs#secretFile
   */
  readonly secretFile?: string;

  /**
   * Optional: SecretRef is reference to the authentication secret for User, default is empty. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesCephfs#secretRef
   */
  readonly secretRef?: RunnerReplicaSetSpecTemplateSpecVolumesCephfsSecretRef;

  /**
   * Optional: User is the rados user name, default is admin More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesCephfs#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecVolumesCephfs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecVolumesCephfs(obj: RunnerReplicaSetSpecTemplateSpecVolumesCephfs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'monitors': obj.monitors?.map(y => y),
    'path': obj.path,
    'readOnly': obj.readOnly,
    'secretFile': obj.secretFile,
    'secretRef': toJson_RunnerReplicaSetSpecTemplateSpecVolumesCephfsSecretRef(obj.secretRef),
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Cinder represents a cinder volume attached and mounted on kubelets host machine. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
 *
 * @schema RunnerReplicaSetSpecTemplateSpecVolumesCinder
 */
export interface RunnerReplicaSetSpecTemplateSpecVolumesCinder {
  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesCinder#fsType
   */
  readonly fsType?: string;

  /**
   * Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesCinder#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Optional: points to a secret object containing parameters used to connect to OpenStack.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesCinder#secretRef
   */
  readonly secretRef?: RunnerReplicaSetSpecTemplateSpecVolumesCinderSecretRef;

  /**
   * volume id used to identify the volume in cinder. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesCinder#volumeID
   */
  readonly volumeId: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecVolumesCinder' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecVolumesCinder(obj: RunnerReplicaSetSpecTemplateSpecVolumesCinder | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'readOnly': obj.readOnly,
    'secretRef': toJson_RunnerReplicaSetSpecTemplateSpecVolumesCinderSecretRef(obj.secretRef),
    'volumeID': obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap represents a configMap that should populate this volume
 *
 * @schema RunnerReplicaSetSpecTemplateSpecVolumesConfigMap
 */
export interface RunnerReplicaSetSpecTemplateSpecVolumesConfigMap {
  /**
   * Optional: mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesConfigMap#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesConfigMap#items
   */
  readonly items?: RunnerReplicaSetSpecTemplateSpecVolumesConfigMapItems[];

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its keys must be defined
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecVolumesConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecVolumesConfigMap(obj: RunnerReplicaSetSpecTemplateSpecVolumesConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecVolumesConfigMapItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CSI (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers (Beta feature).
 *
 * @schema RunnerReplicaSetSpecTemplateSpecVolumesCsi
 */
export interface RunnerReplicaSetSpecTemplateSpecVolumesCsi {
  /**
   * Driver is the name of the CSI driver that handles this volume. Consult with your admin for the correct name as registered in the cluster.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesCsi#driver
   */
  readonly driver: string;

  /**
   * Filesystem type to mount. Ex. "ext4", "xfs", "ntfs". If not provided, the empty value is passed to the associated CSI driver which will determine the default filesystem to apply.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesCsi#fsType
   */
  readonly fsType?: string;

  /**
   * NodePublishSecretRef is a reference to the secret object containing sensitive information to pass to the CSI driver to complete the CSI NodePublishVolume and NodeUnpublishVolume calls. This field is optional, and  may be empty if no secret is required. If the secret object contains more than one secret, all secret references are passed.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesCsi#nodePublishSecretRef
   */
  readonly nodePublishSecretRef?: RunnerReplicaSetSpecTemplateSpecVolumesCsiNodePublishSecretRef;

  /**
   * Specifies a read-only configuration for the volume. Defaults to false (read/write).
   *
   * @default false (read/write).
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesCsi#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * VolumeAttributes stores driver-specific properties that are passed to the CSI driver. Consult your driver's documentation for supported values.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesCsi#volumeAttributes
   */
  readonly volumeAttributes?: { [key: string]: string };

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecVolumesCsi' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecVolumesCsi(obj: RunnerReplicaSetSpecTemplateSpecVolumesCsi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'driver': obj.driver,
    'fsType': obj.fsType,
    'nodePublishSecretRef': toJson_RunnerReplicaSetSpecTemplateSpecVolumesCsiNodePublishSecretRef(obj.nodePublishSecretRef),
    'readOnly': obj.readOnly,
    'volumeAttributes': ((obj.volumeAttributes) === undefined) ? undefined : (Object.entries(obj.volumeAttributes).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DownwardAPI represents downward API about the pod that should populate this volume
 *
 * @schema RunnerReplicaSetSpecTemplateSpecVolumesDownwardApi
 */
export interface RunnerReplicaSetSpecTemplateSpecVolumesDownwardApi {
  /**
   * Optional: mode bits to use on created files by default. Must be a Optional: mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesDownwardApi#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * Items is a list of downward API volume file
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesDownwardApi#items
   */
  readonly items?: RunnerReplicaSetSpecTemplateSpecVolumesDownwardApiItems[];

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecVolumesDownwardApi' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecVolumesDownwardApi(obj: RunnerReplicaSetSpecTemplateSpecVolumesDownwardApi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecVolumesDownwardApiItems(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EmptyDir represents a temporary directory that shares a pod's lifetime. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
 *
 * @schema RunnerReplicaSetSpecTemplateSpecVolumesEmptyDir
 */
export interface RunnerReplicaSetSpecTemplateSpecVolumesEmptyDir {
  /**
   * What type of storage medium should back this directory. The default is "" which means to use the node's default medium. Must be an empty string (default) or Memory. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesEmptyDir#medium
   */
  readonly medium?: string;

  /**
   * Total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. The default is nil which means that the limit is undefined. More info: http://kubernetes.io/docs/user-guide/volumes#emptydir
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesEmptyDir#sizeLimit
   */
  readonly sizeLimit?: RunnerReplicaSetSpecTemplateSpecVolumesEmptyDirSizeLimit;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecVolumesEmptyDir' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecVolumesEmptyDir(obj: RunnerReplicaSetSpecTemplateSpecVolumesEmptyDir | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'medium': obj.medium,
    'sizeLimit': obj.sizeLimit?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Ephemeral represents a volume that is handled by a cluster storage driver. The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts, and deleted when the pod is removed.
 * Use this if: a) the volume is only needed while the pod runs, b) features of normal volumes like restoring from snapshot or capacity    tracking are needed, c) the storage driver is specified through a storage class, and d) the storage driver supports dynamic volume provisioning through    a PersistentVolumeClaim (see EphemeralVolumeSource for more    information on the connection between this volume type    and PersistentVolumeClaim).
 * Use PersistentVolumeClaim or one of the vendor-specific APIs for volumes that persist for longer than the lifecycle of an individual pod.
 * Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to be used that way - see the documentation of the driver for more information.
 * A pod can use both types of ephemeral volumes and persistent volumes at the same time.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecVolumesEphemeral
 */
export interface RunnerReplicaSetSpecTemplateSpecVolumesEphemeral {
  /**
   * Will be used to create a stand-alone PVC to provision the volume. The pod in which this EphemeralVolumeSource is embedded will be the owner of the PVC, i.e. the PVC will be deleted together with the pod.  The name of the PVC will be `<pod name>-<volume name>` where `<volume name>` is the name from the `PodSpec.Volumes` array entry. Pod validation will reject the pod if the concatenated name is not valid for a PVC (for example, too long).
   * An existing PVC with that name that is not owned by the pod will *not* be used for the pod to avoid using an unrelated volume by mistake. Starting the pod is then blocked until the unrelated PVC is removed. If such a pre-created PVC is meant to be used by the pod, the PVC has to updated with an owner reference to the pod once the pod exists. Normally this should not be necessary, but it may be useful when manually reconstructing a broken cluster.
   * This field is read-only and no changes will be made by Kubernetes to the PVC after it has been created.
   * Required, must not be nil.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesEphemeral#volumeClaimTemplate
   */
  readonly volumeClaimTemplate?: RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplate;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecVolumesEphemeral' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecVolumesEphemeral(obj: RunnerReplicaSetSpecTemplateSpecVolumesEphemeral | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'volumeClaimTemplate': toJson_RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplate(obj.volumeClaimTemplate),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FC represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecVolumesFc
 */
export interface RunnerReplicaSetSpecTemplateSpecVolumesFc {
  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesFc#fsType
   */
  readonly fsType?: string;

  /**
   * Optional: FC target lun number
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesFc#lun
   */
  readonly lun?: number;

  /**
   * Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesFc#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Optional: FC target worldwide names (WWNs)
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesFc#targetWWNs
   */
  readonly targetWwNs?: string[];

  /**
   * Optional: FC volume world wide identifiers (wwids) Either wwids or combination of targetWWNs and lun must be set, but not both simultaneously.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesFc#wwids
   */
  readonly wwids?: string[];

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecVolumesFc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecVolumesFc(obj: RunnerReplicaSetSpecTemplateSpecVolumesFc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'lun': obj.lun,
    'readOnly': obj.readOnly,
    'targetWWNs': obj.targetWwNs?.map(y => y),
    'wwids': obj.wwids?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FlexVolume represents a generic volume resource that is provisioned/attached using an exec based plugin.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecVolumesFlexVolume
 */
export interface RunnerReplicaSetSpecTemplateSpecVolumesFlexVolume {
  /**
   * Driver is the name of the driver to use for this volume.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesFlexVolume#driver
   */
  readonly driver: string;

  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesFlexVolume#fsType
   */
  readonly fsType?: string;

  /**
   * Optional: Extra command options if any.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesFlexVolume#options
   */
  readonly options?: { [key: string]: string };

  /**
   * Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesFlexVolume#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Optional: SecretRef is reference to the secret object containing sensitive information to pass to the plugin scripts. This may be empty if no secret object is specified. If the secret object contains more than one secret, all secrets are passed to the plugin scripts.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesFlexVolume#secretRef
   */
  readonly secretRef?: RunnerReplicaSetSpecTemplateSpecVolumesFlexVolumeSecretRef;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecVolumesFlexVolume' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecVolumesFlexVolume(obj: RunnerReplicaSetSpecTemplateSpecVolumesFlexVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'driver': obj.driver,
    'fsType': obj.fsType,
    'options': ((obj.options) === undefined) ? undefined : (Object.entries(obj.options).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'readOnly': obj.readOnly,
    'secretRef': toJson_RunnerReplicaSetSpecTemplateSpecVolumesFlexVolumeSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running
 *
 * @schema RunnerReplicaSetSpecTemplateSpecVolumesFlocker
 */
export interface RunnerReplicaSetSpecTemplateSpecVolumesFlocker {
  /**
   * Name of the dataset stored as metadata -> name on the dataset for Flocker should be considered as deprecated
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesFlocker#datasetName
   */
  readonly datasetName?: string;

  /**
   * UUID of the dataset. This is unique identifier of a Flocker dataset
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesFlocker#datasetUUID
   */
  readonly datasetUuid?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecVolumesFlocker' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecVolumesFlocker(obj: RunnerReplicaSetSpecTemplateSpecVolumesFlocker | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'datasetName': obj.datasetName,
    'datasetUUID': obj.datasetUuid,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
 *
 * @schema RunnerReplicaSetSpecTemplateSpecVolumesGcePersistentDisk
 */
export interface RunnerReplicaSetSpecTemplateSpecVolumesGcePersistentDisk {
  /**
   * Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesGcePersistentDisk#fsType
   */
  readonly fsType?: string;

  /**
   * The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as "1". Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty). More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesGcePersistentDisk#partition
   */
  readonly partition?: number;

  /**
   * Unique name of the PD resource in GCE. Used to identify the disk in GCE. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesGcePersistentDisk#pdName
   */
  readonly pdName: string;

  /**
   * ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @default false. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesGcePersistentDisk#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecVolumesGcePersistentDisk' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecVolumesGcePersistentDisk(obj: RunnerReplicaSetSpecTemplateSpecVolumesGcePersistentDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'partition': obj.partition,
    'pdName': obj.pdName,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GitRepo represents a git repository at a particular revision. DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir into the Pod's container.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecVolumesGitRepo
 */
export interface RunnerReplicaSetSpecTemplateSpecVolumesGitRepo {
  /**
   * Target directory name. Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the git repository.  Otherwise, if specified, the volume will contain the git repository in the subdirectory with the given name.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesGitRepo#directory
   */
  readonly directory?: string;

  /**
   * Repository URL
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesGitRepo#repository
   */
  readonly repository: string;

  /**
   * Commit hash for the specified revision.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesGitRepo#revision
   */
  readonly revision?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecVolumesGitRepo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecVolumesGitRepo(obj: RunnerReplicaSetSpecTemplateSpecVolumesGitRepo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'directory': obj.directory,
    'repository': obj.repository,
    'revision': obj.revision,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/glusterfs/README.md
 *
 * @schema RunnerReplicaSetSpecTemplateSpecVolumesGlusterfs
 */
export interface RunnerReplicaSetSpecTemplateSpecVolumesGlusterfs {
  /**
   * EndpointsName is the endpoint name that details Glusterfs topology. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesGlusterfs#endpoints
   */
  readonly endpoints: string;

  /**
   * Path is the Glusterfs volume path. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesGlusterfs#path
   */
  readonly path: string;

  /**
   * ReadOnly here will force the Glusterfs volume to be mounted with read-only permissions. Defaults to false. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @default false. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesGlusterfs#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecVolumesGlusterfs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecVolumesGlusterfs(obj: RunnerReplicaSetSpecTemplateSpecVolumesGlusterfs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'endpoints': obj.endpoints,
    'path': obj.path,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HostPath represents a pre-existing file or directory on the host machine that is directly exposed to the container. This is generally used for system agents or other privileged things that are allowed to see the host machine. Most containers will NOT need this. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath --- TODO(jonesdl) We need to restrict who can use host directory mounts and who can/can not mount host directories as read/write.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecVolumesHostPath
 */
export interface RunnerReplicaSetSpecTemplateSpecVolumesHostPath {
  /**
   * Path of the directory on the host. If the path is a symlink, it will follow the link to the real path. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesHostPath#path
   */
  readonly path: string;

  /**
   * Type for HostPath Volume Defaults to "" More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @default More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesHostPath#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecVolumesHostPath' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecVolumesHostPath(obj: RunnerReplicaSetSpecTemplateSpecVolumesHostPath | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ISCSI represents an ISCSI Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://examples.k8s.io/volumes/iscsi/README.md
 *
 * @schema RunnerReplicaSetSpecTemplateSpecVolumesIscsi
 */
export interface RunnerReplicaSetSpecTemplateSpecVolumesIscsi {
  /**
   * whether support iSCSI Discovery CHAP authentication
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesIscsi#chapAuthDiscovery
   */
  readonly chapAuthDiscovery?: boolean;

  /**
   * whether support iSCSI Session CHAP authentication
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesIscsi#chapAuthSession
   */
  readonly chapAuthSession?: boolean;

  /**
   * Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesIscsi#fsType
   */
  readonly fsType?: string;

  /**
   * Custom iSCSI Initiator Name. If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface <target portal>:<volume name> will be created for the connection.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesIscsi#initiatorName
   */
  readonly initiatorName?: string;

  /**
   * Target iSCSI Qualified Name.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesIscsi#iqn
   */
  readonly iqn: string;

  /**
   * iSCSI Interface Name that uses an iSCSI transport. Defaults to 'default' (tcp).
   *
   * @default default' (tcp).
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesIscsi#iscsiInterface
   */
  readonly iscsiInterface?: string;

  /**
   * iSCSI Target Lun number.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesIscsi#lun
   */
  readonly lun: number;

  /**
   * iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port is other than default (typically TCP ports 860 and 3260).
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesIscsi#portals
   */
  readonly portals?: string[];

  /**
   * ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false.
   *
   * @default false.
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesIscsi#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * CHAP Secret for iSCSI target and initiator authentication
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesIscsi#secretRef
   */
  readonly secretRef?: RunnerReplicaSetSpecTemplateSpecVolumesIscsiSecretRef;

  /**
   * iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port is other than default (typically TCP ports 860 and 3260).
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesIscsi#targetPortal
   */
  readonly targetPortal: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecVolumesIscsi' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecVolumesIscsi(obj: RunnerReplicaSetSpecTemplateSpecVolumesIscsi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'chapAuthDiscovery': obj.chapAuthDiscovery,
    'chapAuthSession': obj.chapAuthSession,
    'fsType': obj.fsType,
    'initiatorName': obj.initiatorName,
    'iqn': obj.iqn,
    'iscsiInterface': obj.iscsiInterface,
    'lun': obj.lun,
    'portals': obj.portals?.map(y => y),
    'readOnly': obj.readOnly,
    'secretRef': toJson_RunnerReplicaSetSpecTemplateSpecVolumesIscsiSecretRef(obj.secretRef),
    'targetPortal': obj.targetPortal,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NFS represents an NFS mount on the host that shares a pod's lifetime More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
 *
 * @schema RunnerReplicaSetSpecTemplateSpecVolumesNfs
 */
export interface RunnerReplicaSetSpecTemplateSpecVolumesNfs {
  /**
   * Path that is exported by the NFS server. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesNfs#path
   */
  readonly path: string;

  /**
   * ReadOnly here will force the NFS export to be mounted with read-only permissions. Defaults to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @default false. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesNfs#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Server is the hostname or IP address of the NFS server. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesNfs#server
   */
  readonly server: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecVolumesNfs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecVolumesNfs(obj: RunnerReplicaSetSpecTemplateSpecVolumesNfs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'readOnly': obj.readOnly,
    'server': obj.server,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PersistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in the same namespace. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
 *
 * @schema RunnerReplicaSetSpecTemplateSpecVolumesPersistentVolumeClaim
 */
export interface RunnerReplicaSetSpecTemplateSpecVolumesPersistentVolumeClaim {
  /**
   * ClaimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesPersistentVolumeClaim#claimName
   */
  readonly claimName: string;

  /**
   * Will force the ReadOnly setting in VolumeMounts. Default false.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesPersistentVolumeClaim#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecVolumesPersistentVolumeClaim' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecVolumesPersistentVolumeClaim(obj: RunnerReplicaSetSpecTemplateSpecVolumesPersistentVolumeClaim | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claimName': obj.claimName,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PhotonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
 *
 * @schema RunnerReplicaSetSpecTemplateSpecVolumesPhotonPersistentDisk
 */
export interface RunnerReplicaSetSpecTemplateSpecVolumesPhotonPersistentDisk {
  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesPhotonPersistentDisk#fsType
   */
  readonly fsType?: string;

  /**
   * ID that identifies Photon Controller persistent disk
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesPhotonPersistentDisk#pdID
   */
  readonly pdId: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecVolumesPhotonPersistentDisk' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecVolumesPhotonPersistentDisk(obj: RunnerReplicaSetSpecTemplateSpecVolumesPhotonPersistentDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'pdID': obj.pdId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PortworxVolume represents a portworx volume attached and mounted on kubelets host machine
 *
 * @schema RunnerReplicaSetSpecTemplateSpecVolumesPortworxVolume
 */
export interface RunnerReplicaSetSpecTemplateSpecVolumesPortworxVolume {
  /**
   * FSType represents the filesystem type to mount Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesPortworxVolume#fsType
   */
  readonly fsType?: string;

  /**
   * Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesPortworxVolume#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * VolumeID uniquely identifies a Portworx volume
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesPortworxVolume#volumeID
   */
  readonly volumeId: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecVolumesPortworxVolume' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecVolumesPortworxVolume(obj: RunnerReplicaSetSpecTemplateSpecVolumesPortworxVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'readOnly': obj.readOnly,
    'volumeID': obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Items for all in one resources secrets, configmaps, and downward API
 *
 * @schema RunnerReplicaSetSpecTemplateSpecVolumesProjected
 */
export interface RunnerReplicaSetSpecTemplateSpecVolumesProjected {
  /**
   * Mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesProjected#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * list of volume projections
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesProjected#sources
   */
  readonly sources?: RunnerReplicaSetSpecTemplateSpecVolumesProjectedSources[];

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecVolumesProjected' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecVolumesProjected(obj: RunnerReplicaSetSpecTemplateSpecVolumesProjected | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'sources': obj.sources?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecVolumesProjectedSources(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Quobyte represents a Quobyte mount on the host that shares a pod's lifetime
 *
 * @schema RunnerReplicaSetSpecTemplateSpecVolumesQuobyte
 */
export interface RunnerReplicaSetSpecTemplateSpecVolumesQuobyte {
  /**
   * Group to map volume access to Default is no group
   *
   * @default no group
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesQuobyte#group
   */
  readonly group?: string;

  /**
   * ReadOnly here will force the Quobyte volume to be mounted with read-only permissions. Defaults to false.
   *
   * @default false.
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesQuobyte#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Registry represents a single or multiple Quobyte Registry services specified as a string as host:port pair (multiple entries are separated with commas) which acts as the central registry for volumes
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesQuobyte#registry
   */
  readonly registry: string;

  /**
   * Tenant owning the given Quobyte volume in the Backend Used with dynamically provisioned Quobyte volumes, value is set by the plugin
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesQuobyte#tenant
   */
  readonly tenant?: string;

  /**
   * User to map volume access to Defaults to serivceaccount user
   *
   * @default serivceaccount user
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesQuobyte#user
   */
  readonly user?: string;

  /**
   * Volume is a string that references an already created Quobyte volume by name.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesQuobyte#volume
   */
  readonly volume: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecVolumesQuobyte' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecVolumesQuobyte(obj: RunnerReplicaSetSpecTemplateSpecVolumesQuobyte | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'readOnly': obj.readOnly,
    'registry': obj.registry,
    'tenant': obj.tenant,
    'user': obj.user,
    'volume': obj.volume,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RBD represents a Rados Block Device mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/rbd/README.md
 *
 * @schema RunnerReplicaSetSpecTemplateSpecVolumesRbd
 */
export interface RunnerReplicaSetSpecTemplateSpecVolumesRbd {
  /**
   * Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesRbd#fsType
   */
  readonly fsType?: string;

  /**
   * The rados image name. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesRbd#image
   */
  readonly image: string;

  /**
   * Keyring is the path to key ring for RBDUser. Default is /etc/ceph/keyring. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default etc/ceph/keyring. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesRbd#keyring
   */
  readonly keyring?: string;

  /**
   * A collection of Ceph monitors. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesRbd#monitors
   */
  readonly monitors: string[];

  /**
   * The rados pool name. Default is rbd. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default rbd. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesRbd#pool
   */
  readonly pool?: string;

  /**
   * ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default false. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesRbd#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * SecretRef is name of the authentication secret for RBDUser. If provided overrides keyring. Default is nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesRbd#secretRef
   */
  readonly secretRef?: RunnerReplicaSetSpecTemplateSpecVolumesRbdSecretRef;

  /**
   * The rados user name. Default is admin. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default admin. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesRbd#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecVolumesRbd' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecVolumesRbd(obj: RunnerReplicaSetSpecTemplateSpecVolumesRbd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'image': obj.image,
    'keyring': obj.keyring,
    'monitors': obj.monitors?.map(y => y),
    'pool': obj.pool,
    'readOnly': obj.readOnly,
    'secretRef': toJson_RunnerReplicaSetSpecTemplateSpecVolumesRbdSecretRef(obj.secretRef),
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ScaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecVolumesScaleIo
 */
export interface RunnerReplicaSetSpecTemplateSpecVolumesScaleIo {
  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Default is "xfs".
   *
   * @default xfs".
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesScaleIo#fsType
   */
  readonly fsType?: string;

  /**
   * The host address of the ScaleIO API Gateway.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesScaleIo#gateway
   */
  readonly gateway: string;

  /**
   * The name of the ScaleIO Protection Domain for the configured storage.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesScaleIo#protectionDomain
   */
  readonly protectionDomain?: string;

  /**
   * Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesScaleIo#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * SecretRef references to the secret for ScaleIO user and other sensitive information. If this is not provided, Login operation will fail.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesScaleIo#secretRef
   */
  readonly secretRef: RunnerReplicaSetSpecTemplateSpecVolumesScaleIoSecretRef;

  /**
   * Flag to enable/disable SSL communication with Gateway, default false
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesScaleIo#sslEnabled
   */
  readonly sslEnabled?: boolean;

  /**
   * Indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned. Default is ThinProvisioned.
   *
   * @default ThinProvisioned.
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesScaleIo#storageMode
   */
  readonly storageMode?: string;

  /**
   * The ScaleIO Storage Pool associated with the protection domain.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesScaleIo#storagePool
   */
  readonly storagePool?: string;

  /**
   * The name of the storage system as configured in ScaleIO.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesScaleIo#system
   */
  readonly system: string;

  /**
   * The name of a volume already created in the ScaleIO system that is associated with this volume source.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesScaleIo#volumeName
   */
  readonly volumeName?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecVolumesScaleIo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecVolumesScaleIo(obj: RunnerReplicaSetSpecTemplateSpecVolumesScaleIo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'gateway': obj.gateway,
    'protectionDomain': obj.protectionDomain,
    'readOnly': obj.readOnly,
    'secretRef': toJson_RunnerReplicaSetSpecTemplateSpecVolumesScaleIoSecretRef(obj.secretRef),
    'sslEnabled': obj.sslEnabled,
    'storageMode': obj.storageMode,
    'storagePool': obj.storagePool,
    'system': obj.system,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
 *
 * @schema RunnerReplicaSetSpecTemplateSpecVolumesSecret
 */
export interface RunnerReplicaSetSpecTemplateSpecVolumesSecret {
  /**
   * Optional: mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesSecret#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesSecret#items
   */
  readonly items?: RunnerReplicaSetSpecTemplateSpecVolumesSecretItems[];

  /**
   * Specify whether the Secret or its keys must be defined
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesSecret#optional
   */
  readonly optional?: boolean;

  /**
   * Name of the secret in the pod's namespace to use. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesSecret#secretName
   */
  readonly secretName?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecVolumesSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecVolumesSecret(obj: RunnerReplicaSetSpecTemplateSpecVolumesSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecVolumesSecretItems(y)),
    'optional': obj.optional,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * StorageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecVolumesStorageos
 */
export interface RunnerReplicaSetSpecTemplateSpecVolumesStorageos {
  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesStorageos#fsType
   */
  readonly fsType?: string;

  /**
   * Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesStorageos#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * SecretRef specifies the secret to use for obtaining the StorageOS API credentials.  If not specified, default values will be attempted.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesStorageos#secretRef
   */
  readonly secretRef?: RunnerReplicaSetSpecTemplateSpecVolumesStorageosSecretRef;

  /**
   * VolumeName is the human-readable name of the StorageOS volume.  Volume names are only unique within a namespace.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesStorageos#volumeName
   */
  readonly volumeName?: string;

  /**
   * VolumeNamespace specifies the scope of the volume within StorageOS.  If no namespace is specified then the Pod's namespace will be used.  This allows the Kubernetes name scoping to be mirrored within StorageOS for tighter integration. Set VolumeName to any name to override the default behaviour. Set to "default" if you are not using namespaces within StorageOS. Namespaces that do not pre-exist within StorageOS will be created.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesStorageos#volumeNamespace
   */
  readonly volumeNamespace?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecVolumesStorageos' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecVolumesStorageos(obj: RunnerReplicaSetSpecTemplateSpecVolumesStorageos | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'readOnly': obj.readOnly,
    'secretRef': toJson_RunnerReplicaSetSpecTemplateSpecVolumesStorageosSecretRef(obj.secretRef),
    'volumeName': obj.volumeName,
    'volumeNamespace': obj.volumeNamespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
 *
 * @schema RunnerReplicaSetSpecTemplateSpecVolumesVsphereVolume
 */
export interface RunnerReplicaSetSpecTemplateSpecVolumesVsphereVolume {
  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesVsphereVolume#fsType
   */
  readonly fsType?: string;

  /**
   * Storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesVsphereVolume#storagePolicyID
   */
  readonly storagePolicyId?: string;

  /**
   * Storage Policy Based Management (SPBM) profile name.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesVsphereVolume#storagePolicyName
   */
  readonly storagePolicyName?: string;

  /**
   * Path that identifies vSphere volume vmdk
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesVsphereVolume#volumePath
   */
  readonly volumePath: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecVolumesVsphereVolume' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecVolumesVsphereVolume(obj: RunnerReplicaSetSpecTemplateSpecVolumesVsphereVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'storagePolicyID': obj.storagePolicyId,
    'storagePolicyName': obj.storagePolicyName,
    'volumePath': obj.volumePath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * An empty preferred scheduling term matches all objects with implicit weight 0 (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
 *
 * @schema RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * A node selector term, associated with the corresponding weight.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference: RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preference': toJson_RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj.preference),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A list of node selector terms. The terms are ORed.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms: RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeSelectorTerms': obj.nodeSelectorTerms?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm: RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podAffinityTerm': toJson_RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running
 *
 * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces. This field is beta-level and is only honored when PodAffinityNamespaceSelector feature is enabled.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means "this pod's namespace"
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm: RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podAffinityTerm': toJson_RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running
 *
 * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces. This field is beta-level and is only honored when PodAffinityNamespaceSelector feature is enabled.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means "this pod's namespace"
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecContainersEnvValueFrom
 */
export interface RunnerReplicaSetSpecTemplateSpecContainersEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: RunnerReplicaSetSpecTemplateSpecContainersEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersEnvValueFrom#fieldRef
   */
  readonly fieldRef?: RunnerReplicaSetSpecTemplateSpecContainersEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: RunnerReplicaSetSpecTemplateSpecContainersEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: RunnerReplicaSetSpecTemplateSpecContainersEnvValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecContainersEnvValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecContainersEnvValueFrom(obj: RunnerReplicaSetSpecTemplateSpecContainersEnvValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_RunnerReplicaSetSpecTemplateSpecContainersEnvValueFromConfigMapKeyRef(obj.configMapKeyRef),
    'fieldRef': toJson_RunnerReplicaSetSpecTemplateSpecContainersEnvValueFromFieldRef(obj.fieldRef),
    'resourceFieldRef': toJson_RunnerReplicaSetSpecTemplateSpecContainersEnvValueFromResourceFieldRef(obj.resourceFieldRef),
    'secretKeyRef': toJson_RunnerReplicaSetSpecTemplateSpecContainersEnvValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema RunnerReplicaSetSpecTemplateSpecContainersEnvFromConfigMapRef
 */
export interface RunnerReplicaSetSpecTemplateSpecContainersEnvFromConfigMapRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersEnvFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersEnvFromConfigMapRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecContainersEnvFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecContainersEnvFromConfigMapRef(obj: RunnerReplicaSetSpecTemplateSpecContainersEnvFromConfigMapRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Secret to select from
 *
 * @schema RunnerReplicaSetSpecTemplateSpecContainersEnvFromSecretRef
 */
export interface RunnerReplicaSetSpecTemplateSpecContainersEnvFromSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersEnvFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersEnvFromSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecContainersEnvFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecContainersEnvFromSecretRef(obj: RunnerReplicaSetSpecTemplateSpecContainersEnvFromSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PostStart is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema RunnerReplicaSetSpecTemplateSpecContainersLifecyclePostStart
 */
export interface RunnerReplicaSetSpecTemplateSpecContainersLifecyclePostStart {
  /**
   * Exec specifies the action to take.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersLifecyclePostStart#exec
   */
  readonly exec?: RunnerReplicaSetSpecTemplateSpecContainersLifecyclePostStartExec;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersLifecyclePostStart#httpGet
   */
  readonly httpGet?: RunnerReplicaSetSpecTemplateSpecContainersLifecyclePostStartHttpGet;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersLifecyclePostStart#tcpSocket
   */
  readonly tcpSocket?: RunnerReplicaSetSpecTemplateSpecContainersLifecyclePostStartTcpSocket;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecContainersLifecyclePostStart' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecContainersLifecyclePostStart(obj: RunnerReplicaSetSpecTemplateSpecContainersLifecyclePostStart | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_RunnerReplicaSetSpecTemplateSpecContainersLifecyclePostStartExec(obj.exec),
    'httpGet': toJson_RunnerReplicaSetSpecTemplateSpecContainersLifecyclePostStartHttpGet(obj.httpGet),
    'tcpSocket': toJson_RunnerReplicaSetSpecTemplateSpecContainersLifecyclePostStartTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PreStop is called immediately before a container is terminated due to an API request or management event such as liveness/startup probe failure, preemption, resource contention, etc. The handler is not called if the container crashes or exits. The Pod's termination grace period countdown begins before the PreStop hook is executed. Regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period (unless delayed by finalizers). Other management of the container blocks until the hook completes or until the termination grace period is reached. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema RunnerReplicaSetSpecTemplateSpecContainersLifecyclePreStop
 */
export interface RunnerReplicaSetSpecTemplateSpecContainersLifecyclePreStop {
  /**
   * Exec specifies the action to take.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersLifecyclePreStop#exec
   */
  readonly exec?: RunnerReplicaSetSpecTemplateSpecContainersLifecyclePreStopExec;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersLifecyclePreStop#httpGet
   */
  readonly httpGet?: RunnerReplicaSetSpecTemplateSpecContainersLifecyclePreStopHttpGet;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersLifecyclePreStop#tcpSocket
   */
  readonly tcpSocket?: RunnerReplicaSetSpecTemplateSpecContainersLifecyclePreStopTcpSocket;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecContainersLifecyclePreStop' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecContainersLifecyclePreStop(obj: RunnerReplicaSetSpecTemplateSpecContainersLifecyclePreStop | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_RunnerReplicaSetSpecTemplateSpecContainersLifecyclePreStopExec(obj.exec),
    'httpGet': toJson_RunnerReplicaSetSpecTemplateSpecContainersLifecyclePreStopHttpGet(obj.httpGet),
    'tcpSocket': toJson_RunnerReplicaSetSpecTemplateSpecContainersLifecyclePreStopTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecContainersLivenessProbeExec
 */
export interface RunnerReplicaSetSpecTemplateSpecContainersLivenessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersLivenessProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecContainersLivenessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecContainersLivenessProbeExec(obj: RunnerReplicaSetSpecTemplateSpecContainersLivenessProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecContainersLivenessProbeGrpc
 */
export interface RunnerReplicaSetSpecTemplateSpecContainersLivenessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersLivenessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersLivenessProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecContainersLivenessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecContainersLivenessProbeGrpc(obj: RunnerReplicaSetSpecTemplateSpecContainersLivenessProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecContainersLivenessProbeHttpGet
 */
export interface RunnerReplicaSetSpecTemplateSpecContainersLivenessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersLivenessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersLivenessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: RunnerReplicaSetSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersLivenessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersLivenessProbeHttpGet#port
   */
  readonly port: RunnerReplicaSetSpecTemplateSpecContainersLivenessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RunnerReplicaSetSpecTemplateSpecContainersLivenessProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecContainersLivenessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecContainersLivenessProbeHttpGet(obj: RunnerReplicaSetSpecTemplateSpecContainersLivenessProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecContainersLivenessProbeTcpSocket
 */
export interface RunnerReplicaSetSpecTemplateSpecContainersLivenessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersLivenessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersLivenessProbeTcpSocket#port
   */
  readonly port: RunnerReplicaSetSpecTemplateSpecContainersLivenessProbeTcpSocketPort;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecContainersLivenessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecContainersLivenessProbeTcpSocket(obj: RunnerReplicaSetSpecTemplateSpecContainersLivenessProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecContainersReadinessProbeExec
 */
export interface RunnerReplicaSetSpecTemplateSpecContainersReadinessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersReadinessProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecContainersReadinessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecContainersReadinessProbeExec(obj: RunnerReplicaSetSpecTemplateSpecContainersReadinessProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecContainersReadinessProbeGrpc
 */
export interface RunnerReplicaSetSpecTemplateSpecContainersReadinessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersReadinessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersReadinessProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecContainersReadinessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecContainersReadinessProbeGrpc(obj: RunnerReplicaSetSpecTemplateSpecContainersReadinessProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecContainersReadinessProbeHttpGet
 */
export interface RunnerReplicaSetSpecTemplateSpecContainersReadinessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersReadinessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersReadinessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: RunnerReplicaSetSpecTemplateSpecContainersReadinessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersReadinessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersReadinessProbeHttpGet#port
   */
  readonly port: RunnerReplicaSetSpecTemplateSpecContainersReadinessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RunnerReplicaSetSpecTemplateSpecContainersReadinessProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecContainersReadinessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecContainersReadinessProbeHttpGet(obj: RunnerReplicaSetSpecTemplateSpecContainersReadinessProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecContainersReadinessProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecContainersReadinessProbeTcpSocket
 */
export interface RunnerReplicaSetSpecTemplateSpecContainersReadinessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersReadinessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersReadinessProbeTcpSocket#port
   */
  readonly port: RunnerReplicaSetSpecTemplateSpecContainersReadinessProbeTcpSocketPort;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecContainersReadinessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecContainersReadinessProbeTcpSocket(obj: RunnerReplicaSetSpecTemplateSpecContainersReadinessProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RunnerReplicaSetSpecTemplateSpecContainersResourcesLimits
 */
export class RunnerReplicaSetSpecTemplateSpecContainersResourcesLimits {
  public static fromNumber(value: number): RunnerReplicaSetSpecTemplateSpecContainersResourcesLimits {
    return new RunnerReplicaSetSpecTemplateSpecContainersResourcesLimits(value);
  }
  public static fromString(value: string): RunnerReplicaSetSpecTemplateSpecContainersResourcesLimits {
    return new RunnerReplicaSetSpecTemplateSpecContainersResourcesLimits(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * @schema RunnerReplicaSetSpecTemplateSpecContainersResourcesRequests
 */
export class RunnerReplicaSetSpecTemplateSpecContainersResourcesRequests {
  public static fromNumber(value: number): RunnerReplicaSetSpecTemplateSpecContainersResourcesRequests {
    return new RunnerReplicaSetSpecTemplateSpecContainersResourcesRequests(value);
  }
  public static fromString(value: string): RunnerReplicaSetSpecTemplateSpecContainersResourcesRequests {
    return new RunnerReplicaSetSpecTemplateSpecContainersResourcesRequests(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
 *
 * @default the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
 * @schema RunnerReplicaSetSpecTemplateSpecContainersSecurityContextCapabilities
 */
export interface RunnerReplicaSetSpecTemplateSpecContainersSecurityContextCapabilities {
  /**
   * Added capabilities
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * Removed capabilities
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecContainersSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecContainersSecurityContextCapabilities(obj: RunnerReplicaSetSpecTemplateSpecContainersSecurityContextCapabilities | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': obj.add?.map(y => y),
    'drop': obj.drop?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecContainersSecurityContextSeLinuxOptions
 */
export interface RunnerReplicaSetSpecTemplateSpecContainersSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecContainersSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecContainersSecurityContextSeLinuxOptions(obj: RunnerReplicaSetSpecTemplateSpecContainersSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The seccomp options to use by this container. If seccomp options are provided at both the pod & container level, the container options override the pod options. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecContainersSecurityContextSeccompProfile
 */
export interface RunnerReplicaSetSpecTemplateSpecContainersSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Must be a descending path, relative to the kubelet's configured seccomp profile location. Must only be set if type is "Localhost".
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied. Valid options are:
   * Localhost - a profile defined in a file on the node should be used. RuntimeDefault - the container runtime default profile should be used. Unconfined - no profile should be applied.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersSecurityContextSeccompProfile#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecContainersSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecContainersSecurityContextSeccompProfile(obj: RunnerReplicaSetSpecTemplateSpecContainersSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Windows specific settings applied to all containers. If unspecified, the options from the PodSecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecContainersSecurityContextWindowsOptions
 */
export interface RunnerReplicaSetSpecTemplateSpecContainersSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container. This field is alpha-level and will only be honored by components that enable the WindowsHostProcessContainers feature flag. Setting this field without the feature flag will result in errors when validating the Pod. All of a Pod's containers must have the same effective HostProcess value (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).  In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process. Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * @schema RunnerReplicaSetSpecTemplateSpecContainersSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecContainersSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecContainersSecurityContextWindowsOptions(obj: RunnerReplicaSetSpecTemplateSpecContainersSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecContainersStartupProbeExec
 */
export interface RunnerReplicaSetSpecTemplateSpecContainersStartupProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersStartupProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecContainersStartupProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecContainersStartupProbeExec(obj: RunnerReplicaSetSpecTemplateSpecContainersStartupProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecContainersStartupProbeGrpc
 */
export interface RunnerReplicaSetSpecTemplateSpecContainersStartupProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersStartupProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersStartupProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecContainersStartupProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecContainersStartupProbeGrpc(obj: RunnerReplicaSetSpecTemplateSpecContainersStartupProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecContainersStartupProbeHttpGet
 */
export interface RunnerReplicaSetSpecTemplateSpecContainersStartupProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersStartupProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersStartupProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: RunnerReplicaSetSpecTemplateSpecContainersStartupProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersStartupProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersStartupProbeHttpGet#port
   */
  readonly port: RunnerReplicaSetSpecTemplateSpecContainersStartupProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RunnerReplicaSetSpecTemplateSpecContainersStartupProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecContainersStartupProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecContainersStartupProbeHttpGet(obj: RunnerReplicaSetSpecTemplateSpecContainersStartupProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecContainersStartupProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecContainersStartupProbeTcpSocket
 */
export interface RunnerReplicaSetSpecTemplateSpecContainersStartupProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersStartupProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersStartupProbeTcpSocket#port
   */
  readonly port: RunnerReplicaSetSpecTemplateSpecContainersStartupProbeTcpSocketPort;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecContainersStartupProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecContainersStartupProbeTcpSocket(obj: RunnerReplicaSetSpecTemplateSpecContainersStartupProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a ConfigMap.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecDockerEnvValueFromConfigMapKeyRef
 */
export interface RunnerReplicaSetSpecTemplateSpecDockerEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecDockerEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerReplicaSetSpecTemplateSpecDockerEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema RunnerReplicaSetSpecTemplateSpecDockerEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecDockerEnvValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecDockerEnvValueFromConfigMapKeyRef(obj: RunnerReplicaSetSpecTemplateSpecDockerEnvValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecDockerEnvValueFromFieldRef
 */
export interface RunnerReplicaSetSpecTemplateSpecDockerEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema RunnerReplicaSetSpecTemplateSpecDockerEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecDockerEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecDockerEnvValueFromFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecDockerEnvValueFromFieldRef(obj: RunnerReplicaSetSpecTemplateSpecDockerEnvValueFromFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecDockerEnvValueFromResourceFieldRef
 */
export interface RunnerReplicaSetSpecTemplateSpecDockerEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema RunnerReplicaSetSpecTemplateSpecDockerEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema RunnerReplicaSetSpecTemplateSpecDockerEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: RunnerReplicaSetSpecTemplateSpecDockerEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema RunnerReplicaSetSpecTemplateSpecDockerEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecDockerEnvValueFromResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecDockerEnvValueFromResourceFieldRef(obj: RunnerReplicaSetSpecTemplateSpecDockerEnvValueFromResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema RunnerReplicaSetSpecTemplateSpecDockerEnvValueFromSecretKeyRef
 */
export interface RunnerReplicaSetSpecTemplateSpecDockerEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecDockerEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerReplicaSetSpecTemplateSpecDockerEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema RunnerReplicaSetSpecTemplateSpecDockerEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecDockerEnvValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecDockerEnvValueFromSecretKeyRef(obj: RunnerReplicaSetSpecTemplateSpecDockerEnvValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a ConfigMap.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecEnvValueFromConfigMapKeyRef
 */
export interface RunnerReplicaSetSpecTemplateSpecEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecEnvValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecEnvValueFromConfigMapKeyRef(obj: RunnerReplicaSetSpecTemplateSpecEnvValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecEnvValueFromFieldRef
 */
export interface RunnerReplicaSetSpecTemplateSpecEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecEnvValueFromFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecEnvValueFromFieldRef(obj: RunnerReplicaSetSpecTemplateSpecEnvValueFromFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecEnvValueFromResourceFieldRef
 */
export interface RunnerReplicaSetSpecTemplateSpecEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: RunnerReplicaSetSpecTemplateSpecEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecEnvValueFromResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecEnvValueFromResourceFieldRef(obj: RunnerReplicaSetSpecTemplateSpecEnvValueFromResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema RunnerReplicaSetSpecTemplateSpecEnvValueFromSecretKeyRef
 */
export interface RunnerReplicaSetSpecTemplateSpecEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecEnvValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecEnvValueFromSecretKeyRef(obj: RunnerReplicaSetSpecTemplateSpecEnvValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvValueFrom
 */
export interface RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvValueFrom#fieldRef
   */
  readonly fieldRef?: RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvValueFrom(obj: RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvValueFromConfigMapKeyRef(obj.configMapKeyRef),
    'fieldRef': toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvValueFromFieldRef(obj.fieldRef),
    'resourceFieldRef': toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRef(obj.resourceFieldRef),
    'secretKeyRef': toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvFromConfigMapRef
 */
export interface RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvFromConfigMapRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvFromConfigMapRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvFromConfigMapRef(obj: RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvFromConfigMapRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Secret to select from
 *
 * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvFromSecretRef
 */
export interface RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvFromSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvFromSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvFromSecretRef(obj: RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvFromSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PostStart is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePostStart
 */
export interface RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePostStart {
  /**
   * Exec specifies the action to take.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePostStart#exec
   */
  readonly exec?: RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePostStartExec;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePostStart#httpGet
   */
  readonly httpGet?: RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGet;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePostStart#tcpSocket
   */
  readonly tcpSocket?: RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocket;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePostStart' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePostStart(obj: RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePostStart | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePostStartExec(obj.exec),
    'httpGet': toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGet(obj.httpGet),
    'tcpSocket': toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PreStop is called immediately before a container is terminated due to an API request or management event such as liveness/startup probe failure, preemption, resource contention, etc. The handler is not called if the container crashes or exits. The Pod's termination grace period countdown begins before the PreStop hook is executed. Regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period (unless delayed by finalizers). Other management of the container blocks until the hook completes or until the termination grace period is reached. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePreStop
 */
export interface RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePreStop {
  /**
   * Exec specifies the action to take.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePreStop#exec
   */
  readonly exec?: RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePreStopExec;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePreStop#httpGet
   */
  readonly httpGet?: RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGet;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePreStop#tcpSocket
   */
  readonly tcpSocket?: RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocket;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePreStop' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePreStop(obj: RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePreStop | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePreStopExec(obj.exec),
    'httpGet': toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGet(obj.httpGet),
    'tcpSocket': toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbeExec
 */
export interface RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbeExec(obj: RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbeGrpc
 */
export interface RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbeGrpc(obj: RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGet
 */
export interface RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGet#port
   */
  readonly port: RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGet(obj: RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocket
 */
export interface RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocket#port
   */
  readonly port: RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocketPort;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocket(obj: RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbeExec
 */
export interface RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbeExec(obj: RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbeGrpc
 */
export interface RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbeGrpc(obj: RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGet
 */
export interface RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGet#port
   */
  readonly port: RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGet(obj: RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocket
 */
export interface RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocket#port
   */
  readonly port: RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocketPort;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocket(obj: RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersResourcesLimits
 */
export class RunnerReplicaSetSpecTemplateSpecEphemeralContainersResourcesLimits {
  public static fromNumber(value: number): RunnerReplicaSetSpecTemplateSpecEphemeralContainersResourcesLimits {
    return new RunnerReplicaSetSpecTemplateSpecEphemeralContainersResourcesLimits(value);
  }
  public static fromString(value: string): RunnerReplicaSetSpecTemplateSpecEphemeralContainersResourcesLimits {
    return new RunnerReplicaSetSpecTemplateSpecEphemeralContainersResourcesLimits(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersResourcesRequests
 */
export class RunnerReplicaSetSpecTemplateSpecEphemeralContainersResourcesRequests {
  public static fromNumber(value: number): RunnerReplicaSetSpecTemplateSpecEphemeralContainersResourcesRequests {
    return new RunnerReplicaSetSpecTemplateSpecEphemeralContainersResourcesRequests(value);
  }
  public static fromString(value: string): RunnerReplicaSetSpecTemplateSpecEphemeralContainersResourcesRequests {
    return new RunnerReplicaSetSpecTemplateSpecEphemeralContainersResourcesRequests(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
 *
 * @default the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
 * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersSecurityContextCapabilities
 */
export interface RunnerReplicaSetSpecTemplateSpecEphemeralContainersSecurityContextCapabilities {
  /**
   * Added capabilities
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * Removed capabilities
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecEphemeralContainersSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersSecurityContextCapabilities(obj: RunnerReplicaSetSpecTemplateSpecEphemeralContainersSecurityContextCapabilities | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': obj.add?.map(y => y),
    'drop': obj.drop?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions
 */
export interface RunnerReplicaSetSpecTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions(obj: RunnerReplicaSetSpecTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The seccomp options to use by this container. If seccomp options are provided at both the pod & container level, the container options override the pod options. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersSecurityContextSeccompProfile
 */
export interface RunnerReplicaSetSpecTemplateSpecEphemeralContainersSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Must be a descending path, relative to the kubelet's configured seccomp profile location. Must only be set if type is "Localhost".
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied. Valid options are:
   * Localhost - a profile defined in a file on the node should be used. RuntimeDefault - the container runtime default profile should be used. Unconfined - no profile should be applied.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersSecurityContextSeccompProfile#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecEphemeralContainersSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersSecurityContextSeccompProfile(obj: RunnerReplicaSetSpecTemplateSpecEphemeralContainersSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Windows specific settings applied to all containers. If unspecified, the options from the PodSecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersSecurityContextWindowsOptions
 */
export interface RunnerReplicaSetSpecTemplateSpecEphemeralContainersSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container. This field is alpha-level and will only be honored by components that enable the WindowsHostProcessContainers feature flag. Setting this field without the feature flag will result in errors when validating the Pod. All of a Pod's containers must have the same effective HostProcess value (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).  In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process. Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecEphemeralContainersSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersSecurityContextWindowsOptions(obj: RunnerReplicaSetSpecTemplateSpecEphemeralContainersSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbeExec
 */
export interface RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbeExec(obj: RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbeGrpc
 */
export interface RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbeGrpc(obj: RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGet
 */
export interface RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGet#port
   */
  readonly port: RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGet(obj: RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbeTcpSocket
 */
export interface RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbeTcpSocket#port
   */
  readonly port: RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbeTcpSocketPort;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbeTcpSocket(obj: RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecInitContainersEnvValueFrom
 */
export interface RunnerReplicaSetSpecTemplateSpecInitContainersEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: RunnerReplicaSetSpecTemplateSpecInitContainersEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersEnvValueFrom#fieldRef
   */
  readonly fieldRef?: RunnerReplicaSetSpecTemplateSpecInitContainersEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: RunnerReplicaSetSpecTemplateSpecInitContainersEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: RunnerReplicaSetSpecTemplateSpecInitContainersEnvValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecInitContainersEnvValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecInitContainersEnvValueFrom(obj: RunnerReplicaSetSpecTemplateSpecInitContainersEnvValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_RunnerReplicaSetSpecTemplateSpecInitContainersEnvValueFromConfigMapKeyRef(obj.configMapKeyRef),
    'fieldRef': toJson_RunnerReplicaSetSpecTemplateSpecInitContainersEnvValueFromFieldRef(obj.fieldRef),
    'resourceFieldRef': toJson_RunnerReplicaSetSpecTemplateSpecInitContainersEnvValueFromResourceFieldRef(obj.resourceFieldRef),
    'secretKeyRef': toJson_RunnerReplicaSetSpecTemplateSpecInitContainersEnvValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema RunnerReplicaSetSpecTemplateSpecInitContainersEnvFromConfigMapRef
 */
export interface RunnerReplicaSetSpecTemplateSpecInitContainersEnvFromConfigMapRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersEnvFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersEnvFromConfigMapRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecInitContainersEnvFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecInitContainersEnvFromConfigMapRef(obj: RunnerReplicaSetSpecTemplateSpecInitContainersEnvFromConfigMapRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Secret to select from
 *
 * @schema RunnerReplicaSetSpecTemplateSpecInitContainersEnvFromSecretRef
 */
export interface RunnerReplicaSetSpecTemplateSpecInitContainersEnvFromSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersEnvFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersEnvFromSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecInitContainersEnvFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecInitContainersEnvFromSecretRef(obj: RunnerReplicaSetSpecTemplateSpecInitContainersEnvFromSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PostStart is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePostStart
 */
export interface RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePostStart {
  /**
   * Exec specifies the action to take.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePostStart#exec
   */
  readonly exec?: RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePostStartExec;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePostStart#httpGet
   */
  readonly httpGet?: RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGet;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePostStart#tcpSocket
   */
  readonly tcpSocket?: RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePostStartTcpSocket;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePostStart' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePostStart(obj: RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePostStart | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePostStartExec(obj.exec),
    'httpGet': toJson_RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGet(obj.httpGet),
    'tcpSocket': toJson_RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePostStartTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PreStop is called immediately before a container is terminated due to an API request or management event such as liveness/startup probe failure, preemption, resource contention, etc. The handler is not called if the container crashes or exits. The Pod's termination grace period countdown begins before the PreStop hook is executed. Regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period (unless delayed by finalizers). Other management of the container blocks until the hook completes or until the termination grace period is reached. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePreStop
 */
export interface RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePreStop {
  /**
   * Exec specifies the action to take.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePreStop#exec
   */
  readonly exec?: RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePreStopExec;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePreStop#httpGet
   */
  readonly httpGet?: RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGet;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePreStop#tcpSocket
   */
  readonly tcpSocket?: RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePreStopTcpSocket;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePreStop' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePreStop(obj: RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePreStop | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePreStopExec(obj.exec),
    'httpGet': toJson_RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGet(obj.httpGet),
    'tcpSocket': toJson_RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePreStopTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbeExec
 */
export interface RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbeExec(obj: RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbeGrpc
 */
export interface RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbeGrpc(obj: RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbeHttpGet
 */
export interface RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbeHttpGet#port
   */
  readonly port: RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbeHttpGet(obj: RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbeTcpSocket
 */
export interface RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbeTcpSocket#port
   */
  readonly port: RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbeTcpSocketPort;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbeTcpSocket(obj: RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbeExec
 */
export interface RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbeExec(obj: RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbeGrpc
 */
export interface RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbeGrpc(obj: RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbeHttpGet
 */
export interface RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbeHttpGet#port
   */
  readonly port: RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbeHttpGet(obj: RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbeTcpSocket
 */
export interface RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbeTcpSocket#port
   */
  readonly port: RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbeTcpSocketPort;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbeTcpSocket(obj: RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RunnerReplicaSetSpecTemplateSpecInitContainersResourcesLimits
 */
export class RunnerReplicaSetSpecTemplateSpecInitContainersResourcesLimits {
  public static fromNumber(value: number): RunnerReplicaSetSpecTemplateSpecInitContainersResourcesLimits {
    return new RunnerReplicaSetSpecTemplateSpecInitContainersResourcesLimits(value);
  }
  public static fromString(value: string): RunnerReplicaSetSpecTemplateSpecInitContainersResourcesLimits {
    return new RunnerReplicaSetSpecTemplateSpecInitContainersResourcesLimits(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * @schema RunnerReplicaSetSpecTemplateSpecInitContainersResourcesRequests
 */
export class RunnerReplicaSetSpecTemplateSpecInitContainersResourcesRequests {
  public static fromNumber(value: number): RunnerReplicaSetSpecTemplateSpecInitContainersResourcesRequests {
    return new RunnerReplicaSetSpecTemplateSpecInitContainersResourcesRequests(value);
  }
  public static fromString(value: string): RunnerReplicaSetSpecTemplateSpecInitContainersResourcesRequests {
    return new RunnerReplicaSetSpecTemplateSpecInitContainersResourcesRequests(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
 *
 * @default the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
 * @schema RunnerReplicaSetSpecTemplateSpecInitContainersSecurityContextCapabilities
 */
export interface RunnerReplicaSetSpecTemplateSpecInitContainersSecurityContextCapabilities {
  /**
   * Added capabilities
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * Removed capabilities
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecInitContainersSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecInitContainersSecurityContextCapabilities(obj: RunnerReplicaSetSpecTemplateSpecInitContainersSecurityContextCapabilities | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': obj.add?.map(y => y),
    'drop': obj.drop?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecInitContainersSecurityContextSeLinuxOptions
 */
export interface RunnerReplicaSetSpecTemplateSpecInitContainersSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecInitContainersSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecInitContainersSecurityContextSeLinuxOptions(obj: RunnerReplicaSetSpecTemplateSpecInitContainersSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The seccomp options to use by this container. If seccomp options are provided at both the pod & container level, the container options override the pod options. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecInitContainersSecurityContextSeccompProfile
 */
export interface RunnerReplicaSetSpecTemplateSpecInitContainersSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Must be a descending path, relative to the kubelet's configured seccomp profile location. Must only be set if type is "Localhost".
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied. Valid options are:
   * Localhost - a profile defined in a file on the node should be used. RuntimeDefault - the container runtime default profile should be used. Unconfined - no profile should be applied.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersSecurityContextSeccompProfile#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecInitContainersSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecInitContainersSecurityContextSeccompProfile(obj: RunnerReplicaSetSpecTemplateSpecInitContainersSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Windows specific settings applied to all containers. If unspecified, the options from the PodSecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecInitContainersSecurityContextWindowsOptions
 */
export interface RunnerReplicaSetSpecTemplateSpecInitContainersSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container. This field is alpha-level and will only be honored by components that enable the WindowsHostProcessContainers feature flag. Setting this field without the feature flag will result in errors when validating the Pod. All of a Pod's containers must have the same effective HostProcess value (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).  In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process. Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecInitContainersSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecInitContainersSecurityContextWindowsOptions(obj: RunnerReplicaSetSpecTemplateSpecInitContainersSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbeExec
 */
export interface RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbeExec(obj: RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbeGrpc
 */
export interface RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbeGrpc(obj: RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbeHttpGet
 */
export interface RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbeHttpGet#port
   */
  readonly port: RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbeHttpGet(obj: RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbeTcpSocket
 */
export interface RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbeTcpSocket#port
   */
  readonly port: RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbeTcpSocketPort;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbeTcpSocket(obj: RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvValueFrom
 */
export interface RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvValueFrom#fieldRef
   */
  readonly fieldRef?: RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvValueFrom(obj: RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvValueFromConfigMapKeyRef(obj.configMapKeyRef),
    'fieldRef': toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvValueFromFieldRef(obj.fieldRef),
    'resourceFieldRef': toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvValueFromResourceFieldRef(obj.resourceFieldRef),
    'secretKeyRef': toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvFromConfigMapRef
 */
export interface RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvFromConfigMapRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvFromConfigMapRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvFromConfigMapRef(obj: RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvFromConfigMapRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Secret to select from
 *
 * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvFromSecretRef
 */
export interface RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvFromSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvFromSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvFromSecretRef(obj: RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvFromSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PostStart is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePostStart
 */
export interface RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePostStart {
  /**
   * Exec specifies the action to take.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePostStart#exec
   */
  readonly exec?: RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePostStartExec;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePostStart#httpGet
   */
  readonly httpGet?: RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePostStartHttpGet;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePostStart#tcpSocket
   */
  readonly tcpSocket?: RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePostStartTcpSocket;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePostStart' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePostStart(obj: RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePostStart | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePostStartExec(obj.exec),
    'httpGet': toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePostStartHttpGet(obj.httpGet),
    'tcpSocket': toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePostStartTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PreStop is called immediately before a container is terminated due to an API request or management event such as liveness/startup probe failure, preemption, resource contention, etc. The handler is not called if the container crashes or exits. The Pod's termination grace period countdown begins before the PreStop hook is executed. Regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period (unless delayed by finalizers). Other management of the container blocks until the hook completes or until the termination grace period is reached. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePreStop
 */
export interface RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePreStop {
  /**
   * Exec specifies the action to take.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePreStop#exec
   */
  readonly exec?: RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePreStopExec;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePreStop#httpGet
   */
  readonly httpGet?: RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePreStopHttpGet;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePreStop#tcpSocket
   */
  readonly tcpSocket?: RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePreStopTcpSocket;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePreStop' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePreStop(obj: RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePreStop | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePreStopExec(obj.exec),
    'httpGet': toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePreStopHttpGet(obj.httpGet),
    'tcpSocket': toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePreStopTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbeExec
 */
export interface RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbeExec(obj: RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbeGrpc
 */
export interface RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbeGrpc(obj: RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbeHttpGet
 */
export interface RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbeHttpGet#port
   */
  readonly port: RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbeHttpGet(obj: RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbeTcpSocket
 */
export interface RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbeTcpSocket#port
   */
  readonly port: RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbeTcpSocketPort;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbeTcpSocket(obj: RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbeExec
 */
export interface RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbeExec(obj: RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbeGrpc
 */
export interface RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbeGrpc(obj: RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbeHttpGet
 */
export interface RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbeHttpGet#port
   */
  readonly port: RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbeHttpGet(obj: RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbeTcpSocket
 */
export interface RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbeTcpSocket#port
   */
  readonly port: RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbeTcpSocketPort;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbeTcpSocket(obj: RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersResourcesLimits
 */
export class RunnerReplicaSetSpecTemplateSpecSidecarContainersResourcesLimits {
  public static fromNumber(value: number): RunnerReplicaSetSpecTemplateSpecSidecarContainersResourcesLimits {
    return new RunnerReplicaSetSpecTemplateSpecSidecarContainersResourcesLimits(value);
  }
  public static fromString(value: string): RunnerReplicaSetSpecTemplateSpecSidecarContainersResourcesLimits {
    return new RunnerReplicaSetSpecTemplateSpecSidecarContainersResourcesLimits(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersResourcesRequests
 */
export class RunnerReplicaSetSpecTemplateSpecSidecarContainersResourcesRequests {
  public static fromNumber(value: number): RunnerReplicaSetSpecTemplateSpecSidecarContainersResourcesRequests {
    return new RunnerReplicaSetSpecTemplateSpecSidecarContainersResourcesRequests(value);
  }
  public static fromString(value: string): RunnerReplicaSetSpecTemplateSpecSidecarContainersResourcesRequests {
    return new RunnerReplicaSetSpecTemplateSpecSidecarContainersResourcesRequests(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
 *
 * @default the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
 * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersSecurityContextCapabilities
 */
export interface RunnerReplicaSetSpecTemplateSpecSidecarContainersSecurityContextCapabilities {
  /**
   * Added capabilities
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * Removed capabilities
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecSidecarContainersSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersSecurityContextCapabilities(obj: RunnerReplicaSetSpecTemplateSpecSidecarContainersSecurityContextCapabilities | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': obj.add?.map(y => y),
    'drop': obj.drop?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersSecurityContextSeLinuxOptions
 */
export interface RunnerReplicaSetSpecTemplateSpecSidecarContainersSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecSidecarContainersSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersSecurityContextSeLinuxOptions(obj: RunnerReplicaSetSpecTemplateSpecSidecarContainersSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The seccomp options to use by this container. If seccomp options are provided at both the pod & container level, the container options override the pod options. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersSecurityContextSeccompProfile
 */
export interface RunnerReplicaSetSpecTemplateSpecSidecarContainersSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Must be a descending path, relative to the kubelet's configured seccomp profile location. Must only be set if type is "Localhost".
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied. Valid options are:
   * Localhost - a profile defined in a file on the node should be used. RuntimeDefault - the container runtime default profile should be used. Unconfined - no profile should be applied.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersSecurityContextSeccompProfile#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecSidecarContainersSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersSecurityContextSeccompProfile(obj: RunnerReplicaSetSpecTemplateSpecSidecarContainersSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Windows specific settings applied to all containers. If unspecified, the options from the PodSecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersSecurityContextWindowsOptions
 */
export interface RunnerReplicaSetSpecTemplateSpecSidecarContainersSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container. This field is alpha-level and will only be honored by components that enable the WindowsHostProcessContainers feature flag. Setting this field without the feature flag will result in errors when validating the Pod. All of a Pod's containers must have the same effective HostProcess value (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).  In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process. Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecSidecarContainersSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersSecurityContextWindowsOptions(obj: RunnerReplicaSetSpecTemplateSpecSidecarContainersSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbeExec
 */
export interface RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbeExec(obj: RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbeGrpc
 */
export interface RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbeGrpc(obj: RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbeHttpGet
 */
export interface RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbeHttpGet#port
   */
  readonly port: RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbeHttpGet(obj: RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbeTcpSocket
 */
export interface RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbeTcpSocket#port
   */
  readonly port: RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbeTcpSocketPort;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbeTcpSocket(obj: RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecTopologySpreadConstraintLabelSelectorMatchExpressions
 */
export interface RunnerReplicaSetSpecTemplateSpecTopologySpreadConstraintLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecTopologySpreadConstraintLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecTopologySpreadConstraintLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecTopologySpreadConstraintLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecTopologySpreadConstraintLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecTopologySpreadConstraintLabelSelectorMatchExpressions(obj: RunnerReplicaSetSpecTemplateSpecTopologySpreadConstraintLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Optional: SecretRef is reference to the authentication secret for User, default is empty. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
 *
 * @schema RunnerReplicaSetSpecTemplateSpecVolumesCephfsSecretRef
 */
export interface RunnerReplicaSetSpecTemplateSpecVolumesCephfsSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesCephfsSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecVolumesCephfsSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecVolumesCephfsSecretRef(obj: RunnerReplicaSetSpecTemplateSpecVolumesCephfsSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Optional: points to a secret object containing parameters used to connect to OpenStack.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecVolumesCinderSecretRef
 */
export interface RunnerReplicaSetSpecTemplateSpecVolumesCinderSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesCinderSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecVolumesCinderSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecVolumesCinderSecretRef(obj: RunnerReplicaSetSpecTemplateSpecVolumesCinderSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecVolumesConfigMapItems
 */
export interface RunnerReplicaSetSpecTemplateSpecVolumesConfigMapItems {
  /**
   * The key to project.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesConfigMapItems#key
   */
  readonly key: string;

  /**
   * Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesConfigMapItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecVolumesConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecVolumesConfigMapItems(obj: RunnerReplicaSetSpecTemplateSpecVolumesConfigMapItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NodePublishSecretRef is a reference to the secret object containing sensitive information to pass to the CSI driver to complete the CSI NodePublishVolume and NodeUnpublishVolume calls. This field is optional, and  may be empty if no secret is required. If the secret object contains more than one secret, all secret references are passed.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecVolumesCsiNodePublishSecretRef
 */
export interface RunnerReplicaSetSpecTemplateSpecVolumesCsiNodePublishSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesCsiNodePublishSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecVolumesCsiNodePublishSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecVolumesCsiNodePublishSecretRef(obj: RunnerReplicaSetSpecTemplateSpecVolumesCsiNodePublishSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DownwardAPIVolumeFile represents information to create the file containing the pod field
 *
 * @schema RunnerReplicaSetSpecTemplateSpecVolumesDownwardApiItems
 */
export interface RunnerReplicaSetSpecTemplateSpecVolumesDownwardApiItems {
  /**
   * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesDownwardApiItems#fieldRef
   */
  readonly fieldRef?: RunnerReplicaSetSpecTemplateSpecVolumesDownwardApiItemsFieldRef;

  /**
   * Optional: mode bits used to set permissions on this file, must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesDownwardApiItems#mode
   */
  readonly mode?: number;

  /**
   * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesDownwardApiItems#path
   */
  readonly path: string;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesDownwardApiItems#resourceFieldRef
   */
  readonly resourceFieldRef?: RunnerReplicaSetSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRef;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecVolumesDownwardApiItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecVolumesDownwardApiItems(obj: RunnerReplicaSetSpecTemplateSpecVolumesDownwardApiItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fieldRef': toJson_RunnerReplicaSetSpecTemplateSpecVolumesDownwardApiItemsFieldRef(obj.fieldRef),
    'mode': obj.mode,
    'path': obj.path,
    'resourceFieldRef': toJson_RunnerReplicaSetSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRef(obj.resourceFieldRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. The default is nil which means that the limit is undefined. More info: http://kubernetes.io/docs/user-guide/volumes#emptydir
 *
 * @schema RunnerReplicaSetSpecTemplateSpecVolumesEmptyDirSizeLimit
 */
export class RunnerReplicaSetSpecTemplateSpecVolumesEmptyDirSizeLimit {
  public static fromNumber(value: number): RunnerReplicaSetSpecTemplateSpecVolumesEmptyDirSizeLimit {
    return new RunnerReplicaSetSpecTemplateSpecVolumesEmptyDirSizeLimit(value);
  }
  public static fromString(value: string): RunnerReplicaSetSpecTemplateSpecVolumesEmptyDirSizeLimit {
    return new RunnerReplicaSetSpecTemplateSpecVolumesEmptyDirSizeLimit(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Will be used to create a stand-alone PVC to provision the volume. The pod in which this EphemeralVolumeSource is embedded will be the owner of the PVC, i.e. the PVC will be deleted together with the pod.  The name of the PVC will be `<pod name>-<volume name>` where `<volume name>` is the name from the `PodSpec.Volumes` array entry. Pod validation will reject the pod if the concatenated name is not valid for a PVC (for example, too long).
 * An existing PVC with that name that is not owned by the pod will *not* be used for the pod to avoid using an unrelated volume by mistake. Starting the pod is then blocked until the unrelated PVC is removed. If such a pre-created PVC is meant to be used by the pod, the PVC has to updated with an owner reference to the pod once the pod exists. Normally this should not be necessary, but it may be useful when manually reconstructing a broken cluster.
 * This field is read-only and no changes will be made by Kubernetes to the PVC after it has been created.
 * Required, must not be nil.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplate
 */
export interface RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplate {
  /**
   * May contain labels and annotations that will be copied into the PVC when creating it. No other fields are allowed and will be rejected during validation.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplate#metadata
   */
  readonly metadata?: RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateMetadata;

  /**
   * The specification for the PersistentVolumeClaim. The entire content is copied unchanged into the PVC that gets created from this template. The same fields as in a PersistentVolumeClaim are also valid here.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplate#spec
   */
  readonly spec: RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplate(obj: RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateMetadata(obj.metadata),
    'spec': toJson_RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Optional: SecretRef is reference to the secret object containing sensitive information to pass to the plugin scripts. This may be empty if no secret object is specified. If the secret object contains more than one secret, all secrets are passed to the plugin scripts.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecVolumesFlexVolumeSecretRef
 */
export interface RunnerReplicaSetSpecTemplateSpecVolumesFlexVolumeSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesFlexVolumeSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecVolumesFlexVolumeSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecVolumesFlexVolumeSecretRef(obj: RunnerReplicaSetSpecTemplateSpecVolumesFlexVolumeSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CHAP Secret for iSCSI target and initiator authentication
 *
 * @schema RunnerReplicaSetSpecTemplateSpecVolumesIscsiSecretRef
 */
export interface RunnerReplicaSetSpecTemplateSpecVolumesIscsiSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesIscsiSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecVolumesIscsiSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecVolumesIscsiSecretRef(obj: RunnerReplicaSetSpecTemplateSpecVolumesIscsiSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Projection that may be projected along with other supported volume types
 *
 * @schema RunnerReplicaSetSpecTemplateSpecVolumesProjectedSources
 */
export interface RunnerReplicaSetSpecTemplateSpecVolumesProjectedSources {
  /**
   * information about the configMap data to project
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesProjectedSources#configMap
   */
  readonly configMap?: RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesConfigMap;

  /**
   * information about the downwardAPI data to project
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesProjectedSources#downwardAPI
   */
  readonly downwardApi?: RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesDownwardApi;

  /**
   * information about the secret data to project
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesProjectedSources#secret
   */
  readonly secret?: RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesSecret;

  /**
   * information about the serviceAccountToken data to project
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesProjectedSources#serviceAccountToken
   */
  readonly serviceAccountToken?: RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesServiceAccountToken;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecVolumesProjectedSources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecVolumesProjectedSources(obj: RunnerReplicaSetSpecTemplateSpecVolumesProjectedSources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesConfigMap(obj.configMap),
    'downwardAPI': toJson_RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesDownwardApi(obj.downwardApi),
    'secret': toJson_RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesSecret(obj.secret),
    'serviceAccountToken': toJson_RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesServiceAccountToken(obj.serviceAccountToken),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretRef is name of the authentication secret for RBDUser. If provided overrides keyring. Default is nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
 *
 * @default nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
 * @schema RunnerReplicaSetSpecTemplateSpecVolumesRbdSecretRef
 */
export interface RunnerReplicaSetSpecTemplateSpecVolumesRbdSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesRbdSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecVolumesRbdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecVolumesRbdSecretRef(obj: RunnerReplicaSetSpecTemplateSpecVolumesRbdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretRef references to the secret for ScaleIO user and other sensitive information. If this is not provided, Login operation will fail.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecVolumesScaleIoSecretRef
 */
export interface RunnerReplicaSetSpecTemplateSpecVolumesScaleIoSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesScaleIoSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecVolumesScaleIoSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecVolumesScaleIoSecretRef(obj: RunnerReplicaSetSpecTemplateSpecVolumesScaleIoSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecVolumesSecretItems
 */
export interface RunnerReplicaSetSpecTemplateSpecVolumesSecretItems {
  /**
   * The key to project.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesSecretItems#key
   */
  readonly key: string;

  /**
   * Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesSecretItems#mode
   */
  readonly mode?: number;

  /**
   * The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesSecretItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecVolumesSecretItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecVolumesSecretItems(obj: RunnerReplicaSetSpecTemplateSpecVolumesSecretItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretRef specifies the secret to use for obtaining the StorageOS API credentials.  If not specified, default values will be attempted.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecVolumesStorageosSecretRef
 */
export interface RunnerReplicaSetSpecTemplateSpecVolumesStorageosSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesStorageosSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecVolumesStorageosSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecVolumesStorageosSecretRef(obj: RunnerReplicaSetSpecTemplateSpecVolumesStorageosSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector term, associated with the corresponding weight.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj: RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A null or empty node selector term matches no objects. The requirements of them are ANDed. The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(obj: RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces. This field is beta-level and is only honored when PodAffinityNamespaceSelector feature is enabled.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means "this pod's namespace"
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces. This field is beta-level and is only honored when PodAffinityNamespaceSelector feature is enabled.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces. This field is beta-level and is only honored when PodAffinityNamespaceSelector feature is enabled.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means "this pod's namespace"
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces. This field is beta-level and is only honored when PodAffinityNamespaceSelector feature is enabled.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a ConfigMap.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecContainersEnvValueFromConfigMapKeyRef
 */
export interface RunnerReplicaSetSpecTemplateSpecContainersEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecContainersEnvValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecContainersEnvValueFromConfigMapKeyRef(obj: RunnerReplicaSetSpecTemplateSpecContainersEnvValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecContainersEnvValueFromFieldRef
 */
export interface RunnerReplicaSetSpecTemplateSpecContainersEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecContainersEnvValueFromFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecContainersEnvValueFromFieldRef(obj: RunnerReplicaSetSpecTemplateSpecContainersEnvValueFromFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecContainersEnvValueFromResourceFieldRef
 */
export interface RunnerReplicaSetSpecTemplateSpecContainersEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: RunnerReplicaSetSpecTemplateSpecContainersEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecContainersEnvValueFromResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecContainersEnvValueFromResourceFieldRef(obj: RunnerReplicaSetSpecTemplateSpecContainersEnvValueFromResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema RunnerReplicaSetSpecTemplateSpecContainersEnvValueFromSecretKeyRef
 */
export interface RunnerReplicaSetSpecTemplateSpecContainersEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecContainersEnvValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecContainersEnvValueFromSecretKeyRef(obj: RunnerReplicaSetSpecTemplateSpecContainersEnvValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecContainersLifecyclePostStartExec
 */
export interface RunnerReplicaSetSpecTemplateSpecContainersLifecyclePostStartExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersLifecyclePostStartExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecContainersLifecyclePostStartExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecContainersLifecyclePostStartExec(obj: RunnerReplicaSetSpecTemplateSpecContainersLifecyclePostStartExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecContainersLifecyclePostStartHttpGet
 */
export interface RunnerReplicaSetSpecTemplateSpecContainersLifecyclePostStartHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersLifecyclePostStartHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersLifecyclePostStartHttpGet#httpHeaders
   */
  readonly httpHeaders?: RunnerReplicaSetSpecTemplateSpecContainersLifecyclePostStartHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersLifecyclePostStartHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersLifecyclePostStartHttpGet#port
   */
  readonly port: RunnerReplicaSetSpecTemplateSpecContainersLifecyclePostStartHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RunnerReplicaSetSpecTemplateSpecContainersLifecyclePostStartHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecContainersLifecyclePostStartHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecContainersLifecyclePostStartHttpGet(obj: RunnerReplicaSetSpecTemplateSpecContainersLifecyclePostStartHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecContainersLifecyclePostStartHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecContainersLifecyclePostStartTcpSocket
 */
export interface RunnerReplicaSetSpecTemplateSpecContainersLifecyclePostStartTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersLifecyclePostStartTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersLifecyclePostStartTcpSocket#port
   */
  readonly port: RunnerReplicaSetSpecTemplateSpecContainersLifecyclePostStartTcpSocketPort;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecContainersLifecyclePostStartTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecContainersLifecyclePostStartTcpSocket(obj: RunnerReplicaSetSpecTemplateSpecContainersLifecyclePostStartTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecContainersLifecyclePreStopExec
 */
export interface RunnerReplicaSetSpecTemplateSpecContainersLifecyclePreStopExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersLifecyclePreStopExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecContainersLifecyclePreStopExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecContainersLifecyclePreStopExec(obj: RunnerReplicaSetSpecTemplateSpecContainersLifecyclePreStopExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecContainersLifecyclePreStopHttpGet
 */
export interface RunnerReplicaSetSpecTemplateSpecContainersLifecyclePreStopHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersLifecyclePreStopHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersLifecyclePreStopHttpGet#httpHeaders
   */
  readonly httpHeaders?: RunnerReplicaSetSpecTemplateSpecContainersLifecyclePreStopHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersLifecyclePreStopHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersLifecyclePreStopHttpGet#port
   */
  readonly port: RunnerReplicaSetSpecTemplateSpecContainersLifecyclePreStopHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RunnerReplicaSetSpecTemplateSpecContainersLifecyclePreStopHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecContainersLifecyclePreStopHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecContainersLifecyclePreStopHttpGet(obj: RunnerReplicaSetSpecTemplateSpecContainersLifecyclePreStopHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecContainersLifecyclePreStopHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecContainersLifecyclePreStopTcpSocket
 */
export interface RunnerReplicaSetSpecTemplateSpecContainersLifecyclePreStopTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersLifecyclePreStopTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersLifecyclePreStopTcpSocket#port
   */
  readonly port: RunnerReplicaSetSpecTemplateSpecContainersLifecyclePreStopTcpSocketPort;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecContainersLifecyclePreStopTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecContainersLifecyclePreStopTcpSocket(obj: RunnerReplicaSetSpecTemplateSpecContainersLifecyclePreStopTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RunnerReplicaSetSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeaders
 */
export interface RunnerReplicaSetSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeaders(obj: RunnerReplicaSetSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecContainersLivenessProbeHttpGetPort
 */
export class RunnerReplicaSetSpecTemplateSpecContainersLivenessProbeHttpGetPort {
  public static fromNumber(value: number): RunnerReplicaSetSpecTemplateSpecContainersLivenessProbeHttpGetPort {
    return new RunnerReplicaSetSpecTemplateSpecContainersLivenessProbeHttpGetPort(value);
  }
  public static fromString(value: string): RunnerReplicaSetSpecTemplateSpecContainersLivenessProbeHttpGetPort {
    return new RunnerReplicaSetSpecTemplateSpecContainersLivenessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecContainersLivenessProbeTcpSocketPort
 */
export class RunnerReplicaSetSpecTemplateSpecContainersLivenessProbeTcpSocketPort {
  public static fromNumber(value: number): RunnerReplicaSetSpecTemplateSpecContainersLivenessProbeTcpSocketPort {
    return new RunnerReplicaSetSpecTemplateSpecContainersLivenessProbeTcpSocketPort(value);
  }
  public static fromString(value: string): RunnerReplicaSetSpecTemplateSpecContainersLivenessProbeTcpSocketPort {
    return new RunnerReplicaSetSpecTemplateSpecContainersLivenessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RunnerReplicaSetSpecTemplateSpecContainersReadinessProbeHttpGetHttpHeaders
 */
export interface RunnerReplicaSetSpecTemplateSpecContainersReadinessProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersReadinessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersReadinessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecContainersReadinessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecContainersReadinessProbeHttpGetHttpHeaders(obj: RunnerReplicaSetSpecTemplateSpecContainersReadinessProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecContainersReadinessProbeHttpGetPort
 */
export class RunnerReplicaSetSpecTemplateSpecContainersReadinessProbeHttpGetPort {
  public static fromNumber(value: number): RunnerReplicaSetSpecTemplateSpecContainersReadinessProbeHttpGetPort {
    return new RunnerReplicaSetSpecTemplateSpecContainersReadinessProbeHttpGetPort(value);
  }
  public static fromString(value: string): RunnerReplicaSetSpecTemplateSpecContainersReadinessProbeHttpGetPort {
    return new RunnerReplicaSetSpecTemplateSpecContainersReadinessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecContainersReadinessProbeTcpSocketPort
 */
export class RunnerReplicaSetSpecTemplateSpecContainersReadinessProbeTcpSocketPort {
  public static fromNumber(value: number): RunnerReplicaSetSpecTemplateSpecContainersReadinessProbeTcpSocketPort {
    return new RunnerReplicaSetSpecTemplateSpecContainersReadinessProbeTcpSocketPort(value);
  }
  public static fromString(value: string): RunnerReplicaSetSpecTemplateSpecContainersReadinessProbeTcpSocketPort {
    return new RunnerReplicaSetSpecTemplateSpecContainersReadinessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RunnerReplicaSetSpecTemplateSpecContainersStartupProbeHttpGetHttpHeaders
 */
export interface RunnerReplicaSetSpecTemplateSpecContainersStartupProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersStartupProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersStartupProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecContainersStartupProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecContainersStartupProbeHttpGetHttpHeaders(obj: RunnerReplicaSetSpecTemplateSpecContainersStartupProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecContainersStartupProbeHttpGetPort
 */
export class RunnerReplicaSetSpecTemplateSpecContainersStartupProbeHttpGetPort {
  public static fromNumber(value: number): RunnerReplicaSetSpecTemplateSpecContainersStartupProbeHttpGetPort {
    return new RunnerReplicaSetSpecTemplateSpecContainersStartupProbeHttpGetPort(value);
  }
  public static fromString(value: string): RunnerReplicaSetSpecTemplateSpecContainersStartupProbeHttpGetPort {
    return new RunnerReplicaSetSpecTemplateSpecContainersStartupProbeHttpGetPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecContainersStartupProbeTcpSocketPort
 */
export class RunnerReplicaSetSpecTemplateSpecContainersStartupProbeTcpSocketPort {
  public static fromNumber(value: number): RunnerReplicaSetSpecTemplateSpecContainersStartupProbeTcpSocketPort {
    return new RunnerReplicaSetSpecTemplateSpecContainersStartupProbeTcpSocketPort(value);
  }
  public static fromString(value: string): RunnerReplicaSetSpecTemplateSpecContainersStartupProbeTcpSocketPort {
    return new RunnerReplicaSetSpecTemplateSpecContainersStartupProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema RunnerReplicaSetSpecTemplateSpecDockerEnvValueFromResourceFieldRefDivisor
 */
export class RunnerReplicaSetSpecTemplateSpecDockerEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(value: number): RunnerReplicaSetSpecTemplateSpecDockerEnvValueFromResourceFieldRefDivisor {
    return new RunnerReplicaSetSpecTemplateSpecDockerEnvValueFromResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): RunnerReplicaSetSpecTemplateSpecDockerEnvValueFromResourceFieldRefDivisor {
    return new RunnerReplicaSetSpecTemplateSpecDockerEnvValueFromResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema RunnerReplicaSetSpecTemplateSpecEnvValueFromResourceFieldRefDivisor
 */
export class RunnerReplicaSetSpecTemplateSpecEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(value: number): RunnerReplicaSetSpecTemplateSpecEnvValueFromResourceFieldRefDivisor {
    return new RunnerReplicaSetSpecTemplateSpecEnvValueFromResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): RunnerReplicaSetSpecTemplateSpecEnvValueFromResourceFieldRefDivisor {
    return new RunnerReplicaSetSpecTemplateSpecEnvValueFromResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Selects a key of a ConfigMap.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvValueFromConfigMapKeyRef
 */
export interface RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvValueFromConfigMapKeyRef(obj: RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvValueFromFieldRef
 */
export interface RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvValueFromFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvValueFromFieldRef(obj: RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvValueFromFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRef
 */
export interface RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRef(obj: RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvValueFromSecretKeyRef
 */
export interface RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvValueFromSecretKeyRef(obj: RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePostStartExec
 */
export interface RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePostStartExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePostStartExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePostStartExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePostStartExec(obj: RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePostStartExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGet
 */
export interface RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGet#httpHeaders
   */
  readonly httpHeaders?: RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGet#port
   */
  readonly port: RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGet(obj: RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocket
 */
export interface RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocket#port
   */
  readonly port: RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocketPort;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocket(obj: RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePreStopExec
 */
export interface RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePreStopExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePreStopExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePreStopExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePreStopExec(obj: RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePreStopExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGet
 */
export interface RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGet#httpHeaders
   */
  readonly httpHeaders?: RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGet#port
   */
  readonly port: RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGet(obj: RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocket
 */
export interface RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocket#port
   */
  readonly port: RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocketPort;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocket(obj: RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders
 */
export interface RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders(obj: RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetPort
 */
export class RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetPort {
  public static fromNumber(value: number): RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetPort {
    return new RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetPort(value);
  }
  public static fromString(value: string): RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetPort {
    return new RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocketPort
 */
export class RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocketPort {
  public static fromNumber(value: number): RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocketPort {
    return new RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocketPort(value);
  }
  public static fromString(value: string): RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocketPort {
    return new RunnerReplicaSetSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders
 */
export interface RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders(obj: RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetPort
 */
export class RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetPort {
  public static fromNumber(value: number): RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetPort {
    return new RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetPort(value);
  }
  public static fromString(value: string): RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetPort {
    return new RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocketPort
 */
export class RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocketPort {
  public static fromNumber(value: number): RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocketPort {
    return new RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocketPort(value);
  }
  public static fromString(value: string): RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocketPort {
    return new RunnerReplicaSetSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGetHttpHeaders
 */
export interface RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGetHttpHeaders(obj: RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGetPort
 */
export class RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGetPort {
  public static fromNumber(value: number): RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGetPort {
    return new RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGetPort(value);
  }
  public static fromString(value: string): RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGetPort {
    return new RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGetPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbeTcpSocketPort
 */
export class RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbeTcpSocketPort {
  public static fromNumber(value: number): RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbeTcpSocketPort {
    return new RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbeTcpSocketPort(value);
  }
  public static fromString(value: string): RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbeTcpSocketPort {
    return new RunnerReplicaSetSpecTemplateSpecEphemeralContainersStartupProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Selects a key of a ConfigMap.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecInitContainersEnvValueFromConfigMapKeyRef
 */
export interface RunnerReplicaSetSpecTemplateSpecInitContainersEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecInitContainersEnvValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecInitContainersEnvValueFromConfigMapKeyRef(obj: RunnerReplicaSetSpecTemplateSpecInitContainersEnvValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecInitContainersEnvValueFromFieldRef
 */
export interface RunnerReplicaSetSpecTemplateSpecInitContainersEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecInitContainersEnvValueFromFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecInitContainersEnvValueFromFieldRef(obj: RunnerReplicaSetSpecTemplateSpecInitContainersEnvValueFromFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecInitContainersEnvValueFromResourceFieldRef
 */
export interface RunnerReplicaSetSpecTemplateSpecInitContainersEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: RunnerReplicaSetSpecTemplateSpecInitContainersEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecInitContainersEnvValueFromResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecInitContainersEnvValueFromResourceFieldRef(obj: RunnerReplicaSetSpecTemplateSpecInitContainersEnvValueFromResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema RunnerReplicaSetSpecTemplateSpecInitContainersEnvValueFromSecretKeyRef
 */
export interface RunnerReplicaSetSpecTemplateSpecInitContainersEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecInitContainersEnvValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecInitContainersEnvValueFromSecretKeyRef(obj: RunnerReplicaSetSpecTemplateSpecInitContainersEnvValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePostStartExec
 */
export interface RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePostStartExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePostStartExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePostStartExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePostStartExec(obj: RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePostStartExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGet
 */
export interface RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGet#httpHeaders
   */
  readonly httpHeaders?: RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGet#port
   */
  readonly port: RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGet(obj: RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePostStartTcpSocket
 */
export interface RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePostStartTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePostStartTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePostStartTcpSocket#port
   */
  readonly port: RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePostStartTcpSocketPort;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePostStartTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePostStartTcpSocket(obj: RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePostStartTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePreStopExec
 */
export interface RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePreStopExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePreStopExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePreStopExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePreStopExec(obj: RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePreStopExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGet
 */
export interface RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGet#httpHeaders
   */
  readonly httpHeaders?: RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGet#port
   */
  readonly port: RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGet(obj: RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePreStopTcpSocket
 */
export interface RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePreStopTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePreStopTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePreStopTcpSocket#port
   */
  readonly port: RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePreStopTcpSocketPort;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePreStopTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePreStopTcpSocket(obj: RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePreStopTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders
 */
export interface RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders(obj: RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbeHttpGetPort
 */
export class RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbeHttpGetPort {
  public static fromNumber(value: number): RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbeHttpGetPort {
    return new RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbeHttpGetPort(value);
  }
  public static fromString(value: string): RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbeHttpGetPort {
    return new RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbeTcpSocketPort
 */
export class RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbeTcpSocketPort {
  public static fromNumber(value: number): RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbeTcpSocketPort {
    return new RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbeTcpSocketPort(value);
  }
  public static fromString(value: string): RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbeTcpSocketPort {
    return new RunnerReplicaSetSpecTemplateSpecInitContainersLivenessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders
 */
export interface RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders(obj: RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbeHttpGetPort
 */
export class RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbeHttpGetPort {
  public static fromNumber(value: number): RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbeHttpGetPort {
    return new RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbeHttpGetPort(value);
  }
  public static fromString(value: string): RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbeHttpGetPort {
    return new RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbeTcpSocketPort
 */
export class RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbeTcpSocketPort {
  public static fromNumber(value: number): RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbeTcpSocketPort {
    return new RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbeTcpSocketPort(value);
  }
  public static fromString(value: string): RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbeTcpSocketPort {
    return new RunnerReplicaSetSpecTemplateSpecInitContainersReadinessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbeHttpGetHttpHeaders
 */
export interface RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbeHttpGetHttpHeaders(obj: RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbeHttpGetPort
 */
export class RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbeHttpGetPort {
  public static fromNumber(value: number): RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbeHttpGetPort {
    return new RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbeHttpGetPort(value);
  }
  public static fromString(value: string): RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbeHttpGetPort {
    return new RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbeHttpGetPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbeTcpSocketPort
 */
export class RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbeTcpSocketPort {
  public static fromNumber(value: number): RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbeTcpSocketPort {
    return new RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbeTcpSocketPort(value);
  }
  public static fromString(value: string): RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbeTcpSocketPort {
    return new RunnerReplicaSetSpecTemplateSpecInitContainersStartupProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Selects a key of a ConfigMap.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvValueFromConfigMapKeyRef
 */
export interface RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvValueFromConfigMapKeyRef(obj: RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvValueFromFieldRef
 */
export interface RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvValueFromFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvValueFromFieldRef(obj: RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvValueFromFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvValueFromResourceFieldRef
 */
export interface RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvValueFromResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvValueFromResourceFieldRef(obj: RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvValueFromResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvValueFromSecretKeyRef
 */
export interface RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvValueFromSecretKeyRef(obj: RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePostStartExec
 */
export interface RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePostStartExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePostStartExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePostStartExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePostStartExec(obj: RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePostStartExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePostStartHttpGet
 */
export interface RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePostStartHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePostStartHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePostStartHttpGet#httpHeaders
   */
  readonly httpHeaders?: RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePostStartHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePostStartHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePostStartHttpGet#port
   */
  readonly port: RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePostStartHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePostStartHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePostStartHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePostStartHttpGet(obj: RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePostStartHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePostStartHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePostStartTcpSocket
 */
export interface RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePostStartTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePostStartTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePostStartTcpSocket#port
   */
  readonly port: RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePostStartTcpSocketPort;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePostStartTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePostStartTcpSocket(obj: RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePostStartTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePreStopExec
 */
export interface RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePreStopExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePreStopExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePreStopExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePreStopExec(obj: RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePreStopExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePreStopHttpGet
 */
export interface RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePreStopHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePreStopHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePreStopHttpGet#httpHeaders
   */
  readonly httpHeaders?: RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePreStopHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePreStopHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePreStopHttpGet#port
   */
  readonly port: RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePreStopHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePreStopHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePreStopHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePreStopHttpGet(obj: RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePreStopHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePreStopHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePreStopTcpSocket
 */
export interface RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePreStopTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePreStopTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePreStopTcpSocket#port
   */
  readonly port: RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePreStopTcpSocketPort;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePreStopTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePreStopTcpSocket(obj: RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePreStopTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbeHttpGetHttpHeaders
 */
export interface RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbeHttpGetHttpHeaders(obj: RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbeHttpGetPort
 */
export class RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbeHttpGetPort {
  public static fromNumber(value: number): RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbeHttpGetPort {
    return new RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbeHttpGetPort(value);
  }
  public static fromString(value: string): RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbeHttpGetPort {
    return new RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbeTcpSocketPort
 */
export class RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbeTcpSocketPort {
  public static fromNumber(value: number): RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbeTcpSocketPort {
    return new RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbeTcpSocketPort(value);
  }
  public static fromString(value: string): RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbeTcpSocketPort {
    return new RunnerReplicaSetSpecTemplateSpecSidecarContainersLivenessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbeHttpGetHttpHeaders
 */
export interface RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbeHttpGetHttpHeaders(obj: RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbeHttpGetPort
 */
export class RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbeHttpGetPort {
  public static fromNumber(value: number): RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbeHttpGetPort {
    return new RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbeHttpGetPort(value);
  }
  public static fromString(value: string): RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbeHttpGetPort {
    return new RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbeTcpSocketPort
 */
export class RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbeTcpSocketPort {
  public static fromNumber(value: number): RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbeTcpSocketPort {
    return new RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbeTcpSocketPort(value);
  }
  public static fromString(value: string): RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbeTcpSocketPort {
    return new RunnerReplicaSetSpecTemplateSpecSidecarContainersReadinessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbeHttpGetHttpHeaders
 */
export interface RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbeHttpGetHttpHeaders(obj: RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbeHttpGetPort
 */
export class RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbeHttpGetPort {
  public static fromNumber(value: number): RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbeHttpGetPort {
    return new RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbeHttpGetPort(value);
  }
  public static fromString(value: string): RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbeHttpGetPort {
    return new RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbeHttpGetPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbeTcpSocketPort
 */
export class RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbeTcpSocketPort {
  public static fromNumber(value: number): RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbeTcpSocketPort {
    return new RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbeTcpSocketPort(value);
  }
  public static fromString(value: string): RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbeTcpSocketPort {
    return new RunnerReplicaSetSpecTemplateSpecSidecarContainersStartupProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecVolumesDownwardApiItemsFieldRef
 */
export interface RunnerReplicaSetSpecTemplateSpecVolumesDownwardApiItemsFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesDownwardApiItemsFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesDownwardApiItemsFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecVolumesDownwardApiItemsFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecVolumesDownwardApiItemsFieldRef(obj: RunnerReplicaSetSpecTemplateSpecVolumesDownwardApiItemsFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRef
 */
export interface RunnerReplicaSetSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRef#divisor
   */
  readonly divisor?: RunnerReplicaSetSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRef(obj: RunnerReplicaSetSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * May contain labels and annotations that will be copied into the PVC when creating it. No other fields are allowed and will be rejected during validation.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateMetadata
 */
export interface RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateMetadata {
  /**
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateMetadata#finalizers
   */
  readonly finalizers?: string[];

  /**
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateMetadata#name
   */
  readonly name?: string;

  /**
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateMetadata#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateMetadata(obj: RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'finalizers': obj.finalizers?.map(y => y),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The specification for the PersistentVolumeClaim. The entire content is copied unchanged into the PVC that gets created from this template. The same fields as in a PersistentVolumeClaim are also valid here.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec
 */
export interface RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec {
  /**
   * AccessModes contains the desired access modes the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec#accessModes
   */
  readonly accessModes?: string[];

  /**
   * This field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. If the AnyVolumeDataSource feature gate is enabled, this field will always have the same contents as the DataSourceRef field.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec#dataSource
   */
  readonly dataSource?: RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource;

  /**
   * Specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any local object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the DataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, both fields (DataSource and DataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. There are two important differences between DataSource and DataSourceRef: * While DataSource only allows two specific types of objects, DataSourceRef   allows any non-core object, as well as PersistentVolumeClaim objects. * While DataSource ignores disallowed values (dropping them), DataSourceRef   preserves all values, and generates an error if a disallowed value is   specified. (Alpha) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec#dataSourceRef
   */
  readonly dataSourceRef?: RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef;

  /**
   * Resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec#resources
   */
  readonly resources?: RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResources;

  /**
   * A label query over volumes to consider for binding.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec#selector
   */
  readonly selector?: RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelector;

  /**
   * Name of the StorageClass required by the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim spec.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec#volumeMode
   */
  readonly volumeMode?: string;

  /**
   * VolumeName is the binding reference to the PersistentVolume backing this claim.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec#volumeName
   */
  readonly volumeName?: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec(obj: RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessModes': obj.accessModes?.map(y => y),
    'dataSource': toJson_RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource(obj.dataSource),
    'dataSourceRef': toJson_RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef(obj.dataSourceRef),
    'resources': toJson_RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResources(obj.resources),
    'selector': toJson_RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelector(obj.selector),
    'storageClassName': obj.storageClassName,
    'volumeMode': obj.volumeMode,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * information about the configMap data to project
 *
 * @schema RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesConfigMap
 */
export interface RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesConfigMap {
  /**
   * If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesConfigMap#items
   */
  readonly items?: RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesConfigMapItems[];

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its keys must be defined
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesConfigMap(obj: RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesConfigMapItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * information about the downwardAPI data to project
 *
 * @schema RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesDownwardApi
 */
export interface RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesDownwardApi {
  /**
   * Items is a list of DownwardAPIVolume file
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesDownwardApi#items
   */
  readonly items?: RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItems[];

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesDownwardApi' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesDownwardApi(obj: RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesDownwardApi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItems(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * information about the secret data to project
 *
 * @schema RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesSecret
 */
export interface RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesSecret {
  /**
   * If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesSecret#items
   */
  readonly items?: RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesSecretItems[];

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesSecret(obj: RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesSecretItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * information about the serviceAccountToken data to project
 *
 * @schema RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesServiceAccountToken
 */
export interface RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesServiceAccountToken {
  /**
   * Audience is the intended audience of the token. A recipient of a token must identify itself with an identifier specified in the audience of the token, and otherwise should reject the token. The audience defaults to the identifier of the apiserver.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesServiceAccountToken#audience
   */
  readonly audience?: string;

  /**
   * ExpirationSeconds is the requested duration of validity of the service account token. As the token approaches expiration, the kubelet volume plugin will proactively rotate the service account token. The kubelet will start trying to rotate the token if the token is older than 80 percent of its time to live or if the token is older than 24 hours.Defaults to 1 hour and must be at least 10 minutes.
   *
   * @default 1 hour and must be at least 10 minutes.
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesServiceAccountToken#expirationSeconds
   */
  readonly expirationSeconds?: number;

  /**
   * Path is the path relative to the mount point of the file to project the token into.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesServiceAccountToken#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesServiceAccountToken' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesServiceAccountToken(obj: RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesServiceAccountToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audience': obj.audience,
    'expirationSeconds': obj.expirationSeconds,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(obj: RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(obj: RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(obj: RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(obj: RunnerReplicaSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces. This field is beta-level and is only honored when PodAffinityNamespaceSelector feature is enabled.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces. This field is beta-level and is only honored when PodAffinityNamespaceSelector feature is enabled.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema RunnerReplicaSetSpecTemplateSpecContainersEnvValueFromResourceFieldRefDivisor
 */
export class RunnerReplicaSetSpecTemplateSpecContainersEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(value: number): RunnerReplicaSetSpecTemplateSpecContainersEnvValueFromResourceFieldRefDivisor {
    return new RunnerReplicaSetSpecTemplateSpecContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): RunnerReplicaSetSpecTemplateSpecContainersEnvValueFromResourceFieldRefDivisor {
    return new RunnerReplicaSetSpecTemplateSpecContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RunnerReplicaSetSpecTemplateSpecContainersLifecyclePostStartHttpGetHttpHeaders
 */
export interface RunnerReplicaSetSpecTemplateSpecContainersLifecyclePostStartHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersLifecyclePostStartHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersLifecyclePostStartHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecContainersLifecyclePostStartHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecContainersLifecyclePostStartHttpGetHttpHeaders(obj: RunnerReplicaSetSpecTemplateSpecContainersLifecyclePostStartHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecContainersLifecyclePostStartHttpGetPort
 */
export class RunnerReplicaSetSpecTemplateSpecContainersLifecyclePostStartHttpGetPort {
  public static fromNumber(value: number): RunnerReplicaSetSpecTemplateSpecContainersLifecyclePostStartHttpGetPort {
    return new RunnerReplicaSetSpecTemplateSpecContainersLifecyclePostStartHttpGetPort(value);
  }
  public static fromString(value: string): RunnerReplicaSetSpecTemplateSpecContainersLifecyclePostStartHttpGetPort {
    return new RunnerReplicaSetSpecTemplateSpecContainersLifecyclePostStartHttpGetPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecContainersLifecyclePostStartTcpSocketPort
 */
export class RunnerReplicaSetSpecTemplateSpecContainersLifecyclePostStartTcpSocketPort {
  public static fromNumber(value: number): RunnerReplicaSetSpecTemplateSpecContainersLifecyclePostStartTcpSocketPort {
    return new RunnerReplicaSetSpecTemplateSpecContainersLifecyclePostStartTcpSocketPort(value);
  }
  public static fromString(value: string): RunnerReplicaSetSpecTemplateSpecContainersLifecyclePostStartTcpSocketPort {
    return new RunnerReplicaSetSpecTemplateSpecContainersLifecyclePostStartTcpSocketPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RunnerReplicaSetSpecTemplateSpecContainersLifecyclePreStopHttpGetHttpHeaders
 */
export interface RunnerReplicaSetSpecTemplateSpecContainersLifecyclePreStopHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersLifecyclePreStopHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RunnerReplicaSetSpecTemplateSpecContainersLifecyclePreStopHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecContainersLifecyclePreStopHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecContainersLifecyclePreStopHttpGetHttpHeaders(obj: RunnerReplicaSetSpecTemplateSpecContainersLifecyclePreStopHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecContainersLifecyclePreStopHttpGetPort
 */
export class RunnerReplicaSetSpecTemplateSpecContainersLifecyclePreStopHttpGetPort {
  public static fromNumber(value: number): RunnerReplicaSetSpecTemplateSpecContainersLifecyclePreStopHttpGetPort {
    return new RunnerReplicaSetSpecTemplateSpecContainersLifecyclePreStopHttpGetPort(value);
  }
  public static fromString(value: string): RunnerReplicaSetSpecTemplateSpecContainersLifecyclePreStopHttpGetPort {
    return new RunnerReplicaSetSpecTemplateSpecContainersLifecyclePreStopHttpGetPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecContainersLifecyclePreStopTcpSocketPort
 */
export class RunnerReplicaSetSpecTemplateSpecContainersLifecyclePreStopTcpSocketPort {
  public static fromNumber(value: number): RunnerReplicaSetSpecTemplateSpecContainersLifecyclePreStopTcpSocketPort {
    return new RunnerReplicaSetSpecTemplateSpecContainersLifecyclePreStopTcpSocketPort(value);
  }
  public static fromString(value: string): RunnerReplicaSetSpecTemplateSpecContainersLifecyclePreStopTcpSocketPort {
    return new RunnerReplicaSetSpecTemplateSpecContainersLifecyclePreStopTcpSocketPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRefDivisor
 */
export class RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(value: number): RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRefDivisor {
    return new RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRefDivisor {
    return new RunnerReplicaSetSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders
 */
export interface RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders(obj: RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetPort
 */
export class RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetPort {
  public static fromNumber(value: number): RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetPort {
    return new RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetPort(value);
  }
  public static fromString(value: string): RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetPort {
    return new RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocketPort
 */
export class RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocketPort {
  public static fromNumber(value: number): RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocketPort {
    return new RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocketPort(value);
  }
  public static fromString(value: string): RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocketPort {
    return new RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocketPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders
 */
export interface RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders(obj: RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetPort
 */
export class RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetPort {
  public static fromNumber(value: number): RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetPort {
    return new RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetPort(value);
  }
  public static fromString(value: string): RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetPort {
    return new RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocketPort
 */
export class RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocketPort {
  public static fromNumber(value: number): RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocketPort {
    return new RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocketPort(value);
  }
  public static fromString(value: string): RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocketPort {
    return new RunnerReplicaSetSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocketPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema RunnerReplicaSetSpecTemplateSpecInitContainersEnvValueFromResourceFieldRefDivisor
 */
export class RunnerReplicaSetSpecTemplateSpecInitContainersEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(value: number): RunnerReplicaSetSpecTemplateSpecInitContainersEnvValueFromResourceFieldRefDivisor {
    return new RunnerReplicaSetSpecTemplateSpecInitContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): RunnerReplicaSetSpecTemplateSpecInitContainersEnvValueFromResourceFieldRefDivisor {
    return new RunnerReplicaSetSpecTemplateSpecInitContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders
 */
export interface RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders(obj: RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGetPort
 */
export class RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGetPort {
  public static fromNumber(value: number): RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGetPort {
    return new RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGetPort(value);
  }
  public static fromString(value: string): RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGetPort {
    return new RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGetPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePostStartTcpSocketPort
 */
export class RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePostStartTcpSocketPort {
  public static fromNumber(value: number): RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePostStartTcpSocketPort {
    return new RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePostStartTcpSocketPort(value);
  }
  public static fromString(value: string): RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePostStartTcpSocketPort {
    return new RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePostStartTcpSocketPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders
 */
export interface RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders(obj: RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGetPort
 */
export class RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGetPort {
  public static fromNumber(value: number): RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGetPort {
    return new RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGetPort(value);
  }
  public static fromString(value: string): RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGetPort {
    return new RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGetPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePreStopTcpSocketPort
 */
export class RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePreStopTcpSocketPort {
  public static fromNumber(value: number): RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePreStopTcpSocketPort {
    return new RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePreStopTcpSocketPort(value);
  }
  public static fromString(value: string): RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePreStopTcpSocketPort {
    return new RunnerReplicaSetSpecTemplateSpecInitContainersLifecyclePreStopTcpSocketPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvValueFromResourceFieldRefDivisor
 */
export class RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(value: number): RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvValueFromResourceFieldRefDivisor {
    return new RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvValueFromResourceFieldRefDivisor {
    return new RunnerReplicaSetSpecTemplateSpecSidecarContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePostStartHttpGetHttpHeaders
 */
export interface RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePostStartHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePostStartHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePostStartHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePostStartHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePostStartHttpGetHttpHeaders(obj: RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePostStartHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePostStartHttpGetPort
 */
export class RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePostStartHttpGetPort {
  public static fromNumber(value: number): RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePostStartHttpGetPort {
    return new RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePostStartHttpGetPort(value);
  }
  public static fromString(value: string): RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePostStartHttpGetPort {
    return new RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePostStartHttpGetPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePostStartTcpSocketPort
 */
export class RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePostStartTcpSocketPort {
  public static fromNumber(value: number): RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePostStartTcpSocketPort {
    return new RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePostStartTcpSocketPort(value);
  }
  public static fromString(value: string): RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePostStartTcpSocketPort {
    return new RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePostStartTcpSocketPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePreStopHttpGetHttpHeaders
 */
export interface RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePreStopHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePreStopHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePreStopHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePreStopHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePreStopHttpGetHttpHeaders(obj: RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePreStopHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePreStopHttpGetPort
 */
export class RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePreStopHttpGetPort {
  public static fromNumber(value: number): RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePreStopHttpGetPort {
    return new RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePreStopHttpGetPort(value);
  }
  public static fromString(value: string): RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePreStopHttpGetPort {
    return new RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePreStopHttpGetPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePreStopTcpSocketPort
 */
export class RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePreStopTcpSocketPort {
  public static fromNumber(value: number): RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePreStopTcpSocketPort {
    return new RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePreStopTcpSocketPort(value);
  }
  public static fromString(value: string): RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePreStopTcpSocketPort {
    return new RunnerReplicaSetSpecTemplateSpecSidecarContainersLifecyclePreStopTcpSocketPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema RunnerReplicaSetSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRefDivisor
 */
export class RunnerReplicaSetSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRefDivisor {
  public static fromNumber(value: number): RunnerReplicaSetSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRefDivisor {
    return new RunnerReplicaSetSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): RunnerReplicaSetSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRefDivisor {
    return new RunnerReplicaSetSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * This field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. If the AnyVolumeDataSource feature gate is enabled, this field will always have the same contents as the DataSourceRef field.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource
 */
export interface RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource {
  /**
   * APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource(obj: RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any local object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the DataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, both fields (DataSource and DataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. There are two important differences between DataSource and DataSourceRef: * While DataSource only allows two specific types of objects, DataSourceRef   allows any non-core object, as well as PersistentVolumeClaim objects. * While DataSource ignores disallowed values (dropping them), DataSourceRef   preserves all values, and generates an error if a disallowed value is   specified. (Alpha) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef
 */
export interface RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef {
  /**
   * APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef(obj: RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
 *
 * @schema RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResources
 */
export interface RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResources {
  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResources#limits
   */
  readonly limits?: { [key: string]: RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResources#requests
   */
  readonly requests?: { [key: string]: RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests };

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResources(obj: RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over volumes to consider for binding.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelector
 */
export interface RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelector#matchExpressions
   */
  readonly matchExpressions?: RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelector(obj: RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesConfigMapItems
 */
export interface RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesConfigMapItems {
  /**
   * The key to project.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesConfigMapItems#key
   */
  readonly key: string;

  /**
   * Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesConfigMapItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesConfigMapItems(obj: RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesConfigMapItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DownwardAPIVolumeFile represents information to create the file containing the pod field
 *
 * @schema RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItems
 */
export interface RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItems {
  /**
   * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItems#fieldRef
   */
  readonly fieldRef?: RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsFieldRef;

  /**
   * Optional: mode bits used to set permissions on this file, must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItems#mode
   */
  readonly mode?: number;

  /**
   * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItems#path
   */
  readonly path: string;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItems#resourceFieldRef
   */
  readonly resourceFieldRef?: RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItems(obj: RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fieldRef': toJson_RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsFieldRef(obj.fieldRef),
    'mode': obj.mode,
    'path': obj.path,
    'resourceFieldRef': toJson_RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef(obj.resourceFieldRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesSecretItems
 */
export interface RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesSecretItems {
  /**
   * The key to project.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesSecretItems#key
   */
  readonly key: string;

  /**
   * Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesSecretItems#mode
   */
  readonly mode?: number;

  /**
   * The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesSecretItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesSecretItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesSecretItems(obj: RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesSecretItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: RunnerReplicaSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: RunnerReplicaSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits
 */
export class RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
  public static fromNumber(value: number): RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits(value);
  }
  public static fromString(value: string): RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * @schema RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests
 */
export class RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
  public static fromNumber(value: number): RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests(value);
  }
  public static fromString(value: string): RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions
 */
export interface RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(obj: RunnerReplicaSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsFieldRef
 */
export interface RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsFieldRef(obj: RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
 *
 * @schema RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef
 */
export interface RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#divisor
   */
  readonly divisor?: RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef(obj: RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor
 */
export class RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
  public static fromNumber(value: number): RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
    return new RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
    return new RunnerReplicaSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: any) {
  }
}


/**
 * RunnerSet is the Schema for the runnersets API
 *
 * @schema RunnerSet
 */
export class RunnerSet extends ApiObject {
  /**
   * Returns the apiVersion and kind for "RunnerSet"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'actions.summerwind.dev/v1alpha1',
    kind: 'RunnerSet',
  }

  /**
   * Renders a Kubernetes manifest for "RunnerSet".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: RunnerSetProps = {}): any {
    return {
      ...RunnerSet.GVK,
      ...toJson_RunnerSetProps(props),
    };
  }

  /**
   * Defines a "RunnerSet" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: RunnerSetProps = {}) {
    super(scope, id, {
      ...RunnerSet.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...RunnerSet.GVK,
      ...toJson_RunnerSetProps(resolved),
    };
  }
}

/**
 * RunnerSet is the Schema for the runnersets API
 *
 * @schema RunnerSet
 */
export interface RunnerSetProps {
  /**
   * @schema RunnerSet#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * RunnerSetSpec defines the desired state of RunnerSet
   *
   * @schema RunnerSet#spec
   */
  readonly spec?: RunnerSetSpec;

}

/**
 * Converts an object of type 'RunnerSetProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetProps(obj: RunnerSetProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_RunnerSetSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RunnerSetSpec defines the desired state of RunnerSet
 *
 * @schema RunnerSetSpec
 */
export interface RunnerSetSpec {
  /**
   * @schema RunnerSetSpec#dockerEnabled
   */
  readonly dockerEnabled?: boolean;

  /**
   * @schema RunnerSetSpec#dockerMTU
   */
  readonly dockerMtu?: number;

  /**
   * @schema RunnerSetSpec#dockerRegistryMirror
   */
  readonly dockerRegistryMirror?: string;

  /**
   * @schema RunnerSetSpec#dockerdWithinRunnerContainer
   */
  readonly dockerdWithinRunnerContainer?: boolean;

  /**
   * EffectiveTime is the time the upstream controller requested to sync Replicas. It is usually populated by the webhook-based autoscaler via HRA. It is used to prevent ephemeral runners from unnecessarily recreated.
   *
   * @schema RunnerSetSpec#effectiveTime
   */
  readonly effectiveTime?: Date;

  /**
   * @schema RunnerSetSpec#enterprise
   */
  readonly enterprise?: string;

  /**
   * @schema RunnerSetSpec#ephemeral
   */
  readonly ephemeral?: boolean;

  /**
   * @schema RunnerSetSpec#group
   */
  readonly group?: string;

  /**
   * @schema RunnerSetSpec#image
   */
  readonly image?: string;

  /**
   * @schema RunnerSetSpec#labels
   */
  readonly labels?: string[];

  /**
   * Minimum number of seconds for which a newly created pod should be ready without any of its container crashing for it to be considered available. Defaults to 0 (pod will be considered available as soon as it is ready) This is an alpha field and requires enabling StatefulSetMinReadySeconds feature gate.
   *
   * @default 0 (pod will be considered available as soon as it is ready) This is an alpha field and requires enabling StatefulSetMinReadySeconds feature gate.
   * @schema RunnerSetSpec#minReadySeconds
   */
  readonly minReadySeconds?: number;

  /**
   * @schema RunnerSetSpec#organization
   */
  readonly organization?: string;

  /**
   * persistentVolumeClaimRetentionPolicy describes the lifecycle of persistent volume claims created from volumeClaimTemplates. By default, all persistent volume claims are created as needed and retained until manually deleted. This policy allows the lifecycle to be altered, for example by deleting persistent volume claims when their stateful set is deleted, or when their pod is scaled down. This requires the StatefulSetAutoDeletePVC feature gate to be enabled, which is alpha.  +optional
   *
   * @schema RunnerSetSpec#persistentVolumeClaimRetentionPolicy
   */
  readonly persistentVolumeClaimRetentionPolicy?: RunnerSetSpecPersistentVolumeClaimRetentionPolicy;

  /**
   * podManagementPolicy controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is `OrderedReady`, where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is `Parallel` which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once.
   *
   * @schema RunnerSetSpec#podManagementPolicy
   */
  readonly podManagementPolicy?: string;

  /**
   * replicas is the desired number of replicas of the given Template. These are replicas in the sense that they are instantiations of the same Template, but individual replicas also have a consistent identity. If unspecified, defaults to 1. TODO: Consider a rename of this field.
   *
   * @schema RunnerSetSpec#replicas
   */
  readonly replicas?: number;

  /**
   * @schema RunnerSetSpec#repository
   */
  readonly repository?: string;

  /**
   * revisionHistoryLimit is the maximum number of revisions that will be maintained in the StatefulSet's revision history. The revision history consists of all revisions not represented by a currently applied StatefulSetSpec version. The default value is 10.
   *
   * @schema RunnerSetSpec#revisionHistoryLimit
   */
  readonly revisionHistoryLimit?: number;

  /**
   * selector is a label query over pods that should match the replica count. It must match the pod template's labels. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
   *
   * @schema RunnerSetSpec#selector
   */
  readonly selector: RunnerSetSpecSelector;

  /**
   * serviceName is the name of the service that governs this StatefulSet. This service must exist before the StatefulSet, and is responsible for the network identity of the set. Pods get DNS/hostnames that follow the pattern: pod-specific-string.serviceName.default.svc.cluster.local where "pod-specific-string" is managed by the StatefulSet controller.
   *
   * @schema RunnerSetSpec#serviceName
   */
  readonly serviceName: string;

  /**
   * template is the object that describes the pod that will be created if insufficient replicas are detected. Each pod stamped out by the StatefulSet will fulfill this Template, but have a unique identity from the rest of the StatefulSet.
   *
   * @schema RunnerSetSpec#template
   */
  readonly template: RunnerSetSpecTemplate;

  /**
   * updateStrategy indicates the StatefulSetUpdateStrategy that will be employed to update Pods in the StatefulSet when a revision is made to Template.
   *
   * @schema RunnerSetSpec#updateStrategy
   */
  readonly updateStrategy?: RunnerSetSpecUpdateStrategy;

  /**
   * volumeClaimTemplates is a list of claims that pods are allowed to reference. The StatefulSet controller is responsible for mapping network identities to claims in a way that maintains the identity of a pod. Every claim in this list must have at least one matching (by name) volumeMount in one container in the template. A claim in this list takes precedence over any volumes in the template, with the same name. TODO: Define the behavior if a claim already exists with the same name.
   *
   * @schema RunnerSetSpec#volumeClaimTemplates
   */
  readonly volumeClaimTemplates?: RunnerSetSpecVolumeClaimTemplates[];

  /**
   * @schema RunnerSetSpec#volumeSizeLimit
   */
  readonly volumeSizeLimit?: RunnerSetSpecVolumeSizeLimit;

  /**
   * @schema RunnerSetSpec#volumeStorageMedium
   */
  readonly volumeStorageMedium?: string;

  /**
   * @schema RunnerSetSpec#workDir
   */
  readonly workDir?: string;

}

/**
 * Converts an object of type 'RunnerSetSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpec(obj: RunnerSetSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dockerEnabled': obj.dockerEnabled,
    'dockerMTU': obj.dockerMtu,
    'dockerRegistryMirror': obj.dockerRegistryMirror,
    'dockerdWithinRunnerContainer': obj.dockerdWithinRunnerContainer,
    'effectiveTime': obj.effectiveTime?.toISOString(),
    'enterprise': obj.enterprise,
    'ephemeral': obj.ephemeral,
    'group': obj.group,
    'image': obj.image,
    'labels': obj.labels?.map(y => y),
    'minReadySeconds': obj.minReadySeconds,
    'organization': obj.organization,
    'persistentVolumeClaimRetentionPolicy': toJson_RunnerSetSpecPersistentVolumeClaimRetentionPolicy(obj.persistentVolumeClaimRetentionPolicy),
    'podManagementPolicy': obj.podManagementPolicy,
    'replicas': obj.replicas,
    'repository': obj.repository,
    'revisionHistoryLimit': obj.revisionHistoryLimit,
    'selector': toJson_RunnerSetSpecSelector(obj.selector),
    'serviceName': obj.serviceName,
    'template': toJson_RunnerSetSpecTemplate(obj.template),
    'updateStrategy': toJson_RunnerSetSpecUpdateStrategy(obj.updateStrategy),
    'volumeClaimTemplates': obj.volumeClaimTemplates?.map(y => toJson_RunnerSetSpecVolumeClaimTemplates(y)),
    'volumeSizeLimit': obj.volumeSizeLimit?.value,
    'volumeStorageMedium': obj.volumeStorageMedium,
    'workDir': obj.workDir,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * persistentVolumeClaimRetentionPolicy describes the lifecycle of persistent volume claims created from volumeClaimTemplates. By default, all persistent volume claims are created as needed and retained until manually deleted. This policy allows the lifecycle to be altered, for example by deleting persistent volume claims when their stateful set is deleted, or when their pod is scaled down. This requires the StatefulSetAutoDeletePVC feature gate to be enabled, which is alpha.  +optional
 *
 * @schema RunnerSetSpecPersistentVolumeClaimRetentionPolicy
 */
export interface RunnerSetSpecPersistentVolumeClaimRetentionPolicy {
  /**
   * WhenDeleted specifies what happens to PVCs created from StatefulSet VolumeClaimTemplates when the StatefulSet is deleted. The default policy of `Retain` causes PVCs to not be affected by StatefulSet deletion. The `Delete` policy causes those PVCs to be deleted.
   *
   * @schema RunnerSetSpecPersistentVolumeClaimRetentionPolicy#whenDeleted
   */
  readonly whenDeleted?: string;

  /**
   * WhenScaled specifies what happens to PVCs created from StatefulSet VolumeClaimTemplates when the StatefulSet is scaled down. The default policy of `Retain` causes PVCs to not be affected by a scaledown. The `Delete` policy causes the associated PVCs for any excess pods above the replica count to be deleted.
   *
   * @schema RunnerSetSpecPersistentVolumeClaimRetentionPolicy#whenScaled
   */
  readonly whenScaled?: string;

}

/**
 * Converts an object of type 'RunnerSetSpecPersistentVolumeClaimRetentionPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecPersistentVolumeClaimRetentionPolicy(obj: RunnerSetSpecPersistentVolumeClaimRetentionPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'whenDeleted': obj.whenDeleted,
    'whenScaled': obj.whenScaled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * selector is a label query over pods that should match the replica count. It must match the pod template's labels. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
 *
 * @schema RunnerSetSpecSelector
 */
export interface RunnerSetSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema RunnerSetSpecSelector#matchExpressions
   */
  readonly matchExpressions?: RunnerSetSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema RunnerSetSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'RunnerSetSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecSelector(obj: RunnerSetSpecSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_RunnerSetSpecSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * template is the object that describes the pod that will be created if insufficient replicas are detected. Each pod stamped out by the StatefulSet will fulfill this Template, but have a unique identity from the rest of the StatefulSet.
 *
 * @schema RunnerSetSpecTemplate
 */
export interface RunnerSetSpecTemplate {
  /**
   * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   *
   * @schema RunnerSetSpecTemplate#metadata
   */
  readonly metadata?: RunnerSetSpecTemplateMetadata;

  /**
   * Specification of the desired behavior of the pod. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
   *
   * @schema RunnerSetSpecTemplate#spec
   */
  readonly spec?: RunnerSetSpecTemplateSpec;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplate(obj: RunnerSetSpecTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_RunnerSetSpecTemplateMetadata(obj.metadata),
    'spec': toJson_RunnerSetSpecTemplateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * updateStrategy indicates the StatefulSetUpdateStrategy that will be employed to update Pods in the StatefulSet when a revision is made to Template.
 *
 * @schema RunnerSetSpecUpdateStrategy
 */
export interface RunnerSetSpecUpdateStrategy {
  /**
   * RollingUpdate is used to communicate parameters when Type is RollingUpdateStatefulSetStrategyType.
   *
   * @schema RunnerSetSpecUpdateStrategy#rollingUpdate
   */
  readonly rollingUpdate?: RunnerSetSpecUpdateStrategyRollingUpdate;

  /**
   * Type indicates the type of the StatefulSetUpdateStrategy. Default is RollingUpdate.
   *
   * @default RollingUpdate.
   * @schema RunnerSetSpecUpdateStrategy#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RunnerSetSpecUpdateStrategy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecUpdateStrategy(obj: RunnerSetSpecUpdateStrategy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'rollingUpdate': toJson_RunnerSetSpecUpdateStrategyRollingUpdate(obj.rollingUpdate),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PersistentVolumeClaim is a user's request for and claim to a persistent volume
 *
 * @schema RunnerSetSpecVolumeClaimTemplates
 */
export interface RunnerSetSpecVolumeClaimTemplates {
  /**
   * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
   *
   * @schema RunnerSetSpecVolumeClaimTemplates#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   *
   * @schema RunnerSetSpecVolumeClaimTemplates#kind
   */
  readonly kind?: string;

  /**
   * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   *
   * @schema RunnerSetSpecVolumeClaimTemplates#metadata
   */
  readonly metadata?: RunnerSetSpecVolumeClaimTemplatesMetadata;

  /**
   * Spec defines the desired characteristics of a volume requested by a pod author. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema RunnerSetSpecVolumeClaimTemplates#spec
   */
  readonly spec?: RunnerSetSpecVolumeClaimTemplatesSpec;

  /**
   * Status represents the current information/status of a persistent volume claim. Read-only. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema RunnerSetSpecVolumeClaimTemplates#status
   */
  readonly status?: RunnerSetSpecVolumeClaimTemplatesStatus;

}

/**
 * Converts an object of type 'RunnerSetSpecVolumeClaimTemplates' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecVolumeClaimTemplates(obj: RunnerSetSpecVolumeClaimTemplates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'kind': obj.kind,
    'metadata': toJson_RunnerSetSpecVolumeClaimTemplatesMetadata(obj.metadata),
    'spec': toJson_RunnerSetSpecVolumeClaimTemplatesSpec(obj.spec),
    'status': toJson_RunnerSetSpecVolumeClaimTemplatesStatus(obj.status),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RunnerSetSpecVolumeSizeLimit
 */
export class RunnerSetSpecVolumeSizeLimit {
  public static fromNumber(value: number): RunnerSetSpecVolumeSizeLimit {
    return new RunnerSetSpecVolumeSizeLimit(value);
  }
  public static fromString(value: string): RunnerSetSpecVolumeSizeLimit {
    return new RunnerSetSpecVolumeSizeLimit(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema RunnerSetSpecSelectorMatchExpressions
 */
export interface RunnerSetSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema RunnerSetSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema RunnerSetSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema RunnerSetSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'RunnerSetSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecSelectorMatchExpressions(obj: RunnerSetSpecSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
 *
 * @schema RunnerSetSpecTemplateMetadata
 */
export interface RunnerSetSpecTemplateMetadata {
  /**
   * @schema RunnerSetSpecTemplateMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * @schema RunnerSetSpecTemplateMetadata#finalizers
   */
  readonly finalizers?: string[];

  /**
   * @schema RunnerSetSpecTemplateMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * @schema RunnerSetSpecTemplateMetadata#name
   */
  readonly name?: string;

  /**
   * @schema RunnerSetSpecTemplateMetadata#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateMetadata(obj: RunnerSetSpecTemplateMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'finalizers': obj.finalizers?.map(y => y),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specification of the desired behavior of the pod. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
 *
 * @schema RunnerSetSpecTemplateSpec
 */
export interface RunnerSetSpecTemplateSpec {
  /**
   * Optional duration in seconds the pod may be active on the node relative to StartTime before the system will actively try to mark it failed and kill associated containers. Value must be a positive integer.
   *
   * @schema RunnerSetSpecTemplateSpec#activeDeadlineSeconds
   */
  readonly activeDeadlineSeconds?: number;

  /**
   * If specified, the pod's scheduling constraints
   *
   * @schema RunnerSetSpecTemplateSpec#affinity
   */
  readonly affinity?: RunnerSetSpecTemplateSpecAffinity;

  /**
   * AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.
   *
   * @schema RunnerSetSpecTemplateSpec#automountServiceAccountToken
   */
  readonly automountServiceAccountToken?: boolean;

  /**
   * List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. Cannot be updated.
   *
   * @schema RunnerSetSpecTemplateSpec#containers
   */
  readonly containers: RunnerSetSpecTemplateSpecContainers[];

  /**
   * Specifies the DNS parameters of a pod. Parameters specified here will be merged to the generated DNS configuration based on DNSPolicy.
   *
   * @schema RunnerSetSpecTemplateSpec#dnsConfig
   */
  readonly dnsConfig?: RunnerSetSpecTemplateSpecDnsConfig;

  /**
   * Set DNS policy for the pod. Defaults to "ClusterFirst". Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'. DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy. To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to 'ClusterFirstWithHostNet'.
   *
   * @default ClusterFirst". Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'. DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy. To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to 'ClusterFirstWithHostNet'.
   * @schema RunnerSetSpecTemplateSpec#dnsPolicy
   */
  readonly dnsPolicy?: string;

  /**
   * EnableServiceLinks indicates whether information about services should be injected into pod's environment variables, matching the syntax of Docker links. Optional: Defaults to true.
   *
   * @default true.
   * @schema RunnerSetSpecTemplateSpec#enableServiceLinks
   */
  readonly enableServiceLinks?: boolean;

  /**
   * List of ephemeral containers run in this pod. Ephemeral containers may be run in an existing pod to perform user-initiated actions such as debugging. This list cannot be specified when creating a pod, and it cannot be modified by updating the pod spec. In order to add an ephemeral container to an existing pod, use the pod's ephemeralcontainers subresource. This field is beta-level and available on clusters that haven't disabled the EphemeralContainers feature gate.
   *
   * @schema RunnerSetSpecTemplateSpec#ephemeralContainers
   */
  readonly ephemeralContainers?: RunnerSetSpecTemplateSpecEphemeralContainers[];

  /**
   * HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified. This is only valid for non-hostNetwork pods.
   *
   * @schema RunnerSetSpecTemplateSpec#hostAliases
   */
  readonly hostAliases?: RunnerSetSpecTemplateSpecHostAliases[];

  /**
   * Use the host's ipc namespace. Optional: Default to false.
   *
   * @default false.
   * @schema RunnerSetSpecTemplateSpec#hostIPC
   */
  readonly hostIpc?: boolean;

  /**
   * Host networking requested for this pod. Use the host's network namespace. If this option is set, the ports that will be used must be specified. Default to false.
   *
   * @default false.
   * @schema RunnerSetSpecTemplateSpec#hostNetwork
   */
  readonly hostNetwork?: boolean;

  /**
   * Use the host's pid namespace. Optional: Default to false.
   *
   * @default false.
   * @schema RunnerSetSpecTemplateSpec#hostPID
   */
  readonly hostPid?: boolean;

  /**
   * Specifies the hostname of the Pod If not specified, the pod's hostname will be set to a system-defined value.
   *
   * @schema RunnerSetSpecTemplateSpec#hostname
   */
  readonly hostname?: string;

  /**
   * ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec. If specified, these secrets will be passed to individual puller implementations for them to use. For example, in the case of docker, only DockerConfig type secrets are honored. More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod
   *
   * @schema RunnerSetSpecTemplateSpec#imagePullSecrets
   */
  readonly imagePullSecrets?: RunnerSetSpecTemplateSpecImagePullSecrets[];

  /**
   * List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added or removed. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
   *
   * @schema RunnerSetSpecTemplateSpec#initContainers
   */
  readonly initContainers?: RunnerSetSpecTemplateSpecInitContainers[];

  /**
   * NodeName is a request to schedule this pod onto a specific node. If it is non-empty, the scheduler simply schedules this pod onto that node, assuming that it fits resource requirements.
   *
   * @schema RunnerSetSpecTemplateSpec#nodeName
   */
  readonly nodeName?: string;

  /**
   * NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
   *
   * @schema RunnerSetSpecTemplateSpec#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * Specifies the OS of the containers in the pod. Some pod and container fields are restricted if this is set.
   * If the OS field is set to linux, the following fields must be unset: -securityContext.windowsOptions
   * If the OS field is set to windows, following fields must be unset: - spec.hostPID - spec.hostIPC - spec.securityContext.seLinuxOptions - spec.securityContext.seccompProfile - spec.securityContext.fsGroup - spec.securityContext.fsGroupChangePolicy - spec.securityContext.sysctls - spec.shareProcessNamespace - spec.securityContext.runAsUser - spec.securityContext.runAsGroup - spec.securityContext.supplementalGroups - spec.containers[*].securityContext.seLinuxOptions - spec.containers[*].securityContext.seccompProfile - spec.containers[*].securityContext.capabilities - spec.containers[*].securityContext.readOnlyRootFilesystem - spec.containers[*].securityContext.privileged - spec.containers[*].securityContext.allowPrivilegeEscalation - spec.containers[*].securityContext.procMount - spec.containers[*].securityContext.runAsUser - spec.containers[*].securityContext.runAsGroup This is an alpha field and requires the IdentifyPodOS feature
   *
   * @schema RunnerSetSpecTemplateSpec#os
   */
  readonly os?: RunnerSetSpecTemplateSpecOs;

  /**
   * Overhead represents the resource overhead associated with running a pod for a given RuntimeClass. This field will be autopopulated at admission time by the RuntimeClass admission controller. If the RuntimeClass admission controller is enabled, overhead must not be set in Pod create requests. The RuntimeClass admission controller will reject Pod create requests which have the overhead already set. If RuntimeClass is configured and selected in the PodSpec, Overhead will be set to the value defined in the corresponding RuntimeClass, otherwise it will remain unset and treated as zero. More info: https://git.k8s.io/enhancements/keps/sig-node/688-pod-overhead/README.md This field is beta-level as of Kubernetes v1.18, and is only honored by servers that enable the PodOverhead feature.
   *
   * @schema RunnerSetSpecTemplateSpec#overhead
   */
  readonly overhead?: { [key: string]: RunnerSetSpecTemplateSpecOverhead };

  /**
   * PreemptionPolicy is the Policy for preempting pods with lower priority. One of Never, PreemptLowerPriority. Defaults to PreemptLowerPriority if unset. This field is beta-level, gated by the NonPreemptingPriority feature-gate.
   *
   * @default PreemptLowerPriority if unset. This field is beta-level, gated by the NonPreemptingPriority feature-gate.
   * @schema RunnerSetSpecTemplateSpec#preemptionPolicy
   */
  readonly preemptionPolicy?: string;

  /**
   * The priority value. Various system components use this field to find the priority of the pod. When Priority Admission Controller is enabled, it prevents users from setting this field. The admission controller populates this field from PriorityClassName. The higher the value, the higher the priority.
   *
   * @schema RunnerSetSpecTemplateSpec#priority
   */
  readonly priority?: number;

  /**
   * If specified, indicates the pod's priority. "system-node-critical" and "system-cluster-critical" are two special keywords which indicate the highest priorities with the former being the highest priority. Any other name must be defined by creating a PriorityClass object with that name. If not specified, the pod priority will be default or zero if there is no default.
   *
   * @schema RunnerSetSpecTemplateSpec#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * If specified, all readiness gates will be evaluated for pod readiness. A pod is ready when all its containers are ready AND all conditions specified in the readiness gates have status equal to "True" More info: https://git.k8s.io/enhancements/keps/sig-network/580-pod-readiness-gates
   *
   * @schema RunnerSetSpecTemplateSpec#readinessGates
   */
  readonly readinessGates?: RunnerSetSpecTemplateSpecReadinessGates[];

  /**
   * Restart policy for all containers within the pod. One of Always, OnFailure, Never. Default to Always. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy
   *
   * @default Always. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy
   * @schema RunnerSetSpecTemplateSpec#restartPolicy
   */
  readonly restartPolicy?: string;

  /**
   * RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should be used to run this pod.  If no RuntimeClass resource matches the named class, the pod will not be run. If unset or empty, the "legacy" RuntimeClass will be used, which is an implicit class with an empty definition that uses the default runtime handler. More info: https://git.k8s.io/enhancements/keps/sig-node/585-runtime-class This is a beta feature as of Kubernetes v1.14.
   *
   * @schema RunnerSetSpecTemplateSpec#runtimeClassName
   */
  readonly runtimeClassName?: string;

  /**
   * If specified, the pod will be dispatched by specified scheduler. If not specified, the pod will be dispatched by default scheduler.
   *
   * @schema RunnerSetSpecTemplateSpec#schedulerName
   */
  readonly schedulerName?: string;

  /**
   * SecurityContext holds pod-level security attributes and common container settings. Optional: Defaults to empty.  See type description for default values of each field.
   *
   * @default empty.  See type description for default values of each field.
   * @schema RunnerSetSpecTemplateSpec#securityContext
   */
  readonly securityContext?: RunnerSetSpecTemplateSpecSecurityContext;

  /**
   * DeprecatedServiceAccount is a depreciated alias for ServiceAccountName. Deprecated: Use serviceAccountName instead.
   *
   * @schema RunnerSetSpecTemplateSpec#serviceAccount
   */
  readonly serviceAccount?: string;

  /**
   * ServiceAccountName is the name of the ServiceAccount to use to run this pod. More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
   *
   * @schema RunnerSetSpecTemplateSpec#serviceAccountName
   */
  readonly serviceAccountName?: string;

  /**
   * If true the pod's hostname will be configured as the pod's FQDN, rather than the leaf name (the default). In Linux containers, this means setting the FQDN in the hostname field of the kernel (the nodename field of struct utsname). In Windows containers, this means setting the registry value of hostname for the registry key HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters to FQDN. If a pod does not have FQDN, this has no effect. Default to false.
   *
   * @default false.
   * @schema RunnerSetSpecTemplateSpec#setHostnameAsFQDN
   */
  readonly setHostnameAsFqdn?: boolean;

  /**
   * Share a single process namespace between all of the containers in a pod. When this is set containers will be able to view and signal processes from other containers in the same pod, and the first process in each container will not be assigned PID 1. HostPID and ShareProcessNamespace cannot both be set. Optional: Default to false.
   *
   * @default false.
   * @schema RunnerSetSpecTemplateSpec#shareProcessNamespace
   */
  readonly shareProcessNamespace?: boolean;

  /**
   * If specified, the fully qualified Pod hostname will be "<hostname>.<subdomain>.<pod namespace>.svc.<cluster domain>". If not specified, the pod will not have a domainname at all.
   *
   * @schema RunnerSetSpecTemplateSpec#subdomain
   */
  readonly subdomain?: string;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). If this value is nil, the default grace period will be used instead. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. Defaults to 30 seconds.
   *
   * @default 30 seconds.
   * @schema RunnerSetSpecTemplateSpec#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * If specified, the pod's tolerations.
   *
   * @schema RunnerSetSpecTemplateSpec#tolerations
   */
  readonly tolerations?: RunnerSetSpecTemplateSpecTolerations[];

  /**
   * TopologySpreadConstraints describes how a group of pods ought to spread across topology domains. Scheduler will schedule pods in a way which abides by the constraints. All topologySpreadConstraints are ANDed.
   *
   * @schema RunnerSetSpecTemplateSpec#topologySpreadConstraints
   */
  readonly topologySpreadConstraints?: RunnerSetSpecTemplateSpecTopologySpreadConstraints[];

  /**
   * List of volumes that can be mounted by containers belonging to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes
   *
   * @schema RunnerSetSpecTemplateSpec#volumes
   */
  readonly volumes?: RunnerSetSpecTemplateSpecVolumes[];

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpec(obj: RunnerSetSpecTemplateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'activeDeadlineSeconds': obj.activeDeadlineSeconds,
    'affinity': toJson_RunnerSetSpecTemplateSpecAffinity(obj.affinity),
    'automountServiceAccountToken': obj.automountServiceAccountToken,
    'containers': obj.containers?.map(y => toJson_RunnerSetSpecTemplateSpecContainers(y)),
    'dnsConfig': toJson_RunnerSetSpecTemplateSpecDnsConfig(obj.dnsConfig),
    'dnsPolicy': obj.dnsPolicy,
    'enableServiceLinks': obj.enableServiceLinks,
    'ephemeralContainers': obj.ephemeralContainers?.map(y => toJson_RunnerSetSpecTemplateSpecEphemeralContainers(y)),
    'hostAliases': obj.hostAliases?.map(y => toJson_RunnerSetSpecTemplateSpecHostAliases(y)),
    'hostIPC': obj.hostIpc,
    'hostNetwork': obj.hostNetwork,
    'hostPID': obj.hostPid,
    'hostname': obj.hostname,
    'imagePullSecrets': obj.imagePullSecrets?.map(y => toJson_RunnerSetSpecTemplateSpecImagePullSecrets(y)),
    'initContainers': obj.initContainers?.map(y => toJson_RunnerSetSpecTemplateSpecInitContainers(y)),
    'nodeName': obj.nodeName,
    'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'os': toJson_RunnerSetSpecTemplateSpecOs(obj.os),
    'overhead': ((obj.overhead) === undefined) ? undefined : (Object.entries(obj.overhead).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'preemptionPolicy': obj.preemptionPolicy,
    'priority': obj.priority,
    'priorityClassName': obj.priorityClassName,
    'readinessGates': obj.readinessGates?.map(y => toJson_RunnerSetSpecTemplateSpecReadinessGates(y)),
    'restartPolicy': obj.restartPolicy,
    'runtimeClassName': obj.runtimeClassName,
    'schedulerName': obj.schedulerName,
    'securityContext': toJson_RunnerSetSpecTemplateSpecSecurityContext(obj.securityContext),
    'serviceAccount': obj.serviceAccount,
    'serviceAccountName': obj.serviceAccountName,
    'setHostnameAsFQDN': obj.setHostnameAsFqdn,
    'shareProcessNamespace': obj.shareProcessNamespace,
    'subdomain': obj.subdomain,
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'tolerations': obj.tolerations?.map(y => toJson_RunnerSetSpecTemplateSpecTolerations(y)),
    'topologySpreadConstraints': obj.topologySpreadConstraints?.map(y => toJson_RunnerSetSpecTemplateSpecTopologySpreadConstraints(y)),
    'volumes': obj.volumes?.map(y => toJson_RunnerSetSpecTemplateSpecVolumes(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RollingUpdate is used to communicate parameters when Type is RollingUpdateStatefulSetStrategyType.
 *
 * @schema RunnerSetSpecUpdateStrategyRollingUpdate
 */
export interface RunnerSetSpecUpdateStrategyRollingUpdate {
  /**
   * Partition indicates the ordinal at which the StatefulSet should be partitioned. Default value is 0.
   *
   * @schema RunnerSetSpecUpdateStrategyRollingUpdate#partition
   */
  readonly partition?: number;

}

/**
 * Converts an object of type 'RunnerSetSpecUpdateStrategyRollingUpdate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecUpdateStrategyRollingUpdate(obj: RunnerSetSpecUpdateStrategyRollingUpdate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'partition': obj.partition,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
 *
 * @schema RunnerSetSpecVolumeClaimTemplatesMetadata
 */
export interface RunnerSetSpecVolumeClaimTemplatesMetadata {
  /**
   * @schema RunnerSetSpecVolumeClaimTemplatesMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * @schema RunnerSetSpecVolumeClaimTemplatesMetadata#finalizers
   */
  readonly finalizers?: string[];

  /**
   * @schema RunnerSetSpecVolumeClaimTemplatesMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * @schema RunnerSetSpecVolumeClaimTemplatesMetadata#name
   */
  readonly name?: string;

  /**
   * @schema RunnerSetSpecVolumeClaimTemplatesMetadata#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'RunnerSetSpecVolumeClaimTemplatesMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecVolumeClaimTemplatesMetadata(obj: RunnerSetSpecVolumeClaimTemplatesMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'finalizers': obj.finalizers?.map(y => y),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Spec defines the desired characteristics of a volume requested by a pod author. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
 *
 * @schema RunnerSetSpecVolumeClaimTemplatesSpec
 */
export interface RunnerSetSpecVolumeClaimTemplatesSpec {
  /**
   * AccessModes contains the desired access modes the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema RunnerSetSpecVolumeClaimTemplatesSpec#accessModes
   */
  readonly accessModes?: string[];

  /**
   * This field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. If the AnyVolumeDataSource feature gate is enabled, this field will always have the same contents as the DataSourceRef field.
   *
   * @schema RunnerSetSpecVolumeClaimTemplatesSpec#dataSource
   */
  readonly dataSource?: RunnerSetSpecVolumeClaimTemplatesSpecDataSource;

  /**
   * Specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any local object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the DataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, both fields (DataSource and DataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. There are two important differences between DataSource and DataSourceRef: * While DataSource only allows two specific types of objects, DataSourceRef   allows any non-core object, as well as PersistentVolumeClaim objects. * While DataSource ignores disallowed values (dropping them), DataSourceRef   preserves all values, and generates an error if a disallowed value is   specified. (Alpha) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
   *
   * @schema RunnerSetSpecVolumeClaimTemplatesSpec#dataSourceRef
   */
  readonly dataSourceRef?: RunnerSetSpecVolumeClaimTemplatesSpecDataSourceRef;

  /**
   * Resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
   *
   * @schema RunnerSetSpecVolumeClaimTemplatesSpec#resources
   */
  readonly resources?: RunnerSetSpecVolumeClaimTemplatesSpecResources;

  /**
   * A label query over volumes to consider for binding.
   *
   * @schema RunnerSetSpecVolumeClaimTemplatesSpec#selector
   */
  readonly selector?: RunnerSetSpecVolumeClaimTemplatesSpecSelector;

  /**
   * Name of the StorageClass required by the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   *
   * @schema RunnerSetSpecVolumeClaimTemplatesSpec#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim spec.
   *
   * @schema RunnerSetSpecVolumeClaimTemplatesSpec#volumeMode
   */
  readonly volumeMode?: string;

  /**
   * VolumeName is the binding reference to the PersistentVolume backing this claim.
   *
   * @schema RunnerSetSpecVolumeClaimTemplatesSpec#volumeName
   */
  readonly volumeName?: string;

}

/**
 * Converts an object of type 'RunnerSetSpecVolumeClaimTemplatesSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecVolumeClaimTemplatesSpec(obj: RunnerSetSpecVolumeClaimTemplatesSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessModes': obj.accessModes?.map(y => y),
    'dataSource': toJson_RunnerSetSpecVolumeClaimTemplatesSpecDataSource(obj.dataSource),
    'dataSourceRef': toJson_RunnerSetSpecVolumeClaimTemplatesSpecDataSourceRef(obj.dataSourceRef),
    'resources': toJson_RunnerSetSpecVolumeClaimTemplatesSpecResources(obj.resources),
    'selector': toJson_RunnerSetSpecVolumeClaimTemplatesSpecSelector(obj.selector),
    'storageClassName': obj.storageClassName,
    'volumeMode': obj.volumeMode,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Status represents the current information/status of a persistent volume claim. Read-only. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
 *
 * @schema RunnerSetSpecVolumeClaimTemplatesStatus
 */
export interface RunnerSetSpecVolumeClaimTemplatesStatus {
  /**
   * AccessModes contains the actual access modes the volume backing the PVC has. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema RunnerSetSpecVolumeClaimTemplatesStatus#accessModes
   */
  readonly accessModes?: string[];

  /**
   * The storage resource within AllocatedResources tracks the capacity allocated to a PVC. It may be larger than the actual capacity when a volume expansion operation is requested. For storage quota, the larger value from allocatedResources and PVC.spec.resources is used. If allocatedResources is not set, PVC.spec.resources alone is used for quota calculation. If a volume expansion capacity request is lowered, allocatedResources is only lowered if there are no expansion operations in progress and if the actual volume capacity is equal or lower than the requested capacity. This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
   *
   * @schema RunnerSetSpecVolumeClaimTemplatesStatus#allocatedResources
   */
  readonly allocatedResources?: { [key: string]: RunnerSetSpecVolumeClaimTemplatesStatusAllocatedResources };

  /**
   * Represents the actual resources of the underlying volume.
   *
   * @schema RunnerSetSpecVolumeClaimTemplatesStatus#capacity
   */
  readonly capacity?: { [key: string]: RunnerSetSpecVolumeClaimTemplatesStatusCapacity };

  /**
   * Current Condition of persistent volume claim. If underlying persistent volume is being resized then the Condition will be set to 'ResizeStarted'.
   *
   * @schema RunnerSetSpecVolumeClaimTemplatesStatus#conditions
   */
  readonly conditions?: RunnerSetSpecVolumeClaimTemplatesStatusConditions[];

  /**
   * Phase represents the current phase of PersistentVolumeClaim.
   *
   * @schema RunnerSetSpecVolumeClaimTemplatesStatus#phase
   */
  readonly phase?: string;

  /**
   * ResizeStatus stores status of resize operation. ResizeStatus is not set by default but when expansion is complete resizeStatus is set to empty string by resize controller or kubelet. This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
   *
   * @schema RunnerSetSpecVolumeClaimTemplatesStatus#resizeStatus
   */
  readonly resizeStatus?: string;

}

/**
 * Converts an object of type 'RunnerSetSpecVolumeClaimTemplatesStatus' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecVolumeClaimTemplatesStatus(obj: RunnerSetSpecVolumeClaimTemplatesStatus | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessModes': obj.accessModes?.map(y => y),
    'allocatedResources': ((obj.allocatedResources) === undefined) ? undefined : (Object.entries(obj.allocatedResources).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'capacity': ((obj.capacity) === undefined) ? undefined : (Object.entries(obj.capacity).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'conditions': obj.conditions?.map(y => toJson_RunnerSetSpecVolumeClaimTemplatesStatusConditions(y)),
    'phase': obj.phase,
    'resizeStatus': obj.resizeStatus,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * If specified, the pod's scheduling constraints
 *
 * @schema RunnerSetSpecTemplateSpecAffinity
 */
export interface RunnerSetSpecTemplateSpecAffinity {
  /**
   * Describes node affinity scheduling rules for the pod.
   *
   * @schema RunnerSetSpecTemplateSpecAffinity#nodeAffinity
   */
  readonly nodeAffinity?: RunnerSetSpecTemplateSpecAffinityNodeAffinity;

  /**
   * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
   *
   * @schema RunnerSetSpecTemplateSpecAffinity#podAffinity
   */
  readonly podAffinity?: RunnerSetSpecTemplateSpecAffinityPodAffinity;

  /**
   * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
   *
   * @schema RunnerSetSpecTemplateSpecAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: RunnerSetSpecTemplateSpecAffinityPodAntiAffinity;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecAffinity(obj: RunnerSetSpecTemplateSpecAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeAffinity': toJson_RunnerSetSpecTemplateSpecAffinityNodeAffinity(obj.nodeAffinity),
    'podAffinity': toJson_RunnerSetSpecTemplateSpecAffinityPodAffinity(obj.podAffinity),
    'podAntiAffinity': toJson_RunnerSetSpecTemplateSpecAffinityPodAntiAffinity(obj.podAntiAffinity),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A single application container that you want to run within a pod.
 *
 * @schema RunnerSetSpecTemplateSpecContainers
 */
export interface RunnerSetSpecTemplateSpecContainers {
  /**
   * Arguments to the entrypoint. The docker image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema RunnerSetSpecTemplateSpecContainers#args
   */
  readonly args?: string[];

  /**
   * Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema RunnerSetSpecTemplateSpecContainers#command
   */
  readonly command?: string[];

  /**
   * List of environment variables to set in the container. Cannot be updated.
   *
   * @schema RunnerSetSpecTemplateSpecContainers#env
   */
  readonly env?: RunnerSetSpecTemplateSpecContainersEnv[];

  /**
   * List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
   *
   * @schema RunnerSetSpecTemplateSpecContainers#envFrom
   */
  readonly envFrom?: RunnerSetSpecTemplateSpecContainersEnvFrom[];

  /**
   * Docker image name. More info: https://kubernetes.io/docs/concepts/containers/images This field is optional to allow higher level config management to default or override container images in workload controllers like Deployments and StatefulSets.
   *
   * @schema RunnerSetSpecTemplateSpecContainers#image
   */
  readonly image?: string;

  /**
   * Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   *
   * @default Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   * @schema RunnerSetSpecTemplateSpecContainers#imagePullPolicy
   */
  readonly imagePullPolicy?: string;

  /**
   * Actions that the management system should take in response to container lifecycle events. Cannot be updated.
   *
   * @schema RunnerSetSpecTemplateSpecContainers#lifecycle
   */
  readonly lifecycle?: RunnerSetSpecTemplateSpecContainersLifecycle;

  /**
   * Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerSetSpecTemplateSpecContainers#livenessProbe
   */
  readonly livenessProbe?: RunnerSetSpecTemplateSpecContainersLivenessProbe;

  /**
   * Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.
   *
   * @schema RunnerSetSpecTemplateSpecContainers#name
   */
  readonly name: string;

  /**
   * List of ports to expose from the container. Exposing a port here gives the system additional information about the network connections a container uses, but is primarily informational. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default "0.0.0.0" address inside a container will be accessible from the network. Cannot be updated.
   *
   * @schema RunnerSetSpecTemplateSpecContainers#ports
   */
  readonly ports?: RunnerSetSpecTemplateSpecContainersPorts[];

  /**
   * Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerSetSpecTemplateSpecContainers#readinessProbe
   */
  readonly readinessProbe?: RunnerSetSpecTemplateSpecContainersReadinessProbe;

  /**
   * Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema RunnerSetSpecTemplateSpecContainers#resources
   */
  readonly resources?: RunnerSetSpecTemplateSpecContainersResources;

  /**
   * SecurityContext defines the security options the container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
   *
   * @schema RunnerSetSpecTemplateSpecContainers#securityContext
   */
  readonly securityContext?: RunnerSetSpecTemplateSpecContainersSecurityContext;

  /**
   * StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerSetSpecTemplateSpecContainers#startupProbe
   */
  readonly startupProbe?: RunnerSetSpecTemplateSpecContainersStartupProbe;

  /**
   * Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF. Default is false.
   *
   * @default false.
   * @schema RunnerSetSpecTemplateSpecContainers#stdin
   */
  readonly stdin?: boolean;

  /**
   * Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false
   *
   * @default false
   * @schema RunnerSetSpecTemplateSpecContainers#stdinOnce
   */
  readonly stdinOnce?: boolean;

  /**
   * Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Will be truncated by the node if greater than 4096 bytes. The total message length across all containers will be limited to 12kb. Defaults to /dev/termination-log. Cannot be updated.
   *
   * @default dev/termination-log. Cannot be updated.
   * @schema RunnerSetSpecTemplateSpecContainers#terminationMessagePath
   */
  readonly terminationMessagePath?: string;

  /**
   * Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.
   *
   * @default File. Cannot be updated.
   * @schema RunnerSetSpecTemplateSpecContainers#terminationMessagePolicy
   */
  readonly terminationMessagePolicy?: string;

  /**
   * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true. Default is false.
   *
   * @default false.
   * @schema RunnerSetSpecTemplateSpecContainers#tty
   */
  readonly tty?: boolean;

  /**
   * volumeDevices is the list of block devices to be used by the container.
   *
   * @schema RunnerSetSpecTemplateSpecContainers#volumeDevices
   */
  readonly volumeDevices?: RunnerSetSpecTemplateSpecContainersVolumeDevices[];

  /**
   * Pod volumes to mount into the container's filesystem. Cannot be updated.
   *
   * @schema RunnerSetSpecTemplateSpecContainers#volumeMounts
   */
  readonly volumeMounts?: RunnerSetSpecTemplateSpecContainersVolumeMounts[];

  /**
   * Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.
   *
   * @schema RunnerSetSpecTemplateSpecContainers#workingDir
   */
  readonly workingDir?: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecContainers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecContainers(obj: RunnerSetSpecTemplateSpecContainers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'args': obj.args?.map(y => y),
    'command': obj.command?.map(y => y),
    'env': obj.env?.map(y => toJson_RunnerSetSpecTemplateSpecContainersEnv(y)),
    'envFrom': obj.envFrom?.map(y => toJson_RunnerSetSpecTemplateSpecContainersEnvFrom(y)),
    'image': obj.image,
    'imagePullPolicy': obj.imagePullPolicy,
    'lifecycle': toJson_RunnerSetSpecTemplateSpecContainersLifecycle(obj.lifecycle),
    'livenessProbe': toJson_RunnerSetSpecTemplateSpecContainersLivenessProbe(obj.livenessProbe),
    'name': obj.name,
    'ports': obj.ports?.map(y => toJson_RunnerSetSpecTemplateSpecContainersPorts(y)),
    'readinessProbe': toJson_RunnerSetSpecTemplateSpecContainersReadinessProbe(obj.readinessProbe),
    'resources': toJson_RunnerSetSpecTemplateSpecContainersResources(obj.resources),
    'securityContext': toJson_RunnerSetSpecTemplateSpecContainersSecurityContext(obj.securityContext),
    'startupProbe': toJson_RunnerSetSpecTemplateSpecContainersStartupProbe(obj.startupProbe),
    'stdin': obj.stdin,
    'stdinOnce': obj.stdinOnce,
    'terminationMessagePath': obj.terminationMessagePath,
    'terminationMessagePolicy': obj.terminationMessagePolicy,
    'tty': obj.tty,
    'volumeDevices': obj.volumeDevices?.map(y => toJson_RunnerSetSpecTemplateSpecContainersVolumeDevices(y)),
    'volumeMounts': obj.volumeMounts?.map(y => toJson_RunnerSetSpecTemplateSpecContainersVolumeMounts(y)),
    'workingDir': obj.workingDir,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the DNS parameters of a pod. Parameters specified here will be merged to the generated DNS configuration based on DNSPolicy.
 *
 * @schema RunnerSetSpecTemplateSpecDnsConfig
 */
export interface RunnerSetSpecTemplateSpecDnsConfig {
  /**
   * A list of DNS name server IP addresses. This will be appended to the base nameservers generated from DNSPolicy. Duplicated nameservers will be removed.
   *
   * @schema RunnerSetSpecTemplateSpecDnsConfig#nameservers
   */
  readonly nameservers?: string[];

  /**
   * A list of DNS resolver options. This will be merged with the base options generated from DNSPolicy. Duplicated entries will be removed. Resolution options given in Options will override those that appear in the base DNSPolicy.
   *
   * @schema RunnerSetSpecTemplateSpecDnsConfig#options
   */
  readonly options?: RunnerSetSpecTemplateSpecDnsConfigOptions[];

  /**
   * A list of DNS search domains for host-name lookup. This will be appended to the base search paths generated from DNSPolicy. Duplicated search paths will be removed.
   *
   * @schema RunnerSetSpecTemplateSpecDnsConfig#searches
   */
  readonly searches?: string[];

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecDnsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecDnsConfig(obj: RunnerSetSpecTemplateSpecDnsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nameservers': obj.nameservers?.map(y => y),
    'options': obj.options?.map(y => toJson_RunnerSetSpecTemplateSpecDnsConfigOptions(y)),
    'searches': obj.searches?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * An EphemeralContainer is a temporary container that you may add to an existing Pod for user-initiated activities such as debugging. Ephemeral containers have no resource or scheduling guarantees, and they will not be restarted when they exit or when a Pod is removed or restarted. The kubelet may evict a Pod if an ephemeral container causes the Pod to exceed its resource allocation.
 * To add an ephemeral container, use the ephemeralcontainers subresource of an existing Pod. Ephemeral containers may not be removed or restarted.
 * This is a beta feature available on clusters that haven't disabled the EphemeralContainers feature gate.
 *
 * @schema RunnerSetSpecTemplateSpecEphemeralContainers
 */
export interface RunnerSetSpecTemplateSpecEphemeralContainers {
  /**
   * Arguments to the entrypoint. The docker image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainers#args
   */
  readonly args?: string[];

  /**
   * Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainers#command
   */
  readonly command?: string[];

  /**
   * List of environment variables to set in the container. Cannot be updated.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainers#env
   */
  readonly env?: RunnerSetSpecTemplateSpecEphemeralContainersEnv[];

  /**
   * List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainers#envFrom
   */
  readonly envFrom?: RunnerSetSpecTemplateSpecEphemeralContainersEnvFrom[];

  /**
   * Docker image name. More info: https://kubernetes.io/docs/concepts/containers/images
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainers#image
   */
  readonly image?: string;

  /**
   * Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   *
   * @default Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   * @schema RunnerSetSpecTemplateSpecEphemeralContainers#imagePullPolicy
   */
  readonly imagePullPolicy?: string;

  /**
   * Lifecycle is not allowed for ephemeral containers.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainers#lifecycle
   */
  readonly lifecycle?: RunnerSetSpecTemplateSpecEphemeralContainersLifecycle;

  /**
   * Probes are not allowed for ephemeral containers.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainers#livenessProbe
   */
  readonly livenessProbe?: RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbe;

  /**
   * Name of the ephemeral container specified as a DNS_LABEL. This name must be unique among all containers, init containers and ephemeral containers.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainers#name
   */
  readonly name: string;

  /**
   * Ports are not allowed for ephemeral containers.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainers#ports
   */
  readonly ports?: RunnerSetSpecTemplateSpecEphemeralContainersPorts[];

  /**
   * Probes are not allowed for ephemeral containers.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainers#readinessProbe
   */
  readonly readinessProbe?: RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbe;

  /**
   * Resources are not allowed for ephemeral containers. Ephemeral containers use spare resources already allocated to the pod.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainers#resources
   */
  readonly resources?: RunnerSetSpecTemplateSpecEphemeralContainersResources;

  /**
   * Optional: SecurityContext defines the security options the ephemeral container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainers#securityContext
   */
  readonly securityContext?: RunnerSetSpecTemplateSpecEphemeralContainersSecurityContext;

  /**
   * Probes are not allowed for ephemeral containers.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainers#startupProbe
   */
  readonly startupProbe?: RunnerSetSpecTemplateSpecEphemeralContainersStartupProbe;

  /**
   * Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF. Default is false.
   *
   * @default false.
   * @schema RunnerSetSpecTemplateSpecEphemeralContainers#stdin
   */
  readonly stdin?: boolean;

  /**
   * Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false
   *
   * @default false
   * @schema RunnerSetSpecTemplateSpecEphemeralContainers#stdinOnce
   */
  readonly stdinOnce?: boolean;

  /**
   * If set, the name of the container from PodSpec that this ephemeral container targets. The ephemeral container will be run in the namespaces (IPC, PID, etc) of this container. If not set then the ephemeral container uses the namespaces configured in the Pod spec.
   * The container runtime must implement support for this feature. If the runtime does not support namespace targeting then the result of setting this field is undefined.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainers#targetContainerName
   */
  readonly targetContainerName?: string;

  /**
   * Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Will be truncated by the node if greater than 4096 bytes. The total message length across all containers will be limited to 12kb. Defaults to /dev/termination-log. Cannot be updated.
   *
   * @default dev/termination-log. Cannot be updated.
   * @schema RunnerSetSpecTemplateSpecEphemeralContainers#terminationMessagePath
   */
  readonly terminationMessagePath?: string;

  /**
   * Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.
   *
   * @default File. Cannot be updated.
   * @schema RunnerSetSpecTemplateSpecEphemeralContainers#terminationMessagePolicy
   */
  readonly terminationMessagePolicy?: string;

  /**
   * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true. Default is false.
   *
   * @default false.
   * @schema RunnerSetSpecTemplateSpecEphemeralContainers#tty
   */
  readonly tty?: boolean;

  /**
   * volumeDevices is the list of block devices to be used by the container.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainers#volumeDevices
   */
  readonly volumeDevices?: RunnerSetSpecTemplateSpecEphemeralContainersVolumeDevices[];

  /**
   * Pod volumes to mount into the container's filesystem. Subpath mounts are not allowed for ephemeral containers. Cannot be updated.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainers#volumeMounts
   */
  readonly volumeMounts?: RunnerSetSpecTemplateSpecEphemeralContainersVolumeMounts[];

  /**
   * Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainers#workingDir
   */
  readonly workingDir?: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecEphemeralContainers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecEphemeralContainers(obj: RunnerSetSpecTemplateSpecEphemeralContainers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'args': obj.args?.map(y => y),
    'command': obj.command?.map(y => y),
    'env': obj.env?.map(y => toJson_RunnerSetSpecTemplateSpecEphemeralContainersEnv(y)),
    'envFrom': obj.envFrom?.map(y => toJson_RunnerSetSpecTemplateSpecEphemeralContainersEnvFrom(y)),
    'image': obj.image,
    'imagePullPolicy': obj.imagePullPolicy,
    'lifecycle': toJson_RunnerSetSpecTemplateSpecEphemeralContainersLifecycle(obj.lifecycle),
    'livenessProbe': toJson_RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbe(obj.livenessProbe),
    'name': obj.name,
    'ports': obj.ports?.map(y => toJson_RunnerSetSpecTemplateSpecEphemeralContainersPorts(y)),
    'readinessProbe': toJson_RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbe(obj.readinessProbe),
    'resources': toJson_RunnerSetSpecTemplateSpecEphemeralContainersResources(obj.resources),
    'securityContext': toJson_RunnerSetSpecTemplateSpecEphemeralContainersSecurityContext(obj.securityContext),
    'startupProbe': toJson_RunnerSetSpecTemplateSpecEphemeralContainersStartupProbe(obj.startupProbe),
    'stdin': obj.stdin,
    'stdinOnce': obj.stdinOnce,
    'targetContainerName': obj.targetContainerName,
    'terminationMessagePath': obj.terminationMessagePath,
    'terminationMessagePolicy': obj.terminationMessagePolicy,
    'tty': obj.tty,
    'volumeDevices': obj.volumeDevices?.map(y => toJson_RunnerSetSpecTemplateSpecEphemeralContainersVolumeDevices(y)),
    'volumeMounts': obj.volumeMounts?.map(y => toJson_RunnerSetSpecTemplateSpecEphemeralContainersVolumeMounts(y)),
    'workingDir': obj.workingDir,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod's hosts file.
 *
 * @schema RunnerSetSpecTemplateSpecHostAliases
 */
export interface RunnerSetSpecTemplateSpecHostAliases {
  /**
   * Hostnames for the above IP address.
   *
   * @schema RunnerSetSpecTemplateSpecHostAliases#hostnames
   */
  readonly hostnames?: string[];

  /**
   * IP address of the host file entry.
   *
   * @schema RunnerSetSpecTemplateSpecHostAliases#ip
   */
  readonly ip?: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecHostAliases' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecHostAliases(obj: RunnerSetSpecTemplateSpecHostAliases | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostnames': obj.hostnames?.map(y => y),
    'ip': obj.ip,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
 *
 * @schema RunnerSetSpecTemplateSpecImagePullSecrets
 */
export interface RunnerSetSpecTemplateSpecImagePullSecrets {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerSetSpecTemplateSpecImagePullSecrets#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecImagePullSecrets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecImagePullSecrets(obj: RunnerSetSpecTemplateSpecImagePullSecrets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A single application container that you want to run within a pod.
 *
 * @schema RunnerSetSpecTemplateSpecInitContainers
 */
export interface RunnerSetSpecTemplateSpecInitContainers {
  /**
   * Arguments to the entrypoint. The docker image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema RunnerSetSpecTemplateSpecInitContainers#args
   */
  readonly args?: string[];

  /**
   * Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema RunnerSetSpecTemplateSpecInitContainers#command
   */
  readonly command?: string[];

  /**
   * List of environment variables to set in the container. Cannot be updated.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainers#env
   */
  readonly env?: RunnerSetSpecTemplateSpecInitContainersEnv[];

  /**
   * List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainers#envFrom
   */
  readonly envFrom?: RunnerSetSpecTemplateSpecInitContainersEnvFrom[];

  /**
   * Docker image name. More info: https://kubernetes.io/docs/concepts/containers/images This field is optional to allow higher level config management to default or override container images in workload controllers like Deployments and StatefulSets.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainers#image
   */
  readonly image?: string;

  /**
   * Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   *
   * @default Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   * @schema RunnerSetSpecTemplateSpecInitContainers#imagePullPolicy
   */
  readonly imagePullPolicy?: string;

  /**
   * Actions that the management system should take in response to container lifecycle events. Cannot be updated.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainers#lifecycle
   */
  readonly lifecycle?: RunnerSetSpecTemplateSpecInitContainersLifecycle;

  /**
   * Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerSetSpecTemplateSpecInitContainers#livenessProbe
   */
  readonly livenessProbe?: RunnerSetSpecTemplateSpecInitContainersLivenessProbe;

  /**
   * Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainers#name
   */
  readonly name: string;

  /**
   * List of ports to expose from the container. Exposing a port here gives the system additional information about the network connections a container uses, but is primarily informational. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default "0.0.0.0" address inside a container will be accessible from the network. Cannot be updated.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainers#ports
   */
  readonly ports?: RunnerSetSpecTemplateSpecInitContainersPorts[];

  /**
   * Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerSetSpecTemplateSpecInitContainers#readinessProbe
   */
  readonly readinessProbe?: RunnerSetSpecTemplateSpecInitContainersReadinessProbe;

  /**
   * Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema RunnerSetSpecTemplateSpecInitContainers#resources
   */
  readonly resources?: RunnerSetSpecTemplateSpecInitContainersResources;

  /**
   * SecurityContext defines the security options the container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
   *
   * @schema RunnerSetSpecTemplateSpecInitContainers#securityContext
   */
  readonly securityContext?: RunnerSetSpecTemplateSpecInitContainersSecurityContext;

  /**
   * StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerSetSpecTemplateSpecInitContainers#startupProbe
   */
  readonly startupProbe?: RunnerSetSpecTemplateSpecInitContainersStartupProbe;

  /**
   * Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF. Default is false.
   *
   * @default false.
   * @schema RunnerSetSpecTemplateSpecInitContainers#stdin
   */
  readonly stdin?: boolean;

  /**
   * Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false
   *
   * @default false
   * @schema RunnerSetSpecTemplateSpecInitContainers#stdinOnce
   */
  readonly stdinOnce?: boolean;

  /**
   * Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Will be truncated by the node if greater than 4096 bytes. The total message length across all containers will be limited to 12kb. Defaults to /dev/termination-log. Cannot be updated.
   *
   * @default dev/termination-log. Cannot be updated.
   * @schema RunnerSetSpecTemplateSpecInitContainers#terminationMessagePath
   */
  readonly terminationMessagePath?: string;

  /**
   * Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.
   *
   * @default File. Cannot be updated.
   * @schema RunnerSetSpecTemplateSpecInitContainers#terminationMessagePolicy
   */
  readonly terminationMessagePolicy?: string;

  /**
   * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true. Default is false.
   *
   * @default false.
   * @schema RunnerSetSpecTemplateSpecInitContainers#tty
   */
  readonly tty?: boolean;

  /**
   * volumeDevices is the list of block devices to be used by the container.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainers#volumeDevices
   */
  readonly volumeDevices?: RunnerSetSpecTemplateSpecInitContainersVolumeDevices[];

  /**
   * Pod volumes to mount into the container's filesystem. Cannot be updated.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainers#volumeMounts
   */
  readonly volumeMounts?: RunnerSetSpecTemplateSpecInitContainersVolumeMounts[];

  /**
   * Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainers#workingDir
   */
  readonly workingDir?: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecInitContainers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecInitContainers(obj: RunnerSetSpecTemplateSpecInitContainers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'args': obj.args?.map(y => y),
    'command': obj.command?.map(y => y),
    'env': obj.env?.map(y => toJson_RunnerSetSpecTemplateSpecInitContainersEnv(y)),
    'envFrom': obj.envFrom?.map(y => toJson_RunnerSetSpecTemplateSpecInitContainersEnvFrom(y)),
    'image': obj.image,
    'imagePullPolicy': obj.imagePullPolicy,
    'lifecycle': toJson_RunnerSetSpecTemplateSpecInitContainersLifecycle(obj.lifecycle),
    'livenessProbe': toJson_RunnerSetSpecTemplateSpecInitContainersLivenessProbe(obj.livenessProbe),
    'name': obj.name,
    'ports': obj.ports?.map(y => toJson_RunnerSetSpecTemplateSpecInitContainersPorts(y)),
    'readinessProbe': toJson_RunnerSetSpecTemplateSpecInitContainersReadinessProbe(obj.readinessProbe),
    'resources': toJson_RunnerSetSpecTemplateSpecInitContainersResources(obj.resources),
    'securityContext': toJson_RunnerSetSpecTemplateSpecInitContainersSecurityContext(obj.securityContext),
    'startupProbe': toJson_RunnerSetSpecTemplateSpecInitContainersStartupProbe(obj.startupProbe),
    'stdin': obj.stdin,
    'stdinOnce': obj.stdinOnce,
    'terminationMessagePath': obj.terminationMessagePath,
    'terminationMessagePolicy': obj.terminationMessagePolicy,
    'tty': obj.tty,
    'volumeDevices': obj.volumeDevices?.map(y => toJson_RunnerSetSpecTemplateSpecInitContainersVolumeDevices(y)),
    'volumeMounts': obj.volumeMounts?.map(y => toJson_RunnerSetSpecTemplateSpecInitContainersVolumeMounts(y)),
    'workingDir': obj.workingDir,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the OS of the containers in the pod. Some pod and container fields are restricted if this is set.
 * If the OS field is set to linux, the following fields must be unset: -securityContext.windowsOptions
 * If the OS field is set to windows, following fields must be unset: - spec.hostPID - spec.hostIPC - spec.securityContext.seLinuxOptions - spec.securityContext.seccompProfile - spec.securityContext.fsGroup - spec.securityContext.fsGroupChangePolicy - spec.securityContext.sysctls - spec.shareProcessNamespace - spec.securityContext.runAsUser - spec.securityContext.runAsGroup - spec.securityContext.supplementalGroups - spec.containers[*].securityContext.seLinuxOptions - spec.containers[*].securityContext.seccompProfile - spec.containers[*].securityContext.capabilities - spec.containers[*].securityContext.readOnlyRootFilesystem - spec.containers[*].securityContext.privileged - spec.containers[*].securityContext.allowPrivilegeEscalation - spec.containers[*].securityContext.procMount - spec.containers[*].securityContext.runAsUser - spec.containers[*].securityContext.runAsGroup This is an alpha field and requires the IdentifyPodOS feature
 *
 * @schema RunnerSetSpecTemplateSpecOs
 */
export interface RunnerSetSpecTemplateSpecOs {
  /**
   * Name is the name of the operating system. The currently supported values are linux and windows. Additional value may be defined in future and can be one of: https://github.com/opencontainers/runtime-spec/blob/master/config.md#platform-specific-configuration Clients should expect to handle additional values and treat unrecognized values in this field as os: null
   *
   * @schema RunnerSetSpecTemplateSpecOs#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecOs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecOs(obj: RunnerSetSpecTemplateSpecOs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RunnerSetSpecTemplateSpecOverhead
 */
export class RunnerSetSpecTemplateSpecOverhead {
  public static fromNumber(value: number): RunnerSetSpecTemplateSpecOverhead {
    return new RunnerSetSpecTemplateSpecOverhead(value);
  }
  public static fromString(value: string): RunnerSetSpecTemplateSpecOverhead {
    return new RunnerSetSpecTemplateSpecOverhead(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * PodReadinessGate contains the reference to a pod condition
 *
 * @schema RunnerSetSpecTemplateSpecReadinessGates
 */
export interface RunnerSetSpecTemplateSpecReadinessGates {
  /**
   * ConditionType refers to a condition in the pod's condition list with matching type.
   *
   * @schema RunnerSetSpecTemplateSpecReadinessGates#conditionType
   */
  readonly conditionType: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecReadinessGates' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecReadinessGates(obj: RunnerSetSpecTemplateSpecReadinessGates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conditionType': obj.conditionType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecurityContext holds pod-level security attributes and common container settings. Optional: Defaults to empty.  See type description for default values of each field.
 *
 * @default empty.  See type description for default values of each field.
 * @schema RunnerSetSpecTemplateSpecSecurityContext
 */
export interface RunnerSetSpecTemplateSpecSecurityContext {
  /**
   * A special supplemental group that applies to all containers in a pod. Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod:
   * 1. The owning GID will be the FSGroup 2. The setgid bit is set (new files created in the volume will be owned by FSGroup) 3. The permission bits are OR'd with rw-rw----
   * If unset, the Kubelet will not modify the ownership and permissions of any volume. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerSetSpecTemplateSpecSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * fsGroupChangePolicy defines behavior of changing ownership and permission of the volume before being exposed inside Pod. This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir. Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerSetSpecTemplateSpecSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerSetSpecTemplateSpecSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema RunnerSetSpecTemplateSpecSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   * @schema RunnerSetSpecTemplateSpecSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerSetSpecTemplateSpecSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: RunnerSetSpecTemplateSpecSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerSetSpecTemplateSpecSecurityContext#seccompProfile
   */
  readonly seccompProfile?: RunnerSetSpecTemplateSpecSecurityContextSeccompProfile;

  /**
   * A list of groups applied to the first process run in each container, in addition to the container's primary GID.  If unspecified, no groups will be added to any container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerSetSpecTemplateSpecSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported sysctls (by the container runtime) might fail to launch. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerSetSpecTemplateSpecSecurityContext#sysctls
   */
  readonly sysctls?: RunnerSetSpecTemplateSpecSecurityContextSysctls[];

  /**
   * The Windows specific settings applied to all containers. If unspecified, the options within a container's SecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema RunnerSetSpecTemplateSpecSecurityContext#windowsOptions
   */
  readonly windowsOptions?: RunnerSetSpecTemplateSpecSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecSecurityContext(obj: RunnerSetSpecTemplateSpecSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsGroup': obj.fsGroup,
    'fsGroupChangePolicy': obj.fsGroupChangePolicy,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_RunnerSetSpecTemplateSpecSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_RunnerSetSpecTemplateSpecSecurityContextSeccompProfile(obj.seccompProfile),
    'supplementalGroups': obj.supplementalGroups?.map(y => y),
    'sysctls': obj.sysctls?.map(y => toJson_RunnerSetSpecTemplateSpecSecurityContextSysctls(y)),
    'windowsOptions': toJson_RunnerSetSpecTemplateSpecSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema RunnerSetSpecTemplateSpecTolerations
 */
export interface RunnerSetSpecTemplateSpecTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema RunnerSetSpecTemplateSpecTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema RunnerSetSpecTemplateSpecTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
   *
   * @default Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
   * @schema RunnerSetSpecTemplateSpecTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema RunnerSetSpecTemplateSpecTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema RunnerSetSpecTemplateSpecTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecTolerations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecTolerations(obj: RunnerSetSpecTemplateSpecTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TopologySpreadConstraint specifies how to spread matching pods among the given topology.
 *
 * @schema RunnerSetSpecTemplateSpecTopologySpreadConstraints
 */
export interface RunnerSetSpecTemplateSpecTopologySpreadConstraints {
  /**
   * LabelSelector is used to find matching pods. Pods that match this label selector are counted to determine the number of pods in their corresponding topology domain.
   *
   * @schema RunnerSetSpecTemplateSpecTopologySpreadConstraints#labelSelector
   */
  readonly labelSelector?: RunnerSetSpecTemplateSpecTopologySpreadConstraintsLabelSelector;

  /**
   * MaxSkew describes the degree to which pods may be unevenly distributed. When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted difference between the number of matching pods in the target topology and the global minimum. For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same labelSelector spread as 1/1/0: | zone1 | zone2 | zone3 | |   P   |   P   |       | - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 1/1/1; scheduling it onto zone1(zone2) would make the ActualSkew(2-0) on zone1(zone2) violate MaxSkew(1). - if MaxSkew is 2, incoming pod can be scheduled onto any zone. When `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher precedence to topologies that satisfy it. It's a required field. Default value is 1 and 0 is not allowed.
   *
   * @schema RunnerSetSpecTemplateSpecTopologySpreadConstraints#maxSkew
   */
  readonly maxSkew: number;

  /**
   * TopologyKey is the key of node labels. Nodes that have a label with this key and identical values are considered to be in the same topology. We consider each <key, value> as a "bucket", and try to put balanced number of pods into each bucket. It's a required field.
   *
   * @schema RunnerSetSpecTemplateSpecTopologySpreadConstraints#topologyKey
   */
  readonly topologyKey: string;

  /**
   * WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy the spread constraint. - DoNotSchedule (default) tells the scheduler not to schedule it. - ScheduleAnyway tells the scheduler to schedule the pod in any location,   but giving higher precedence to topologies that would help reduce the   skew. A constraint is considered "Unsatisfiable" for an incoming pod if and only if every possible node assignment for that pod would violate "MaxSkew" on some topology. For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same labelSelector spread as 3/1/1: | zone1 | zone2 | zone3 | | P P P |   P   |   P   | If WhenUnsatisfiable is set to DoNotSchedule, incoming pod can only be scheduled to zone2(zone3) to become 3/2/1(3/1/2) as ActualSkew(2-1) on zone2(zone3) satisfies MaxSkew(1). In other words, the cluster can still be imbalanced, but scheduler won't make it *more* imbalanced. It's a required field.
   *
   * @schema RunnerSetSpecTemplateSpecTopologySpreadConstraints#whenUnsatisfiable
   */
  readonly whenUnsatisfiable: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecTopologySpreadConstraints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecTopologySpreadConstraints(obj: RunnerSetSpecTemplateSpecTopologySpreadConstraints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_RunnerSetSpecTemplateSpecTopologySpreadConstraintsLabelSelector(obj.labelSelector),
    'maxSkew': obj.maxSkew,
    'topologyKey': obj.topologyKey,
    'whenUnsatisfiable': obj.whenUnsatisfiable,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Volume represents a named volume in a pod that may be accessed by any container in the pod.
 *
 * @schema RunnerSetSpecTemplateSpecVolumes
 */
export interface RunnerSetSpecTemplateSpecVolumes {
  /**
   * AWSElasticBlockStore represents an AWS Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema RunnerSetSpecTemplateSpecVolumes#awsElasticBlockStore
   */
  readonly awsElasticBlockStore?: RunnerSetSpecTemplateSpecVolumesAwsElasticBlockStore;

  /**
   * AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
   *
   * @schema RunnerSetSpecTemplateSpecVolumes#azureDisk
   */
  readonly azureDisk?: RunnerSetSpecTemplateSpecVolumesAzureDisk;

  /**
   * AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
   *
   * @schema RunnerSetSpecTemplateSpecVolumes#azureFile
   */
  readonly azureFile?: RunnerSetSpecTemplateSpecVolumesAzureFile;

  /**
   * CephFS represents a Ceph FS mount on the host that shares a pod's lifetime
   *
   * @schema RunnerSetSpecTemplateSpecVolumes#cephfs
   */
  readonly cephfs?: RunnerSetSpecTemplateSpecVolumesCephfs;

  /**
   * Cinder represents a cinder volume attached and mounted on kubelets host machine. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema RunnerSetSpecTemplateSpecVolumes#cinder
   */
  readonly cinder?: RunnerSetSpecTemplateSpecVolumesCinder;

  /**
   * ConfigMap represents a configMap that should populate this volume
   *
   * @schema RunnerSetSpecTemplateSpecVolumes#configMap
   */
  readonly configMap?: RunnerSetSpecTemplateSpecVolumesConfigMap;

  /**
   * CSI (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers (Beta feature).
   *
   * @schema RunnerSetSpecTemplateSpecVolumes#csi
   */
  readonly csi?: RunnerSetSpecTemplateSpecVolumesCsi;

  /**
   * DownwardAPI represents downward API about the pod that should populate this volume
   *
   * @schema RunnerSetSpecTemplateSpecVolumes#downwardAPI
   */
  readonly downwardApi?: RunnerSetSpecTemplateSpecVolumesDownwardApi;

  /**
   * EmptyDir represents a temporary directory that shares a pod's lifetime. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema RunnerSetSpecTemplateSpecVolumes#emptyDir
   */
  readonly emptyDir?: RunnerSetSpecTemplateSpecVolumesEmptyDir;

  /**
   * Ephemeral represents a volume that is handled by a cluster storage driver. The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts, and deleted when the pod is removed.
   * Use this if: a) the volume is only needed while the pod runs, b) features of normal volumes like restoring from snapshot or capacity    tracking are needed, c) the storage driver is specified through a storage class, and d) the storage driver supports dynamic volume provisioning through    a PersistentVolumeClaim (see EphemeralVolumeSource for more    information on the connection between this volume type    and PersistentVolumeClaim).
   * Use PersistentVolumeClaim or one of the vendor-specific APIs for volumes that persist for longer than the lifecycle of an individual pod.
   * Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to be used that way - see the documentation of the driver for more information.
   * A pod can use both types of ephemeral volumes and persistent volumes at the same time.
   *
   * @schema RunnerSetSpecTemplateSpecVolumes#ephemeral
   */
  readonly ephemeral?: RunnerSetSpecTemplateSpecVolumesEphemeral;

  /**
   * FC represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
   *
   * @schema RunnerSetSpecTemplateSpecVolumes#fc
   */
  readonly fc?: RunnerSetSpecTemplateSpecVolumesFc;

  /**
   * FlexVolume represents a generic volume resource that is provisioned/attached using an exec based plugin.
   *
   * @schema RunnerSetSpecTemplateSpecVolumes#flexVolume
   */
  readonly flexVolume?: RunnerSetSpecTemplateSpecVolumesFlexVolume;

  /**
   * Flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running
   *
   * @schema RunnerSetSpecTemplateSpecVolumes#flocker
   */
  readonly flocker?: RunnerSetSpecTemplateSpecVolumesFlocker;

  /**
   * GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema RunnerSetSpecTemplateSpecVolumes#gcePersistentDisk
   */
  readonly gcePersistentDisk?: RunnerSetSpecTemplateSpecVolumesGcePersistentDisk;

  /**
   * GitRepo represents a git repository at a particular revision. DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir into the Pod's container.
   *
   * @schema RunnerSetSpecTemplateSpecVolumes#gitRepo
   */
  readonly gitRepo?: RunnerSetSpecTemplateSpecVolumesGitRepo;

  /**
   * Glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/glusterfs/README.md
   *
   * @schema RunnerSetSpecTemplateSpecVolumes#glusterfs
   */
  readonly glusterfs?: RunnerSetSpecTemplateSpecVolumesGlusterfs;

  /**
   * HostPath represents a pre-existing file or directory on the host machine that is directly exposed to the container. This is generally used for system agents or other privileged things that are allowed to see the host machine. Most containers will NOT need this. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath --- TODO(jonesdl) We need to restrict who can use host directory mounts and who can/can not mount host directories as read/write.
   *
   * @schema RunnerSetSpecTemplateSpecVolumes#hostPath
   */
  readonly hostPath?: RunnerSetSpecTemplateSpecVolumesHostPath;

  /**
   * ISCSI represents an ISCSI Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://examples.k8s.io/volumes/iscsi/README.md
   *
   * @schema RunnerSetSpecTemplateSpecVolumes#iscsi
   */
  readonly iscsi?: RunnerSetSpecTemplateSpecVolumesIscsi;

  /**
   * Volume's name. Must be a DNS_LABEL and unique within the pod. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema RunnerSetSpecTemplateSpecVolumes#name
   */
  readonly name: string;

  /**
   * NFS represents an NFS mount on the host that shares a pod's lifetime More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema RunnerSetSpecTemplateSpecVolumes#nfs
   */
  readonly nfs?: RunnerSetSpecTemplateSpecVolumesNfs;

  /**
   * PersistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in the same namespace. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema RunnerSetSpecTemplateSpecVolumes#persistentVolumeClaim
   */
  readonly persistentVolumeClaim?: RunnerSetSpecTemplateSpecVolumesPersistentVolumeClaim;

  /**
   * PhotonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
   *
   * @schema RunnerSetSpecTemplateSpecVolumes#photonPersistentDisk
   */
  readonly photonPersistentDisk?: RunnerSetSpecTemplateSpecVolumesPhotonPersistentDisk;

  /**
   * PortworxVolume represents a portworx volume attached and mounted on kubelets host machine
   *
   * @schema RunnerSetSpecTemplateSpecVolumes#portworxVolume
   */
  readonly portworxVolume?: RunnerSetSpecTemplateSpecVolumesPortworxVolume;

  /**
   * Items for all in one resources secrets, configmaps, and downward API
   *
   * @schema RunnerSetSpecTemplateSpecVolumes#projected
   */
  readonly projected?: RunnerSetSpecTemplateSpecVolumesProjected;

  /**
   * Quobyte represents a Quobyte mount on the host that shares a pod's lifetime
   *
   * @schema RunnerSetSpecTemplateSpecVolumes#quobyte
   */
  readonly quobyte?: RunnerSetSpecTemplateSpecVolumesQuobyte;

  /**
   * RBD represents a Rados Block Device mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/rbd/README.md
   *
   * @schema RunnerSetSpecTemplateSpecVolumes#rbd
   */
  readonly rbd?: RunnerSetSpecTemplateSpecVolumesRbd;

  /**
   * ScaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
   *
   * @schema RunnerSetSpecTemplateSpecVolumes#scaleIO
   */
  readonly scaleIo?: RunnerSetSpecTemplateSpecVolumesScaleIo;

  /**
   * Secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   *
   * @schema RunnerSetSpecTemplateSpecVolumes#secret
   */
  readonly secret?: RunnerSetSpecTemplateSpecVolumesSecret;

  /**
   * StorageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
   *
   * @schema RunnerSetSpecTemplateSpecVolumes#storageos
   */
  readonly storageos?: RunnerSetSpecTemplateSpecVolumesStorageos;

  /**
   * VsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
   *
   * @schema RunnerSetSpecTemplateSpecVolumes#vsphereVolume
   */
  readonly vsphereVolume?: RunnerSetSpecTemplateSpecVolumesVsphereVolume;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecVolumes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecVolumes(obj: RunnerSetSpecTemplateSpecVolumes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'awsElasticBlockStore': toJson_RunnerSetSpecTemplateSpecVolumesAwsElasticBlockStore(obj.awsElasticBlockStore),
    'azureDisk': toJson_RunnerSetSpecTemplateSpecVolumesAzureDisk(obj.azureDisk),
    'azureFile': toJson_RunnerSetSpecTemplateSpecVolumesAzureFile(obj.azureFile),
    'cephfs': toJson_RunnerSetSpecTemplateSpecVolumesCephfs(obj.cephfs),
    'cinder': toJson_RunnerSetSpecTemplateSpecVolumesCinder(obj.cinder),
    'configMap': toJson_RunnerSetSpecTemplateSpecVolumesConfigMap(obj.configMap),
    'csi': toJson_RunnerSetSpecTemplateSpecVolumesCsi(obj.csi),
    'downwardAPI': toJson_RunnerSetSpecTemplateSpecVolumesDownwardApi(obj.downwardApi),
    'emptyDir': toJson_RunnerSetSpecTemplateSpecVolumesEmptyDir(obj.emptyDir),
    'ephemeral': toJson_RunnerSetSpecTemplateSpecVolumesEphemeral(obj.ephemeral),
    'fc': toJson_RunnerSetSpecTemplateSpecVolumesFc(obj.fc),
    'flexVolume': toJson_RunnerSetSpecTemplateSpecVolumesFlexVolume(obj.flexVolume),
    'flocker': toJson_RunnerSetSpecTemplateSpecVolumesFlocker(obj.flocker),
    'gcePersistentDisk': toJson_RunnerSetSpecTemplateSpecVolumesGcePersistentDisk(obj.gcePersistentDisk),
    'gitRepo': toJson_RunnerSetSpecTemplateSpecVolumesGitRepo(obj.gitRepo),
    'glusterfs': toJson_RunnerSetSpecTemplateSpecVolumesGlusterfs(obj.glusterfs),
    'hostPath': toJson_RunnerSetSpecTemplateSpecVolumesHostPath(obj.hostPath),
    'iscsi': toJson_RunnerSetSpecTemplateSpecVolumesIscsi(obj.iscsi),
    'name': obj.name,
    'nfs': toJson_RunnerSetSpecTemplateSpecVolumesNfs(obj.nfs),
    'persistentVolumeClaim': toJson_RunnerSetSpecTemplateSpecVolumesPersistentVolumeClaim(obj.persistentVolumeClaim),
    'photonPersistentDisk': toJson_RunnerSetSpecTemplateSpecVolumesPhotonPersistentDisk(obj.photonPersistentDisk),
    'portworxVolume': toJson_RunnerSetSpecTemplateSpecVolumesPortworxVolume(obj.portworxVolume),
    'projected': toJson_RunnerSetSpecTemplateSpecVolumesProjected(obj.projected),
    'quobyte': toJson_RunnerSetSpecTemplateSpecVolumesQuobyte(obj.quobyte),
    'rbd': toJson_RunnerSetSpecTemplateSpecVolumesRbd(obj.rbd),
    'scaleIO': toJson_RunnerSetSpecTemplateSpecVolumesScaleIo(obj.scaleIo),
    'secret': toJson_RunnerSetSpecTemplateSpecVolumesSecret(obj.secret),
    'storageos': toJson_RunnerSetSpecTemplateSpecVolumesStorageos(obj.storageos),
    'vsphereVolume': toJson_RunnerSetSpecTemplateSpecVolumesVsphereVolume(obj.vsphereVolume),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * This field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. If the AnyVolumeDataSource feature gate is enabled, this field will always have the same contents as the DataSourceRef field.
 *
 * @schema RunnerSetSpecVolumeClaimTemplatesSpecDataSource
 */
export interface RunnerSetSpecVolumeClaimTemplatesSpecDataSource {
  /**
   * APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
   *
   * @schema RunnerSetSpecVolumeClaimTemplatesSpecDataSource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema RunnerSetSpecVolumeClaimTemplatesSpecDataSource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema RunnerSetSpecVolumeClaimTemplatesSpecDataSource#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RunnerSetSpecVolumeClaimTemplatesSpecDataSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecVolumeClaimTemplatesSpecDataSource(obj: RunnerSetSpecVolumeClaimTemplatesSpecDataSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any local object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the DataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, both fields (DataSource and DataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. There are two important differences between DataSource and DataSourceRef: * While DataSource only allows two specific types of objects, DataSourceRef   allows any non-core object, as well as PersistentVolumeClaim objects. * While DataSource ignores disallowed values (dropping them), DataSourceRef   preserves all values, and generates an error if a disallowed value is   specified. (Alpha) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
 *
 * @schema RunnerSetSpecVolumeClaimTemplatesSpecDataSourceRef
 */
export interface RunnerSetSpecVolumeClaimTemplatesSpecDataSourceRef {
  /**
   * APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
   *
   * @schema RunnerSetSpecVolumeClaimTemplatesSpecDataSourceRef#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema RunnerSetSpecVolumeClaimTemplatesSpecDataSourceRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema RunnerSetSpecVolumeClaimTemplatesSpecDataSourceRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RunnerSetSpecVolumeClaimTemplatesSpecDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecVolumeClaimTemplatesSpecDataSourceRef(obj: RunnerSetSpecVolumeClaimTemplatesSpecDataSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
 *
 * @schema RunnerSetSpecVolumeClaimTemplatesSpecResources
 */
export interface RunnerSetSpecVolumeClaimTemplatesSpecResources {
  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema RunnerSetSpecVolumeClaimTemplatesSpecResources#limits
   */
  readonly limits?: { [key: string]: RunnerSetSpecVolumeClaimTemplatesSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema RunnerSetSpecVolumeClaimTemplatesSpecResources#requests
   */
  readonly requests?: { [key: string]: RunnerSetSpecVolumeClaimTemplatesSpecResourcesRequests };

}

/**
 * Converts an object of type 'RunnerSetSpecVolumeClaimTemplatesSpecResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecVolumeClaimTemplatesSpecResources(obj: RunnerSetSpecVolumeClaimTemplatesSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over volumes to consider for binding.
 *
 * @schema RunnerSetSpecVolumeClaimTemplatesSpecSelector
 */
export interface RunnerSetSpecVolumeClaimTemplatesSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema RunnerSetSpecVolumeClaimTemplatesSpecSelector#matchExpressions
   */
  readonly matchExpressions?: RunnerSetSpecVolumeClaimTemplatesSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema RunnerSetSpecVolumeClaimTemplatesSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'RunnerSetSpecVolumeClaimTemplatesSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecVolumeClaimTemplatesSpecSelector(obj: RunnerSetSpecVolumeClaimTemplatesSpecSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_RunnerSetSpecVolumeClaimTemplatesSpecSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RunnerSetSpecVolumeClaimTemplatesStatusAllocatedResources
 */
export class RunnerSetSpecVolumeClaimTemplatesStatusAllocatedResources {
  public static fromNumber(value: number): RunnerSetSpecVolumeClaimTemplatesStatusAllocatedResources {
    return new RunnerSetSpecVolumeClaimTemplatesStatusAllocatedResources(value);
  }
  public static fromString(value: string): RunnerSetSpecVolumeClaimTemplatesStatusAllocatedResources {
    return new RunnerSetSpecVolumeClaimTemplatesStatusAllocatedResources(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * @schema RunnerSetSpecVolumeClaimTemplatesStatusCapacity
 */
export class RunnerSetSpecVolumeClaimTemplatesStatusCapacity {
  public static fromNumber(value: number): RunnerSetSpecVolumeClaimTemplatesStatusCapacity {
    return new RunnerSetSpecVolumeClaimTemplatesStatusCapacity(value);
  }
  public static fromString(value: string): RunnerSetSpecVolumeClaimTemplatesStatusCapacity {
    return new RunnerSetSpecVolumeClaimTemplatesStatusCapacity(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * PersistentVolumeClaimCondition contails details about state of pvc
 *
 * @schema RunnerSetSpecVolumeClaimTemplatesStatusConditions
 */
export interface RunnerSetSpecVolumeClaimTemplatesStatusConditions {
  /**
   * Last time we probed the condition.
   *
   * @schema RunnerSetSpecVolumeClaimTemplatesStatusConditions#lastProbeTime
   */
  readonly lastProbeTime?: Date;

  /**
   * Last time the condition transitioned from one status to another.
   *
   * @schema RunnerSetSpecVolumeClaimTemplatesStatusConditions#lastTransitionTime
   */
  readonly lastTransitionTime?: Date;

  /**
   * Human-readable message indicating details about last transition.
   *
   * @schema RunnerSetSpecVolumeClaimTemplatesStatusConditions#message
   */
  readonly message?: string;

  /**
   * Unique, this should be a short, machine understandable string that gives the reason for condition's last transition. If it reports "ResizeStarted" that means the underlying persistent volume is being resized.
   *
   * @schema RunnerSetSpecVolumeClaimTemplatesStatusConditions#reason
   */
  readonly reason?: string;

  /**
   * @schema RunnerSetSpecVolumeClaimTemplatesStatusConditions#status
   */
  readonly status: string;

  /**
   * PersistentVolumeClaimConditionType is a valid value of PersistentVolumeClaimCondition.Type
   *
   * @schema RunnerSetSpecVolumeClaimTemplatesStatusConditions#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'RunnerSetSpecVolumeClaimTemplatesStatusConditions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecVolumeClaimTemplatesStatusConditions(obj: RunnerSetSpecVolumeClaimTemplatesStatusConditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'lastProbeTime': obj.lastProbeTime?.toISOString(),
    'lastTransitionTime': obj.lastTransitionTime?.toISOString(),
    'message': obj.message,
    'reason': obj.reason,
    'status': obj.status,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Describes node affinity scheduling rules for the pod.
 *
 * @schema RunnerSetSpecTemplateSpecAffinityNodeAffinity
 */
export interface RunnerSetSpecTemplateSpecAffinityNodeAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the most preferred.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: RunnerSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: RunnerSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecAffinityNodeAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecAffinityNodeAffinity(obj: RunnerSetSpecTemplateSpecAffinityNodeAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_RunnerSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': toJson_RunnerSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj.requiredDuringSchedulingIgnoredDuringExecution),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
 *
 * @schema RunnerSetSpecTemplateSpecAffinityPodAffinity
 */
export interface RunnerSetSpecTemplateSpecAffinityPodAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: RunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: RunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecAffinityPodAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecAffinityPodAffinity(obj: RunnerSetSpecTemplateSpecAffinityPodAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_RunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_RunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
 *
 * @schema RunnerSetSpecTemplateSpecAffinityPodAntiAffinity
 */
export interface RunnerSetSpecTemplateSpecAffinityPodAntiAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: RunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: RunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecAffinityPodAntiAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecAffinityPodAntiAffinity(obj: RunnerSetSpecTemplateSpecAffinityPodAntiAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_RunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_RunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema RunnerSetSpecTemplateSpecContainersEnv
 */
export interface RunnerSetSpecTemplateSpecContainersEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema RunnerSetSpecTemplateSpecContainersEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded using the previously defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
   *
   * @default .
   * @schema RunnerSetSpecTemplateSpecContainersEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema RunnerSetSpecTemplateSpecContainersEnv#valueFrom
   */
  readonly valueFrom?: RunnerSetSpecTemplateSpecContainersEnvValueFrom;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecContainersEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecContainersEnv(obj: RunnerSetSpecTemplateSpecContainersEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
    'valueFrom': toJson_RunnerSetSpecTemplateSpecContainersEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema RunnerSetSpecTemplateSpecContainersEnvFrom
 */
export interface RunnerSetSpecTemplateSpecContainersEnvFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema RunnerSetSpecTemplateSpecContainersEnvFrom#configMapRef
   */
  readonly configMapRef?: RunnerSetSpecTemplateSpecContainersEnvFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema RunnerSetSpecTemplateSpecContainersEnvFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema RunnerSetSpecTemplateSpecContainersEnvFrom#secretRef
   */
  readonly secretRef?: RunnerSetSpecTemplateSpecContainersEnvFromSecretRef;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecContainersEnvFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecContainersEnvFrom(obj: RunnerSetSpecTemplateSpecContainersEnvFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapRef': toJson_RunnerSetSpecTemplateSpecContainersEnvFromConfigMapRef(obj.configMapRef),
    'prefix': obj.prefix,
    'secretRef': toJson_RunnerSetSpecTemplateSpecContainersEnvFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Actions that the management system should take in response to container lifecycle events. Cannot be updated.
 *
 * @schema RunnerSetSpecTemplateSpecContainersLifecycle
 */
export interface RunnerSetSpecTemplateSpecContainersLifecycle {
  /**
   * PostStart is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema RunnerSetSpecTemplateSpecContainersLifecycle#postStart
   */
  readonly postStart?: RunnerSetSpecTemplateSpecContainersLifecyclePostStart;

  /**
   * PreStop is called immediately before a container is terminated due to an API request or management event such as liveness/startup probe failure, preemption, resource contention, etc. The handler is not called if the container crashes or exits. The Pod's termination grace period countdown begins before the PreStop hook is executed. Regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period (unless delayed by finalizers). Other management of the container blocks until the hook completes or until the termination grace period is reached. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema RunnerSetSpecTemplateSpecContainersLifecycle#preStop
   */
  readonly preStop?: RunnerSetSpecTemplateSpecContainersLifecyclePreStop;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecContainersLifecycle' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecContainersLifecycle(obj: RunnerSetSpecTemplateSpecContainersLifecycle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'postStart': toJson_RunnerSetSpecTemplateSpecContainersLifecyclePostStart(obj.postStart),
    'preStop': toJson_RunnerSetSpecTemplateSpecContainersLifecyclePreStop(obj.preStop),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema RunnerSetSpecTemplateSpecContainersLivenessProbe
 */
export interface RunnerSetSpecTemplateSpecContainersLivenessProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema RunnerSetSpecTemplateSpecContainersLivenessProbe#exec
   */
  readonly exec?: RunnerSetSpecTemplateSpecContainersLivenessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema RunnerSetSpecTemplateSpecContainersLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
   *
   * @schema RunnerSetSpecTemplateSpecContainersLivenessProbe#grpc
   */
  readonly grpc?: RunnerSetSpecTemplateSpecContainersLivenessProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema RunnerSetSpecTemplateSpecContainersLivenessProbe#httpGet
   */
  readonly httpGet?: RunnerSetSpecTemplateSpecContainersLivenessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerSetSpecTemplateSpecContainersLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema RunnerSetSpecTemplateSpecContainersLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema RunnerSetSpecTemplateSpecContainersLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema RunnerSetSpecTemplateSpecContainersLivenessProbe#tcpSocket
   */
  readonly tcpSocket?: RunnerSetSpecTemplateSpecContainersLivenessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema RunnerSetSpecTemplateSpecContainersLivenessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema RunnerSetSpecTemplateSpecContainersLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecContainersLivenessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecContainersLivenessProbe(obj: RunnerSetSpecTemplateSpecContainersLivenessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_RunnerSetSpecTemplateSpecContainersLivenessProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_RunnerSetSpecTemplateSpecContainersLivenessProbeGrpc(obj.grpc),
    'httpGet': toJson_RunnerSetSpecTemplateSpecContainersLivenessProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_RunnerSetSpecTemplateSpecContainersLivenessProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ContainerPort represents a network port in a single container.
 *
 * @schema RunnerSetSpecTemplateSpecContainersPorts
 */
export interface RunnerSetSpecTemplateSpecContainersPorts {
  /**
   * Number of port to expose on the pod's IP address. This must be a valid port number, 0 < x < 65536.
   *
   * @schema RunnerSetSpecTemplateSpecContainersPorts#containerPort
   */
  readonly containerPort: number;

  /**
   * What host IP to bind the external port to.
   *
   * @schema RunnerSetSpecTemplateSpecContainersPorts#hostIP
   */
  readonly hostIp?: string;

  /**
   * Number of port to expose on the host. If specified, this must be a valid port number, 0 < x < 65536. If HostNetwork is specified, this must match ContainerPort. Most containers do not need this.
   *
   * @schema RunnerSetSpecTemplateSpecContainersPorts#hostPort
   */
  readonly hostPort?: number;

  /**
   * If specified, this must be an IANA_SVC_NAME and unique within the pod. Each named port in a pod must have a unique name. Name for the port that can be referred to by services.
   *
   * @schema RunnerSetSpecTemplateSpecContainersPorts#name
   */
  readonly name?: string;

  /**
   * Protocol for port. Must be UDP, TCP, or SCTP. Defaults to "TCP".
   *
   * @default TCP".
   * @schema RunnerSetSpecTemplateSpecContainersPorts#protocol
   */
  readonly protocol?: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecContainersPorts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecContainersPorts(obj: RunnerSetSpecTemplateSpecContainersPorts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerPort': obj.containerPort,
    'hostIP': obj.hostIp,
    'hostPort': obj.hostPort,
    'name': obj.name,
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema RunnerSetSpecTemplateSpecContainersReadinessProbe
 */
export interface RunnerSetSpecTemplateSpecContainersReadinessProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema RunnerSetSpecTemplateSpecContainersReadinessProbe#exec
   */
  readonly exec?: RunnerSetSpecTemplateSpecContainersReadinessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema RunnerSetSpecTemplateSpecContainersReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
   *
   * @schema RunnerSetSpecTemplateSpecContainersReadinessProbe#grpc
   */
  readonly grpc?: RunnerSetSpecTemplateSpecContainersReadinessProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema RunnerSetSpecTemplateSpecContainersReadinessProbe#httpGet
   */
  readonly httpGet?: RunnerSetSpecTemplateSpecContainersReadinessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerSetSpecTemplateSpecContainersReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema RunnerSetSpecTemplateSpecContainersReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema RunnerSetSpecTemplateSpecContainersReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema RunnerSetSpecTemplateSpecContainersReadinessProbe#tcpSocket
   */
  readonly tcpSocket?: RunnerSetSpecTemplateSpecContainersReadinessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema RunnerSetSpecTemplateSpecContainersReadinessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema RunnerSetSpecTemplateSpecContainersReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecContainersReadinessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecContainersReadinessProbe(obj: RunnerSetSpecTemplateSpecContainersReadinessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_RunnerSetSpecTemplateSpecContainersReadinessProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_RunnerSetSpecTemplateSpecContainersReadinessProbeGrpc(obj.grpc),
    'httpGet': toJson_RunnerSetSpecTemplateSpecContainersReadinessProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_RunnerSetSpecTemplateSpecContainersReadinessProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
 *
 * @schema RunnerSetSpecTemplateSpecContainersResources
 */
export interface RunnerSetSpecTemplateSpecContainersResources {
  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema RunnerSetSpecTemplateSpecContainersResources#limits
   */
  readonly limits?: { [key: string]: RunnerSetSpecTemplateSpecContainersResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema RunnerSetSpecTemplateSpecContainersResources#requests
   */
  readonly requests?: { [key: string]: RunnerSetSpecTemplateSpecContainersResourcesRequests };

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecContainersResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecContainersResources(obj: RunnerSetSpecTemplateSpecContainersResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecurityContext defines the security options the container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
 *
 * @schema RunnerSetSpecTemplateSpecContainersSecurityContext
 */
export interface RunnerSetSpecTemplateSpecContainersSecurityContext {
  /**
   * AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process. This bool directly controls if the no_new_privs flag will be set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP_SYS_ADMIN Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerSetSpecTemplateSpecContainersSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
   * @schema RunnerSetSpecTemplateSpecContainersSecurityContext#capabilities
   */
  readonly capabilities?: RunnerSetSpecTemplateSpecContainersSecurityContextCapabilities;

  /**
   * Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. Defaults to false. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false. Note that this field cannot be set when spec.os.name is windows.
   * @schema RunnerSetSpecTemplateSpecContainersSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * procMount denotes the type of proc mount to use for the containers. The default is DefaultProcMount which uses the container runtime defaults for readonly paths and masked paths. This requires the ProcMountType feature flag to be enabled. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerSetSpecTemplateSpecContainersSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * Whether this container has a read-only root filesystem. Default is false. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false. Note that this field cannot be set when spec.os.name is windows.
   * @schema RunnerSetSpecTemplateSpecContainersSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerSetSpecTemplateSpecContainersSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema RunnerSetSpecTemplateSpecContainersSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   * @schema RunnerSetSpecTemplateSpecContainersSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerSetSpecTemplateSpecContainersSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: RunnerSetSpecTemplateSpecContainersSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by this container. If seccomp options are provided at both the pod & container level, the container options override the pod options. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerSetSpecTemplateSpecContainersSecurityContext#seccompProfile
   */
  readonly seccompProfile?: RunnerSetSpecTemplateSpecContainersSecurityContextSeccompProfile;

  /**
   * The Windows specific settings applied to all containers. If unspecified, the options from the PodSecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema RunnerSetSpecTemplateSpecContainersSecurityContext#windowsOptions
   */
  readonly windowsOptions?: RunnerSetSpecTemplateSpecContainersSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecContainersSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecContainersSecurityContext(obj: RunnerSetSpecTemplateSpecContainersSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowPrivilegeEscalation': obj.allowPrivilegeEscalation,
    'capabilities': toJson_RunnerSetSpecTemplateSpecContainersSecurityContextCapabilities(obj.capabilities),
    'privileged': obj.privileged,
    'procMount': obj.procMount,
    'readOnlyRootFilesystem': obj.readOnlyRootFilesystem,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_RunnerSetSpecTemplateSpecContainersSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_RunnerSetSpecTemplateSpecContainersSecurityContextSeccompProfile(obj.seccompProfile),
    'windowsOptions': toJson_RunnerSetSpecTemplateSpecContainersSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema RunnerSetSpecTemplateSpecContainersStartupProbe
 */
export interface RunnerSetSpecTemplateSpecContainersStartupProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema RunnerSetSpecTemplateSpecContainersStartupProbe#exec
   */
  readonly exec?: RunnerSetSpecTemplateSpecContainersStartupProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema RunnerSetSpecTemplateSpecContainersStartupProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
   *
   * @schema RunnerSetSpecTemplateSpecContainersStartupProbe#grpc
   */
  readonly grpc?: RunnerSetSpecTemplateSpecContainersStartupProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema RunnerSetSpecTemplateSpecContainersStartupProbe#httpGet
   */
  readonly httpGet?: RunnerSetSpecTemplateSpecContainersStartupProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerSetSpecTemplateSpecContainersStartupProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema RunnerSetSpecTemplateSpecContainersStartupProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema RunnerSetSpecTemplateSpecContainersStartupProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema RunnerSetSpecTemplateSpecContainersStartupProbe#tcpSocket
   */
  readonly tcpSocket?: RunnerSetSpecTemplateSpecContainersStartupProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema RunnerSetSpecTemplateSpecContainersStartupProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema RunnerSetSpecTemplateSpecContainersStartupProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecContainersStartupProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecContainersStartupProbe(obj: RunnerSetSpecTemplateSpecContainersStartupProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_RunnerSetSpecTemplateSpecContainersStartupProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_RunnerSetSpecTemplateSpecContainersStartupProbeGrpc(obj.grpc),
    'httpGet': toJson_RunnerSetSpecTemplateSpecContainersStartupProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_RunnerSetSpecTemplateSpecContainersStartupProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * volumeDevice describes a mapping of a raw block device within a container.
 *
 * @schema RunnerSetSpecTemplateSpecContainersVolumeDevices
 */
export interface RunnerSetSpecTemplateSpecContainersVolumeDevices {
  /**
   * devicePath is the path inside of the container that the device will be mapped to.
   *
   * @schema RunnerSetSpecTemplateSpecContainersVolumeDevices#devicePath
   */
  readonly devicePath: string;

  /**
   * name must match the name of a persistentVolumeClaim in the pod
   *
   * @schema RunnerSetSpecTemplateSpecContainersVolumeDevices#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecContainersVolumeDevices' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecContainersVolumeDevices(obj: RunnerSetSpecTemplateSpecContainersVolumeDevices | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'devicePath': obj.devicePath,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema RunnerSetSpecTemplateSpecContainersVolumeMounts
 */
export interface RunnerSetSpecTemplateSpecContainersVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must not contain ':'.
   *
   * @schema RunnerSetSpecTemplateSpecContainersVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. This field is beta in 1.10.
   *
   * @schema RunnerSetSpecTemplateSpecContainersVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema RunnerSetSpecTemplateSpecContainersVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.
   *
   * @default false.
   * @schema RunnerSetSpecTemplateSpecContainersVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema RunnerSetSpecTemplateSpecContainersVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment. Defaults to "" (volume's root). SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root). SubPathExpr and SubPath are mutually exclusive.
   * @schema RunnerSetSpecTemplateSpecContainersVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecContainersVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecContainersVolumeMounts(obj: RunnerSetSpecTemplateSpecContainersVolumeMounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'mountPropagation': obj.mountPropagation,
    'name': obj.name,
    'readOnly': obj.readOnly,
    'subPath': obj.subPath,
    'subPathExpr': obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PodDNSConfigOption defines DNS resolver options of a pod.
 *
 * @schema RunnerSetSpecTemplateSpecDnsConfigOptions
 */
export interface RunnerSetSpecTemplateSpecDnsConfigOptions {
  /**
   * Required.
   *
   * @schema RunnerSetSpecTemplateSpecDnsConfigOptions#name
   */
  readonly name?: string;

  /**
   * @schema RunnerSetSpecTemplateSpecDnsConfigOptions#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecDnsConfigOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecDnsConfigOptions(obj: RunnerSetSpecTemplateSpecDnsConfigOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema RunnerSetSpecTemplateSpecEphemeralContainersEnv
 */
export interface RunnerSetSpecTemplateSpecEphemeralContainersEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded using the previously defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
   *
   * @default .
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersEnv#valueFrom
   */
  readonly valueFrom?: RunnerSetSpecTemplateSpecEphemeralContainersEnvValueFrom;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecEphemeralContainersEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecEphemeralContainersEnv(obj: RunnerSetSpecTemplateSpecEphemeralContainersEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
    'valueFrom': toJson_RunnerSetSpecTemplateSpecEphemeralContainersEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema RunnerSetSpecTemplateSpecEphemeralContainersEnvFrom
 */
export interface RunnerSetSpecTemplateSpecEphemeralContainersEnvFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersEnvFrom#configMapRef
   */
  readonly configMapRef?: RunnerSetSpecTemplateSpecEphemeralContainersEnvFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersEnvFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersEnvFrom#secretRef
   */
  readonly secretRef?: RunnerSetSpecTemplateSpecEphemeralContainersEnvFromSecretRef;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecEphemeralContainersEnvFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecEphemeralContainersEnvFrom(obj: RunnerSetSpecTemplateSpecEphemeralContainersEnvFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapRef': toJson_RunnerSetSpecTemplateSpecEphemeralContainersEnvFromConfigMapRef(obj.configMapRef),
    'prefix': obj.prefix,
    'secretRef': toJson_RunnerSetSpecTemplateSpecEphemeralContainersEnvFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Lifecycle is not allowed for ephemeral containers.
 *
 * @schema RunnerSetSpecTemplateSpecEphemeralContainersLifecycle
 */
export interface RunnerSetSpecTemplateSpecEphemeralContainersLifecycle {
  /**
   * PostStart is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersLifecycle#postStart
   */
  readonly postStart?: RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStart;

  /**
   * PreStop is called immediately before a container is terminated due to an API request or management event such as liveness/startup probe failure, preemption, resource contention, etc. The handler is not called if the container crashes or exits. The Pod's termination grace period countdown begins before the PreStop hook is executed. Regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period (unless delayed by finalizers). Other management of the container blocks until the hook completes or until the termination grace period is reached. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersLifecycle#preStop
   */
  readonly preStop?: RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStop;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecEphemeralContainersLifecycle' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecEphemeralContainersLifecycle(obj: RunnerSetSpecTemplateSpecEphemeralContainersLifecycle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'postStart': toJson_RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStart(obj.postStart),
    'preStop': toJson_RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStop(obj.preStop),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Probes are not allowed for ephemeral containers.
 *
 * @schema RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbe
 */
export interface RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbe#exec
   */
  readonly exec?: RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbe#grpc
   */
  readonly grpc?: RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbe#httpGet
   */
  readonly httpGet?: RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbe#tcpSocket
   */
  readonly tcpSocket?: RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbe(obj: RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeGrpc(obj.grpc),
    'httpGet': toJson_RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ContainerPort represents a network port in a single container.
 *
 * @schema RunnerSetSpecTemplateSpecEphemeralContainersPorts
 */
export interface RunnerSetSpecTemplateSpecEphemeralContainersPorts {
  /**
   * Number of port to expose on the pod's IP address. This must be a valid port number, 0 < x < 65536.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersPorts#containerPort
   */
  readonly containerPort: number;

  /**
   * What host IP to bind the external port to.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersPorts#hostIP
   */
  readonly hostIp?: string;

  /**
   * Number of port to expose on the host. If specified, this must be a valid port number, 0 < x < 65536. If HostNetwork is specified, this must match ContainerPort. Most containers do not need this.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersPorts#hostPort
   */
  readonly hostPort?: number;

  /**
   * If specified, this must be an IANA_SVC_NAME and unique within the pod. Each named port in a pod must have a unique name. Name for the port that can be referred to by services.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersPorts#name
   */
  readonly name?: string;

  /**
   * Protocol for port. Must be UDP, TCP, or SCTP. Defaults to "TCP".
   *
   * @default TCP".
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersPorts#protocol
   */
  readonly protocol?: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecEphemeralContainersPorts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecEphemeralContainersPorts(obj: RunnerSetSpecTemplateSpecEphemeralContainersPorts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerPort': obj.containerPort,
    'hostIP': obj.hostIp,
    'hostPort': obj.hostPort,
    'name': obj.name,
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Probes are not allowed for ephemeral containers.
 *
 * @schema RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbe
 */
export interface RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbe#exec
   */
  readonly exec?: RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbe#grpc
   */
  readonly grpc?: RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbe#httpGet
   */
  readonly httpGet?: RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbe#tcpSocket
   */
  readonly tcpSocket?: RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbe(obj: RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeGrpc(obj.grpc),
    'httpGet': toJson_RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resources are not allowed for ephemeral containers. Ephemeral containers use spare resources already allocated to the pod.
 *
 * @schema RunnerSetSpecTemplateSpecEphemeralContainersResources
 */
export interface RunnerSetSpecTemplateSpecEphemeralContainersResources {
  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersResources#limits
   */
  readonly limits?: { [key: string]: RunnerSetSpecTemplateSpecEphemeralContainersResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersResources#requests
   */
  readonly requests?: { [key: string]: RunnerSetSpecTemplateSpecEphemeralContainersResourcesRequests };

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecEphemeralContainersResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecEphemeralContainersResources(obj: RunnerSetSpecTemplateSpecEphemeralContainersResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Optional: SecurityContext defines the security options the ephemeral container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
 *
 * @schema RunnerSetSpecTemplateSpecEphemeralContainersSecurityContext
 */
export interface RunnerSetSpecTemplateSpecEphemeralContainersSecurityContext {
  /**
   * AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process. This bool directly controls if the no_new_privs flag will be set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP_SYS_ADMIN Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersSecurityContext#capabilities
   */
  readonly capabilities?: RunnerSetSpecTemplateSpecEphemeralContainersSecurityContextCapabilities;

  /**
   * Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. Defaults to false. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false. Note that this field cannot be set when spec.os.name is windows.
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * procMount denotes the type of proc mount to use for the containers. The default is DefaultProcMount which uses the container runtime defaults for readonly paths and masked paths. This requires the ProcMountType feature flag to be enabled. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * Whether this container has a read-only root filesystem. Default is false. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false. Note that this field cannot be set when spec.os.name is windows.
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: RunnerSetSpecTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by this container. If seccomp options are provided at both the pod & container level, the container options override the pod options. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersSecurityContext#seccompProfile
   */
  readonly seccompProfile?: RunnerSetSpecTemplateSpecEphemeralContainersSecurityContextSeccompProfile;

  /**
   * The Windows specific settings applied to all containers. If unspecified, the options from the PodSecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersSecurityContext#windowsOptions
   */
  readonly windowsOptions?: RunnerSetSpecTemplateSpecEphemeralContainersSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecEphemeralContainersSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecEphemeralContainersSecurityContext(obj: RunnerSetSpecTemplateSpecEphemeralContainersSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowPrivilegeEscalation': obj.allowPrivilegeEscalation,
    'capabilities': toJson_RunnerSetSpecTemplateSpecEphemeralContainersSecurityContextCapabilities(obj.capabilities),
    'privileged': obj.privileged,
    'procMount': obj.procMount,
    'readOnlyRootFilesystem': obj.readOnlyRootFilesystem,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_RunnerSetSpecTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_RunnerSetSpecTemplateSpecEphemeralContainersSecurityContextSeccompProfile(obj.seccompProfile),
    'windowsOptions': toJson_RunnerSetSpecTemplateSpecEphemeralContainersSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Probes are not allowed for ephemeral containers.
 *
 * @schema RunnerSetSpecTemplateSpecEphemeralContainersStartupProbe
 */
export interface RunnerSetSpecTemplateSpecEphemeralContainersStartupProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersStartupProbe#exec
   */
  readonly exec?: RunnerSetSpecTemplateSpecEphemeralContainersStartupProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersStartupProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersStartupProbe#grpc
   */
  readonly grpc?: RunnerSetSpecTemplateSpecEphemeralContainersStartupProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersStartupProbe#httpGet
   */
  readonly httpGet?: RunnerSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersStartupProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersStartupProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersStartupProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersStartupProbe#tcpSocket
   */
  readonly tcpSocket?: RunnerSetSpecTemplateSpecEphemeralContainersStartupProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersStartupProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersStartupProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecEphemeralContainersStartupProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecEphemeralContainersStartupProbe(obj: RunnerSetSpecTemplateSpecEphemeralContainersStartupProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_RunnerSetSpecTemplateSpecEphemeralContainersStartupProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_RunnerSetSpecTemplateSpecEphemeralContainersStartupProbeGrpc(obj.grpc),
    'httpGet': toJson_RunnerSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_RunnerSetSpecTemplateSpecEphemeralContainersStartupProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * volumeDevice describes a mapping of a raw block device within a container.
 *
 * @schema RunnerSetSpecTemplateSpecEphemeralContainersVolumeDevices
 */
export interface RunnerSetSpecTemplateSpecEphemeralContainersVolumeDevices {
  /**
   * devicePath is the path inside of the container that the device will be mapped to.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersVolumeDevices#devicePath
   */
  readonly devicePath: string;

  /**
   * name must match the name of a persistentVolumeClaim in the pod
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersVolumeDevices#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecEphemeralContainersVolumeDevices' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecEphemeralContainersVolumeDevices(obj: RunnerSetSpecTemplateSpecEphemeralContainersVolumeDevices | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'devicePath': obj.devicePath,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema RunnerSetSpecTemplateSpecEphemeralContainersVolumeMounts
 */
export interface RunnerSetSpecTemplateSpecEphemeralContainersVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must not contain ':'.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. This field is beta in 1.10.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.
   *
   * @default false.
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment. Defaults to "" (volume's root). SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root). SubPathExpr and SubPath are mutually exclusive.
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecEphemeralContainersVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecEphemeralContainersVolumeMounts(obj: RunnerSetSpecTemplateSpecEphemeralContainersVolumeMounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'mountPropagation': obj.mountPropagation,
    'name': obj.name,
    'readOnly': obj.readOnly,
    'subPath': obj.subPath,
    'subPathExpr': obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema RunnerSetSpecTemplateSpecInitContainersEnv
 */
export interface RunnerSetSpecTemplateSpecInitContainersEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded using the previously defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
   *
   * @default .
   * @schema RunnerSetSpecTemplateSpecInitContainersEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersEnv#valueFrom
   */
  readonly valueFrom?: RunnerSetSpecTemplateSpecInitContainersEnvValueFrom;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecInitContainersEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecInitContainersEnv(obj: RunnerSetSpecTemplateSpecInitContainersEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
    'valueFrom': toJson_RunnerSetSpecTemplateSpecInitContainersEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema RunnerSetSpecTemplateSpecInitContainersEnvFrom
 */
export interface RunnerSetSpecTemplateSpecInitContainersEnvFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersEnvFrom#configMapRef
   */
  readonly configMapRef?: RunnerSetSpecTemplateSpecInitContainersEnvFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersEnvFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersEnvFrom#secretRef
   */
  readonly secretRef?: RunnerSetSpecTemplateSpecInitContainersEnvFromSecretRef;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecInitContainersEnvFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecInitContainersEnvFrom(obj: RunnerSetSpecTemplateSpecInitContainersEnvFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapRef': toJson_RunnerSetSpecTemplateSpecInitContainersEnvFromConfigMapRef(obj.configMapRef),
    'prefix': obj.prefix,
    'secretRef': toJson_RunnerSetSpecTemplateSpecInitContainersEnvFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Actions that the management system should take in response to container lifecycle events. Cannot be updated.
 *
 * @schema RunnerSetSpecTemplateSpecInitContainersLifecycle
 */
export interface RunnerSetSpecTemplateSpecInitContainersLifecycle {
  /**
   * PostStart is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersLifecycle#postStart
   */
  readonly postStart?: RunnerSetSpecTemplateSpecInitContainersLifecyclePostStart;

  /**
   * PreStop is called immediately before a container is terminated due to an API request or management event such as liveness/startup probe failure, preemption, resource contention, etc. The handler is not called if the container crashes or exits. The Pod's termination grace period countdown begins before the PreStop hook is executed. Regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period (unless delayed by finalizers). Other management of the container blocks until the hook completes or until the termination grace period is reached. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersLifecycle#preStop
   */
  readonly preStop?: RunnerSetSpecTemplateSpecInitContainersLifecyclePreStop;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecInitContainersLifecycle' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecInitContainersLifecycle(obj: RunnerSetSpecTemplateSpecInitContainersLifecycle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'postStart': toJson_RunnerSetSpecTemplateSpecInitContainersLifecyclePostStart(obj.postStart),
    'preStop': toJson_RunnerSetSpecTemplateSpecInitContainersLifecyclePreStop(obj.preStop),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema RunnerSetSpecTemplateSpecInitContainersLivenessProbe
 */
export interface RunnerSetSpecTemplateSpecInitContainersLivenessProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersLivenessProbe#exec
   */
  readonly exec?: RunnerSetSpecTemplateSpecInitContainersLivenessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema RunnerSetSpecTemplateSpecInitContainersLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersLivenessProbe#grpc
   */
  readonly grpc?: RunnerSetSpecTemplateSpecInitContainersLivenessProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersLivenessProbe#httpGet
   */
  readonly httpGet?: RunnerSetSpecTemplateSpecInitContainersLivenessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema RunnerSetSpecTemplateSpecInitContainersLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema RunnerSetSpecTemplateSpecInitContainersLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersLivenessProbe#tcpSocket
   */
  readonly tcpSocket?: RunnerSetSpecTemplateSpecInitContainersLivenessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersLivenessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema RunnerSetSpecTemplateSpecInitContainersLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecInitContainersLivenessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecInitContainersLivenessProbe(obj: RunnerSetSpecTemplateSpecInitContainersLivenessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_RunnerSetSpecTemplateSpecInitContainersLivenessProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_RunnerSetSpecTemplateSpecInitContainersLivenessProbeGrpc(obj.grpc),
    'httpGet': toJson_RunnerSetSpecTemplateSpecInitContainersLivenessProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_RunnerSetSpecTemplateSpecInitContainersLivenessProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ContainerPort represents a network port in a single container.
 *
 * @schema RunnerSetSpecTemplateSpecInitContainersPorts
 */
export interface RunnerSetSpecTemplateSpecInitContainersPorts {
  /**
   * Number of port to expose on the pod's IP address. This must be a valid port number, 0 < x < 65536.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersPorts#containerPort
   */
  readonly containerPort: number;

  /**
   * What host IP to bind the external port to.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersPorts#hostIP
   */
  readonly hostIp?: string;

  /**
   * Number of port to expose on the host. If specified, this must be a valid port number, 0 < x < 65536. If HostNetwork is specified, this must match ContainerPort. Most containers do not need this.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersPorts#hostPort
   */
  readonly hostPort?: number;

  /**
   * If specified, this must be an IANA_SVC_NAME and unique within the pod. Each named port in a pod must have a unique name. Name for the port that can be referred to by services.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersPorts#name
   */
  readonly name?: string;

  /**
   * Protocol for port. Must be UDP, TCP, or SCTP. Defaults to "TCP".
   *
   * @default TCP".
   * @schema RunnerSetSpecTemplateSpecInitContainersPorts#protocol
   */
  readonly protocol?: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecInitContainersPorts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecInitContainersPorts(obj: RunnerSetSpecTemplateSpecInitContainersPorts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerPort': obj.containerPort,
    'hostIP': obj.hostIp,
    'hostPort': obj.hostPort,
    'name': obj.name,
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema RunnerSetSpecTemplateSpecInitContainersReadinessProbe
 */
export interface RunnerSetSpecTemplateSpecInitContainersReadinessProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersReadinessProbe#exec
   */
  readonly exec?: RunnerSetSpecTemplateSpecInitContainersReadinessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema RunnerSetSpecTemplateSpecInitContainersReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersReadinessProbe#grpc
   */
  readonly grpc?: RunnerSetSpecTemplateSpecInitContainersReadinessProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersReadinessProbe#httpGet
   */
  readonly httpGet?: RunnerSetSpecTemplateSpecInitContainersReadinessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema RunnerSetSpecTemplateSpecInitContainersReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema RunnerSetSpecTemplateSpecInitContainersReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersReadinessProbe#tcpSocket
   */
  readonly tcpSocket?: RunnerSetSpecTemplateSpecInitContainersReadinessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersReadinessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema RunnerSetSpecTemplateSpecInitContainersReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecInitContainersReadinessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecInitContainersReadinessProbe(obj: RunnerSetSpecTemplateSpecInitContainersReadinessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_RunnerSetSpecTemplateSpecInitContainersReadinessProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_RunnerSetSpecTemplateSpecInitContainersReadinessProbeGrpc(obj.grpc),
    'httpGet': toJson_RunnerSetSpecTemplateSpecInitContainersReadinessProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_RunnerSetSpecTemplateSpecInitContainersReadinessProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
 *
 * @schema RunnerSetSpecTemplateSpecInitContainersResources
 */
export interface RunnerSetSpecTemplateSpecInitContainersResources {
  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersResources#limits
   */
  readonly limits?: { [key: string]: RunnerSetSpecTemplateSpecInitContainersResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersResources#requests
   */
  readonly requests?: { [key: string]: RunnerSetSpecTemplateSpecInitContainersResourcesRequests };

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecInitContainersResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecInitContainersResources(obj: RunnerSetSpecTemplateSpecInitContainersResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecurityContext defines the security options the container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
 *
 * @schema RunnerSetSpecTemplateSpecInitContainersSecurityContext
 */
export interface RunnerSetSpecTemplateSpecInitContainersSecurityContext {
  /**
   * AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process. This bool directly controls if the no_new_privs flag will be set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP_SYS_ADMIN Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
   * @schema RunnerSetSpecTemplateSpecInitContainersSecurityContext#capabilities
   */
  readonly capabilities?: RunnerSetSpecTemplateSpecInitContainersSecurityContextCapabilities;

  /**
   * Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. Defaults to false. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false. Note that this field cannot be set when spec.os.name is windows.
   * @schema RunnerSetSpecTemplateSpecInitContainersSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * procMount denotes the type of proc mount to use for the containers. The default is DefaultProcMount which uses the container runtime defaults for readonly paths and masked paths. This requires the ProcMountType feature flag to be enabled. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * Whether this container has a read-only root filesystem. Default is false. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false. Note that this field cannot be set when spec.os.name is windows.
   * @schema RunnerSetSpecTemplateSpecInitContainersSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   * @schema RunnerSetSpecTemplateSpecInitContainersSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: RunnerSetSpecTemplateSpecInitContainersSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by this container. If seccomp options are provided at both the pod & container level, the container options override the pod options. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersSecurityContext#seccompProfile
   */
  readonly seccompProfile?: RunnerSetSpecTemplateSpecInitContainersSecurityContextSeccompProfile;

  /**
   * The Windows specific settings applied to all containers. If unspecified, the options from the PodSecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersSecurityContext#windowsOptions
   */
  readonly windowsOptions?: RunnerSetSpecTemplateSpecInitContainersSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecInitContainersSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecInitContainersSecurityContext(obj: RunnerSetSpecTemplateSpecInitContainersSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowPrivilegeEscalation': obj.allowPrivilegeEscalation,
    'capabilities': toJson_RunnerSetSpecTemplateSpecInitContainersSecurityContextCapabilities(obj.capabilities),
    'privileged': obj.privileged,
    'procMount': obj.procMount,
    'readOnlyRootFilesystem': obj.readOnlyRootFilesystem,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_RunnerSetSpecTemplateSpecInitContainersSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_RunnerSetSpecTemplateSpecInitContainersSecurityContextSeccompProfile(obj.seccompProfile),
    'windowsOptions': toJson_RunnerSetSpecTemplateSpecInitContainersSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema RunnerSetSpecTemplateSpecInitContainersStartupProbe
 */
export interface RunnerSetSpecTemplateSpecInitContainersStartupProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersStartupProbe#exec
   */
  readonly exec?: RunnerSetSpecTemplateSpecInitContainersStartupProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema RunnerSetSpecTemplateSpecInitContainersStartupProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersStartupProbe#grpc
   */
  readonly grpc?: RunnerSetSpecTemplateSpecInitContainersStartupProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersStartupProbe#httpGet
   */
  readonly httpGet?: RunnerSetSpecTemplateSpecInitContainersStartupProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersStartupProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema RunnerSetSpecTemplateSpecInitContainersStartupProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema RunnerSetSpecTemplateSpecInitContainersStartupProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersStartupProbe#tcpSocket
   */
  readonly tcpSocket?: RunnerSetSpecTemplateSpecInitContainersStartupProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersStartupProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema RunnerSetSpecTemplateSpecInitContainersStartupProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecInitContainersStartupProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecInitContainersStartupProbe(obj: RunnerSetSpecTemplateSpecInitContainersStartupProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_RunnerSetSpecTemplateSpecInitContainersStartupProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_RunnerSetSpecTemplateSpecInitContainersStartupProbeGrpc(obj.grpc),
    'httpGet': toJson_RunnerSetSpecTemplateSpecInitContainersStartupProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_RunnerSetSpecTemplateSpecInitContainersStartupProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * volumeDevice describes a mapping of a raw block device within a container.
 *
 * @schema RunnerSetSpecTemplateSpecInitContainersVolumeDevices
 */
export interface RunnerSetSpecTemplateSpecInitContainersVolumeDevices {
  /**
   * devicePath is the path inside of the container that the device will be mapped to.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersVolumeDevices#devicePath
   */
  readonly devicePath: string;

  /**
   * name must match the name of a persistentVolumeClaim in the pod
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersVolumeDevices#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecInitContainersVolumeDevices' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecInitContainersVolumeDevices(obj: RunnerSetSpecTemplateSpecInitContainersVolumeDevices | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'devicePath': obj.devicePath,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema RunnerSetSpecTemplateSpecInitContainersVolumeMounts
 */
export interface RunnerSetSpecTemplateSpecInitContainersVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must not contain ':'.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. This field is beta in 1.10.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.
   *
   * @default false.
   * @schema RunnerSetSpecTemplateSpecInitContainersVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema RunnerSetSpecTemplateSpecInitContainersVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment. Defaults to "" (volume's root). SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root). SubPathExpr and SubPath are mutually exclusive.
   * @schema RunnerSetSpecTemplateSpecInitContainersVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecInitContainersVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecInitContainersVolumeMounts(obj: RunnerSetSpecTemplateSpecInitContainersVolumeMounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'mountPropagation': obj.mountPropagation,
    'name': obj.name,
    'readOnly': obj.readOnly,
    'subPath': obj.subPath,
    'subPathExpr': obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema RunnerSetSpecTemplateSpecSecurityContextSeLinuxOptions
 */
export interface RunnerSetSpecTemplateSpecSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema RunnerSetSpecTemplateSpecSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema RunnerSetSpecTemplateSpecSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema RunnerSetSpecTemplateSpecSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema RunnerSetSpecTemplateSpecSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecSecurityContextSeLinuxOptions(obj: RunnerSetSpecTemplateSpecSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema RunnerSetSpecTemplateSpecSecurityContextSeccompProfile
 */
export interface RunnerSetSpecTemplateSpecSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Must be a descending path, relative to the kubelet's configured seccomp profile location. Must only be set if type is "Localhost".
   *
   * @schema RunnerSetSpecTemplateSpecSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied. Valid options are:
   * Localhost - a profile defined in a file on the node should be used. RuntimeDefault - the container runtime default profile should be used. Unconfined - no profile should be applied.
   *
   * @schema RunnerSetSpecTemplateSpecSecurityContextSeccompProfile#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecSecurityContextSeccompProfile(obj: RunnerSetSpecTemplateSpecSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Sysctl defines a kernel parameter to be set
 *
 * @schema RunnerSetSpecTemplateSpecSecurityContextSysctls
 */
export interface RunnerSetSpecTemplateSpecSecurityContextSysctls {
  /**
   * Name of a property to set
   *
   * @schema RunnerSetSpecTemplateSpecSecurityContextSysctls#name
   */
  readonly name: string;

  /**
   * Value of a property to set
   *
   * @schema RunnerSetSpecTemplateSpecSecurityContextSysctls#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecSecurityContextSysctls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecSecurityContextSysctls(obj: RunnerSetSpecTemplateSpecSecurityContextSysctls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Windows specific settings applied to all containers. If unspecified, the options within a container's SecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema RunnerSetSpecTemplateSpecSecurityContextWindowsOptions
 */
export interface RunnerSetSpecTemplateSpecSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema RunnerSetSpecTemplateSpecSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema RunnerSetSpecTemplateSpecSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container. This field is alpha-level and will only be honored by components that enable the WindowsHostProcessContainers feature flag. Setting this field without the feature flag will result in errors when validating the Pod. All of a Pod's containers must have the same effective HostProcess value (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).  In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema RunnerSetSpecTemplateSpecSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process. Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * @schema RunnerSetSpecTemplateSpecSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecSecurityContextWindowsOptions(obj: RunnerSetSpecTemplateSpecSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LabelSelector is used to find matching pods. Pods that match this label selector are counted to determine the number of pods in their corresponding topology domain.
 *
 * @schema RunnerSetSpecTemplateSpecTopologySpreadConstraintsLabelSelector
 */
export interface RunnerSetSpecTemplateSpecTopologySpreadConstraintsLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema RunnerSetSpecTemplateSpecTopologySpreadConstraintsLabelSelector#matchExpressions
   */
  readonly matchExpressions?: RunnerSetSpecTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema RunnerSetSpecTemplateSpecTopologySpreadConstraintsLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecTopologySpreadConstraintsLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecTopologySpreadConstraintsLabelSelector(obj: RunnerSetSpecTemplateSpecTopologySpreadConstraintsLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_RunnerSetSpecTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AWSElasticBlockStore represents an AWS Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
 *
 * @schema RunnerSetSpecTemplateSpecVolumesAwsElasticBlockStore
 */
export interface RunnerSetSpecTemplateSpecVolumesAwsElasticBlockStore {
  /**
   * Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema RunnerSetSpecTemplateSpecVolumesAwsElasticBlockStore#fsType
   */
  readonly fsType?: string;

  /**
   * The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as "1". Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
   *
   * @schema RunnerSetSpecTemplateSpecVolumesAwsElasticBlockStore#partition
   */
  readonly partition?: number;

  /**
   * Specify "true" to force and set the ReadOnly property in VolumeMounts to "true". If omitted, the default is "false". More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema RunnerSetSpecTemplateSpecVolumesAwsElasticBlockStore#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema RunnerSetSpecTemplateSpecVolumesAwsElasticBlockStore#volumeID
   */
  readonly volumeId: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecVolumesAwsElasticBlockStore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecVolumesAwsElasticBlockStore(obj: RunnerSetSpecTemplateSpecVolumesAwsElasticBlockStore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'partition': obj.partition,
    'readOnly': obj.readOnly,
    'volumeID': obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
 *
 * @schema RunnerSetSpecTemplateSpecVolumesAzureDisk
 */
export interface RunnerSetSpecTemplateSpecVolumesAzureDisk {
  /**
   * Host Caching mode: None, Read Only, Read Write.
   *
   * @schema RunnerSetSpecTemplateSpecVolumesAzureDisk#cachingMode
   */
  readonly cachingMode?: string;

  /**
   * The Name of the data disk in the blob storage
   *
   * @schema RunnerSetSpecTemplateSpecVolumesAzureDisk#diskName
   */
  readonly diskName: string;

  /**
   * The URI the data disk in the blob storage
   *
   * @schema RunnerSetSpecTemplateSpecVolumesAzureDisk#diskURI
   */
  readonly diskUri: string;

  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema RunnerSetSpecTemplateSpecVolumesAzureDisk#fsType
   */
  readonly fsType?: string;

  /**
   * Expected values Shared: multiple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared
   *
   * @schema RunnerSetSpecTemplateSpecVolumesAzureDisk#kind
   */
  readonly kind?: string;

  /**
   * Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema RunnerSetSpecTemplateSpecVolumesAzureDisk#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecVolumesAzureDisk' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecVolumesAzureDisk(obj: RunnerSetSpecTemplateSpecVolumesAzureDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cachingMode': obj.cachingMode,
    'diskName': obj.diskName,
    'diskURI': obj.diskUri,
    'fsType': obj.fsType,
    'kind': obj.kind,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
 *
 * @schema RunnerSetSpecTemplateSpecVolumesAzureFile
 */
export interface RunnerSetSpecTemplateSpecVolumesAzureFile {
  /**
   * Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema RunnerSetSpecTemplateSpecVolumesAzureFile#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * the name of secret that contains Azure Storage Account Name and Key
   *
   * @schema RunnerSetSpecTemplateSpecVolumesAzureFile#secretName
   */
  readonly secretName: string;

  /**
   * Share Name
   *
   * @schema RunnerSetSpecTemplateSpecVolumesAzureFile#shareName
   */
  readonly shareName: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecVolumesAzureFile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecVolumesAzureFile(obj: RunnerSetSpecTemplateSpecVolumesAzureFile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'readOnly': obj.readOnly,
    'secretName': obj.secretName,
    'shareName': obj.shareName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CephFS represents a Ceph FS mount on the host that shares a pod's lifetime
 *
 * @schema RunnerSetSpecTemplateSpecVolumesCephfs
 */
export interface RunnerSetSpecTemplateSpecVolumesCephfs {
  /**
   * Required: Monitors is a collection of Ceph monitors More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema RunnerSetSpecTemplateSpecVolumesCephfs#monitors
   */
  readonly monitors: string[];

  /**
   * Optional: Used as the mounted root, rather than the full Ceph tree, default is /
   *
   * @schema RunnerSetSpecTemplateSpecVolumesCephfs#path
   */
  readonly path?: string;

  /**
   * Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   * @schema RunnerSetSpecTemplateSpecVolumesCephfs#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema RunnerSetSpecTemplateSpecVolumesCephfs#secretFile
   */
  readonly secretFile?: string;

  /**
   * Optional: SecretRef is reference to the authentication secret for User, default is empty. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema RunnerSetSpecTemplateSpecVolumesCephfs#secretRef
   */
  readonly secretRef?: RunnerSetSpecTemplateSpecVolumesCephfsSecretRef;

  /**
   * Optional: User is the rados user name, default is admin More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema RunnerSetSpecTemplateSpecVolumesCephfs#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecVolumesCephfs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecVolumesCephfs(obj: RunnerSetSpecTemplateSpecVolumesCephfs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'monitors': obj.monitors?.map(y => y),
    'path': obj.path,
    'readOnly': obj.readOnly,
    'secretFile': obj.secretFile,
    'secretRef': toJson_RunnerSetSpecTemplateSpecVolumesCephfsSecretRef(obj.secretRef),
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Cinder represents a cinder volume attached and mounted on kubelets host machine. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
 *
 * @schema RunnerSetSpecTemplateSpecVolumesCinder
 */
export interface RunnerSetSpecTemplateSpecVolumesCinder {
  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema RunnerSetSpecTemplateSpecVolumesCinder#fsType
   */
  readonly fsType?: string;

  /**
   * Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   * @schema RunnerSetSpecTemplateSpecVolumesCinder#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Optional: points to a secret object containing parameters used to connect to OpenStack.
   *
   * @schema RunnerSetSpecTemplateSpecVolumesCinder#secretRef
   */
  readonly secretRef?: RunnerSetSpecTemplateSpecVolumesCinderSecretRef;

  /**
   * volume id used to identify the volume in cinder. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema RunnerSetSpecTemplateSpecVolumesCinder#volumeID
   */
  readonly volumeId: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecVolumesCinder' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecVolumesCinder(obj: RunnerSetSpecTemplateSpecVolumesCinder | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'readOnly': obj.readOnly,
    'secretRef': toJson_RunnerSetSpecTemplateSpecVolumesCinderSecretRef(obj.secretRef),
    'volumeID': obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap represents a configMap that should populate this volume
 *
 * @schema RunnerSetSpecTemplateSpecVolumesConfigMap
 */
export interface RunnerSetSpecTemplateSpecVolumesConfigMap {
  /**
   * Optional: mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   * @schema RunnerSetSpecTemplateSpecVolumesConfigMap#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema RunnerSetSpecTemplateSpecVolumesConfigMap#items
   */
  readonly items?: RunnerSetSpecTemplateSpecVolumesConfigMapItems[];

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerSetSpecTemplateSpecVolumesConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its keys must be defined
   *
   * @schema RunnerSetSpecTemplateSpecVolumesConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecVolumesConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecVolumesConfigMap(obj: RunnerSetSpecTemplateSpecVolumesConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_RunnerSetSpecTemplateSpecVolumesConfigMapItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CSI (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers (Beta feature).
 *
 * @schema RunnerSetSpecTemplateSpecVolumesCsi
 */
export interface RunnerSetSpecTemplateSpecVolumesCsi {
  /**
   * Driver is the name of the CSI driver that handles this volume. Consult with your admin for the correct name as registered in the cluster.
   *
   * @schema RunnerSetSpecTemplateSpecVolumesCsi#driver
   */
  readonly driver: string;

  /**
   * Filesystem type to mount. Ex. "ext4", "xfs", "ntfs". If not provided, the empty value is passed to the associated CSI driver which will determine the default filesystem to apply.
   *
   * @schema RunnerSetSpecTemplateSpecVolumesCsi#fsType
   */
  readonly fsType?: string;

  /**
   * NodePublishSecretRef is a reference to the secret object containing sensitive information to pass to the CSI driver to complete the CSI NodePublishVolume and NodeUnpublishVolume calls. This field is optional, and  may be empty if no secret is required. If the secret object contains more than one secret, all secret references are passed.
   *
   * @schema RunnerSetSpecTemplateSpecVolumesCsi#nodePublishSecretRef
   */
  readonly nodePublishSecretRef?: RunnerSetSpecTemplateSpecVolumesCsiNodePublishSecretRef;

  /**
   * Specifies a read-only configuration for the volume. Defaults to false (read/write).
   *
   * @default false (read/write).
   * @schema RunnerSetSpecTemplateSpecVolumesCsi#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * VolumeAttributes stores driver-specific properties that are passed to the CSI driver. Consult your driver's documentation for supported values.
   *
   * @schema RunnerSetSpecTemplateSpecVolumesCsi#volumeAttributes
   */
  readonly volumeAttributes?: { [key: string]: string };

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecVolumesCsi' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecVolumesCsi(obj: RunnerSetSpecTemplateSpecVolumesCsi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'driver': obj.driver,
    'fsType': obj.fsType,
    'nodePublishSecretRef': toJson_RunnerSetSpecTemplateSpecVolumesCsiNodePublishSecretRef(obj.nodePublishSecretRef),
    'readOnly': obj.readOnly,
    'volumeAttributes': ((obj.volumeAttributes) === undefined) ? undefined : (Object.entries(obj.volumeAttributes).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DownwardAPI represents downward API about the pod that should populate this volume
 *
 * @schema RunnerSetSpecTemplateSpecVolumesDownwardApi
 */
export interface RunnerSetSpecTemplateSpecVolumesDownwardApi {
  /**
   * Optional: mode bits to use on created files by default. Must be a Optional: mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   * @schema RunnerSetSpecTemplateSpecVolumesDownwardApi#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * Items is a list of downward API volume file
   *
   * @schema RunnerSetSpecTemplateSpecVolumesDownwardApi#items
   */
  readonly items?: RunnerSetSpecTemplateSpecVolumesDownwardApiItems[];

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecVolumesDownwardApi' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecVolumesDownwardApi(obj: RunnerSetSpecTemplateSpecVolumesDownwardApi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_RunnerSetSpecTemplateSpecVolumesDownwardApiItems(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EmptyDir represents a temporary directory that shares a pod's lifetime. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
 *
 * @schema RunnerSetSpecTemplateSpecVolumesEmptyDir
 */
export interface RunnerSetSpecTemplateSpecVolumesEmptyDir {
  /**
   * What type of storage medium should back this directory. The default is "" which means to use the node's default medium. Must be an empty string (default) or Memory. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema RunnerSetSpecTemplateSpecVolumesEmptyDir#medium
   */
  readonly medium?: string;

  /**
   * Total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. The default is nil which means that the limit is undefined. More info: http://kubernetes.io/docs/user-guide/volumes#emptydir
   *
   * @schema RunnerSetSpecTemplateSpecVolumesEmptyDir#sizeLimit
   */
  readonly sizeLimit?: RunnerSetSpecTemplateSpecVolumesEmptyDirSizeLimit;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecVolumesEmptyDir' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecVolumesEmptyDir(obj: RunnerSetSpecTemplateSpecVolumesEmptyDir | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'medium': obj.medium,
    'sizeLimit': obj.sizeLimit?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Ephemeral represents a volume that is handled by a cluster storage driver. The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts, and deleted when the pod is removed.
 * Use this if: a) the volume is only needed while the pod runs, b) features of normal volumes like restoring from snapshot or capacity    tracking are needed, c) the storage driver is specified through a storage class, and d) the storage driver supports dynamic volume provisioning through    a PersistentVolumeClaim (see EphemeralVolumeSource for more    information on the connection between this volume type    and PersistentVolumeClaim).
 * Use PersistentVolumeClaim or one of the vendor-specific APIs for volumes that persist for longer than the lifecycle of an individual pod.
 * Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to be used that way - see the documentation of the driver for more information.
 * A pod can use both types of ephemeral volumes and persistent volumes at the same time.
 *
 * @schema RunnerSetSpecTemplateSpecVolumesEphemeral
 */
export interface RunnerSetSpecTemplateSpecVolumesEphemeral {
  /**
   * Will be used to create a stand-alone PVC to provision the volume. The pod in which this EphemeralVolumeSource is embedded will be the owner of the PVC, i.e. the PVC will be deleted together with the pod.  The name of the PVC will be `<pod name>-<volume name>` where `<volume name>` is the name from the `PodSpec.Volumes` array entry. Pod validation will reject the pod if the concatenated name is not valid for a PVC (for example, too long).
   * An existing PVC with that name that is not owned by the pod will *not* be used for the pod to avoid using an unrelated volume by mistake. Starting the pod is then blocked until the unrelated PVC is removed. If such a pre-created PVC is meant to be used by the pod, the PVC has to updated with an owner reference to the pod once the pod exists. Normally this should not be necessary, but it may be useful when manually reconstructing a broken cluster.
   * This field is read-only and no changes will be made by Kubernetes to the PVC after it has been created.
   * Required, must not be nil.
   *
   * @schema RunnerSetSpecTemplateSpecVolumesEphemeral#volumeClaimTemplate
   */
  readonly volumeClaimTemplate?: RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplate;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecVolumesEphemeral' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecVolumesEphemeral(obj: RunnerSetSpecTemplateSpecVolumesEphemeral | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'volumeClaimTemplate': toJson_RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplate(obj.volumeClaimTemplate),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FC represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
 *
 * @schema RunnerSetSpecTemplateSpecVolumesFc
 */
export interface RunnerSetSpecTemplateSpecVolumesFc {
  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema RunnerSetSpecTemplateSpecVolumesFc#fsType
   */
  readonly fsType?: string;

  /**
   * Optional: FC target lun number
   *
   * @schema RunnerSetSpecTemplateSpecVolumesFc#lun
   */
  readonly lun?: number;

  /**
   * Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema RunnerSetSpecTemplateSpecVolumesFc#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Optional: FC target worldwide names (WWNs)
   *
   * @schema RunnerSetSpecTemplateSpecVolumesFc#targetWWNs
   */
  readonly targetWwNs?: string[];

  /**
   * Optional: FC volume world wide identifiers (wwids) Either wwids or combination of targetWWNs and lun must be set, but not both simultaneously.
   *
   * @schema RunnerSetSpecTemplateSpecVolumesFc#wwids
   */
  readonly wwids?: string[];

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecVolumesFc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecVolumesFc(obj: RunnerSetSpecTemplateSpecVolumesFc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'lun': obj.lun,
    'readOnly': obj.readOnly,
    'targetWWNs': obj.targetWwNs?.map(y => y),
    'wwids': obj.wwids?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FlexVolume represents a generic volume resource that is provisioned/attached using an exec based plugin.
 *
 * @schema RunnerSetSpecTemplateSpecVolumesFlexVolume
 */
export interface RunnerSetSpecTemplateSpecVolumesFlexVolume {
  /**
   * Driver is the name of the driver to use for this volume.
   *
   * @schema RunnerSetSpecTemplateSpecVolumesFlexVolume#driver
   */
  readonly driver: string;

  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
   *
   * @schema RunnerSetSpecTemplateSpecVolumesFlexVolume#fsType
   */
  readonly fsType?: string;

  /**
   * Optional: Extra command options if any.
   *
   * @schema RunnerSetSpecTemplateSpecVolumesFlexVolume#options
   */
  readonly options?: { [key: string]: string };

  /**
   * Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema RunnerSetSpecTemplateSpecVolumesFlexVolume#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Optional: SecretRef is reference to the secret object containing sensitive information to pass to the plugin scripts. This may be empty if no secret object is specified. If the secret object contains more than one secret, all secrets are passed to the plugin scripts.
   *
   * @schema RunnerSetSpecTemplateSpecVolumesFlexVolume#secretRef
   */
  readonly secretRef?: RunnerSetSpecTemplateSpecVolumesFlexVolumeSecretRef;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecVolumesFlexVolume' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecVolumesFlexVolume(obj: RunnerSetSpecTemplateSpecVolumesFlexVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'driver': obj.driver,
    'fsType': obj.fsType,
    'options': ((obj.options) === undefined) ? undefined : (Object.entries(obj.options).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'readOnly': obj.readOnly,
    'secretRef': toJson_RunnerSetSpecTemplateSpecVolumesFlexVolumeSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running
 *
 * @schema RunnerSetSpecTemplateSpecVolumesFlocker
 */
export interface RunnerSetSpecTemplateSpecVolumesFlocker {
  /**
   * Name of the dataset stored as metadata -> name on the dataset for Flocker should be considered as deprecated
   *
   * @schema RunnerSetSpecTemplateSpecVolumesFlocker#datasetName
   */
  readonly datasetName?: string;

  /**
   * UUID of the dataset. This is unique identifier of a Flocker dataset
   *
   * @schema RunnerSetSpecTemplateSpecVolumesFlocker#datasetUUID
   */
  readonly datasetUuid?: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecVolumesFlocker' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecVolumesFlocker(obj: RunnerSetSpecTemplateSpecVolumesFlocker | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'datasetName': obj.datasetName,
    'datasetUUID': obj.datasetUuid,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
 *
 * @schema RunnerSetSpecTemplateSpecVolumesGcePersistentDisk
 */
export interface RunnerSetSpecTemplateSpecVolumesGcePersistentDisk {
  /**
   * Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema RunnerSetSpecTemplateSpecVolumesGcePersistentDisk#fsType
   */
  readonly fsType?: string;

  /**
   * The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as "1". Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty). More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema RunnerSetSpecTemplateSpecVolumesGcePersistentDisk#partition
   */
  readonly partition?: number;

  /**
   * Unique name of the PD resource in GCE. Used to identify the disk in GCE. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema RunnerSetSpecTemplateSpecVolumesGcePersistentDisk#pdName
   */
  readonly pdName: string;

  /**
   * ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @default false. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   * @schema RunnerSetSpecTemplateSpecVolumesGcePersistentDisk#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecVolumesGcePersistentDisk' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecVolumesGcePersistentDisk(obj: RunnerSetSpecTemplateSpecVolumesGcePersistentDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'partition': obj.partition,
    'pdName': obj.pdName,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GitRepo represents a git repository at a particular revision. DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir into the Pod's container.
 *
 * @schema RunnerSetSpecTemplateSpecVolumesGitRepo
 */
export interface RunnerSetSpecTemplateSpecVolumesGitRepo {
  /**
   * Target directory name. Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the git repository.  Otherwise, if specified, the volume will contain the git repository in the subdirectory with the given name.
   *
   * @schema RunnerSetSpecTemplateSpecVolumesGitRepo#directory
   */
  readonly directory?: string;

  /**
   * Repository URL
   *
   * @schema RunnerSetSpecTemplateSpecVolumesGitRepo#repository
   */
  readonly repository: string;

  /**
   * Commit hash for the specified revision.
   *
   * @schema RunnerSetSpecTemplateSpecVolumesGitRepo#revision
   */
  readonly revision?: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecVolumesGitRepo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecVolumesGitRepo(obj: RunnerSetSpecTemplateSpecVolumesGitRepo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'directory': obj.directory,
    'repository': obj.repository,
    'revision': obj.revision,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/glusterfs/README.md
 *
 * @schema RunnerSetSpecTemplateSpecVolumesGlusterfs
 */
export interface RunnerSetSpecTemplateSpecVolumesGlusterfs {
  /**
   * EndpointsName is the endpoint name that details Glusterfs topology. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @schema RunnerSetSpecTemplateSpecVolumesGlusterfs#endpoints
   */
  readonly endpoints: string;

  /**
   * Path is the Glusterfs volume path. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @schema RunnerSetSpecTemplateSpecVolumesGlusterfs#path
   */
  readonly path: string;

  /**
   * ReadOnly here will force the Glusterfs volume to be mounted with read-only permissions. Defaults to false. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @default false. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   * @schema RunnerSetSpecTemplateSpecVolumesGlusterfs#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecVolumesGlusterfs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecVolumesGlusterfs(obj: RunnerSetSpecTemplateSpecVolumesGlusterfs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'endpoints': obj.endpoints,
    'path': obj.path,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HostPath represents a pre-existing file or directory on the host machine that is directly exposed to the container. This is generally used for system agents or other privileged things that are allowed to see the host machine. Most containers will NOT need this. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath --- TODO(jonesdl) We need to restrict who can use host directory mounts and who can/can not mount host directories as read/write.
 *
 * @schema RunnerSetSpecTemplateSpecVolumesHostPath
 */
export interface RunnerSetSpecTemplateSpecVolumesHostPath {
  /**
   * Path of the directory on the host. If the path is a symlink, it will follow the link to the real path. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @schema RunnerSetSpecTemplateSpecVolumesHostPath#path
   */
  readonly path: string;

  /**
   * Type for HostPath Volume Defaults to "" More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @default More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   * @schema RunnerSetSpecTemplateSpecVolumesHostPath#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecVolumesHostPath' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecVolumesHostPath(obj: RunnerSetSpecTemplateSpecVolumesHostPath | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ISCSI represents an ISCSI Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://examples.k8s.io/volumes/iscsi/README.md
 *
 * @schema RunnerSetSpecTemplateSpecVolumesIscsi
 */
export interface RunnerSetSpecTemplateSpecVolumesIscsi {
  /**
   * whether support iSCSI Discovery CHAP authentication
   *
   * @schema RunnerSetSpecTemplateSpecVolumesIscsi#chapAuthDiscovery
   */
  readonly chapAuthDiscovery?: boolean;

  /**
   * whether support iSCSI Session CHAP authentication
   *
   * @schema RunnerSetSpecTemplateSpecVolumesIscsi#chapAuthSession
   */
  readonly chapAuthSession?: boolean;

  /**
   * Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema RunnerSetSpecTemplateSpecVolumesIscsi#fsType
   */
  readonly fsType?: string;

  /**
   * Custom iSCSI Initiator Name. If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface <target portal>:<volume name> will be created for the connection.
   *
   * @schema RunnerSetSpecTemplateSpecVolumesIscsi#initiatorName
   */
  readonly initiatorName?: string;

  /**
   * Target iSCSI Qualified Name.
   *
   * @schema RunnerSetSpecTemplateSpecVolumesIscsi#iqn
   */
  readonly iqn: string;

  /**
   * iSCSI Interface Name that uses an iSCSI transport. Defaults to 'default' (tcp).
   *
   * @default default' (tcp).
   * @schema RunnerSetSpecTemplateSpecVolumesIscsi#iscsiInterface
   */
  readonly iscsiInterface?: string;

  /**
   * iSCSI Target Lun number.
   *
   * @schema RunnerSetSpecTemplateSpecVolumesIscsi#lun
   */
  readonly lun: number;

  /**
   * iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port is other than default (typically TCP ports 860 and 3260).
   *
   * @schema RunnerSetSpecTemplateSpecVolumesIscsi#portals
   */
  readonly portals?: string[];

  /**
   * ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false.
   *
   * @default false.
   * @schema RunnerSetSpecTemplateSpecVolumesIscsi#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * CHAP Secret for iSCSI target and initiator authentication
   *
   * @schema RunnerSetSpecTemplateSpecVolumesIscsi#secretRef
   */
  readonly secretRef?: RunnerSetSpecTemplateSpecVolumesIscsiSecretRef;

  /**
   * iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port is other than default (typically TCP ports 860 and 3260).
   *
   * @schema RunnerSetSpecTemplateSpecVolumesIscsi#targetPortal
   */
  readonly targetPortal: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecVolumesIscsi' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecVolumesIscsi(obj: RunnerSetSpecTemplateSpecVolumesIscsi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'chapAuthDiscovery': obj.chapAuthDiscovery,
    'chapAuthSession': obj.chapAuthSession,
    'fsType': obj.fsType,
    'initiatorName': obj.initiatorName,
    'iqn': obj.iqn,
    'iscsiInterface': obj.iscsiInterface,
    'lun': obj.lun,
    'portals': obj.portals?.map(y => y),
    'readOnly': obj.readOnly,
    'secretRef': toJson_RunnerSetSpecTemplateSpecVolumesIscsiSecretRef(obj.secretRef),
    'targetPortal': obj.targetPortal,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NFS represents an NFS mount on the host that shares a pod's lifetime More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
 *
 * @schema RunnerSetSpecTemplateSpecVolumesNfs
 */
export interface RunnerSetSpecTemplateSpecVolumesNfs {
  /**
   * Path that is exported by the NFS server. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema RunnerSetSpecTemplateSpecVolumesNfs#path
   */
  readonly path: string;

  /**
   * ReadOnly here will force the NFS export to be mounted with read-only permissions. Defaults to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @default false. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   * @schema RunnerSetSpecTemplateSpecVolumesNfs#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Server is the hostname or IP address of the NFS server. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema RunnerSetSpecTemplateSpecVolumesNfs#server
   */
  readonly server: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecVolumesNfs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecVolumesNfs(obj: RunnerSetSpecTemplateSpecVolumesNfs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'readOnly': obj.readOnly,
    'server': obj.server,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PersistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in the same namespace. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
 *
 * @schema RunnerSetSpecTemplateSpecVolumesPersistentVolumeClaim
 */
export interface RunnerSetSpecTemplateSpecVolumesPersistentVolumeClaim {
  /**
   * ClaimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema RunnerSetSpecTemplateSpecVolumesPersistentVolumeClaim#claimName
   */
  readonly claimName: string;

  /**
   * Will force the ReadOnly setting in VolumeMounts. Default false.
   *
   * @schema RunnerSetSpecTemplateSpecVolumesPersistentVolumeClaim#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecVolumesPersistentVolumeClaim' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecVolumesPersistentVolumeClaim(obj: RunnerSetSpecTemplateSpecVolumesPersistentVolumeClaim | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claimName': obj.claimName,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PhotonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
 *
 * @schema RunnerSetSpecTemplateSpecVolumesPhotonPersistentDisk
 */
export interface RunnerSetSpecTemplateSpecVolumesPhotonPersistentDisk {
  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema RunnerSetSpecTemplateSpecVolumesPhotonPersistentDisk#fsType
   */
  readonly fsType?: string;

  /**
   * ID that identifies Photon Controller persistent disk
   *
   * @schema RunnerSetSpecTemplateSpecVolumesPhotonPersistentDisk#pdID
   */
  readonly pdId: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecVolumesPhotonPersistentDisk' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecVolumesPhotonPersistentDisk(obj: RunnerSetSpecTemplateSpecVolumesPhotonPersistentDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'pdID': obj.pdId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PortworxVolume represents a portworx volume attached and mounted on kubelets host machine
 *
 * @schema RunnerSetSpecTemplateSpecVolumesPortworxVolume
 */
export interface RunnerSetSpecTemplateSpecVolumesPortworxVolume {
  /**
   * FSType represents the filesystem type to mount Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema RunnerSetSpecTemplateSpecVolumesPortworxVolume#fsType
   */
  readonly fsType?: string;

  /**
   * Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema RunnerSetSpecTemplateSpecVolumesPortworxVolume#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * VolumeID uniquely identifies a Portworx volume
   *
   * @schema RunnerSetSpecTemplateSpecVolumesPortworxVolume#volumeID
   */
  readonly volumeId: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecVolumesPortworxVolume' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecVolumesPortworxVolume(obj: RunnerSetSpecTemplateSpecVolumesPortworxVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'readOnly': obj.readOnly,
    'volumeID': obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Items for all in one resources secrets, configmaps, and downward API
 *
 * @schema RunnerSetSpecTemplateSpecVolumesProjected
 */
export interface RunnerSetSpecTemplateSpecVolumesProjected {
  /**
   * Mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema RunnerSetSpecTemplateSpecVolumesProjected#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * list of volume projections
   *
   * @schema RunnerSetSpecTemplateSpecVolumesProjected#sources
   */
  readonly sources?: RunnerSetSpecTemplateSpecVolumesProjectedSources[];

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecVolumesProjected' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecVolumesProjected(obj: RunnerSetSpecTemplateSpecVolumesProjected | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'sources': obj.sources?.map(y => toJson_RunnerSetSpecTemplateSpecVolumesProjectedSources(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Quobyte represents a Quobyte mount on the host that shares a pod's lifetime
 *
 * @schema RunnerSetSpecTemplateSpecVolumesQuobyte
 */
export interface RunnerSetSpecTemplateSpecVolumesQuobyte {
  /**
   * Group to map volume access to Default is no group
   *
   * @default no group
   * @schema RunnerSetSpecTemplateSpecVolumesQuobyte#group
   */
  readonly group?: string;

  /**
   * ReadOnly here will force the Quobyte volume to be mounted with read-only permissions. Defaults to false.
   *
   * @default false.
   * @schema RunnerSetSpecTemplateSpecVolumesQuobyte#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Registry represents a single or multiple Quobyte Registry services specified as a string as host:port pair (multiple entries are separated with commas) which acts as the central registry for volumes
   *
   * @schema RunnerSetSpecTemplateSpecVolumesQuobyte#registry
   */
  readonly registry: string;

  /**
   * Tenant owning the given Quobyte volume in the Backend Used with dynamically provisioned Quobyte volumes, value is set by the plugin
   *
   * @schema RunnerSetSpecTemplateSpecVolumesQuobyte#tenant
   */
  readonly tenant?: string;

  /**
   * User to map volume access to Defaults to serivceaccount user
   *
   * @default serivceaccount user
   * @schema RunnerSetSpecTemplateSpecVolumesQuobyte#user
   */
  readonly user?: string;

  /**
   * Volume is a string that references an already created Quobyte volume by name.
   *
   * @schema RunnerSetSpecTemplateSpecVolumesQuobyte#volume
   */
  readonly volume: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecVolumesQuobyte' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecVolumesQuobyte(obj: RunnerSetSpecTemplateSpecVolumesQuobyte | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'readOnly': obj.readOnly,
    'registry': obj.registry,
    'tenant': obj.tenant,
    'user': obj.user,
    'volume': obj.volume,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RBD represents a Rados Block Device mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/rbd/README.md
 *
 * @schema RunnerSetSpecTemplateSpecVolumesRbd
 */
export interface RunnerSetSpecTemplateSpecVolumesRbd {
  /**
   * Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema RunnerSetSpecTemplateSpecVolumesRbd#fsType
   */
  readonly fsType?: string;

  /**
   * The rados image name. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @schema RunnerSetSpecTemplateSpecVolumesRbd#image
   */
  readonly image: string;

  /**
   * Keyring is the path to key ring for RBDUser. Default is /etc/ceph/keyring. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default etc/ceph/keyring. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema RunnerSetSpecTemplateSpecVolumesRbd#keyring
   */
  readonly keyring?: string;

  /**
   * A collection of Ceph monitors. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @schema RunnerSetSpecTemplateSpecVolumesRbd#monitors
   */
  readonly monitors: string[];

  /**
   * The rados pool name. Default is rbd. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default rbd. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema RunnerSetSpecTemplateSpecVolumesRbd#pool
   */
  readonly pool?: string;

  /**
   * ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default false. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema RunnerSetSpecTemplateSpecVolumesRbd#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * SecretRef is name of the authentication secret for RBDUser. If provided overrides keyring. Default is nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema RunnerSetSpecTemplateSpecVolumesRbd#secretRef
   */
  readonly secretRef?: RunnerSetSpecTemplateSpecVolumesRbdSecretRef;

  /**
   * The rados user name. Default is admin. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default admin. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema RunnerSetSpecTemplateSpecVolumesRbd#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecVolumesRbd' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecVolumesRbd(obj: RunnerSetSpecTemplateSpecVolumesRbd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'image': obj.image,
    'keyring': obj.keyring,
    'monitors': obj.monitors?.map(y => y),
    'pool': obj.pool,
    'readOnly': obj.readOnly,
    'secretRef': toJson_RunnerSetSpecTemplateSpecVolumesRbdSecretRef(obj.secretRef),
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ScaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
 *
 * @schema RunnerSetSpecTemplateSpecVolumesScaleIo
 */
export interface RunnerSetSpecTemplateSpecVolumesScaleIo {
  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Default is "xfs".
   *
   * @default xfs".
   * @schema RunnerSetSpecTemplateSpecVolumesScaleIo#fsType
   */
  readonly fsType?: string;

  /**
   * The host address of the ScaleIO API Gateway.
   *
   * @schema RunnerSetSpecTemplateSpecVolumesScaleIo#gateway
   */
  readonly gateway: string;

  /**
   * The name of the ScaleIO Protection Domain for the configured storage.
   *
   * @schema RunnerSetSpecTemplateSpecVolumesScaleIo#protectionDomain
   */
  readonly protectionDomain?: string;

  /**
   * Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema RunnerSetSpecTemplateSpecVolumesScaleIo#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * SecretRef references to the secret for ScaleIO user and other sensitive information. If this is not provided, Login operation will fail.
   *
   * @schema RunnerSetSpecTemplateSpecVolumesScaleIo#secretRef
   */
  readonly secretRef: RunnerSetSpecTemplateSpecVolumesScaleIoSecretRef;

  /**
   * Flag to enable/disable SSL communication with Gateway, default false
   *
   * @schema RunnerSetSpecTemplateSpecVolumesScaleIo#sslEnabled
   */
  readonly sslEnabled?: boolean;

  /**
   * Indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned. Default is ThinProvisioned.
   *
   * @default ThinProvisioned.
   * @schema RunnerSetSpecTemplateSpecVolumesScaleIo#storageMode
   */
  readonly storageMode?: string;

  /**
   * The ScaleIO Storage Pool associated with the protection domain.
   *
   * @schema RunnerSetSpecTemplateSpecVolumesScaleIo#storagePool
   */
  readonly storagePool?: string;

  /**
   * The name of the storage system as configured in ScaleIO.
   *
   * @schema RunnerSetSpecTemplateSpecVolumesScaleIo#system
   */
  readonly system: string;

  /**
   * The name of a volume already created in the ScaleIO system that is associated with this volume source.
   *
   * @schema RunnerSetSpecTemplateSpecVolumesScaleIo#volumeName
   */
  readonly volumeName?: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecVolumesScaleIo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecVolumesScaleIo(obj: RunnerSetSpecTemplateSpecVolumesScaleIo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'gateway': obj.gateway,
    'protectionDomain': obj.protectionDomain,
    'readOnly': obj.readOnly,
    'secretRef': toJson_RunnerSetSpecTemplateSpecVolumesScaleIoSecretRef(obj.secretRef),
    'sslEnabled': obj.sslEnabled,
    'storageMode': obj.storageMode,
    'storagePool': obj.storagePool,
    'system': obj.system,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
 *
 * @schema RunnerSetSpecTemplateSpecVolumesSecret
 */
export interface RunnerSetSpecTemplateSpecVolumesSecret {
  /**
   * Optional: mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   * @schema RunnerSetSpecTemplateSpecVolumesSecret#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema RunnerSetSpecTemplateSpecVolumesSecret#items
   */
  readonly items?: RunnerSetSpecTemplateSpecVolumesSecretItems[];

  /**
   * Specify whether the Secret or its keys must be defined
   *
   * @schema RunnerSetSpecTemplateSpecVolumesSecret#optional
   */
  readonly optional?: boolean;

  /**
   * Name of the secret in the pod's namespace to use. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   *
   * @schema RunnerSetSpecTemplateSpecVolumesSecret#secretName
   */
  readonly secretName?: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecVolumesSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecVolumesSecret(obj: RunnerSetSpecTemplateSpecVolumesSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_RunnerSetSpecTemplateSpecVolumesSecretItems(y)),
    'optional': obj.optional,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * StorageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
 *
 * @schema RunnerSetSpecTemplateSpecVolumesStorageos
 */
export interface RunnerSetSpecTemplateSpecVolumesStorageos {
  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema RunnerSetSpecTemplateSpecVolumesStorageos#fsType
   */
  readonly fsType?: string;

  /**
   * Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema RunnerSetSpecTemplateSpecVolumesStorageos#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * SecretRef specifies the secret to use for obtaining the StorageOS API credentials.  If not specified, default values will be attempted.
   *
   * @schema RunnerSetSpecTemplateSpecVolumesStorageos#secretRef
   */
  readonly secretRef?: RunnerSetSpecTemplateSpecVolumesStorageosSecretRef;

  /**
   * VolumeName is the human-readable name of the StorageOS volume.  Volume names are only unique within a namespace.
   *
   * @schema RunnerSetSpecTemplateSpecVolumesStorageos#volumeName
   */
  readonly volumeName?: string;

  /**
   * VolumeNamespace specifies the scope of the volume within StorageOS.  If no namespace is specified then the Pod's namespace will be used.  This allows the Kubernetes name scoping to be mirrored within StorageOS for tighter integration. Set VolumeName to any name to override the default behaviour. Set to "default" if you are not using namespaces within StorageOS. Namespaces that do not pre-exist within StorageOS will be created.
   *
   * @schema RunnerSetSpecTemplateSpecVolumesStorageos#volumeNamespace
   */
  readonly volumeNamespace?: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecVolumesStorageos' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecVolumesStorageos(obj: RunnerSetSpecTemplateSpecVolumesStorageos | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'readOnly': obj.readOnly,
    'secretRef': toJson_RunnerSetSpecTemplateSpecVolumesStorageosSecretRef(obj.secretRef),
    'volumeName': obj.volumeName,
    'volumeNamespace': obj.volumeNamespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
 *
 * @schema RunnerSetSpecTemplateSpecVolumesVsphereVolume
 */
export interface RunnerSetSpecTemplateSpecVolumesVsphereVolume {
  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema RunnerSetSpecTemplateSpecVolumesVsphereVolume#fsType
   */
  readonly fsType?: string;

  /**
   * Storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.
   *
   * @schema RunnerSetSpecTemplateSpecVolumesVsphereVolume#storagePolicyID
   */
  readonly storagePolicyId?: string;

  /**
   * Storage Policy Based Management (SPBM) profile name.
   *
   * @schema RunnerSetSpecTemplateSpecVolumesVsphereVolume#storagePolicyName
   */
  readonly storagePolicyName?: string;

  /**
   * Path that identifies vSphere volume vmdk
   *
   * @schema RunnerSetSpecTemplateSpecVolumesVsphereVolume#volumePath
   */
  readonly volumePath: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecVolumesVsphereVolume' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecVolumesVsphereVolume(obj: RunnerSetSpecTemplateSpecVolumesVsphereVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'storagePolicyID': obj.storagePolicyId,
    'storagePolicyName': obj.storagePolicyName,
    'volumePath': obj.volumePath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RunnerSetSpecVolumeClaimTemplatesSpecResourcesLimits
 */
export class RunnerSetSpecVolumeClaimTemplatesSpecResourcesLimits {
  public static fromNumber(value: number): RunnerSetSpecVolumeClaimTemplatesSpecResourcesLimits {
    return new RunnerSetSpecVolumeClaimTemplatesSpecResourcesLimits(value);
  }
  public static fromString(value: string): RunnerSetSpecVolumeClaimTemplatesSpecResourcesLimits {
    return new RunnerSetSpecVolumeClaimTemplatesSpecResourcesLimits(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * @schema RunnerSetSpecVolumeClaimTemplatesSpecResourcesRequests
 */
export class RunnerSetSpecVolumeClaimTemplatesSpecResourcesRequests {
  public static fromNumber(value: number): RunnerSetSpecVolumeClaimTemplatesSpecResourcesRequests {
    return new RunnerSetSpecVolumeClaimTemplatesSpecResourcesRequests(value);
  }
  public static fromString(value: string): RunnerSetSpecVolumeClaimTemplatesSpecResourcesRequests {
    return new RunnerSetSpecVolumeClaimTemplatesSpecResourcesRequests(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema RunnerSetSpecVolumeClaimTemplatesSpecSelectorMatchExpressions
 */
export interface RunnerSetSpecVolumeClaimTemplatesSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema RunnerSetSpecVolumeClaimTemplatesSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema RunnerSetSpecVolumeClaimTemplatesSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema RunnerSetSpecVolumeClaimTemplatesSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'RunnerSetSpecVolumeClaimTemplatesSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecVolumeClaimTemplatesSpecSelectorMatchExpressions(obj: RunnerSetSpecVolumeClaimTemplatesSpecSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * An empty preferred scheduling term matches all objects with implicit weight 0 (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
 *
 * @schema RunnerSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface RunnerSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * A node selector term, associated with the corresponding weight.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference: RunnerSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: RunnerSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preference': toJson_RunnerSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj.preference),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node.
 *
 * @schema RunnerSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface RunnerSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A list of node selector terms. The terms are ORed.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms: RunnerSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: RunnerSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeSelectorTerms': obj.nodeSelectorTerms?.map(y => toJson_RunnerSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema RunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface RunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm: RunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: RunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podAffinityTerm': toJson_RunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running
 *
 * @schema RunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface RunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: RunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces. This field is beta-level and is only honored when PodAffinityNamespaceSelector feature is enabled.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: RunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means "this pod's namespace"
   *
   * @schema RunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: RunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_RunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_RunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema RunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface RunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm: RunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: RunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podAffinityTerm': toJson_RunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running
 *
 * @schema RunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface RunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: RunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces. This field is beta-level and is only honored when PodAffinityNamespaceSelector feature is enabled.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: RunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means "this pod's namespace"
   *
   * @schema RunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: RunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_RunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_RunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema RunnerSetSpecTemplateSpecContainersEnvValueFrom
 */
export interface RunnerSetSpecTemplateSpecContainersEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema RunnerSetSpecTemplateSpecContainersEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: RunnerSetSpecTemplateSpecContainersEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema RunnerSetSpecTemplateSpecContainersEnvValueFrom#fieldRef
   */
  readonly fieldRef?: RunnerSetSpecTemplateSpecContainersEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema RunnerSetSpecTemplateSpecContainersEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: RunnerSetSpecTemplateSpecContainersEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema RunnerSetSpecTemplateSpecContainersEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: RunnerSetSpecTemplateSpecContainersEnvValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecContainersEnvValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecContainersEnvValueFrom(obj: RunnerSetSpecTemplateSpecContainersEnvValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_RunnerSetSpecTemplateSpecContainersEnvValueFromConfigMapKeyRef(obj.configMapKeyRef),
    'fieldRef': toJson_RunnerSetSpecTemplateSpecContainersEnvValueFromFieldRef(obj.fieldRef),
    'resourceFieldRef': toJson_RunnerSetSpecTemplateSpecContainersEnvValueFromResourceFieldRef(obj.resourceFieldRef),
    'secretKeyRef': toJson_RunnerSetSpecTemplateSpecContainersEnvValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema RunnerSetSpecTemplateSpecContainersEnvFromConfigMapRef
 */
export interface RunnerSetSpecTemplateSpecContainersEnvFromConfigMapRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerSetSpecTemplateSpecContainersEnvFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema RunnerSetSpecTemplateSpecContainersEnvFromConfigMapRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecContainersEnvFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecContainersEnvFromConfigMapRef(obj: RunnerSetSpecTemplateSpecContainersEnvFromConfigMapRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Secret to select from
 *
 * @schema RunnerSetSpecTemplateSpecContainersEnvFromSecretRef
 */
export interface RunnerSetSpecTemplateSpecContainersEnvFromSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerSetSpecTemplateSpecContainersEnvFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema RunnerSetSpecTemplateSpecContainersEnvFromSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecContainersEnvFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecContainersEnvFromSecretRef(obj: RunnerSetSpecTemplateSpecContainersEnvFromSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PostStart is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema RunnerSetSpecTemplateSpecContainersLifecyclePostStart
 */
export interface RunnerSetSpecTemplateSpecContainersLifecyclePostStart {
  /**
   * Exec specifies the action to take.
   *
   * @schema RunnerSetSpecTemplateSpecContainersLifecyclePostStart#exec
   */
  readonly exec?: RunnerSetSpecTemplateSpecContainersLifecyclePostStartExec;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema RunnerSetSpecTemplateSpecContainersLifecyclePostStart#httpGet
   */
  readonly httpGet?: RunnerSetSpecTemplateSpecContainersLifecyclePostStartHttpGet;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
   *
   * @schema RunnerSetSpecTemplateSpecContainersLifecyclePostStart#tcpSocket
   */
  readonly tcpSocket?: RunnerSetSpecTemplateSpecContainersLifecyclePostStartTcpSocket;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecContainersLifecyclePostStart' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecContainersLifecyclePostStart(obj: RunnerSetSpecTemplateSpecContainersLifecyclePostStart | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_RunnerSetSpecTemplateSpecContainersLifecyclePostStartExec(obj.exec),
    'httpGet': toJson_RunnerSetSpecTemplateSpecContainersLifecyclePostStartHttpGet(obj.httpGet),
    'tcpSocket': toJson_RunnerSetSpecTemplateSpecContainersLifecyclePostStartTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PreStop is called immediately before a container is terminated due to an API request or management event such as liveness/startup probe failure, preemption, resource contention, etc. The handler is not called if the container crashes or exits. The Pod's termination grace period countdown begins before the PreStop hook is executed. Regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period (unless delayed by finalizers). Other management of the container blocks until the hook completes or until the termination grace period is reached. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema RunnerSetSpecTemplateSpecContainersLifecyclePreStop
 */
export interface RunnerSetSpecTemplateSpecContainersLifecyclePreStop {
  /**
   * Exec specifies the action to take.
   *
   * @schema RunnerSetSpecTemplateSpecContainersLifecyclePreStop#exec
   */
  readonly exec?: RunnerSetSpecTemplateSpecContainersLifecyclePreStopExec;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema RunnerSetSpecTemplateSpecContainersLifecyclePreStop#httpGet
   */
  readonly httpGet?: RunnerSetSpecTemplateSpecContainersLifecyclePreStopHttpGet;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
   *
   * @schema RunnerSetSpecTemplateSpecContainersLifecyclePreStop#tcpSocket
   */
  readonly tcpSocket?: RunnerSetSpecTemplateSpecContainersLifecyclePreStopTcpSocket;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecContainersLifecyclePreStop' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecContainersLifecyclePreStop(obj: RunnerSetSpecTemplateSpecContainersLifecyclePreStop | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_RunnerSetSpecTemplateSpecContainersLifecyclePreStopExec(obj.exec),
    'httpGet': toJson_RunnerSetSpecTemplateSpecContainersLifecyclePreStopHttpGet(obj.httpGet),
    'tcpSocket': toJson_RunnerSetSpecTemplateSpecContainersLifecyclePreStopTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema RunnerSetSpecTemplateSpecContainersLivenessProbeExec
 */
export interface RunnerSetSpecTemplateSpecContainersLivenessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RunnerSetSpecTemplateSpecContainersLivenessProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecContainersLivenessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecContainersLivenessProbeExec(obj: RunnerSetSpecTemplateSpecContainersLivenessProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
 *
 * @schema RunnerSetSpecTemplateSpecContainersLivenessProbeGrpc
 */
export interface RunnerSetSpecTemplateSpecContainersLivenessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema RunnerSetSpecTemplateSpecContainersLivenessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema RunnerSetSpecTemplateSpecContainersLivenessProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecContainersLivenessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecContainersLivenessProbeGrpc(obj: RunnerSetSpecTemplateSpecContainersLivenessProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema RunnerSetSpecTemplateSpecContainersLivenessProbeHttpGet
 */
export interface RunnerSetSpecTemplateSpecContainersLivenessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RunnerSetSpecTemplateSpecContainersLivenessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RunnerSetSpecTemplateSpecContainersLivenessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: RunnerSetSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RunnerSetSpecTemplateSpecContainersLivenessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerSetSpecTemplateSpecContainersLivenessProbeHttpGet#port
   */
  readonly port: RunnerSetSpecTemplateSpecContainersLivenessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RunnerSetSpecTemplateSpecContainersLivenessProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecContainersLivenessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecContainersLivenessProbeHttpGet(obj: RunnerSetSpecTemplateSpecContainersLivenessProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_RunnerSetSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema RunnerSetSpecTemplateSpecContainersLivenessProbeTcpSocket
 */
export interface RunnerSetSpecTemplateSpecContainersLivenessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RunnerSetSpecTemplateSpecContainersLivenessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerSetSpecTemplateSpecContainersLivenessProbeTcpSocket#port
   */
  readonly port: RunnerSetSpecTemplateSpecContainersLivenessProbeTcpSocketPort;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecContainersLivenessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecContainersLivenessProbeTcpSocket(obj: RunnerSetSpecTemplateSpecContainersLivenessProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema RunnerSetSpecTemplateSpecContainersReadinessProbeExec
 */
export interface RunnerSetSpecTemplateSpecContainersReadinessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RunnerSetSpecTemplateSpecContainersReadinessProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecContainersReadinessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecContainersReadinessProbeExec(obj: RunnerSetSpecTemplateSpecContainersReadinessProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
 *
 * @schema RunnerSetSpecTemplateSpecContainersReadinessProbeGrpc
 */
export interface RunnerSetSpecTemplateSpecContainersReadinessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema RunnerSetSpecTemplateSpecContainersReadinessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema RunnerSetSpecTemplateSpecContainersReadinessProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecContainersReadinessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecContainersReadinessProbeGrpc(obj: RunnerSetSpecTemplateSpecContainersReadinessProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema RunnerSetSpecTemplateSpecContainersReadinessProbeHttpGet
 */
export interface RunnerSetSpecTemplateSpecContainersReadinessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RunnerSetSpecTemplateSpecContainersReadinessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RunnerSetSpecTemplateSpecContainersReadinessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: RunnerSetSpecTemplateSpecContainersReadinessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RunnerSetSpecTemplateSpecContainersReadinessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerSetSpecTemplateSpecContainersReadinessProbeHttpGet#port
   */
  readonly port: RunnerSetSpecTemplateSpecContainersReadinessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RunnerSetSpecTemplateSpecContainersReadinessProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecContainersReadinessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecContainersReadinessProbeHttpGet(obj: RunnerSetSpecTemplateSpecContainersReadinessProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_RunnerSetSpecTemplateSpecContainersReadinessProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema RunnerSetSpecTemplateSpecContainersReadinessProbeTcpSocket
 */
export interface RunnerSetSpecTemplateSpecContainersReadinessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RunnerSetSpecTemplateSpecContainersReadinessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerSetSpecTemplateSpecContainersReadinessProbeTcpSocket#port
   */
  readonly port: RunnerSetSpecTemplateSpecContainersReadinessProbeTcpSocketPort;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecContainersReadinessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecContainersReadinessProbeTcpSocket(obj: RunnerSetSpecTemplateSpecContainersReadinessProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RunnerSetSpecTemplateSpecContainersResourcesLimits
 */
export class RunnerSetSpecTemplateSpecContainersResourcesLimits {
  public static fromNumber(value: number): RunnerSetSpecTemplateSpecContainersResourcesLimits {
    return new RunnerSetSpecTemplateSpecContainersResourcesLimits(value);
  }
  public static fromString(value: string): RunnerSetSpecTemplateSpecContainersResourcesLimits {
    return new RunnerSetSpecTemplateSpecContainersResourcesLimits(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * @schema RunnerSetSpecTemplateSpecContainersResourcesRequests
 */
export class RunnerSetSpecTemplateSpecContainersResourcesRequests {
  public static fromNumber(value: number): RunnerSetSpecTemplateSpecContainersResourcesRequests {
    return new RunnerSetSpecTemplateSpecContainersResourcesRequests(value);
  }
  public static fromString(value: string): RunnerSetSpecTemplateSpecContainersResourcesRequests {
    return new RunnerSetSpecTemplateSpecContainersResourcesRequests(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
 *
 * @default the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
 * @schema RunnerSetSpecTemplateSpecContainersSecurityContextCapabilities
 */
export interface RunnerSetSpecTemplateSpecContainersSecurityContextCapabilities {
  /**
   * Added capabilities
   *
   * @schema RunnerSetSpecTemplateSpecContainersSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * Removed capabilities
   *
   * @schema RunnerSetSpecTemplateSpecContainersSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecContainersSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecContainersSecurityContextCapabilities(obj: RunnerSetSpecTemplateSpecContainersSecurityContextCapabilities | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': obj.add?.map(y => y),
    'drop': obj.drop?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema RunnerSetSpecTemplateSpecContainersSecurityContextSeLinuxOptions
 */
export interface RunnerSetSpecTemplateSpecContainersSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema RunnerSetSpecTemplateSpecContainersSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema RunnerSetSpecTemplateSpecContainersSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema RunnerSetSpecTemplateSpecContainersSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema RunnerSetSpecTemplateSpecContainersSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecContainersSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecContainersSecurityContextSeLinuxOptions(obj: RunnerSetSpecTemplateSpecContainersSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The seccomp options to use by this container. If seccomp options are provided at both the pod & container level, the container options override the pod options. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema RunnerSetSpecTemplateSpecContainersSecurityContextSeccompProfile
 */
export interface RunnerSetSpecTemplateSpecContainersSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Must be a descending path, relative to the kubelet's configured seccomp profile location. Must only be set if type is "Localhost".
   *
   * @schema RunnerSetSpecTemplateSpecContainersSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied. Valid options are:
   * Localhost - a profile defined in a file on the node should be used. RuntimeDefault - the container runtime default profile should be used. Unconfined - no profile should be applied.
   *
   * @schema RunnerSetSpecTemplateSpecContainersSecurityContextSeccompProfile#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecContainersSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecContainersSecurityContextSeccompProfile(obj: RunnerSetSpecTemplateSpecContainersSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Windows specific settings applied to all containers. If unspecified, the options from the PodSecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema RunnerSetSpecTemplateSpecContainersSecurityContextWindowsOptions
 */
export interface RunnerSetSpecTemplateSpecContainersSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema RunnerSetSpecTemplateSpecContainersSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema RunnerSetSpecTemplateSpecContainersSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container. This field is alpha-level and will only be honored by components that enable the WindowsHostProcessContainers feature flag. Setting this field without the feature flag will result in errors when validating the Pod. All of a Pod's containers must have the same effective HostProcess value (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).  In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema RunnerSetSpecTemplateSpecContainersSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process. Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * @schema RunnerSetSpecTemplateSpecContainersSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecContainersSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecContainersSecurityContextWindowsOptions(obj: RunnerSetSpecTemplateSpecContainersSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema RunnerSetSpecTemplateSpecContainersStartupProbeExec
 */
export interface RunnerSetSpecTemplateSpecContainersStartupProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RunnerSetSpecTemplateSpecContainersStartupProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecContainersStartupProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecContainersStartupProbeExec(obj: RunnerSetSpecTemplateSpecContainersStartupProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
 *
 * @schema RunnerSetSpecTemplateSpecContainersStartupProbeGrpc
 */
export interface RunnerSetSpecTemplateSpecContainersStartupProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema RunnerSetSpecTemplateSpecContainersStartupProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema RunnerSetSpecTemplateSpecContainersStartupProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecContainersStartupProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecContainersStartupProbeGrpc(obj: RunnerSetSpecTemplateSpecContainersStartupProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema RunnerSetSpecTemplateSpecContainersStartupProbeHttpGet
 */
export interface RunnerSetSpecTemplateSpecContainersStartupProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RunnerSetSpecTemplateSpecContainersStartupProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RunnerSetSpecTemplateSpecContainersStartupProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: RunnerSetSpecTemplateSpecContainersStartupProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RunnerSetSpecTemplateSpecContainersStartupProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerSetSpecTemplateSpecContainersStartupProbeHttpGet#port
   */
  readonly port: RunnerSetSpecTemplateSpecContainersStartupProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RunnerSetSpecTemplateSpecContainersStartupProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecContainersStartupProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecContainersStartupProbeHttpGet(obj: RunnerSetSpecTemplateSpecContainersStartupProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_RunnerSetSpecTemplateSpecContainersStartupProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema RunnerSetSpecTemplateSpecContainersStartupProbeTcpSocket
 */
export interface RunnerSetSpecTemplateSpecContainersStartupProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RunnerSetSpecTemplateSpecContainersStartupProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerSetSpecTemplateSpecContainersStartupProbeTcpSocket#port
   */
  readonly port: RunnerSetSpecTemplateSpecContainersStartupProbeTcpSocketPort;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecContainersStartupProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecContainersStartupProbeTcpSocket(obj: RunnerSetSpecTemplateSpecContainersStartupProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema RunnerSetSpecTemplateSpecEphemeralContainersEnvValueFrom
 */
export interface RunnerSetSpecTemplateSpecEphemeralContainersEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: RunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersEnvValueFrom#fieldRef
   */
  readonly fieldRef?: RunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: RunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: RunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecEphemeralContainersEnvValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecEphemeralContainersEnvValueFrom(obj: RunnerSetSpecTemplateSpecEphemeralContainersEnvValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_RunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromConfigMapKeyRef(obj.configMapKeyRef),
    'fieldRef': toJson_RunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromFieldRef(obj.fieldRef),
    'resourceFieldRef': toJson_RunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRef(obj.resourceFieldRef),
    'secretKeyRef': toJson_RunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema RunnerSetSpecTemplateSpecEphemeralContainersEnvFromConfigMapRef
 */
export interface RunnerSetSpecTemplateSpecEphemeralContainersEnvFromConfigMapRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersEnvFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersEnvFromConfigMapRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecEphemeralContainersEnvFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecEphemeralContainersEnvFromConfigMapRef(obj: RunnerSetSpecTemplateSpecEphemeralContainersEnvFromConfigMapRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Secret to select from
 *
 * @schema RunnerSetSpecTemplateSpecEphemeralContainersEnvFromSecretRef
 */
export interface RunnerSetSpecTemplateSpecEphemeralContainersEnvFromSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersEnvFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersEnvFromSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecEphemeralContainersEnvFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecEphemeralContainersEnvFromSecretRef(obj: RunnerSetSpecTemplateSpecEphemeralContainersEnvFromSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PostStart is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStart
 */
export interface RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStart {
  /**
   * Exec specifies the action to take.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStart#exec
   */
  readonly exec?: RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartExec;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStart#httpGet
   */
  readonly httpGet?: RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGet;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStart#tcpSocket
   */
  readonly tcpSocket?: RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocket;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStart' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStart(obj: RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStart | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartExec(obj.exec),
    'httpGet': toJson_RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGet(obj.httpGet),
    'tcpSocket': toJson_RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PreStop is called immediately before a container is terminated due to an API request or management event such as liveness/startup probe failure, preemption, resource contention, etc. The handler is not called if the container crashes or exits. The Pod's termination grace period countdown begins before the PreStop hook is executed. Regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period (unless delayed by finalizers). Other management of the container blocks until the hook completes or until the termination grace period is reached. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStop
 */
export interface RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStop {
  /**
   * Exec specifies the action to take.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStop#exec
   */
  readonly exec?: RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopExec;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStop#httpGet
   */
  readonly httpGet?: RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGet;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStop#tcpSocket
   */
  readonly tcpSocket?: RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocket;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStop' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStop(obj: RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStop | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopExec(obj.exec),
    'httpGet': toJson_RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGet(obj.httpGet),
    'tcpSocket': toJson_RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeExec
 */
export interface RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeExec(obj: RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
 *
 * @schema RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeGrpc
 */
export interface RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeGrpc(obj: RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGet
 */
export interface RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGet#port
   */
  readonly port: RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGet(obj: RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocket
 */
export interface RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocket#port
   */
  readonly port: RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocketPort;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocket(obj: RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeExec
 */
export interface RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeExec(obj: RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
 *
 * @schema RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeGrpc
 */
export interface RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeGrpc(obj: RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGet
 */
export interface RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGet#port
   */
  readonly port: RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGet(obj: RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocket
 */
export interface RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocket#port
   */
  readonly port: RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocketPort;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocket(obj: RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RunnerSetSpecTemplateSpecEphemeralContainersResourcesLimits
 */
export class RunnerSetSpecTemplateSpecEphemeralContainersResourcesLimits {
  public static fromNumber(value: number): RunnerSetSpecTemplateSpecEphemeralContainersResourcesLimits {
    return new RunnerSetSpecTemplateSpecEphemeralContainersResourcesLimits(value);
  }
  public static fromString(value: string): RunnerSetSpecTemplateSpecEphemeralContainersResourcesLimits {
    return new RunnerSetSpecTemplateSpecEphemeralContainersResourcesLimits(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * @schema RunnerSetSpecTemplateSpecEphemeralContainersResourcesRequests
 */
export class RunnerSetSpecTemplateSpecEphemeralContainersResourcesRequests {
  public static fromNumber(value: number): RunnerSetSpecTemplateSpecEphemeralContainersResourcesRequests {
    return new RunnerSetSpecTemplateSpecEphemeralContainersResourcesRequests(value);
  }
  public static fromString(value: string): RunnerSetSpecTemplateSpecEphemeralContainersResourcesRequests {
    return new RunnerSetSpecTemplateSpecEphemeralContainersResourcesRequests(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
 *
 * @default the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
 * @schema RunnerSetSpecTemplateSpecEphemeralContainersSecurityContextCapabilities
 */
export interface RunnerSetSpecTemplateSpecEphemeralContainersSecurityContextCapabilities {
  /**
   * Added capabilities
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * Removed capabilities
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecEphemeralContainersSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecEphemeralContainersSecurityContextCapabilities(obj: RunnerSetSpecTemplateSpecEphemeralContainersSecurityContextCapabilities | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': obj.add?.map(y => y),
    'drop': obj.drop?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema RunnerSetSpecTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions
 */
export interface RunnerSetSpecTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions(obj: RunnerSetSpecTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The seccomp options to use by this container. If seccomp options are provided at both the pod & container level, the container options override the pod options. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema RunnerSetSpecTemplateSpecEphemeralContainersSecurityContextSeccompProfile
 */
export interface RunnerSetSpecTemplateSpecEphemeralContainersSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Must be a descending path, relative to the kubelet's configured seccomp profile location. Must only be set if type is "Localhost".
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied. Valid options are:
   * Localhost - a profile defined in a file on the node should be used. RuntimeDefault - the container runtime default profile should be used. Unconfined - no profile should be applied.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersSecurityContextSeccompProfile#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecEphemeralContainersSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecEphemeralContainersSecurityContextSeccompProfile(obj: RunnerSetSpecTemplateSpecEphemeralContainersSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Windows specific settings applied to all containers. If unspecified, the options from the PodSecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema RunnerSetSpecTemplateSpecEphemeralContainersSecurityContextWindowsOptions
 */
export interface RunnerSetSpecTemplateSpecEphemeralContainersSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container. This field is alpha-level and will only be honored by components that enable the WindowsHostProcessContainers feature flag. Setting this field without the feature flag will result in errors when validating the Pod. All of a Pod's containers must have the same effective HostProcess value (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).  In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process. Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecEphemeralContainersSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecEphemeralContainersSecurityContextWindowsOptions(obj: RunnerSetSpecTemplateSpecEphemeralContainersSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema RunnerSetSpecTemplateSpecEphemeralContainersStartupProbeExec
 */
export interface RunnerSetSpecTemplateSpecEphemeralContainersStartupProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersStartupProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecEphemeralContainersStartupProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecEphemeralContainersStartupProbeExec(obj: RunnerSetSpecTemplateSpecEphemeralContainersStartupProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
 *
 * @schema RunnerSetSpecTemplateSpecEphemeralContainersStartupProbeGrpc
 */
export interface RunnerSetSpecTemplateSpecEphemeralContainersStartupProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersStartupProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersStartupProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecEphemeralContainersStartupProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecEphemeralContainersStartupProbeGrpc(obj: RunnerSetSpecTemplateSpecEphemeralContainersStartupProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema RunnerSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGet
 */
export interface RunnerSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: RunnerSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGet#port
   */
  readonly port: RunnerSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGet(obj: RunnerSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_RunnerSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema RunnerSetSpecTemplateSpecEphemeralContainersStartupProbeTcpSocket
 */
export interface RunnerSetSpecTemplateSpecEphemeralContainersStartupProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersStartupProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersStartupProbeTcpSocket#port
   */
  readonly port: RunnerSetSpecTemplateSpecEphemeralContainersStartupProbeTcpSocketPort;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecEphemeralContainersStartupProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecEphemeralContainersStartupProbeTcpSocket(obj: RunnerSetSpecTemplateSpecEphemeralContainersStartupProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema RunnerSetSpecTemplateSpecInitContainersEnvValueFrom
 */
export interface RunnerSetSpecTemplateSpecInitContainersEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: RunnerSetSpecTemplateSpecInitContainersEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersEnvValueFrom#fieldRef
   */
  readonly fieldRef?: RunnerSetSpecTemplateSpecInitContainersEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: RunnerSetSpecTemplateSpecInitContainersEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: RunnerSetSpecTemplateSpecInitContainersEnvValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecInitContainersEnvValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecInitContainersEnvValueFrom(obj: RunnerSetSpecTemplateSpecInitContainersEnvValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_RunnerSetSpecTemplateSpecInitContainersEnvValueFromConfigMapKeyRef(obj.configMapKeyRef),
    'fieldRef': toJson_RunnerSetSpecTemplateSpecInitContainersEnvValueFromFieldRef(obj.fieldRef),
    'resourceFieldRef': toJson_RunnerSetSpecTemplateSpecInitContainersEnvValueFromResourceFieldRef(obj.resourceFieldRef),
    'secretKeyRef': toJson_RunnerSetSpecTemplateSpecInitContainersEnvValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema RunnerSetSpecTemplateSpecInitContainersEnvFromConfigMapRef
 */
export interface RunnerSetSpecTemplateSpecInitContainersEnvFromConfigMapRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersEnvFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersEnvFromConfigMapRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecInitContainersEnvFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecInitContainersEnvFromConfigMapRef(obj: RunnerSetSpecTemplateSpecInitContainersEnvFromConfigMapRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Secret to select from
 *
 * @schema RunnerSetSpecTemplateSpecInitContainersEnvFromSecretRef
 */
export interface RunnerSetSpecTemplateSpecInitContainersEnvFromSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersEnvFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersEnvFromSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecInitContainersEnvFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecInitContainersEnvFromSecretRef(obj: RunnerSetSpecTemplateSpecInitContainersEnvFromSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PostStart is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema RunnerSetSpecTemplateSpecInitContainersLifecyclePostStart
 */
export interface RunnerSetSpecTemplateSpecInitContainersLifecyclePostStart {
  /**
   * Exec specifies the action to take.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersLifecyclePostStart#exec
   */
  readonly exec?: RunnerSetSpecTemplateSpecInitContainersLifecyclePostStartExec;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersLifecyclePostStart#httpGet
   */
  readonly httpGet?: RunnerSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGet;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersLifecyclePostStart#tcpSocket
   */
  readonly tcpSocket?: RunnerSetSpecTemplateSpecInitContainersLifecyclePostStartTcpSocket;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecInitContainersLifecyclePostStart' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecInitContainersLifecyclePostStart(obj: RunnerSetSpecTemplateSpecInitContainersLifecyclePostStart | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_RunnerSetSpecTemplateSpecInitContainersLifecyclePostStartExec(obj.exec),
    'httpGet': toJson_RunnerSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGet(obj.httpGet),
    'tcpSocket': toJson_RunnerSetSpecTemplateSpecInitContainersLifecyclePostStartTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PreStop is called immediately before a container is terminated due to an API request or management event such as liveness/startup probe failure, preemption, resource contention, etc. The handler is not called if the container crashes or exits. The Pod's termination grace period countdown begins before the PreStop hook is executed. Regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period (unless delayed by finalizers). Other management of the container blocks until the hook completes or until the termination grace period is reached. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema RunnerSetSpecTemplateSpecInitContainersLifecyclePreStop
 */
export interface RunnerSetSpecTemplateSpecInitContainersLifecyclePreStop {
  /**
   * Exec specifies the action to take.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersLifecyclePreStop#exec
   */
  readonly exec?: RunnerSetSpecTemplateSpecInitContainersLifecyclePreStopExec;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersLifecyclePreStop#httpGet
   */
  readonly httpGet?: RunnerSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGet;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersLifecyclePreStop#tcpSocket
   */
  readonly tcpSocket?: RunnerSetSpecTemplateSpecInitContainersLifecyclePreStopTcpSocket;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecInitContainersLifecyclePreStop' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecInitContainersLifecyclePreStop(obj: RunnerSetSpecTemplateSpecInitContainersLifecyclePreStop | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_RunnerSetSpecTemplateSpecInitContainersLifecyclePreStopExec(obj.exec),
    'httpGet': toJson_RunnerSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGet(obj.httpGet),
    'tcpSocket': toJson_RunnerSetSpecTemplateSpecInitContainersLifecyclePreStopTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema RunnerSetSpecTemplateSpecInitContainersLivenessProbeExec
 */
export interface RunnerSetSpecTemplateSpecInitContainersLivenessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersLivenessProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecInitContainersLivenessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecInitContainersLivenessProbeExec(obj: RunnerSetSpecTemplateSpecInitContainersLivenessProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
 *
 * @schema RunnerSetSpecTemplateSpecInitContainersLivenessProbeGrpc
 */
export interface RunnerSetSpecTemplateSpecInitContainersLivenessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersLivenessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersLivenessProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecInitContainersLivenessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecInitContainersLivenessProbeGrpc(obj: RunnerSetSpecTemplateSpecInitContainersLivenessProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema RunnerSetSpecTemplateSpecInitContainersLivenessProbeHttpGet
 */
export interface RunnerSetSpecTemplateSpecInitContainersLivenessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersLivenessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersLivenessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: RunnerSetSpecTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersLivenessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersLivenessProbeHttpGet#port
   */
  readonly port: RunnerSetSpecTemplateSpecInitContainersLivenessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RunnerSetSpecTemplateSpecInitContainersLivenessProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecInitContainersLivenessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecInitContainersLivenessProbeHttpGet(obj: RunnerSetSpecTemplateSpecInitContainersLivenessProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_RunnerSetSpecTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema RunnerSetSpecTemplateSpecInitContainersLivenessProbeTcpSocket
 */
export interface RunnerSetSpecTemplateSpecInitContainersLivenessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersLivenessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersLivenessProbeTcpSocket#port
   */
  readonly port: RunnerSetSpecTemplateSpecInitContainersLivenessProbeTcpSocketPort;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecInitContainersLivenessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecInitContainersLivenessProbeTcpSocket(obj: RunnerSetSpecTemplateSpecInitContainersLivenessProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema RunnerSetSpecTemplateSpecInitContainersReadinessProbeExec
 */
export interface RunnerSetSpecTemplateSpecInitContainersReadinessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersReadinessProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecInitContainersReadinessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecInitContainersReadinessProbeExec(obj: RunnerSetSpecTemplateSpecInitContainersReadinessProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
 *
 * @schema RunnerSetSpecTemplateSpecInitContainersReadinessProbeGrpc
 */
export interface RunnerSetSpecTemplateSpecInitContainersReadinessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersReadinessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersReadinessProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecInitContainersReadinessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecInitContainersReadinessProbeGrpc(obj: RunnerSetSpecTemplateSpecInitContainersReadinessProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema RunnerSetSpecTemplateSpecInitContainersReadinessProbeHttpGet
 */
export interface RunnerSetSpecTemplateSpecInitContainersReadinessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersReadinessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersReadinessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: RunnerSetSpecTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersReadinessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersReadinessProbeHttpGet#port
   */
  readonly port: RunnerSetSpecTemplateSpecInitContainersReadinessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RunnerSetSpecTemplateSpecInitContainersReadinessProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecInitContainersReadinessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecInitContainersReadinessProbeHttpGet(obj: RunnerSetSpecTemplateSpecInitContainersReadinessProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_RunnerSetSpecTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema RunnerSetSpecTemplateSpecInitContainersReadinessProbeTcpSocket
 */
export interface RunnerSetSpecTemplateSpecInitContainersReadinessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersReadinessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersReadinessProbeTcpSocket#port
   */
  readonly port: RunnerSetSpecTemplateSpecInitContainersReadinessProbeTcpSocketPort;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecInitContainersReadinessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecInitContainersReadinessProbeTcpSocket(obj: RunnerSetSpecTemplateSpecInitContainersReadinessProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RunnerSetSpecTemplateSpecInitContainersResourcesLimits
 */
export class RunnerSetSpecTemplateSpecInitContainersResourcesLimits {
  public static fromNumber(value: number): RunnerSetSpecTemplateSpecInitContainersResourcesLimits {
    return new RunnerSetSpecTemplateSpecInitContainersResourcesLimits(value);
  }
  public static fromString(value: string): RunnerSetSpecTemplateSpecInitContainersResourcesLimits {
    return new RunnerSetSpecTemplateSpecInitContainersResourcesLimits(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * @schema RunnerSetSpecTemplateSpecInitContainersResourcesRequests
 */
export class RunnerSetSpecTemplateSpecInitContainersResourcesRequests {
  public static fromNumber(value: number): RunnerSetSpecTemplateSpecInitContainersResourcesRequests {
    return new RunnerSetSpecTemplateSpecInitContainersResourcesRequests(value);
  }
  public static fromString(value: string): RunnerSetSpecTemplateSpecInitContainersResourcesRequests {
    return new RunnerSetSpecTemplateSpecInitContainersResourcesRequests(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
 *
 * @default the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
 * @schema RunnerSetSpecTemplateSpecInitContainersSecurityContextCapabilities
 */
export interface RunnerSetSpecTemplateSpecInitContainersSecurityContextCapabilities {
  /**
   * Added capabilities
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * Removed capabilities
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecInitContainersSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecInitContainersSecurityContextCapabilities(obj: RunnerSetSpecTemplateSpecInitContainersSecurityContextCapabilities | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': obj.add?.map(y => y),
    'drop': obj.drop?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema RunnerSetSpecTemplateSpecInitContainersSecurityContextSeLinuxOptions
 */
export interface RunnerSetSpecTemplateSpecInitContainersSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecInitContainersSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecInitContainersSecurityContextSeLinuxOptions(obj: RunnerSetSpecTemplateSpecInitContainersSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The seccomp options to use by this container. If seccomp options are provided at both the pod & container level, the container options override the pod options. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema RunnerSetSpecTemplateSpecInitContainersSecurityContextSeccompProfile
 */
export interface RunnerSetSpecTemplateSpecInitContainersSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Must be a descending path, relative to the kubelet's configured seccomp profile location. Must only be set if type is "Localhost".
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied. Valid options are:
   * Localhost - a profile defined in a file on the node should be used. RuntimeDefault - the container runtime default profile should be used. Unconfined - no profile should be applied.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersSecurityContextSeccompProfile#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecInitContainersSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecInitContainersSecurityContextSeccompProfile(obj: RunnerSetSpecTemplateSpecInitContainersSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Windows specific settings applied to all containers. If unspecified, the options from the PodSecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema RunnerSetSpecTemplateSpecInitContainersSecurityContextWindowsOptions
 */
export interface RunnerSetSpecTemplateSpecInitContainersSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container. This field is alpha-level and will only be honored by components that enable the WindowsHostProcessContainers feature flag. Setting this field without the feature flag will result in errors when validating the Pod. All of a Pod's containers must have the same effective HostProcess value (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).  In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process. Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * @schema RunnerSetSpecTemplateSpecInitContainersSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecInitContainersSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecInitContainersSecurityContextWindowsOptions(obj: RunnerSetSpecTemplateSpecInitContainersSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema RunnerSetSpecTemplateSpecInitContainersStartupProbeExec
 */
export interface RunnerSetSpecTemplateSpecInitContainersStartupProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersStartupProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecInitContainersStartupProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecInitContainersStartupProbeExec(obj: RunnerSetSpecTemplateSpecInitContainersStartupProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
 *
 * @schema RunnerSetSpecTemplateSpecInitContainersStartupProbeGrpc
 */
export interface RunnerSetSpecTemplateSpecInitContainersStartupProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersStartupProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersStartupProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecInitContainersStartupProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecInitContainersStartupProbeGrpc(obj: RunnerSetSpecTemplateSpecInitContainersStartupProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema RunnerSetSpecTemplateSpecInitContainersStartupProbeHttpGet
 */
export interface RunnerSetSpecTemplateSpecInitContainersStartupProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersStartupProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersStartupProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: RunnerSetSpecTemplateSpecInitContainersStartupProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersStartupProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersStartupProbeHttpGet#port
   */
  readonly port: RunnerSetSpecTemplateSpecInitContainersStartupProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RunnerSetSpecTemplateSpecInitContainersStartupProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecInitContainersStartupProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecInitContainersStartupProbeHttpGet(obj: RunnerSetSpecTemplateSpecInitContainersStartupProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_RunnerSetSpecTemplateSpecInitContainersStartupProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema RunnerSetSpecTemplateSpecInitContainersStartupProbeTcpSocket
 */
export interface RunnerSetSpecTemplateSpecInitContainersStartupProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersStartupProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersStartupProbeTcpSocket#port
   */
  readonly port: RunnerSetSpecTemplateSpecInitContainersStartupProbeTcpSocketPort;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecInitContainersStartupProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecInitContainersStartupProbeTcpSocket(obj: RunnerSetSpecTemplateSpecInitContainersStartupProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema RunnerSetSpecTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressions
 */
export interface RunnerSetSpecTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema RunnerSetSpecTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema RunnerSetSpecTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema RunnerSetSpecTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressions(obj: RunnerSetSpecTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Optional: SecretRef is reference to the authentication secret for User, default is empty. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
 *
 * @schema RunnerSetSpecTemplateSpecVolumesCephfsSecretRef
 */
export interface RunnerSetSpecTemplateSpecVolumesCephfsSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerSetSpecTemplateSpecVolumesCephfsSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecVolumesCephfsSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecVolumesCephfsSecretRef(obj: RunnerSetSpecTemplateSpecVolumesCephfsSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Optional: points to a secret object containing parameters used to connect to OpenStack.
 *
 * @schema RunnerSetSpecTemplateSpecVolumesCinderSecretRef
 */
export interface RunnerSetSpecTemplateSpecVolumesCinderSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerSetSpecTemplateSpecVolumesCinderSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecVolumesCinderSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecVolumesCinderSecretRef(obj: RunnerSetSpecTemplateSpecVolumesCinderSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema RunnerSetSpecTemplateSpecVolumesConfigMapItems
 */
export interface RunnerSetSpecTemplateSpecVolumesConfigMapItems {
  /**
   * The key to project.
   *
   * @schema RunnerSetSpecTemplateSpecVolumesConfigMapItems#key
   */
  readonly key: string;

  /**
   * Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema RunnerSetSpecTemplateSpecVolumesConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema RunnerSetSpecTemplateSpecVolumesConfigMapItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecVolumesConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecVolumesConfigMapItems(obj: RunnerSetSpecTemplateSpecVolumesConfigMapItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NodePublishSecretRef is a reference to the secret object containing sensitive information to pass to the CSI driver to complete the CSI NodePublishVolume and NodeUnpublishVolume calls. This field is optional, and  may be empty if no secret is required. If the secret object contains more than one secret, all secret references are passed.
 *
 * @schema RunnerSetSpecTemplateSpecVolumesCsiNodePublishSecretRef
 */
export interface RunnerSetSpecTemplateSpecVolumesCsiNodePublishSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerSetSpecTemplateSpecVolumesCsiNodePublishSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecVolumesCsiNodePublishSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecVolumesCsiNodePublishSecretRef(obj: RunnerSetSpecTemplateSpecVolumesCsiNodePublishSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DownwardAPIVolumeFile represents information to create the file containing the pod field
 *
 * @schema RunnerSetSpecTemplateSpecVolumesDownwardApiItems
 */
export interface RunnerSetSpecTemplateSpecVolumesDownwardApiItems {
  /**
   * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
   *
   * @schema RunnerSetSpecTemplateSpecVolumesDownwardApiItems#fieldRef
   */
  readonly fieldRef?: RunnerSetSpecTemplateSpecVolumesDownwardApiItemsFieldRef;

  /**
   * Optional: mode bits used to set permissions on this file, must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema RunnerSetSpecTemplateSpecVolumesDownwardApiItems#mode
   */
  readonly mode?: number;

  /**
   * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
   *
   * @schema RunnerSetSpecTemplateSpecVolumesDownwardApiItems#path
   */
  readonly path: string;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
   *
   * @schema RunnerSetSpecTemplateSpecVolumesDownwardApiItems#resourceFieldRef
   */
  readonly resourceFieldRef?: RunnerSetSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRef;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecVolumesDownwardApiItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecVolumesDownwardApiItems(obj: RunnerSetSpecTemplateSpecVolumesDownwardApiItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fieldRef': toJson_RunnerSetSpecTemplateSpecVolumesDownwardApiItemsFieldRef(obj.fieldRef),
    'mode': obj.mode,
    'path': obj.path,
    'resourceFieldRef': toJson_RunnerSetSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRef(obj.resourceFieldRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. The default is nil which means that the limit is undefined. More info: http://kubernetes.io/docs/user-guide/volumes#emptydir
 *
 * @schema RunnerSetSpecTemplateSpecVolumesEmptyDirSizeLimit
 */
export class RunnerSetSpecTemplateSpecVolumesEmptyDirSizeLimit {
  public static fromNumber(value: number): RunnerSetSpecTemplateSpecVolumesEmptyDirSizeLimit {
    return new RunnerSetSpecTemplateSpecVolumesEmptyDirSizeLimit(value);
  }
  public static fromString(value: string): RunnerSetSpecTemplateSpecVolumesEmptyDirSizeLimit {
    return new RunnerSetSpecTemplateSpecVolumesEmptyDirSizeLimit(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Will be used to create a stand-alone PVC to provision the volume. The pod in which this EphemeralVolumeSource is embedded will be the owner of the PVC, i.e. the PVC will be deleted together with the pod.  The name of the PVC will be `<pod name>-<volume name>` where `<volume name>` is the name from the `PodSpec.Volumes` array entry. Pod validation will reject the pod if the concatenated name is not valid for a PVC (for example, too long).
 * An existing PVC with that name that is not owned by the pod will *not* be used for the pod to avoid using an unrelated volume by mistake. Starting the pod is then blocked until the unrelated PVC is removed. If such a pre-created PVC is meant to be used by the pod, the PVC has to updated with an owner reference to the pod once the pod exists. Normally this should not be necessary, but it may be useful when manually reconstructing a broken cluster.
 * This field is read-only and no changes will be made by Kubernetes to the PVC after it has been created.
 * Required, must not be nil.
 *
 * @schema RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplate
 */
export interface RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplate {
  /**
   * May contain labels and annotations that will be copied into the PVC when creating it. No other fields are allowed and will be rejected during validation.
   *
   * @schema RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplate#metadata
   */
  readonly metadata?: RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateMetadata;

  /**
   * The specification for the PersistentVolumeClaim. The entire content is copied unchanged into the PVC that gets created from this template. The same fields as in a PersistentVolumeClaim are also valid here.
   *
   * @schema RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplate#spec
   */
  readonly spec: RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplate(obj: RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateMetadata(obj.metadata),
    'spec': toJson_RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Optional: SecretRef is reference to the secret object containing sensitive information to pass to the plugin scripts. This may be empty if no secret object is specified. If the secret object contains more than one secret, all secrets are passed to the plugin scripts.
 *
 * @schema RunnerSetSpecTemplateSpecVolumesFlexVolumeSecretRef
 */
export interface RunnerSetSpecTemplateSpecVolumesFlexVolumeSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerSetSpecTemplateSpecVolumesFlexVolumeSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecVolumesFlexVolumeSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecVolumesFlexVolumeSecretRef(obj: RunnerSetSpecTemplateSpecVolumesFlexVolumeSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CHAP Secret for iSCSI target and initiator authentication
 *
 * @schema RunnerSetSpecTemplateSpecVolumesIscsiSecretRef
 */
export interface RunnerSetSpecTemplateSpecVolumesIscsiSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerSetSpecTemplateSpecVolumesIscsiSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecVolumesIscsiSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecVolumesIscsiSecretRef(obj: RunnerSetSpecTemplateSpecVolumesIscsiSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Projection that may be projected along with other supported volume types
 *
 * @schema RunnerSetSpecTemplateSpecVolumesProjectedSources
 */
export interface RunnerSetSpecTemplateSpecVolumesProjectedSources {
  /**
   * information about the configMap data to project
   *
   * @schema RunnerSetSpecTemplateSpecVolumesProjectedSources#configMap
   */
  readonly configMap?: RunnerSetSpecTemplateSpecVolumesProjectedSourcesConfigMap;

  /**
   * information about the downwardAPI data to project
   *
   * @schema RunnerSetSpecTemplateSpecVolumesProjectedSources#downwardAPI
   */
  readonly downwardApi?: RunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApi;

  /**
   * information about the secret data to project
   *
   * @schema RunnerSetSpecTemplateSpecVolumesProjectedSources#secret
   */
  readonly secret?: RunnerSetSpecTemplateSpecVolumesProjectedSourcesSecret;

  /**
   * information about the serviceAccountToken data to project
   *
   * @schema RunnerSetSpecTemplateSpecVolumesProjectedSources#serviceAccountToken
   */
  readonly serviceAccountToken?: RunnerSetSpecTemplateSpecVolumesProjectedSourcesServiceAccountToken;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecVolumesProjectedSources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecVolumesProjectedSources(obj: RunnerSetSpecTemplateSpecVolumesProjectedSources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_RunnerSetSpecTemplateSpecVolumesProjectedSourcesConfigMap(obj.configMap),
    'downwardAPI': toJson_RunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApi(obj.downwardApi),
    'secret': toJson_RunnerSetSpecTemplateSpecVolumesProjectedSourcesSecret(obj.secret),
    'serviceAccountToken': toJson_RunnerSetSpecTemplateSpecVolumesProjectedSourcesServiceAccountToken(obj.serviceAccountToken),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretRef is name of the authentication secret for RBDUser. If provided overrides keyring. Default is nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
 *
 * @default nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
 * @schema RunnerSetSpecTemplateSpecVolumesRbdSecretRef
 */
export interface RunnerSetSpecTemplateSpecVolumesRbdSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerSetSpecTemplateSpecVolumesRbdSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecVolumesRbdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecVolumesRbdSecretRef(obj: RunnerSetSpecTemplateSpecVolumesRbdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretRef references to the secret for ScaleIO user and other sensitive information. If this is not provided, Login operation will fail.
 *
 * @schema RunnerSetSpecTemplateSpecVolumesScaleIoSecretRef
 */
export interface RunnerSetSpecTemplateSpecVolumesScaleIoSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerSetSpecTemplateSpecVolumesScaleIoSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecVolumesScaleIoSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecVolumesScaleIoSecretRef(obj: RunnerSetSpecTemplateSpecVolumesScaleIoSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema RunnerSetSpecTemplateSpecVolumesSecretItems
 */
export interface RunnerSetSpecTemplateSpecVolumesSecretItems {
  /**
   * The key to project.
   *
   * @schema RunnerSetSpecTemplateSpecVolumesSecretItems#key
   */
  readonly key: string;

  /**
   * Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema RunnerSetSpecTemplateSpecVolumesSecretItems#mode
   */
  readonly mode?: number;

  /**
   * The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema RunnerSetSpecTemplateSpecVolumesSecretItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecVolumesSecretItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecVolumesSecretItems(obj: RunnerSetSpecTemplateSpecVolumesSecretItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretRef specifies the secret to use for obtaining the StorageOS API credentials.  If not specified, default values will be attempted.
 *
 * @schema RunnerSetSpecTemplateSpecVolumesStorageosSecretRef
 */
export interface RunnerSetSpecTemplateSpecVolumesStorageosSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerSetSpecTemplateSpecVolumesStorageosSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecVolumesStorageosSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecVolumesStorageosSecretRef(obj: RunnerSetSpecTemplateSpecVolumesStorageosSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector term, associated with the corresponding weight.
 *
 * @schema RunnerSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface RunnerSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: RunnerSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: RunnerSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj: RunnerSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_RunnerSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_RunnerSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A null or empty node selector term matches no objects. The requirements of them are ANDed. The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
 *
 * @schema RunnerSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface RunnerSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: RunnerSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: RunnerSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(obj: RunnerSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_RunnerSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_RunnerSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema RunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface RunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: RunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces. This field is beta-level and is only honored when PodAffinityNamespaceSelector feature is enabled.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: RunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means "this pod's namespace"
   *
   * @schema RunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: RunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_RunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_RunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 *
 * @schema RunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface RunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: RunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: RunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_RunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces. This field is beta-level and is only honored when PodAffinityNamespaceSelector feature is enabled.
 *
 * @schema RunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface RunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: RunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: RunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_RunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema RunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface RunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: RunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces. This field is beta-level and is only honored when PodAffinityNamespaceSelector feature is enabled.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: RunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means "this pod's namespace"
   *
   * @schema RunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: RunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_RunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_RunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 *
 * @schema RunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface RunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: RunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: RunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_RunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces. This field is beta-level and is only honored when PodAffinityNamespaceSelector feature is enabled.
 *
 * @schema RunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface RunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: RunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: RunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_RunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a ConfigMap.
 *
 * @schema RunnerSetSpecTemplateSpecContainersEnvValueFromConfigMapKeyRef
 */
export interface RunnerSetSpecTemplateSpecContainersEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema RunnerSetSpecTemplateSpecContainersEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerSetSpecTemplateSpecContainersEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema RunnerSetSpecTemplateSpecContainersEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecContainersEnvValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecContainersEnvValueFromConfigMapKeyRef(obj: RunnerSetSpecTemplateSpecContainersEnvValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema RunnerSetSpecTemplateSpecContainersEnvValueFromFieldRef
 */
export interface RunnerSetSpecTemplateSpecContainersEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema RunnerSetSpecTemplateSpecContainersEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema RunnerSetSpecTemplateSpecContainersEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecContainersEnvValueFromFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecContainersEnvValueFromFieldRef(obj: RunnerSetSpecTemplateSpecContainersEnvValueFromFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema RunnerSetSpecTemplateSpecContainersEnvValueFromResourceFieldRef
 */
export interface RunnerSetSpecTemplateSpecContainersEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema RunnerSetSpecTemplateSpecContainersEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema RunnerSetSpecTemplateSpecContainersEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: RunnerSetSpecTemplateSpecContainersEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema RunnerSetSpecTemplateSpecContainersEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecContainersEnvValueFromResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecContainersEnvValueFromResourceFieldRef(obj: RunnerSetSpecTemplateSpecContainersEnvValueFromResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema RunnerSetSpecTemplateSpecContainersEnvValueFromSecretKeyRef
 */
export interface RunnerSetSpecTemplateSpecContainersEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema RunnerSetSpecTemplateSpecContainersEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerSetSpecTemplateSpecContainersEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema RunnerSetSpecTemplateSpecContainersEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecContainersEnvValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecContainersEnvValueFromSecretKeyRef(obj: RunnerSetSpecTemplateSpecContainersEnvValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema RunnerSetSpecTemplateSpecContainersLifecyclePostStartExec
 */
export interface RunnerSetSpecTemplateSpecContainersLifecyclePostStartExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RunnerSetSpecTemplateSpecContainersLifecyclePostStartExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecContainersLifecyclePostStartExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecContainersLifecyclePostStartExec(obj: RunnerSetSpecTemplateSpecContainersLifecyclePostStartExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema RunnerSetSpecTemplateSpecContainersLifecyclePostStartHttpGet
 */
export interface RunnerSetSpecTemplateSpecContainersLifecyclePostStartHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RunnerSetSpecTemplateSpecContainersLifecyclePostStartHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RunnerSetSpecTemplateSpecContainersLifecyclePostStartHttpGet#httpHeaders
   */
  readonly httpHeaders?: RunnerSetSpecTemplateSpecContainersLifecyclePostStartHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RunnerSetSpecTemplateSpecContainersLifecyclePostStartHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerSetSpecTemplateSpecContainersLifecyclePostStartHttpGet#port
   */
  readonly port: RunnerSetSpecTemplateSpecContainersLifecyclePostStartHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RunnerSetSpecTemplateSpecContainersLifecyclePostStartHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecContainersLifecyclePostStartHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecContainersLifecyclePostStartHttpGet(obj: RunnerSetSpecTemplateSpecContainersLifecyclePostStartHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_RunnerSetSpecTemplateSpecContainersLifecyclePostStartHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
 *
 * @schema RunnerSetSpecTemplateSpecContainersLifecyclePostStartTcpSocket
 */
export interface RunnerSetSpecTemplateSpecContainersLifecyclePostStartTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RunnerSetSpecTemplateSpecContainersLifecyclePostStartTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerSetSpecTemplateSpecContainersLifecyclePostStartTcpSocket#port
   */
  readonly port: RunnerSetSpecTemplateSpecContainersLifecyclePostStartTcpSocketPort;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecContainersLifecyclePostStartTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecContainersLifecyclePostStartTcpSocket(obj: RunnerSetSpecTemplateSpecContainersLifecyclePostStartTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema RunnerSetSpecTemplateSpecContainersLifecyclePreStopExec
 */
export interface RunnerSetSpecTemplateSpecContainersLifecyclePreStopExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RunnerSetSpecTemplateSpecContainersLifecyclePreStopExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecContainersLifecyclePreStopExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecContainersLifecyclePreStopExec(obj: RunnerSetSpecTemplateSpecContainersLifecyclePreStopExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema RunnerSetSpecTemplateSpecContainersLifecyclePreStopHttpGet
 */
export interface RunnerSetSpecTemplateSpecContainersLifecyclePreStopHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RunnerSetSpecTemplateSpecContainersLifecyclePreStopHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RunnerSetSpecTemplateSpecContainersLifecyclePreStopHttpGet#httpHeaders
   */
  readonly httpHeaders?: RunnerSetSpecTemplateSpecContainersLifecyclePreStopHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RunnerSetSpecTemplateSpecContainersLifecyclePreStopHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerSetSpecTemplateSpecContainersLifecyclePreStopHttpGet#port
   */
  readonly port: RunnerSetSpecTemplateSpecContainersLifecyclePreStopHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RunnerSetSpecTemplateSpecContainersLifecyclePreStopHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecContainersLifecyclePreStopHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecContainersLifecyclePreStopHttpGet(obj: RunnerSetSpecTemplateSpecContainersLifecyclePreStopHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_RunnerSetSpecTemplateSpecContainersLifecyclePreStopHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
 *
 * @schema RunnerSetSpecTemplateSpecContainersLifecyclePreStopTcpSocket
 */
export interface RunnerSetSpecTemplateSpecContainersLifecyclePreStopTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RunnerSetSpecTemplateSpecContainersLifecyclePreStopTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerSetSpecTemplateSpecContainersLifecyclePreStopTcpSocket#port
   */
  readonly port: RunnerSetSpecTemplateSpecContainersLifecyclePreStopTcpSocketPort;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecContainersLifecyclePreStopTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecContainersLifecyclePreStopTcpSocket(obj: RunnerSetSpecTemplateSpecContainersLifecyclePreStopTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RunnerSetSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeaders
 */
export interface RunnerSetSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RunnerSetSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RunnerSetSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeaders(obj: RunnerSetSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerSetSpecTemplateSpecContainersLivenessProbeHttpGetPort
 */
export class RunnerSetSpecTemplateSpecContainersLivenessProbeHttpGetPort {
  public static fromNumber(value: number): RunnerSetSpecTemplateSpecContainersLivenessProbeHttpGetPort {
    return new RunnerSetSpecTemplateSpecContainersLivenessProbeHttpGetPort(value);
  }
  public static fromString(value: string): RunnerSetSpecTemplateSpecContainersLivenessProbeHttpGetPort {
    return new RunnerSetSpecTemplateSpecContainersLivenessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerSetSpecTemplateSpecContainersLivenessProbeTcpSocketPort
 */
export class RunnerSetSpecTemplateSpecContainersLivenessProbeTcpSocketPort {
  public static fromNumber(value: number): RunnerSetSpecTemplateSpecContainersLivenessProbeTcpSocketPort {
    return new RunnerSetSpecTemplateSpecContainersLivenessProbeTcpSocketPort(value);
  }
  public static fromString(value: string): RunnerSetSpecTemplateSpecContainersLivenessProbeTcpSocketPort {
    return new RunnerSetSpecTemplateSpecContainersLivenessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RunnerSetSpecTemplateSpecContainersReadinessProbeHttpGetHttpHeaders
 */
export interface RunnerSetSpecTemplateSpecContainersReadinessProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RunnerSetSpecTemplateSpecContainersReadinessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RunnerSetSpecTemplateSpecContainersReadinessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecContainersReadinessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecContainersReadinessProbeHttpGetHttpHeaders(obj: RunnerSetSpecTemplateSpecContainersReadinessProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerSetSpecTemplateSpecContainersReadinessProbeHttpGetPort
 */
export class RunnerSetSpecTemplateSpecContainersReadinessProbeHttpGetPort {
  public static fromNumber(value: number): RunnerSetSpecTemplateSpecContainersReadinessProbeHttpGetPort {
    return new RunnerSetSpecTemplateSpecContainersReadinessProbeHttpGetPort(value);
  }
  public static fromString(value: string): RunnerSetSpecTemplateSpecContainersReadinessProbeHttpGetPort {
    return new RunnerSetSpecTemplateSpecContainersReadinessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerSetSpecTemplateSpecContainersReadinessProbeTcpSocketPort
 */
export class RunnerSetSpecTemplateSpecContainersReadinessProbeTcpSocketPort {
  public static fromNumber(value: number): RunnerSetSpecTemplateSpecContainersReadinessProbeTcpSocketPort {
    return new RunnerSetSpecTemplateSpecContainersReadinessProbeTcpSocketPort(value);
  }
  public static fromString(value: string): RunnerSetSpecTemplateSpecContainersReadinessProbeTcpSocketPort {
    return new RunnerSetSpecTemplateSpecContainersReadinessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RunnerSetSpecTemplateSpecContainersStartupProbeHttpGetHttpHeaders
 */
export interface RunnerSetSpecTemplateSpecContainersStartupProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RunnerSetSpecTemplateSpecContainersStartupProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RunnerSetSpecTemplateSpecContainersStartupProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecContainersStartupProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecContainersStartupProbeHttpGetHttpHeaders(obj: RunnerSetSpecTemplateSpecContainersStartupProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerSetSpecTemplateSpecContainersStartupProbeHttpGetPort
 */
export class RunnerSetSpecTemplateSpecContainersStartupProbeHttpGetPort {
  public static fromNumber(value: number): RunnerSetSpecTemplateSpecContainersStartupProbeHttpGetPort {
    return new RunnerSetSpecTemplateSpecContainersStartupProbeHttpGetPort(value);
  }
  public static fromString(value: string): RunnerSetSpecTemplateSpecContainersStartupProbeHttpGetPort {
    return new RunnerSetSpecTemplateSpecContainersStartupProbeHttpGetPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerSetSpecTemplateSpecContainersStartupProbeTcpSocketPort
 */
export class RunnerSetSpecTemplateSpecContainersStartupProbeTcpSocketPort {
  public static fromNumber(value: number): RunnerSetSpecTemplateSpecContainersStartupProbeTcpSocketPort {
    return new RunnerSetSpecTemplateSpecContainersStartupProbeTcpSocketPort(value);
  }
  public static fromString(value: string): RunnerSetSpecTemplateSpecContainersStartupProbeTcpSocketPort {
    return new RunnerSetSpecTemplateSpecContainersStartupProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Selects a key of a ConfigMap.
 *
 * @schema RunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromConfigMapKeyRef
 */
export interface RunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromConfigMapKeyRef(obj: RunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema RunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromFieldRef
 */
export interface RunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromFieldRef(obj: RunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema RunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRef
 */
export interface RunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: RunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRef(obj: RunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema RunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromSecretKeyRef
 */
export interface RunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromSecretKeyRef(obj: RunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartExec
 */
export interface RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartExec(obj: RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGet
 */
export interface RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGet#httpHeaders
   */
  readonly httpHeaders?: RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGet#port
   */
  readonly port: RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGet(obj: RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
 *
 * @schema RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocket
 */
export interface RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocket#port
   */
  readonly port: RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocketPort;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocket(obj: RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopExec
 */
export interface RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopExec(obj: RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGet
 */
export interface RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGet#httpHeaders
   */
  readonly httpHeaders?: RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGet#port
   */
  readonly port: RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGet(obj: RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
 *
 * @schema RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocket
 */
export interface RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocket#port
   */
  readonly port: RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocketPort;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocket(obj: RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders
 */
export interface RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders(obj: RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetPort
 */
export class RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetPort {
  public static fromNumber(value: number): RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetPort {
    return new RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetPort(value);
  }
  public static fromString(value: string): RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetPort {
    return new RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocketPort
 */
export class RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocketPort {
  public static fromNumber(value: number): RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocketPort {
    return new RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocketPort(value);
  }
  public static fromString(value: string): RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocketPort {
    return new RunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders
 */
export interface RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders(obj: RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetPort
 */
export class RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetPort {
  public static fromNumber(value: number): RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetPort {
    return new RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetPort(value);
  }
  public static fromString(value: string): RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetPort {
    return new RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocketPort
 */
export class RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocketPort {
  public static fromNumber(value: number): RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocketPort {
    return new RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocketPort(value);
  }
  public static fromString(value: string): RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocketPort {
    return new RunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RunnerSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGetHttpHeaders
 */
export interface RunnerSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGetHttpHeaders(obj: RunnerSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGetPort
 */
export class RunnerSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGetPort {
  public static fromNumber(value: number): RunnerSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGetPort {
    return new RunnerSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGetPort(value);
  }
  public static fromString(value: string): RunnerSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGetPort {
    return new RunnerSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGetPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerSetSpecTemplateSpecEphemeralContainersStartupProbeTcpSocketPort
 */
export class RunnerSetSpecTemplateSpecEphemeralContainersStartupProbeTcpSocketPort {
  public static fromNumber(value: number): RunnerSetSpecTemplateSpecEphemeralContainersStartupProbeTcpSocketPort {
    return new RunnerSetSpecTemplateSpecEphemeralContainersStartupProbeTcpSocketPort(value);
  }
  public static fromString(value: string): RunnerSetSpecTemplateSpecEphemeralContainersStartupProbeTcpSocketPort {
    return new RunnerSetSpecTemplateSpecEphemeralContainersStartupProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Selects a key of a ConfigMap.
 *
 * @schema RunnerSetSpecTemplateSpecInitContainersEnvValueFromConfigMapKeyRef
 */
export interface RunnerSetSpecTemplateSpecInitContainersEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecInitContainersEnvValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecInitContainersEnvValueFromConfigMapKeyRef(obj: RunnerSetSpecTemplateSpecInitContainersEnvValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema RunnerSetSpecTemplateSpecInitContainersEnvValueFromFieldRef
 */
export interface RunnerSetSpecTemplateSpecInitContainersEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecInitContainersEnvValueFromFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecInitContainersEnvValueFromFieldRef(obj: RunnerSetSpecTemplateSpecInitContainersEnvValueFromFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema RunnerSetSpecTemplateSpecInitContainersEnvValueFromResourceFieldRef
 */
export interface RunnerSetSpecTemplateSpecInitContainersEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: RunnerSetSpecTemplateSpecInitContainersEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecInitContainersEnvValueFromResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecInitContainersEnvValueFromResourceFieldRef(obj: RunnerSetSpecTemplateSpecInitContainersEnvValueFromResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema RunnerSetSpecTemplateSpecInitContainersEnvValueFromSecretKeyRef
 */
export interface RunnerSetSpecTemplateSpecInitContainersEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecInitContainersEnvValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecInitContainersEnvValueFromSecretKeyRef(obj: RunnerSetSpecTemplateSpecInitContainersEnvValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema RunnerSetSpecTemplateSpecInitContainersLifecyclePostStartExec
 */
export interface RunnerSetSpecTemplateSpecInitContainersLifecyclePostStartExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersLifecyclePostStartExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecInitContainersLifecyclePostStartExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecInitContainersLifecyclePostStartExec(obj: RunnerSetSpecTemplateSpecInitContainersLifecyclePostStartExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema RunnerSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGet
 */
export interface RunnerSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGet#httpHeaders
   */
  readonly httpHeaders?: RunnerSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGet#port
   */
  readonly port: RunnerSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RunnerSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGet(obj: RunnerSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_RunnerSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
 *
 * @schema RunnerSetSpecTemplateSpecInitContainersLifecyclePostStartTcpSocket
 */
export interface RunnerSetSpecTemplateSpecInitContainersLifecyclePostStartTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersLifecyclePostStartTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersLifecyclePostStartTcpSocket#port
   */
  readonly port: RunnerSetSpecTemplateSpecInitContainersLifecyclePostStartTcpSocketPort;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecInitContainersLifecyclePostStartTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecInitContainersLifecyclePostStartTcpSocket(obj: RunnerSetSpecTemplateSpecInitContainersLifecyclePostStartTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema RunnerSetSpecTemplateSpecInitContainersLifecyclePreStopExec
 */
export interface RunnerSetSpecTemplateSpecInitContainersLifecyclePreStopExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersLifecyclePreStopExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecInitContainersLifecyclePreStopExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecInitContainersLifecyclePreStopExec(obj: RunnerSetSpecTemplateSpecInitContainersLifecyclePreStopExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema RunnerSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGet
 */
export interface RunnerSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGet#httpHeaders
   */
  readonly httpHeaders?: RunnerSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGet#port
   */
  readonly port: RunnerSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RunnerSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGet(obj: RunnerSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_RunnerSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
 *
 * @schema RunnerSetSpecTemplateSpecInitContainersLifecyclePreStopTcpSocket
 */
export interface RunnerSetSpecTemplateSpecInitContainersLifecyclePreStopTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersLifecyclePreStopTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersLifecyclePreStopTcpSocket#port
   */
  readonly port: RunnerSetSpecTemplateSpecInitContainersLifecyclePreStopTcpSocketPort;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecInitContainersLifecyclePreStopTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecInitContainersLifecyclePreStopTcpSocket(obj: RunnerSetSpecTemplateSpecInitContainersLifecyclePreStopTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RunnerSetSpecTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders
 */
export interface RunnerSetSpecTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders(obj: RunnerSetSpecTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerSetSpecTemplateSpecInitContainersLivenessProbeHttpGetPort
 */
export class RunnerSetSpecTemplateSpecInitContainersLivenessProbeHttpGetPort {
  public static fromNumber(value: number): RunnerSetSpecTemplateSpecInitContainersLivenessProbeHttpGetPort {
    return new RunnerSetSpecTemplateSpecInitContainersLivenessProbeHttpGetPort(value);
  }
  public static fromString(value: string): RunnerSetSpecTemplateSpecInitContainersLivenessProbeHttpGetPort {
    return new RunnerSetSpecTemplateSpecInitContainersLivenessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerSetSpecTemplateSpecInitContainersLivenessProbeTcpSocketPort
 */
export class RunnerSetSpecTemplateSpecInitContainersLivenessProbeTcpSocketPort {
  public static fromNumber(value: number): RunnerSetSpecTemplateSpecInitContainersLivenessProbeTcpSocketPort {
    return new RunnerSetSpecTemplateSpecInitContainersLivenessProbeTcpSocketPort(value);
  }
  public static fromString(value: string): RunnerSetSpecTemplateSpecInitContainersLivenessProbeTcpSocketPort {
    return new RunnerSetSpecTemplateSpecInitContainersLivenessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RunnerSetSpecTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders
 */
export interface RunnerSetSpecTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders(obj: RunnerSetSpecTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerSetSpecTemplateSpecInitContainersReadinessProbeHttpGetPort
 */
export class RunnerSetSpecTemplateSpecInitContainersReadinessProbeHttpGetPort {
  public static fromNumber(value: number): RunnerSetSpecTemplateSpecInitContainersReadinessProbeHttpGetPort {
    return new RunnerSetSpecTemplateSpecInitContainersReadinessProbeHttpGetPort(value);
  }
  public static fromString(value: string): RunnerSetSpecTemplateSpecInitContainersReadinessProbeHttpGetPort {
    return new RunnerSetSpecTemplateSpecInitContainersReadinessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerSetSpecTemplateSpecInitContainersReadinessProbeTcpSocketPort
 */
export class RunnerSetSpecTemplateSpecInitContainersReadinessProbeTcpSocketPort {
  public static fromNumber(value: number): RunnerSetSpecTemplateSpecInitContainersReadinessProbeTcpSocketPort {
    return new RunnerSetSpecTemplateSpecInitContainersReadinessProbeTcpSocketPort(value);
  }
  public static fromString(value: string): RunnerSetSpecTemplateSpecInitContainersReadinessProbeTcpSocketPort {
    return new RunnerSetSpecTemplateSpecInitContainersReadinessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RunnerSetSpecTemplateSpecInitContainersStartupProbeHttpGetHttpHeaders
 */
export interface RunnerSetSpecTemplateSpecInitContainersStartupProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersStartupProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersStartupProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecInitContainersStartupProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecInitContainersStartupProbeHttpGetHttpHeaders(obj: RunnerSetSpecTemplateSpecInitContainersStartupProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerSetSpecTemplateSpecInitContainersStartupProbeHttpGetPort
 */
export class RunnerSetSpecTemplateSpecInitContainersStartupProbeHttpGetPort {
  public static fromNumber(value: number): RunnerSetSpecTemplateSpecInitContainersStartupProbeHttpGetPort {
    return new RunnerSetSpecTemplateSpecInitContainersStartupProbeHttpGetPort(value);
  }
  public static fromString(value: string): RunnerSetSpecTemplateSpecInitContainersStartupProbeHttpGetPort {
    return new RunnerSetSpecTemplateSpecInitContainersStartupProbeHttpGetPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerSetSpecTemplateSpecInitContainersStartupProbeTcpSocketPort
 */
export class RunnerSetSpecTemplateSpecInitContainersStartupProbeTcpSocketPort {
  public static fromNumber(value: number): RunnerSetSpecTemplateSpecInitContainersStartupProbeTcpSocketPort {
    return new RunnerSetSpecTemplateSpecInitContainersStartupProbeTcpSocketPort(value);
  }
  public static fromString(value: string): RunnerSetSpecTemplateSpecInitContainersStartupProbeTcpSocketPort {
    return new RunnerSetSpecTemplateSpecInitContainersStartupProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
 *
 * @schema RunnerSetSpecTemplateSpecVolumesDownwardApiItemsFieldRef
 */
export interface RunnerSetSpecTemplateSpecVolumesDownwardApiItemsFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema RunnerSetSpecTemplateSpecVolumesDownwardApiItemsFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema RunnerSetSpecTemplateSpecVolumesDownwardApiItemsFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecVolumesDownwardApiItemsFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecVolumesDownwardApiItemsFieldRef(obj: RunnerSetSpecTemplateSpecVolumesDownwardApiItemsFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
 *
 * @schema RunnerSetSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRef
 */
export interface RunnerSetSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema RunnerSetSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema RunnerSetSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRef#divisor
   */
  readonly divisor?: RunnerSetSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema RunnerSetSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRef(obj: RunnerSetSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * May contain labels and annotations that will be copied into the PVC when creating it. No other fields are allowed and will be rejected during validation.
 *
 * @schema RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateMetadata
 */
export interface RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateMetadata {
  /**
   * @schema RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * @schema RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateMetadata#finalizers
   */
  readonly finalizers?: string[];

  /**
   * @schema RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * @schema RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateMetadata#name
   */
  readonly name?: string;

  /**
   * @schema RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateMetadata#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateMetadata(obj: RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'finalizers': obj.finalizers?.map(y => y),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The specification for the PersistentVolumeClaim. The entire content is copied unchanged into the PVC that gets created from this template. The same fields as in a PersistentVolumeClaim are also valid here.
 *
 * @schema RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec
 */
export interface RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec {
  /**
   * AccessModes contains the desired access modes the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec#accessModes
   */
  readonly accessModes?: string[];

  /**
   * This field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. If the AnyVolumeDataSource feature gate is enabled, this field will always have the same contents as the DataSourceRef field.
   *
   * @schema RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec#dataSource
   */
  readonly dataSource?: RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource;

  /**
   * Specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any local object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the DataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, both fields (DataSource and DataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. There are two important differences between DataSource and DataSourceRef: * While DataSource only allows two specific types of objects, DataSourceRef   allows any non-core object, as well as PersistentVolumeClaim objects. * While DataSource ignores disallowed values (dropping them), DataSourceRef   preserves all values, and generates an error if a disallowed value is   specified. (Alpha) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
   *
   * @schema RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec#dataSourceRef
   */
  readonly dataSourceRef?: RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef;

  /**
   * Resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
   *
   * @schema RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec#resources
   */
  readonly resources?: RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResources;

  /**
   * A label query over volumes to consider for binding.
   *
   * @schema RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec#selector
   */
  readonly selector?: RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelector;

  /**
   * Name of the StorageClass required by the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   *
   * @schema RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim spec.
   *
   * @schema RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec#volumeMode
   */
  readonly volumeMode?: string;

  /**
   * VolumeName is the binding reference to the PersistentVolume backing this claim.
   *
   * @schema RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec#volumeName
   */
  readonly volumeName?: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec(obj: RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessModes': obj.accessModes?.map(y => y),
    'dataSource': toJson_RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource(obj.dataSource),
    'dataSourceRef': toJson_RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef(obj.dataSourceRef),
    'resources': toJson_RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResources(obj.resources),
    'selector': toJson_RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelector(obj.selector),
    'storageClassName': obj.storageClassName,
    'volumeMode': obj.volumeMode,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * information about the configMap data to project
 *
 * @schema RunnerSetSpecTemplateSpecVolumesProjectedSourcesConfigMap
 */
export interface RunnerSetSpecTemplateSpecVolumesProjectedSourcesConfigMap {
  /**
   * If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema RunnerSetSpecTemplateSpecVolumesProjectedSourcesConfigMap#items
   */
  readonly items?: RunnerSetSpecTemplateSpecVolumesProjectedSourcesConfigMapItems[];

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerSetSpecTemplateSpecVolumesProjectedSourcesConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its keys must be defined
   *
   * @schema RunnerSetSpecTemplateSpecVolumesProjectedSourcesConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecVolumesProjectedSourcesConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecVolumesProjectedSourcesConfigMap(obj: RunnerSetSpecTemplateSpecVolumesProjectedSourcesConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_RunnerSetSpecTemplateSpecVolumesProjectedSourcesConfigMapItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * information about the downwardAPI data to project
 *
 * @schema RunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApi
 */
export interface RunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApi {
  /**
   * Items is a list of DownwardAPIVolume file
   *
   * @schema RunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApi#items
   */
  readonly items?: RunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItems[];

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApi' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApi(obj: RunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_RunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItems(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * information about the secret data to project
 *
 * @schema RunnerSetSpecTemplateSpecVolumesProjectedSourcesSecret
 */
export interface RunnerSetSpecTemplateSpecVolumesProjectedSourcesSecret {
  /**
   * If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema RunnerSetSpecTemplateSpecVolumesProjectedSourcesSecret#items
   */
  readonly items?: RunnerSetSpecTemplateSpecVolumesProjectedSourcesSecretItems[];

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema RunnerSetSpecTemplateSpecVolumesProjectedSourcesSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema RunnerSetSpecTemplateSpecVolumesProjectedSourcesSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecVolumesProjectedSourcesSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecVolumesProjectedSourcesSecret(obj: RunnerSetSpecTemplateSpecVolumesProjectedSourcesSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_RunnerSetSpecTemplateSpecVolumesProjectedSourcesSecretItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * information about the serviceAccountToken data to project
 *
 * @schema RunnerSetSpecTemplateSpecVolumesProjectedSourcesServiceAccountToken
 */
export interface RunnerSetSpecTemplateSpecVolumesProjectedSourcesServiceAccountToken {
  /**
   * Audience is the intended audience of the token. A recipient of a token must identify itself with an identifier specified in the audience of the token, and otherwise should reject the token. The audience defaults to the identifier of the apiserver.
   *
   * @schema RunnerSetSpecTemplateSpecVolumesProjectedSourcesServiceAccountToken#audience
   */
  readonly audience?: string;

  /**
   * ExpirationSeconds is the requested duration of validity of the service account token. As the token approaches expiration, the kubelet volume plugin will proactively rotate the service account token. The kubelet will start trying to rotate the token if the token is older than 80 percent of its time to live or if the token is older than 24 hours.Defaults to 1 hour and must be at least 10 minutes.
   *
   * @default 1 hour and must be at least 10 minutes.
   * @schema RunnerSetSpecTemplateSpecVolumesProjectedSourcesServiceAccountToken#expirationSeconds
   */
  readonly expirationSeconds?: number;

  /**
   * Path is the path relative to the mount point of the file to project the token into.
   *
   * @schema RunnerSetSpecTemplateSpecVolumesProjectedSourcesServiceAccountToken#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecVolumesProjectedSourcesServiceAccountToken' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecVolumesProjectedSourcesServiceAccountToken(obj: RunnerSetSpecTemplateSpecVolumesProjectedSourcesServiceAccountToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audience': obj.audience,
    'expirationSeconds': obj.expirationSeconds,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema RunnerSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface RunnerSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(obj: RunnerSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema RunnerSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface RunnerSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(obj: RunnerSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema RunnerSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface RunnerSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(obj: RunnerSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema RunnerSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface RunnerSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(obj: RunnerSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 *
 * @schema RunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface RunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: RunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: RunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_RunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces. This field is beta-level and is only honored when PodAffinityNamespaceSelector feature is enabled.
 *
 * @schema RunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface RunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: RunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: RunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_RunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema RunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface RunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: RunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema RunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface RunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: RunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 *
 * @schema RunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface RunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: RunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: RunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_RunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces. This field is beta-level and is only honored when PodAffinityNamespaceSelector feature is enabled.
 *
 * @schema RunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface RunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: RunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: RunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_RunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema RunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface RunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: RunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema RunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface RunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: RunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema RunnerSetSpecTemplateSpecContainersEnvValueFromResourceFieldRefDivisor
 */
export class RunnerSetSpecTemplateSpecContainersEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(value: number): RunnerSetSpecTemplateSpecContainersEnvValueFromResourceFieldRefDivisor {
    return new RunnerSetSpecTemplateSpecContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): RunnerSetSpecTemplateSpecContainersEnvValueFromResourceFieldRefDivisor {
    return new RunnerSetSpecTemplateSpecContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RunnerSetSpecTemplateSpecContainersLifecyclePostStartHttpGetHttpHeaders
 */
export interface RunnerSetSpecTemplateSpecContainersLifecyclePostStartHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RunnerSetSpecTemplateSpecContainersLifecyclePostStartHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RunnerSetSpecTemplateSpecContainersLifecyclePostStartHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecContainersLifecyclePostStartHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecContainersLifecyclePostStartHttpGetHttpHeaders(obj: RunnerSetSpecTemplateSpecContainersLifecyclePostStartHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerSetSpecTemplateSpecContainersLifecyclePostStartHttpGetPort
 */
export class RunnerSetSpecTemplateSpecContainersLifecyclePostStartHttpGetPort {
  public static fromNumber(value: number): RunnerSetSpecTemplateSpecContainersLifecyclePostStartHttpGetPort {
    return new RunnerSetSpecTemplateSpecContainersLifecyclePostStartHttpGetPort(value);
  }
  public static fromString(value: string): RunnerSetSpecTemplateSpecContainersLifecyclePostStartHttpGetPort {
    return new RunnerSetSpecTemplateSpecContainersLifecyclePostStartHttpGetPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerSetSpecTemplateSpecContainersLifecyclePostStartTcpSocketPort
 */
export class RunnerSetSpecTemplateSpecContainersLifecyclePostStartTcpSocketPort {
  public static fromNumber(value: number): RunnerSetSpecTemplateSpecContainersLifecyclePostStartTcpSocketPort {
    return new RunnerSetSpecTemplateSpecContainersLifecyclePostStartTcpSocketPort(value);
  }
  public static fromString(value: string): RunnerSetSpecTemplateSpecContainersLifecyclePostStartTcpSocketPort {
    return new RunnerSetSpecTemplateSpecContainersLifecyclePostStartTcpSocketPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RunnerSetSpecTemplateSpecContainersLifecyclePreStopHttpGetHttpHeaders
 */
export interface RunnerSetSpecTemplateSpecContainersLifecyclePreStopHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RunnerSetSpecTemplateSpecContainersLifecyclePreStopHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RunnerSetSpecTemplateSpecContainersLifecyclePreStopHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecContainersLifecyclePreStopHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecContainersLifecyclePreStopHttpGetHttpHeaders(obj: RunnerSetSpecTemplateSpecContainersLifecyclePreStopHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerSetSpecTemplateSpecContainersLifecyclePreStopHttpGetPort
 */
export class RunnerSetSpecTemplateSpecContainersLifecyclePreStopHttpGetPort {
  public static fromNumber(value: number): RunnerSetSpecTemplateSpecContainersLifecyclePreStopHttpGetPort {
    return new RunnerSetSpecTemplateSpecContainersLifecyclePreStopHttpGetPort(value);
  }
  public static fromString(value: string): RunnerSetSpecTemplateSpecContainersLifecyclePreStopHttpGetPort {
    return new RunnerSetSpecTemplateSpecContainersLifecyclePreStopHttpGetPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerSetSpecTemplateSpecContainersLifecyclePreStopTcpSocketPort
 */
export class RunnerSetSpecTemplateSpecContainersLifecyclePreStopTcpSocketPort {
  public static fromNumber(value: number): RunnerSetSpecTemplateSpecContainersLifecyclePreStopTcpSocketPort {
    return new RunnerSetSpecTemplateSpecContainersLifecyclePreStopTcpSocketPort(value);
  }
  public static fromString(value: string): RunnerSetSpecTemplateSpecContainersLifecyclePreStopTcpSocketPort {
    return new RunnerSetSpecTemplateSpecContainersLifecyclePreStopTcpSocketPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema RunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRefDivisor
 */
export class RunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(value: number): RunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRefDivisor {
    return new RunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): RunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRefDivisor {
    return new RunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders
 */
export interface RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders(obj: RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetPort
 */
export class RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetPort {
  public static fromNumber(value: number): RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetPort {
    return new RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetPort(value);
  }
  public static fromString(value: string): RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetPort {
    return new RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocketPort
 */
export class RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocketPort {
  public static fromNumber(value: number): RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocketPort {
    return new RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocketPort(value);
  }
  public static fromString(value: string): RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocketPort {
    return new RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocketPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders
 */
export interface RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders(obj: RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetPort
 */
export class RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetPort {
  public static fromNumber(value: number): RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetPort {
    return new RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetPort(value);
  }
  public static fromString(value: string): RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetPort {
    return new RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocketPort
 */
export class RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocketPort {
  public static fromNumber(value: number): RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocketPort {
    return new RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocketPort(value);
  }
  public static fromString(value: string): RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocketPort {
    return new RunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocketPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema RunnerSetSpecTemplateSpecInitContainersEnvValueFromResourceFieldRefDivisor
 */
export class RunnerSetSpecTemplateSpecInitContainersEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(value: number): RunnerSetSpecTemplateSpecInitContainersEnvValueFromResourceFieldRefDivisor {
    return new RunnerSetSpecTemplateSpecInitContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): RunnerSetSpecTemplateSpecInitContainersEnvValueFromResourceFieldRefDivisor {
    return new RunnerSetSpecTemplateSpecInitContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RunnerSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders
 */
export interface RunnerSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders(obj: RunnerSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGetPort
 */
export class RunnerSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGetPort {
  public static fromNumber(value: number): RunnerSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGetPort {
    return new RunnerSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGetPort(value);
  }
  public static fromString(value: string): RunnerSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGetPort {
    return new RunnerSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGetPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerSetSpecTemplateSpecInitContainersLifecyclePostStartTcpSocketPort
 */
export class RunnerSetSpecTemplateSpecInitContainersLifecyclePostStartTcpSocketPort {
  public static fromNumber(value: number): RunnerSetSpecTemplateSpecInitContainersLifecyclePostStartTcpSocketPort {
    return new RunnerSetSpecTemplateSpecInitContainersLifecyclePostStartTcpSocketPort(value);
  }
  public static fromString(value: string): RunnerSetSpecTemplateSpecInitContainersLifecyclePostStartTcpSocketPort {
    return new RunnerSetSpecTemplateSpecInitContainersLifecyclePostStartTcpSocketPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RunnerSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders
 */
export interface RunnerSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RunnerSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders(obj: RunnerSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGetPort
 */
export class RunnerSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGetPort {
  public static fromNumber(value: number): RunnerSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGetPort {
    return new RunnerSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGetPort(value);
  }
  public static fromString(value: string): RunnerSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGetPort {
    return new RunnerSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGetPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema RunnerSetSpecTemplateSpecInitContainersLifecyclePreStopTcpSocketPort
 */
export class RunnerSetSpecTemplateSpecInitContainersLifecyclePreStopTcpSocketPort {
  public static fromNumber(value: number): RunnerSetSpecTemplateSpecInitContainersLifecyclePreStopTcpSocketPort {
    return new RunnerSetSpecTemplateSpecInitContainersLifecyclePreStopTcpSocketPort(value);
  }
  public static fromString(value: string): RunnerSetSpecTemplateSpecInitContainersLifecyclePreStopTcpSocketPort {
    return new RunnerSetSpecTemplateSpecInitContainersLifecyclePreStopTcpSocketPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema RunnerSetSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRefDivisor
 */
export class RunnerSetSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRefDivisor {
  public static fromNumber(value: number): RunnerSetSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRefDivisor {
    return new RunnerSetSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): RunnerSetSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRefDivisor {
    return new RunnerSetSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * This field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. If the AnyVolumeDataSource feature gate is enabled, this field will always have the same contents as the DataSourceRef field.
 *
 * @schema RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource
 */
export interface RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource {
  /**
   * APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
   *
   * @schema RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource(obj: RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any local object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the DataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, both fields (DataSource and DataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. There are two important differences between DataSource and DataSourceRef: * While DataSource only allows two specific types of objects, DataSourceRef   allows any non-core object, as well as PersistentVolumeClaim objects. * While DataSource ignores disallowed values (dropping them), DataSourceRef   preserves all values, and generates an error if a disallowed value is   specified. (Alpha) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
 *
 * @schema RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef
 */
export interface RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef {
  /**
   * APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
   *
   * @schema RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef(obj: RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
 *
 * @schema RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResources
 */
export interface RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResources {
  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResources#limits
   */
  readonly limits?: { [key: string]: RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResources#requests
   */
  readonly requests?: { [key: string]: RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests };

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResources(obj: RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over volumes to consider for binding.
 *
 * @schema RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelector
 */
export interface RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelector#matchExpressions
   */
  readonly matchExpressions?: RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelector(obj: RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema RunnerSetSpecTemplateSpecVolumesProjectedSourcesConfigMapItems
 */
export interface RunnerSetSpecTemplateSpecVolumesProjectedSourcesConfigMapItems {
  /**
   * The key to project.
   *
   * @schema RunnerSetSpecTemplateSpecVolumesProjectedSourcesConfigMapItems#key
   */
  readonly key: string;

  /**
   * Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema RunnerSetSpecTemplateSpecVolumesProjectedSourcesConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema RunnerSetSpecTemplateSpecVolumesProjectedSourcesConfigMapItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecVolumesProjectedSourcesConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecVolumesProjectedSourcesConfigMapItems(obj: RunnerSetSpecTemplateSpecVolumesProjectedSourcesConfigMapItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DownwardAPIVolumeFile represents information to create the file containing the pod field
 *
 * @schema RunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItems
 */
export interface RunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItems {
  /**
   * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
   *
   * @schema RunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItems#fieldRef
   */
  readonly fieldRef?: RunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsFieldRef;

  /**
   * Optional: mode bits used to set permissions on this file, must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema RunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItems#mode
   */
  readonly mode?: number;

  /**
   * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
   *
   * @schema RunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItems#path
   */
  readonly path: string;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
   *
   * @schema RunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItems#resourceFieldRef
   */
  readonly resourceFieldRef?: RunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItems(obj: RunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fieldRef': toJson_RunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsFieldRef(obj.fieldRef),
    'mode': obj.mode,
    'path': obj.path,
    'resourceFieldRef': toJson_RunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef(obj.resourceFieldRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema RunnerSetSpecTemplateSpecVolumesProjectedSourcesSecretItems
 */
export interface RunnerSetSpecTemplateSpecVolumesProjectedSourcesSecretItems {
  /**
   * The key to project.
   *
   * @schema RunnerSetSpecTemplateSpecVolumesProjectedSourcesSecretItems#key
   */
  readonly key: string;

  /**
   * Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema RunnerSetSpecTemplateSpecVolumesProjectedSourcesSecretItems#mode
   */
  readonly mode?: number;

  /**
   * The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema RunnerSetSpecTemplateSpecVolumesProjectedSourcesSecretItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecVolumesProjectedSourcesSecretItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecVolumesProjectedSourcesSecretItems(obj: RunnerSetSpecTemplateSpecVolumesProjectedSourcesSecretItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema RunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface RunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: RunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema RunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface RunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: RunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema RunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface RunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: RunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema RunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface RunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema RunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: RunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits
 */
export class RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
  public static fromNumber(value: number): RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits(value);
  }
  public static fromString(value: string): RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * @schema RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests
 */
export class RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
  public static fromNumber(value: number): RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests(value);
  }
  public static fromString(value: string): RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions
 */
export interface RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(obj: RunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
 *
 * @schema RunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsFieldRef
 */
export interface RunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema RunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema RunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsFieldRef(obj: RunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
 *
 * @schema RunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef
 */
export interface RunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema RunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema RunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#divisor
   */
  readonly divisor?: RunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema RunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'RunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef(obj: RunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema RunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor
 */
export class RunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
  public static fromNumber(value: number): RunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
    return new RunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): RunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
    return new RunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: any) {
  }
}

