// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * IngressRoute is an Ingress CRD specification.
 *
 * @schema IngressRoute
 */
export class IngressRoute extends ApiObject {
  /**
   * Returns the apiVersion and kind for "IngressRoute"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'traefik.containo.us/v1alpha1',
    kind: 'IngressRoute',
  }

  /**
   * Renders a Kubernetes manifest for "IngressRoute".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: IngressRouteProps): any {
    return {
      ...IngressRoute.GVK,
      ...toJson_IngressRouteProps(props),
    };
  }

  /**
   * Defines a "IngressRoute" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: IngressRouteProps) {
    super(scope, id, {
      ...IngressRoute.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...IngressRoute.GVK,
      ...toJson_IngressRouteProps(resolved),
    };
  }
}

/**
 * IngressRoute is an Ingress CRD specification.
 *
 * @schema IngressRoute
 */
export interface IngressRouteProps {
  /**
   * @schema IngressRoute#metadata
   */
  readonly metadata: ApiObjectMetadata;

  /**
   * IngressRouteSpec is a specification for a IngressRouteSpec resource.
   *
   * @schema IngressRoute#spec
   */
  readonly spec: IngressRouteSpec;

}

/**
 * Converts an object of type 'IngressRouteProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IngressRouteProps(obj: IngressRouteProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_IngressRouteSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IngressRouteSpec is a specification for a IngressRouteSpec resource.
 *
 * @schema IngressRouteSpec
 */
export interface IngressRouteSpec {
  /**
   * @schema IngressRouteSpec#entryPoints
   */
  readonly entryPoints?: string[];

  /**
   * @schema IngressRouteSpec#routes
   */
  readonly routes: IngressRouteSpecRoutes[];

  /**
   * TLS contains the TLS certificates configuration of the routes. To enable Let's Encrypt, use an empty TLS struct, e.g. in YAML:
   * tls: {} # inline format
   * tls: 	   secretName: # block format
   *
   * @schema IngressRouteSpec#tls
   */
  readonly tls?: IngressRouteSpecTls;

}

/**
 * Converts an object of type 'IngressRouteSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IngressRouteSpec(obj: IngressRouteSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'entryPoints': obj.entryPoints?.map(y => y),
    'routes': obj.routes?.map(y => toJson_IngressRouteSpecRoutes(y)),
    'tls': toJson_IngressRouteSpecTls(obj.tls),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Route contains the set of routes.
 *
 * @schema IngressRouteSpecRoutes
 */
export interface IngressRouteSpecRoutes {
  /**
   * @schema IngressRouteSpecRoutes#kind
   */
  readonly kind: IngressRouteSpecRoutesKind;

  /**
   * @schema IngressRouteSpecRoutes#match
   */
  readonly match: string;

  /**
   * @schema IngressRouteSpecRoutes#middlewares
   */
  readonly middlewares?: IngressRouteSpecRoutesMiddlewares[];

  /**
   * @schema IngressRouteSpecRoutes#priority
   */
  readonly priority?: number;

  /**
   * @schema IngressRouteSpecRoutes#services
   */
  readonly services?: IngressRouteSpecRoutesServices[];

}

/**
 * Converts an object of type 'IngressRouteSpecRoutes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IngressRouteSpecRoutes(obj: IngressRouteSpecRoutes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kind': obj.kind,
    'match': obj.match,
    'middlewares': obj.middlewares?.map(y => toJson_IngressRouteSpecRoutesMiddlewares(y)),
    'priority': obj.priority,
    'services': obj.services?.map(y => toJson_IngressRouteSpecRoutesServices(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLS contains the TLS certificates configuration of the routes. To enable Let's Encrypt, use an empty TLS struct, e.g. in YAML:
 * tls: {} # inline format
 * tls: 	   secretName: # block format
 *
 * @schema IngressRouteSpecTls
 */
export interface IngressRouteSpecTls {
  /**
   * @schema IngressRouteSpecTls#certResolver
   */
  readonly certResolver?: string;

  /**
   * @schema IngressRouteSpecTls#domains
   */
  readonly domains?: IngressRouteSpecTlsDomains[];

  /**
   * Options is a reference to a TLSOption, that specifies the parameters of the TLS connection.
   *
   * @schema IngressRouteSpecTls#options
   */
  readonly options?: IngressRouteSpecTlsOptions;

  /**
   * SecretName is the name of the referenced Kubernetes Secret to specify the certificate details.
   *
   * @schema IngressRouteSpecTls#secretName
   */
  readonly secretName?: string;

  /**
   * Store is a reference to a TLSStore, that specifies the parameters of the TLS store.
   *
   * @schema IngressRouteSpecTls#store
   */
  readonly store?: IngressRouteSpecTlsStore;

}

/**
 * Converts an object of type 'IngressRouteSpecTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IngressRouteSpecTls(obj: IngressRouteSpecTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certResolver': obj.certResolver,
    'domains': obj.domains?.map(y => toJson_IngressRouteSpecTlsDomains(y)),
    'options': toJson_IngressRouteSpecTlsOptions(obj.options),
    'secretName': obj.secretName,
    'store': toJson_IngressRouteSpecTlsStore(obj.store),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema IngressRouteSpecRoutesKind
 */
export enum IngressRouteSpecRoutesKind {
  /** Rule */
  RULE = 'Rule',
}

/**
 * MiddlewareRef is a ref to the Middleware resources.
 *
 * @schema IngressRouteSpecRoutesMiddlewares
 */
export interface IngressRouteSpecRoutesMiddlewares {
  /**
   * @schema IngressRouteSpecRoutesMiddlewares#name
   */
  readonly name: string;

  /**
   * @schema IngressRouteSpecRoutesMiddlewares#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'IngressRouteSpecRoutesMiddlewares' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IngressRouteSpecRoutesMiddlewares(obj: IngressRouteSpecRoutesMiddlewares | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Service defines an upstream to proxy traffic.
 *
 * @schema IngressRouteSpecRoutesServices
 */
export interface IngressRouteSpecRoutesServices {
  /**
   * @schema IngressRouteSpecRoutesServices#kind
   */
  readonly kind?: IngressRouteSpecRoutesServicesKind;

  /**
   * Name is a reference to a Kubernetes Service object (for a load-balancer of servers), or to a TraefikService object (service load-balancer, mirroring, etc). The differentiation between the two is specified in the Kind field.
   *
   * @schema IngressRouteSpecRoutesServices#name
   */
  readonly name: string;

  /**
   * @schema IngressRouteSpecRoutesServices#namespace
   */
  readonly namespace?: string;

  /**
   * @schema IngressRouteSpecRoutesServices#passHostHeader
   */
  readonly passHostHeader?: boolean;

  /**
   * @schema IngressRouteSpecRoutesServices#port
   */
  readonly port?: IngressRouteSpecRoutesServicesPort;

  /**
   * ResponseForwarding holds configuration for the forward of the response.
   *
   * @schema IngressRouteSpecRoutesServices#responseForwarding
   */
  readonly responseForwarding?: IngressRouteSpecRoutesServicesResponseForwarding;

  /**
   * @schema IngressRouteSpecRoutesServices#scheme
   */
  readonly scheme?: string;

  /**
   * @schema IngressRouteSpecRoutesServices#serversTransport
   */
  readonly serversTransport?: string;

  /**
   * Sticky holds the sticky configuration.
   *
   * @schema IngressRouteSpecRoutesServices#sticky
   */
  readonly sticky?: IngressRouteSpecRoutesServicesSticky;

  /**
   * @schema IngressRouteSpecRoutesServices#strategy
   */
  readonly strategy?: string;

  /**
   * Weight should only be specified when Name references a TraefikService object (and to be precise, one that embeds a Weighted Round Robin).
   *
   * @schema IngressRouteSpecRoutesServices#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'IngressRouteSpecRoutesServices' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IngressRouteSpecRoutesServices(obj: IngressRouteSpecRoutesServices | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
    'passHostHeader': obj.passHostHeader,
    'port': obj.port?.value,
    'responseForwarding': toJson_IngressRouteSpecRoutesServicesResponseForwarding(obj.responseForwarding),
    'scheme': obj.scheme,
    'serversTransport': obj.serversTransport,
    'sticky': toJson_IngressRouteSpecRoutesServicesSticky(obj.sticky),
    'strategy': obj.strategy,
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Domain holds a domain name with SANs.
 *
 * @schema IngressRouteSpecTlsDomains
 */
export interface IngressRouteSpecTlsDomains {
  /**
   * @schema IngressRouteSpecTlsDomains#main
   */
  readonly main?: string;

  /**
   * @schema IngressRouteSpecTlsDomains#sans
   */
  readonly sans?: string[];

}

/**
 * Converts an object of type 'IngressRouteSpecTlsDomains' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IngressRouteSpecTlsDomains(obj: IngressRouteSpecTlsDomains | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'main': obj.main,
    'sans': obj.sans?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Options is a reference to a TLSOption, that specifies the parameters of the TLS connection.
 *
 * @schema IngressRouteSpecTlsOptions
 */
export interface IngressRouteSpecTlsOptions {
  /**
   * @schema IngressRouteSpecTlsOptions#name
   */
  readonly name: string;

  /**
   * @schema IngressRouteSpecTlsOptions#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'IngressRouteSpecTlsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IngressRouteSpecTlsOptions(obj: IngressRouteSpecTlsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Store is a reference to a TLSStore, that specifies the parameters of the TLS store.
 *
 * @schema IngressRouteSpecTlsStore
 */
export interface IngressRouteSpecTlsStore {
  /**
   * @schema IngressRouteSpecTlsStore#name
   */
  readonly name: string;

  /**
   * @schema IngressRouteSpecTlsStore#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'IngressRouteSpecTlsStore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IngressRouteSpecTlsStore(obj: IngressRouteSpecTlsStore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema IngressRouteSpecRoutesServicesKind
 */
export enum IngressRouteSpecRoutesServicesKind {
  /** Service */
  SERVICE = 'Service',
  /** TraefikService */
  TRAEFIK_SERVICE = 'TraefikService',
}

/**
 * @schema IngressRouteSpecRoutesServicesPort
 */
export class IngressRouteSpecRoutesServicesPort {
  public static fromNumber(value: number): IngressRouteSpecRoutesServicesPort {
    return new IngressRouteSpecRoutesServicesPort(value);
  }
  public static fromString(value: string): IngressRouteSpecRoutesServicesPort {
    return new IngressRouteSpecRoutesServicesPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * ResponseForwarding holds configuration for the forward of the response.
 *
 * @schema IngressRouteSpecRoutesServicesResponseForwarding
 */
export interface IngressRouteSpecRoutesServicesResponseForwarding {
  /**
   * @schema IngressRouteSpecRoutesServicesResponseForwarding#flushInterval
   */
  readonly flushInterval?: string;

}

/**
 * Converts an object of type 'IngressRouteSpecRoutesServicesResponseForwarding' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IngressRouteSpecRoutesServicesResponseForwarding(obj: IngressRouteSpecRoutesServicesResponseForwarding | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'flushInterval': obj.flushInterval,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Sticky holds the sticky configuration.
 *
 * @schema IngressRouteSpecRoutesServicesSticky
 */
export interface IngressRouteSpecRoutesServicesSticky {
  /**
   * Cookie holds the sticky configuration based on cookie.
   *
   * @schema IngressRouteSpecRoutesServicesSticky#cookie
   */
  readonly cookie?: IngressRouteSpecRoutesServicesStickyCookie;

}

/**
 * Converts an object of type 'IngressRouteSpecRoutesServicesSticky' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IngressRouteSpecRoutesServicesSticky(obj: IngressRouteSpecRoutesServicesSticky | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cookie': toJson_IngressRouteSpecRoutesServicesStickyCookie(obj.cookie),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Cookie holds the sticky configuration based on cookie.
 *
 * @schema IngressRouteSpecRoutesServicesStickyCookie
 */
export interface IngressRouteSpecRoutesServicesStickyCookie {
  /**
   * @schema IngressRouteSpecRoutesServicesStickyCookie#httpOnly
   */
  readonly httpOnly?: boolean;

  /**
   * @schema IngressRouteSpecRoutesServicesStickyCookie#name
   */
  readonly name?: string;

  /**
   * @schema IngressRouteSpecRoutesServicesStickyCookie#sameSite
   */
  readonly sameSite?: string;

  /**
   * @schema IngressRouteSpecRoutesServicesStickyCookie#secure
   */
  readonly secure?: boolean;

}

/**
 * Converts an object of type 'IngressRouteSpecRoutesServicesStickyCookie' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IngressRouteSpecRoutesServicesStickyCookie(obj: IngressRouteSpecRoutesServicesStickyCookie | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpOnly': obj.httpOnly,
    'name': obj.name,
    'sameSite': obj.sameSite,
    'secure': obj.secure,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * IngressRouteTCP is an Ingress CRD specification.
 *
 * @schema IngressRouteTCP
 */
export class IngressRouteTcp extends ApiObject {
  /**
   * Returns the apiVersion and kind for "IngressRouteTCP"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'traefik.containo.us/v1alpha1',
    kind: 'IngressRouteTCP',
  }

  /**
   * Renders a Kubernetes manifest for "IngressRouteTCP".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: IngressRouteTcpProps): any {
    return {
      ...IngressRouteTcp.GVK,
      ...toJson_IngressRouteTcpProps(props),
    };
  }

  /**
   * Defines a "IngressRouteTCP" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: IngressRouteTcpProps) {
    super(scope, id, {
      ...IngressRouteTcp.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...IngressRouteTcp.GVK,
      ...toJson_IngressRouteTcpProps(resolved),
    };
  }
}

/**
 * IngressRouteTCP is an Ingress CRD specification.
 *
 * @schema IngressRouteTCP
 */
export interface IngressRouteTcpProps {
  /**
   * @schema IngressRouteTCP#metadata
   */
  readonly metadata: ApiObjectMetadata;

  /**
   * IngressRouteTCPSpec is a specification for a IngressRouteTCPSpec resource.
   *
   * @schema IngressRouteTCP#spec
   */
  readonly spec: IngressRouteTcpSpec;

}

/**
 * Converts an object of type 'IngressRouteTcpProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IngressRouteTcpProps(obj: IngressRouteTcpProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_IngressRouteTcpSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IngressRouteTCPSpec is a specification for a IngressRouteTCPSpec resource.
 *
 * @schema IngressRouteTcpSpec
 */
export interface IngressRouteTcpSpec {
  /**
   * @schema IngressRouteTcpSpec#entryPoints
   */
  readonly entryPoints?: string[];

  /**
   * @schema IngressRouteTcpSpec#routes
   */
  readonly routes: IngressRouteTcpSpecRoutes[];

  /**
   * TLSTCP contains the TLS certificates configuration of the routes. To enable Let's Encrypt, use an empty TLS struct, e.g. in YAML:
   * tls: {} # inline format
   * tls: 	   secretName: # block format
   *
   * @schema IngressRouteTcpSpec#tls
   */
  readonly tls?: IngressRouteTcpSpecTls;

}

/**
 * Converts an object of type 'IngressRouteTcpSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IngressRouteTcpSpec(obj: IngressRouteTcpSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'entryPoints': obj.entryPoints?.map(y => y),
    'routes': obj.routes?.map(y => toJson_IngressRouteTcpSpecRoutes(y)),
    'tls': toJson_IngressRouteTcpSpecTls(obj.tls),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RouteTCP contains the set of routes.
 *
 * @schema IngressRouteTcpSpecRoutes
 */
export interface IngressRouteTcpSpecRoutes {
  /**
   * @schema IngressRouteTcpSpecRoutes#match
   */
  readonly match: string;

  /**
   * Middlewares contains references to MiddlewareTCP resources.
   *
   * @schema IngressRouteTcpSpecRoutes#middlewares
   */
  readonly middlewares?: IngressRouteTcpSpecRoutesMiddlewares[];

  /**
   * @schema IngressRouteTcpSpecRoutes#priority
   */
  readonly priority?: number;

  /**
   * @schema IngressRouteTcpSpecRoutes#services
   */
  readonly services?: IngressRouteTcpSpecRoutesServices[];

}

/**
 * Converts an object of type 'IngressRouteTcpSpecRoutes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IngressRouteTcpSpecRoutes(obj: IngressRouteTcpSpecRoutes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'match': obj.match,
    'middlewares': obj.middlewares?.map(y => toJson_IngressRouteTcpSpecRoutesMiddlewares(y)),
    'priority': obj.priority,
    'services': obj.services?.map(y => toJson_IngressRouteTcpSpecRoutesServices(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLSTCP contains the TLS certificates configuration of the routes. To enable Let's Encrypt, use an empty TLS struct, e.g. in YAML:
 * tls: {} # inline format
 * tls: 	   secretName: # block format
 *
 * @schema IngressRouteTcpSpecTls
 */
export interface IngressRouteTcpSpecTls {
  /**
   * @schema IngressRouteTcpSpecTls#certResolver
   */
  readonly certResolver?: string;

  /**
   * @schema IngressRouteTcpSpecTls#domains
   */
  readonly domains?: IngressRouteTcpSpecTlsDomains[];

  /**
   * Options is a reference to a TLSOption, that specifies the parameters of the TLS connection.
   *
   * @schema IngressRouteTcpSpecTls#options
   */
  readonly options?: IngressRouteTcpSpecTlsOptions;

  /**
   * @schema IngressRouteTcpSpecTls#passthrough
   */
  readonly passthrough?: boolean;

  /**
   * SecretName is the name of the referenced Kubernetes Secret to specify the certificate details.
   *
   * @schema IngressRouteTcpSpecTls#secretName
   */
  readonly secretName?: string;

  /**
   * Store is a reference to a TLSStore, that specifies the parameters of the TLS store.
   *
   * @schema IngressRouteTcpSpecTls#store
   */
  readonly store?: IngressRouteTcpSpecTlsStore;

}

/**
 * Converts an object of type 'IngressRouteTcpSpecTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IngressRouteTcpSpecTls(obj: IngressRouteTcpSpecTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certResolver': obj.certResolver,
    'domains': obj.domains?.map(y => toJson_IngressRouteTcpSpecTlsDomains(y)),
    'options': toJson_IngressRouteTcpSpecTlsOptions(obj.options),
    'passthrough': obj.passthrough,
    'secretName': obj.secretName,
    'store': toJson_IngressRouteTcpSpecTlsStore(obj.store),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ObjectReference is a generic reference to a Traefik resource.
 *
 * @schema IngressRouteTcpSpecRoutesMiddlewares
 */
export interface IngressRouteTcpSpecRoutesMiddlewares {
  /**
   * @schema IngressRouteTcpSpecRoutesMiddlewares#name
   */
  readonly name: string;

  /**
   * @schema IngressRouteTcpSpecRoutesMiddlewares#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'IngressRouteTcpSpecRoutesMiddlewares' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IngressRouteTcpSpecRoutesMiddlewares(obj: IngressRouteTcpSpecRoutesMiddlewares | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ServiceTCP defines an upstream to proxy traffic.
 *
 * @schema IngressRouteTcpSpecRoutesServices
 */
export interface IngressRouteTcpSpecRoutesServices {
  /**
   * @schema IngressRouteTcpSpecRoutesServices#name
   */
  readonly name: string;

  /**
   * @schema IngressRouteTcpSpecRoutesServices#namespace
   */
  readonly namespace?: string;

  /**
   * @schema IngressRouteTcpSpecRoutesServices#port
   */
  readonly port: IngressRouteTcpSpecRoutesServicesPort;

  /**
   * ProxyProtocol holds the ProxyProtocol configuration.
   *
   * @schema IngressRouteTcpSpecRoutesServices#proxyProtocol
   */
  readonly proxyProtocol?: IngressRouteTcpSpecRoutesServicesProxyProtocol;

  /**
   * @schema IngressRouteTcpSpecRoutesServices#terminationDelay
   */
  readonly terminationDelay?: number;

  /**
   * @schema IngressRouteTcpSpecRoutesServices#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'IngressRouteTcpSpecRoutesServices' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IngressRouteTcpSpecRoutesServices(obj: IngressRouteTcpSpecRoutesServices | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
    'port': obj.port?.value,
    'proxyProtocol': toJson_IngressRouteTcpSpecRoutesServicesProxyProtocol(obj.proxyProtocol),
    'terminationDelay': obj.terminationDelay,
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Domain holds a domain name with SANs.
 *
 * @schema IngressRouteTcpSpecTlsDomains
 */
export interface IngressRouteTcpSpecTlsDomains {
  /**
   * @schema IngressRouteTcpSpecTlsDomains#main
   */
  readonly main?: string;

  /**
   * @schema IngressRouteTcpSpecTlsDomains#sans
   */
  readonly sans?: string[];

}

/**
 * Converts an object of type 'IngressRouteTcpSpecTlsDomains' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IngressRouteTcpSpecTlsDomains(obj: IngressRouteTcpSpecTlsDomains | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'main': obj.main,
    'sans': obj.sans?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Options is a reference to a TLSOption, that specifies the parameters of the TLS connection.
 *
 * @schema IngressRouteTcpSpecTlsOptions
 */
export interface IngressRouteTcpSpecTlsOptions {
  /**
   * @schema IngressRouteTcpSpecTlsOptions#name
   */
  readonly name: string;

  /**
   * @schema IngressRouteTcpSpecTlsOptions#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'IngressRouteTcpSpecTlsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IngressRouteTcpSpecTlsOptions(obj: IngressRouteTcpSpecTlsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Store is a reference to a TLSStore, that specifies the parameters of the TLS store.
 *
 * @schema IngressRouteTcpSpecTlsStore
 */
export interface IngressRouteTcpSpecTlsStore {
  /**
   * @schema IngressRouteTcpSpecTlsStore#name
   */
  readonly name: string;

  /**
   * @schema IngressRouteTcpSpecTlsStore#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'IngressRouteTcpSpecTlsStore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IngressRouteTcpSpecTlsStore(obj: IngressRouteTcpSpecTlsStore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema IngressRouteTcpSpecRoutesServicesPort
 */
export class IngressRouteTcpSpecRoutesServicesPort {
  public static fromNumber(value: number): IngressRouteTcpSpecRoutesServicesPort {
    return new IngressRouteTcpSpecRoutesServicesPort(value);
  }
  public static fromString(value: string): IngressRouteTcpSpecRoutesServicesPort {
    return new IngressRouteTcpSpecRoutesServicesPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * ProxyProtocol holds the ProxyProtocol configuration.
 *
 * @schema IngressRouteTcpSpecRoutesServicesProxyProtocol
 */
export interface IngressRouteTcpSpecRoutesServicesProxyProtocol {
  /**
   * @schema IngressRouteTcpSpecRoutesServicesProxyProtocol#version
   */
  readonly version?: number;

}

/**
 * Converts an object of type 'IngressRouteTcpSpecRoutesServicesProxyProtocol' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IngressRouteTcpSpecRoutesServicesProxyProtocol(obj: IngressRouteTcpSpecRoutesServicesProxyProtocol | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * IngressRouteUDP is an Ingress CRD specification.
 *
 * @schema IngressRouteUDP
 */
export class IngressRouteUdp extends ApiObject {
  /**
   * Returns the apiVersion and kind for "IngressRouteUDP"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'traefik.containo.us/v1alpha1',
    kind: 'IngressRouteUDP',
  }

  /**
   * Renders a Kubernetes manifest for "IngressRouteUDP".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: IngressRouteUdpProps): any {
    return {
      ...IngressRouteUdp.GVK,
      ...toJson_IngressRouteUdpProps(props),
    };
  }

  /**
   * Defines a "IngressRouteUDP" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: IngressRouteUdpProps) {
    super(scope, id, {
      ...IngressRouteUdp.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...IngressRouteUdp.GVK,
      ...toJson_IngressRouteUdpProps(resolved),
    };
  }
}

/**
 * IngressRouteUDP is an Ingress CRD specification.
 *
 * @schema IngressRouteUDP
 */
export interface IngressRouteUdpProps {
  /**
   * @schema IngressRouteUDP#metadata
   */
  readonly metadata: ApiObjectMetadata;

  /**
   * IngressRouteUDPSpec is a specification for a IngressRouteUDPSpec resource.
   *
   * @schema IngressRouteUDP#spec
   */
  readonly spec: IngressRouteUdpSpec;

}

/**
 * Converts an object of type 'IngressRouteUdpProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IngressRouteUdpProps(obj: IngressRouteUdpProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_IngressRouteUdpSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IngressRouteUDPSpec is a specification for a IngressRouteUDPSpec resource.
 *
 * @schema IngressRouteUdpSpec
 */
export interface IngressRouteUdpSpec {
  /**
   * @schema IngressRouteUdpSpec#entryPoints
   */
  readonly entryPoints?: string[];

  /**
   * @schema IngressRouteUdpSpec#routes
   */
  readonly routes: IngressRouteUdpSpecRoutes[];

}

/**
 * Converts an object of type 'IngressRouteUdpSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IngressRouteUdpSpec(obj: IngressRouteUdpSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'entryPoints': obj.entryPoints?.map(y => y),
    'routes': obj.routes?.map(y => toJson_IngressRouteUdpSpecRoutes(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RouteUDP contains the set of routes.
 *
 * @schema IngressRouteUdpSpecRoutes
 */
export interface IngressRouteUdpSpecRoutes {
  /**
   * @schema IngressRouteUdpSpecRoutes#services
   */
  readonly services?: IngressRouteUdpSpecRoutesServices[];

}

/**
 * Converts an object of type 'IngressRouteUdpSpecRoutes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IngressRouteUdpSpecRoutes(obj: IngressRouteUdpSpecRoutes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'services': obj.services?.map(y => toJson_IngressRouteUdpSpecRoutesServices(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ServiceUDP defines an upstream to proxy traffic.
 *
 * @schema IngressRouteUdpSpecRoutesServices
 */
export interface IngressRouteUdpSpecRoutesServices {
  /**
   * @schema IngressRouteUdpSpecRoutesServices#name
   */
  readonly name: string;

  /**
   * @schema IngressRouteUdpSpecRoutesServices#namespace
   */
  readonly namespace?: string;

  /**
   * @schema IngressRouteUdpSpecRoutesServices#port
   */
  readonly port: IngressRouteUdpSpecRoutesServicesPort;

  /**
   * @schema IngressRouteUdpSpecRoutesServices#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'IngressRouteUdpSpecRoutesServices' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IngressRouteUdpSpecRoutesServices(obj: IngressRouteUdpSpecRoutesServices | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
    'port': obj.port?.value,
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema IngressRouteUdpSpecRoutesServicesPort
 */
export class IngressRouteUdpSpecRoutesServicesPort {
  public static fromNumber(value: number): IngressRouteUdpSpecRoutesServicesPort {
    return new IngressRouteUdpSpecRoutesServicesPort(value);
  }
  public static fromString(value: string): IngressRouteUdpSpecRoutesServicesPort {
    return new IngressRouteUdpSpecRoutesServicesPort(value);
  }
  private constructor(public readonly value: any) {
  }
}


/**
 * Middleware is a specification for a Middleware resource.
 *
 * @schema Middleware
 */
export class Middleware extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Middleware"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'traefik.containo.us/v1alpha1',
    kind: 'Middleware',
  }

  /**
   * Renders a Kubernetes manifest for "Middleware".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: MiddlewareProps): any {
    return {
      ...Middleware.GVK,
      ...toJson_MiddlewareProps(props),
    };
  }

  /**
   * Defines a "Middleware" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: MiddlewareProps) {
    super(scope, id, {
      ...Middleware.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Middleware.GVK,
      ...toJson_MiddlewareProps(resolved),
    };
  }
}

/**
 * Middleware is a specification for a Middleware resource.
 *
 * @schema Middleware
 */
export interface MiddlewareProps {
  /**
   * @schema Middleware#metadata
   */
  readonly metadata: ApiObjectMetadata;

  /**
   * MiddlewareSpec holds the Middleware configuration.
   *
   * @schema Middleware#spec
   */
  readonly spec: MiddlewareSpec;

}

/**
 * Converts an object of type 'MiddlewareProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MiddlewareProps(obj: MiddlewareProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_MiddlewareSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * MiddlewareSpec holds the Middleware configuration.
 *
 * @schema MiddlewareSpec
 */
export interface MiddlewareSpec {
  /**
   * AddPrefix holds the AddPrefix configuration.
   *
   * @schema MiddlewareSpec#addPrefix
   */
  readonly addPrefix?: MiddlewareSpecAddPrefix;

  /**
   * BasicAuth holds the HTTP basic authentication configuration.
   *
   * @schema MiddlewareSpec#basicAuth
   */
  readonly basicAuth?: MiddlewareSpecBasicAuth;

  /**
   * Buffering holds the request/response buffering configuration.
   *
   * @schema MiddlewareSpec#buffering
   */
  readonly buffering?: MiddlewareSpecBuffering;

  /**
   * Chain holds a chain of middlewares.
   *
   * @schema MiddlewareSpec#chain
   */
  readonly chain?: MiddlewareSpecChain;

  /**
   * CircuitBreaker holds the circuit breaker configuration.
   *
   * @schema MiddlewareSpec#circuitBreaker
   */
  readonly circuitBreaker?: MiddlewareSpecCircuitBreaker;

  /**
   * Compress holds the compress configuration.
   *
   * @schema MiddlewareSpec#compress
   */
  readonly compress?: MiddlewareSpecCompress;

  /**
   * ContentType middleware - or rather its unique `autoDetect` option - specifies whether to let the `Content-Type` header, if it has not been set by the backend, be automatically set to a value derived from the contents of the response. As a proxy, the default behavior should be to leave the header alone, regardless of what the backend did with it. However, the historic default was to always auto-detect and set the header if it was nil, and it is going to be kept that way in order to support users currently relying on it. This middleware exists to enable the correct behavior until at least the default one can be changed in a future version.
   *
   * @schema MiddlewareSpec#contentType
   */
  readonly contentType?: MiddlewareSpecContentType;

  /**
   * DigestAuth holds the Digest HTTP authentication configuration.
   *
   * @schema MiddlewareSpec#digestAuth
   */
  readonly digestAuth?: MiddlewareSpecDigestAuth;

  /**
   * ErrorPage holds the custom error page configuration.
   *
   * @schema MiddlewareSpec#errors
   */
  readonly errors?: MiddlewareSpecErrors;

  /**
   * ForwardAuth holds the http forward authentication configuration.
   *
   * @schema MiddlewareSpec#forwardAuth
   */
  readonly forwardAuth?: MiddlewareSpecForwardAuth;

  /**
   * Headers holds the custom header configuration.
   *
   * @schema MiddlewareSpec#headers
   */
  readonly headers?: MiddlewareSpecHeaders;

  /**
   * InFlightReq  the number of requests being processed and served concurrently.
   *
   * @schema MiddlewareSpec#inFlightReq
   */
  readonly inFlightReq?: MiddlewareSpecInFlightReq;

  /**
   * IPWhiteList holds the ip white list configuration.
   *
   * @schema MiddlewareSpec#ipWhiteList
   */
  readonly ipWhiteList?: MiddlewareSpecIpWhiteList;

  /**
   * PassTLSClientCert holds the TLS client cert headers configuration.
   *
   * @schema MiddlewareSpec#passTLSClientCert
   */
  readonly passTlsClientCert?: MiddlewareSpecPassTlsClientCert;

  /**
   * @schema MiddlewareSpec#plugin
   */
  readonly plugin?: { [key: string]: any };

  /**
   * RateLimit holds the rate limiting configuration for a given router.
   *
   * @schema MiddlewareSpec#rateLimit
   */
  readonly rateLimit?: MiddlewareSpecRateLimit;

  /**
   * RedirectRegex holds the redirection configuration.
   *
   * @schema MiddlewareSpec#redirectRegex
   */
  readonly redirectRegex?: MiddlewareSpecRedirectRegex;

  /**
   * RedirectScheme holds the scheme redirection configuration.
   *
   * @schema MiddlewareSpec#redirectScheme
   */
  readonly redirectScheme?: MiddlewareSpecRedirectScheme;

  /**
   * ReplacePath holds the ReplacePath configuration.
   *
   * @schema MiddlewareSpec#replacePath
   */
  readonly replacePath?: MiddlewareSpecReplacePath;

  /**
   * ReplacePathRegex holds the ReplacePathRegex configuration.
   *
   * @schema MiddlewareSpec#replacePathRegex
   */
  readonly replacePathRegex?: MiddlewareSpecReplacePathRegex;

  /**
   * Retry holds the retry configuration.
   *
   * @schema MiddlewareSpec#retry
   */
  readonly retry?: MiddlewareSpecRetry;

  /**
   * StripPrefix holds the StripPrefix configuration.
   *
   * @schema MiddlewareSpec#stripPrefix
   */
  readonly stripPrefix?: MiddlewareSpecStripPrefix;

  /**
   * StripPrefixRegex holds the StripPrefixRegex configuration.
   *
   * @schema MiddlewareSpec#stripPrefixRegex
   */
  readonly stripPrefixRegex?: MiddlewareSpecStripPrefixRegex;

}

/**
 * Converts an object of type 'MiddlewareSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MiddlewareSpec(obj: MiddlewareSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'addPrefix': toJson_MiddlewareSpecAddPrefix(obj.addPrefix),
    'basicAuth': toJson_MiddlewareSpecBasicAuth(obj.basicAuth),
    'buffering': toJson_MiddlewareSpecBuffering(obj.buffering),
    'chain': toJson_MiddlewareSpecChain(obj.chain),
    'circuitBreaker': toJson_MiddlewareSpecCircuitBreaker(obj.circuitBreaker),
    'compress': toJson_MiddlewareSpecCompress(obj.compress),
    'contentType': toJson_MiddlewareSpecContentType(obj.contentType),
    'digestAuth': toJson_MiddlewareSpecDigestAuth(obj.digestAuth),
    'errors': toJson_MiddlewareSpecErrors(obj.errors),
    'forwardAuth': toJson_MiddlewareSpecForwardAuth(obj.forwardAuth),
    'headers': toJson_MiddlewareSpecHeaders(obj.headers),
    'inFlightReq': toJson_MiddlewareSpecInFlightReq(obj.inFlightReq),
    'ipWhiteList': toJson_MiddlewareSpecIpWhiteList(obj.ipWhiteList),
    'passTLSClientCert': toJson_MiddlewareSpecPassTlsClientCert(obj.passTlsClientCert),
    'plugin': ((obj.plugin) === undefined) ? undefined : (Object.entries(obj.plugin).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'rateLimit': toJson_MiddlewareSpecRateLimit(obj.rateLimit),
    'redirectRegex': toJson_MiddlewareSpecRedirectRegex(obj.redirectRegex),
    'redirectScheme': toJson_MiddlewareSpecRedirectScheme(obj.redirectScheme),
    'replacePath': toJson_MiddlewareSpecReplacePath(obj.replacePath),
    'replacePathRegex': toJson_MiddlewareSpecReplacePathRegex(obj.replacePathRegex),
    'retry': toJson_MiddlewareSpecRetry(obj.retry),
    'stripPrefix': toJson_MiddlewareSpecStripPrefix(obj.stripPrefix),
    'stripPrefixRegex': toJson_MiddlewareSpecStripPrefixRegex(obj.stripPrefixRegex),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AddPrefix holds the AddPrefix configuration.
 *
 * @schema MiddlewareSpecAddPrefix
 */
export interface MiddlewareSpecAddPrefix {
  /**
   * @schema MiddlewareSpecAddPrefix#prefix
   */
  readonly prefix?: string;

}

/**
 * Converts an object of type 'MiddlewareSpecAddPrefix' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MiddlewareSpecAddPrefix(obj: MiddlewareSpecAddPrefix | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'prefix': obj.prefix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BasicAuth holds the HTTP basic authentication configuration.
 *
 * @schema MiddlewareSpecBasicAuth
 */
export interface MiddlewareSpecBasicAuth {
  /**
   * @schema MiddlewareSpecBasicAuth#headerField
   */
  readonly headerField?: string;

  /**
   * @schema MiddlewareSpecBasicAuth#realm
   */
  readonly realm?: string;

  /**
   * @schema MiddlewareSpecBasicAuth#removeHeader
   */
  readonly removeHeader?: boolean;

  /**
   * @schema MiddlewareSpecBasicAuth#secret
   */
  readonly secret?: string;

}

/**
 * Converts an object of type 'MiddlewareSpecBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MiddlewareSpecBasicAuth(obj: MiddlewareSpecBasicAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'headerField': obj.headerField,
    'realm': obj.realm,
    'removeHeader': obj.removeHeader,
    'secret': obj.secret,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Buffering holds the request/response buffering configuration.
 *
 * @schema MiddlewareSpecBuffering
 */
export interface MiddlewareSpecBuffering {
  /**
   * @schema MiddlewareSpecBuffering#maxRequestBodyBytes
   */
  readonly maxRequestBodyBytes?: number;

  /**
   * @schema MiddlewareSpecBuffering#maxResponseBodyBytes
   */
  readonly maxResponseBodyBytes?: number;

  /**
   * @schema MiddlewareSpecBuffering#memRequestBodyBytes
   */
  readonly memRequestBodyBytes?: number;

  /**
   * @schema MiddlewareSpecBuffering#memResponseBodyBytes
   */
  readonly memResponseBodyBytes?: number;

  /**
   * @schema MiddlewareSpecBuffering#retryExpression
   */
  readonly retryExpression?: string;

}

/**
 * Converts an object of type 'MiddlewareSpecBuffering' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MiddlewareSpecBuffering(obj: MiddlewareSpecBuffering | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxRequestBodyBytes': obj.maxRequestBodyBytes,
    'maxResponseBodyBytes': obj.maxResponseBodyBytes,
    'memRequestBodyBytes': obj.memRequestBodyBytes,
    'memResponseBodyBytes': obj.memResponseBodyBytes,
    'retryExpression': obj.retryExpression,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Chain holds a chain of middlewares.
 *
 * @schema MiddlewareSpecChain
 */
export interface MiddlewareSpecChain {
  /**
   * @schema MiddlewareSpecChain#middlewares
   */
  readonly middlewares?: MiddlewareSpecChainMiddlewares[];

}

/**
 * Converts an object of type 'MiddlewareSpecChain' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MiddlewareSpecChain(obj: MiddlewareSpecChain | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'middlewares': obj.middlewares?.map(y => toJson_MiddlewareSpecChainMiddlewares(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CircuitBreaker holds the circuit breaker configuration.
 *
 * @schema MiddlewareSpecCircuitBreaker
 */
export interface MiddlewareSpecCircuitBreaker {
  /**
   * @schema MiddlewareSpecCircuitBreaker#expression
   */
  readonly expression?: string;

}

/**
 * Converts an object of type 'MiddlewareSpecCircuitBreaker' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MiddlewareSpecCircuitBreaker(obj: MiddlewareSpecCircuitBreaker | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'expression': obj.expression,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Compress holds the compress configuration.
 *
 * @schema MiddlewareSpecCompress
 */
export interface MiddlewareSpecCompress {
  /**
   * @schema MiddlewareSpecCompress#excludedContentTypes
   */
  readonly excludedContentTypes?: string[];

  /**
   * @schema MiddlewareSpecCompress#minResponseBodyBytes
   */
  readonly minResponseBodyBytes?: number;

}

/**
 * Converts an object of type 'MiddlewareSpecCompress' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MiddlewareSpecCompress(obj: MiddlewareSpecCompress | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'excludedContentTypes': obj.excludedContentTypes?.map(y => y),
    'minResponseBodyBytes': obj.minResponseBodyBytes,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ContentType middleware - or rather its unique `autoDetect` option - specifies whether to let the `Content-Type` header, if it has not been set by the backend, be automatically set to a value derived from the contents of the response. As a proxy, the default behavior should be to leave the header alone, regardless of what the backend did with it. However, the historic default was to always auto-detect and set the header if it was nil, and it is going to be kept that way in order to support users currently relying on it. This middleware exists to enable the correct behavior until at least the default one can be changed in a future version.
 *
 * @schema MiddlewareSpecContentType
 */
export interface MiddlewareSpecContentType {
  /**
   * @schema MiddlewareSpecContentType#autoDetect
   */
  readonly autoDetect?: boolean;

}

/**
 * Converts an object of type 'MiddlewareSpecContentType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MiddlewareSpecContentType(obj: MiddlewareSpecContentType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoDetect': obj.autoDetect,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DigestAuth holds the Digest HTTP authentication configuration.
 *
 * @schema MiddlewareSpecDigestAuth
 */
export interface MiddlewareSpecDigestAuth {
  /**
   * @schema MiddlewareSpecDigestAuth#headerField
   */
  readonly headerField?: string;

  /**
   * @schema MiddlewareSpecDigestAuth#realm
   */
  readonly realm?: string;

  /**
   * @schema MiddlewareSpecDigestAuth#removeHeader
   */
  readonly removeHeader?: boolean;

  /**
   * @schema MiddlewareSpecDigestAuth#secret
   */
  readonly secret?: string;

}

/**
 * Converts an object of type 'MiddlewareSpecDigestAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MiddlewareSpecDigestAuth(obj: MiddlewareSpecDigestAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'headerField': obj.headerField,
    'realm': obj.realm,
    'removeHeader': obj.removeHeader,
    'secret': obj.secret,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ErrorPage holds the custom error page configuration.
 *
 * @schema MiddlewareSpecErrors
 */
export interface MiddlewareSpecErrors {
  /**
   * @schema MiddlewareSpecErrors#query
   */
  readonly query?: string;

  /**
   * Service defines an upstream to proxy traffic.
   *
   * @schema MiddlewareSpecErrors#service
   */
  readonly service?: MiddlewareSpecErrorsService;

  /**
   * @schema MiddlewareSpecErrors#status
   */
  readonly status?: string[];

}

/**
 * Converts an object of type 'MiddlewareSpecErrors' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MiddlewareSpecErrors(obj: MiddlewareSpecErrors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'query': obj.query,
    'service': toJson_MiddlewareSpecErrorsService(obj.service),
    'status': obj.status?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ForwardAuth holds the http forward authentication configuration.
 *
 * @schema MiddlewareSpecForwardAuth
 */
export interface MiddlewareSpecForwardAuth {
  /**
   * @schema MiddlewareSpecForwardAuth#address
   */
  readonly address?: string;

  /**
   * @schema MiddlewareSpecForwardAuth#authRequestHeaders
   */
  readonly authRequestHeaders?: string[];

  /**
   * @schema MiddlewareSpecForwardAuth#authResponseHeaders
   */
  readonly authResponseHeaders?: string[];

  /**
   * @schema MiddlewareSpecForwardAuth#authResponseHeadersRegex
   */
  readonly authResponseHeadersRegex?: string;

  /**
   * ClientTLS holds TLS specific configurations as client.
   *
   * @schema MiddlewareSpecForwardAuth#tls
   */
  readonly tls?: MiddlewareSpecForwardAuthTls;

  /**
   * @schema MiddlewareSpecForwardAuth#trustForwardHeader
   */
  readonly trustForwardHeader?: boolean;

}

/**
 * Converts an object of type 'MiddlewareSpecForwardAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MiddlewareSpecForwardAuth(obj: MiddlewareSpecForwardAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'address': obj.address,
    'authRequestHeaders': obj.authRequestHeaders?.map(y => y),
    'authResponseHeaders': obj.authResponseHeaders?.map(y => y),
    'authResponseHeadersRegex': obj.authResponseHeadersRegex,
    'tls': toJson_MiddlewareSpecForwardAuthTls(obj.tls),
    'trustForwardHeader': obj.trustForwardHeader,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Headers holds the custom header configuration.
 *
 * @schema MiddlewareSpecHeaders
 */
export interface MiddlewareSpecHeaders {
  /**
   * AccessControlAllowCredentials is only valid if true. false is ignored.
   *
   * @schema MiddlewareSpecHeaders#accessControlAllowCredentials
   */
  readonly accessControlAllowCredentials?: boolean;

  /**
   * AccessControlAllowHeaders must be used in response to a preflight request with Access-Control-Request-Headers set.
   *
   * @schema MiddlewareSpecHeaders#accessControlAllowHeaders
   */
  readonly accessControlAllowHeaders?: string[];

  /**
   * AccessControlAllowMethods must be used in response to a preflight request with Access-Control-Request-Method set.
   *
   * @schema MiddlewareSpecHeaders#accessControlAllowMethods
   */
  readonly accessControlAllowMethods?: string[];

  /**
   * AccessControlAllowOriginList is a list of allowable origins. Can also be a wildcard origin "*".
   *
   * @schema MiddlewareSpecHeaders#accessControlAllowOriginList
   */
  readonly accessControlAllowOriginList?: string[];

  /**
   * AccessControlAllowOriginListRegex is a list of allowable origins written following the Regular Expression syntax (https://golang.org/pkg/regexp/).
   *
   * @schema MiddlewareSpecHeaders#accessControlAllowOriginListRegex
   */
  readonly accessControlAllowOriginListRegex?: string[];

  /**
   * AccessControlExposeHeaders sets valid headers for the response.
   *
   * @schema MiddlewareSpecHeaders#accessControlExposeHeaders
   */
  readonly accessControlExposeHeaders?: string[];

  /**
   * AccessControlMaxAge sets the time that a preflight request may be cached.
   *
   * @schema MiddlewareSpecHeaders#accessControlMaxAge
   */
  readonly accessControlMaxAge?: number;

  /**
   * AddVaryHeader controls if the Vary header is automatically added/updated when the AccessControlAllowOriginList is set.
   *
   * @schema MiddlewareSpecHeaders#addVaryHeader
   */
  readonly addVaryHeader?: boolean;

  /**
   * @schema MiddlewareSpecHeaders#allowedHosts
   */
  readonly allowedHosts?: string[];

  /**
   * @schema MiddlewareSpecHeaders#browserXssFilter
   */
  readonly browserXssFilter?: boolean;

  /**
   * @schema MiddlewareSpecHeaders#contentSecurityPolicy
   */
  readonly contentSecurityPolicy?: string;

  /**
   * @schema MiddlewareSpecHeaders#contentTypeNosniff
   */
  readonly contentTypeNosniff?: boolean;

  /**
   * @schema MiddlewareSpecHeaders#customBrowserXSSValue
   */
  readonly customBrowserXssValue?: string;

  /**
   * @schema MiddlewareSpecHeaders#customFrameOptionsValue
   */
  readonly customFrameOptionsValue?: string;

  /**
   * @schema MiddlewareSpecHeaders#customRequestHeaders
   */
  readonly customRequestHeaders?: { [key: string]: string };

  /**
   * @schema MiddlewareSpecHeaders#customResponseHeaders
   */
  readonly customResponseHeaders?: { [key: string]: string };

  /**
   * Deprecated: use PermissionsPolicy instead.
   *
   * @schema MiddlewareSpecHeaders#featurePolicy
   */
  readonly featurePolicy?: string;

  /**
   * @schema MiddlewareSpecHeaders#forceSTSHeader
   */
  readonly forceStsHeader?: boolean;

  /**
   * @schema MiddlewareSpecHeaders#frameDeny
   */
  readonly frameDeny?: boolean;

  /**
   * @schema MiddlewareSpecHeaders#hostsProxyHeaders
   */
  readonly hostsProxyHeaders?: string[];

  /**
   * @schema MiddlewareSpecHeaders#isDevelopment
   */
  readonly isDevelopment?: boolean;

  /**
   * @schema MiddlewareSpecHeaders#permissionsPolicy
   */
  readonly permissionsPolicy?: string;

  /**
   * @schema MiddlewareSpecHeaders#publicKey
   */
  readonly publicKey?: string;

  /**
   * @schema MiddlewareSpecHeaders#referrerPolicy
   */
  readonly referrerPolicy?: string;

  /**
   * Deprecated: use RedirectRegex instead.
   *
   * @schema MiddlewareSpecHeaders#sslForceHost
   */
  readonly sslForceHost?: boolean;

  /**
   * Deprecated: use RedirectRegex instead.
   *
   * @schema MiddlewareSpecHeaders#sslHost
   */
  readonly sslHost?: string;

  /**
   * @schema MiddlewareSpecHeaders#sslProxyHeaders
   */
  readonly sslProxyHeaders?: { [key: string]: string };

  /**
   * Deprecated: use EntryPoint redirection or RedirectScheme instead.
   *
   * @schema MiddlewareSpecHeaders#sslRedirect
   */
  readonly sslRedirect?: boolean;

  /**
   * Deprecated: use EntryPoint redirection or RedirectScheme instead.
   *
   * @schema MiddlewareSpecHeaders#sslTemporaryRedirect
   */
  readonly sslTemporaryRedirect?: boolean;

  /**
   * @schema MiddlewareSpecHeaders#stsIncludeSubdomains
   */
  readonly stsIncludeSubdomains?: boolean;

  /**
   * @schema MiddlewareSpecHeaders#stsPreload
   */
  readonly stsPreload?: boolean;

  /**
   * @schema MiddlewareSpecHeaders#stsSeconds
   */
  readonly stsSeconds?: number;

}

/**
 * Converts an object of type 'MiddlewareSpecHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MiddlewareSpecHeaders(obj: MiddlewareSpecHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessControlAllowCredentials': obj.accessControlAllowCredentials,
    'accessControlAllowHeaders': obj.accessControlAllowHeaders?.map(y => y),
    'accessControlAllowMethods': obj.accessControlAllowMethods?.map(y => y),
    'accessControlAllowOriginList': obj.accessControlAllowOriginList?.map(y => y),
    'accessControlAllowOriginListRegex': obj.accessControlAllowOriginListRegex?.map(y => y),
    'accessControlExposeHeaders': obj.accessControlExposeHeaders?.map(y => y),
    'accessControlMaxAge': obj.accessControlMaxAge,
    'addVaryHeader': obj.addVaryHeader,
    'allowedHosts': obj.allowedHosts?.map(y => y),
    'browserXssFilter': obj.browserXssFilter,
    'contentSecurityPolicy': obj.contentSecurityPolicy,
    'contentTypeNosniff': obj.contentTypeNosniff,
    'customBrowserXSSValue': obj.customBrowserXssValue,
    'customFrameOptionsValue': obj.customFrameOptionsValue,
    'customRequestHeaders': ((obj.customRequestHeaders) === undefined) ? undefined : (Object.entries(obj.customRequestHeaders).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'customResponseHeaders': ((obj.customResponseHeaders) === undefined) ? undefined : (Object.entries(obj.customResponseHeaders).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'featurePolicy': obj.featurePolicy,
    'forceSTSHeader': obj.forceStsHeader,
    'frameDeny': obj.frameDeny,
    'hostsProxyHeaders': obj.hostsProxyHeaders?.map(y => y),
    'isDevelopment': obj.isDevelopment,
    'permissionsPolicy': obj.permissionsPolicy,
    'publicKey': obj.publicKey,
    'referrerPolicy': obj.referrerPolicy,
    'sslForceHost': obj.sslForceHost,
    'sslHost': obj.sslHost,
    'sslProxyHeaders': ((obj.sslProxyHeaders) === undefined) ? undefined : (Object.entries(obj.sslProxyHeaders).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'sslRedirect': obj.sslRedirect,
    'sslTemporaryRedirect': obj.sslTemporaryRedirect,
    'stsIncludeSubdomains': obj.stsIncludeSubdomains,
    'stsPreload': obj.stsPreload,
    'stsSeconds': obj.stsSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * InFlightReq  the number of requests being processed and served concurrently.
 *
 * @schema MiddlewareSpecInFlightReq
 */
export interface MiddlewareSpecInFlightReq {
  /**
   * @schema MiddlewareSpecInFlightReq#amount
   */
  readonly amount?: number;

  /**
   * SourceCriterion defines what criterion is used to group requests as originating from a common source. If none are set, the default is to use the request's remote address field. All fields are mutually exclusive.
   *
   * @schema MiddlewareSpecInFlightReq#sourceCriterion
   */
  readonly sourceCriterion?: MiddlewareSpecInFlightReqSourceCriterion;

}

/**
 * Converts an object of type 'MiddlewareSpecInFlightReq' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MiddlewareSpecInFlightReq(obj: MiddlewareSpecInFlightReq | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'amount': obj.amount,
    'sourceCriterion': toJson_MiddlewareSpecInFlightReqSourceCriterion(obj.sourceCriterion),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IPWhiteList holds the ip white list configuration.
 *
 * @schema MiddlewareSpecIpWhiteList
 */
export interface MiddlewareSpecIpWhiteList {
  /**
   * IPStrategy holds the ip strategy configuration.
   *
   * @schema MiddlewareSpecIpWhiteList#ipStrategy
   */
  readonly ipStrategy?: MiddlewareSpecIpWhiteListIpStrategy;

  /**
   * @schema MiddlewareSpecIpWhiteList#sourceRange
   */
  readonly sourceRange?: string[];

}

/**
 * Converts an object of type 'MiddlewareSpecIpWhiteList' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MiddlewareSpecIpWhiteList(obj: MiddlewareSpecIpWhiteList | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ipStrategy': toJson_MiddlewareSpecIpWhiteListIpStrategy(obj.ipStrategy),
    'sourceRange': obj.sourceRange?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PassTLSClientCert holds the TLS client cert headers configuration.
 *
 * @schema MiddlewareSpecPassTlsClientCert
 */
export interface MiddlewareSpecPassTlsClientCert {
  /**
   * TLSClientCertificateInfo holds the client TLS certificate info configuration.
   *
   * @schema MiddlewareSpecPassTlsClientCert#info
   */
  readonly info?: MiddlewareSpecPassTlsClientCertInfo;

  /**
   * @schema MiddlewareSpecPassTlsClientCert#pem
   */
  readonly pem?: boolean;

}

/**
 * Converts an object of type 'MiddlewareSpecPassTlsClientCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MiddlewareSpecPassTlsClientCert(obj: MiddlewareSpecPassTlsClientCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'info': toJson_MiddlewareSpecPassTlsClientCertInfo(obj.info),
    'pem': obj.pem,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RateLimit holds the rate limiting configuration for a given router.
 *
 * @schema MiddlewareSpecRateLimit
 */
export interface MiddlewareSpecRateLimit {
  /**
   * @schema MiddlewareSpecRateLimit#average
   */
  readonly average?: number;

  /**
   * @schema MiddlewareSpecRateLimit#burst
   */
  readonly burst?: number;

  /**
   * @schema MiddlewareSpecRateLimit#period
   */
  readonly period?: MiddlewareSpecRateLimitPeriod;

  /**
   * SourceCriterion defines what criterion is used to group requests as originating from a common source. If none are set, the default is to use the request's remote address field. All fields are mutually exclusive.
   *
   * @schema MiddlewareSpecRateLimit#sourceCriterion
   */
  readonly sourceCriterion?: MiddlewareSpecRateLimitSourceCriterion;

}

/**
 * Converts an object of type 'MiddlewareSpecRateLimit' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MiddlewareSpecRateLimit(obj: MiddlewareSpecRateLimit | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'average': obj.average,
    'burst': obj.burst,
    'period': obj.period?.value,
    'sourceCriterion': toJson_MiddlewareSpecRateLimitSourceCriterion(obj.sourceCriterion),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RedirectRegex holds the redirection configuration.
 *
 * @schema MiddlewareSpecRedirectRegex
 */
export interface MiddlewareSpecRedirectRegex {
  /**
   * @schema MiddlewareSpecRedirectRegex#permanent
   */
  readonly permanent?: boolean;

  /**
   * @schema MiddlewareSpecRedirectRegex#regex
   */
  readonly regex?: string;

  /**
   * @schema MiddlewareSpecRedirectRegex#replacement
   */
  readonly replacement?: string;

}

/**
 * Converts an object of type 'MiddlewareSpecRedirectRegex' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MiddlewareSpecRedirectRegex(obj: MiddlewareSpecRedirectRegex | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'permanent': obj.permanent,
    'regex': obj.regex,
    'replacement': obj.replacement,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RedirectScheme holds the scheme redirection configuration.
 *
 * @schema MiddlewareSpecRedirectScheme
 */
export interface MiddlewareSpecRedirectScheme {
  /**
   * @schema MiddlewareSpecRedirectScheme#permanent
   */
  readonly permanent?: boolean;

  /**
   * @schema MiddlewareSpecRedirectScheme#port
   */
  readonly port?: string;

  /**
   * @schema MiddlewareSpecRedirectScheme#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'MiddlewareSpecRedirectScheme' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MiddlewareSpecRedirectScheme(obj: MiddlewareSpecRedirectScheme | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'permanent': obj.permanent,
    'port': obj.port,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ReplacePath holds the ReplacePath configuration.
 *
 * @schema MiddlewareSpecReplacePath
 */
export interface MiddlewareSpecReplacePath {
  /**
   * @schema MiddlewareSpecReplacePath#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'MiddlewareSpecReplacePath' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MiddlewareSpecReplacePath(obj: MiddlewareSpecReplacePath | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ReplacePathRegex holds the ReplacePathRegex configuration.
 *
 * @schema MiddlewareSpecReplacePathRegex
 */
export interface MiddlewareSpecReplacePathRegex {
  /**
   * @schema MiddlewareSpecReplacePathRegex#regex
   */
  readonly regex?: string;

  /**
   * @schema MiddlewareSpecReplacePathRegex#replacement
   */
  readonly replacement?: string;

}

/**
 * Converts an object of type 'MiddlewareSpecReplacePathRegex' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MiddlewareSpecReplacePathRegex(obj: MiddlewareSpecReplacePathRegex | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'regex': obj.regex,
    'replacement': obj.replacement,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Retry holds the retry configuration.
 *
 * @schema MiddlewareSpecRetry
 */
export interface MiddlewareSpecRetry {
  /**
   * @schema MiddlewareSpecRetry#attempts
   */
  readonly attempts?: number;

  /**
   * @schema MiddlewareSpecRetry#initialInterval
   */
  readonly initialInterval?: MiddlewareSpecRetryInitialInterval;

}

/**
 * Converts an object of type 'MiddlewareSpecRetry' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MiddlewareSpecRetry(obj: MiddlewareSpecRetry | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'attempts': obj.attempts,
    'initialInterval': obj.initialInterval?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * StripPrefix holds the StripPrefix configuration.
 *
 * @schema MiddlewareSpecStripPrefix
 */
export interface MiddlewareSpecStripPrefix {
  /**
   * @schema MiddlewareSpecStripPrefix#forceSlash
   */
  readonly forceSlash?: boolean;

  /**
   * @schema MiddlewareSpecStripPrefix#prefixes
   */
  readonly prefixes?: string[];

}

/**
 * Converts an object of type 'MiddlewareSpecStripPrefix' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MiddlewareSpecStripPrefix(obj: MiddlewareSpecStripPrefix | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'forceSlash': obj.forceSlash,
    'prefixes': obj.prefixes?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * StripPrefixRegex holds the StripPrefixRegex configuration.
 *
 * @schema MiddlewareSpecStripPrefixRegex
 */
export interface MiddlewareSpecStripPrefixRegex {
  /**
   * @schema MiddlewareSpecStripPrefixRegex#regex
   */
  readonly regex?: string[];

}

/**
 * Converts an object of type 'MiddlewareSpecStripPrefixRegex' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MiddlewareSpecStripPrefixRegex(obj: MiddlewareSpecStripPrefixRegex | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'regex': obj.regex?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * MiddlewareRef is a ref to the Middleware resources.
 *
 * @schema MiddlewareSpecChainMiddlewares
 */
export interface MiddlewareSpecChainMiddlewares {
  /**
   * @schema MiddlewareSpecChainMiddlewares#name
   */
  readonly name: string;

  /**
   * @schema MiddlewareSpecChainMiddlewares#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'MiddlewareSpecChainMiddlewares' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MiddlewareSpecChainMiddlewares(obj: MiddlewareSpecChainMiddlewares | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Service defines an upstream to proxy traffic.
 *
 * @schema MiddlewareSpecErrorsService
 */
export interface MiddlewareSpecErrorsService {
  /**
   * @schema MiddlewareSpecErrorsService#kind
   */
  readonly kind?: MiddlewareSpecErrorsServiceKind;

  /**
   * Name is a reference to a Kubernetes Service object (for a load-balancer of servers), or to a TraefikService object (service load-balancer, mirroring, etc). The differentiation between the two is specified in the Kind field.
   *
   * @schema MiddlewareSpecErrorsService#name
   */
  readonly name: string;

  /**
   * @schema MiddlewareSpecErrorsService#namespace
   */
  readonly namespace?: string;

  /**
   * @schema MiddlewareSpecErrorsService#passHostHeader
   */
  readonly passHostHeader?: boolean;

  /**
   * @schema MiddlewareSpecErrorsService#port
   */
  readonly port?: MiddlewareSpecErrorsServicePort;

  /**
   * ResponseForwarding holds configuration for the forward of the response.
   *
   * @schema MiddlewareSpecErrorsService#responseForwarding
   */
  readonly responseForwarding?: MiddlewareSpecErrorsServiceResponseForwarding;

  /**
   * @schema MiddlewareSpecErrorsService#scheme
   */
  readonly scheme?: string;

  /**
   * @schema MiddlewareSpecErrorsService#serversTransport
   */
  readonly serversTransport?: string;

  /**
   * Sticky holds the sticky configuration.
   *
   * @schema MiddlewareSpecErrorsService#sticky
   */
  readonly sticky?: MiddlewareSpecErrorsServiceSticky;

  /**
   * @schema MiddlewareSpecErrorsService#strategy
   */
  readonly strategy?: string;

  /**
   * Weight should only be specified when Name references a TraefikService object (and to be precise, one that embeds a Weighted Round Robin).
   *
   * @schema MiddlewareSpecErrorsService#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'MiddlewareSpecErrorsService' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MiddlewareSpecErrorsService(obj: MiddlewareSpecErrorsService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
    'passHostHeader': obj.passHostHeader,
    'port': obj.port?.value,
    'responseForwarding': toJson_MiddlewareSpecErrorsServiceResponseForwarding(obj.responseForwarding),
    'scheme': obj.scheme,
    'serversTransport': obj.serversTransport,
    'sticky': toJson_MiddlewareSpecErrorsServiceSticky(obj.sticky),
    'strategy': obj.strategy,
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ClientTLS holds TLS specific configurations as client.
 *
 * @schema MiddlewareSpecForwardAuthTls
 */
export interface MiddlewareSpecForwardAuthTls {
  /**
   * @schema MiddlewareSpecForwardAuthTls#caOptional
   */
  readonly caOptional?: boolean;

  /**
   * @schema MiddlewareSpecForwardAuthTls#caSecret
   */
  readonly caSecret?: string;

  /**
   * @schema MiddlewareSpecForwardAuthTls#certSecret
   */
  readonly certSecret?: string;

  /**
   * @schema MiddlewareSpecForwardAuthTls#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

}

/**
 * Converts an object of type 'MiddlewareSpecForwardAuthTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MiddlewareSpecForwardAuthTls(obj: MiddlewareSpecForwardAuthTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caOptional': obj.caOptional,
    'caSecret': obj.caSecret,
    'certSecret': obj.certSecret,
    'insecureSkipVerify': obj.insecureSkipVerify,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SourceCriterion defines what criterion is used to group requests as originating from a common source. If none are set, the default is to use the request's remote address field. All fields are mutually exclusive.
 *
 * @schema MiddlewareSpecInFlightReqSourceCriterion
 */
export interface MiddlewareSpecInFlightReqSourceCriterion {
  /**
   * IPStrategy holds the ip strategy configuration.
   *
   * @schema MiddlewareSpecInFlightReqSourceCriterion#ipStrategy
   */
  readonly ipStrategy?: MiddlewareSpecInFlightReqSourceCriterionIpStrategy;

  /**
   * @schema MiddlewareSpecInFlightReqSourceCriterion#requestHeaderName
   */
  readonly requestHeaderName?: string;

  /**
   * @schema MiddlewareSpecInFlightReqSourceCriterion#requestHost
   */
  readonly requestHost?: boolean;

}

/**
 * Converts an object of type 'MiddlewareSpecInFlightReqSourceCriterion' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MiddlewareSpecInFlightReqSourceCriterion(obj: MiddlewareSpecInFlightReqSourceCriterion | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ipStrategy': toJson_MiddlewareSpecInFlightReqSourceCriterionIpStrategy(obj.ipStrategy),
    'requestHeaderName': obj.requestHeaderName,
    'requestHost': obj.requestHost,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IPStrategy holds the ip strategy configuration.
 *
 * @schema MiddlewareSpecIpWhiteListIpStrategy
 */
export interface MiddlewareSpecIpWhiteListIpStrategy {
  /**
   * @schema MiddlewareSpecIpWhiteListIpStrategy#depth
   */
  readonly depth?: number;

  /**
   * @schema MiddlewareSpecIpWhiteListIpStrategy#excludedIPs
   */
  readonly excludedIPs?: string[];

}

/**
 * Converts an object of type 'MiddlewareSpecIpWhiteListIpStrategy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MiddlewareSpecIpWhiteListIpStrategy(obj: MiddlewareSpecIpWhiteListIpStrategy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'depth': obj.depth,
    'excludedIPs': obj.excludedIPs?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLSClientCertificateInfo holds the client TLS certificate info configuration.
 *
 * @schema MiddlewareSpecPassTlsClientCertInfo
 */
export interface MiddlewareSpecPassTlsClientCertInfo {
  /**
   * TLSClientCertificateIssuerDNInfo holds the client TLS certificate distinguished name info configuration. cf https://tools.ietf.org/html/rfc3739
   *
   * @schema MiddlewareSpecPassTlsClientCertInfo#issuer
   */
  readonly issuer?: MiddlewareSpecPassTlsClientCertInfoIssuer;

  /**
   * @schema MiddlewareSpecPassTlsClientCertInfo#notAfter
   */
  readonly notAfter?: boolean;

  /**
   * @schema MiddlewareSpecPassTlsClientCertInfo#notBefore
   */
  readonly notBefore?: boolean;

  /**
   * @schema MiddlewareSpecPassTlsClientCertInfo#sans
   */
  readonly sans?: boolean;

  /**
   * @schema MiddlewareSpecPassTlsClientCertInfo#serialNumber
   */
  readonly serialNumber?: boolean;

  /**
   * TLSClientCertificateSubjectDNInfo holds the client TLS certificate distinguished name info configuration. cf https://tools.ietf.org/html/rfc3739
   *
   * @schema MiddlewareSpecPassTlsClientCertInfo#subject
   */
  readonly subject?: MiddlewareSpecPassTlsClientCertInfoSubject;

}

/**
 * Converts an object of type 'MiddlewareSpecPassTlsClientCertInfo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MiddlewareSpecPassTlsClientCertInfo(obj: MiddlewareSpecPassTlsClientCertInfo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'issuer': toJson_MiddlewareSpecPassTlsClientCertInfoIssuer(obj.issuer),
    'notAfter': obj.notAfter,
    'notBefore': obj.notBefore,
    'sans': obj.sans,
    'serialNumber': obj.serialNumber,
    'subject': toJson_MiddlewareSpecPassTlsClientCertInfoSubject(obj.subject),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MiddlewareSpecRateLimitPeriod
 */
export class MiddlewareSpecRateLimitPeriod {
  public static fromNumber(value: number): MiddlewareSpecRateLimitPeriod {
    return new MiddlewareSpecRateLimitPeriod(value);
  }
  public static fromString(value: string): MiddlewareSpecRateLimitPeriod {
    return new MiddlewareSpecRateLimitPeriod(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * SourceCriterion defines what criterion is used to group requests as originating from a common source. If none are set, the default is to use the request's remote address field. All fields are mutually exclusive.
 *
 * @schema MiddlewareSpecRateLimitSourceCriterion
 */
export interface MiddlewareSpecRateLimitSourceCriterion {
  /**
   * IPStrategy holds the ip strategy configuration.
   *
   * @schema MiddlewareSpecRateLimitSourceCriterion#ipStrategy
   */
  readonly ipStrategy?: MiddlewareSpecRateLimitSourceCriterionIpStrategy;

  /**
   * @schema MiddlewareSpecRateLimitSourceCriterion#requestHeaderName
   */
  readonly requestHeaderName?: string;

  /**
   * @schema MiddlewareSpecRateLimitSourceCriterion#requestHost
   */
  readonly requestHost?: boolean;

}

/**
 * Converts an object of type 'MiddlewareSpecRateLimitSourceCriterion' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MiddlewareSpecRateLimitSourceCriterion(obj: MiddlewareSpecRateLimitSourceCriterion | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ipStrategy': toJson_MiddlewareSpecRateLimitSourceCriterionIpStrategy(obj.ipStrategy),
    'requestHeaderName': obj.requestHeaderName,
    'requestHost': obj.requestHost,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MiddlewareSpecRetryInitialInterval
 */
export class MiddlewareSpecRetryInitialInterval {
  public static fromNumber(value: number): MiddlewareSpecRetryInitialInterval {
    return new MiddlewareSpecRetryInitialInterval(value);
  }
  public static fromString(value: string): MiddlewareSpecRetryInitialInterval {
    return new MiddlewareSpecRetryInitialInterval(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * @schema MiddlewareSpecErrorsServiceKind
 */
export enum MiddlewareSpecErrorsServiceKind {
  /** Service */
  SERVICE = 'Service',
  /** TraefikService */
  TRAEFIK_SERVICE = 'TraefikService',
}

/**
 * @schema MiddlewareSpecErrorsServicePort
 */
export class MiddlewareSpecErrorsServicePort {
  public static fromNumber(value: number): MiddlewareSpecErrorsServicePort {
    return new MiddlewareSpecErrorsServicePort(value);
  }
  public static fromString(value: string): MiddlewareSpecErrorsServicePort {
    return new MiddlewareSpecErrorsServicePort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * ResponseForwarding holds configuration for the forward of the response.
 *
 * @schema MiddlewareSpecErrorsServiceResponseForwarding
 */
export interface MiddlewareSpecErrorsServiceResponseForwarding {
  /**
   * @schema MiddlewareSpecErrorsServiceResponseForwarding#flushInterval
   */
  readonly flushInterval?: string;

}

/**
 * Converts an object of type 'MiddlewareSpecErrorsServiceResponseForwarding' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MiddlewareSpecErrorsServiceResponseForwarding(obj: MiddlewareSpecErrorsServiceResponseForwarding | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'flushInterval': obj.flushInterval,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Sticky holds the sticky configuration.
 *
 * @schema MiddlewareSpecErrorsServiceSticky
 */
export interface MiddlewareSpecErrorsServiceSticky {
  /**
   * Cookie holds the sticky configuration based on cookie.
   *
   * @schema MiddlewareSpecErrorsServiceSticky#cookie
   */
  readonly cookie?: MiddlewareSpecErrorsServiceStickyCookie;

}

/**
 * Converts an object of type 'MiddlewareSpecErrorsServiceSticky' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MiddlewareSpecErrorsServiceSticky(obj: MiddlewareSpecErrorsServiceSticky | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cookie': toJson_MiddlewareSpecErrorsServiceStickyCookie(obj.cookie),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IPStrategy holds the ip strategy configuration.
 *
 * @schema MiddlewareSpecInFlightReqSourceCriterionIpStrategy
 */
export interface MiddlewareSpecInFlightReqSourceCriterionIpStrategy {
  /**
   * @schema MiddlewareSpecInFlightReqSourceCriterionIpStrategy#depth
   */
  readonly depth?: number;

  /**
   * @schema MiddlewareSpecInFlightReqSourceCriterionIpStrategy#excludedIPs
   */
  readonly excludedIPs?: string[];

}

/**
 * Converts an object of type 'MiddlewareSpecInFlightReqSourceCriterionIpStrategy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MiddlewareSpecInFlightReqSourceCriterionIpStrategy(obj: MiddlewareSpecInFlightReqSourceCriterionIpStrategy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'depth': obj.depth,
    'excludedIPs': obj.excludedIPs?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLSClientCertificateIssuerDNInfo holds the client TLS certificate distinguished name info configuration. cf https://tools.ietf.org/html/rfc3739
 *
 * @schema MiddlewareSpecPassTlsClientCertInfoIssuer
 */
export interface MiddlewareSpecPassTlsClientCertInfoIssuer {
  /**
   * @schema MiddlewareSpecPassTlsClientCertInfoIssuer#commonName
   */
  readonly commonName?: boolean;

  /**
   * @schema MiddlewareSpecPassTlsClientCertInfoIssuer#country
   */
  readonly country?: boolean;

  /**
   * @schema MiddlewareSpecPassTlsClientCertInfoIssuer#domainComponent
   */
  readonly domainComponent?: boolean;

  /**
   * @schema MiddlewareSpecPassTlsClientCertInfoIssuer#locality
   */
  readonly locality?: boolean;

  /**
   * @schema MiddlewareSpecPassTlsClientCertInfoIssuer#organization
   */
  readonly organization?: boolean;

  /**
   * @schema MiddlewareSpecPassTlsClientCertInfoIssuer#province
   */
  readonly province?: boolean;

  /**
   * @schema MiddlewareSpecPassTlsClientCertInfoIssuer#serialNumber
   */
  readonly serialNumber?: boolean;

}

/**
 * Converts an object of type 'MiddlewareSpecPassTlsClientCertInfoIssuer' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MiddlewareSpecPassTlsClientCertInfoIssuer(obj: MiddlewareSpecPassTlsClientCertInfoIssuer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'commonName': obj.commonName,
    'country': obj.country,
    'domainComponent': obj.domainComponent,
    'locality': obj.locality,
    'organization': obj.organization,
    'province': obj.province,
    'serialNumber': obj.serialNumber,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLSClientCertificateSubjectDNInfo holds the client TLS certificate distinguished name info configuration. cf https://tools.ietf.org/html/rfc3739
 *
 * @schema MiddlewareSpecPassTlsClientCertInfoSubject
 */
export interface MiddlewareSpecPassTlsClientCertInfoSubject {
  /**
   * @schema MiddlewareSpecPassTlsClientCertInfoSubject#commonName
   */
  readonly commonName?: boolean;

  /**
   * @schema MiddlewareSpecPassTlsClientCertInfoSubject#country
   */
  readonly country?: boolean;

  /**
   * @schema MiddlewareSpecPassTlsClientCertInfoSubject#domainComponent
   */
  readonly domainComponent?: boolean;

  /**
   * @schema MiddlewareSpecPassTlsClientCertInfoSubject#locality
   */
  readonly locality?: boolean;

  /**
   * @schema MiddlewareSpecPassTlsClientCertInfoSubject#organization
   */
  readonly organization?: boolean;

  /**
   * @schema MiddlewareSpecPassTlsClientCertInfoSubject#organizationalUnit
   */
  readonly organizationalUnit?: boolean;

  /**
   * @schema MiddlewareSpecPassTlsClientCertInfoSubject#province
   */
  readonly province?: boolean;

  /**
   * @schema MiddlewareSpecPassTlsClientCertInfoSubject#serialNumber
   */
  readonly serialNumber?: boolean;

}

/**
 * Converts an object of type 'MiddlewareSpecPassTlsClientCertInfoSubject' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MiddlewareSpecPassTlsClientCertInfoSubject(obj: MiddlewareSpecPassTlsClientCertInfoSubject | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'commonName': obj.commonName,
    'country': obj.country,
    'domainComponent': obj.domainComponent,
    'locality': obj.locality,
    'organization': obj.organization,
    'organizationalUnit': obj.organizationalUnit,
    'province': obj.province,
    'serialNumber': obj.serialNumber,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IPStrategy holds the ip strategy configuration.
 *
 * @schema MiddlewareSpecRateLimitSourceCriterionIpStrategy
 */
export interface MiddlewareSpecRateLimitSourceCriterionIpStrategy {
  /**
   * @schema MiddlewareSpecRateLimitSourceCriterionIpStrategy#depth
   */
  readonly depth?: number;

  /**
   * @schema MiddlewareSpecRateLimitSourceCriterionIpStrategy#excludedIPs
   */
  readonly excludedIPs?: string[];

}

/**
 * Converts an object of type 'MiddlewareSpecRateLimitSourceCriterionIpStrategy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MiddlewareSpecRateLimitSourceCriterionIpStrategy(obj: MiddlewareSpecRateLimitSourceCriterionIpStrategy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'depth': obj.depth,
    'excludedIPs': obj.excludedIPs?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Cookie holds the sticky configuration based on cookie.
 *
 * @schema MiddlewareSpecErrorsServiceStickyCookie
 */
export interface MiddlewareSpecErrorsServiceStickyCookie {
  /**
   * @schema MiddlewareSpecErrorsServiceStickyCookie#httpOnly
   */
  readonly httpOnly?: boolean;

  /**
   * @schema MiddlewareSpecErrorsServiceStickyCookie#name
   */
  readonly name?: string;

  /**
   * @schema MiddlewareSpecErrorsServiceStickyCookie#sameSite
   */
  readonly sameSite?: string;

  /**
   * @schema MiddlewareSpecErrorsServiceStickyCookie#secure
   */
  readonly secure?: boolean;

}

/**
 * Converts an object of type 'MiddlewareSpecErrorsServiceStickyCookie' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MiddlewareSpecErrorsServiceStickyCookie(obj: MiddlewareSpecErrorsServiceStickyCookie | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpOnly': obj.httpOnly,
    'name': obj.name,
    'sameSite': obj.sameSite,
    'secure': obj.secure,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * MiddlewareTCP is a specification for a MiddlewareTCP resource.
 *
 * @schema MiddlewareTCP
 */
export class MiddlewareTcp extends ApiObject {
  /**
   * Returns the apiVersion and kind for "MiddlewareTCP"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'traefik.containo.us/v1alpha1',
    kind: 'MiddlewareTCP',
  }

  /**
   * Renders a Kubernetes manifest for "MiddlewareTCP".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: MiddlewareTcpProps): any {
    return {
      ...MiddlewareTcp.GVK,
      ...toJson_MiddlewareTcpProps(props),
    };
  }

  /**
   * Defines a "MiddlewareTCP" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: MiddlewareTcpProps) {
    super(scope, id, {
      ...MiddlewareTcp.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...MiddlewareTcp.GVK,
      ...toJson_MiddlewareTcpProps(resolved),
    };
  }
}

/**
 * MiddlewareTCP is a specification for a MiddlewareTCP resource.
 *
 * @schema MiddlewareTCP
 */
export interface MiddlewareTcpProps {
  /**
   * @schema MiddlewareTCP#metadata
   */
  readonly metadata: ApiObjectMetadata;

  /**
   * MiddlewareTCPSpec holds the MiddlewareTCP configuration.
   *
   * @schema MiddlewareTCP#spec
   */
  readonly spec: MiddlewareTcpSpec;

}

/**
 * Converts an object of type 'MiddlewareTcpProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MiddlewareTcpProps(obj: MiddlewareTcpProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_MiddlewareTcpSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * MiddlewareTCPSpec holds the MiddlewareTCP configuration.
 *
 * @schema MiddlewareTcpSpec
 */
export interface MiddlewareTcpSpec {
  /**
   * TCPInFlightConn holds the TCP in flight connection configuration.
   *
   * @schema MiddlewareTcpSpec#inFlightConn
   */
  readonly inFlightConn?: MiddlewareTcpSpecInFlightConn;

  /**
   * TCPIPWhiteList holds the TCP ip white list configuration.
   *
   * @schema MiddlewareTcpSpec#ipWhiteList
   */
  readonly ipWhiteList?: MiddlewareTcpSpecIpWhiteList;

}

/**
 * Converts an object of type 'MiddlewareTcpSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MiddlewareTcpSpec(obj: MiddlewareTcpSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'inFlightConn': toJson_MiddlewareTcpSpecInFlightConn(obj.inFlightConn),
    'ipWhiteList': toJson_MiddlewareTcpSpecIpWhiteList(obj.ipWhiteList),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPInFlightConn holds the TCP in flight connection configuration.
 *
 * @schema MiddlewareTcpSpecInFlightConn
 */
export interface MiddlewareTcpSpecInFlightConn {
  /**
   * @schema MiddlewareTcpSpecInFlightConn#amount
   */
  readonly amount?: number;

}

/**
 * Converts an object of type 'MiddlewareTcpSpecInFlightConn' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MiddlewareTcpSpecInFlightConn(obj: MiddlewareTcpSpecInFlightConn | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'amount': obj.amount,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPIPWhiteList holds the TCP ip white list configuration.
 *
 * @schema MiddlewareTcpSpecIpWhiteList
 */
export interface MiddlewareTcpSpecIpWhiteList {
  /**
   * @schema MiddlewareTcpSpecIpWhiteList#sourceRange
   */
  readonly sourceRange?: string[];

}

/**
 * Converts an object of type 'MiddlewareTcpSpecIpWhiteList' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MiddlewareTcpSpecIpWhiteList(obj: MiddlewareTcpSpecIpWhiteList | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'sourceRange': obj.sourceRange?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * ServersTransport is a specification for a ServersTransport resource.
 *
 * @schema ServersTransport
 */
export class ServersTransport extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ServersTransport"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'traefik.containo.us/v1alpha1',
    kind: 'ServersTransport',
  }

  /**
   * Renders a Kubernetes manifest for "ServersTransport".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ServersTransportProps): any {
    return {
      ...ServersTransport.GVK,
      ...toJson_ServersTransportProps(props),
    };
  }

  /**
   * Defines a "ServersTransport" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ServersTransportProps) {
    super(scope, id, {
      ...ServersTransport.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ServersTransport.GVK,
      ...toJson_ServersTransportProps(resolved),
    };
  }
}

/**
 * ServersTransport is a specification for a ServersTransport resource.
 *
 * @schema ServersTransport
 */
export interface ServersTransportProps {
  /**
   * @schema ServersTransport#metadata
   */
  readonly metadata: ApiObjectMetadata;

  /**
   * ServersTransportSpec options to configure communication between Traefik and the servers.
   *
   * @schema ServersTransport#spec
   */
  readonly spec: ServersTransportSpec;

}

/**
 * Converts an object of type 'ServersTransportProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServersTransportProps(obj: ServersTransportProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ServersTransportSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ServersTransportSpec options to configure communication between Traefik and the servers.
 *
 * @schema ServersTransportSpec
 */
export interface ServersTransportSpec {
  /**
   * Certificates for mTLS.
   *
   * @schema ServersTransportSpec#certificatesSecrets
   */
  readonly certificatesSecrets?: string[];

  /**
   * Disable HTTP/2 for connections with backend servers.
   *
   * @schema ServersTransportSpec#disableHTTP2
   */
  readonly disableHttp2?: boolean;

  /**
   * Timeouts for requests forwarded to the backend servers.
   *
   * @schema ServersTransportSpec#forwardingTimeouts
   */
  readonly forwardingTimeouts?: ServersTransportSpecForwardingTimeouts;

  /**
   * Disable SSL certificate verification.
   *
   * @schema ServersTransportSpec#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * If non-zero, controls the maximum idle (keep-alive) to keep per-host. If zero, DefaultMaxIdleConnsPerHost is used.
   *
   * @schema ServersTransportSpec#maxIdleConnsPerHost
   */
  readonly maxIdleConnsPerHost?: number;

  /**
   * URI used to match against SAN URI during the peer certificate verification.
   *
   * @schema ServersTransportSpec#peerCertURI
   */
  readonly peerCertUri?: string;

  /**
   * Add cert file for self-signed certificate.
   *
   * @schema ServersTransportSpec#rootCAsSecrets
   */
  readonly rootCAsSecrets?: string[];

  /**
   * ServerName used to contact the server.
   *
   * @schema ServersTransportSpec#serverName
   */
  readonly serverName?: string;

}

/**
 * Converts an object of type 'ServersTransportSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServersTransportSpec(obj: ServersTransportSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificatesSecrets': obj.certificatesSecrets?.map(y => y),
    'disableHTTP2': obj.disableHttp2,
    'forwardingTimeouts': toJson_ServersTransportSpecForwardingTimeouts(obj.forwardingTimeouts),
    'insecureSkipVerify': obj.insecureSkipVerify,
    'maxIdleConnsPerHost': obj.maxIdleConnsPerHost,
    'peerCertURI': obj.peerCertUri,
    'rootCAsSecrets': obj.rootCAsSecrets?.map(y => y),
    'serverName': obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Timeouts for requests forwarded to the backend servers.
 *
 * @schema ServersTransportSpecForwardingTimeouts
 */
export interface ServersTransportSpecForwardingTimeouts {
  /**
   * DialTimeout is the amount of time to wait until a connection to a backend server can be established. If zero, no timeout exists.
   *
   * @schema ServersTransportSpecForwardingTimeouts#dialTimeout
   */
  readonly dialTimeout?: ServersTransportSpecForwardingTimeoutsDialTimeout;

  /**
   * IdleConnTimeout is the maximum period for which an idle HTTP keep-alive connection will remain open before closing itself.
   *
   * @schema ServersTransportSpecForwardingTimeouts#idleConnTimeout
   */
  readonly idleConnTimeout?: ServersTransportSpecForwardingTimeoutsIdleConnTimeout;

  /**
   * PingTimeout is the timeout after which the HTTP/2 connection will be closed if a response to ping is not received.
   *
   * @schema ServersTransportSpecForwardingTimeouts#pingTimeout
   */
  readonly pingTimeout?: ServersTransportSpecForwardingTimeoutsPingTimeout;

  /**
   * ReadIdleTimeout is the timeout after which a health check using ping frame will be carried out if no frame is received on the HTTP/2 connection. If zero, no health check is performed.
   *
   * @schema ServersTransportSpecForwardingTimeouts#readIdleTimeout
   */
  readonly readIdleTimeout?: ServersTransportSpecForwardingTimeoutsReadIdleTimeout;

  /**
   * ResponseHeaderTimeout is the amount of time to wait for a server's response headers after fully writing the request (including its body, if any). If zero, no timeout exists.
   *
   * @schema ServersTransportSpecForwardingTimeouts#responseHeaderTimeout
   */
  readonly responseHeaderTimeout?: ServersTransportSpecForwardingTimeoutsResponseHeaderTimeout;

}

/**
 * Converts an object of type 'ServersTransportSpecForwardingTimeouts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServersTransportSpecForwardingTimeouts(obj: ServersTransportSpecForwardingTimeouts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dialTimeout': obj.dialTimeout?.value,
    'idleConnTimeout': obj.idleConnTimeout?.value,
    'pingTimeout': obj.pingTimeout?.value,
    'readIdleTimeout': obj.readIdleTimeout?.value,
    'responseHeaderTimeout': obj.responseHeaderTimeout?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DialTimeout is the amount of time to wait until a connection to a backend server can be established. If zero, no timeout exists.
 *
 * @schema ServersTransportSpecForwardingTimeoutsDialTimeout
 */
export class ServersTransportSpecForwardingTimeoutsDialTimeout {
  public static fromNumber(value: number): ServersTransportSpecForwardingTimeoutsDialTimeout {
    return new ServersTransportSpecForwardingTimeoutsDialTimeout(value);
  }
  public static fromString(value: string): ServersTransportSpecForwardingTimeoutsDialTimeout {
    return new ServersTransportSpecForwardingTimeoutsDialTimeout(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * IdleConnTimeout is the maximum period for which an idle HTTP keep-alive connection will remain open before closing itself.
 *
 * @schema ServersTransportSpecForwardingTimeoutsIdleConnTimeout
 */
export class ServersTransportSpecForwardingTimeoutsIdleConnTimeout {
  public static fromNumber(value: number): ServersTransportSpecForwardingTimeoutsIdleConnTimeout {
    return new ServersTransportSpecForwardingTimeoutsIdleConnTimeout(value);
  }
  public static fromString(value: string): ServersTransportSpecForwardingTimeoutsIdleConnTimeout {
    return new ServersTransportSpecForwardingTimeoutsIdleConnTimeout(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * PingTimeout is the timeout after which the HTTP/2 connection will be closed if a response to ping is not received.
 *
 * @schema ServersTransportSpecForwardingTimeoutsPingTimeout
 */
export class ServersTransportSpecForwardingTimeoutsPingTimeout {
  public static fromNumber(value: number): ServersTransportSpecForwardingTimeoutsPingTimeout {
    return new ServersTransportSpecForwardingTimeoutsPingTimeout(value);
  }
  public static fromString(value: string): ServersTransportSpecForwardingTimeoutsPingTimeout {
    return new ServersTransportSpecForwardingTimeoutsPingTimeout(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * ReadIdleTimeout is the timeout after which a health check using ping frame will be carried out if no frame is received on the HTTP/2 connection. If zero, no health check is performed.
 *
 * @schema ServersTransportSpecForwardingTimeoutsReadIdleTimeout
 */
export class ServersTransportSpecForwardingTimeoutsReadIdleTimeout {
  public static fromNumber(value: number): ServersTransportSpecForwardingTimeoutsReadIdleTimeout {
    return new ServersTransportSpecForwardingTimeoutsReadIdleTimeout(value);
  }
  public static fromString(value: string): ServersTransportSpecForwardingTimeoutsReadIdleTimeout {
    return new ServersTransportSpecForwardingTimeoutsReadIdleTimeout(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * ResponseHeaderTimeout is the amount of time to wait for a server's response headers after fully writing the request (including its body, if any). If zero, no timeout exists.
 *
 * @schema ServersTransportSpecForwardingTimeoutsResponseHeaderTimeout
 */
export class ServersTransportSpecForwardingTimeoutsResponseHeaderTimeout {
  public static fromNumber(value: number): ServersTransportSpecForwardingTimeoutsResponseHeaderTimeout {
    return new ServersTransportSpecForwardingTimeoutsResponseHeaderTimeout(value);
  }
  public static fromString(value: string): ServersTransportSpecForwardingTimeoutsResponseHeaderTimeout {
    return new ServersTransportSpecForwardingTimeoutsResponseHeaderTimeout(value);
  }
  private constructor(public readonly value: any) {
  }
}


/**
 * TLSOption is a specification for a TLSOption resource.
 *
 * @schema TLSOption
 */
export class TlsOption extends ApiObject {
  /**
   * Returns the apiVersion and kind for "TLSOption"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'traefik.containo.us/v1alpha1',
    kind: 'TLSOption',
  }

  /**
   * Renders a Kubernetes manifest for "TLSOption".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: TlsOptionProps): any {
    return {
      ...TlsOption.GVK,
      ...toJson_TlsOptionProps(props),
    };
  }

  /**
   * Defines a "TLSOption" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: TlsOptionProps) {
    super(scope, id, {
      ...TlsOption.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...TlsOption.GVK,
      ...toJson_TlsOptionProps(resolved),
    };
  }
}

/**
 * TLSOption is a specification for a TLSOption resource.
 *
 * @schema TLSOption
 */
export interface TlsOptionProps {
  /**
   * @schema TLSOption#metadata
   */
  readonly metadata: ApiObjectMetadata;

  /**
   * TLSOptionSpec configures TLS for an entry point.
   *
   * @schema TLSOption#spec
   */
  readonly spec: TlsOptionSpec;

}

/**
 * Converts an object of type 'TlsOptionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TlsOptionProps(obj: TlsOptionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_TlsOptionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLSOptionSpec configures TLS for an entry point.
 *
 * @schema TlsOptionSpec
 */
export interface TlsOptionSpec {
  /**
   * @schema TlsOptionSpec#alpnProtocols
   */
  readonly alpnProtocols?: string[];

  /**
   * @schema TlsOptionSpec#cipherSuites
   */
  readonly cipherSuites?: string[];

  /**
   * ClientAuth defines the parameters of the client authentication part of the TLS connection, if any.
   *
   * @schema TlsOptionSpec#clientAuth
   */
  readonly clientAuth?: TlsOptionSpecClientAuth;

  /**
   * @schema TlsOptionSpec#curvePreferences
   */
  readonly curvePreferences?: string[];

  /**
   * @schema TlsOptionSpec#maxVersion
   */
  readonly maxVersion?: string;

  /**
   * @schema TlsOptionSpec#minVersion
   */
  readonly minVersion?: string;

  /**
   * @schema TlsOptionSpec#preferServerCipherSuites
   */
  readonly preferServerCipherSuites?: boolean;

  /**
   * @schema TlsOptionSpec#sniStrict
   */
  readonly sniStrict?: boolean;

}

/**
 * Converts an object of type 'TlsOptionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TlsOptionSpec(obj: TlsOptionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alpnProtocols': obj.alpnProtocols?.map(y => y),
    'cipherSuites': obj.cipherSuites?.map(y => y),
    'clientAuth': toJson_TlsOptionSpecClientAuth(obj.clientAuth),
    'curvePreferences': obj.curvePreferences?.map(y => y),
    'maxVersion': obj.maxVersion,
    'minVersion': obj.minVersion,
    'preferServerCipherSuites': obj.preferServerCipherSuites,
    'sniStrict': obj.sniStrict,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ClientAuth defines the parameters of the client authentication part of the TLS connection, if any.
 *
 * @schema TlsOptionSpecClientAuth
 */
export interface TlsOptionSpecClientAuth {
  /**
   * ClientAuthType defines the client authentication type to apply.
   *
   * @schema TlsOptionSpecClientAuth#clientAuthType
   */
  readonly clientAuthType?: TlsOptionSpecClientAuthClientAuthType;

  /**
   * SecretName is the name of the referenced Kubernetes Secret to specify the certificate details.
   *
   * @schema TlsOptionSpecClientAuth#secretNames
   */
  readonly secretNames?: string[];

}

/**
 * Converts an object of type 'TlsOptionSpecClientAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TlsOptionSpecClientAuth(obj: TlsOptionSpecClientAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientAuthType': obj.clientAuthType,
    'secretNames': obj.secretNames?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ClientAuthType defines the client authentication type to apply.
 *
 * @schema TlsOptionSpecClientAuthClientAuthType
 */
export enum TlsOptionSpecClientAuthClientAuthType {
  /** NoClientCert */
  NO_CLIENT_CERT = 'NoClientCert',
  /** RequestClientCert */
  REQUEST_CLIENT_CERT = 'RequestClientCert',
  /** RequireAnyClientCert */
  REQUIRE_ANY_CLIENT_CERT = 'RequireAnyClientCert',
  /** VerifyClientCertIfGiven */
  VERIFY_CLIENT_CERT_IF_GIVEN = 'VerifyClientCertIfGiven',
  /** RequireAndVerifyClientCert */
  REQUIRE_AND_VERIFY_CLIENT_CERT = 'RequireAndVerifyClientCert',
}


/**
 * TLSStore is a specification for a TLSStore resource.
 *
 * @schema TLSStore
 */
export class TlsStore extends ApiObject {
  /**
   * Returns the apiVersion and kind for "TLSStore"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'traefik.containo.us/v1alpha1',
    kind: 'TLSStore',
  }

  /**
   * Renders a Kubernetes manifest for "TLSStore".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: TlsStoreProps): any {
    return {
      ...TlsStore.GVK,
      ...toJson_TlsStoreProps(props),
    };
  }

  /**
   * Defines a "TLSStore" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: TlsStoreProps) {
    super(scope, id, {
      ...TlsStore.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...TlsStore.GVK,
      ...toJson_TlsStoreProps(resolved),
    };
  }
}

/**
 * TLSStore is a specification for a TLSStore resource.
 *
 * @schema TLSStore
 */
export interface TlsStoreProps {
  /**
   * @schema TLSStore#metadata
   */
  readonly metadata: ApiObjectMetadata;

  /**
   * TLSStoreSpec configures a TLSStore resource.
   *
   * @schema TLSStore#spec
   */
  readonly spec: TlsStoreSpec;

}

/**
 * Converts an object of type 'TlsStoreProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TlsStoreProps(obj: TlsStoreProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_TlsStoreSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLSStoreSpec configures a TLSStore resource.
 *
 * @schema TlsStoreSpec
 */
export interface TlsStoreSpec {
  /**
   * DefaultCertificate holds a secret name for the TLSOption resource.
   *
   * @schema TlsStoreSpec#defaultCertificate
   */
  readonly defaultCertificate: TlsStoreSpecDefaultCertificate;

}

/**
 * Converts an object of type 'TlsStoreSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TlsStoreSpec(obj: TlsStoreSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultCertificate': toJson_TlsStoreSpecDefaultCertificate(obj.defaultCertificate),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DefaultCertificate holds a secret name for the TLSOption resource.
 *
 * @schema TlsStoreSpecDefaultCertificate
 */
export interface TlsStoreSpecDefaultCertificate {
  /**
   * SecretName is the name of the referenced Kubernetes Secret to specify the certificate details.
   *
   * @schema TlsStoreSpecDefaultCertificate#secretName
   */
  readonly secretName: string;

}

/**
 * Converts an object of type 'TlsStoreSpecDefaultCertificate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TlsStoreSpecDefaultCertificate(obj: TlsStoreSpecDefaultCertificate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * TraefikService is the specification for a service (that an IngressRoute refers to) that is usually not a terminal service (i.e. not a pod of servers), as opposed to a Kubernetes Service. That is to say, it usually refers to other (children) services, which themselves can be TraefikServices or Services.
 *
 * @schema TraefikService
 */
export class TraefikService extends ApiObject {
  /**
   * Returns the apiVersion and kind for "TraefikService"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'traefik.containo.us/v1alpha1',
    kind: 'TraefikService',
  }

  /**
   * Renders a Kubernetes manifest for "TraefikService".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: TraefikServiceProps): any {
    return {
      ...TraefikService.GVK,
      ...toJson_TraefikServiceProps(props),
    };
  }

  /**
   * Defines a "TraefikService" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: TraefikServiceProps) {
    super(scope, id, {
      ...TraefikService.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...TraefikService.GVK,
      ...toJson_TraefikServiceProps(resolved),
    };
  }
}

/**
 * TraefikService is the specification for a service (that an IngressRoute refers to) that is usually not a terminal service (i.e. not a pod of servers), as opposed to a Kubernetes Service. That is to say, it usually refers to other (children) services, which themselves can be TraefikServices or Services.
 *
 * @schema TraefikService
 */
export interface TraefikServiceProps {
  /**
   * @schema TraefikService#metadata
   */
  readonly metadata: ApiObjectMetadata;

  /**
   * ServiceSpec defines whether a TraefikService is a load-balancer of services or a mirroring service.
   *
   * @schema TraefikService#spec
   */
  readonly spec: TraefikServiceSpec;

}

/**
 * Converts an object of type 'TraefikServiceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TraefikServiceProps(obj: TraefikServiceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_TraefikServiceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ServiceSpec defines whether a TraefikService is a load-balancer of services or a mirroring service.
 *
 * @schema TraefikServiceSpec
 */
export interface TraefikServiceSpec {
  /**
   * Mirroring defines a mirroring service, which is composed of a main load-balancer, and a list of mirrors.
   *
   * @schema TraefikServiceSpec#mirroring
   */
  readonly mirroring?: TraefikServiceSpecMirroring;

  /**
   * WeightedRoundRobin defines a load-balancer of services.
   *
   * @schema TraefikServiceSpec#weighted
   */
  readonly weighted?: TraefikServiceSpecWeighted;

}

/**
 * Converts an object of type 'TraefikServiceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TraefikServiceSpec(obj: TraefikServiceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mirroring': toJson_TraefikServiceSpecMirroring(obj.mirroring),
    'weighted': toJson_TraefikServiceSpecWeighted(obj.weighted),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Mirroring defines a mirroring service, which is composed of a main load-balancer, and a list of mirrors.
 *
 * @schema TraefikServiceSpecMirroring
 */
export interface TraefikServiceSpecMirroring {
  /**
   * @schema TraefikServiceSpecMirroring#kind
   */
  readonly kind?: TraefikServiceSpecMirroringKind;

  /**
   * @schema TraefikServiceSpecMirroring#maxBodySize
   */
  readonly maxBodySize?: number;

  /**
   * @schema TraefikServiceSpecMirroring#mirrors
   */
  readonly mirrors?: TraefikServiceSpecMirroringMirrors[];

  /**
   * Name is a reference to a Kubernetes Service object (for a load-balancer of servers), or to a TraefikService object (service load-balancer, mirroring, etc). The differentiation between the two is specified in the Kind field.
   *
   * @schema TraefikServiceSpecMirroring#name
   */
  readonly name: string;

  /**
   * @schema TraefikServiceSpecMirroring#namespace
   */
  readonly namespace?: string;

  /**
   * @schema TraefikServiceSpecMirroring#passHostHeader
   */
  readonly passHostHeader?: boolean;

  /**
   * @schema TraefikServiceSpecMirroring#port
   */
  readonly port?: TraefikServiceSpecMirroringPort;

  /**
   * ResponseForwarding holds configuration for the forward of the response.
   *
   * @schema TraefikServiceSpecMirroring#responseForwarding
   */
  readonly responseForwarding?: TraefikServiceSpecMirroringResponseForwarding;

  /**
   * @schema TraefikServiceSpecMirroring#scheme
   */
  readonly scheme?: string;

  /**
   * @schema TraefikServiceSpecMirroring#serversTransport
   */
  readonly serversTransport?: string;

  /**
   * Sticky holds the sticky configuration.
   *
   * @schema TraefikServiceSpecMirroring#sticky
   */
  readonly sticky?: TraefikServiceSpecMirroringSticky;

  /**
   * @schema TraefikServiceSpecMirroring#strategy
   */
  readonly strategy?: string;

  /**
   * Weight should only be specified when Name references a TraefikService object (and to be precise, one that embeds a Weighted Round Robin).
   *
   * @schema TraefikServiceSpecMirroring#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'TraefikServiceSpecMirroring' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TraefikServiceSpecMirroring(obj: TraefikServiceSpecMirroring | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kind': obj.kind,
    'maxBodySize': obj.maxBodySize,
    'mirrors': obj.mirrors?.map(y => toJson_TraefikServiceSpecMirroringMirrors(y)),
    'name': obj.name,
    'namespace': obj.namespace,
    'passHostHeader': obj.passHostHeader,
    'port': obj.port?.value,
    'responseForwarding': toJson_TraefikServiceSpecMirroringResponseForwarding(obj.responseForwarding),
    'scheme': obj.scheme,
    'serversTransport': obj.serversTransport,
    'sticky': toJson_TraefikServiceSpecMirroringSticky(obj.sticky),
    'strategy': obj.strategy,
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WeightedRoundRobin defines a load-balancer of services.
 *
 * @schema TraefikServiceSpecWeighted
 */
export interface TraefikServiceSpecWeighted {
  /**
   * @schema TraefikServiceSpecWeighted#services
   */
  readonly services?: TraefikServiceSpecWeightedServices[];

  /**
   * Sticky holds the sticky configuration.
   *
   * @schema TraefikServiceSpecWeighted#sticky
   */
  readonly sticky?: TraefikServiceSpecWeightedSticky;

}

/**
 * Converts an object of type 'TraefikServiceSpecWeighted' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TraefikServiceSpecWeighted(obj: TraefikServiceSpecWeighted | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'services': obj.services?.map(y => toJson_TraefikServiceSpecWeightedServices(y)),
    'sticky': toJson_TraefikServiceSpecWeightedSticky(obj.sticky),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TraefikServiceSpecMirroringKind
 */
export enum TraefikServiceSpecMirroringKind {
  /** Service */
  SERVICE = 'Service',
  /** TraefikService */
  TRAEFIK_SERVICE = 'TraefikService',
}

/**
 * MirrorService defines one of the mirrors of a Mirroring service.
 *
 * @schema TraefikServiceSpecMirroringMirrors
 */
export interface TraefikServiceSpecMirroringMirrors {
  /**
   * @schema TraefikServiceSpecMirroringMirrors#kind
   */
  readonly kind?: TraefikServiceSpecMirroringMirrorsKind;

  /**
   * Name is a reference to a Kubernetes Service object (for a load-balancer of servers), or to a TraefikService object (service load-balancer, mirroring, etc). The differentiation between the two is specified in the Kind field.
   *
   * @schema TraefikServiceSpecMirroringMirrors#name
   */
  readonly name: string;

  /**
   * @schema TraefikServiceSpecMirroringMirrors#namespace
   */
  readonly namespace?: string;

  /**
   * @schema TraefikServiceSpecMirroringMirrors#passHostHeader
   */
  readonly passHostHeader?: boolean;

  /**
   * @schema TraefikServiceSpecMirroringMirrors#percent
   */
  readonly percent?: number;

  /**
   * @schema TraefikServiceSpecMirroringMirrors#port
   */
  readonly port?: TraefikServiceSpecMirroringMirrorsPort;

  /**
   * ResponseForwarding holds configuration for the forward of the response.
   *
   * @schema TraefikServiceSpecMirroringMirrors#responseForwarding
   */
  readonly responseForwarding?: TraefikServiceSpecMirroringMirrorsResponseForwarding;

  /**
   * @schema TraefikServiceSpecMirroringMirrors#scheme
   */
  readonly scheme?: string;

  /**
   * @schema TraefikServiceSpecMirroringMirrors#serversTransport
   */
  readonly serversTransport?: string;

  /**
   * Sticky holds the sticky configuration.
   *
   * @schema TraefikServiceSpecMirroringMirrors#sticky
   */
  readonly sticky?: TraefikServiceSpecMirroringMirrorsSticky;

  /**
   * @schema TraefikServiceSpecMirroringMirrors#strategy
   */
  readonly strategy?: string;

  /**
   * Weight should only be specified when Name references a TraefikService object (and to be precise, one that embeds a Weighted Round Robin).
   *
   * @schema TraefikServiceSpecMirroringMirrors#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'TraefikServiceSpecMirroringMirrors' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TraefikServiceSpecMirroringMirrors(obj: TraefikServiceSpecMirroringMirrors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
    'passHostHeader': obj.passHostHeader,
    'percent': obj.percent,
    'port': obj.port?.value,
    'responseForwarding': toJson_TraefikServiceSpecMirroringMirrorsResponseForwarding(obj.responseForwarding),
    'scheme': obj.scheme,
    'serversTransport': obj.serversTransport,
    'sticky': toJson_TraefikServiceSpecMirroringMirrorsSticky(obj.sticky),
    'strategy': obj.strategy,
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TraefikServiceSpecMirroringPort
 */
export class TraefikServiceSpecMirroringPort {
  public static fromNumber(value: number): TraefikServiceSpecMirroringPort {
    return new TraefikServiceSpecMirroringPort(value);
  }
  public static fromString(value: string): TraefikServiceSpecMirroringPort {
    return new TraefikServiceSpecMirroringPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * ResponseForwarding holds configuration for the forward of the response.
 *
 * @schema TraefikServiceSpecMirroringResponseForwarding
 */
export interface TraefikServiceSpecMirroringResponseForwarding {
  /**
   * @schema TraefikServiceSpecMirroringResponseForwarding#flushInterval
   */
  readonly flushInterval?: string;

}

/**
 * Converts an object of type 'TraefikServiceSpecMirroringResponseForwarding' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TraefikServiceSpecMirroringResponseForwarding(obj: TraefikServiceSpecMirroringResponseForwarding | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'flushInterval': obj.flushInterval,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Sticky holds the sticky configuration.
 *
 * @schema TraefikServiceSpecMirroringSticky
 */
export interface TraefikServiceSpecMirroringSticky {
  /**
   * Cookie holds the sticky configuration based on cookie.
   *
   * @schema TraefikServiceSpecMirroringSticky#cookie
   */
  readonly cookie?: TraefikServiceSpecMirroringStickyCookie;

}

/**
 * Converts an object of type 'TraefikServiceSpecMirroringSticky' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TraefikServiceSpecMirroringSticky(obj: TraefikServiceSpecMirroringSticky | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cookie': toJson_TraefikServiceSpecMirroringStickyCookie(obj.cookie),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Service defines an upstream to proxy traffic.
 *
 * @schema TraefikServiceSpecWeightedServices
 */
export interface TraefikServiceSpecWeightedServices {
  /**
   * @schema TraefikServiceSpecWeightedServices#kind
   */
  readonly kind?: TraefikServiceSpecWeightedServicesKind;

  /**
   * Name is a reference to a Kubernetes Service object (for a load-balancer of servers), or to a TraefikService object (service load-balancer, mirroring, etc). The differentiation between the two is specified in the Kind field.
   *
   * @schema TraefikServiceSpecWeightedServices#name
   */
  readonly name: string;

  /**
   * @schema TraefikServiceSpecWeightedServices#namespace
   */
  readonly namespace?: string;

  /**
   * @schema TraefikServiceSpecWeightedServices#passHostHeader
   */
  readonly passHostHeader?: boolean;

  /**
   * @schema TraefikServiceSpecWeightedServices#port
   */
  readonly port?: TraefikServiceSpecWeightedServicesPort;

  /**
   * ResponseForwarding holds configuration for the forward of the response.
   *
   * @schema TraefikServiceSpecWeightedServices#responseForwarding
   */
  readonly responseForwarding?: TraefikServiceSpecWeightedServicesResponseForwarding;

  /**
   * @schema TraefikServiceSpecWeightedServices#scheme
   */
  readonly scheme?: string;

  /**
   * @schema TraefikServiceSpecWeightedServices#serversTransport
   */
  readonly serversTransport?: string;

  /**
   * Sticky holds the sticky configuration.
   *
   * @schema TraefikServiceSpecWeightedServices#sticky
   */
  readonly sticky?: TraefikServiceSpecWeightedServicesSticky;

  /**
   * @schema TraefikServiceSpecWeightedServices#strategy
   */
  readonly strategy?: string;

  /**
   * Weight should only be specified when Name references a TraefikService object (and to be precise, one that embeds a Weighted Round Robin).
   *
   * @schema TraefikServiceSpecWeightedServices#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'TraefikServiceSpecWeightedServices' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TraefikServiceSpecWeightedServices(obj: TraefikServiceSpecWeightedServices | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
    'passHostHeader': obj.passHostHeader,
    'port': obj.port?.value,
    'responseForwarding': toJson_TraefikServiceSpecWeightedServicesResponseForwarding(obj.responseForwarding),
    'scheme': obj.scheme,
    'serversTransport': obj.serversTransport,
    'sticky': toJson_TraefikServiceSpecWeightedServicesSticky(obj.sticky),
    'strategy': obj.strategy,
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Sticky holds the sticky configuration.
 *
 * @schema TraefikServiceSpecWeightedSticky
 */
export interface TraefikServiceSpecWeightedSticky {
  /**
   * Cookie holds the sticky configuration based on cookie.
   *
   * @schema TraefikServiceSpecWeightedSticky#cookie
   */
  readonly cookie?: TraefikServiceSpecWeightedStickyCookie;

}

/**
 * Converts an object of type 'TraefikServiceSpecWeightedSticky' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TraefikServiceSpecWeightedSticky(obj: TraefikServiceSpecWeightedSticky | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cookie': toJson_TraefikServiceSpecWeightedStickyCookie(obj.cookie),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TraefikServiceSpecMirroringMirrorsKind
 */
export enum TraefikServiceSpecMirroringMirrorsKind {
  /** Service */
  SERVICE = 'Service',
  /** TraefikService */
  TRAEFIK_SERVICE = 'TraefikService',
}

/**
 * @schema TraefikServiceSpecMirroringMirrorsPort
 */
export class TraefikServiceSpecMirroringMirrorsPort {
  public static fromNumber(value: number): TraefikServiceSpecMirroringMirrorsPort {
    return new TraefikServiceSpecMirroringMirrorsPort(value);
  }
  public static fromString(value: string): TraefikServiceSpecMirroringMirrorsPort {
    return new TraefikServiceSpecMirroringMirrorsPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * ResponseForwarding holds configuration for the forward of the response.
 *
 * @schema TraefikServiceSpecMirroringMirrorsResponseForwarding
 */
export interface TraefikServiceSpecMirroringMirrorsResponseForwarding {
  /**
   * @schema TraefikServiceSpecMirroringMirrorsResponseForwarding#flushInterval
   */
  readonly flushInterval?: string;

}

/**
 * Converts an object of type 'TraefikServiceSpecMirroringMirrorsResponseForwarding' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TraefikServiceSpecMirroringMirrorsResponseForwarding(obj: TraefikServiceSpecMirroringMirrorsResponseForwarding | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'flushInterval': obj.flushInterval,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Sticky holds the sticky configuration.
 *
 * @schema TraefikServiceSpecMirroringMirrorsSticky
 */
export interface TraefikServiceSpecMirroringMirrorsSticky {
  /**
   * Cookie holds the sticky configuration based on cookie.
   *
   * @schema TraefikServiceSpecMirroringMirrorsSticky#cookie
   */
  readonly cookie?: TraefikServiceSpecMirroringMirrorsStickyCookie;

}

/**
 * Converts an object of type 'TraefikServiceSpecMirroringMirrorsSticky' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TraefikServiceSpecMirroringMirrorsSticky(obj: TraefikServiceSpecMirroringMirrorsSticky | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cookie': toJson_TraefikServiceSpecMirroringMirrorsStickyCookie(obj.cookie),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Cookie holds the sticky configuration based on cookie.
 *
 * @schema TraefikServiceSpecMirroringStickyCookie
 */
export interface TraefikServiceSpecMirroringStickyCookie {
  /**
   * @schema TraefikServiceSpecMirroringStickyCookie#httpOnly
   */
  readonly httpOnly?: boolean;

  /**
   * @schema TraefikServiceSpecMirroringStickyCookie#name
   */
  readonly name?: string;

  /**
   * @schema TraefikServiceSpecMirroringStickyCookie#sameSite
   */
  readonly sameSite?: string;

  /**
   * @schema TraefikServiceSpecMirroringStickyCookie#secure
   */
  readonly secure?: boolean;

}

/**
 * Converts an object of type 'TraefikServiceSpecMirroringStickyCookie' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TraefikServiceSpecMirroringStickyCookie(obj: TraefikServiceSpecMirroringStickyCookie | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpOnly': obj.httpOnly,
    'name': obj.name,
    'sameSite': obj.sameSite,
    'secure': obj.secure,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TraefikServiceSpecWeightedServicesKind
 */
export enum TraefikServiceSpecWeightedServicesKind {
  /** Service */
  SERVICE = 'Service',
  /** TraefikService */
  TRAEFIK_SERVICE = 'TraefikService',
}

/**
 * @schema TraefikServiceSpecWeightedServicesPort
 */
export class TraefikServiceSpecWeightedServicesPort {
  public static fromNumber(value: number): TraefikServiceSpecWeightedServicesPort {
    return new TraefikServiceSpecWeightedServicesPort(value);
  }
  public static fromString(value: string): TraefikServiceSpecWeightedServicesPort {
    return new TraefikServiceSpecWeightedServicesPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * ResponseForwarding holds configuration for the forward of the response.
 *
 * @schema TraefikServiceSpecWeightedServicesResponseForwarding
 */
export interface TraefikServiceSpecWeightedServicesResponseForwarding {
  /**
   * @schema TraefikServiceSpecWeightedServicesResponseForwarding#flushInterval
   */
  readonly flushInterval?: string;

}

/**
 * Converts an object of type 'TraefikServiceSpecWeightedServicesResponseForwarding' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TraefikServiceSpecWeightedServicesResponseForwarding(obj: TraefikServiceSpecWeightedServicesResponseForwarding | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'flushInterval': obj.flushInterval,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Sticky holds the sticky configuration.
 *
 * @schema TraefikServiceSpecWeightedServicesSticky
 */
export interface TraefikServiceSpecWeightedServicesSticky {
  /**
   * Cookie holds the sticky configuration based on cookie.
   *
   * @schema TraefikServiceSpecWeightedServicesSticky#cookie
   */
  readonly cookie?: TraefikServiceSpecWeightedServicesStickyCookie;

}

/**
 * Converts an object of type 'TraefikServiceSpecWeightedServicesSticky' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TraefikServiceSpecWeightedServicesSticky(obj: TraefikServiceSpecWeightedServicesSticky | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cookie': toJson_TraefikServiceSpecWeightedServicesStickyCookie(obj.cookie),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Cookie holds the sticky configuration based on cookie.
 *
 * @schema TraefikServiceSpecWeightedStickyCookie
 */
export interface TraefikServiceSpecWeightedStickyCookie {
  /**
   * @schema TraefikServiceSpecWeightedStickyCookie#httpOnly
   */
  readonly httpOnly?: boolean;

  /**
   * @schema TraefikServiceSpecWeightedStickyCookie#name
   */
  readonly name?: string;

  /**
   * @schema TraefikServiceSpecWeightedStickyCookie#sameSite
   */
  readonly sameSite?: string;

  /**
   * @schema TraefikServiceSpecWeightedStickyCookie#secure
   */
  readonly secure?: boolean;

}

/**
 * Converts an object of type 'TraefikServiceSpecWeightedStickyCookie' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TraefikServiceSpecWeightedStickyCookie(obj: TraefikServiceSpecWeightedStickyCookie | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpOnly': obj.httpOnly,
    'name': obj.name,
    'sameSite': obj.sameSite,
    'secure': obj.secure,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Cookie holds the sticky configuration based on cookie.
 *
 * @schema TraefikServiceSpecMirroringMirrorsStickyCookie
 */
export interface TraefikServiceSpecMirroringMirrorsStickyCookie {
  /**
   * @schema TraefikServiceSpecMirroringMirrorsStickyCookie#httpOnly
   */
  readonly httpOnly?: boolean;

  /**
   * @schema TraefikServiceSpecMirroringMirrorsStickyCookie#name
   */
  readonly name?: string;

  /**
   * @schema TraefikServiceSpecMirroringMirrorsStickyCookie#sameSite
   */
  readonly sameSite?: string;

  /**
   * @schema TraefikServiceSpecMirroringMirrorsStickyCookie#secure
   */
  readonly secure?: boolean;

}

/**
 * Converts an object of type 'TraefikServiceSpecMirroringMirrorsStickyCookie' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TraefikServiceSpecMirroringMirrorsStickyCookie(obj: TraefikServiceSpecMirroringMirrorsStickyCookie | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpOnly': obj.httpOnly,
    'name': obj.name,
    'sameSite': obj.sameSite,
    'secure': obj.secure,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Cookie holds the sticky configuration based on cookie.
 *
 * @schema TraefikServiceSpecWeightedServicesStickyCookie
 */
export interface TraefikServiceSpecWeightedServicesStickyCookie {
  /**
   * @schema TraefikServiceSpecWeightedServicesStickyCookie#httpOnly
   */
  readonly httpOnly?: boolean;

  /**
   * @schema TraefikServiceSpecWeightedServicesStickyCookie#name
   */
  readonly name?: string;

  /**
   * @schema TraefikServiceSpecWeightedServicesStickyCookie#sameSite
   */
  readonly sameSite?: string;

  /**
   * @schema TraefikServiceSpecWeightedServicesStickyCookie#secure
   */
  readonly secure?: boolean;

}

/**
 * Converts an object of type 'TraefikServiceSpecWeightedServicesStickyCookie' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TraefikServiceSpecWeightedServicesStickyCookie(obj: TraefikServiceSpecWeightedServicesStickyCookie | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpOnly': obj.httpOnly,
    'name': obj.name,
    'sameSite': obj.sameSite,
    'secure': obj.secure,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

