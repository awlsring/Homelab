// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * AddressPool is the Schema for the addresspools API.
 *
 * @schema AddressPool
 */
export class AddressPool extends ApiObject {
  /**
   * Returns the apiVersion and kind for "AddressPool"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'metallb.io/v1alpha1',
    kind: 'AddressPool',
  }

  /**
   * Renders a Kubernetes manifest for "AddressPool".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AddressPoolProps): any {
    return {
      ...AddressPool.GVK,
      ...toJson_AddressPoolProps(props),
    };
  }

  /**
   * Defines a "AddressPool" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AddressPoolProps) {
    super(scope, id, {
      ...AddressPool.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...AddressPool.GVK,
      ...toJson_AddressPoolProps(resolved),
    };
  }
}

/**
 * AddressPool is the Schema for the addresspools API.
 *
 * @schema AddressPool
 */
export interface AddressPoolProps {
  /**
   * @schema AddressPool#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AddressPoolSpec defines the desired state of AddressPool.
   *
   * @schema AddressPool#spec
   */
  readonly spec: AddressPoolSpec;

}

/**
 * Converts an object of type 'AddressPoolProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AddressPoolProps(obj: AddressPoolProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AddressPoolSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AddressPoolSpec defines the desired state of AddressPool.
 *
 * @schema AddressPoolSpec
 */
export interface AddressPoolSpec {
  /**
   * A list of IP address ranges over which MetalLB has authority. You can list multiple ranges in a single pool, they will all share the same settings. Each range can be either a CIDR prefix, or an explicit start-end range of IPs.
   *
   * @schema AddressPoolSpec#addresses
   */
  readonly addresses: string[];

  /**
   * AutoAssign flag used to prevent MetallB from automatic allocation for a pool.
   *
   * @schema AddressPoolSpec#autoAssign
   */
  readonly autoAssign?: boolean;

  /**
   * When an IP is allocated from this pool, how should it be translated into BGP announcements?
   *
   * @schema AddressPoolSpec#bgpAdvertisements
   */
  readonly bgpAdvertisements?: AddressPoolSpecBgpAdvertisements[];

  /**
   * Protocol can be used to select how the announcement is done.
   *
   * @schema AddressPoolSpec#protocol
   */
  readonly protocol: AddressPoolSpecProtocol;

}

/**
 * Converts an object of type 'AddressPoolSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AddressPoolSpec(obj: AddressPoolSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'addresses': obj.addresses?.map(y => y),
    'autoAssign': obj.autoAssign,
    'bgpAdvertisements': obj.bgpAdvertisements?.map(y => toJson_AddressPoolSpecBgpAdvertisements(y)),
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AddressPoolSpecBgpAdvertisements
 */
export interface AddressPoolSpecBgpAdvertisements {
  /**
   * The aggregation-length advertisement option lets you “roll up” the /32s into a larger prefix.
   *
   * @schema AddressPoolSpecBgpAdvertisements#aggregationLength
   */
  readonly aggregationLength?: number;

  /**
   * Optional, defaults to 128 (i.e. no aggregation) if not specified.
   *
   * @schema AddressPoolSpecBgpAdvertisements#aggregationLengthV6
   */
  readonly aggregationLengthV6?: number;

  /**
   * BGP communities
   *
   * @schema AddressPoolSpecBgpAdvertisements#communities
   */
  readonly communities?: string[];

  /**
   * BGP LOCAL_PREF attribute which is used by BGP best path algorithm, Path with higher localpref is preferred over one with lower localpref.
   *
   * @schema AddressPoolSpecBgpAdvertisements#localPref
   */
  readonly localPref?: number;

}

/**
 * Converts an object of type 'AddressPoolSpecBgpAdvertisements' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AddressPoolSpecBgpAdvertisements(obj: AddressPoolSpecBgpAdvertisements | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aggregationLength': obj.aggregationLength,
    'aggregationLengthV6': obj.aggregationLengthV6,
    'communities': obj.communities?.map(y => y),
    'localPref': obj.localPref,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Protocol can be used to select how the announcement is done.
 *
 * @schema AddressPoolSpecProtocol
 */
export enum AddressPoolSpecProtocol {
  /** layer2 */
  LAYER2 = "layer2",
  /** bgp */
  BGP = "bgp",
}


/**
 * AddressPool represents a pool of IP addresses that can be allocated to LoadBalancer services. AddressPool is deprecated and being replaced by IPAddressPool.
 *
 * @schema AddressPoolV1Beta1
 */
export class AddressPoolV1Beta1 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "AddressPoolV1Beta1"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'metallb.io/v1beta1',
    kind: 'AddressPool',
  }

  /**
   * Renders a Kubernetes manifest for "AddressPoolV1Beta1".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AddressPoolV1Beta1Props): any {
    return {
      ...AddressPoolV1Beta1.GVK,
      ...toJson_AddressPoolV1Beta1Props(props),
    };
  }

  /**
   * Defines a "AddressPoolV1Beta1" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AddressPoolV1Beta1Props) {
    super(scope, id, {
      ...AddressPoolV1Beta1.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...AddressPoolV1Beta1.GVK,
      ...toJson_AddressPoolV1Beta1Props(resolved),
    };
  }
}

/**
 * AddressPool represents a pool of IP addresses that can be allocated to LoadBalancer services. AddressPool is deprecated and being replaced by IPAddressPool.
 *
 * @schema AddressPoolV1Beta1
 */
export interface AddressPoolV1Beta1Props {
  /**
   * @schema AddressPoolV1Beta1#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AddressPoolSpec defines the desired state of AddressPool.
   *
   * @schema AddressPoolV1Beta1#spec
   */
  readonly spec: AddressPoolV1Beta1Spec;

}

/**
 * Converts an object of type 'AddressPoolV1Beta1Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AddressPoolV1Beta1Props(obj: AddressPoolV1Beta1Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AddressPoolV1Beta1Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AddressPoolSpec defines the desired state of AddressPool.
 *
 * @schema AddressPoolV1Beta1Spec
 */
export interface AddressPoolV1Beta1Spec {
  /**
   * A list of IP address ranges over which MetalLB has authority. You can list multiple ranges in a single pool, they will all share the same settings. Each range can be either a CIDR prefix, or an explicit start-end range of IPs.
   *
   * @schema AddressPoolV1Beta1Spec#addresses
   */
  readonly addresses: string[];

  /**
   * AutoAssign flag used to prevent MetallB from automatic allocation for a pool.
   *
   * @schema AddressPoolV1Beta1Spec#autoAssign
   */
  readonly autoAssign?: boolean;

  /**
   * Drives how an IP allocated from this pool should translated into BGP announcements.
   *
   * @schema AddressPoolV1Beta1Spec#bgpAdvertisements
   */
  readonly bgpAdvertisements?: AddressPoolV1Beta1SpecBgpAdvertisements[];

  /**
   * Protocol can be used to select how the announcement is done.
   *
   * @schema AddressPoolV1Beta1Spec#protocol
   */
  readonly protocol: AddressPoolV1Beta1SpecProtocol;

}

/**
 * Converts an object of type 'AddressPoolV1Beta1Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AddressPoolV1Beta1Spec(obj: AddressPoolV1Beta1Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'addresses': obj.addresses?.map(y => y),
    'autoAssign': obj.autoAssign,
    'bgpAdvertisements': obj.bgpAdvertisements?.map(y => toJson_AddressPoolV1Beta1SpecBgpAdvertisements(y)),
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AddressPoolV1Beta1SpecBgpAdvertisements
 */
export interface AddressPoolV1Beta1SpecBgpAdvertisements {
  /**
   * The aggregation-length advertisement option lets you “roll up” the /32s into a larger prefix.
   *
   * @schema AddressPoolV1Beta1SpecBgpAdvertisements#aggregationLength
   */
  readonly aggregationLength?: number;

  /**
   * Optional, defaults to 128 (i.e. no aggregation) if not specified.
   *
   * @schema AddressPoolV1Beta1SpecBgpAdvertisements#aggregationLengthV6
   */
  readonly aggregationLengthV6?: number;

  /**
   * BGP communities to be associated with the given advertisement.
   *
   * @schema AddressPoolV1Beta1SpecBgpAdvertisements#communities
   */
  readonly communities?: string[];

  /**
   * BGP LOCAL_PREF attribute which is used by BGP best path algorithm, Path with higher localpref is preferred over one with lower localpref.
   *
   * @schema AddressPoolV1Beta1SpecBgpAdvertisements#localPref
   */
  readonly localPref?: number;

}

/**
 * Converts an object of type 'AddressPoolV1Beta1SpecBgpAdvertisements' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AddressPoolV1Beta1SpecBgpAdvertisements(obj: AddressPoolV1Beta1SpecBgpAdvertisements | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aggregationLength': obj.aggregationLength,
    'aggregationLengthV6': obj.aggregationLengthV6,
    'communities': obj.communities?.map(y => y),
    'localPref': obj.localPref,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Protocol can be used to select how the announcement is done.
 *
 * @schema AddressPoolV1Beta1SpecProtocol
 */
export enum AddressPoolV1Beta1SpecProtocol {
  /** layer2 */
  LAYER2 = "layer2",
  /** bgp */
  BGP = "bgp",
}


/**
 * BFDProfile represents the settings of the bfd session that can be optionally associated with a BGP session.
 *
 * @schema BFDProfile
 */
export class BfdProfile extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BFDProfile"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'metallb.io/v1beta1',
    kind: 'BFDProfile',
  }

  /**
   * Renders a Kubernetes manifest for "BFDProfile".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BfdProfileProps = {}): any {
    return {
      ...BfdProfile.GVK,
      ...toJson_BfdProfileProps(props),
    };
  }

  /**
   * Defines a "BFDProfile" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BfdProfileProps = {}) {
    super(scope, id, {
      ...BfdProfile.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...BfdProfile.GVK,
      ...toJson_BfdProfileProps(resolved),
    };
  }
}

/**
 * BFDProfile represents the settings of the bfd session that can be optionally associated with a BGP session.
 *
 * @schema BFDProfile
 */
export interface BfdProfileProps {
  /**
   * @schema BFDProfile#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BFDProfileSpec defines the desired state of BFDProfile.
   *
   * @schema BFDProfile#spec
   */
  readonly spec?: BfdProfileSpec;

}

/**
 * Converts an object of type 'BfdProfileProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BfdProfileProps(obj: BfdProfileProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BfdProfileSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BFDProfileSpec defines the desired state of BFDProfile.
 *
 * @schema BfdProfileSpec
 */
export interface BfdProfileSpec {
  /**
   * Configures the detection multiplier to determine packet loss. The remote transmission interval will be multiplied by this value to determine the connection loss detection timer.
   *
   * @schema BfdProfileSpec#detectMultiplier
   */
  readonly detectMultiplier?: number;

  /**
   * Configures the minimal echo receive transmission interval that this system is capable of handling in milliseconds. Defaults to 50ms
   *
   * @default 50ms
   * @schema BfdProfileSpec#echoInterval
   */
  readonly echoInterval?: number;

  /**
   * Enables or disables the echo transmission mode. This mode is disabled by default, and not supported on multi hops setups.
   *
   * @schema BfdProfileSpec#echoMode
   */
  readonly echoMode?: boolean;

  /**
   * For multi hop sessions only: configure the minimum expected TTL for an incoming BFD control packet.
   *
   * @schema BfdProfileSpec#minimumTtl
   */
  readonly minimumTtl?: number;

  /**
   * Mark session as passive: a passive session will not attempt to start the connection and will wait for control packets from peer before it begins replying.
   *
   * @schema BfdProfileSpec#passiveMode
   */
  readonly passiveMode?: boolean;

  /**
   * The minimum interval that this system is capable of receiving control packets in milliseconds. Defaults to 300ms.
   *
   * @default 300ms.
   * @schema BfdProfileSpec#receiveInterval
   */
  readonly receiveInterval?: number;

  /**
   * The minimum transmission interval (less jitter) that this system wants to use to send BFD control packets in milliseconds. Defaults to 300ms
   *
   * @default 300ms
   * @schema BfdProfileSpec#transmitInterval
   */
  readonly transmitInterval?: number;

}

/**
 * Converts an object of type 'BfdProfileSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BfdProfileSpec(obj: BfdProfileSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'detectMultiplier': obj.detectMultiplier,
    'echoInterval': obj.echoInterval,
    'echoMode': obj.echoMode,
    'minimumTtl': obj.minimumTtl,
    'passiveMode': obj.passiveMode,
    'receiveInterval': obj.receiveInterval,
    'transmitInterval': obj.transmitInterval,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * BGPAdvertisement allows to advertise the IPs coming from the selected IPAddressPools via BGP, setting the parameters of the BGP Advertisement.
 *
 * @schema BGPAdvertisement
 */
export class BgpAdvertisement extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BGPAdvertisement"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'metallb.io/v1beta1',
    kind: 'BGPAdvertisement',
  }

  /**
   * Renders a Kubernetes manifest for "BGPAdvertisement".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BgpAdvertisementProps = {}): any {
    return {
      ...BgpAdvertisement.GVK,
      ...toJson_BgpAdvertisementProps(props),
    };
  }

  /**
   * Defines a "BGPAdvertisement" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BgpAdvertisementProps = {}) {
    super(scope, id, {
      ...BgpAdvertisement.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...BgpAdvertisement.GVK,
      ...toJson_BgpAdvertisementProps(resolved),
    };
  }
}

/**
 * BGPAdvertisement allows to advertise the IPs coming from the selected IPAddressPools via BGP, setting the parameters of the BGP Advertisement.
 *
 * @schema BGPAdvertisement
 */
export interface BgpAdvertisementProps {
  /**
   * @schema BGPAdvertisement#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BGPAdvertisementSpec defines the desired state of BGPAdvertisement.
   *
   * @schema BGPAdvertisement#spec
   */
  readonly spec?: BgpAdvertisementSpec;

}

/**
 * Converts an object of type 'BgpAdvertisementProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BgpAdvertisementProps(obj: BgpAdvertisementProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BgpAdvertisementSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BGPAdvertisementSpec defines the desired state of BGPAdvertisement.
 *
 * @schema BgpAdvertisementSpec
 */
export interface BgpAdvertisementSpec {
  /**
   * The aggregation-length advertisement option lets you “roll up” the /32s into a larger prefix. Defaults to 32. Works for IPv4 addresses.
   *
   * @default 32. Works for IPv4 addresses.
   * @schema BgpAdvertisementSpec#aggregationLength
   */
  readonly aggregationLength?: number;

  /**
   * The aggregation-length advertisement option lets you “roll up” the /128s into a larger prefix. Defaults to 128. Works for IPv6 addresses.
   *
   * @default 128. Works for IPv6 addresses.
   * @schema BgpAdvertisementSpec#aggregationLengthV6
   */
  readonly aggregationLengthV6?: number;

  /**
   * The BGP communities to be associated with the announcement. Each item can be a standard community of the form 1234:1234, a large community of the form large:1234:1234:1234 or the name of an alias defined in the Community CRD.
   *
   * @schema BgpAdvertisementSpec#communities
   */
  readonly communities?: string[];

  /**
   * A selector for the IPAddressPools which would get advertised via this advertisement. If no IPAddressPool is selected by this or by the list, the advertisement is applied to all the IPAddressPools.
   *
   * @schema BgpAdvertisementSpec#ipAddressPoolSelectors
   */
  readonly ipAddressPoolSelectors?: BgpAdvertisementSpecIpAddressPoolSelectors[];

  /**
   * The list of IPAddressPools to advertise via this advertisement, selected by name.
   *
   * @schema BgpAdvertisementSpec#ipAddressPools
   */
  readonly ipAddressPools?: string[];

  /**
   * The BGP LOCAL_PREF attribute which is used by BGP best path algorithm, Path with higher localpref is preferred over one with lower localpref.
   *
   * @schema BgpAdvertisementSpec#localPref
   */
  readonly localPref?: number;

  /**
   * NodeSelectors allows to limit the nodes to announce as next hops for the LoadBalancer IP. When empty, all the nodes having  are announced as next hops.
   *
   * @schema BgpAdvertisementSpec#nodeSelectors
   */
  readonly nodeSelectors?: BgpAdvertisementSpecNodeSelectors[];

  /**
   * Peers limits the bgppeer to advertise the ips of the selected pools to. When empty, the loadbalancer IP is announced to all the BGPPeers configured.
   *
   * @schema BgpAdvertisementSpec#peers
   */
  readonly peers?: string[];

}

/**
 * Converts an object of type 'BgpAdvertisementSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BgpAdvertisementSpec(obj: BgpAdvertisementSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aggregationLength': obj.aggregationLength,
    'aggregationLengthV6': obj.aggregationLengthV6,
    'communities': obj.communities?.map(y => y),
    'ipAddressPoolSelectors': obj.ipAddressPoolSelectors?.map(y => toJson_BgpAdvertisementSpecIpAddressPoolSelectors(y)),
    'ipAddressPools': obj.ipAddressPools?.map(y => y),
    'localPref': obj.localPref,
    'nodeSelectors': obj.nodeSelectors?.map(y => toJson_BgpAdvertisementSpecNodeSelectors(y)),
    'peers': obj.peers?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
 *
 * @schema BgpAdvertisementSpecIpAddressPoolSelectors
 */
export interface BgpAdvertisementSpecIpAddressPoolSelectors {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema BgpAdvertisementSpecIpAddressPoolSelectors#matchExpressions
   */
  readonly matchExpressions?: BgpAdvertisementSpecIpAddressPoolSelectorsMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema BgpAdvertisementSpecIpAddressPoolSelectors#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'BgpAdvertisementSpecIpAddressPoolSelectors' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BgpAdvertisementSpecIpAddressPoolSelectors(obj: BgpAdvertisementSpecIpAddressPoolSelectors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_BgpAdvertisementSpecIpAddressPoolSelectorsMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
 *
 * @schema BgpAdvertisementSpecNodeSelectors
 */
export interface BgpAdvertisementSpecNodeSelectors {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema BgpAdvertisementSpecNodeSelectors#matchExpressions
   */
  readonly matchExpressions?: BgpAdvertisementSpecNodeSelectorsMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema BgpAdvertisementSpecNodeSelectors#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'BgpAdvertisementSpecNodeSelectors' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BgpAdvertisementSpecNodeSelectors(obj: BgpAdvertisementSpecNodeSelectors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_BgpAdvertisementSpecNodeSelectorsMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema BgpAdvertisementSpecIpAddressPoolSelectorsMatchExpressions
 */
export interface BgpAdvertisementSpecIpAddressPoolSelectorsMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema BgpAdvertisementSpecIpAddressPoolSelectorsMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema BgpAdvertisementSpecIpAddressPoolSelectorsMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema BgpAdvertisementSpecIpAddressPoolSelectorsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'BgpAdvertisementSpecIpAddressPoolSelectorsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BgpAdvertisementSpecIpAddressPoolSelectorsMatchExpressions(obj: BgpAdvertisementSpecIpAddressPoolSelectorsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema BgpAdvertisementSpecNodeSelectorsMatchExpressions
 */
export interface BgpAdvertisementSpecNodeSelectorsMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema BgpAdvertisementSpecNodeSelectorsMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema BgpAdvertisementSpecNodeSelectorsMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema BgpAdvertisementSpecNodeSelectorsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'BgpAdvertisementSpecNodeSelectorsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BgpAdvertisementSpecNodeSelectorsMatchExpressions(obj: BgpAdvertisementSpecNodeSelectorsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * BGPPeer is the Schema for the peers API.
 *
 * @schema BGPPeer
 */
export class BgpPeer extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BGPPeer"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'metallb.io/v1beta1',
    kind: 'BGPPeer',
  }

  /**
   * Renders a Kubernetes manifest for "BGPPeer".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BgpPeerProps = {}): any {
    return {
      ...BgpPeer.GVK,
      ...toJson_BgpPeerProps(props),
    };
  }

  /**
   * Defines a "BGPPeer" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BgpPeerProps = {}) {
    super(scope, id, {
      ...BgpPeer.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...BgpPeer.GVK,
      ...toJson_BgpPeerProps(resolved),
    };
  }
}

/**
 * BGPPeer is the Schema for the peers API.
 *
 * @schema BGPPeer
 */
export interface BgpPeerProps {
  /**
   * @schema BGPPeer#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BGPPeerSpec defines the desired state of Peer.
   *
   * @schema BGPPeer#spec
   */
  readonly spec?: BgpPeerSpec;

}

/**
 * Converts an object of type 'BgpPeerProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BgpPeerProps(obj: BgpPeerProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BgpPeerSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BGPPeerSpec defines the desired state of Peer.
 *
 * @schema BgpPeerSpec
 */
export interface BgpPeerSpec {
  /**
   * @schema BgpPeerSpec#bfdProfile
   */
  readonly bfdProfile?: string;

  /**
   * EBGP peer is multi-hops away
   *
   * @schema BgpPeerSpec#ebgpMultiHop
   */
  readonly ebgpMultiHop?: boolean;

  /**
   * Requested BGP hold time, per RFC4271.
   *
   * @schema BgpPeerSpec#holdTime
   */
  readonly holdTime?: string;

  /**
   * Requested BGP keepalive time, per RFC4271.
   *
   * @schema BgpPeerSpec#keepaliveTime
   */
  readonly keepaliveTime?: string;

  /**
   * AS number to use for the local end of the session.
   *
   * @schema BgpPeerSpec#myASN
   */
  readonly myAsn: number;

  /**
   * Only connect to this peer on nodes that match one of these selectors.
   *
   * @schema BgpPeerSpec#nodeSelectors
   */
  readonly nodeSelectors?: BgpPeerSpecNodeSelectors[];

  /**
   * Authentication password for routers enforcing TCP MD5 authenticated sessions
   *
   * @schema BgpPeerSpec#password
   */
  readonly password?: string;

  /**
   * AS number to expect from the remote end of the session.
   *
   * @schema BgpPeerSpec#peerASN
   */
  readonly peerAsn: number;

  /**
   * Address to dial when establishing the session.
   *
   * @schema BgpPeerSpec#peerAddress
   */
  readonly peerAddress: string;

  /**
   * Port to dial when establishing the session.
   *
   * @schema BgpPeerSpec#peerPort
   */
  readonly peerPort?: number;

  /**
   * BGP router ID to advertise to the peer
   *
   * @schema BgpPeerSpec#routerID
   */
  readonly routerId?: string;

  /**
   * Source address to use when establishing the session.
   *
   * @schema BgpPeerSpec#sourceAddress
   */
  readonly sourceAddress?: string;

}

/**
 * Converts an object of type 'BgpPeerSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BgpPeerSpec(obj: BgpPeerSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bfdProfile': obj.bfdProfile,
    'ebgpMultiHop': obj.ebgpMultiHop,
    'holdTime': obj.holdTime,
    'keepaliveTime': obj.keepaliveTime,
    'myASN': obj.myAsn,
    'nodeSelectors': obj.nodeSelectors?.map(y => toJson_BgpPeerSpecNodeSelectors(y)),
    'password': obj.password,
    'peerASN': obj.peerAsn,
    'peerAddress': obj.peerAddress,
    'peerPort': obj.peerPort,
    'routerID': obj.routerId,
    'sourceAddress': obj.sourceAddress,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BgpPeerSpecNodeSelectors
 */
export interface BgpPeerSpecNodeSelectors {
  /**
   * @schema BgpPeerSpecNodeSelectors#matchExpressions
   */
  readonly matchExpressions?: BgpPeerSpecNodeSelectorsMatchExpressions[];

  /**
   * @schema BgpPeerSpecNodeSelectors#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'BgpPeerSpecNodeSelectors' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BgpPeerSpecNodeSelectors(obj: BgpPeerSpecNodeSelectors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_BgpPeerSpecNodeSelectorsMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BgpPeerSpecNodeSelectorsMatchExpressions
 */
export interface BgpPeerSpecNodeSelectorsMatchExpressions {
  /**
   * @schema BgpPeerSpecNodeSelectorsMatchExpressions#key
   */
  readonly key: string;

  /**
   * @schema BgpPeerSpecNodeSelectorsMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * @schema BgpPeerSpecNodeSelectorsMatchExpressions#values
   */
  readonly values: string[];

}

/**
 * Converts an object of type 'BgpPeerSpecNodeSelectorsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BgpPeerSpecNodeSelectorsMatchExpressions(obj: BgpPeerSpecNodeSelectorsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * BGPPeer is the Schema for the peers API.
 *
 * @schema BGPPeerV1Beta2
 */
export class BgpPeerV1Beta2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BGPPeerV1Beta2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'metallb.io/v1beta2',
    kind: 'BGPPeer',
  }

  /**
   * Renders a Kubernetes manifest for "BGPPeerV1Beta2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BgpPeerV1Beta2Props = {}): any {
    return {
      ...BgpPeerV1Beta2.GVK,
      ...toJson_BgpPeerV1Beta2Props(props),
    };
  }

  /**
   * Defines a "BGPPeerV1Beta2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BgpPeerV1Beta2Props = {}) {
    super(scope, id, {
      ...BgpPeerV1Beta2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...BgpPeerV1Beta2.GVK,
      ...toJson_BgpPeerV1Beta2Props(resolved),
    };
  }
}

/**
 * BGPPeer is the Schema for the peers API.
 *
 * @schema BGPPeerV1Beta2
 */
export interface BgpPeerV1Beta2Props {
  /**
   * @schema BGPPeerV1Beta2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BGPPeerSpec defines the desired state of Peer.
   *
   * @schema BGPPeerV1Beta2#spec
   */
  readonly spec?: BgpPeerV1Beta2Spec;

}

/**
 * Converts an object of type 'BgpPeerV1Beta2Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BgpPeerV1Beta2Props(obj: BgpPeerV1Beta2Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BgpPeerV1Beta2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BGPPeerSpec defines the desired state of Peer.
 *
 * @schema BgpPeerV1Beta2Spec
 */
export interface BgpPeerV1Beta2Spec {
  /**
   * The name of the BFD Profile to be used for the BFD session associated to the BGP session. If not set, the BFD session won't be set up.
   *
   * @schema BgpPeerV1Beta2Spec#bfdProfile
   */
  readonly bfdProfile?: string;

  /**
   * To set if the BGPPeer is multi-hops away. Needed for FRR mode only.
   *
   * @schema BgpPeerV1Beta2Spec#ebgpMultiHop
   */
  readonly ebgpMultiHop?: boolean;

  /**
   * Requested BGP hold time, per RFC4271.
   *
   * @schema BgpPeerV1Beta2Spec#holdTime
   */
  readonly holdTime?: string;

  /**
   * Requested BGP keepalive time, per RFC4271.
   *
   * @schema BgpPeerV1Beta2Spec#keepaliveTime
   */
  readonly keepaliveTime?: string;

  /**
   * AS number to use for the local end of the session.
   *
   * @schema BgpPeerV1Beta2Spec#myASN
   */
  readonly myAsn: number;

  /**
   * Only connect to this peer on nodes that match one of these selectors.
   *
   * @schema BgpPeerV1Beta2Spec#nodeSelectors
   */
  readonly nodeSelectors?: BgpPeerV1Beta2SpecNodeSelectors[];

  /**
   * Authentication password for routers enforcing TCP MD5 authenticated sessions
   *
   * @schema BgpPeerV1Beta2Spec#password
   */
  readonly password?: string;

  /**
   * passwordSecret is name of the authentication secret for BGP Peer. the secret must be of type "kubernetes.io/basic-auth", and created in the same namespace as the MetalLB deployment. The password is stored in the secret as the key "password".
   *
   * @schema BgpPeerV1Beta2Spec#passwordSecret
   */
  readonly passwordSecret?: BgpPeerV1Beta2SpecPasswordSecret;

  /**
   * AS number to expect from the remote end of the session.
   *
   * @schema BgpPeerV1Beta2Spec#peerASN
   */
  readonly peerAsn: number;

  /**
   * Address to dial when establishing the session.
   *
   * @schema BgpPeerV1Beta2Spec#peerAddress
   */
  readonly peerAddress: string;

  /**
   * Port to dial when establishing the session.
   *
   * @schema BgpPeerV1Beta2Spec#peerPort
   */
  readonly peerPort?: number;

  /**
   * BGP router ID to advertise to the peer
   *
   * @schema BgpPeerV1Beta2Spec#routerID
   */
  readonly routerId?: string;

  /**
   * Source address to use when establishing the session.
   *
   * @schema BgpPeerV1Beta2Spec#sourceAddress
   */
  readonly sourceAddress?: string;

  /**
   * To set if we want to peer with the BGPPeer using an interface belonging to a host vrf
   *
   * @schema BgpPeerV1Beta2Spec#vrf
   */
  readonly vrf?: string;

}

/**
 * Converts an object of type 'BgpPeerV1Beta2Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BgpPeerV1Beta2Spec(obj: BgpPeerV1Beta2Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bfdProfile': obj.bfdProfile,
    'ebgpMultiHop': obj.ebgpMultiHop,
    'holdTime': obj.holdTime,
    'keepaliveTime': obj.keepaliveTime,
    'myASN': obj.myAsn,
    'nodeSelectors': obj.nodeSelectors?.map(y => toJson_BgpPeerV1Beta2SpecNodeSelectors(y)),
    'password': obj.password,
    'passwordSecret': toJson_BgpPeerV1Beta2SpecPasswordSecret(obj.passwordSecret),
    'peerASN': obj.peerAsn,
    'peerAddress': obj.peerAddress,
    'peerPort': obj.peerPort,
    'routerID': obj.routerId,
    'sourceAddress': obj.sourceAddress,
    'vrf': obj.vrf,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
 *
 * @schema BgpPeerV1Beta2SpecNodeSelectors
 */
export interface BgpPeerV1Beta2SpecNodeSelectors {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema BgpPeerV1Beta2SpecNodeSelectors#matchExpressions
   */
  readonly matchExpressions?: BgpPeerV1Beta2SpecNodeSelectorsMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema BgpPeerV1Beta2SpecNodeSelectors#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'BgpPeerV1Beta2SpecNodeSelectors' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BgpPeerV1Beta2SpecNodeSelectors(obj: BgpPeerV1Beta2SpecNodeSelectors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_BgpPeerV1Beta2SpecNodeSelectorsMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * passwordSecret is name of the authentication secret for BGP Peer. the secret must be of type "kubernetes.io/basic-auth", and created in the same namespace as the MetalLB deployment. The password is stored in the secret as the key "password".
 *
 * @schema BgpPeerV1Beta2SpecPasswordSecret
 */
export interface BgpPeerV1Beta2SpecPasswordSecret {
  /**
   * name is unique within a namespace to reference a secret resource.
   *
   * @schema BgpPeerV1Beta2SpecPasswordSecret#name
   */
  readonly name?: string;

  /**
   * namespace defines the space within which the secret name must be unique.
   *
   * @schema BgpPeerV1Beta2SpecPasswordSecret#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'BgpPeerV1Beta2SpecPasswordSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BgpPeerV1Beta2SpecPasswordSecret(obj: BgpPeerV1Beta2SpecPasswordSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema BgpPeerV1Beta2SpecNodeSelectorsMatchExpressions
 */
export interface BgpPeerV1Beta2SpecNodeSelectorsMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema BgpPeerV1Beta2SpecNodeSelectorsMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema BgpPeerV1Beta2SpecNodeSelectorsMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema BgpPeerV1Beta2SpecNodeSelectorsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'BgpPeerV1Beta2SpecNodeSelectorsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BgpPeerV1Beta2SpecNodeSelectorsMatchExpressions(obj: BgpPeerV1Beta2SpecNodeSelectorsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * Community is a collection of aliases for communities. Users can define named aliases to be used in the BGPPeer CRD.
 *
 * @schema Community
 */
export class Community extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Community"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'metallb.io/v1beta1',
    kind: 'Community',
  }

  /**
   * Renders a Kubernetes manifest for "Community".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CommunityProps = {}): any {
    return {
      ...Community.GVK,
      ...toJson_CommunityProps(props),
    };
  }

  /**
   * Defines a "Community" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CommunityProps = {}) {
    super(scope, id, {
      ...Community.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Community.GVK,
      ...toJson_CommunityProps(resolved),
    };
  }
}

/**
 * Community is a collection of aliases for communities. Users can define named aliases to be used in the BGPPeer CRD.
 *
 * @schema Community
 */
export interface CommunityProps {
  /**
   * @schema Community#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * CommunitySpec defines the desired state of Community.
   *
   * @schema Community#spec
   */
  readonly spec?: CommunitySpec;

}

/**
 * Converts an object of type 'CommunityProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CommunityProps(obj: CommunityProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CommunitySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CommunitySpec defines the desired state of Community.
 *
 * @schema CommunitySpec
 */
export interface CommunitySpec {
  /**
   * @schema CommunitySpec#communities
   */
  readonly communities?: CommunitySpecCommunities[];

}

/**
 * Converts an object of type 'CommunitySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CommunitySpec(obj: CommunitySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'communities': obj.communities?.map(y => toJson_CommunitySpecCommunities(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CommunitySpecCommunities
 */
export interface CommunitySpecCommunities {
  /**
   * The name of the alias for the community.
   *
   * @schema CommunitySpecCommunities#name
   */
  readonly name?: string;

  /**
   * The BGP community value corresponding to the given name. Can be a standard community of the form 1234:1234 or a large community of the form large:1234:1234:1234.
   *
   * @schema CommunitySpecCommunities#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'CommunitySpecCommunities' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CommunitySpecCommunities(obj: CommunitySpecCommunities | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * IPAddressPool represents a pool of IP addresses that can be allocated to LoadBalancer services.
 *
 * @schema IPAddressPool
 */
export class IpAddressPool extends ApiObject {
  /**
   * Returns the apiVersion and kind for "IPAddressPool"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'metallb.io/v1beta1',
    kind: 'IPAddressPool',
  }

  /**
   * Renders a Kubernetes manifest for "IPAddressPool".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: IpAddressPoolProps): any {
    return {
      ...IpAddressPool.GVK,
      ...toJson_IpAddressPoolProps(props),
    };
  }

  /**
   * Defines a "IPAddressPool" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: IpAddressPoolProps) {
    super(scope, id, {
      ...IpAddressPool.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...IpAddressPool.GVK,
      ...toJson_IpAddressPoolProps(resolved),
    };
  }
}

/**
 * IPAddressPool represents a pool of IP addresses that can be allocated to LoadBalancer services.
 *
 * @schema IPAddressPool
 */
export interface IpAddressPoolProps {
  /**
   * @schema IPAddressPool#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * IPAddressPoolSpec defines the desired state of IPAddressPool.
   *
   * @schema IPAddressPool#spec
   */
  readonly spec: IpAddressPoolSpec;

}

/**
 * Converts an object of type 'IpAddressPoolProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IpAddressPoolProps(obj: IpAddressPoolProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_IpAddressPoolSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IPAddressPoolSpec defines the desired state of IPAddressPool.
 *
 * @schema IpAddressPoolSpec
 */
export interface IpAddressPoolSpec {
  /**
   * A list of IP address ranges over which MetalLB has authority. You can list multiple ranges in a single pool, they will all share the same settings. Each range can be either a CIDR prefix, or an explicit start-end range of IPs.
   *
   * @schema IpAddressPoolSpec#addresses
   */
  readonly addresses: string[];

  /**
   * AutoAssign flag used to prevent MetallB from automatic allocation for a pool.
   *
   * @schema IpAddressPoolSpec#autoAssign
   */
  readonly autoAssign?: boolean;

  /**
   * AvoidBuggyIPs prevents addresses ending with .0 and .255 to be used by a pool.
   *
   * @schema IpAddressPoolSpec#avoidBuggyIPs
   */
  readonly avoidBuggyIPs?: boolean;

  /**
   * AllocateTo makes ip pool allocation to specific namespace and/or service. The controller will use the pool with lowest value of priority in case of multiple matches. A pool with no priority set will be used only if the pools with priority can't be used. If multiple matching IPAddressPools are available it will check for the availability of IPs sorting the matching IPAddressPools by priority, starting from the highest to the lowest. If multiple IPAddressPools have the same priority, choice will be random.
   *
   * @schema IpAddressPoolSpec#serviceAllocation
   */
  readonly serviceAllocation?: IpAddressPoolSpecServiceAllocation;

}

/**
 * Converts an object of type 'IpAddressPoolSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IpAddressPoolSpec(obj: IpAddressPoolSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'addresses': obj.addresses?.map(y => y),
    'autoAssign': obj.autoAssign,
    'avoidBuggyIPs': obj.avoidBuggyIPs,
    'serviceAllocation': toJson_IpAddressPoolSpecServiceAllocation(obj.serviceAllocation),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AllocateTo makes ip pool allocation to specific namespace and/or service. The controller will use the pool with lowest value of priority in case of multiple matches. A pool with no priority set will be used only if the pools with priority can't be used. If multiple matching IPAddressPools are available it will check for the availability of IPs sorting the matching IPAddressPools by priority, starting from the highest to the lowest. If multiple IPAddressPools have the same priority, choice will be random.
 *
 * @schema IpAddressPoolSpecServiceAllocation
 */
export interface IpAddressPoolSpecServiceAllocation {
  /**
   * NamespaceSelectors list of label selectors to select namespace(s) for ip pool, an alternative to using namespace list.
   *
   * @schema IpAddressPoolSpecServiceAllocation#namespaceSelectors
   */
  readonly namespaceSelectors?: IpAddressPoolSpecServiceAllocationNamespaceSelectors[];

  /**
   * Namespaces list of namespace(s) on which ip pool can be attached.
   *
   * @schema IpAddressPoolSpecServiceAllocation#namespaces
   */
  readonly namespaces?: string[];

  /**
   * Priority priority given for ip pool while ip allocation on a service.
   *
   * @schema IpAddressPoolSpecServiceAllocation#priority
   */
  readonly priority?: number;

  /**
   * ServiceSelectors list of label selector to select service(s) for which ip pool can be used for ip allocation.
   *
   * @schema IpAddressPoolSpecServiceAllocation#serviceSelectors
   */
  readonly serviceSelectors?: IpAddressPoolSpecServiceAllocationServiceSelectors[];

}

/**
 * Converts an object of type 'IpAddressPoolSpecServiceAllocation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IpAddressPoolSpecServiceAllocation(obj: IpAddressPoolSpecServiceAllocation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'namespaceSelectors': obj.namespaceSelectors?.map(y => toJson_IpAddressPoolSpecServiceAllocationNamespaceSelectors(y)),
    'namespaces': obj.namespaces?.map(y => y),
    'priority': obj.priority,
    'serviceSelectors': obj.serviceSelectors?.map(y => toJson_IpAddressPoolSpecServiceAllocationServiceSelectors(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
 *
 * @schema IpAddressPoolSpecServiceAllocationNamespaceSelectors
 */
export interface IpAddressPoolSpecServiceAllocationNamespaceSelectors {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema IpAddressPoolSpecServiceAllocationNamespaceSelectors#matchExpressions
   */
  readonly matchExpressions?: IpAddressPoolSpecServiceAllocationNamespaceSelectorsMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema IpAddressPoolSpecServiceAllocationNamespaceSelectors#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'IpAddressPoolSpecServiceAllocationNamespaceSelectors' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IpAddressPoolSpecServiceAllocationNamespaceSelectors(obj: IpAddressPoolSpecServiceAllocationNamespaceSelectors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_IpAddressPoolSpecServiceAllocationNamespaceSelectorsMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
 *
 * @schema IpAddressPoolSpecServiceAllocationServiceSelectors
 */
export interface IpAddressPoolSpecServiceAllocationServiceSelectors {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema IpAddressPoolSpecServiceAllocationServiceSelectors#matchExpressions
   */
  readonly matchExpressions?: IpAddressPoolSpecServiceAllocationServiceSelectorsMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema IpAddressPoolSpecServiceAllocationServiceSelectors#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'IpAddressPoolSpecServiceAllocationServiceSelectors' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IpAddressPoolSpecServiceAllocationServiceSelectors(obj: IpAddressPoolSpecServiceAllocationServiceSelectors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_IpAddressPoolSpecServiceAllocationServiceSelectorsMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema IpAddressPoolSpecServiceAllocationNamespaceSelectorsMatchExpressions
 */
export interface IpAddressPoolSpecServiceAllocationNamespaceSelectorsMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema IpAddressPoolSpecServiceAllocationNamespaceSelectorsMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema IpAddressPoolSpecServiceAllocationNamespaceSelectorsMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema IpAddressPoolSpecServiceAllocationNamespaceSelectorsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'IpAddressPoolSpecServiceAllocationNamespaceSelectorsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IpAddressPoolSpecServiceAllocationNamespaceSelectorsMatchExpressions(obj: IpAddressPoolSpecServiceAllocationNamespaceSelectorsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema IpAddressPoolSpecServiceAllocationServiceSelectorsMatchExpressions
 */
export interface IpAddressPoolSpecServiceAllocationServiceSelectorsMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema IpAddressPoolSpecServiceAllocationServiceSelectorsMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema IpAddressPoolSpecServiceAllocationServiceSelectorsMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema IpAddressPoolSpecServiceAllocationServiceSelectorsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'IpAddressPoolSpecServiceAllocationServiceSelectorsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IpAddressPoolSpecServiceAllocationServiceSelectorsMatchExpressions(obj: IpAddressPoolSpecServiceAllocationServiceSelectorsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * L2Advertisement allows to advertise the LoadBalancer IPs provided by the selected pools via L2.
 *
 * @schema L2Advertisement
 */
export class L2Advertisement extends ApiObject {
  /**
   * Returns the apiVersion and kind for "L2Advertisement"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'metallb.io/v1beta1',
    kind: 'L2Advertisement',
  }

  /**
   * Renders a Kubernetes manifest for "L2Advertisement".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: L2AdvertisementProps = {}): any {
    return {
      ...L2Advertisement.GVK,
      ...toJson_L2AdvertisementProps(props),
    };
  }

  /**
   * Defines a "L2Advertisement" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: L2AdvertisementProps = {}) {
    super(scope, id, {
      ...L2Advertisement.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...L2Advertisement.GVK,
      ...toJson_L2AdvertisementProps(resolved),
    };
  }
}

/**
 * L2Advertisement allows to advertise the LoadBalancer IPs provided by the selected pools via L2.
 *
 * @schema L2Advertisement
 */
export interface L2AdvertisementProps {
  /**
   * @schema L2Advertisement#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * L2AdvertisementSpec defines the desired state of L2Advertisement.
   *
   * @schema L2Advertisement#spec
   */
  readonly spec?: L2AdvertisementSpec;

}

/**
 * Converts an object of type 'L2AdvertisementProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_L2AdvertisementProps(obj: L2AdvertisementProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_L2AdvertisementSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * L2AdvertisementSpec defines the desired state of L2Advertisement.
 *
 * @schema L2AdvertisementSpec
 */
export interface L2AdvertisementSpec {
  /**
   * A list of interfaces to announce from. The LB IP will be announced only from these interfaces. If the field is not set, we advertise from all the interfaces on the host.
   *
   * @schema L2AdvertisementSpec#interfaces
   */
  readonly interfaces?: string[];

  /**
   * A selector for the IPAddressPools which would get advertised via this advertisement. If no IPAddressPool is selected by this or by the list, the advertisement is applied to all the IPAddressPools.
   *
   * @schema L2AdvertisementSpec#ipAddressPoolSelectors
   */
  readonly ipAddressPoolSelectors?: L2AdvertisementSpecIpAddressPoolSelectors[];

  /**
   * The list of IPAddressPools to advertise via this advertisement, selected by name.
   *
   * @schema L2AdvertisementSpec#ipAddressPools
   */
  readonly ipAddressPools?: string[];

  /**
   * NodeSelectors allows to limit the nodes to announce as next hops for the LoadBalancer IP. When empty, all the nodes having  are announced as next hops.
   *
   * @schema L2AdvertisementSpec#nodeSelectors
   */
  readonly nodeSelectors?: L2AdvertisementSpecNodeSelectors[];

}

/**
 * Converts an object of type 'L2AdvertisementSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_L2AdvertisementSpec(obj: L2AdvertisementSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'interfaces': obj.interfaces?.map(y => y),
    'ipAddressPoolSelectors': obj.ipAddressPoolSelectors?.map(y => toJson_L2AdvertisementSpecIpAddressPoolSelectors(y)),
    'ipAddressPools': obj.ipAddressPools?.map(y => y),
    'nodeSelectors': obj.nodeSelectors?.map(y => toJson_L2AdvertisementSpecNodeSelectors(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
 *
 * @schema L2AdvertisementSpecIpAddressPoolSelectors
 */
export interface L2AdvertisementSpecIpAddressPoolSelectors {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema L2AdvertisementSpecIpAddressPoolSelectors#matchExpressions
   */
  readonly matchExpressions?: L2AdvertisementSpecIpAddressPoolSelectorsMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema L2AdvertisementSpecIpAddressPoolSelectors#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'L2AdvertisementSpecIpAddressPoolSelectors' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_L2AdvertisementSpecIpAddressPoolSelectors(obj: L2AdvertisementSpecIpAddressPoolSelectors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_L2AdvertisementSpecIpAddressPoolSelectorsMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
 *
 * @schema L2AdvertisementSpecNodeSelectors
 */
export interface L2AdvertisementSpecNodeSelectors {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema L2AdvertisementSpecNodeSelectors#matchExpressions
   */
  readonly matchExpressions?: L2AdvertisementSpecNodeSelectorsMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema L2AdvertisementSpecNodeSelectors#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'L2AdvertisementSpecNodeSelectors' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_L2AdvertisementSpecNodeSelectors(obj: L2AdvertisementSpecNodeSelectors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_L2AdvertisementSpecNodeSelectorsMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema L2AdvertisementSpecIpAddressPoolSelectorsMatchExpressions
 */
export interface L2AdvertisementSpecIpAddressPoolSelectorsMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema L2AdvertisementSpecIpAddressPoolSelectorsMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema L2AdvertisementSpecIpAddressPoolSelectorsMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema L2AdvertisementSpecIpAddressPoolSelectorsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'L2AdvertisementSpecIpAddressPoolSelectorsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_L2AdvertisementSpecIpAddressPoolSelectorsMatchExpressions(obj: L2AdvertisementSpecIpAddressPoolSelectorsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema L2AdvertisementSpecNodeSelectorsMatchExpressions
 */
export interface L2AdvertisementSpecNodeSelectorsMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema L2AdvertisementSpecNodeSelectorsMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema L2AdvertisementSpecNodeSelectorsMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema L2AdvertisementSpecNodeSelectorsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'L2AdvertisementSpecNodeSelectorsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_L2AdvertisementSpecNodeSelectorsMatchExpressions(obj: L2AdvertisementSpecNodeSelectorsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

