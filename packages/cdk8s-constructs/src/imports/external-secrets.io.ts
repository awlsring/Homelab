// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from "cdk8s";
import { Construct } from "constructs";

/**
 * ClusterExternalSecret is the Schema for the clusterexternalsecrets API.
 *
 * @schema ClusterExternalSecret
 */
export class ClusterExternalSecret extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ClusterExternalSecret"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "external-secrets.io/v1beta1",
    kind: "ClusterExternalSecret",
  };

  /**
   * Renders a Kubernetes manifest for "ClusterExternalSecret".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ClusterExternalSecretProps = {}): any {
    return {
      ...ClusterExternalSecret.GVK,
      ...toJson_ClusterExternalSecretProps(props),
    };
  }

  /**
   * Defines a "ClusterExternalSecret" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(
    scope: Construct,
    id: string,
    props: ClusterExternalSecretProps = {},
  ) {
    super(scope, id, {
      ...ClusterExternalSecret.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ClusterExternalSecret.GVK,
      ...toJson_ClusterExternalSecretProps(resolved),
    };
  }
}

/**
 * ClusterExternalSecret is the Schema for the clusterexternalsecrets API.
 *
 * @schema ClusterExternalSecret
 */
export interface ClusterExternalSecretProps {
  /**
   * @schema ClusterExternalSecret#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ClusterExternalSecretSpec defines the desired state of ClusterExternalSecret.
   *
   * @schema ClusterExternalSecret#spec
   */
  readonly spec?: ClusterExternalSecretSpec;
}

/**
 * Converts an object of type 'ClusterExternalSecretProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterExternalSecretProps(
  obj: ClusterExternalSecretProps | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    spec: toJson_ClusterExternalSecretSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ClusterExternalSecretSpec defines the desired state of ClusterExternalSecret.
 *
 * @schema ClusterExternalSecretSpec
 */
export interface ClusterExternalSecretSpec {
  /**
   * The metadata of the external secrets to be created
   *
   * @schema ClusterExternalSecretSpec#externalSecretMetadata
   */
  readonly externalSecretMetadata?: ClusterExternalSecretSpecExternalSecretMetadata;

  /**
   * The name of the external secrets to be created defaults to the name of the ClusterExternalSecret
   *
   * @schema ClusterExternalSecretSpec#externalSecretName
   */
  readonly externalSecretName?: string;

  /**
   * The spec for the ExternalSecrets to be created
   *
   * @schema ClusterExternalSecretSpec#externalSecretSpec
   */
  readonly externalSecretSpec: ClusterExternalSecretSpecExternalSecretSpec;

  /**
   * The labels to select by to find the Namespaces to create the ExternalSecrets in.
   *
   * @schema ClusterExternalSecretSpec#namespaceSelector
   */
  readonly namespaceSelector?: ClusterExternalSecretSpecNamespaceSelector;

  /**
   * Choose namespaces by name. This field is ORed with anything that NamespaceSelector ends up choosing.
   *
   * @schema ClusterExternalSecretSpec#namespaces
   */
  readonly namespaces?: string[];

  /**
   * The time in which the controller should reconcile its objects and recheck namespaces for labels.
   *
   * @schema ClusterExternalSecretSpec#refreshTime
   */
  readonly refreshTime?: string;
}

/**
 * Converts an object of type 'ClusterExternalSecretSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterExternalSecretSpec(
  obj: ClusterExternalSecretSpec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    externalSecretMetadata:
      toJson_ClusterExternalSecretSpecExternalSecretMetadata(
        obj.externalSecretMetadata,
      ),
    externalSecretName: obj.externalSecretName,
    externalSecretSpec: toJson_ClusterExternalSecretSpecExternalSecretSpec(
      obj.externalSecretSpec,
    ),
    namespaceSelector: toJson_ClusterExternalSecretSpecNamespaceSelector(
      obj.namespaceSelector,
    ),
    namespaces: obj.namespaces?.map((y) => y),
    refreshTime: obj.refreshTime,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The metadata of the external secrets to be created
 *
 * @schema ClusterExternalSecretSpecExternalSecretMetadata
 */
export interface ClusterExternalSecretSpecExternalSecretMetadata {
  /**
   * @schema ClusterExternalSecretSpecExternalSecretMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * @schema ClusterExternalSecretSpecExternalSecretMetadata#labels
   */
  readonly labels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ClusterExternalSecretSpecExternalSecretMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterExternalSecretSpecExternalSecretMetadata(
  obj: ClusterExternalSecretSpecExternalSecretMetadata | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    annotations:
      obj.annotations === undefined
        ? undefined
        : Object.entries(obj.annotations).reduce(
            (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
            {},
          ),
    labels:
      obj.labels === undefined
        ? undefined
        : Object.entries(obj.labels).reduce(
            (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
            {},
          ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The spec for the ExternalSecrets to be created
 *
 * @schema ClusterExternalSecretSpecExternalSecretSpec
 */
export interface ClusterExternalSecretSpecExternalSecretSpec {
  /**
   * Data defines the connection between the Kubernetes Secret keys and the Provider data
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpec#data
   */
  readonly data?: ClusterExternalSecretSpecExternalSecretSpecData[];

  /**
   * DataFrom is used to fetch all properties from a specific Provider data If multiple entries are specified, the Secret keys are merged in the specified order
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpec#dataFrom
   */
  readonly dataFrom?: ClusterExternalSecretSpecExternalSecretSpecDataFrom[];

  /**
   * RefreshInterval is the amount of time before the values are read again from the SecretStore provider Valid time units are "ns", "us" (or "Âµs"), "ms", "s", "m", "h" May be set to zero to fetch and create it once. Defaults to 1h.
   *
   * @default 1h.
   * @schema ClusterExternalSecretSpecExternalSecretSpec#refreshInterval
   */
  readonly refreshInterval?: string;

  /**
   * SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpec#secretStoreRef
   */
  readonly secretStoreRef?: ClusterExternalSecretSpecExternalSecretSpecSecretStoreRef;

  /**
   * ExternalSecretTarget defines the Kubernetes Secret to be created There can be only one target per ExternalSecret.
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpec#target
   */
  readonly target?: ClusterExternalSecretSpecExternalSecretSpecTarget;
}

/**
 * Converts an object of type 'ClusterExternalSecretSpecExternalSecretSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterExternalSecretSpecExternalSecretSpec(
  obj: ClusterExternalSecretSpecExternalSecretSpec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    data: obj.data?.map((y) =>
      toJson_ClusterExternalSecretSpecExternalSecretSpecData(y),
    ),
    dataFrom: obj.dataFrom?.map((y) =>
      toJson_ClusterExternalSecretSpecExternalSecretSpecDataFrom(y),
    ),
    refreshInterval: obj.refreshInterval,
    secretStoreRef:
      toJson_ClusterExternalSecretSpecExternalSecretSpecSecretStoreRef(
        obj.secretStoreRef,
      ),
    target: toJson_ClusterExternalSecretSpecExternalSecretSpecTarget(
      obj.target,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The labels to select by to find the Namespaces to create the ExternalSecrets in.
 *
 * @schema ClusterExternalSecretSpecNamespaceSelector
 */
export interface ClusterExternalSecretSpecNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterExternalSecretSpecNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterExternalSecretSpecNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterExternalSecretSpecNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ClusterExternalSecretSpecNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterExternalSecretSpecNamespaceSelector(
  obj: ClusterExternalSecretSpecNamespaceSelector | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) =>
      toJson_ClusterExternalSecretSpecNamespaceSelectorMatchExpressions(y),
    ),
    matchLabels:
      obj.matchLabels === undefined
        ? undefined
        : Object.entries(obj.matchLabels).reduce(
            (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
            {},
          ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ExternalSecretData defines the connection between the Kubernetes Secret key (spec.data.<key>) and the Provider data.
 *
 * @schema ClusterExternalSecretSpecExternalSecretSpecData
 */
export interface ClusterExternalSecretSpecExternalSecretSpecData {
  /**
   * RemoteRef points to the remote secret and defines which secret (version/property/..) to fetch.
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecData#remoteRef
   */
  readonly remoteRef: ClusterExternalSecretSpecExternalSecretSpecDataRemoteRef;

  /**
   * SecretKey defines the key in which the controller stores the value. This is the key in the Kind=Secret
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecData#secretKey
   */
  readonly secretKey: string;

  /**
   * SourceRef allows you to override the source from which the value will pulled from.
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecData#sourceRef
   */
  readonly sourceRef?: ClusterExternalSecretSpecExternalSecretSpecDataSourceRef;
}

/**
 * Converts an object of type 'ClusterExternalSecretSpecExternalSecretSpecData' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterExternalSecretSpecExternalSecretSpecData(
  obj: ClusterExternalSecretSpecExternalSecretSpecData | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    remoteRef: toJson_ClusterExternalSecretSpecExternalSecretSpecDataRemoteRef(
      obj.remoteRef,
    ),
    secretKey: obj.secretKey,
    sourceRef: toJson_ClusterExternalSecretSpecExternalSecretSpecDataSourceRef(
      obj.sourceRef,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterExternalSecretSpecExternalSecretSpecDataFrom
 */
export interface ClusterExternalSecretSpecExternalSecretSpecDataFrom {
  /**
   * Used to extract multiple key/value pairs from one secret Note: Extract does not support sourceRef.Generator or sourceRef.GeneratorRef.
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataFrom#extract
   */
  readonly extract?: ClusterExternalSecretSpecExternalSecretSpecDataFromExtract;

  /**
   * Used to find secrets based on tags or regular expressions Note: Find does not support sourceRef.Generator or sourceRef.GeneratorRef.
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataFrom#find
   */
  readonly find?: ClusterExternalSecretSpecExternalSecretSpecDataFromFind;

  /**
   * Used to rewrite secret Keys after getting them from the secret Provider Multiple Rewrite operations can be provided. They are applied in a layered order (first to last)
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataFrom#rewrite
   */
  readonly rewrite?: ClusterExternalSecretSpecExternalSecretSpecDataFromRewrite[];

  /**
   * SourceRef points to a store or generator which contains secret values ready to use. Use this in combination with Extract or Find pull values out of a specific SecretStore. When sourceRef points to a generator Extract or Find is not supported. The generator returns a static map of values
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataFrom#sourceRef
   */
  readonly sourceRef?: ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRef;
}

/**
 * Converts an object of type 'ClusterExternalSecretSpecExternalSecretSpecDataFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterExternalSecretSpecExternalSecretSpecDataFrom(
  obj: ClusterExternalSecretSpecExternalSecretSpecDataFrom | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    extract: toJson_ClusterExternalSecretSpecExternalSecretSpecDataFromExtract(
      obj.extract,
    ),
    find: toJson_ClusterExternalSecretSpecExternalSecretSpecDataFromFind(
      obj.find,
    ),
    rewrite: obj.rewrite?.map((y) =>
      toJson_ClusterExternalSecretSpecExternalSecretSpecDataFromRewrite(y),
    ),
    sourceRef:
      toJson_ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRef(
        obj.sourceRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.
 *
 * @schema ClusterExternalSecretSpecExternalSecretSpecSecretStoreRef
 */
export interface ClusterExternalSecretSpecExternalSecretSpecSecretStoreRef {
  /**
   * Kind of the SecretStore resource (SecretStore or ClusterSecretStore) Defaults to `SecretStore`
   *
   * @default SecretStore`
   * @schema ClusterExternalSecretSpecExternalSecretSpecSecretStoreRef#kind
   */
  readonly kind?: string;

  /**
   * Name of the SecretStore resource
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecSecretStoreRef#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ClusterExternalSecretSpecExternalSecretSpecSecretStoreRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterExternalSecretSpecExternalSecretSpecSecretStoreRef(
  obj: ClusterExternalSecretSpecExternalSecretSpecSecretStoreRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    kind: obj.kind,
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ExternalSecretTarget defines the Kubernetes Secret to be created There can be only one target per ExternalSecret.
 *
 * @schema ClusterExternalSecretSpecExternalSecretSpecTarget
 */
export interface ClusterExternalSecretSpecExternalSecretSpecTarget {
  /**
   * CreationPolicy defines rules on how to create the resulting Secret Defaults to 'Owner'
   *
   * @default Owner'
   * @schema ClusterExternalSecretSpecExternalSecretSpecTarget#creationPolicy
   */
  readonly creationPolicy?: ClusterExternalSecretSpecExternalSecretSpecTargetCreationPolicy;

  /**
   * DeletionPolicy defines rules on how to delete the resulting Secret Defaults to 'Retain'
   *
   * @default Retain'
   * @schema ClusterExternalSecretSpecExternalSecretSpecTarget#deletionPolicy
   */
  readonly deletionPolicy?: ClusterExternalSecretSpecExternalSecretSpecTargetDeletionPolicy;

  /**
   * Immutable defines if the final secret will be immutable
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecTarget#immutable
   */
  readonly immutable?: boolean;

  /**
   * Name defines the name of the Secret resource to be managed This field is immutable Defaults to the .metadata.name of the ExternalSecret resource
   *
   * @default the .metadata.name of the ExternalSecret resource
   * @schema ClusterExternalSecretSpecExternalSecretSpecTarget#name
   */
  readonly name?: string;

  /**
   * Template defines a blueprint for the created Secret resource.
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecTarget#template
   */
  readonly template?: ClusterExternalSecretSpecExternalSecretSpecTargetTemplate;
}

/**
 * Converts an object of type 'ClusterExternalSecretSpecExternalSecretSpecTarget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterExternalSecretSpecExternalSecretSpecTarget(
  obj: ClusterExternalSecretSpecExternalSecretSpecTarget | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    creationPolicy: obj.creationPolicy,
    deletionPolicy: obj.deletionPolicy,
    immutable: obj.immutable,
    name: obj.name,
    template: toJson_ClusterExternalSecretSpecExternalSecretSpecTargetTemplate(
      obj.template,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema ClusterExternalSecretSpecNamespaceSelectorMatchExpressions
 */
export interface ClusterExternalSecretSpecNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterExternalSecretSpecNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterExternalSecretSpecNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema ClusterExternalSecretSpecNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ClusterExternalSecretSpecNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterExternalSecretSpecNamespaceSelectorMatchExpressions(
  obj: ClusterExternalSecretSpecNamespaceSelectorMatchExpressions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * RemoteRef points to the remote secret and defines which secret (version/property/..) to fetch.
 *
 * @schema ClusterExternalSecretSpecExternalSecretSpecDataRemoteRef
 */
export interface ClusterExternalSecretSpecExternalSecretSpecDataRemoteRef {
  /**
   * Used to define a conversion Strategy
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataRemoteRef#conversionStrategy
   */
  readonly conversionStrategy?: ClusterExternalSecretSpecExternalSecretSpecDataRemoteRefConversionStrategy;

  /**
   * Used to define a decoding Strategy
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataRemoteRef#decodingStrategy
   */
  readonly decodingStrategy?: ClusterExternalSecretSpecExternalSecretSpecDataRemoteRefDecodingStrategy;

  /**
   * Key is the key used in the Provider, mandatory
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataRemoteRef#key
   */
  readonly key: string;

  /**
   * Policy for fetching tags/labels from provider secrets, possible options are Fetch, None. Defaults to None
   *
   * @default None
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataRemoteRef#metadataPolicy
   */
  readonly metadataPolicy?: ClusterExternalSecretSpecExternalSecretSpecDataRemoteRefMetadataPolicy;

  /**
   * Used to select a specific property of the Provider value (if a map), if supported
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataRemoteRef#property
   */
  readonly property?: string;

  /**
   * Used to select a specific version of the Provider value, if supported
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataRemoteRef#version
   */
  readonly version?: string;
}

/**
 * Converts an object of type 'ClusterExternalSecretSpecExternalSecretSpecDataRemoteRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterExternalSecretSpecExternalSecretSpecDataRemoteRef(
  obj: ClusterExternalSecretSpecExternalSecretSpecDataRemoteRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    conversionStrategy: obj.conversionStrategy,
    decodingStrategy: obj.decodingStrategy,
    key: obj.key,
    metadataPolicy: obj.metadataPolicy,
    property: obj.property,
    version: obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * SourceRef allows you to override the source from which the value will pulled from.
 *
 * @schema ClusterExternalSecretSpecExternalSecretSpecDataSourceRef
 */
export interface ClusterExternalSecretSpecExternalSecretSpecDataSourceRef {
  /**
   * GeneratorRef points to a generator custom resource.
   * Deprecated: The generatorRef is not implemented in .data[]. this will be removed with v1.
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataSourceRef#generatorRef
   */
  readonly generatorRef?: ClusterExternalSecretSpecExternalSecretSpecDataSourceRefGeneratorRef;

  /**
   * SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataSourceRef#storeRef
   */
  readonly storeRef?: ClusterExternalSecretSpecExternalSecretSpecDataSourceRefStoreRef;
}

/**
 * Converts an object of type 'ClusterExternalSecretSpecExternalSecretSpecDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterExternalSecretSpecExternalSecretSpecDataSourceRef(
  obj: ClusterExternalSecretSpecExternalSecretSpecDataSourceRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    generatorRef:
      toJson_ClusterExternalSecretSpecExternalSecretSpecDataSourceRefGeneratorRef(
        obj.generatorRef,
      ),
    storeRef:
      toJson_ClusterExternalSecretSpecExternalSecretSpecDataSourceRefStoreRef(
        obj.storeRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Used to extract multiple key/value pairs from one secret Note: Extract does not support sourceRef.Generator or sourceRef.GeneratorRef.
 *
 * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromExtract
 */
export interface ClusterExternalSecretSpecExternalSecretSpecDataFromExtract {
  /**
   * Used to define a conversion Strategy
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromExtract#conversionStrategy
   */
  readonly conversionStrategy?: ClusterExternalSecretSpecExternalSecretSpecDataFromExtractConversionStrategy;

  /**
   * Used to define a decoding Strategy
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromExtract#decodingStrategy
   */
  readonly decodingStrategy?: ClusterExternalSecretSpecExternalSecretSpecDataFromExtractDecodingStrategy;

  /**
   * Key is the key used in the Provider, mandatory
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromExtract#key
   */
  readonly key: string;

  /**
   * Policy for fetching tags/labels from provider secrets, possible options are Fetch, None. Defaults to None
   *
   * @default None
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromExtract#metadataPolicy
   */
  readonly metadataPolicy?: ClusterExternalSecretSpecExternalSecretSpecDataFromExtractMetadataPolicy;

  /**
   * Used to select a specific property of the Provider value (if a map), if supported
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromExtract#property
   */
  readonly property?: string;

  /**
   * Used to select a specific version of the Provider value, if supported
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromExtract#version
   */
  readonly version?: string;
}

/**
 * Converts an object of type 'ClusterExternalSecretSpecExternalSecretSpecDataFromExtract' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterExternalSecretSpecExternalSecretSpecDataFromExtract(
  obj: ClusterExternalSecretSpecExternalSecretSpecDataFromExtract | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    conversionStrategy: obj.conversionStrategy,
    decodingStrategy: obj.decodingStrategy,
    key: obj.key,
    metadataPolicy: obj.metadataPolicy,
    property: obj.property,
    version: obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Used to find secrets based on tags or regular expressions Note: Find does not support sourceRef.Generator or sourceRef.GeneratorRef.
 *
 * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromFind
 */
export interface ClusterExternalSecretSpecExternalSecretSpecDataFromFind {
  /**
   * Used to define a conversion Strategy
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromFind#conversionStrategy
   */
  readonly conversionStrategy?: ClusterExternalSecretSpecExternalSecretSpecDataFromFindConversionStrategy;

  /**
   * Used to define a decoding Strategy
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromFind#decodingStrategy
   */
  readonly decodingStrategy?: ClusterExternalSecretSpecExternalSecretSpecDataFromFindDecodingStrategy;

  /**
   * Finds secrets based on the name.
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromFind#name
   */
  readonly name?: ClusterExternalSecretSpecExternalSecretSpecDataFromFindName;

  /**
   * A root path to start the find operations.
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromFind#path
   */
  readonly path?: string;

  /**
   * Find secrets based on tags.
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromFind#tags
   */
  readonly tags?: { [key: string]: string };
}

/**
 * Converts an object of type 'ClusterExternalSecretSpecExternalSecretSpecDataFromFind' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterExternalSecretSpecExternalSecretSpecDataFromFind(
  obj: ClusterExternalSecretSpecExternalSecretSpecDataFromFind | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    conversionStrategy: obj.conversionStrategy,
    decodingStrategy: obj.decodingStrategy,
    name: toJson_ClusterExternalSecretSpecExternalSecretSpecDataFromFindName(
      obj.name,
    ),
    path: obj.path,
    tags:
      obj.tags === undefined
        ? undefined
        : Object.entries(obj.tags).reduce(
            (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
            {},
          ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromRewrite
 */
export interface ClusterExternalSecretSpecExternalSecretSpecDataFromRewrite {
  /**
   * Used to rewrite with regular expressions. The resulting key will be the output of a regexp.ReplaceAll operation.
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromRewrite#regexp
   */
  readonly regexp?: ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteRegexp;

  /**
   * Used to apply string transformation on the secrets. The resulting key will be the output of the template applied by the operation.
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromRewrite#transform
   */
  readonly transform?: ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteTransform;
}

/**
 * Converts an object of type 'ClusterExternalSecretSpecExternalSecretSpecDataFromRewrite' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterExternalSecretSpecExternalSecretSpecDataFromRewrite(
  obj: ClusterExternalSecretSpecExternalSecretSpecDataFromRewrite | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    regexp:
      toJson_ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteRegexp(
        obj.regexp,
      ),
    transform:
      toJson_ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteTransform(
        obj.transform,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * SourceRef points to a store or generator which contains secret values ready to use. Use this in combination with Extract or Find pull values out of a specific SecretStore. When sourceRef points to a generator Extract or Find is not supported. The generator returns a static map of values
 *
 * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRef
 */
export interface ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRef {
  /**
   * GeneratorRef points to a generator custom resource.
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRef#generatorRef
   */
  readonly generatorRef?: ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefGeneratorRef;

  /**
   * SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRef#storeRef
   */
  readonly storeRef?: ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefStoreRef;
}

/**
 * Converts an object of type 'ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRef(
  obj: ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    generatorRef:
      toJson_ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefGeneratorRef(
        obj.generatorRef,
      ),
    storeRef:
      toJson_ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefStoreRef(
        obj.storeRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * CreationPolicy defines rules on how to create the resulting Secret Defaults to 'Owner'
 *
 * @default Owner'
 * @schema ClusterExternalSecretSpecExternalSecretSpecTargetCreationPolicy
 */
export enum ClusterExternalSecretSpecExternalSecretSpecTargetCreationPolicy {
  /** Owner */
  OWNER = "Owner",
  /** Orphan */
  ORPHAN = "Orphan",
  /** Merge */
  MERGE = "Merge",
  /** None */
  NONE = "None",
}

/**
 * DeletionPolicy defines rules on how to delete the resulting Secret Defaults to 'Retain'
 *
 * @default Retain'
 * @schema ClusterExternalSecretSpecExternalSecretSpecTargetDeletionPolicy
 */
export enum ClusterExternalSecretSpecExternalSecretSpecTargetDeletionPolicy {
  /** Delete */
  DELETE = "Delete",
  /** Merge */
  MERGE = "Merge",
  /** Retain */
  RETAIN = "Retain",
}

/**
 * Template defines a blueprint for the created Secret resource.
 *
 * @schema ClusterExternalSecretSpecExternalSecretSpecTargetTemplate
 */
export interface ClusterExternalSecretSpecExternalSecretSpecTargetTemplate {
  /**
   * @schema ClusterExternalSecretSpecExternalSecretSpecTargetTemplate#data
   */
  readonly data?: { [key: string]: string };

  /**
   * EngineVersion specifies the template engine version that should be used to compile/execute the template specified in .data and .templateFrom[].
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecTargetTemplate#engineVersion
   */
  readonly engineVersion?: ClusterExternalSecretSpecExternalSecretSpecTargetTemplateEngineVersion;

  /**
   * @schema ClusterExternalSecretSpecExternalSecretSpecTargetTemplate#mergePolicy
   */
  readonly mergePolicy?: ClusterExternalSecretSpecExternalSecretSpecTargetTemplateMergePolicy;

  /**
   * ExternalSecretTemplateMetadata defines metadata fields for the Secret blueprint.
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecTargetTemplate#metadata
   */
  readonly metadata?: ClusterExternalSecretSpecExternalSecretSpecTargetTemplateMetadata;

  /**
   * @schema ClusterExternalSecretSpecExternalSecretSpecTargetTemplate#templateFrom
   */
  readonly templateFrom?: ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFrom[];

  /**
   * @schema ClusterExternalSecretSpecExternalSecretSpecTargetTemplate#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'ClusterExternalSecretSpecExternalSecretSpecTargetTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterExternalSecretSpecExternalSecretSpecTargetTemplate(
  obj: ClusterExternalSecretSpecExternalSecretSpecTargetTemplate | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    data:
      obj.data === undefined
        ? undefined
        : Object.entries(obj.data).reduce(
            (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
            {},
          ),
    engineVersion: obj.engineVersion,
    mergePolicy: obj.mergePolicy,
    metadata:
      toJson_ClusterExternalSecretSpecExternalSecretSpecTargetTemplateMetadata(
        obj.metadata,
      ),
    templateFrom: obj.templateFrom?.map((y) =>
      toJson_ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFrom(
        y,
      ),
    ),
    type: obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Used to define a conversion Strategy
 *
 * @schema ClusterExternalSecretSpecExternalSecretSpecDataRemoteRefConversionStrategy
 */
export enum ClusterExternalSecretSpecExternalSecretSpecDataRemoteRefConversionStrategy {
  /** Default */
  DEFAULT = "Default",
  /** Unicode */
  UNICODE = "Unicode",
}

/**
 * Used to define a decoding Strategy
 *
 * @schema ClusterExternalSecretSpecExternalSecretSpecDataRemoteRefDecodingStrategy
 */
export enum ClusterExternalSecretSpecExternalSecretSpecDataRemoteRefDecodingStrategy {
  /** Auto */
  AUTO = "Auto",
  /** Base64 */
  BASE64 = "Base64",
  /** Base64URL */
  BASE64_URL = "Base64URL",
  /** None */
  NONE = "None",
}

/**
 * Policy for fetching tags/labels from provider secrets, possible options are Fetch, None. Defaults to None
 *
 * @default None
 * @schema ClusterExternalSecretSpecExternalSecretSpecDataRemoteRefMetadataPolicy
 */
export enum ClusterExternalSecretSpecExternalSecretSpecDataRemoteRefMetadataPolicy {
  /** None */
  NONE = "None",
  /** Fetch */
  FETCH = "Fetch",
}

/**
 * GeneratorRef points to a generator custom resource.
 * Deprecated: The generatorRef is not implemented in .data[]. this will be removed with v1.
 *
 * @schema ClusterExternalSecretSpecExternalSecretSpecDataSourceRefGeneratorRef
 */
export interface ClusterExternalSecretSpecExternalSecretSpecDataSourceRefGeneratorRef {
  /**
   * Specify the apiVersion of the generator resource
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataSourceRefGeneratorRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Specify the Kind of the resource, e.g. Password, ACRAccessToken etc.
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataSourceRefGeneratorRef#kind
   */
  readonly kind: string;

  /**
   * Specify the name of the generator resource
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataSourceRefGeneratorRef#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ClusterExternalSecretSpecExternalSecretSpecDataSourceRefGeneratorRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterExternalSecretSpecExternalSecretSpecDataSourceRefGeneratorRef(
  obj:
    | ClusterExternalSecretSpecExternalSecretSpecDataSourceRefGeneratorRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    apiVersion: obj.apiVersion,
    kind: obj.kind,
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.
 *
 * @schema ClusterExternalSecretSpecExternalSecretSpecDataSourceRefStoreRef
 */
export interface ClusterExternalSecretSpecExternalSecretSpecDataSourceRefStoreRef {
  /**
   * Kind of the SecretStore resource (SecretStore or ClusterSecretStore) Defaults to `SecretStore`
   *
   * @default SecretStore`
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataSourceRefStoreRef#kind
   */
  readonly kind?: string;

  /**
   * Name of the SecretStore resource
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataSourceRefStoreRef#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ClusterExternalSecretSpecExternalSecretSpecDataSourceRefStoreRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterExternalSecretSpecExternalSecretSpecDataSourceRefStoreRef(
  obj:
    | ClusterExternalSecretSpecExternalSecretSpecDataSourceRefStoreRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    kind: obj.kind,
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Used to define a conversion Strategy
 *
 * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromExtractConversionStrategy
 */
export enum ClusterExternalSecretSpecExternalSecretSpecDataFromExtractConversionStrategy {
  /** Default */
  DEFAULT = "Default",
  /** Unicode */
  UNICODE = "Unicode",
}

/**
 * Used to define a decoding Strategy
 *
 * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromExtractDecodingStrategy
 */
export enum ClusterExternalSecretSpecExternalSecretSpecDataFromExtractDecodingStrategy {
  /** Auto */
  AUTO = "Auto",
  /** Base64 */
  BASE64 = "Base64",
  /** Base64URL */
  BASE64_URL = "Base64URL",
  /** None */
  NONE = "None",
}

/**
 * Policy for fetching tags/labels from provider secrets, possible options are Fetch, None. Defaults to None
 *
 * @default None
 * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromExtractMetadataPolicy
 */
export enum ClusterExternalSecretSpecExternalSecretSpecDataFromExtractMetadataPolicy {
  /** None */
  NONE = "None",
  /** Fetch */
  FETCH = "Fetch",
}

/**
 * Used to define a conversion Strategy
 *
 * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromFindConversionStrategy
 */
export enum ClusterExternalSecretSpecExternalSecretSpecDataFromFindConversionStrategy {
  /** Default */
  DEFAULT = "Default",
  /** Unicode */
  UNICODE = "Unicode",
}

/**
 * Used to define a decoding Strategy
 *
 * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromFindDecodingStrategy
 */
export enum ClusterExternalSecretSpecExternalSecretSpecDataFromFindDecodingStrategy {
  /** Auto */
  AUTO = "Auto",
  /** Base64 */
  BASE64 = "Base64",
  /** Base64URL */
  BASE64_URL = "Base64URL",
  /** None */
  NONE = "None",
}

/**
 * Finds secrets based on the name.
 *
 * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromFindName
 */
export interface ClusterExternalSecretSpecExternalSecretSpecDataFromFindName {
  /**
   * Finds secrets base
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromFindName#regexp
   */
  readonly regexp?: string;
}

/**
 * Converts an object of type 'ClusterExternalSecretSpecExternalSecretSpecDataFromFindName' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterExternalSecretSpecExternalSecretSpecDataFromFindName(
  obj: ClusterExternalSecretSpecExternalSecretSpecDataFromFindName | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    regexp: obj.regexp,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Used to rewrite with regular expressions. The resulting key will be the output of a regexp.ReplaceAll operation.
 *
 * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteRegexp
 */
export interface ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteRegexp {
  /**
   * Used to define the regular expression of a re.Compiler.
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteRegexp#source
   */
  readonly source: string;

  /**
   * Used to define the target pattern of a ReplaceAll operation.
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteRegexp#target
   */
  readonly target: string;
}

/**
 * Converts an object of type 'ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteRegexp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteRegexp(
  obj:
    | ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteRegexp
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    source: obj.source,
    target: obj.target,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Used to apply string transformation on the secrets. The resulting key will be the output of the template applied by the operation.
 *
 * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteTransform
 */
export interface ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteTransform {
  /**
   * Used to define the template to apply on the secret name. `.value ` will specify the secret name in the template.
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteTransform#template
   */
  readonly template: string;
}

/**
 * Converts an object of type 'ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteTransform' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteTransform(
  obj:
    | ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteTransform
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    template: obj.template,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * GeneratorRef points to a generator custom resource.
 *
 * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefGeneratorRef
 */
export interface ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefGeneratorRef {
  /**
   * Specify the apiVersion of the generator resource
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefGeneratorRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Specify the Kind of the resource, e.g. Password, ACRAccessToken etc.
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefGeneratorRef#kind
   */
  readonly kind: string;

  /**
   * Specify the name of the generator resource
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefGeneratorRef#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefGeneratorRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefGeneratorRef(
  obj:
    | ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefGeneratorRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    apiVersion: obj.apiVersion,
    kind: obj.kind,
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.
 *
 * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefStoreRef
 */
export interface ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefStoreRef {
  /**
   * Kind of the SecretStore resource (SecretStore or ClusterSecretStore) Defaults to `SecretStore`
   *
   * @default SecretStore`
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefStoreRef#kind
   */
  readonly kind?: string;

  /**
   * Name of the SecretStore resource
   *
   * @schema ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefStoreRef#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefStoreRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefStoreRef(
  obj:
    | ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefStoreRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    kind: obj.kind,
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * EngineVersion specifies the template engine version that should be used to compile/execute the template specified in .data and .templateFrom[].
 *
 * @schema ClusterExternalSecretSpecExternalSecretSpecTargetTemplateEngineVersion
 */
export enum ClusterExternalSecretSpecExternalSecretSpecTargetTemplateEngineVersion {
  /** v1 */
  V1 = "v1",
  /** v2 */
  V2 = "v2",
}

/**
 * @schema ClusterExternalSecretSpecExternalSecretSpecTargetTemplateMergePolicy
 */
export enum ClusterExternalSecretSpecExternalSecretSpecTargetTemplateMergePolicy {
  /** Replace */
  REPLACE = "Replace",
  /** Merge */
  MERGE = "Merge",
}

/**
 * ExternalSecretTemplateMetadata defines metadata fields for the Secret blueprint.
 *
 * @schema ClusterExternalSecretSpecExternalSecretSpecTargetTemplateMetadata
 */
export interface ClusterExternalSecretSpecExternalSecretSpecTargetTemplateMetadata {
  /**
   * @schema ClusterExternalSecretSpecExternalSecretSpecTargetTemplateMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * @schema ClusterExternalSecretSpecExternalSecretSpecTargetTemplateMetadata#labels
   */
  readonly labels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ClusterExternalSecretSpecExternalSecretSpecTargetTemplateMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterExternalSecretSpecExternalSecretSpecTargetTemplateMetadata(
  obj:
    | ClusterExternalSecretSpecExternalSecretSpecTargetTemplateMetadata
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    annotations:
      obj.annotations === undefined
        ? undefined
        : Object.entries(obj.annotations).reduce(
            (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
            {},
          ),
    labels:
      obj.labels === undefined
        ? undefined
        : Object.entries(obj.labels).reduce(
            (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
            {},
          ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFrom
 */
export interface ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFrom {
  /**
   * @schema ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFrom#configMap
   */
  readonly configMap?: ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMap;

  /**
   * @schema ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFrom#literal
   */
  readonly literal?: string;

  /**
   * @schema ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFrom#secret
   */
  readonly secret?: ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecret;

  /**
   * @schema ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFrom#target
   */
  readonly target?: ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromTarget;
}

/**
 * Converts an object of type 'ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFrom(
  obj:
    | ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFrom
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    configMap:
      toJson_ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMap(
        obj.configMap,
      ),
    literal: obj.literal,
    secret:
      toJson_ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecret(
        obj.secret,
      ),
    target: obj.target,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMap
 */
export interface ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMap {
  /**
   * @schema ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMap#items
   */
  readonly items: ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMapItems[];

  /**
   * @schema ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMap#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMap(
  obj:
    | ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMap
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    items: obj.items?.map((y) =>
      toJson_ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMapItems(
        y,
      ),
    ),
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecret
 */
export interface ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecret {
  /**
   * @schema ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecret#items
   */
  readonly items: ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecretItems[];

  /**
   * @schema ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecret#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecret(
  obj:
    | ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    items: obj.items?.map((y) =>
      toJson_ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecretItems(
        y,
      ),
    ),
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromTarget
 */
export enum ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromTarget {
  /** Data */
  DATA = "Data",
  /** Annotations */
  ANNOTATIONS = "Annotations",
  /** Labels */
  LABELS = "Labels",
}

/**
 * @schema ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMapItems
 */
export interface ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMapItems {
  /**
   * @schema ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMapItems#key
   */
  readonly key: string;

  /**
   * @schema ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMapItems#templateAs
   */
  readonly templateAs?: ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMapItemsTemplateAs;
}

/**
 * Converts an object of type 'ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMapItems(
  obj:
    | ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMapItems
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    templateAs: obj.templateAs,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecretItems
 */
export interface ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecretItems {
  /**
   * @schema ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecretItems#key
   */
  readonly key: string;

  /**
   * @schema ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecretItems#templateAs
   */
  readonly templateAs?: ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecretItemsTemplateAs;
}

/**
 * Converts an object of type 'ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecretItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecretItems(
  obj:
    | ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecretItems
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    templateAs: obj.templateAs,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMapItemsTemplateAs
 */
export enum ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMapItemsTemplateAs {
  /** Values */
  VALUES = "Values",
  /** KeysAndValues */
  KEYS_AND_VALUES = "KeysAndValues",
}

/**
 * @schema ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecretItemsTemplateAs
 */
export enum ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecretItemsTemplateAs {
  /** Values */
  VALUES = "Values",
  /** KeysAndValues */
  KEYS_AND_VALUES = "KeysAndValues",
}

/**
 * ClusterSecretStore represents a secure external location for storing secrets, which can be referenced as part of `storeRef` fields.
 *
 * @schema ClusterSecretStore
 */
export class ClusterSecretStore extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ClusterSecretStore"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "external-secrets.io/v1alpha1",
    kind: "ClusterSecretStore",
  };

  /**
   * Renders a Kubernetes manifest for "ClusterSecretStore".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ClusterSecretStoreProps = {}): any {
    return {
      ...ClusterSecretStore.GVK,
      ...toJson_ClusterSecretStoreProps(props),
    };
  }

  /**
   * Defines a "ClusterSecretStore" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(
    scope: Construct,
    id: string,
    props: ClusterSecretStoreProps = {},
  ) {
    super(scope, id, {
      ...ClusterSecretStore.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ClusterSecretStore.GVK,
      ...toJson_ClusterSecretStoreProps(resolved),
    };
  }
}

/**
 * ClusterSecretStore represents a secure external location for storing secrets, which can be referenced as part of `storeRef` fields.
 *
 * @schema ClusterSecretStore
 */
export interface ClusterSecretStoreProps {
  /**
   * @schema ClusterSecretStore#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * SecretStoreSpec defines the desired state of SecretStore.
   *
   * @schema ClusterSecretStore#spec
   */
  readonly spec?: ClusterSecretStoreSpec;
}

/**
 * Converts an object of type 'ClusterSecretStoreProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreProps(
  obj: ClusterSecretStoreProps | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    spec: toJson_ClusterSecretStoreSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreSpec defines the desired state of SecretStore.
 *
 * @schema ClusterSecretStoreSpec
 */
export interface ClusterSecretStoreSpec {
  /**
   * Used to select the correct ESO controller (think: ingress.ingressClassName) The ESO controller is instantiated with a specific controller name and filters ES based on this property
   *
   * @schema ClusterSecretStoreSpec#controller
   */
  readonly controller?: string;

  /**
   * Used to configure the provider. Only one provider may be set
   *
   * @schema ClusterSecretStoreSpec#provider
   */
  readonly provider: ClusterSecretStoreSpecProvider;

  /**
   * Used to configure http retries if failed
   *
   * @schema ClusterSecretStoreSpec#retrySettings
   */
  readonly retrySettings?: ClusterSecretStoreSpecRetrySettings;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpec(
  obj: ClusterSecretStoreSpec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    controller: obj.controller,
    provider: toJson_ClusterSecretStoreSpecProvider(obj.provider),
    retrySettings: toJson_ClusterSecretStoreSpecRetrySettings(
      obj.retrySettings,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Used to configure the provider. Only one provider may be set
 *
 * @schema ClusterSecretStoreSpecProvider
 */
export interface ClusterSecretStoreSpecProvider {
  /**
   * Akeyless configures this store to sync secrets using Akeyless Vault provider
   *
   * @schema ClusterSecretStoreSpecProvider#akeyless
   */
  readonly akeyless?: ClusterSecretStoreSpecProviderAkeyless;

  /**
   * Alibaba configures this store to sync secrets using Alibaba Cloud provider
   *
   * @schema ClusterSecretStoreSpecProvider#alibaba
   */
  readonly alibaba?: ClusterSecretStoreSpecProviderAlibaba;

  /**
   * AWS configures this store to sync secrets using AWS Secret Manager provider
   *
   * @schema ClusterSecretStoreSpecProvider#aws
   */
  readonly aws?: ClusterSecretStoreSpecProviderAws;

  /**
   * AzureKV configures this store to sync secrets using Azure Key Vault provider
   *
   * @schema ClusterSecretStoreSpecProvider#azurekv
   */
  readonly azurekv?: ClusterSecretStoreSpecProviderAzurekv;

  /**
   * Fake configures a store with static key/value pairs
   *
   * @schema ClusterSecretStoreSpecProvider#fake
   */
  readonly fake?: ClusterSecretStoreSpecProviderFake;

  /**
   * GCPSM configures this store to sync secrets using Google Cloud Platform Secret Manager provider
   *
   * @schema ClusterSecretStoreSpecProvider#gcpsm
   */
  readonly gcpsm?: ClusterSecretStoreSpecProviderGcpsm;

  /**
   * GitLab configures this store to sync secrets using GitLab Variables provider
   *
   * @schema ClusterSecretStoreSpecProvider#gitlab
   */
  readonly gitlab?: ClusterSecretStoreSpecProviderGitlab;

  /**
   * IBM configures this store to sync secrets using IBM Cloud provider
   *
   * @schema ClusterSecretStoreSpecProvider#ibm
   */
  readonly ibm?: ClusterSecretStoreSpecProviderIbm;

  /**
   * Kubernetes configures this store to sync secrets using a Kubernetes cluster provider
   *
   * @schema ClusterSecretStoreSpecProvider#kubernetes
   */
  readonly kubernetes?: ClusterSecretStoreSpecProviderKubernetes;

  /**
   * Oracle configures this store to sync secrets using Oracle Vault provider
   *
   * @schema ClusterSecretStoreSpecProvider#oracle
   */
  readonly oracle?: ClusterSecretStoreSpecProviderOracle;

  /**
   * Vault configures this store to sync secrets using Hashi provider
   *
   * @schema ClusterSecretStoreSpecProvider#vault
   */
  readonly vault?: ClusterSecretStoreSpecProviderVault;

  /**
   * Webhook configures this store to sync secrets using a generic templated webhook
   *
   * @schema ClusterSecretStoreSpecProvider#webhook
   */
  readonly webhook?: ClusterSecretStoreSpecProviderWebhook;

  /**
   * YandexLockbox configures this store to sync secrets using Yandex Lockbox provider
   *
   * @schema ClusterSecretStoreSpecProvider#yandexlockbox
   */
  readonly yandexlockbox?: ClusterSecretStoreSpecProviderYandexlockbox;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProvider(
  obj: ClusterSecretStoreSpecProvider | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    akeyless: toJson_ClusterSecretStoreSpecProviderAkeyless(obj.akeyless),
    alibaba: toJson_ClusterSecretStoreSpecProviderAlibaba(obj.alibaba),
    aws: toJson_ClusterSecretStoreSpecProviderAws(obj.aws),
    azurekv: toJson_ClusterSecretStoreSpecProviderAzurekv(obj.azurekv),
    fake: toJson_ClusterSecretStoreSpecProviderFake(obj.fake),
    gcpsm: toJson_ClusterSecretStoreSpecProviderGcpsm(obj.gcpsm),
    gitlab: toJson_ClusterSecretStoreSpecProviderGitlab(obj.gitlab),
    ibm: toJson_ClusterSecretStoreSpecProviderIbm(obj.ibm),
    kubernetes: toJson_ClusterSecretStoreSpecProviderKubernetes(obj.kubernetes),
    oracle: toJson_ClusterSecretStoreSpecProviderOracle(obj.oracle),
    vault: toJson_ClusterSecretStoreSpecProviderVault(obj.vault),
    webhook: toJson_ClusterSecretStoreSpecProviderWebhook(obj.webhook),
    yandexlockbox: toJson_ClusterSecretStoreSpecProviderYandexlockbox(
      obj.yandexlockbox,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Used to configure http retries if failed
 *
 * @schema ClusterSecretStoreSpecRetrySettings
 */
export interface ClusterSecretStoreSpecRetrySettings {
  /**
   * @schema ClusterSecretStoreSpecRetrySettings#maxRetries
   */
  readonly maxRetries?: number;

  /**
   * @schema ClusterSecretStoreSpecRetrySettings#retryInterval
   */
  readonly retryInterval?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecRetrySettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecRetrySettings(
  obj: ClusterSecretStoreSpecRetrySettings | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    maxRetries: obj.maxRetries,
    retryInterval: obj.retryInterval,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Akeyless configures this store to sync secrets using Akeyless Vault provider
 *
 * @schema ClusterSecretStoreSpecProviderAkeyless
 */
export interface ClusterSecretStoreSpecProviderAkeyless {
  /**
   * Akeyless GW API Url from which the secrets to be fetched from.
   *
   * @schema ClusterSecretStoreSpecProviderAkeyless#akeylessGWApiURL
   */
  readonly akeylessGwApiUrl: string;

  /**
   * Auth configures how the operator authenticates with Akeyless.
   *
   * @schema ClusterSecretStoreSpecProviderAkeyless#authSecretRef
   */
  readonly authSecretRef: ClusterSecretStoreSpecProviderAkeylessAuthSecretRef;

  /**
   * PEM/base64 encoded CA bundle used to validate Akeyless Gateway certificate. Only used if the AkeylessGWApiURL URL is using HTTPS protocol. If not set the system root certificates are used to validate the TLS connection.
   *
   * @schema ClusterSecretStoreSpecProviderAkeyless#caBundle
   */
  readonly caBundle?: string;

  /**
   * The provider for the CA bundle to use to validate Akeyless Gateway certificate.
   *
   * @schema ClusterSecretStoreSpecProviderAkeyless#caProvider
   */
  readonly caProvider?: ClusterSecretStoreSpecProviderAkeylessCaProvider;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAkeyless' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderAkeyless(
  obj: ClusterSecretStoreSpecProviderAkeyless | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    akeylessGWApiURL: obj.akeylessGwApiUrl,
    authSecretRef: toJson_ClusterSecretStoreSpecProviderAkeylessAuthSecretRef(
      obj.authSecretRef,
    ),
    caBundle: obj.caBundle,
    caProvider: toJson_ClusterSecretStoreSpecProviderAkeylessCaProvider(
      obj.caProvider,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Alibaba configures this store to sync secrets using Alibaba Cloud provider
 *
 * @schema ClusterSecretStoreSpecProviderAlibaba
 */
export interface ClusterSecretStoreSpecProviderAlibaba {
  /**
   * AlibabaAuth contains a secretRef for credentials.
   *
   * @schema ClusterSecretStoreSpecProviderAlibaba#auth
   */
  readonly auth: ClusterSecretStoreSpecProviderAlibabaAuth;

  /**
   * Alibaba Region to be used for the provider
   *
   * @schema ClusterSecretStoreSpecProviderAlibaba#regionID
   */
  readonly regionId: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAlibaba' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderAlibaba(
  obj: ClusterSecretStoreSpecProviderAlibaba | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    auth: toJson_ClusterSecretStoreSpecProviderAlibabaAuth(obj.auth),
    regionID: obj.regionId,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * AWS configures this store to sync secrets using AWS Secret Manager provider
 *
 * @schema ClusterSecretStoreSpecProviderAws
 */
export interface ClusterSecretStoreSpecProviderAws {
  /**
   * Auth defines the information necessary to authenticate against AWS if not set aws sdk will infer credentials from your environment see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
   *
   * @schema ClusterSecretStoreSpecProviderAws#auth
   */
  readonly auth?: ClusterSecretStoreSpecProviderAwsAuth;

  /**
   * AWS Region to be used for the provider
   *
   * @schema ClusterSecretStoreSpecProviderAws#region
   */
  readonly region: string;

  /**
   * Role is a Role ARN which the SecretManager provider will assume
   *
   * @schema ClusterSecretStoreSpecProviderAws#role
   */
  readonly role?: string;

  /**
   * Service defines which service should be used to fetch the secrets
   *
   * @schema ClusterSecretStoreSpecProviderAws#service
   */
  readonly service: ClusterSecretStoreSpecProviderAwsService;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAws' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderAws(
  obj: ClusterSecretStoreSpecProviderAws | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    auth: toJson_ClusterSecretStoreSpecProviderAwsAuth(obj.auth),
    region: obj.region,
    role: obj.role,
    service: obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * AzureKV configures this store to sync secrets using Azure Key Vault provider
 *
 * @schema ClusterSecretStoreSpecProviderAzurekv
 */
export interface ClusterSecretStoreSpecProviderAzurekv {
  /**
   * Auth configures how the operator authenticates with Azure. Required for ServicePrincipal auth type.
   *
   * @schema ClusterSecretStoreSpecProviderAzurekv#authSecretRef
   */
  readonly authSecretRef?: ClusterSecretStoreSpecProviderAzurekvAuthSecretRef;

  /**
   * Auth type defines how to authenticate to the keyvault service. Valid values are: - "ServicePrincipal" (default): Using a service principal (tenantId, clientId, clientSecret) - "ManagedIdentity": Using Managed Identity assigned to the pod (see aad-pod-identity)
   *
   * @schema ClusterSecretStoreSpecProviderAzurekv#authType
   */
  readonly authType?: ClusterSecretStoreSpecProviderAzurekvAuthType;

  /**
   * If multiple Managed Identity is assigned to the pod, you can select the one to be used
   *
   * @schema ClusterSecretStoreSpecProviderAzurekv#identityId
   */
  readonly identityId?: string;

  /**
   * ServiceAccountRef specified the service account that should be used when authenticating with WorkloadIdentity.
   *
   * @schema ClusterSecretStoreSpecProviderAzurekv#serviceAccountRef
   */
  readonly serviceAccountRef?: ClusterSecretStoreSpecProviderAzurekvServiceAccountRef;

  /**
   * TenantID configures the Azure Tenant to send requests to. Required for ServicePrincipal auth type.
   *
   * @schema ClusterSecretStoreSpecProviderAzurekv#tenantId
   */
  readonly tenantId?: string;

  /**
   * Vault Url from which the secrets to be fetched from.
   *
   * @schema ClusterSecretStoreSpecProviderAzurekv#vaultUrl
   */
  readonly vaultUrl: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAzurekv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderAzurekv(
  obj: ClusterSecretStoreSpecProviderAzurekv | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    authSecretRef: toJson_ClusterSecretStoreSpecProviderAzurekvAuthSecretRef(
      obj.authSecretRef,
    ),
    authType: obj.authType,
    identityId: obj.identityId,
    serviceAccountRef:
      toJson_ClusterSecretStoreSpecProviderAzurekvServiceAccountRef(
        obj.serviceAccountRef,
      ),
    tenantId: obj.tenantId,
    vaultUrl: obj.vaultUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Fake configures a store with static key/value pairs
 *
 * @schema ClusterSecretStoreSpecProviderFake
 */
export interface ClusterSecretStoreSpecProviderFake {
  /**
   * @schema ClusterSecretStoreSpecProviderFake#data
   */
  readonly data: ClusterSecretStoreSpecProviderFakeData[];
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderFake' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderFake(
  obj: ClusterSecretStoreSpecProviderFake | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    data: obj.data?.map((y) =>
      toJson_ClusterSecretStoreSpecProviderFakeData(y),
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * GCPSM configures this store to sync secrets using Google Cloud Platform Secret Manager provider
 *
 * @schema ClusterSecretStoreSpecProviderGcpsm
 */
export interface ClusterSecretStoreSpecProviderGcpsm {
  /**
   * Auth defines the information necessary to authenticate against GCP
   *
   * @schema ClusterSecretStoreSpecProviderGcpsm#auth
   */
  readonly auth?: ClusterSecretStoreSpecProviderGcpsmAuth;

  /**
   * ProjectID project where secret is located
   *
   * @schema ClusterSecretStoreSpecProviderGcpsm#projectID
   */
  readonly projectId?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderGcpsm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderGcpsm(
  obj: ClusterSecretStoreSpecProviderGcpsm | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    auth: toJson_ClusterSecretStoreSpecProviderGcpsmAuth(obj.auth),
    projectID: obj.projectId,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * GitLab configures this store to sync secrets using GitLab Variables provider
 *
 * @schema ClusterSecretStoreSpecProviderGitlab
 */
export interface ClusterSecretStoreSpecProviderGitlab {
  /**
   * Auth configures how secret-manager authenticates with a GitLab instance.
   *
   * @schema ClusterSecretStoreSpecProviderGitlab#auth
   */
  readonly auth: ClusterSecretStoreSpecProviderGitlabAuth;

  /**
   * ProjectID specifies a project where secrets are located.
   *
   * @schema ClusterSecretStoreSpecProviderGitlab#projectID
   */
  readonly projectId?: string;

  /**
   * URL configures the GitLab instance URL. Defaults to https://gitlab.com/.
   *
   * @default https://gitlab.com/.
   * @schema ClusterSecretStoreSpecProviderGitlab#url
   */
  readonly url?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderGitlab' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderGitlab(
  obj: ClusterSecretStoreSpecProviderGitlab | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    auth: toJson_ClusterSecretStoreSpecProviderGitlabAuth(obj.auth),
    projectID: obj.projectId,
    url: obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * IBM configures this store to sync secrets using IBM Cloud provider
 *
 * @schema ClusterSecretStoreSpecProviderIbm
 */
export interface ClusterSecretStoreSpecProviderIbm {
  /**
   * Auth configures how secret-manager authenticates with the IBM secrets manager.
   *
   * @schema ClusterSecretStoreSpecProviderIbm#auth
   */
  readonly auth: ClusterSecretStoreSpecProviderIbmAuth;

  /**
   * ServiceURL is the Endpoint URL that is specific to the Secrets Manager service instance
   *
   * @schema ClusterSecretStoreSpecProviderIbm#serviceUrl
   */
  readonly serviceUrl?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderIbm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderIbm(
  obj: ClusterSecretStoreSpecProviderIbm | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    auth: toJson_ClusterSecretStoreSpecProviderIbmAuth(obj.auth),
    serviceUrl: obj.serviceUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Kubernetes configures this store to sync secrets using a Kubernetes cluster provider
 *
 * @schema ClusterSecretStoreSpecProviderKubernetes
 */
export interface ClusterSecretStoreSpecProviderKubernetes {
  /**
   * Auth configures how secret-manager authenticates with a Kubernetes instance.
   *
   * @schema ClusterSecretStoreSpecProviderKubernetes#auth
   */
  readonly auth: ClusterSecretStoreSpecProviderKubernetesAuth;

  /**
   * Remote namespace to fetch the secrets from
   *
   * @schema ClusterSecretStoreSpecProviderKubernetes#remoteNamespace
   */
  readonly remoteNamespace?: string;

  /**
   * configures the Kubernetes server Address.
   *
   * @schema ClusterSecretStoreSpecProviderKubernetes#server
   */
  readonly server?: ClusterSecretStoreSpecProviderKubernetesServer;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderKubernetes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderKubernetes(
  obj: ClusterSecretStoreSpecProviderKubernetes | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    auth: toJson_ClusterSecretStoreSpecProviderKubernetesAuth(obj.auth),
    remoteNamespace: obj.remoteNamespace,
    server: toJson_ClusterSecretStoreSpecProviderKubernetesServer(obj.server),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Oracle configures this store to sync secrets using Oracle Vault provider
 *
 * @schema ClusterSecretStoreSpecProviderOracle
 */
export interface ClusterSecretStoreSpecProviderOracle {
  /**
   * Auth configures how secret-manager authenticates with the Oracle Vault. If empty, instance principal is used. Optionally, the authenticating principal type and/or user data may be supplied for the use of workload identity and user principal.
   *
   * @schema ClusterSecretStoreSpecProviderOracle#auth
   */
  readonly auth?: ClusterSecretStoreSpecProviderOracleAuth;

  /**
   * Compartment is the vault compartment OCID. Required for PushSecret
   *
   * @schema ClusterSecretStoreSpecProviderOracle#compartment
   */
  readonly compartment?: string;

  /**
   * EncryptionKey is the OCID of the encryption key within the vault. Required for PushSecret
   *
   * @schema ClusterSecretStoreSpecProviderOracle#encryptionKey
   */
  readonly encryptionKey?: string;

  /**
   * The type of principal to use for authentication. If left blank, the Auth struct will determine the principal type. This optional field must be specified if using workload identity.
   *
   * @schema ClusterSecretStoreSpecProviderOracle#principalType
   */
  readonly principalType?: ClusterSecretStoreSpecProviderOraclePrincipalType;

  /**
   * Region is the region where vault is located.
   *
   * @schema ClusterSecretStoreSpecProviderOracle#region
   */
  readonly region: string;

  /**
   * ServiceAccountRef specified the service account that should be used when authenticating with WorkloadIdentity.
   *
   * @schema ClusterSecretStoreSpecProviderOracle#serviceAccountRef
   */
  readonly serviceAccountRef?: ClusterSecretStoreSpecProviderOracleServiceAccountRef;

  /**
   * Vault is the vault's OCID of the specific vault where secret is located.
   *
   * @schema ClusterSecretStoreSpecProviderOracle#vault
   */
  readonly vault: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderOracle' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderOracle(
  obj: ClusterSecretStoreSpecProviderOracle | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    auth: toJson_ClusterSecretStoreSpecProviderOracleAuth(obj.auth),
    compartment: obj.compartment,
    encryptionKey: obj.encryptionKey,
    principalType: obj.principalType,
    region: obj.region,
    serviceAccountRef:
      toJson_ClusterSecretStoreSpecProviderOracleServiceAccountRef(
        obj.serviceAccountRef,
      ),
    vault: obj.vault,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Vault configures this store to sync secrets using Hashi provider
 *
 * @schema ClusterSecretStoreSpecProviderVault
 */
export interface ClusterSecretStoreSpecProviderVault {
  /**
   * Auth configures how secret-manager authenticates with the Vault server.
   *
   * @schema ClusterSecretStoreSpecProviderVault#auth
   */
  readonly auth: ClusterSecretStoreSpecProviderVaultAuth;

  /**
   * PEM encoded CA bundle used to validate Vault server certificate. Only used if the Server URL is using HTTPS protocol. This parameter is ignored for plain HTTP protocol connection. If not set the system root certificates are used to validate the TLS connection.
   *
   * @schema ClusterSecretStoreSpecProviderVault#caBundle
   */
  readonly caBundle?: string;

  /**
   * The provider for the CA bundle to use to validate Vault server certificate.
   *
   * @schema ClusterSecretStoreSpecProviderVault#caProvider
   */
  readonly caProvider?: ClusterSecretStoreSpecProviderVaultCaProvider;

  /**
   * ForwardInconsistent tells Vault to forward read-after-write requests to the Vault leader instead of simply retrying within a loop. This can increase performance if the option is enabled serverside. https://www.vaultproject.io/docs/configuration/replication#allow_forwarding_via_header
   *
   * @schema ClusterSecretStoreSpecProviderVault#forwardInconsistent
   */
  readonly forwardInconsistent?: boolean;

  /**
   * Name of the vault namespace. Namespaces is a set of features within Vault Enterprise that allows Vault environments to support Secure Multi-tenancy. e.g: "ns1". More about namespaces can be found here https://www.vaultproject.io/docs/enterprise/namespaces
   *
   * @schema ClusterSecretStoreSpecProviderVault#namespace
   */
  readonly namespace?: string;

  /**
   * Path is the mount path of the Vault KV backend endpoint, e.g: "secret". The v2 KV secret engine version specific "/data" path suffix for fetching secrets from Vault is optional and will be appended if not present in specified path.
   *
   * @schema ClusterSecretStoreSpecProviderVault#path
   */
  readonly path?: string;

  /**
   * ReadYourWrites ensures isolated read-after-write semantics by providing discovered cluster replication states in each request. More information about eventual consistency in Vault can be found here https://www.vaultproject.io/docs/enterprise/consistency
   *
   * @schema ClusterSecretStoreSpecProviderVault#readYourWrites
   */
  readonly readYourWrites?: boolean;

  /**
   * Server is the connection address for the Vault server, e.g: "https://vault.example.com:8200".
   *
   * @schema ClusterSecretStoreSpecProviderVault#server
   */
  readonly server: string;

  /**
   * Version is the Vault KV secret engine version. This can be either "v1" or "v2". Version defaults to "v2".
   *
   * @schema ClusterSecretStoreSpecProviderVault#version
   */
  readonly version?: ClusterSecretStoreSpecProviderVaultVersion;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderVault' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderVault(
  obj: ClusterSecretStoreSpecProviderVault | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    auth: toJson_ClusterSecretStoreSpecProviderVaultAuth(obj.auth),
    caBundle: obj.caBundle,
    caProvider: toJson_ClusterSecretStoreSpecProviderVaultCaProvider(
      obj.caProvider,
    ),
    forwardInconsistent: obj.forwardInconsistent,
    namespace: obj.namespace,
    path: obj.path,
    readYourWrites: obj.readYourWrites,
    server: obj.server,
    version: obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Webhook configures this store to sync secrets using a generic templated webhook
 *
 * @schema ClusterSecretStoreSpecProviderWebhook
 */
export interface ClusterSecretStoreSpecProviderWebhook {
  /**
   * Body
   *
   * @schema ClusterSecretStoreSpecProviderWebhook#body
   */
  readonly body?: string;

  /**
   * PEM encoded CA bundle used to validate webhook server certificate. Only used if the Server URL is using HTTPS protocol. This parameter is ignored for plain HTTP protocol connection. If not set the system root certificates are used to validate the TLS connection.
   *
   * @schema ClusterSecretStoreSpecProviderWebhook#caBundle
   */
  readonly caBundle?: string;

  /**
   * The provider for the CA bundle to use to validate webhook server certificate.
   *
   * @schema ClusterSecretStoreSpecProviderWebhook#caProvider
   */
  readonly caProvider?: ClusterSecretStoreSpecProviderWebhookCaProvider;

  /**
   * Headers
   *
   * @schema ClusterSecretStoreSpecProviderWebhook#headers
   */
  readonly headers?: { [key: string]: string };

  /**
   * Webhook Method
   *
   * @schema ClusterSecretStoreSpecProviderWebhook#method
   */
  readonly method?: string;

  /**
   * Result formatting
   *
   * @schema ClusterSecretStoreSpecProviderWebhook#result
   */
  readonly result: ClusterSecretStoreSpecProviderWebhookResult;

  /**
   * Secrets to fill in templates These secrets will be passed to the templating function as key value pairs under the given name
   *
   * @schema ClusterSecretStoreSpecProviderWebhook#secrets
   */
  readonly secrets?: ClusterSecretStoreSpecProviderWebhookSecrets[];

  /**
   * Timeout
   *
   * @schema ClusterSecretStoreSpecProviderWebhook#timeout
   */
  readonly timeout?: string;

  /**
   * Webhook url to call
   *
   * @schema ClusterSecretStoreSpecProviderWebhook#url
   */
  readonly url: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderWebhook' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderWebhook(
  obj: ClusterSecretStoreSpecProviderWebhook | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    body: obj.body,
    caBundle: obj.caBundle,
    caProvider: toJson_ClusterSecretStoreSpecProviderWebhookCaProvider(
      obj.caProvider,
    ),
    headers:
      obj.headers === undefined
        ? undefined
        : Object.entries(obj.headers).reduce(
            (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
            {},
          ),
    method: obj.method,
    result: toJson_ClusterSecretStoreSpecProviderWebhookResult(obj.result),
    secrets: obj.secrets?.map((y) =>
      toJson_ClusterSecretStoreSpecProviderWebhookSecrets(y),
    ),
    timeout: obj.timeout,
    url: obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * YandexLockbox configures this store to sync secrets using Yandex Lockbox provider
 *
 * @schema ClusterSecretStoreSpecProviderYandexlockbox
 */
export interface ClusterSecretStoreSpecProviderYandexlockbox {
  /**
   * Yandex.Cloud API endpoint (e.g. 'api.cloud.yandex.net:443')
   *
   * @schema ClusterSecretStoreSpecProviderYandexlockbox#apiEndpoint
   */
  readonly apiEndpoint?: string;

  /**
   * Auth defines the information necessary to authenticate against Yandex Lockbox
   *
   * @schema ClusterSecretStoreSpecProviderYandexlockbox#auth
   */
  readonly auth: ClusterSecretStoreSpecProviderYandexlockboxAuth;

  /**
   * The provider for the CA bundle to use to validate Yandex.Cloud server certificate.
   *
   * @schema ClusterSecretStoreSpecProviderYandexlockbox#caProvider
   */
  readonly caProvider?: ClusterSecretStoreSpecProviderYandexlockboxCaProvider;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderYandexlockbox' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderYandexlockbox(
  obj: ClusterSecretStoreSpecProviderYandexlockbox | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    apiEndpoint: obj.apiEndpoint,
    auth: toJson_ClusterSecretStoreSpecProviderYandexlockboxAuth(obj.auth),
    caProvider: toJson_ClusterSecretStoreSpecProviderYandexlockboxCaProvider(
      obj.caProvider,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Auth configures how the operator authenticates with Akeyless.
 *
 * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRef
 */
export interface ClusterSecretStoreSpecProviderAkeylessAuthSecretRef {
  /**
   * Kubernetes authenticates with Akeyless by passing the ServiceAccount token stored in the named Secret resource.
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRef#kubernetesAuth
   */
  readonly kubernetesAuth?: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth;

  /**
   * Reference to a Secret that contains the details to authenticate with Akeyless.
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRef#secretRef
   */
  readonly secretRef?: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRef;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAkeylessAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderAkeylessAuthSecretRef(
  obj: ClusterSecretStoreSpecProviderAkeylessAuthSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    kubernetesAuth:
      toJson_ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth(
        obj.kubernetesAuth,
      ),
    secretRef:
      toJson_ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRef(
        obj.secretRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The provider for the CA bundle to use to validate Akeyless Gateway certificate.
 *
 * @schema ClusterSecretStoreSpecProviderAkeylessCaProvider
 */
export interface ClusterSecretStoreSpecProviderAkeylessCaProvider {
  /**
   * The key the value inside of the provider type to use, only used with "Secret" type
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessCaProvider#key
   */
  readonly key?: string;

  /**
   * The name of the object located at the provider type.
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessCaProvider#name
   */
  readonly name: string;

  /**
   * The namespace the Provider type is in.
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessCaProvider#namespace
   */
  readonly namespace?: string;

  /**
   * The type of provider to use such as "Secret", or "ConfigMap".
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessCaProvider#type
   */
  readonly type: ClusterSecretStoreSpecProviderAkeylessCaProviderType;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAkeylessCaProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderAkeylessCaProvider(
  obj: ClusterSecretStoreSpecProviderAkeylessCaProvider | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
    type: obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * AlibabaAuth contains a secretRef for credentials.
 *
 * @schema ClusterSecretStoreSpecProviderAlibabaAuth
 */
export interface ClusterSecretStoreSpecProviderAlibabaAuth {
  /**
   * Authenticate against Alibaba using RRSA.
   *
   * @schema ClusterSecretStoreSpecProviderAlibabaAuth#rrsa
   */
  readonly rrsa?: ClusterSecretStoreSpecProviderAlibabaAuthRrsa;

  /**
   * AlibabaAuthSecretRef holds secret references for Alibaba credentials.
   *
   * @schema ClusterSecretStoreSpecProviderAlibabaAuth#secretRef
   */
  readonly secretRef?: ClusterSecretStoreSpecProviderAlibabaAuthSecretRef;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAlibabaAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderAlibabaAuth(
  obj: ClusterSecretStoreSpecProviderAlibabaAuth | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    rrsa: toJson_ClusterSecretStoreSpecProviderAlibabaAuthRrsa(obj.rrsa),
    secretRef: toJson_ClusterSecretStoreSpecProviderAlibabaAuthSecretRef(
      obj.secretRef,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Auth defines the information necessary to authenticate against AWS if not set aws sdk will infer credentials from your environment see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
 *
 * @schema ClusterSecretStoreSpecProviderAwsAuth
 */
export interface ClusterSecretStoreSpecProviderAwsAuth {
  /**
   * Authenticate against AWS using service account tokens.
   *
   * @schema ClusterSecretStoreSpecProviderAwsAuth#jwt
   */
  readonly jwt?: ClusterSecretStoreSpecProviderAwsAuthJwt;

  /**
   * AWSAuthSecretRef holds secret references for AWS credentials both AccessKeyID and SecretAccessKey must be defined in order to properly authenticate.
   *
   * @schema ClusterSecretStoreSpecProviderAwsAuth#secretRef
   */
  readonly secretRef?: ClusterSecretStoreSpecProviderAwsAuthSecretRef;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAwsAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderAwsAuth(
  obj: ClusterSecretStoreSpecProviderAwsAuth | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    jwt: toJson_ClusterSecretStoreSpecProviderAwsAuthJwt(obj.jwt),
    secretRef: toJson_ClusterSecretStoreSpecProviderAwsAuthSecretRef(
      obj.secretRef,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Service defines which service should be used to fetch the secrets
 *
 * @schema ClusterSecretStoreSpecProviderAwsService
 */
export enum ClusterSecretStoreSpecProviderAwsService {
  /** SecretsManager */
  SECRETS_MANAGER = "SecretsManager",
  /** ParameterStore */
  PARAMETER_STORE = "ParameterStore",
}

/**
 * Auth configures how the operator authenticates with Azure. Required for ServicePrincipal auth type.
 *
 * @schema ClusterSecretStoreSpecProviderAzurekvAuthSecretRef
 */
export interface ClusterSecretStoreSpecProviderAzurekvAuthSecretRef {
  /**
   * The Azure clientId of the service principle used for authentication.
   *
   * @schema ClusterSecretStoreSpecProviderAzurekvAuthSecretRef#clientId
   */
  readonly clientId?: ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientId;

  /**
   * The Azure ClientSecret of the service principle used for authentication.
   *
   * @schema ClusterSecretStoreSpecProviderAzurekvAuthSecretRef#clientSecret
   */
  readonly clientSecret?: ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientSecret;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAzurekvAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderAzurekvAuthSecretRef(
  obj: ClusterSecretStoreSpecProviderAzurekvAuthSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    clientId: toJson_ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientId(
      obj.clientId,
    ),
    clientSecret:
      toJson_ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientSecret(
        obj.clientSecret,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Auth type defines how to authenticate to the keyvault service. Valid values are: - "ServicePrincipal" (default): Using a service principal (tenantId, clientId, clientSecret) - "ManagedIdentity": Using Managed Identity assigned to the pod (see aad-pod-identity)
 *
 * @schema ClusterSecretStoreSpecProviderAzurekvAuthType
 */
export enum ClusterSecretStoreSpecProviderAzurekvAuthType {
  /** ServicePrincipal */
  SERVICE_PRINCIPAL = "ServicePrincipal",
  /** ManagedIdentity */
  MANAGED_IDENTITY = "ManagedIdentity",
  /** WorkloadIdentity */
  WORKLOAD_IDENTITY = "WorkloadIdentity",
}

/**
 * ServiceAccountRef specified the service account that should be used when authenticating with WorkloadIdentity.
 *
 * @schema ClusterSecretStoreSpecProviderAzurekvServiceAccountRef
 */
export interface ClusterSecretStoreSpecProviderAzurekvServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
   *
   * @schema ClusterSecretStoreSpecProviderAzurekvServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderAzurekvServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderAzurekvServiceAccountRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAzurekvServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderAzurekvServiceAccountRef(
  obj: ClusterSecretStoreSpecProviderAzurekvServiceAccountRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    audiences: obj.audiences?.map((y) => y),
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSecretStoreSpecProviderFakeData
 */
export interface ClusterSecretStoreSpecProviderFakeData {
  /**
   * @schema ClusterSecretStoreSpecProviderFakeData#key
   */
  readonly key: string;

  /**
   * @schema ClusterSecretStoreSpecProviderFakeData#value
   */
  readonly value?: string;

  /**
   * @schema ClusterSecretStoreSpecProviderFakeData#valueMap
   */
  readonly valueMap?: { [key: string]: string };

  /**
   * @schema ClusterSecretStoreSpecProviderFakeData#version
   */
  readonly version?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderFakeData' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderFakeData(
  obj: ClusterSecretStoreSpecProviderFakeData | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    value: obj.value,
    valueMap:
      obj.valueMap === undefined
        ? undefined
        : Object.entries(obj.valueMap).reduce(
            (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
            {},
          ),
    version: obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Auth defines the information necessary to authenticate against GCP
 *
 * @schema ClusterSecretStoreSpecProviderGcpsmAuth
 */
export interface ClusterSecretStoreSpecProviderGcpsmAuth {
  /**
   * @schema ClusterSecretStoreSpecProviderGcpsmAuth#secretRef
   */
  readonly secretRef?: ClusterSecretStoreSpecProviderGcpsmAuthSecretRef;

  /**
   * @schema ClusterSecretStoreSpecProviderGcpsmAuth#workloadIdentity
   */
  readonly workloadIdentity?: ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentity;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderGcpsmAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderGcpsmAuth(
  obj: ClusterSecretStoreSpecProviderGcpsmAuth | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    secretRef: toJson_ClusterSecretStoreSpecProviderGcpsmAuthSecretRef(
      obj.secretRef,
    ),
    workloadIdentity:
      toJson_ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentity(
        obj.workloadIdentity,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Auth configures how secret-manager authenticates with a GitLab instance.
 *
 * @schema ClusterSecretStoreSpecProviderGitlabAuth
 */
export interface ClusterSecretStoreSpecProviderGitlabAuth {
  /**
   * @schema ClusterSecretStoreSpecProviderGitlabAuth#SecretRef
   */
  readonly secretRef: ClusterSecretStoreSpecProviderGitlabAuthSecretRef;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderGitlabAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderGitlabAuth(
  obj: ClusterSecretStoreSpecProviderGitlabAuth | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    SecretRef: toJson_ClusterSecretStoreSpecProviderGitlabAuthSecretRef(
      obj.secretRef,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Auth configures how secret-manager authenticates with the IBM secrets manager.
 *
 * @schema ClusterSecretStoreSpecProviderIbmAuth
 */
export interface ClusterSecretStoreSpecProviderIbmAuth {
  /**
   * @schema ClusterSecretStoreSpecProviderIbmAuth#secretRef
   */
  readonly secretRef: ClusterSecretStoreSpecProviderIbmAuthSecretRef;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderIbmAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderIbmAuth(
  obj: ClusterSecretStoreSpecProviderIbmAuth | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    secretRef: toJson_ClusterSecretStoreSpecProviderIbmAuthSecretRef(
      obj.secretRef,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Auth configures how secret-manager authenticates with a Kubernetes instance.
 *
 * @schema ClusterSecretStoreSpecProviderKubernetesAuth
 */
export interface ClusterSecretStoreSpecProviderKubernetesAuth {
  /**
   * has both clientCert and clientKey as secretKeySelector
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesAuth#cert
   */
  readonly cert?: ClusterSecretStoreSpecProviderKubernetesAuthCert;

  /**
   * points to a service account that should be used for authentication
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesAuth#serviceAccount
   */
  readonly serviceAccount?: ClusterSecretStoreSpecProviderKubernetesAuthServiceAccount;

  /**
   * use static token to authenticate with
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesAuth#token
   */
  readonly token?: ClusterSecretStoreSpecProviderKubernetesAuthToken;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderKubernetesAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderKubernetesAuth(
  obj: ClusterSecretStoreSpecProviderKubernetesAuth | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    cert: toJson_ClusterSecretStoreSpecProviderKubernetesAuthCert(obj.cert),
    serviceAccount:
      toJson_ClusterSecretStoreSpecProviderKubernetesAuthServiceAccount(
        obj.serviceAccount,
      ),
    token: toJson_ClusterSecretStoreSpecProviderKubernetesAuthToken(obj.token),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * configures the Kubernetes server Address.
 *
 * @schema ClusterSecretStoreSpecProviderKubernetesServer
 */
export interface ClusterSecretStoreSpecProviderKubernetesServer {
  /**
   * CABundle is a base64-encoded CA certificate
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesServer#caBundle
   */
  readonly caBundle?: string;

  /**
   * see: https://external-secrets.io/v0.4.1/spec/#external-secrets.io/v1alpha1.CAProvider
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesServer#caProvider
   */
  readonly caProvider?: ClusterSecretStoreSpecProviderKubernetesServerCaProvider;

  /**
   * configures the Kubernetes server Address.
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesServer#url
   */
  readonly url?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderKubernetesServer' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderKubernetesServer(
  obj: ClusterSecretStoreSpecProviderKubernetesServer | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    caBundle: obj.caBundle,
    caProvider: toJson_ClusterSecretStoreSpecProviderKubernetesServerCaProvider(
      obj.caProvider,
    ),
    url: obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Auth configures how secret-manager authenticates with the Oracle Vault. If empty, instance principal is used. Optionally, the authenticating principal type and/or user data may be supplied for the use of workload identity and user principal.
 *
 * @schema ClusterSecretStoreSpecProviderOracleAuth
 */
export interface ClusterSecretStoreSpecProviderOracleAuth {
  /**
   * SecretRef to pass through sensitive information.
   *
   * @schema ClusterSecretStoreSpecProviderOracleAuth#secretRef
   */
  readonly secretRef: ClusterSecretStoreSpecProviderOracleAuthSecretRef;

  /**
   * Tenancy is the tenancy OCID where user is located.
   *
   * @schema ClusterSecretStoreSpecProviderOracleAuth#tenancy
   */
  readonly tenancy: string;

  /**
   * User is an access OCID specific to the account.
   *
   * @schema ClusterSecretStoreSpecProviderOracleAuth#user
   */
  readonly user: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderOracleAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderOracleAuth(
  obj: ClusterSecretStoreSpecProviderOracleAuth | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    secretRef: toJson_ClusterSecretStoreSpecProviderOracleAuthSecretRef(
      obj.secretRef,
    ),
    tenancy: obj.tenancy,
    user: obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The type of principal to use for authentication. If left blank, the Auth struct will determine the principal type. This optional field must be specified if using workload identity.
 *
 * @schema ClusterSecretStoreSpecProviderOraclePrincipalType
 */
export enum ClusterSecretStoreSpecProviderOraclePrincipalType {
  /** UserPrincipal */
  USER_PRINCIPAL = "UserPrincipal",
  /** InstancePrincipal */
  INSTANCE_PRINCIPAL = "InstancePrincipal",
  /** Workload */
  WORKLOAD = "Workload",
}

/**
 * ServiceAccountRef specified the service account that should be used when authenticating with WorkloadIdentity.
 *
 * @schema ClusterSecretStoreSpecProviderOracleServiceAccountRef
 */
export interface ClusterSecretStoreSpecProviderOracleServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
   *
   * @schema ClusterSecretStoreSpecProviderOracleServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderOracleServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderOracleServiceAccountRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderOracleServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderOracleServiceAccountRef(
  obj: ClusterSecretStoreSpecProviderOracleServiceAccountRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    audiences: obj.audiences?.map((y) => y),
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Auth configures how secret-manager authenticates with the Vault server.
 *
 * @schema ClusterSecretStoreSpecProviderVaultAuth
 */
export interface ClusterSecretStoreSpecProviderVaultAuth {
  /**
   * AppRole authenticates with Vault using the App Role auth mechanism, with the role and secret stored in a Kubernetes Secret resource.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuth#appRole
   */
  readonly appRole?: ClusterSecretStoreSpecProviderVaultAuthAppRole;

  /**
   * Cert authenticates with TLS Certificates by passing client certificate, private key and ca certificate Cert authentication method
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuth#cert
   */
  readonly cert?: ClusterSecretStoreSpecProviderVaultAuthCert;

  /**
   * Jwt authenticates with Vault by passing role and JWT token using the JWT/OIDC authentication method
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuth#jwt
   */
  readonly jwt?: ClusterSecretStoreSpecProviderVaultAuthJwt;

  /**
   * Kubernetes authenticates with Vault by passing the ServiceAccount token stored in the named Secret resource to the Vault server.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuth#kubernetes
   */
  readonly kubernetes?: ClusterSecretStoreSpecProviderVaultAuthKubernetes;

  /**
   * Ldap authenticates with Vault by passing username/password pair using the LDAP authentication method
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuth#ldap
   */
  readonly ldap?: ClusterSecretStoreSpecProviderVaultAuthLdap;

  /**
   * TokenSecretRef authenticates with Vault by presenting a token.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuth#tokenSecretRef
   */
  readonly tokenSecretRef?: ClusterSecretStoreSpecProviderVaultAuthTokenSecretRef;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderVaultAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderVaultAuth(
  obj: ClusterSecretStoreSpecProviderVaultAuth | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    appRole: toJson_ClusterSecretStoreSpecProviderVaultAuthAppRole(obj.appRole),
    cert: toJson_ClusterSecretStoreSpecProviderVaultAuthCert(obj.cert),
    jwt: toJson_ClusterSecretStoreSpecProviderVaultAuthJwt(obj.jwt),
    kubernetes: toJson_ClusterSecretStoreSpecProviderVaultAuthKubernetes(
      obj.kubernetes,
    ),
    ldap: toJson_ClusterSecretStoreSpecProviderVaultAuthLdap(obj.ldap),
    tokenSecretRef:
      toJson_ClusterSecretStoreSpecProviderVaultAuthTokenSecretRef(
        obj.tokenSecretRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The provider for the CA bundle to use to validate Vault server certificate.
 *
 * @schema ClusterSecretStoreSpecProviderVaultCaProvider
 */
export interface ClusterSecretStoreSpecProviderVaultCaProvider {
  /**
   * The key the value inside of the provider type to use, only used with "Secret" type
   *
   * @schema ClusterSecretStoreSpecProviderVaultCaProvider#key
   */
  readonly key?: string;

  /**
   * The name of the object located at the provider type.
   *
   * @schema ClusterSecretStoreSpecProviderVaultCaProvider#name
   */
  readonly name: string;

  /**
   * The namespace the Provider type is in.
   *
   * @schema ClusterSecretStoreSpecProviderVaultCaProvider#namespace
   */
  readonly namespace?: string;

  /**
   * The type of provider to use such as "Secret", or "ConfigMap".
   *
   * @schema ClusterSecretStoreSpecProviderVaultCaProvider#type
   */
  readonly type: ClusterSecretStoreSpecProviderVaultCaProviderType;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderVaultCaProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderVaultCaProvider(
  obj: ClusterSecretStoreSpecProviderVaultCaProvider | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
    type: obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Version is the Vault KV secret engine version. This can be either "v1" or "v2". Version defaults to "v2".
 *
 * @schema ClusterSecretStoreSpecProviderVaultVersion
 */
export enum ClusterSecretStoreSpecProviderVaultVersion {
  /** v1 */
  V1 = "v1",
  /** v2 */
  V2 = "v2",
}

/**
 * The provider for the CA bundle to use to validate webhook server certificate.
 *
 * @schema ClusterSecretStoreSpecProviderWebhookCaProvider
 */
export interface ClusterSecretStoreSpecProviderWebhookCaProvider {
  /**
   * The key the value inside of the provider type to use, only used with "Secret" type
   *
   * @schema ClusterSecretStoreSpecProviderWebhookCaProvider#key
   */
  readonly key?: string;

  /**
   * The name of the object located at the provider type.
   *
   * @schema ClusterSecretStoreSpecProviderWebhookCaProvider#name
   */
  readonly name: string;

  /**
   * The namespace the Provider type is in.
   *
   * @schema ClusterSecretStoreSpecProviderWebhookCaProvider#namespace
   */
  readonly namespace?: string;

  /**
   * The type of provider to use such as "Secret", or "ConfigMap".
   *
   * @schema ClusterSecretStoreSpecProviderWebhookCaProvider#type
   */
  readonly type: ClusterSecretStoreSpecProviderWebhookCaProviderType;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderWebhookCaProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderWebhookCaProvider(
  obj: ClusterSecretStoreSpecProviderWebhookCaProvider | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
    type: obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Result formatting
 *
 * @schema ClusterSecretStoreSpecProviderWebhookResult
 */
export interface ClusterSecretStoreSpecProviderWebhookResult {
  /**
   * Json path of return value
   *
   * @schema ClusterSecretStoreSpecProviderWebhookResult#jsonPath
   */
  readonly jsonPath?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderWebhookResult' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderWebhookResult(
  obj: ClusterSecretStoreSpecProviderWebhookResult | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    jsonPath: obj.jsonPath,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSecretStoreSpecProviderWebhookSecrets
 */
export interface ClusterSecretStoreSpecProviderWebhookSecrets {
  /**
   * Name of this secret in templates
   *
   * @schema ClusterSecretStoreSpecProviderWebhookSecrets#name
   */
  readonly name: string;

  /**
   * Secret ref to fill in credentials
   *
   * @schema ClusterSecretStoreSpecProviderWebhookSecrets#secretRef
   */
  readonly secretRef: ClusterSecretStoreSpecProviderWebhookSecretsSecretRef;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderWebhookSecrets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderWebhookSecrets(
  obj: ClusterSecretStoreSpecProviderWebhookSecrets | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    secretRef: toJson_ClusterSecretStoreSpecProviderWebhookSecretsSecretRef(
      obj.secretRef,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Auth defines the information necessary to authenticate against Yandex Lockbox
 *
 * @schema ClusterSecretStoreSpecProviderYandexlockboxAuth
 */
export interface ClusterSecretStoreSpecProviderYandexlockboxAuth {
  /**
   * The authorized key used for authentication
   *
   * @schema ClusterSecretStoreSpecProviderYandexlockboxAuth#authorizedKeySecretRef
   */
  readonly authorizedKeySecretRef?: ClusterSecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderYandexlockboxAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderYandexlockboxAuth(
  obj: ClusterSecretStoreSpecProviderYandexlockboxAuth | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    authorizedKeySecretRef:
      toJson_ClusterSecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef(
        obj.authorizedKeySecretRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The provider for the CA bundle to use to validate Yandex.Cloud server certificate.
 *
 * @schema ClusterSecretStoreSpecProviderYandexlockboxCaProvider
 */
export interface ClusterSecretStoreSpecProviderYandexlockboxCaProvider {
  /**
   * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
   *
   * @schema ClusterSecretStoreSpecProviderYandexlockboxCaProvider#certSecretRef
   */
  readonly certSecretRef?: ClusterSecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderYandexlockboxCaProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderYandexlockboxCaProvider(
  obj: ClusterSecretStoreSpecProviderYandexlockboxCaProvider | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    certSecretRef:
      toJson_ClusterSecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef(
        obj.certSecretRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Kubernetes authenticates with Akeyless by passing the ServiceAccount token stored in the named Secret resource.
 *
 * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth
 */
export interface ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth {
  /**
   * the Akeyless Kubernetes auth-method access-id
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth#accessID
   */
  readonly accessId: string;

  /**
   * Kubernetes-auth configuration name in Akeyless-Gateway
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth#k8sConfName
   */
  readonly k8SConfName: string;

  /**
   * Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Akeyless. If a name is specified without a key, `token` is the default. If one is not specified, the one bound to the controller will be used.
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth#secretRef
   */
  readonly secretRef?: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef;

  /**
   * Optional service account field containing the name of a kubernetes ServiceAccount. If the service account is specified, the service account secret token JWT will be used for authenticating with Akeyless. If the service account selector is not supplied, the secretRef will be used instead.
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth#serviceAccountRef
   */
  readonly serviceAccountRef?: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth(
  obj:
    | ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    accessID: obj.accessId,
    k8sConfName: obj.k8SConfName,
    secretRef:
      toJson_ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef(
        obj.secretRef,
      ),
    serviceAccountRef:
      toJson_ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef(
        obj.serviceAccountRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Secret that contains the details to authenticate with Akeyless.
 *
 * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRef
 */
export interface ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRef {
  /**
   * The SecretAccessID is used for authentication
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRef#accessID
   */
  readonly accessId?: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId;

  /**
   * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRef#accessType
   */
  readonly accessType?: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType;

  /**
   * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRef#accessTypeParam
   */
  readonly accessTypeParam?: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRef(
  obj: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    accessID:
      toJson_ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId(
        obj.accessId,
      ),
    accessType:
      toJson_ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType(
        obj.accessType,
      ),
    accessTypeParam:
      toJson_ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam(
        obj.accessTypeParam,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The type of provider to use such as "Secret", or "ConfigMap".
 *
 * @schema ClusterSecretStoreSpecProviderAkeylessCaProviderType
 */
export enum ClusterSecretStoreSpecProviderAkeylessCaProviderType {
  /** Secret */
  SECRET = "Secret",
  /** ConfigMap */
  CONFIG_MAP = "ConfigMap",
}

/**
 * Authenticate against Alibaba using RRSA.
 *
 * @schema ClusterSecretStoreSpecProviderAlibabaAuthRrsa
 */
export interface ClusterSecretStoreSpecProviderAlibabaAuthRrsa {
  /**
   * @schema ClusterSecretStoreSpecProviderAlibabaAuthRrsa#oidcProviderArn
   */
  readonly oidcProviderArn: string;

  /**
   * @schema ClusterSecretStoreSpecProviderAlibabaAuthRrsa#oidcTokenFilePath
   */
  readonly oidcTokenFilePath: string;

  /**
   * @schema ClusterSecretStoreSpecProviderAlibabaAuthRrsa#roleArn
   */
  readonly roleArn: string;

  /**
   * @schema ClusterSecretStoreSpecProviderAlibabaAuthRrsa#sessionName
   */
  readonly sessionName: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAlibabaAuthRrsa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderAlibabaAuthRrsa(
  obj: ClusterSecretStoreSpecProviderAlibabaAuthRrsa | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    oidcProviderArn: obj.oidcProviderArn,
    oidcTokenFilePath: obj.oidcTokenFilePath,
    roleArn: obj.roleArn,
    sessionName: obj.sessionName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * AlibabaAuthSecretRef holds secret references for Alibaba credentials.
 *
 * @schema ClusterSecretStoreSpecProviderAlibabaAuthSecretRef
 */
export interface ClusterSecretStoreSpecProviderAlibabaAuthSecretRef {
  /**
   * The AccessKeyID is used for authentication
   *
   * @schema ClusterSecretStoreSpecProviderAlibabaAuthSecretRef#accessKeyIDSecretRef
   */
  readonly accessKeyIdSecretRef: ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef;

  /**
   * The AccessKeySecret is used for authentication
   *
   * @schema ClusterSecretStoreSpecProviderAlibabaAuthSecretRef#accessKeySecretSecretRef
   */
  readonly accessKeySecretSecretRef: ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAlibabaAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderAlibabaAuthSecretRef(
  obj: ClusterSecretStoreSpecProviderAlibabaAuthSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    accessKeyIDSecretRef:
      toJson_ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef(
        obj.accessKeyIdSecretRef,
      ),
    accessKeySecretSecretRef:
      toJson_ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef(
        obj.accessKeySecretSecretRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Authenticate against AWS using service account tokens.
 *
 * @schema ClusterSecretStoreSpecProviderAwsAuthJwt
 */
export interface ClusterSecretStoreSpecProviderAwsAuthJwt {
  /**
   * A reference to a ServiceAccount resource.
   *
   * @schema ClusterSecretStoreSpecProviderAwsAuthJwt#serviceAccountRef
   */
  readonly serviceAccountRef?: ClusterSecretStoreSpecProviderAwsAuthJwtServiceAccountRef;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAwsAuthJwt' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderAwsAuthJwt(
  obj: ClusterSecretStoreSpecProviderAwsAuthJwt | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    serviceAccountRef:
      toJson_ClusterSecretStoreSpecProviderAwsAuthJwtServiceAccountRef(
        obj.serviceAccountRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * AWSAuthSecretRef holds secret references for AWS credentials both AccessKeyID and SecretAccessKey must be defined in order to properly authenticate.
 *
 * @schema ClusterSecretStoreSpecProviderAwsAuthSecretRef
 */
export interface ClusterSecretStoreSpecProviderAwsAuthSecretRef {
  /**
   * The AccessKeyID is used for authentication
   *
   * @schema ClusterSecretStoreSpecProviderAwsAuthSecretRef#accessKeyIDSecretRef
   */
  readonly accessKeyIdSecretRef?: ClusterSecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef;

  /**
   * The SecretAccessKey is used for authentication
   *
   * @schema ClusterSecretStoreSpecProviderAwsAuthSecretRef#secretAccessKeySecretRef
   */
  readonly secretAccessKeySecretRef?: ClusterSecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAwsAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderAwsAuthSecretRef(
  obj: ClusterSecretStoreSpecProviderAwsAuthSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    accessKeyIDSecretRef:
      toJson_ClusterSecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef(
        obj.accessKeyIdSecretRef,
      ),
    secretAccessKeySecretRef:
      toJson_ClusterSecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef(
        obj.secretAccessKeySecretRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The Azure clientId of the service principle used for authentication.
 *
 * @schema ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientId
 */
export interface ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientId {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientId#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientId#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientId#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientId(
  obj: ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientId | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The Azure ClientSecret of the service principle used for authentication.
 *
 * @schema ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientSecret
 */
export interface ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientSecret {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientSecret#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientSecret#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientSecret#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientSecret(
  obj:
    | ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientSecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSecretStoreSpecProviderGcpsmAuthSecretRef
 */
export interface ClusterSecretStoreSpecProviderGcpsmAuthSecretRef {
  /**
   * The SecretAccessKey is used for authentication
   *
   * @schema ClusterSecretStoreSpecProviderGcpsmAuthSecretRef#secretAccessKeySecretRef
   */
  readonly secretAccessKeySecretRef?: ClusterSecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderGcpsmAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderGcpsmAuthSecretRef(
  obj: ClusterSecretStoreSpecProviderGcpsmAuthSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    secretAccessKeySecretRef:
      toJson_ClusterSecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef(
        obj.secretAccessKeySecretRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentity
 */
export interface ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentity {
  /**
   * @schema ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentity#clusterLocation
   */
  readonly clusterLocation: string;

  /**
   * @schema ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentity#clusterName
   */
  readonly clusterName: string;

  /**
   * @schema ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentity#clusterProjectID
   */
  readonly clusterProjectId?: string;

  /**
   * A reference to a ServiceAccount resource.
   *
   * @schema ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentity#serviceAccountRef
   */
  readonly serviceAccountRef: ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentity(
  obj: ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentity | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    clusterLocation: obj.clusterLocation,
    clusterName: obj.clusterName,
    clusterProjectID: obj.clusterProjectId,
    serviceAccountRef:
      toJson_ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef(
        obj.serviceAccountRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSecretStoreSpecProviderGitlabAuthSecretRef
 */
export interface ClusterSecretStoreSpecProviderGitlabAuthSecretRef {
  /**
   * AccessToken is used for authentication.
   *
   * @schema ClusterSecretStoreSpecProviderGitlabAuthSecretRef#accessToken
   */
  readonly accessToken?: ClusterSecretStoreSpecProviderGitlabAuthSecretRefAccessToken;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderGitlabAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderGitlabAuthSecretRef(
  obj: ClusterSecretStoreSpecProviderGitlabAuthSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    accessToken:
      toJson_ClusterSecretStoreSpecProviderGitlabAuthSecretRefAccessToken(
        obj.accessToken,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSecretStoreSpecProviderIbmAuthSecretRef
 */
export interface ClusterSecretStoreSpecProviderIbmAuthSecretRef {
  /**
   * The SecretAccessKey is used for authentication
   *
   * @schema ClusterSecretStoreSpecProviderIbmAuthSecretRef#secretApiKeySecretRef
   */
  readonly secretApiKeySecretRef?: ClusterSecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderIbmAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderIbmAuthSecretRef(
  obj: ClusterSecretStoreSpecProviderIbmAuthSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    secretApiKeySecretRef:
      toJson_ClusterSecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef(
        obj.secretApiKeySecretRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * has both clientCert and clientKey as secretKeySelector
 *
 * @schema ClusterSecretStoreSpecProviderKubernetesAuthCert
 */
export interface ClusterSecretStoreSpecProviderKubernetesAuthCert {
  /**
   * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesAuthCert#clientCert
   */
  readonly clientCert?: ClusterSecretStoreSpecProviderKubernetesAuthCertClientCert;

  /**
   * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesAuthCert#clientKey
   */
  readonly clientKey?: ClusterSecretStoreSpecProviderKubernetesAuthCertClientKey;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderKubernetesAuthCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderKubernetesAuthCert(
  obj: ClusterSecretStoreSpecProviderKubernetesAuthCert | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    clientCert:
      toJson_ClusterSecretStoreSpecProviderKubernetesAuthCertClientCert(
        obj.clientCert,
      ),
    clientKey: toJson_ClusterSecretStoreSpecProviderKubernetesAuthCertClientKey(
      obj.clientKey,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * points to a service account that should be used for authentication
 *
 * @schema ClusterSecretStoreSpecProviderKubernetesAuthServiceAccount
 */
export interface ClusterSecretStoreSpecProviderKubernetesAuthServiceAccount {
  /**
   * A reference to a ServiceAccount resource.
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesAuthServiceAccount#serviceAccount
   */
  readonly serviceAccount?: ClusterSecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderKubernetesAuthServiceAccount' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderKubernetesAuthServiceAccount(
  obj: ClusterSecretStoreSpecProviderKubernetesAuthServiceAccount | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    serviceAccount:
      toJson_ClusterSecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount(
        obj.serviceAccount,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * use static token to authenticate with
 *
 * @schema ClusterSecretStoreSpecProviderKubernetesAuthToken
 */
export interface ClusterSecretStoreSpecProviderKubernetesAuthToken {
  /**
   * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesAuthToken#bearerToken
   */
  readonly bearerToken?: ClusterSecretStoreSpecProviderKubernetesAuthTokenBearerToken;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderKubernetesAuthToken' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderKubernetesAuthToken(
  obj: ClusterSecretStoreSpecProviderKubernetesAuthToken | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    bearerToken:
      toJson_ClusterSecretStoreSpecProviderKubernetesAuthTokenBearerToken(
        obj.bearerToken,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * see: https://external-secrets.io/v0.4.1/spec/#external-secrets.io/v1alpha1.CAProvider
 *
 * @schema ClusterSecretStoreSpecProviderKubernetesServerCaProvider
 */
export interface ClusterSecretStoreSpecProviderKubernetesServerCaProvider {
  /**
   * The key the value inside of the provider type to use, only used with "Secret" type
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesServerCaProvider#key
   */
  readonly key?: string;

  /**
   * The name of the object located at the provider type.
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesServerCaProvider#name
   */
  readonly name: string;

  /**
   * The namespace the Provider type is in.
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesServerCaProvider#namespace
   */
  readonly namespace?: string;

  /**
   * The type of provider to use such as "Secret", or "ConfigMap".
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesServerCaProvider#type
   */
  readonly type: ClusterSecretStoreSpecProviderKubernetesServerCaProviderType;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderKubernetesServerCaProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderKubernetesServerCaProvider(
  obj: ClusterSecretStoreSpecProviderKubernetesServerCaProvider | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
    type: obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * SecretRef to pass through sensitive information.
 *
 * @schema ClusterSecretStoreSpecProviderOracleAuthSecretRef
 */
export interface ClusterSecretStoreSpecProviderOracleAuthSecretRef {
  /**
   * Fingerprint is the fingerprint of the API private key.
   *
   * @schema ClusterSecretStoreSpecProviderOracleAuthSecretRef#fingerprint
   */
  readonly fingerprint: ClusterSecretStoreSpecProviderOracleAuthSecretRefFingerprint;

  /**
   * PrivateKey is the user's API Signing Key in PEM format, used for authentication.
   *
   * @schema ClusterSecretStoreSpecProviderOracleAuthSecretRef#privatekey
   */
  readonly privatekey: ClusterSecretStoreSpecProviderOracleAuthSecretRefPrivatekey;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderOracleAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderOracleAuthSecretRef(
  obj: ClusterSecretStoreSpecProviderOracleAuthSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    fingerprint:
      toJson_ClusterSecretStoreSpecProviderOracleAuthSecretRefFingerprint(
        obj.fingerprint,
      ),
    privatekey:
      toJson_ClusterSecretStoreSpecProviderOracleAuthSecretRefPrivatekey(
        obj.privatekey,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * AppRole authenticates with Vault using the App Role auth mechanism, with the role and secret stored in a Kubernetes Secret resource.
 *
 * @schema ClusterSecretStoreSpecProviderVaultAuthAppRole
 */
export interface ClusterSecretStoreSpecProviderVaultAuthAppRole {
  /**
   * Path where the App Role authentication backend is mounted in Vault, e.g: "approle"
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthAppRole#path
   */
  readonly path: string;

  /**
   * RoleID configured in the App Role authentication backend when setting up the authentication backend in Vault.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthAppRole#roleId
   */
  readonly roleId: string;

  /**
   * Reference to a key in a Secret that contains the App Role secret used to authenticate with Vault. The `key` field must be specified and denotes which entry within the Secret resource is used as the app role secret.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthAppRole#secretRef
   */
  readonly secretRef: ClusterSecretStoreSpecProviderVaultAuthAppRoleSecretRef;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderVaultAuthAppRole' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderVaultAuthAppRole(
  obj: ClusterSecretStoreSpecProviderVaultAuthAppRole | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    path: obj.path,
    roleId: obj.roleId,
    secretRef: toJson_ClusterSecretStoreSpecProviderVaultAuthAppRoleSecretRef(
      obj.secretRef,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Cert authenticates with TLS Certificates by passing client certificate, private key and ca certificate Cert authentication method
 *
 * @schema ClusterSecretStoreSpecProviderVaultAuthCert
 */
export interface ClusterSecretStoreSpecProviderVaultAuthCert {
  /**
   * ClientCert is a certificate to authenticate using the Cert Vault authentication method
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthCert#clientCert
   */
  readonly clientCert?: ClusterSecretStoreSpecProviderVaultAuthCertClientCert;

  /**
   * SecretRef to a key in a Secret resource containing client private key to authenticate with Vault using the Cert authentication method
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthCert#secretRef
   */
  readonly secretRef?: ClusterSecretStoreSpecProviderVaultAuthCertSecretRef;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderVaultAuthCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderVaultAuthCert(
  obj: ClusterSecretStoreSpecProviderVaultAuthCert | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    clientCert: toJson_ClusterSecretStoreSpecProviderVaultAuthCertClientCert(
      obj.clientCert,
    ),
    secretRef: toJson_ClusterSecretStoreSpecProviderVaultAuthCertSecretRef(
      obj.secretRef,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Jwt authenticates with Vault by passing role and JWT token using the JWT/OIDC authentication method
 *
 * @schema ClusterSecretStoreSpecProviderVaultAuthJwt
 */
export interface ClusterSecretStoreSpecProviderVaultAuthJwt {
  /**
   * Optional ServiceAccountToken specifies the Kubernetes service account for which to request a token for with the `TokenRequest` API.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthJwt#kubernetesServiceAccountToken
   */
  readonly kubernetesServiceAccountToken?: ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken;

  /**
   * Path where the JWT authentication backend is mounted in Vault, e.g: "jwt"
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthJwt#path
   */
  readonly path: string;

  /**
   * Role is a JWT role to authenticate using the JWT/OIDC Vault authentication method
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthJwt#role
   */
  readonly role?: string;

  /**
   * Optional SecretRef that refers to a key in a Secret resource containing JWT token to authenticate with Vault using the JWT/OIDC authentication method.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthJwt#secretRef
   */
  readonly secretRef?: ClusterSecretStoreSpecProviderVaultAuthJwtSecretRef;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderVaultAuthJwt' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderVaultAuthJwt(
  obj: ClusterSecretStoreSpecProviderVaultAuthJwt | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    kubernetesServiceAccountToken:
      toJson_ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken(
        obj.kubernetesServiceAccountToken,
      ),
    path: obj.path,
    role: obj.role,
    secretRef: toJson_ClusterSecretStoreSpecProviderVaultAuthJwtSecretRef(
      obj.secretRef,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Kubernetes authenticates with Vault by passing the ServiceAccount token stored in the named Secret resource to the Vault server.
 *
 * @schema ClusterSecretStoreSpecProviderVaultAuthKubernetes
 */
export interface ClusterSecretStoreSpecProviderVaultAuthKubernetes {
  /**
   * Path where the Kubernetes authentication backend is mounted in Vault, e.g: "kubernetes"
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthKubernetes#mountPath
   */
  readonly mountPath: string;

  /**
   * A required field containing the Vault Role to assume. A Role binds a Kubernetes ServiceAccount with a set of Vault policies.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthKubernetes#role
   */
  readonly role: string;

  /**
   * Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Vault. If a name is specified without a key, `token` is the default. If one is not specified, the one bound to the controller will be used.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthKubernetes#secretRef
   */
  readonly secretRef?: ClusterSecretStoreSpecProviderVaultAuthKubernetesSecretRef;

  /**
   * Optional service account field containing the name of a kubernetes ServiceAccount. If the service account is specified, the service account secret token JWT will be used for authenticating with Vault. If the service account selector is not supplied, the secretRef will be used instead.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthKubernetes#serviceAccountRef
   */
  readonly serviceAccountRef?: ClusterSecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderVaultAuthKubernetes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderVaultAuthKubernetes(
  obj: ClusterSecretStoreSpecProviderVaultAuthKubernetes | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    mountPath: obj.mountPath,
    role: obj.role,
    secretRef:
      toJson_ClusterSecretStoreSpecProviderVaultAuthKubernetesSecretRef(
        obj.secretRef,
      ),
    serviceAccountRef:
      toJson_ClusterSecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef(
        obj.serviceAccountRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Ldap authenticates with Vault by passing username/password pair using the LDAP authentication method
 *
 * @schema ClusterSecretStoreSpecProviderVaultAuthLdap
 */
export interface ClusterSecretStoreSpecProviderVaultAuthLdap {
  /**
   * Path where the LDAP authentication backend is mounted in Vault, e.g: "ldap"
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthLdap#path
   */
  readonly path: string;

  /**
   * SecretRef to a key in a Secret resource containing password for the LDAP user used to authenticate with Vault using the LDAP authentication method
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthLdap#secretRef
   */
  readonly secretRef?: ClusterSecretStoreSpecProviderVaultAuthLdapSecretRef;

  /**
   * Username is a LDAP user name used to authenticate using the LDAP Vault authentication method
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthLdap#username
   */
  readonly username: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderVaultAuthLdap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderVaultAuthLdap(
  obj: ClusterSecretStoreSpecProviderVaultAuthLdap | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    path: obj.path,
    secretRef: toJson_ClusterSecretStoreSpecProviderVaultAuthLdapSecretRef(
      obj.secretRef,
    ),
    username: obj.username,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * TokenSecretRef authenticates with Vault by presenting a token.
 *
 * @schema ClusterSecretStoreSpecProviderVaultAuthTokenSecretRef
 */
export interface ClusterSecretStoreSpecProviderVaultAuthTokenSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthTokenSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthTokenSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthTokenSecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderVaultAuthTokenSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderVaultAuthTokenSecretRef(
  obj: ClusterSecretStoreSpecProviderVaultAuthTokenSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The type of provider to use such as "Secret", or "ConfigMap".
 *
 * @schema ClusterSecretStoreSpecProviderVaultCaProviderType
 */
export enum ClusterSecretStoreSpecProviderVaultCaProviderType {
  /** Secret */
  SECRET = "Secret",
  /** ConfigMap */
  CONFIG_MAP = "ConfigMap",
}

/**
 * The type of provider to use such as "Secret", or "ConfigMap".
 *
 * @schema ClusterSecretStoreSpecProviderWebhookCaProviderType
 */
export enum ClusterSecretStoreSpecProviderWebhookCaProviderType {
  /** Secret */
  SECRET = "Secret",
  /** ConfigMap */
  CONFIG_MAP = "ConfigMap",
}

/**
 * Secret ref to fill in credentials
 *
 * @schema ClusterSecretStoreSpecProviderWebhookSecretsSecretRef
 */
export interface ClusterSecretStoreSpecProviderWebhookSecretsSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderWebhookSecretsSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderWebhookSecretsSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderWebhookSecretsSecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderWebhookSecretsSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderWebhookSecretsSecretRef(
  obj: ClusterSecretStoreSpecProviderWebhookSecretsSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The authorized key used for authentication
 *
 * @schema ClusterSecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef
 */
export interface ClusterSecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef(
  obj:
    | ClusterSecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
 *
 * @schema ClusterSecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef
 */
export interface ClusterSecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef(
  obj:
    | ClusterSecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Akeyless. If a name is specified without a key, `token` is the default. If one is not specified, the one bound to the controller will be used.
 *
 * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef
 */
export interface ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef(
  obj:
    | ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Optional service account field containing the name of a kubernetes ServiceAccount. If the service account is specified, the service account secret token JWT will be used for authenticating with Akeyless. If the service account selector is not supplied, the secretRef will be used instead.
 *
 * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef
 */
export interface ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef(
  obj:
    | ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    audiences: obj.audiences?.map((y) => y),
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The SecretAccessID is used for authentication
 *
 * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId
 */
export interface ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId(
  obj:
    | ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
 *
 * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType
 */
export interface ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType(
  obj:
    | ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
 *
 * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam
 */
export interface ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam(
  obj:
    | ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The AccessKeyID is used for authentication
 *
 * @schema ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef
 */
export interface ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef(
  obj:
    | ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The AccessKeySecret is used for authentication
 *
 * @schema ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef
 */
export interface ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef(
  obj:
    | ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A reference to a ServiceAccount resource.
 *
 * @schema ClusterSecretStoreSpecProviderAwsAuthJwtServiceAccountRef
 */
export interface ClusterSecretStoreSpecProviderAwsAuthJwtServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
   *
   * @schema ClusterSecretStoreSpecProviderAwsAuthJwtServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderAwsAuthJwtServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderAwsAuthJwtServiceAccountRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAwsAuthJwtServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderAwsAuthJwtServiceAccountRef(
  obj: ClusterSecretStoreSpecProviderAwsAuthJwtServiceAccountRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    audiences: obj.audiences?.map((y) => y),
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The AccessKeyID is used for authentication
 *
 * @schema ClusterSecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef
 */
export interface ClusterSecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef(
  obj:
    | ClusterSecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The SecretAccessKey is used for authentication
 *
 * @schema ClusterSecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef
 */
export interface ClusterSecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef(
  obj:
    | ClusterSecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The SecretAccessKey is used for authentication
 *
 * @schema ClusterSecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef
 */
export interface ClusterSecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef(
  obj:
    | ClusterSecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A reference to a ServiceAccount resource.
 *
 * @schema ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef
 */
export interface ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
   *
   * @schema ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef(
  obj:
    | ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    audiences: obj.audiences?.map((y) => y),
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * AccessToken is used for authentication.
 *
 * @schema ClusterSecretStoreSpecProviderGitlabAuthSecretRefAccessToken
 */
export interface ClusterSecretStoreSpecProviderGitlabAuthSecretRefAccessToken {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderGitlabAuthSecretRefAccessToken#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderGitlabAuthSecretRefAccessToken#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderGitlabAuthSecretRefAccessToken#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderGitlabAuthSecretRefAccessToken' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderGitlabAuthSecretRefAccessToken(
  obj: ClusterSecretStoreSpecProviderGitlabAuthSecretRefAccessToken | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The SecretAccessKey is used for authentication
 *
 * @schema ClusterSecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef
 */
export interface ClusterSecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef(
  obj:
    | ClusterSecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
 *
 * @schema ClusterSecretStoreSpecProviderKubernetesAuthCertClientCert
 */
export interface ClusterSecretStoreSpecProviderKubernetesAuthCertClientCert {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesAuthCertClientCert#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesAuthCertClientCert#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesAuthCertClientCert#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderKubernetesAuthCertClientCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderKubernetesAuthCertClientCert(
  obj: ClusterSecretStoreSpecProviderKubernetesAuthCertClientCert | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
 *
 * @schema ClusterSecretStoreSpecProviderKubernetesAuthCertClientKey
 */
export interface ClusterSecretStoreSpecProviderKubernetesAuthCertClientKey {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesAuthCertClientKey#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesAuthCertClientKey#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesAuthCertClientKey#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderKubernetesAuthCertClientKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderKubernetesAuthCertClientKey(
  obj: ClusterSecretStoreSpecProviderKubernetesAuthCertClientKey | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A reference to a ServiceAccount resource.
 *
 * @schema ClusterSecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount
 */
export interface ClusterSecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount {
  /**
   * Audience specifies the `aud` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount(
  obj:
    | ClusterSecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    audiences: obj.audiences?.map((y) => y),
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
 *
 * @schema ClusterSecretStoreSpecProviderKubernetesAuthTokenBearerToken
 */
export interface ClusterSecretStoreSpecProviderKubernetesAuthTokenBearerToken {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesAuthTokenBearerToken#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesAuthTokenBearerToken#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesAuthTokenBearerToken#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderKubernetesAuthTokenBearerToken' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderKubernetesAuthTokenBearerToken(
  obj: ClusterSecretStoreSpecProviderKubernetesAuthTokenBearerToken | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The type of provider to use such as "Secret", or "ConfigMap".
 *
 * @schema ClusterSecretStoreSpecProviderKubernetesServerCaProviderType
 */
export enum ClusterSecretStoreSpecProviderKubernetesServerCaProviderType {
  /** Secret */
  SECRET = "Secret",
  /** ConfigMap */
  CONFIG_MAP = "ConfigMap",
}

/**
 * Fingerprint is the fingerprint of the API private key.
 *
 * @schema ClusterSecretStoreSpecProviderOracleAuthSecretRefFingerprint
 */
export interface ClusterSecretStoreSpecProviderOracleAuthSecretRefFingerprint {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderOracleAuthSecretRefFingerprint#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderOracleAuthSecretRefFingerprint#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderOracleAuthSecretRefFingerprint#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderOracleAuthSecretRefFingerprint' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderOracleAuthSecretRefFingerprint(
  obj: ClusterSecretStoreSpecProviderOracleAuthSecretRefFingerprint | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * PrivateKey is the user's API Signing Key in PEM format, used for authentication.
 *
 * @schema ClusterSecretStoreSpecProviderOracleAuthSecretRefPrivatekey
 */
export interface ClusterSecretStoreSpecProviderOracleAuthSecretRefPrivatekey {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderOracleAuthSecretRefPrivatekey#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderOracleAuthSecretRefPrivatekey#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderOracleAuthSecretRefPrivatekey#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderOracleAuthSecretRefPrivatekey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderOracleAuthSecretRefPrivatekey(
  obj: ClusterSecretStoreSpecProviderOracleAuthSecretRefPrivatekey | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a key in a Secret that contains the App Role secret used to authenticate with Vault. The `key` field must be specified and denotes which entry within the Secret resource is used as the app role secret.
 *
 * @schema ClusterSecretStoreSpecProviderVaultAuthAppRoleSecretRef
 */
export interface ClusterSecretStoreSpecProviderVaultAuthAppRoleSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthAppRoleSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthAppRoleSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthAppRoleSecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderVaultAuthAppRoleSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderVaultAuthAppRoleSecretRef(
  obj: ClusterSecretStoreSpecProviderVaultAuthAppRoleSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ClientCert is a certificate to authenticate using the Cert Vault authentication method
 *
 * @schema ClusterSecretStoreSpecProviderVaultAuthCertClientCert
 */
export interface ClusterSecretStoreSpecProviderVaultAuthCertClientCert {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthCertClientCert#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthCertClientCert#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthCertClientCert#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderVaultAuthCertClientCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderVaultAuthCertClientCert(
  obj: ClusterSecretStoreSpecProviderVaultAuthCertClientCert | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * SecretRef to a key in a Secret resource containing client private key to authenticate with Vault using the Cert authentication method
 *
 * @schema ClusterSecretStoreSpecProviderVaultAuthCertSecretRef
 */
export interface ClusterSecretStoreSpecProviderVaultAuthCertSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthCertSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthCertSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthCertSecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderVaultAuthCertSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderVaultAuthCertSecretRef(
  obj: ClusterSecretStoreSpecProviderVaultAuthCertSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Optional ServiceAccountToken specifies the Kubernetes service account for which to request a token for with the `TokenRequest` API.
 *
 * @schema ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken
 */
export interface ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken {
  /**
   * Optional audiences field that will be used to request a temporary Kubernetes service account token for the service account referenced by `serviceAccountRef`. Defaults to a single audience `vault` it not specified.
   *
   * @default a single audience `vault` it not specified.
   * @schema ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken#audiences
   */
  readonly audiences?: string[];

  /**
   * Optional expiration time in seconds that will be used to request a temporary Kubernetes service account token for the service account referenced by `serviceAccountRef`. Defaults to 10 minutes.
   *
   * @default 10 minutes.
   * @schema ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken#expirationSeconds
   */
  readonly expirationSeconds?: number;

  /**
   * Service account field containing the name of a kubernetes ServiceAccount.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken#serviceAccountRef
   */
  readonly serviceAccountRef: ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken(
  obj:
    | ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    audiences: obj.audiences?.map((y) => y),
    expirationSeconds: obj.expirationSeconds,
    serviceAccountRef:
      toJson_ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef(
        obj.serviceAccountRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Optional SecretRef that refers to a key in a Secret resource containing JWT token to authenticate with Vault using the JWT/OIDC authentication method.
 *
 * @schema ClusterSecretStoreSpecProviderVaultAuthJwtSecretRef
 */
export interface ClusterSecretStoreSpecProviderVaultAuthJwtSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthJwtSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthJwtSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthJwtSecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderVaultAuthJwtSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderVaultAuthJwtSecretRef(
  obj: ClusterSecretStoreSpecProviderVaultAuthJwtSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Vault. If a name is specified without a key, `token` is the default. If one is not specified, the one bound to the controller will be used.
 *
 * @schema ClusterSecretStoreSpecProviderVaultAuthKubernetesSecretRef
 */
export interface ClusterSecretStoreSpecProviderVaultAuthKubernetesSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthKubernetesSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthKubernetesSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthKubernetesSecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderVaultAuthKubernetesSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderVaultAuthKubernetesSecretRef(
  obj: ClusterSecretStoreSpecProviderVaultAuthKubernetesSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Optional service account field containing the name of a kubernetes ServiceAccount. If the service account is specified, the service account secret token JWT will be used for authenticating with Vault. If the service account selector is not supplied, the secretRef will be used instead.
 *
 * @schema ClusterSecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef
 */
export interface ClusterSecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef(
  obj:
    | ClusterSecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    audiences: obj.audiences?.map((y) => y),
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * SecretRef to a key in a Secret resource containing password for the LDAP user used to authenticate with Vault using the LDAP authentication method
 *
 * @schema ClusterSecretStoreSpecProviderVaultAuthLdapSecretRef
 */
export interface ClusterSecretStoreSpecProviderVaultAuthLdapSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthLdapSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthLdapSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthLdapSecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderVaultAuthLdapSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderVaultAuthLdapSecretRef(
  obj: ClusterSecretStoreSpecProviderVaultAuthLdapSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Service account field containing the name of a kubernetes ServiceAccount.
 *
 * @schema ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef
 */
export interface ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef(
  obj:
    | ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    audiences: obj.audiences?.map((y) => y),
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ClusterSecretStore represents a secure external location for storing secrets, which can be referenced as part of `storeRef` fields.
 *
 * @schema ClusterSecretStoreV1Beta1
 */
export class ClusterSecretStoreV1Beta1 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ClusterSecretStoreV1Beta1"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "external-secrets.io/v1beta1",
    kind: "ClusterSecretStore",
  };

  /**
   * Renders a Kubernetes manifest for "ClusterSecretStoreV1Beta1".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ClusterSecretStoreV1Beta1Props = {}): any {
    return {
      ...ClusterSecretStoreV1Beta1.GVK,
      ...toJson_ClusterSecretStoreV1Beta1Props(props),
    };
  }

  /**
   * Defines a "ClusterSecretStoreV1Beta1" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(
    scope: Construct,
    id: string,
    props: ClusterSecretStoreV1Beta1Props = {},
  ) {
    super(scope, id, {
      ...ClusterSecretStoreV1Beta1.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ClusterSecretStoreV1Beta1.GVK,
      ...toJson_ClusterSecretStoreV1Beta1Props(resolved),
    };
  }
}

/**
 * ClusterSecretStore represents a secure external location for storing secrets, which can be referenced as part of `storeRef` fields.
 *
 * @schema ClusterSecretStoreV1Beta1
 */
export interface ClusterSecretStoreV1Beta1Props {
  /**
   * @schema ClusterSecretStoreV1Beta1#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * SecretStoreSpec defines the desired state of SecretStore.
   *
   * @schema ClusterSecretStoreV1Beta1#spec
   */
  readonly spec?: ClusterSecretStoreV1Beta1Spec;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1Props(
  obj: ClusterSecretStoreV1Beta1Props | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    spec: toJson_ClusterSecretStoreV1Beta1Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreSpec defines the desired state of SecretStore.
 *
 * @schema ClusterSecretStoreV1Beta1Spec
 */
export interface ClusterSecretStoreV1Beta1Spec {
  /**
   * Used to constraint a ClusterSecretStore to specific namespaces. Relevant only to ClusterSecretStore
   *
   * @schema ClusterSecretStoreV1Beta1Spec#conditions
   */
  readonly conditions?: ClusterSecretStoreV1Beta1SpecConditions[];

  /**
   * Used to select the correct ESO controller (think: ingress.ingressClassName) The ESO controller is instantiated with a specific controller name and filters ES based on this property
   *
   * @schema ClusterSecretStoreV1Beta1Spec#controller
   */
  readonly controller?: string;

  /**
   * Used to configure the provider. Only one provider may be set
   *
   * @schema ClusterSecretStoreV1Beta1Spec#provider
   */
  readonly provider: ClusterSecretStoreV1Beta1SpecProvider;

  /**
   * Used to configure store refresh interval in seconds. Empty or 0 will default to the controller config.
   *
   * @schema ClusterSecretStoreV1Beta1Spec#refreshInterval
   */
  readonly refreshInterval?: number;

  /**
   * Used to configure http retries if failed
   *
   * @schema ClusterSecretStoreV1Beta1Spec#retrySettings
   */
  readonly retrySettings?: ClusterSecretStoreV1Beta1SpecRetrySettings;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1Spec(
  obj: ClusterSecretStoreV1Beta1Spec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    conditions: obj.conditions?.map((y) =>
      toJson_ClusterSecretStoreV1Beta1SpecConditions(y),
    ),
    controller: obj.controller,
    provider: toJson_ClusterSecretStoreV1Beta1SpecProvider(obj.provider),
    refreshInterval: obj.refreshInterval,
    retrySettings: toJson_ClusterSecretStoreV1Beta1SpecRetrySettings(
      obj.retrySettings,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ClusterSecretStoreCondition describes a condition by which to choose namespaces to process ExternalSecrets in for a ClusterSecretStore instance.
 *
 * @schema ClusterSecretStoreV1Beta1SpecConditions
 */
export interface ClusterSecretStoreV1Beta1SpecConditions {
  /**
   * Choose namespace using a labelSelector
   *
   * @schema ClusterSecretStoreV1Beta1SpecConditions#namespaceSelector
   */
  readonly namespaceSelector?: ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelector;

  /**
   * Choose namespaces by name
   *
   * @schema ClusterSecretStoreV1Beta1SpecConditions#namespaces
   */
  readonly namespaces?: string[];
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecConditions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecConditions(
  obj: ClusterSecretStoreV1Beta1SpecConditions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    namespaceSelector:
      toJson_ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelector(
        obj.namespaceSelector,
      ),
    namespaces: obj.namespaces?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Used to configure the provider. Only one provider may be set
 *
 * @schema ClusterSecretStoreV1Beta1SpecProvider
 */
export interface ClusterSecretStoreV1Beta1SpecProvider {
  /**
   * Akeyless configures this store to sync secrets using Akeyless Vault provider
   *
   * @schema ClusterSecretStoreV1Beta1SpecProvider#akeyless
   */
  readonly akeyless?: ClusterSecretStoreV1Beta1SpecProviderAkeyless;

  /**
   * Alibaba configures this store to sync secrets using Alibaba Cloud provider
   *
   * @schema ClusterSecretStoreV1Beta1SpecProvider#alibaba
   */
  readonly alibaba?: ClusterSecretStoreV1Beta1SpecProviderAlibaba;

  /**
   * AWS configures this store to sync secrets using AWS Secret Manager provider
   *
   * @schema ClusterSecretStoreV1Beta1SpecProvider#aws
   */
  readonly aws?: ClusterSecretStoreV1Beta1SpecProviderAws;

  /**
   * AzureKV configures this store to sync secrets using Azure Key Vault provider
   *
   * @schema ClusterSecretStoreV1Beta1SpecProvider#azurekv
   */
  readonly azurekv?: ClusterSecretStoreV1Beta1SpecProviderAzurekv;

  /**
   * Conjur configures this store to sync secrets using conjur provider
   *
   * @schema ClusterSecretStoreV1Beta1SpecProvider#conjur
   */
  readonly conjur?: ClusterSecretStoreV1Beta1SpecProviderConjur;

  /**
   * Delinea DevOps Secrets Vault https://docs.delinea.com/online-help/products/devops-secrets-vault/current
   *
   * @schema ClusterSecretStoreV1Beta1SpecProvider#delinea
   */
  readonly delinea?: ClusterSecretStoreV1Beta1SpecProviderDelinea;

  /**
   * Doppler configures this store to sync secrets using the Doppler provider
   *
   * @schema ClusterSecretStoreV1Beta1SpecProvider#doppler
   */
  readonly doppler?: ClusterSecretStoreV1Beta1SpecProviderDoppler;

  /**
   * Fake configures a store with static key/value pairs
   *
   * @schema ClusterSecretStoreV1Beta1SpecProvider#fake
   */
  readonly fake?: ClusterSecretStoreV1Beta1SpecProviderFake;

  /**
   * GCPSM configures this store to sync secrets using Google Cloud Platform Secret Manager provider
   *
   * @schema ClusterSecretStoreV1Beta1SpecProvider#gcpsm
   */
  readonly gcpsm?: ClusterSecretStoreV1Beta1SpecProviderGcpsm;

  /**
   * GitLab configures this store to sync secrets using GitLab Variables provider
   *
   * @schema ClusterSecretStoreV1Beta1SpecProvider#gitlab
   */
  readonly gitlab?: ClusterSecretStoreV1Beta1SpecProviderGitlab;

  /**
   * IBM configures this store to sync secrets using IBM Cloud provider
   *
   * @schema ClusterSecretStoreV1Beta1SpecProvider#ibm
   */
  readonly ibm?: ClusterSecretStoreV1Beta1SpecProviderIbm;

  /**
   * KeeperSecurity configures this store to sync secrets using the KeeperSecurity provider
   *
   * @schema ClusterSecretStoreV1Beta1SpecProvider#keepersecurity
   */
  readonly keepersecurity?: ClusterSecretStoreV1Beta1SpecProviderKeepersecurity;

  /**
   * Kubernetes configures this store to sync secrets using a Kubernetes cluster provider
   *
   * @schema ClusterSecretStoreV1Beta1SpecProvider#kubernetes
   */
  readonly kubernetes?: ClusterSecretStoreV1Beta1SpecProviderKubernetes;

  /**
   * OnePassword configures this store to sync secrets using the 1Password Cloud provider
   *
   * @schema ClusterSecretStoreV1Beta1SpecProvider#onepassword
   */
  readonly onepassword?: ClusterSecretStoreV1Beta1SpecProviderOnepassword;

  /**
   * Oracle configures this store to sync secrets using Oracle Vault provider
   *
   * @schema ClusterSecretStoreV1Beta1SpecProvider#oracle
   */
  readonly oracle?: ClusterSecretStoreV1Beta1SpecProviderOracle;

  /**
   * Scaleway
   *
   * @schema ClusterSecretStoreV1Beta1SpecProvider#scaleway
   */
  readonly scaleway?: ClusterSecretStoreV1Beta1SpecProviderScaleway;

  /**
   * Senhasegura configures this store to sync secrets using senhasegura provider
   *
   * @schema ClusterSecretStoreV1Beta1SpecProvider#senhasegura
   */
  readonly senhasegura?: ClusterSecretStoreV1Beta1SpecProviderSenhasegura;

  /**
   * Vault configures this store to sync secrets using Hashi provider
   *
   * @schema ClusterSecretStoreV1Beta1SpecProvider#vault
   */
  readonly vault?: ClusterSecretStoreV1Beta1SpecProviderVault;

  /**
   * Webhook configures this store to sync secrets using a generic templated webhook
   *
   * @schema ClusterSecretStoreV1Beta1SpecProvider#webhook
   */
  readonly webhook?: ClusterSecretStoreV1Beta1SpecProviderWebhook;

  /**
   * YandexCertificateManager configures this store to sync secrets using Yandex Certificate Manager provider
   *
   * @schema ClusterSecretStoreV1Beta1SpecProvider#yandexcertificatemanager
   */
  readonly yandexcertificatemanager?: ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanager;

  /**
   * YandexLockbox configures this store to sync secrets using Yandex Lockbox provider
   *
   * @schema ClusterSecretStoreV1Beta1SpecProvider#yandexlockbox
   */
  readonly yandexlockbox?: ClusterSecretStoreV1Beta1SpecProviderYandexlockbox;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProvider(
  obj: ClusterSecretStoreV1Beta1SpecProvider | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    akeyless: toJson_ClusterSecretStoreV1Beta1SpecProviderAkeyless(
      obj.akeyless,
    ),
    alibaba: toJson_ClusterSecretStoreV1Beta1SpecProviderAlibaba(obj.alibaba),
    aws: toJson_ClusterSecretStoreV1Beta1SpecProviderAws(obj.aws),
    azurekv: toJson_ClusterSecretStoreV1Beta1SpecProviderAzurekv(obj.azurekv),
    conjur: toJson_ClusterSecretStoreV1Beta1SpecProviderConjur(obj.conjur),
    delinea: toJson_ClusterSecretStoreV1Beta1SpecProviderDelinea(obj.delinea),
    doppler: toJson_ClusterSecretStoreV1Beta1SpecProviderDoppler(obj.doppler),
    fake: toJson_ClusterSecretStoreV1Beta1SpecProviderFake(obj.fake),
    gcpsm: toJson_ClusterSecretStoreV1Beta1SpecProviderGcpsm(obj.gcpsm),
    gitlab: toJson_ClusterSecretStoreV1Beta1SpecProviderGitlab(obj.gitlab),
    ibm: toJson_ClusterSecretStoreV1Beta1SpecProviderIbm(obj.ibm),
    keepersecurity: toJson_ClusterSecretStoreV1Beta1SpecProviderKeepersecurity(
      obj.keepersecurity,
    ),
    kubernetes: toJson_ClusterSecretStoreV1Beta1SpecProviderKubernetes(
      obj.kubernetes,
    ),
    onepassword: toJson_ClusterSecretStoreV1Beta1SpecProviderOnepassword(
      obj.onepassword,
    ),
    oracle: toJson_ClusterSecretStoreV1Beta1SpecProviderOracle(obj.oracle),
    scaleway: toJson_ClusterSecretStoreV1Beta1SpecProviderScaleway(
      obj.scaleway,
    ),
    senhasegura: toJson_ClusterSecretStoreV1Beta1SpecProviderSenhasegura(
      obj.senhasegura,
    ),
    vault: toJson_ClusterSecretStoreV1Beta1SpecProviderVault(obj.vault),
    webhook: toJson_ClusterSecretStoreV1Beta1SpecProviderWebhook(obj.webhook),
    yandexcertificatemanager:
      toJson_ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanager(
        obj.yandexcertificatemanager,
      ),
    yandexlockbox: toJson_ClusterSecretStoreV1Beta1SpecProviderYandexlockbox(
      obj.yandexlockbox,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Used to configure http retries if failed
 *
 * @schema ClusterSecretStoreV1Beta1SpecRetrySettings
 */
export interface ClusterSecretStoreV1Beta1SpecRetrySettings {
  /**
   * @schema ClusterSecretStoreV1Beta1SpecRetrySettings#maxRetries
   */
  readonly maxRetries?: number;

  /**
   * @schema ClusterSecretStoreV1Beta1SpecRetrySettings#retryInterval
   */
  readonly retryInterval?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecRetrySettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecRetrySettings(
  obj: ClusterSecretStoreV1Beta1SpecRetrySettings | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    maxRetries: obj.maxRetries,
    retryInterval: obj.retryInterval,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Choose namespace using a labelSelector
 *
 * @schema ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelector
 */
export interface ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelector(
  obj: ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelector | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) =>
      toJson_ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions(
        y,
      ),
    ),
    matchLabels:
      obj.matchLabels === undefined
        ? undefined
        : Object.entries(obj.matchLabels).reduce(
            (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
            {},
          ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Akeyless configures this store to sync secrets using Akeyless Vault provider
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAkeyless
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAkeyless {
  /**
   * Akeyless GW API Url from which the secrets to be fetched from.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeyless#akeylessGWApiURL
   */
  readonly akeylessGwApiUrl: string;

  /**
   * Auth configures how the operator authenticates with Akeyless.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeyless#authSecretRef
   */
  readonly authSecretRef: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef;

  /**
   * PEM/base64 encoded CA bundle used to validate Akeyless Gateway certificate. Only used if the AkeylessGWApiURL URL is using HTTPS protocol. If not set the system root certificates are used to validate the TLS connection.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeyless#caBundle
   */
  readonly caBundle?: string;

  /**
   * The provider for the CA bundle to use to validate Akeyless Gateway certificate.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeyless#caProvider
   */
  readonly caProvider?: ClusterSecretStoreV1Beta1SpecProviderAkeylessCaProvider;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAkeyless' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAkeyless(
  obj: ClusterSecretStoreV1Beta1SpecProviderAkeyless | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    akeylessGWApiURL: obj.akeylessGwApiUrl,
    authSecretRef:
      toJson_ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef(
        obj.authSecretRef,
      ),
    caBundle: obj.caBundle,
    caProvider: toJson_ClusterSecretStoreV1Beta1SpecProviderAkeylessCaProvider(
      obj.caProvider,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Alibaba configures this store to sync secrets using Alibaba Cloud provider
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAlibaba
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAlibaba {
  /**
   * AlibabaAuth contains a secretRef for credentials.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAlibaba#auth
   */
  readonly auth: ClusterSecretStoreV1Beta1SpecProviderAlibabaAuth;

  /**
   * Alibaba Region to be used for the provider
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAlibaba#regionID
   */
  readonly regionId: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAlibaba' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAlibaba(
  obj: ClusterSecretStoreV1Beta1SpecProviderAlibaba | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    auth: toJson_ClusterSecretStoreV1Beta1SpecProviderAlibabaAuth(obj.auth),
    regionID: obj.regionId,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * AWS configures this store to sync secrets using AWS Secret Manager provider
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAws
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAws {
  /**
   * AdditionalRoles is a chained list of Role ARNs which the provider will sequentially assume before assuming the Role
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAws#additionalRoles
   */
  readonly additionalRoles?: string[];

  /**
   * Auth defines the information necessary to authenticate against AWS if not set aws sdk will infer credentials from your environment see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAws#auth
   */
  readonly auth?: ClusterSecretStoreV1Beta1SpecProviderAwsAuth;

  /**
   * AWS External ID set on assumed IAM roles
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAws#externalID
   */
  readonly externalId?: string;

  /**
   * AWS Region to be used for the provider
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAws#region
   */
  readonly region: string;

  /**
   * Role is a Role ARN which the provider will assume
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAws#role
   */
  readonly role?: string;

  /**
   * SecretsManager defines how the provider behaves when interacting with AWS SecretsManager
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAws#secretsManager
   */
  readonly secretsManager?: ClusterSecretStoreV1Beta1SpecProviderAwsSecretsManager;

  /**
   * Service defines which service should be used to fetch the secrets
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAws#service
   */
  readonly service: ClusterSecretStoreV1Beta1SpecProviderAwsService;

  /**
   * AWS STS assume role session tags
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAws#sessionTags
   */
  readonly sessionTags?: ClusterSecretStoreV1Beta1SpecProviderAwsSessionTags[];

  /**
   * AWS STS assume role transitive session tags. Required when multiple rules are used with the provider
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAws#transitiveTagKeys
   */
  readonly transitiveTagKeys?: string[];
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAws' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAws(
  obj: ClusterSecretStoreV1Beta1SpecProviderAws | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    additionalRoles: obj.additionalRoles?.map((y) => y),
    auth: toJson_ClusterSecretStoreV1Beta1SpecProviderAwsAuth(obj.auth),
    externalID: obj.externalId,
    region: obj.region,
    role: obj.role,
    secretsManager:
      toJson_ClusterSecretStoreV1Beta1SpecProviderAwsSecretsManager(
        obj.secretsManager,
      ),
    service: obj.service,
    sessionTags: obj.sessionTags?.map((y) =>
      toJson_ClusterSecretStoreV1Beta1SpecProviderAwsSessionTags(y),
    ),
    transitiveTagKeys: obj.transitiveTagKeys?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * AzureKV configures this store to sync secrets using Azure Key Vault provider
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekv
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAzurekv {
  /**
   * Auth configures how the operator authenticates with Azure. Required for ServicePrincipal auth type.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekv#authSecretRef
   */
  readonly authSecretRef?: ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef;

  /**
   * Auth type defines how to authenticate to the keyvault service. Valid values are: - "ServicePrincipal" (default): Using a service principal (tenantId, clientId, clientSecret) - "ManagedIdentity": Using Managed Identity assigned to the pod (see aad-pod-identity)
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekv#authType
   */
  readonly authType?: ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthType;

  /**
   * EnvironmentType specifies the Azure cloud environment endpoints to use for connecting and authenticating with Azure. By default it points to the public cloud AAD endpoint. The following endpoints are available, also see here: https://github.com/Azure/go-autorest/blob/main/autorest/azure/environments.go#L152 PublicCloud, USGovernmentCloud, ChinaCloud, GermanCloud
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekv#environmentType
   */
  readonly environmentType?: ClusterSecretStoreV1Beta1SpecProviderAzurekvEnvironmentType;

  /**
   * If multiple Managed Identity is assigned to the pod, you can select the one to be used
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekv#identityId
   */
  readonly identityId?: string;

  /**
   * ServiceAccountRef specified the service account that should be used when authenticating with WorkloadIdentity.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekv#serviceAccountRef
   */
  readonly serviceAccountRef?: ClusterSecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef;

  /**
   * TenantID configures the Azure Tenant to send requests to. Required for ServicePrincipal auth type.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekv#tenantId
   */
  readonly tenantId?: string;

  /**
   * Vault Url from which the secrets to be fetched from.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekv#vaultUrl
   */
  readonly vaultUrl: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAzurekv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAzurekv(
  obj: ClusterSecretStoreV1Beta1SpecProviderAzurekv | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    authSecretRef:
      toJson_ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef(
        obj.authSecretRef,
      ),
    authType: obj.authType,
    environmentType: obj.environmentType,
    identityId: obj.identityId,
    serviceAccountRef:
      toJson_ClusterSecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef(
        obj.serviceAccountRef,
      ),
    tenantId: obj.tenantId,
    vaultUrl: obj.vaultUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Conjur configures this store to sync secrets using conjur provider
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderConjur
 */
export interface ClusterSecretStoreV1Beta1SpecProviderConjur {
  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjur#auth
   */
  readonly auth: ClusterSecretStoreV1Beta1SpecProviderConjurAuth;

  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjur#caBundle
   */
  readonly caBundle?: string;

  /**
   * Used to provide custom certificate authority (CA) certificates for a secret store. The CAProvider points to a Secret or ConfigMap resource that contains a PEM-encoded certificate.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjur#caProvider
   */
  readonly caProvider?: ClusterSecretStoreV1Beta1SpecProviderConjurCaProvider;

  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjur#url
   */
  readonly url: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderConjur' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderConjur(
  obj: ClusterSecretStoreV1Beta1SpecProviderConjur | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    auth: toJson_ClusterSecretStoreV1Beta1SpecProviderConjurAuth(obj.auth),
    caBundle: obj.caBundle,
    caProvider: toJson_ClusterSecretStoreV1Beta1SpecProviderConjurCaProvider(
      obj.caProvider,
    ),
    url: obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Delinea DevOps Secrets Vault https://docs.delinea.com/online-help/products/devops-secrets-vault/current
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderDelinea
 */
export interface ClusterSecretStoreV1Beta1SpecProviderDelinea {
  /**
   * ClientID is the non-secret part of the credential.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDelinea#clientId
   */
  readonly clientId: ClusterSecretStoreV1Beta1SpecProviderDelineaClientId;

  /**
   * ClientSecret is the secret part of the credential.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDelinea#clientSecret
   */
  readonly clientSecret: ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecret;

  /**
   * Tenant is the chosen hostname / site name.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDelinea#tenant
   */
  readonly tenant: string;

  /**
   * TLD is based on the server location that was chosen during provisioning. If unset, defaults to "com".
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDelinea#tld
   */
  readonly tld?: string;

  /**
   * URLTemplate If unset, defaults to "https://%s.secretsvaultcloud.%s/v1/%s%s".
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDelinea#urlTemplate
   */
  readonly urlTemplate?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderDelinea' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderDelinea(
  obj: ClusterSecretStoreV1Beta1SpecProviderDelinea | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    clientId: toJson_ClusterSecretStoreV1Beta1SpecProviderDelineaClientId(
      obj.clientId,
    ),
    clientSecret:
      toJson_ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecret(
        obj.clientSecret,
      ),
    tenant: obj.tenant,
    tld: obj.tld,
    urlTemplate: obj.urlTemplate,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Doppler configures this store to sync secrets using the Doppler provider
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderDoppler
 */
export interface ClusterSecretStoreV1Beta1SpecProviderDoppler {
  /**
   * Auth configures how the Operator authenticates with the Doppler API
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDoppler#auth
   */
  readonly auth: ClusterSecretStoreV1Beta1SpecProviderDopplerAuth;

  /**
   * Doppler config (required if not using a Service Token)
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDoppler#config
   */
  readonly config?: string;

  /**
   * Format enables the downloading of secrets as a file (string)
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDoppler#format
   */
  readonly format?: ClusterSecretStoreV1Beta1SpecProviderDopplerFormat;

  /**
   * Environment variable compatible name transforms that change secret names to a different format
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDoppler#nameTransformer
   */
  readonly nameTransformer?: ClusterSecretStoreV1Beta1SpecProviderDopplerNameTransformer;

  /**
   * Doppler project (required if not using a Service Token)
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDoppler#project
   */
  readonly project?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderDoppler' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderDoppler(
  obj: ClusterSecretStoreV1Beta1SpecProviderDoppler | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    auth: toJson_ClusterSecretStoreV1Beta1SpecProviderDopplerAuth(obj.auth),
    config: obj.config,
    format: obj.format,
    nameTransformer: obj.nameTransformer,
    project: obj.project,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Fake configures a store with static key/value pairs
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderFake
 */
export interface ClusterSecretStoreV1Beta1SpecProviderFake {
  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderFake#data
   */
  readonly data: ClusterSecretStoreV1Beta1SpecProviderFakeData[];
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderFake' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderFake(
  obj: ClusterSecretStoreV1Beta1SpecProviderFake | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    data: obj.data?.map((y) =>
      toJson_ClusterSecretStoreV1Beta1SpecProviderFakeData(y),
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * GCPSM configures this store to sync secrets using Google Cloud Platform Secret Manager provider
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderGcpsm
 */
export interface ClusterSecretStoreV1Beta1SpecProviderGcpsm {
  /**
   * Auth defines the information necessary to authenticate against GCP
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderGcpsm#auth
   */
  readonly auth?: ClusterSecretStoreV1Beta1SpecProviderGcpsmAuth;

  /**
   * ProjectID project where secret is located
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderGcpsm#projectID
   */
  readonly projectId?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderGcpsm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderGcpsm(
  obj: ClusterSecretStoreV1Beta1SpecProviderGcpsm | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    auth: toJson_ClusterSecretStoreV1Beta1SpecProviderGcpsmAuth(obj.auth),
    projectID: obj.projectId,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * GitLab configures this store to sync secrets using GitLab Variables provider
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderGitlab
 */
export interface ClusterSecretStoreV1Beta1SpecProviderGitlab {
  /**
   * Auth configures how secret-manager authenticates with a GitLab instance.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderGitlab#auth
   */
  readonly auth: ClusterSecretStoreV1Beta1SpecProviderGitlabAuth;

  /**
   * Environment environment_scope of gitlab CI/CD variables (Please see https://docs.gitlab.com/ee/ci/environments/#create-a-static-environment on how to create environments)
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderGitlab#environment
   */
  readonly environment?: string;

  /**
   * GroupIDs specify, which gitlab groups to pull secrets from. Group secrets are read from left to right followed by the project variables.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderGitlab#groupIDs
   */
  readonly groupIDs?: string[];

  /**
   * InheritFromGroups specifies whether parent groups should be discovered and checked for secrets.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderGitlab#inheritFromGroups
   */
  readonly inheritFromGroups?: boolean;

  /**
   * ProjectID specifies a project where secrets are located.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderGitlab#projectID
   */
  readonly projectId?: string;

  /**
   * URL configures the GitLab instance URL. Defaults to https://gitlab.com/.
   *
   * @default https://gitlab.com/.
   * @schema ClusterSecretStoreV1Beta1SpecProviderGitlab#url
   */
  readonly url?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderGitlab' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderGitlab(
  obj: ClusterSecretStoreV1Beta1SpecProviderGitlab | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    auth: toJson_ClusterSecretStoreV1Beta1SpecProviderGitlabAuth(obj.auth),
    environment: obj.environment,
    groupIDs: obj.groupIDs?.map((y) => y),
    inheritFromGroups: obj.inheritFromGroups,
    projectID: obj.projectId,
    url: obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * IBM configures this store to sync secrets using IBM Cloud provider
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderIbm
 */
export interface ClusterSecretStoreV1Beta1SpecProviderIbm {
  /**
   * Auth configures how secret-manager authenticates with the IBM secrets manager.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderIbm#auth
   */
  readonly auth: ClusterSecretStoreV1Beta1SpecProviderIbmAuth;

  /**
   * ServiceURL is the Endpoint URL that is specific to the Secrets Manager service instance
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderIbm#serviceUrl
   */
  readonly serviceUrl?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderIbm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderIbm(
  obj: ClusterSecretStoreV1Beta1SpecProviderIbm | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    auth: toJson_ClusterSecretStoreV1Beta1SpecProviderIbmAuth(obj.auth),
    serviceUrl: obj.serviceUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * KeeperSecurity configures this store to sync secrets using the KeeperSecurity provider
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderKeepersecurity
 */
export interface ClusterSecretStoreV1Beta1SpecProviderKeepersecurity {
  /**
   * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKeepersecurity#authRef
   */
  readonly authRef: ClusterSecretStoreV1Beta1SpecProviderKeepersecurityAuthRef;

  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderKeepersecurity#folderID
   */
  readonly folderId: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderKeepersecurity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderKeepersecurity(
  obj: ClusterSecretStoreV1Beta1SpecProviderKeepersecurity | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    authRef: toJson_ClusterSecretStoreV1Beta1SpecProviderKeepersecurityAuthRef(
      obj.authRef,
    ),
    folderID: obj.folderId,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Kubernetes configures this store to sync secrets using a Kubernetes cluster provider
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetes
 */
export interface ClusterSecretStoreV1Beta1SpecProviderKubernetes {
  /**
   * Auth configures how secret-manager authenticates with a Kubernetes instance.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetes#auth
   */
  readonly auth: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuth;

  /**
   * Remote namespace to fetch the secrets from
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetes#remoteNamespace
   */
  readonly remoteNamespace?: string;

  /**
   * configures the Kubernetes server Address.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetes#server
   */
  readonly server?: ClusterSecretStoreV1Beta1SpecProviderKubernetesServer;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderKubernetes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderKubernetes(
  obj: ClusterSecretStoreV1Beta1SpecProviderKubernetes | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    auth: toJson_ClusterSecretStoreV1Beta1SpecProviderKubernetesAuth(obj.auth),
    remoteNamespace: obj.remoteNamespace,
    server: toJson_ClusterSecretStoreV1Beta1SpecProviderKubernetesServer(
      obj.server,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * OnePassword configures this store to sync secrets using the 1Password Cloud provider
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderOnepassword
 */
export interface ClusterSecretStoreV1Beta1SpecProviderOnepassword {
  /**
   * Auth defines the information necessary to authenticate against OnePassword Connect Server
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOnepassword#auth
   */
  readonly auth: ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuth;

  /**
   * ConnectHost defines the OnePassword Connect Server to connect to
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOnepassword#connectHost
   */
  readonly connectHost: string;

  /**
   * Vaults defines which OnePassword vaults to search in which order
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOnepassword#vaults
   */
  readonly vaults: { [key: string]: number };
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderOnepassword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderOnepassword(
  obj: ClusterSecretStoreV1Beta1SpecProviderOnepassword | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    auth: toJson_ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuth(obj.auth),
    connectHost: obj.connectHost,
    vaults:
      obj.vaults === undefined
        ? undefined
        : Object.entries(obj.vaults).reduce(
            (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
            {},
          ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Oracle configures this store to sync secrets using Oracle Vault provider
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderOracle
 */
export interface ClusterSecretStoreV1Beta1SpecProviderOracle {
  /**
   * Auth configures how secret-manager authenticates with the Oracle Vault. If empty, use the instance principal, otherwise the user credentials specified in Auth.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOracle#auth
   */
  readonly auth?: ClusterSecretStoreV1Beta1SpecProviderOracleAuth;

  /**
   * Compartment is the vault compartment OCID. Required for PushSecret
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOracle#compartment
   */
  readonly compartment?: string;

  /**
   * EncryptionKey is the OCID of the encryption key within the vault. Required for PushSecret
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOracle#encryptionKey
   */
  readonly encryptionKey?: string;

  /**
   * The type of principal to use for authentication. If left blank, the Auth struct will determine the principal type. This optional field must be specified if using workload identity.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOracle#principalType
   */
  readonly principalType?: ClusterSecretStoreV1Beta1SpecProviderOraclePrincipalType;

  /**
   * Region is the region where vault is located.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOracle#region
   */
  readonly region: string;

  /**
   * ServiceAccountRef specified the service account that should be used when authenticating with WorkloadIdentity.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOracle#serviceAccountRef
   */
  readonly serviceAccountRef?: ClusterSecretStoreV1Beta1SpecProviderOracleServiceAccountRef;

  /**
   * Vault is the vault's OCID of the specific vault where secret is located.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOracle#vault
   */
  readonly vault: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderOracle' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderOracle(
  obj: ClusterSecretStoreV1Beta1SpecProviderOracle | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    auth: toJson_ClusterSecretStoreV1Beta1SpecProviderOracleAuth(obj.auth),
    compartment: obj.compartment,
    encryptionKey: obj.encryptionKey,
    principalType: obj.principalType,
    region: obj.region,
    serviceAccountRef:
      toJson_ClusterSecretStoreV1Beta1SpecProviderOracleServiceAccountRef(
        obj.serviceAccountRef,
      ),
    vault: obj.vault,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Scaleway
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderScaleway
 */
export interface ClusterSecretStoreV1Beta1SpecProviderScaleway {
  /**
   * AccessKey is the non-secret part of the api key.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderScaleway#accessKey
   */
  readonly accessKey: ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKey;

  /**
   * APIURL is the url of the api to use. Defaults to https://api.scaleway.com
   *
   * @default https://api.scaleway.com
   * @schema ClusterSecretStoreV1Beta1SpecProviderScaleway#apiUrl
   */
  readonly apiUrl?: string;

  /**
   * ProjectID is the id of your project, which you can find in the console: https://console.scaleway.com/project/settings
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderScaleway#projectId
   */
  readonly projectId: string;

  /**
   * Region where your secrets are located: https://developers.scaleway.com/en/quickstart/#region-and-zone
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderScaleway#region
   */
  readonly region: string;

  /**
   * SecretKey is the non-secret part of the api key.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderScaleway#secretKey
   */
  readonly secretKey: ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKey;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderScaleway' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderScaleway(
  obj: ClusterSecretStoreV1Beta1SpecProviderScaleway | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    accessKey: toJson_ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKey(
      obj.accessKey,
    ),
    apiUrl: obj.apiUrl,
    projectId: obj.projectId,
    region: obj.region,
    secretKey: toJson_ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKey(
      obj.secretKey,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Senhasegura configures this store to sync secrets using senhasegura provider
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderSenhasegura
 */
export interface ClusterSecretStoreV1Beta1SpecProviderSenhasegura {
  /**
   * Auth defines parameters to authenticate in senhasegura
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderSenhasegura#auth
   */
  readonly auth: ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuth;

  /**
   * IgnoreSslCertificate defines if SSL certificate must be ignored
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderSenhasegura#ignoreSslCertificate
   */
  readonly ignoreSslCertificate?: boolean;

  /**
   * Module defines which senhasegura module should be used to get secrets
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderSenhasegura#module
   */
  readonly module: string;

  /**
   * URL of senhasegura
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderSenhasegura#url
   */
  readonly url: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderSenhasegura' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderSenhasegura(
  obj: ClusterSecretStoreV1Beta1SpecProviderSenhasegura | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    auth: toJson_ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuth(obj.auth),
    ignoreSslCertificate: obj.ignoreSslCertificate,
    module: obj.module,
    url: obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Vault configures this store to sync secrets using Hashi provider
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVault
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVault {
  /**
   * Auth configures how secret-manager authenticates with the Vault server.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVault#auth
   */
  readonly auth: ClusterSecretStoreV1Beta1SpecProviderVaultAuth;

  /**
   * PEM encoded CA bundle used to validate Vault server certificate. Only used if the Server URL is using HTTPS protocol. This parameter is ignored for plain HTTP protocol connection. If not set the system root certificates are used to validate the TLS connection.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVault#caBundle
   */
  readonly caBundle?: string;

  /**
   * The provider for the CA bundle to use to validate Vault server certificate.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVault#caProvider
   */
  readonly caProvider?: ClusterSecretStoreV1Beta1SpecProviderVaultCaProvider;

  /**
   * ForwardInconsistent tells Vault to forward read-after-write requests to the Vault leader instead of simply retrying within a loop. This can increase performance if the option is enabled serverside. https://www.vaultproject.io/docs/configuration/replication#allow_forwarding_via_header
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVault#forwardInconsistent
   */
  readonly forwardInconsistent?: boolean;

  /**
   * Name of the vault namespace. Namespaces is a set of features within Vault Enterprise that allows Vault environments to support Secure Multi-tenancy. e.g: "ns1". More about namespaces can be found here https://www.vaultproject.io/docs/enterprise/namespaces
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVault#namespace
   */
  readonly namespace?: string;

  /**
   * Path is the mount path of the Vault KV backend endpoint, e.g: "secret". The v2 KV secret engine version specific "/data" path suffix for fetching secrets from Vault is optional and will be appended if not present in specified path.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVault#path
   */
  readonly path?: string;

  /**
   * ReadYourWrites ensures isolated read-after-write semantics by providing discovered cluster replication states in each request. More information about eventual consistency in Vault can be found here https://www.vaultproject.io/docs/enterprise/consistency
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVault#readYourWrites
   */
  readonly readYourWrites?: boolean;

  /**
   * Server is the connection address for the Vault server, e.g: "https://vault.example.com:8200".
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVault#server
   */
  readonly server: string;

  /**
   * Version is the Vault KV secret engine version. This can be either "v1" or "v2". Version defaults to "v2".
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVault#version
   */
  readonly version?: ClusterSecretStoreV1Beta1SpecProviderVaultVersion;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVault' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVault(
  obj: ClusterSecretStoreV1Beta1SpecProviderVault | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    auth: toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuth(obj.auth),
    caBundle: obj.caBundle,
    caProvider: toJson_ClusterSecretStoreV1Beta1SpecProviderVaultCaProvider(
      obj.caProvider,
    ),
    forwardInconsistent: obj.forwardInconsistent,
    namespace: obj.namespace,
    path: obj.path,
    readYourWrites: obj.readYourWrites,
    server: obj.server,
    version: obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Webhook configures this store to sync secrets using a generic templated webhook
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderWebhook
 */
export interface ClusterSecretStoreV1Beta1SpecProviderWebhook {
  /**
   * Body
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderWebhook#body
   */
  readonly body?: string;

  /**
   * PEM encoded CA bundle used to validate webhook server certificate. Only used if the Server URL is using HTTPS protocol. This parameter is ignored for plain HTTP protocol connection. If not set the system root certificates are used to validate the TLS connection.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderWebhook#caBundle
   */
  readonly caBundle?: string;

  /**
   * The provider for the CA bundle to use to validate webhook server certificate.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderWebhook#caProvider
   */
  readonly caProvider?: ClusterSecretStoreV1Beta1SpecProviderWebhookCaProvider;

  /**
   * Headers
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderWebhook#headers
   */
  readonly headers?: { [key: string]: string };

  /**
   * Webhook Method
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderWebhook#method
   */
  readonly method?: string;

  /**
   * Result formatting
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderWebhook#result
   */
  readonly result: ClusterSecretStoreV1Beta1SpecProviderWebhookResult;

  /**
   * Secrets to fill in templates These secrets will be passed to the templating function as key value pairs under the given name
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderWebhook#secrets
   */
  readonly secrets?: ClusterSecretStoreV1Beta1SpecProviderWebhookSecrets[];

  /**
   * Timeout
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderWebhook#timeout
   */
  readonly timeout?: string;

  /**
   * Webhook url to call
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderWebhook#url
   */
  readonly url: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderWebhook' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderWebhook(
  obj: ClusterSecretStoreV1Beta1SpecProviderWebhook | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    body: obj.body,
    caBundle: obj.caBundle,
    caProvider: toJson_ClusterSecretStoreV1Beta1SpecProviderWebhookCaProvider(
      obj.caProvider,
    ),
    headers:
      obj.headers === undefined
        ? undefined
        : Object.entries(obj.headers).reduce(
            (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
            {},
          ),
    method: obj.method,
    result: toJson_ClusterSecretStoreV1Beta1SpecProviderWebhookResult(
      obj.result,
    ),
    secrets: obj.secrets?.map((y) =>
      toJson_ClusterSecretStoreV1Beta1SpecProviderWebhookSecrets(y),
    ),
    timeout: obj.timeout,
    url: obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * YandexCertificateManager configures this store to sync secrets using Yandex Certificate Manager provider
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanager
 */
export interface ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanager {
  /**
   * Yandex.Cloud API endpoint (e.g. 'api.cloud.yandex.net:443')
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanager#apiEndpoint
   */
  readonly apiEndpoint?: string;

  /**
   * Auth defines the information necessary to authenticate against Yandex Certificate Manager
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanager#auth
   */
  readonly auth: ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth;

  /**
   * The provider for the CA bundle to use to validate Yandex.Cloud server certificate.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanager#caProvider
   */
  readonly caProvider?: ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanager' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanager(
  obj:
    | ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanager
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    apiEndpoint: obj.apiEndpoint,
    auth: toJson_ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth(
      obj.auth,
    ),
    caProvider:
      toJson_ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider(
        obj.caProvider,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * YandexLockbox configures this store to sync secrets using Yandex Lockbox provider
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderYandexlockbox
 */
export interface ClusterSecretStoreV1Beta1SpecProviderYandexlockbox {
  /**
   * Yandex.Cloud API endpoint (e.g. 'api.cloud.yandex.net:443')
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderYandexlockbox#apiEndpoint
   */
  readonly apiEndpoint?: string;

  /**
   * Auth defines the information necessary to authenticate against Yandex Lockbox
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderYandexlockbox#auth
   */
  readonly auth: ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuth;

  /**
   * The provider for the CA bundle to use to validate Yandex.Cloud server certificate.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderYandexlockbox#caProvider
   */
  readonly caProvider?: ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProvider;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderYandexlockbox' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderYandexlockbox(
  obj: ClusterSecretStoreV1Beta1SpecProviderYandexlockbox | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    apiEndpoint: obj.apiEndpoint,
    auth: toJson_ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuth(
      obj.auth,
    ),
    caProvider:
      toJson_ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProvider(
        obj.caProvider,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions
 */
export interface ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions(
  obj:
    | ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Auth configures how the operator authenticates with Akeyless.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef {
  /**
   * Kubernetes authenticates with Akeyless by passing the ServiceAccount token stored in the named Secret resource.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef#kubernetesAuth
   */
  readonly kubernetesAuth?: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth;

  /**
   * Reference to a Secret that contains the details to authenticate with Akeyless.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef#secretRef
   */
  readonly secretRef?: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef(
  obj: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    kubernetesAuth:
      toJson_ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth(
        obj.kubernetesAuth,
      ),
    secretRef:
      toJson_ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef(
        obj.secretRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The provider for the CA bundle to use to validate Akeyless Gateway certificate.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessCaProvider
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAkeylessCaProvider {
  /**
   * The key where the CA certificate can be found in the Secret or ConfigMap.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessCaProvider#key
   */
  readonly key?: string;

  /**
   * The name of the object located at the provider type.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessCaProvider#name
   */
  readonly name: string;

  /**
   * The namespace the Provider type is in. Can only be defined when used in a ClusterSecretStore.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessCaProvider#namespace
   */
  readonly namespace?: string;

  /**
   * The type of provider to use such as "Secret", or "ConfigMap".
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessCaProvider#type
   */
  readonly type: ClusterSecretStoreV1Beta1SpecProviderAkeylessCaProviderType;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAkeylessCaProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAkeylessCaProvider(
  obj: ClusterSecretStoreV1Beta1SpecProviderAkeylessCaProvider | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
    type: obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * AlibabaAuth contains a secretRef for credentials.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAlibabaAuth
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAlibabaAuth {
  /**
   * Authenticate against Alibaba using RRSA.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAlibabaAuth#rrsa
   */
  readonly rrsa?: ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthRrsa;

  /**
   * AlibabaAuthSecretRef holds secret references for Alibaba credentials.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAlibabaAuth#secretRef
   */
  readonly secretRef?: ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAlibabaAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAlibabaAuth(
  obj: ClusterSecretStoreV1Beta1SpecProviderAlibabaAuth | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    rrsa: toJson_ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthRrsa(obj.rrsa),
    secretRef: toJson_ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef(
      obj.secretRef,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Auth defines the information necessary to authenticate against AWS if not set aws sdk will infer credentials from your environment see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAwsAuth
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAwsAuth {
  /**
   * Authenticate against AWS using service account tokens.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAwsAuth#jwt
   */
  readonly jwt?: ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwt;

  /**
   * AWSAuthSecretRef holds secret references for AWS credentials both AccessKeyID and SecretAccessKey must be defined in order to properly authenticate.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAwsAuth#secretRef
   */
  readonly secretRef?: ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRef;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAwsAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAwsAuth(
  obj: ClusterSecretStoreV1Beta1SpecProviderAwsAuth | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    jwt: toJson_ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwt(obj.jwt),
    secretRef: toJson_ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRef(
      obj.secretRef,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * SecretsManager defines how the provider behaves when interacting with AWS SecretsManager
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAwsSecretsManager
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAwsSecretsManager {
  /**
   * Specifies whether to delete the secret without any recovery window. You can't use both this parameter and RecoveryWindowInDays in the same call. If you don't use either, then by default Secrets Manager uses a 30 day recovery window. see: https://docs.aws.amazon.com/secretsmanager/latest/apireference/API_DeleteSecret.html#SecretsManager-DeleteSecret-request-ForceDeleteWithoutRecovery
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAwsSecretsManager#forceDeleteWithoutRecovery
   */
  readonly forceDeleteWithoutRecovery?: boolean;

  /**
   * The number of days from 7 to 30 that Secrets Manager waits before permanently deleting the secret. You can't use both this parameter and ForceDeleteWithoutRecovery in the same call. If you don't use either, then by default Secrets Manager uses a 30 day recovery window. see: https://docs.aws.amazon.com/secretsmanager/latest/apireference/API_DeleteSecret.html#SecretsManager-DeleteSecret-request-RecoveryWindowInDays
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAwsSecretsManager#recoveryWindowInDays
   */
  readonly recoveryWindowInDays?: number;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAwsSecretsManager' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAwsSecretsManager(
  obj: ClusterSecretStoreV1Beta1SpecProviderAwsSecretsManager | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    forceDeleteWithoutRecovery: obj.forceDeleteWithoutRecovery,
    recoveryWindowInDays: obj.recoveryWindowInDays,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Service defines which service should be used to fetch the secrets
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAwsService
 */
export enum ClusterSecretStoreV1Beta1SpecProviderAwsService {
  /** SecretsManager */
  SECRETS_MANAGER = "SecretsManager",
  /** ParameterStore */
  PARAMETER_STORE = "ParameterStore",
}

/**
 * @schema ClusterSecretStoreV1Beta1SpecProviderAwsSessionTags
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAwsSessionTags {
  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderAwsSessionTags#key
   */
  readonly key: string;

  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderAwsSessionTags#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAwsSessionTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAwsSessionTags(
  obj: ClusterSecretStoreV1Beta1SpecProviderAwsSessionTags | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Auth configures how the operator authenticates with Azure. Required for ServicePrincipal auth type.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef {
  /**
   * The Azure clientId of the service principle used for authentication.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef#clientId
   */
  readonly clientId?: ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId;

  /**
   * The Azure ClientSecret of the service principle used for authentication.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef#clientSecret
   */
  readonly clientSecret?: ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef(
  obj: ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    clientId:
      toJson_ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId(
        obj.clientId,
      ),
    clientSecret:
      toJson_ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret(
        obj.clientSecret,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Auth type defines how to authenticate to the keyvault service. Valid values are: - "ServicePrincipal" (default): Using a service principal (tenantId, clientId, clientSecret) - "ManagedIdentity": Using Managed Identity assigned to the pod (see aad-pod-identity)
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthType
 */
export enum ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthType {
  /** ServicePrincipal */
  SERVICE_PRINCIPAL = "ServicePrincipal",
  /** ManagedIdentity */
  MANAGED_IDENTITY = "ManagedIdentity",
  /** WorkloadIdentity */
  WORKLOAD_IDENTITY = "WorkloadIdentity",
}

/**
 * EnvironmentType specifies the Azure cloud environment endpoints to use for connecting and authenticating with Azure. By default it points to the public cloud AAD endpoint. The following endpoints are available, also see here: https://github.com/Azure/go-autorest/blob/main/autorest/azure/environments.go#L152 PublicCloud, USGovernmentCloud, ChinaCloud, GermanCloud
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekvEnvironmentType
 */
export enum ClusterSecretStoreV1Beta1SpecProviderAzurekvEnvironmentType {
  /** PublicCloud */
  PUBLIC_CLOUD = "PublicCloud",
  /** USGovernmentCloud */
  US_GOVERNMENT_CLOUD = "USGovernmentCloud",
  /** ChinaCloud */
  CHINA_CLOUD = "ChinaCloud",
  /** GermanCloud */
  GERMAN_CLOUD = "GermanCloud",
}

/**
 * ServiceAccountRef specified the service account that should be used when authenticating with WorkloadIdentity.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef(
  obj:
    | ClusterSecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    audiences: obj.audiences?.map((y) => y),
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuth
 */
export interface ClusterSecretStoreV1Beta1SpecProviderConjurAuth {
  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuth#apikey
   */
  readonly apikey?: ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikey;

  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuth#jwt
   */
  readonly jwt?: ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwt;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderConjurAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderConjurAuth(
  obj: ClusterSecretStoreV1Beta1SpecProviderConjurAuth | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    apikey: toJson_ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikey(
      obj.apikey,
    ),
    jwt: toJson_ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwt(obj.jwt),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Used to provide custom certificate authority (CA) certificates for a secret store. The CAProvider points to a Secret or ConfigMap resource that contains a PEM-encoded certificate.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderConjurCaProvider
 */
export interface ClusterSecretStoreV1Beta1SpecProviderConjurCaProvider {
  /**
   * The key where the CA certificate can be found in the Secret or ConfigMap.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjurCaProvider#key
   */
  readonly key?: string;

  /**
   * The name of the object located at the provider type.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjurCaProvider#name
   */
  readonly name: string;

  /**
   * The namespace the Provider type is in. Can only be defined when used in a ClusterSecretStore.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjurCaProvider#namespace
   */
  readonly namespace?: string;

  /**
   * The type of provider to use such as "Secret", or "ConfigMap".
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjurCaProvider#type
   */
  readonly type: ClusterSecretStoreV1Beta1SpecProviderConjurCaProviderType;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderConjurCaProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderConjurCaProvider(
  obj: ClusterSecretStoreV1Beta1SpecProviderConjurCaProvider | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
    type: obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ClientID is the non-secret part of the credential.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderDelineaClientId
 */
export interface ClusterSecretStoreV1Beta1SpecProviderDelineaClientId {
  /**
   * SecretRef references a key in a secret that will be used as value.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDelineaClientId#secretRef
   */
  readonly secretRef?: ClusterSecretStoreV1Beta1SpecProviderDelineaClientIdSecretRef;

  /**
   * Value can be specified directly to set a value without using a secret.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDelineaClientId#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderDelineaClientId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderDelineaClientId(
  obj: ClusterSecretStoreV1Beta1SpecProviderDelineaClientId | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    secretRef:
      toJson_ClusterSecretStoreV1Beta1SpecProviderDelineaClientIdSecretRef(
        obj.secretRef,
      ),
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ClientSecret is the secret part of the credential.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecret
 */
export interface ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecret {
  /**
   * SecretRef references a key in a secret that will be used as value.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecret#secretRef
   */
  readonly secretRef?: ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecretSecretRef;

  /**
   * Value can be specified directly to set a value without using a secret.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecret#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecret(
  obj: ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    secretRef:
      toJson_ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecretSecretRef(
        obj.secretRef,
      ),
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Auth configures how the Operator authenticates with the Doppler API
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderDopplerAuth
 */
export interface ClusterSecretStoreV1Beta1SpecProviderDopplerAuth {
  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderDopplerAuth#secretRef
   */
  readonly secretRef: ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRef;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderDopplerAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderDopplerAuth(
  obj: ClusterSecretStoreV1Beta1SpecProviderDopplerAuth | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    secretRef: toJson_ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRef(
      obj.secretRef,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Format enables the downloading of secrets as a file (string)
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderDopplerFormat
 */
export enum ClusterSecretStoreV1Beta1SpecProviderDopplerFormat {
  /** json */
  JSON = "json",
  /** dotnet-json */
  DOTNET_HYPHEN_JSON = "dotnet-json",
  /** env */
  ENV = "env",
  /** yaml */
  YAML = "yaml",
  /** docker */
  DOCKER = "docker",
}

/**
 * Environment variable compatible name transforms that change secret names to a different format
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderDopplerNameTransformer
 */
export enum ClusterSecretStoreV1Beta1SpecProviderDopplerNameTransformer {
  /** upper-camel */
  UPPER_HYPHEN_CAMEL = "upper-camel",
  /** camel */
  CAMEL = "camel",
  /** lower-snake */
  LOWER_HYPHEN_SNAKE = "lower-snake",
  /** tf-var */
  TF_HYPHEN_VAR = "tf-var",
  /** dotnet-env */
  DOTNET_HYPHEN_ENV = "dotnet-env",
  /** lower-kebab */
  LOWER_HYPHEN_KEBAB = "lower-kebab",
}

/**
 * @schema ClusterSecretStoreV1Beta1SpecProviderFakeData
 */
export interface ClusterSecretStoreV1Beta1SpecProviderFakeData {
  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderFakeData#key
   */
  readonly key: string;

  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderFakeData#value
   */
  readonly value?: string;

  /**
   * Deprecated: ValueMap is deprecated and is intended to be removed in the future, use the `value` field instead.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderFakeData#valueMap
   */
  readonly valueMap?: { [key: string]: string };

  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderFakeData#version
   */
  readonly version?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderFakeData' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderFakeData(
  obj: ClusterSecretStoreV1Beta1SpecProviderFakeData | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    value: obj.value,
    valueMap:
      obj.valueMap === undefined
        ? undefined
        : Object.entries(obj.valueMap).reduce(
            (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
            {},
          ),
    version: obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Auth defines the information necessary to authenticate against GCP
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderGcpsmAuth
 */
export interface ClusterSecretStoreV1Beta1SpecProviderGcpsmAuth {
  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderGcpsmAuth#secretRef
   */
  readonly secretRef?: ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef;

  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderGcpsmAuth#workloadIdentity
   */
  readonly workloadIdentity?: ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderGcpsmAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderGcpsmAuth(
  obj: ClusterSecretStoreV1Beta1SpecProviderGcpsmAuth | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    secretRef: toJson_ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef(
      obj.secretRef,
    ),
    workloadIdentity:
      toJson_ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity(
        obj.workloadIdentity,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Auth configures how secret-manager authenticates with a GitLab instance.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderGitlabAuth
 */
export interface ClusterSecretStoreV1Beta1SpecProviderGitlabAuth {
  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderGitlabAuth#SecretRef
   */
  readonly secretRef: ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRef;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderGitlabAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderGitlabAuth(
  obj: ClusterSecretStoreV1Beta1SpecProviderGitlabAuth | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    SecretRef: toJson_ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRef(
      obj.secretRef,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Auth configures how secret-manager authenticates with the IBM secrets manager.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderIbmAuth
 */
export interface ClusterSecretStoreV1Beta1SpecProviderIbmAuth {
  /**
   * IBM Container-based auth with IAM Trusted Profile.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderIbmAuth#containerAuth
   */
  readonly containerAuth?: ClusterSecretStoreV1Beta1SpecProviderIbmAuthContainerAuth;

  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderIbmAuth#secretRef
   */
  readonly secretRef?: ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRef;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderIbmAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderIbmAuth(
  obj: ClusterSecretStoreV1Beta1SpecProviderIbmAuth | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    containerAuth:
      toJson_ClusterSecretStoreV1Beta1SpecProviderIbmAuthContainerAuth(
        obj.containerAuth,
      ),
    secretRef: toJson_ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRef(
      obj.secretRef,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderKeepersecurityAuthRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderKeepersecurityAuthRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKeepersecurityAuthRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKeepersecurityAuthRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKeepersecurityAuthRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderKeepersecurityAuthRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderKeepersecurityAuthRef(
  obj: ClusterSecretStoreV1Beta1SpecProviderKeepersecurityAuthRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Auth configures how secret-manager authenticates with a Kubernetes instance.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuth
 */
export interface ClusterSecretStoreV1Beta1SpecProviderKubernetesAuth {
  /**
   * has both clientCert and clientKey as secretKeySelector
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuth#cert
   */
  readonly cert?: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCert;

  /**
   * points to a service account that should be used for authentication
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuth#serviceAccount
   */
  readonly serviceAccount?: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount;

  /**
   * use static token to authenticate with
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuth#token
   */
  readonly token?: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthToken;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderKubernetesAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderKubernetesAuth(
  obj: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuth | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    cert: toJson_ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCert(
      obj.cert,
    ),
    serviceAccount:
      toJson_ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount(
        obj.serviceAccount,
      ),
    token: toJson_ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthToken(
      obj.token,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * configures the Kubernetes server Address.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesServer
 */
export interface ClusterSecretStoreV1Beta1SpecProviderKubernetesServer {
  /**
   * CABundle is a base64-encoded CA certificate
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesServer#caBundle
   */
  readonly caBundle?: string;

  /**
   * see: https://external-secrets.io/v0.4.1/spec/#external-secrets.io/v1alpha1.CAProvider
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesServer#caProvider
   */
  readonly caProvider?: ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProvider;

  /**
   * configures the Kubernetes server Address.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesServer#url
   */
  readonly url?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderKubernetesServer' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderKubernetesServer(
  obj: ClusterSecretStoreV1Beta1SpecProviderKubernetesServer | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    caBundle: obj.caBundle,
    caProvider:
      toJson_ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProvider(
        obj.caProvider,
      ),
    url: obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Auth defines the information necessary to authenticate against OnePassword Connect Server
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuth
 */
export interface ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuth {
  /**
   * OnePasswordAuthSecretRef holds secret references for 1Password credentials.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuth#secretRef
   */
  readonly secretRef: ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuth(
  obj: ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuth | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    secretRef:
      toJson_ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef(
        obj.secretRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Auth configures how secret-manager authenticates with the Oracle Vault. If empty, use the instance principal, otherwise the user credentials specified in Auth.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderOracleAuth
 */
export interface ClusterSecretStoreV1Beta1SpecProviderOracleAuth {
  /**
   * SecretRef to pass through sensitive information.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOracleAuth#secretRef
   */
  readonly secretRef: ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRef;

  /**
   * Tenancy is the tenancy OCID where user is located.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOracleAuth#tenancy
   */
  readonly tenancy: string;

  /**
   * User is an access OCID specific to the account.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOracleAuth#user
   */
  readonly user: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderOracleAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderOracleAuth(
  obj: ClusterSecretStoreV1Beta1SpecProviderOracleAuth | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    secretRef: toJson_ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRef(
      obj.secretRef,
    ),
    tenancy: obj.tenancy,
    user: obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The type of principal to use for authentication. If left blank, the Auth struct will determine the principal type. This optional field must be specified if using workload identity.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderOraclePrincipalType
 */
export enum ClusterSecretStoreV1Beta1SpecProviderOraclePrincipalType {
  /** UserPrincipal */
  USER_PRINCIPAL = "UserPrincipal",
  /** InstancePrincipal */
  INSTANCE_PRINCIPAL = "InstancePrincipal",
  /** Workload */
  WORKLOAD = "Workload",
}

/**
 * ServiceAccountRef specified the service account that should be used when authenticating with WorkloadIdentity.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderOracleServiceAccountRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderOracleServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOracleServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOracleServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOracleServiceAccountRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderOracleServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderOracleServiceAccountRef(
  obj: ClusterSecretStoreV1Beta1SpecProviderOracleServiceAccountRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    audiences: obj.audiences?.map((y) => y),
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * AccessKey is the non-secret part of the api key.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKey
 */
export interface ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKey {
  /**
   * SecretRef references a key in a secret that will be used as value.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKey#secretRef
   */
  readonly secretRef?: ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKeySecretRef;

  /**
   * Value can be specified directly to set a value without using a secret.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKey#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKey(
  obj: ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKey | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    secretRef:
      toJson_ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKeySecretRef(
        obj.secretRef,
      ),
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKey is the non-secret part of the api key.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKey
 */
export interface ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKey {
  /**
   * SecretRef references a key in a secret that will be used as value.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKey#secretRef
   */
  readonly secretRef?: ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKeySecretRef;

  /**
   * Value can be specified directly to set a value without using a secret.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKey#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKey(
  obj: ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKey | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    secretRef:
      toJson_ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKeySecretRef(
        obj.secretRef,
      ),
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Auth defines parameters to authenticate in senhasegura
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuth
 */
export interface ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuth {
  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuth#clientId
   */
  readonly clientId: string;

  /**
   * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuth#clientSecretSecretRef
   */
  readonly clientSecretSecretRef: ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuth(
  obj: ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuth | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    clientId: obj.clientId,
    clientSecretSecretRef:
      toJson_ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef(
        obj.clientSecretSecretRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Auth configures how secret-manager authenticates with the Vault server.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuth
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuth {
  /**
   * AppRole authenticates with Vault using the App Role auth mechanism, with the role and secret stored in a Kubernetes Secret resource.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuth#appRole
   */
  readonly appRole?: ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRole;

  /**
   * Cert authenticates with TLS Certificates by passing client certificate, private key and ca certificate Cert authentication method
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuth#cert
   */
  readonly cert?: ClusterSecretStoreV1Beta1SpecProviderVaultAuthCert;

  /**
   * Iam authenticates with vault by passing a special AWS request signed with AWS IAM credentials AWS IAM authentication method
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuth#iam
   */
  readonly iam?: ClusterSecretStoreV1Beta1SpecProviderVaultAuthIam;

  /**
   * Jwt authenticates with Vault by passing role and JWT token using the JWT/OIDC authentication method
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuth#jwt
   */
  readonly jwt?: ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwt;

  /**
   * Kubernetes authenticates with Vault by passing the ServiceAccount token stored in the named Secret resource to the Vault server.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuth#kubernetes
   */
  readonly kubernetes?: ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetes;

  /**
   * Ldap authenticates with Vault by passing username/password pair using the LDAP authentication method
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuth#ldap
   */
  readonly ldap?: ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdap;

  /**
   * TokenSecretRef authenticates with Vault by presenting a token.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuth#tokenSecretRef
   */
  readonly tokenSecretRef?: ClusterSecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef;

  /**
   * UserPass authenticates with Vault by passing username/password pair
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuth#userPass
   */
  readonly userPass?: ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPass;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuth(
  obj: ClusterSecretStoreV1Beta1SpecProviderVaultAuth | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    appRole: toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRole(
      obj.appRole,
    ),
    cert: toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthCert(obj.cert),
    iam: toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthIam(obj.iam),
    jwt: toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwt(obj.jwt),
    kubernetes: toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetes(
      obj.kubernetes,
    ),
    ldap: toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdap(obj.ldap),
    tokenSecretRef:
      toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef(
        obj.tokenSecretRef,
      ),
    userPass: toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPass(
      obj.userPass,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The provider for the CA bundle to use to validate Vault server certificate.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultCaProvider
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultCaProvider {
  /**
   * The key where the CA certificate can be found in the Secret or ConfigMap.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultCaProvider#key
   */
  readonly key?: string;

  /**
   * The name of the object located at the provider type.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultCaProvider#name
   */
  readonly name: string;

  /**
   * The namespace the Provider type is in. Can only be defined when used in a ClusterSecretStore.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultCaProvider#namespace
   */
  readonly namespace?: string;

  /**
   * The type of provider to use such as "Secret", or "ConfigMap".
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultCaProvider#type
   */
  readonly type: ClusterSecretStoreV1Beta1SpecProviderVaultCaProviderType;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultCaProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultCaProvider(
  obj: ClusterSecretStoreV1Beta1SpecProviderVaultCaProvider | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
    type: obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Version is the Vault KV secret engine version. This can be either "v1" or "v2". Version defaults to "v2".
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultVersion
 */
export enum ClusterSecretStoreV1Beta1SpecProviderVaultVersion {
  /** v1 */
  V1 = "v1",
  /** v2 */
  V2 = "v2",
}

/**
 * The provider for the CA bundle to use to validate webhook server certificate.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderWebhookCaProvider
 */
export interface ClusterSecretStoreV1Beta1SpecProviderWebhookCaProvider {
  /**
   * The key the value inside of the provider type to use, only used with "Secret" type
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderWebhookCaProvider#key
   */
  readonly key?: string;

  /**
   * The name of the object located at the provider type.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderWebhookCaProvider#name
   */
  readonly name: string;

  /**
   * The namespace the Provider type is in.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderWebhookCaProvider#namespace
   */
  readonly namespace?: string;

  /**
   * The type of provider to use such as "Secret", or "ConfigMap".
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderWebhookCaProvider#type
   */
  readonly type: ClusterSecretStoreV1Beta1SpecProviderWebhookCaProviderType;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderWebhookCaProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderWebhookCaProvider(
  obj: ClusterSecretStoreV1Beta1SpecProviderWebhookCaProvider | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
    type: obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Result formatting
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderWebhookResult
 */
export interface ClusterSecretStoreV1Beta1SpecProviderWebhookResult {
  /**
   * Json path of return value
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderWebhookResult#jsonPath
   */
  readonly jsonPath?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderWebhookResult' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderWebhookResult(
  obj: ClusterSecretStoreV1Beta1SpecProviderWebhookResult | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    jsonPath: obj.jsonPath,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSecretStoreV1Beta1SpecProviderWebhookSecrets
 */
export interface ClusterSecretStoreV1Beta1SpecProviderWebhookSecrets {
  /**
   * Name of this secret in templates
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderWebhookSecrets#name
   */
  readonly name: string;

  /**
   * Secret ref to fill in credentials
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderWebhookSecrets#secretRef
   */
  readonly secretRef: ClusterSecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderWebhookSecrets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderWebhookSecrets(
  obj: ClusterSecretStoreV1Beta1SpecProviderWebhookSecrets | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    secretRef:
      toJson_ClusterSecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef(
        obj.secretRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Auth defines the information necessary to authenticate against Yandex Certificate Manager
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth
 */
export interface ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth {
  /**
   * The authorized key used for authentication
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth#authorizedKeySecretRef
   */
  readonly authorizedKeySecretRef?: ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth(
  obj:
    | ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    authorizedKeySecretRef:
      toJson_ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef(
        obj.authorizedKeySecretRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The provider for the CA bundle to use to validate Yandex.Cloud server certificate.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider
 */
export interface ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider {
  /**
   * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider#certSecretRef
   */
  readonly certSecretRef?: ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider(
  obj:
    | ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    certSecretRef:
      toJson_ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef(
        obj.certSecretRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Auth defines the information necessary to authenticate against Yandex Lockbox
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuth
 */
export interface ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuth {
  /**
   * The authorized key used for authentication
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuth#authorizedKeySecretRef
   */
  readonly authorizedKeySecretRef?: ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuth(
  obj: ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuth | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    authorizedKeySecretRef:
      toJson_ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef(
        obj.authorizedKeySecretRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The provider for the CA bundle to use to validate Yandex.Cloud server certificate.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProvider
 */
export interface ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProvider {
  /**
   * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProvider#certSecretRef
   */
  readonly certSecretRef?: ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProvider(
  obj: ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProvider | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    certSecretRef:
      toJson_ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef(
        obj.certSecretRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Kubernetes authenticates with Akeyless by passing the ServiceAccount token stored in the named Secret resource.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth {
  /**
   * the Akeyless Kubernetes auth-method access-id
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth#accessID
   */
  readonly accessId: string;

  /**
   * Kubernetes-auth configuration name in Akeyless-Gateway
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth#k8sConfName
   */
  readonly k8SConfName: string;

  /**
   * Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Akeyless. If a name is specified without a key, `token` is the default. If one is not specified, the one bound to the controller will be used.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth#secretRef
   */
  readonly secretRef?: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef;

  /**
   * Optional service account field containing the name of a kubernetes ServiceAccount. If the service account is specified, the service account secret token JWT will be used for authenticating with Akeyless. If the service account selector is not supplied, the secretRef will be used instead.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth#serviceAccountRef
   */
  readonly serviceAccountRef?: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth(
  obj:
    | ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    accessID: obj.accessId,
    k8sConfName: obj.k8SConfName,
    secretRef:
      toJson_ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef(
        obj.secretRef,
      ),
    serviceAccountRef:
      toJson_ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef(
        obj.serviceAccountRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Secret that contains the details to authenticate with Akeyless.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef {
  /**
   * The SecretAccessID is used for authentication
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef#accessID
   */
  readonly accessId?: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId;

  /**
   * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef#accessType
   */
  readonly accessType?: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType;

  /**
   * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef#accessTypeParam
   */
  readonly accessTypeParam?: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef(
  obj:
    | ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    accessID:
      toJson_ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId(
        obj.accessId,
      ),
    accessType:
      toJson_ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType(
        obj.accessType,
      ),
    accessTypeParam:
      toJson_ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam(
        obj.accessTypeParam,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The type of provider to use such as "Secret", or "ConfigMap".
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessCaProviderType
 */
export enum ClusterSecretStoreV1Beta1SpecProviderAkeylessCaProviderType {
  /** Secret */
  SECRET = "Secret",
  /** ConfigMap */
  CONFIG_MAP = "ConfigMap",
}

/**
 * Authenticate against Alibaba using RRSA.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthRrsa
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthRrsa {
  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthRrsa#oidcProviderArn
   */
  readonly oidcProviderArn: string;

  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthRrsa#oidcTokenFilePath
   */
  readonly oidcTokenFilePath: string;

  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthRrsa#roleArn
   */
  readonly roleArn: string;

  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthRrsa#sessionName
   */
  readonly sessionName: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthRrsa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthRrsa(
  obj: ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthRrsa | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    oidcProviderArn: obj.oidcProviderArn,
    oidcTokenFilePath: obj.oidcTokenFilePath,
    roleArn: obj.roleArn,
    sessionName: obj.sessionName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * AlibabaAuthSecretRef holds secret references for Alibaba credentials.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef {
  /**
   * The AccessKeyID is used for authentication
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef#accessKeyIDSecretRef
   */
  readonly accessKeyIdSecretRef: ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef;

  /**
   * The AccessKeySecret is used for authentication
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef#accessKeySecretSecretRef
   */
  readonly accessKeySecretSecretRef: ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef(
  obj: ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    accessKeyIDSecretRef:
      toJson_ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef(
        obj.accessKeyIdSecretRef,
      ),
    accessKeySecretSecretRef:
      toJson_ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef(
        obj.accessKeySecretSecretRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Authenticate against AWS using service account tokens.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwt
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwt {
  /**
   * A reference to a ServiceAccount resource.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwt#serviceAccountRef
   */
  readonly serviceAccountRef?: ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwt' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwt(
  obj: ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwt | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    serviceAccountRef:
      toJson_ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef(
        obj.serviceAccountRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * AWSAuthSecretRef holds secret references for AWS credentials both AccessKeyID and SecretAccessKey must be defined in order to properly authenticate.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRef {
  /**
   * The AccessKeyID is used for authentication
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRef#accessKeyIDSecretRef
   */
  readonly accessKeyIdSecretRef?: ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef;

  /**
   * The SecretAccessKey is used for authentication
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRef#secretAccessKeySecretRef
   */
  readonly secretAccessKeySecretRef?: ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef;

  /**
   * The SessionToken used for authentication This must be defined if AccessKeyID and SecretAccessKey are temporary credentials see: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_use-resources.html
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRef#sessionTokenSecretRef
   */
  readonly sessionTokenSecretRef?: ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSessionTokenSecretRef;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRef(
  obj: ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    accessKeyIDSecretRef:
      toJson_ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef(
        obj.accessKeyIdSecretRef,
      ),
    secretAccessKeySecretRef:
      toJson_ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef(
        obj.secretAccessKeySecretRef,
      ),
    sessionTokenSecretRef:
      toJson_ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSessionTokenSecretRef(
        obj.sessionTokenSecretRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The Azure clientId of the service principle used for authentication.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId(
  obj:
    | ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The Azure ClientSecret of the service principle used for authentication.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret(
  obj:
    | ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikey
 */
export interface ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikey {
  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikey#account
   */
  readonly account: string;

  /**
   * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikey#apiKeyRef
   */
  readonly apiKeyRef: ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyApiKeyRef;

  /**
   * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikey#userRef
   */
  readonly userRef: ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyUserRef;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikey(
  obj: ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikey | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    account: obj.account,
    apiKeyRef:
      toJson_ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyApiKeyRef(
        obj.apiKeyRef,
      ),
    userRef:
      toJson_ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyUserRef(
        obj.userRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwt
 */
export interface ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwt {
  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwt#account
   */
  readonly account: string;

  /**
   * Optional SecretRef that refers to a key in a Secret resource containing JWT token to authenticate with Conjur using the JWT authentication method.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwt#secretRef
   */
  readonly secretRef?: ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtSecretRef;

  /**
   * Optional ServiceAccountRef specifies the Kubernetes service account for which to request a token for with the `TokenRequest` API.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwt#serviceAccountRef
   */
  readonly serviceAccountRef?: ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtServiceAccountRef;

  /**
   * The conjur authn jwt webservice id
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwt#serviceID
   */
  readonly serviceId: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwt' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwt(
  obj: ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwt | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    account: obj.account,
    secretRef:
      toJson_ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtSecretRef(
        obj.secretRef,
      ),
    serviceAccountRef:
      toJson_ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtServiceAccountRef(
        obj.serviceAccountRef,
      ),
    serviceID: obj.serviceId,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The type of provider to use such as "Secret", or "ConfigMap".
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderConjurCaProviderType
 */
export enum ClusterSecretStoreV1Beta1SpecProviderConjurCaProviderType {
  /** Secret */
  SECRET = "Secret",
  /** ConfigMap */
  CONFIG_MAP = "ConfigMap",
}

/**
 * SecretRef references a key in a secret that will be used as value.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderDelineaClientIdSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderDelineaClientIdSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDelineaClientIdSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDelineaClientIdSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDelineaClientIdSecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderDelineaClientIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderDelineaClientIdSecretRef(
  obj:
    | ClusterSecretStoreV1Beta1SpecProviderDelineaClientIdSecretRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * SecretRef references a key in a secret that will be used as value.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecretSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecretSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecretSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecretSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecretSecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecretSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecretSecretRef(
  obj:
    | ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecretSecretRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRef {
  /**
   * The DopplerToken is used for authentication. See https://docs.doppler.com/reference/api#authentication for auth token types. The Key attribute defaults to dopplerToken if not specified.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRef#dopplerToken
   */
  readonly dopplerToken: ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRef(
  obj: ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    dopplerToken:
      toJson_ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken(
        obj.dopplerToken,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef {
  /**
   * The SecretAccessKey is used for authentication
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef#secretAccessKeySecretRef
   */
  readonly secretAccessKeySecretRef?: ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef(
  obj: ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    secretAccessKeySecretRef:
      toJson_ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef(
        obj.secretAccessKeySecretRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity
 */
export interface ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity {
  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity#clusterLocation
   */
  readonly clusterLocation: string;

  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity#clusterName
   */
  readonly clusterName: string;

  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity#clusterProjectID
   */
  readonly clusterProjectId?: string;

  /**
   * A reference to a ServiceAccount resource.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity#serviceAccountRef
   */
  readonly serviceAccountRef: ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity(
  obj:
    | ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    clusterLocation: obj.clusterLocation,
    clusterName: obj.clusterName,
    clusterProjectID: obj.clusterProjectId,
    serviceAccountRef:
      toJson_ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef(
        obj.serviceAccountRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRef {
  /**
   * AccessToken is used for authentication.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRef#accessToken
   */
  readonly accessToken?: ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRef(
  obj: ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    accessToken:
      toJson_ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken(
        obj.accessToken,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * IBM Container-based auth with IAM Trusted Profile.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderIbmAuthContainerAuth
 */
export interface ClusterSecretStoreV1Beta1SpecProviderIbmAuthContainerAuth {
  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderIbmAuthContainerAuth#iamEndpoint
   */
  readonly iamEndpoint?: string;

  /**
   * the IBM Trusted Profile
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderIbmAuthContainerAuth#profile
   */
  readonly profile: string;

  /**
   * Location the token is mounted on the pod
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderIbmAuthContainerAuth#tokenLocation
   */
  readonly tokenLocation?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderIbmAuthContainerAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderIbmAuthContainerAuth(
  obj: ClusterSecretStoreV1Beta1SpecProviderIbmAuthContainerAuth | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    iamEndpoint: obj.iamEndpoint,
    profile: obj.profile,
    tokenLocation: obj.tokenLocation,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRef {
  /**
   * The SecretAccessKey is used for authentication
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRef#secretApiKeySecretRef
   */
  readonly secretApiKeySecretRef?: ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRef(
  obj: ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    secretApiKeySecretRef:
      toJson_ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef(
        obj.secretApiKeySecretRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * has both clientCert and clientKey as secretKeySelector
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCert
 */
export interface ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCert {
  /**
   * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCert#clientCert
   */
  readonly clientCert?: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert;

  /**
   * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCert#clientKey
   */
  readonly clientKey?: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCert(
  obj: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCert | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    clientCert:
      toJson_ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert(
        obj.clientCert,
      ),
    clientKey:
      toJson_ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey(
        obj.clientKey,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * points to a service account that should be used for authentication
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount
 */
export interface ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount {
  /**
   * Audience specifies the `aud` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount(
  obj:
    | ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    audiences: obj.audiences?.map((y) => y),
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * use static token to authenticate with
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthToken
 */
export interface ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthToken {
  /**
   * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthToken#bearerToken
   */
  readonly bearerToken?: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthToken' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthToken(
  obj: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthToken | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    bearerToken:
      toJson_ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken(
        obj.bearerToken,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * see: https://external-secrets.io/v0.4.1/spec/#external-secrets.io/v1alpha1.CAProvider
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProvider
 */
export interface ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProvider {
  /**
   * The key where the CA certificate can be found in the Secret or ConfigMap.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProvider#key
   */
  readonly key?: string;

  /**
   * The name of the object located at the provider type.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProvider#name
   */
  readonly name: string;

  /**
   * The namespace the Provider type is in. Can only be defined when used in a ClusterSecretStore.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProvider#namespace
   */
  readonly namespace?: string;

  /**
   * The type of provider to use such as "Secret", or "ConfigMap".
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProvider#type
   */
  readonly type: ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProviderType;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProvider(
  obj:
    | ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProvider
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
    type: obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * OnePasswordAuthSecretRef holds secret references for 1Password credentials.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef {
  /**
   * The ConnectToken is used for authentication to a 1Password Connect Server.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef#connectTokenSecretRef
   */
  readonly connectTokenSecretRef: ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef(
  obj:
    | ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    connectTokenSecretRef:
      toJson_ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef(
        obj.connectTokenSecretRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * SecretRef to pass through sensitive information.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRef {
  /**
   * Fingerprint is the fingerprint of the API private key.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRef#fingerprint
   */
  readonly fingerprint: ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint;

  /**
   * PrivateKey is the user's API Signing Key in PEM format, used for authentication.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRef#privatekey
   */
  readonly privatekey: ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRef(
  obj: ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    fingerprint:
      toJson_ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint(
        obj.fingerprint,
      ),
    privatekey:
      toJson_ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey(
        obj.privatekey,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * SecretRef references a key in a secret that will be used as value.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKeySecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKeySecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKeySecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKeySecretRef(
  obj:
    | ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKeySecretRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * SecretRef references a key in a secret that will be used as value.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKeySecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKeySecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKeySecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKeySecretRef(
  obj:
    | ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKeySecretRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef(
  obj:
    | ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * AppRole authenticates with Vault using the App Role auth mechanism, with the role and secret stored in a Kubernetes Secret resource.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRole
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRole {
  /**
   * Path where the App Role authentication backend is mounted in Vault, e.g: "approle"
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRole#path
   */
  readonly path: string;

  /**
   * RoleID configured in the App Role authentication backend when setting up the authentication backend in Vault.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRole#roleId
   */
  readonly roleId?: string;

  /**
   * Reference to a key in a Secret that contains the App Role ID used to authenticate with Vault. The `key` field must be specified and denotes which entry within the Secret resource is used as the app role id.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRole#roleRef
   */
  readonly roleRef?: ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleRoleRef;

  /**
   * Reference to a key in a Secret that contains the App Role secret used to authenticate with Vault. The `key` field must be specified and denotes which entry within the Secret resource is used as the app role secret.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRole#secretRef
   */
  readonly secretRef: ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRole' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRole(
  obj: ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRole | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    path: obj.path,
    roleId: obj.roleId,
    roleRef:
      toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleRoleRef(
        obj.roleRef,
      ),
    secretRef:
      toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef(
        obj.secretRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Cert authenticates with TLS Certificates by passing client certificate, private key and ca certificate Cert authentication method
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthCert
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuthCert {
  /**
   * ClientCert is a certificate to authenticate using the Cert Vault authentication method
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthCert#clientCert
   */
  readonly clientCert?: ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertClientCert;

  /**
   * SecretRef to a key in a Secret resource containing client private key to authenticate with Vault using the Cert authentication method
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthCert#secretRef
   */
  readonly secretRef?: ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuthCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthCert(
  obj: ClusterSecretStoreV1Beta1SpecProviderVaultAuthCert | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    clientCert:
      toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertClientCert(
        obj.clientCert,
      ),
    secretRef:
      toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef(
        obj.secretRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Iam authenticates with vault by passing a special AWS request signed with AWS IAM credentials AWS IAM authentication method
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIam
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuthIam {
  /**
   * AWS External ID set on assumed IAM roles
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIam#externalID
   */
  readonly externalId?: string;

  /**
   * Specify a service account with IRSA enabled
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIam#jwt
   */
  readonly jwt?: ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwt;

  /**
   * Path where the AWS auth method is enabled in Vault, e.g: "aws"
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIam#path
   */
  readonly path?: string;

  /**
   * AWS region
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIam#region
   */
  readonly region?: string;

  /**
   * This is the AWS role to be assumed before talking to vault
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIam#role
   */
  readonly role?: string;

  /**
   * Specify credentials in a Secret object
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIam#secretRef
   */
  readonly secretRef?: ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRef;

  /**
   * X-Vault-AWS-IAM-Server-ID is an additional header used by Vault IAM auth method to mitigate against different types of replay attacks. More details here: https://developer.hashicorp.com/vault/docs/auth/aws
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIam#vaultAwsIamServerID
   */
  readonly vaultAwsIamServerId?: string;

  /**
   * Vault Role. In vault, a role describes an identity with a set of permissions, groups, or policies you want to attach a user of the secrets engine
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIam#vaultRole
   */
  readonly vaultRole: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuthIam' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthIam(
  obj: ClusterSecretStoreV1Beta1SpecProviderVaultAuthIam | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    externalID: obj.externalId,
    jwt: toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwt(obj.jwt),
    path: obj.path,
    region: obj.region,
    role: obj.role,
    secretRef:
      toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRef(
        obj.secretRef,
      ),
    vaultAwsIamServerID: obj.vaultAwsIamServerId,
    vaultRole: obj.vaultRole,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Jwt authenticates with Vault by passing role and JWT token using the JWT/OIDC authentication method
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwt
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwt {
  /**
   * Optional ServiceAccountToken specifies the Kubernetes service account for which to request a token for with the `TokenRequest` API.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwt#kubernetesServiceAccountToken
   */
  readonly kubernetesServiceAccountToken?: ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken;

  /**
   * Path where the JWT authentication backend is mounted in Vault, e.g: "jwt"
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwt#path
   */
  readonly path: string;

  /**
   * Role is a JWT role to authenticate using the JWT/OIDC Vault authentication method
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwt#role
   */
  readonly role?: string;

  /**
   * Optional SecretRef that refers to a key in a Secret resource containing JWT token to authenticate with Vault using the JWT/OIDC authentication method.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwt#secretRef
   */
  readonly secretRef?: ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwt' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwt(
  obj: ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwt | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    kubernetesServiceAccountToken:
      toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken(
        obj.kubernetesServiceAccountToken,
      ),
    path: obj.path,
    role: obj.role,
    secretRef:
      toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef(
        obj.secretRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Kubernetes authenticates with Vault by passing the ServiceAccount token stored in the named Secret resource to the Vault server.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetes
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetes {
  /**
   * Path where the Kubernetes authentication backend is mounted in Vault, e.g: "kubernetes"
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetes#mountPath
   */
  readonly mountPath: string;

  /**
   * A required field containing the Vault Role to assume. A Role binds a Kubernetes ServiceAccount with a set of Vault policies.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetes#role
   */
  readonly role: string;

  /**
   * Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Vault. If a name is specified without a key, `token` is the default. If one is not specified, the one bound to the controller will be used.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetes#secretRef
   */
  readonly secretRef?: ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef;

  /**
   * Optional service account field containing the name of a kubernetes ServiceAccount. If the service account is specified, the service account secret token JWT will be used for authenticating with Vault. If the service account selector is not supplied, the secretRef will be used instead.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetes#serviceAccountRef
   */
  readonly serviceAccountRef?: ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetes(
  obj: ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetes | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    mountPath: obj.mountPath,
    role: obj.role,
    secretRef:
      toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef(
        obj.secretRef,
      ),
    serviceAccountRef:
      toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef(
        obj.serviceAccountRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Ldap authenticates with Vault by passing username/password pair using the LDAP authentication method
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdap
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdap {
  /**
   * Path where the LDAP authentication backend is mounted in Vault, e.g: "ldap"
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdap#path
   */
  readonly path: string;

  /**
   * SecretRef to a key in a Secret resource containing password for the LDAP user used to authenticate with Vault using the LDAP authentication method
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdap#secretRef
   */
  readonly secretRef?: ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef;

  /**
   * Username is a LDAP user name used to authenticate using the LDAP Vault authentication method
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdap#username
   */
  readonly username: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdap(
  obj: ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdap | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    path: obj.path,
    secretRef:
      toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef(
        obj.secretRef,
      ),
    username: obj.username,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * TokenSecretRef authenticates with Vault by presenting a token.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef(
  obj: ClusterSecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * UserPass authenticates with Vault by passing username/password pair
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPass
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPass {
  /**
   * Path where the UserPassword authentication backend is mounted in Vault, e.g: "user"
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPass#path
   */
  readonly path: string;

  /**
   * SecretRef to a key in a Secret resource containing password for the user used to authenticate with Vault using the UserPass authentication method
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPass#secretRef
   */
  readonly secretRef?: ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPassSecretRef;

  /**
   * Username is a user name used to authenticate using the UserPass Vault authentication method
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPass#username
   */
  readonly username: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPass' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPass(
  obj: ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPass | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    path: obj.path,
    secretRef:
      toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPassSecretRef(
        obj.secretRef,
      ),
    username: obj.username,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The type of provider to use such as "Secret", or "ConfigMap".
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultCaProviderType
 */
export enum ClusterSecretStoreV1Beta1SpecProviderVaultCaProviderType {
  /** Secret */
  SECRET = "Secret",
  /** ConfigMap */
  CONFIG_MAP = "ConfigMap",
}

/**
 * The type of provider to use such as "Secret", or "ConfigMap".
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderWebhookCaProviderType
 */
export enum ClusterSecretStoreV1Beta1SpecProviderWebhookCaProviderType {
  /** Secret */
  SECRET = "Secret",
  /** ConfigMap */
  CONFIG_MAP = "ConfigMap",
}

/**
 * Secret ref to fill in credentials
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef(
  obj: ClusterSecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The authorized key used for authentication
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef(
  obj:
    | ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef(
  obj:
    | ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The authorized key used for authentication
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef(
  obj:
    | ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef(
  obj:
    | ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Akeyless. If a name is specified without a key, `token` is the default. If one is not specified, the one bound to the controller will be used.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef(
  obj:
    | ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Optional service account field containing the name of a kubernetes ServiceAccount. If the service account is specified, the service account secret token JWT will be used for authenticating with Akeyless. If the service account selector is not supplied, the secretRef will be used instead.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef(
  obj:
    | ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    audiences: obj.audiences?.map((y) => y),
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The SecretAccessID is used for authentication
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId(
  obj:
    | ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType(
  obj:
    | ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam(
  obj:
    | ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The AccessKeyID is used for authentication
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef(
  obj:
    | ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The AccessKeySecret is used for authentication
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef(
  obj:
    | ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A reference to a ServiceAccount resource.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef(
  obj:
    | ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    audiences: obj.audiences?.map((y) => y),
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The AccessKeyID is used for authentication
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef(
  obj:
    | ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The SecretAccessKey is used for authentication
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef(
  obj:
    | ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The SessionToken used for authentication This must be defined if AccessKeyID and SecretAccessKey are temporary credentials see: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_use-resources.html
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSessionTokenSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSessionTokenSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSessionTokenSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSessionTokenSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSessionTokenSecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSessionTokenSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSessionTokenSecretRef(
  obj:
    | ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSessionTokenSecretRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyApiKeyRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyApiKeyRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyApiKeyRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyApiKeyRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyApiKeyRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyApiKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyApiKeyRef(
  obj:
    | ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyApiKeyRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyUserRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyUserRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyUserRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyUserRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyUserRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyUserRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyUserRef(
  obj: ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyUserRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Optional SecretRef that refers to a key in a Secret resource containing JWT token to authenticate with Conjur using the JWT authentication method.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtSecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtSecretRef(
  obj: ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Optional ServiceAccountRef specifies the Kubernetes service account for which to request a token for with the `TokenRequest` API.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtServiceAccountRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtServiceAccountRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtServiceAccountRef(
  obj:
    | ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtServiceAccountRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    audiences: obj.audiences?.map((y) => y),
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The DopplerToken is used for authentication. See https://docs.doppler.com/reference/api#authentication for auth token types. The Key attribute defaults to dopplerToken if not specified.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken
 */
export interface ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken(
  obj:
    | ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The SecretAccessKey is used for authentication
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef(
  obj:
    | ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A reference to a ServiceAccount resource.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef(
  obj:
    | ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    audiences: obj.audiences?.map((y) => y),
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * AccessToken is used for authentication.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken
 */
export interface ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken(
  obj:
    | ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The SecretAccessKey is used for authentication
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef(
  obj:
    | ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert
 */
export interface ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert(
  obj:
    | ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey
 */
export interface ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey(
  obj:
    | ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken
 */
export interface ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken(
  obj:
    | ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The type of provider to use such as "Secret", or "ConfigMap".
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProviderType
 */
export enum ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProviderType {
  /** Secret */
  SECRET = "Secret",
  /** ConfigMap */
  CONFIG_MAP = "ConfigMap",
}

/**
 * The ConnectToken is used for authentication to a 1Password Connect Server.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef(
  obj:
    | ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Fingerprint is the fingerprint of the API private key.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint
 */
export interface ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint(
  obj:
    | ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * PrivateKey is the user's API Signing Key in PEM format, used for authentication.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey
 */
export interface ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey(
  obj:
    | ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a key in a Secret that contains the App Role ID used to authenticate with Vault. The `key` field must be specified and denotes which entry within the Secret resource is used as the app role id.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleRoleRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleRoleRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleRoleRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleRoleRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleRoleRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleRoleRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleRoleRef(
  obj: ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleRoleRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a key in a Secret that contains the App Role secret used to authenticate with Vault. The `key` field must be specified and denotes which entry within the Secret resource is used as the app role secret.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef(
  obj:
    | ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ClientCert is a certificate to authenticate using the Cert Vault authentication method
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertClientCert
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertClientCert {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertClientCert#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertClientCert#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertClientCert#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertClientCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertClientCert(
  obj: ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertClientCert | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * SecretRef to a key in a Secret resource containing client private key to authenticate with Vault using the Cert authentication method
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef(
  obj: ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Specify a service account with IRSA enabled
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwt
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwt {
  /**
   * A reference to a ServiceAccount resource.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwt#serviceAccountRef
   */
  readonly serviceAccountRef?: ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwtServiceAccountRef;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwt' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwt(
  obj: ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwt | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    serviceAccountRef:
      toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwtServiceAccountRef(
        obj.serviceAccountRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Specify credentials in a Secret object
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRef {
  /**
   * The AccessKeyID is used for authentication
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRef#accessKeyIDSecretRef
   */
  readonly accessKeyIdSecretRef?: ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef;

  /**
   * The SecretAccessKey is used for authentication
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRef#secretAccessKeySecretRef
   */
  readonly secretAccessKeySecretRef?: ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef;

  /**
   * The SessionToken used for authentication This must be defined if AccessKeyID and SecretAccessKey are temporary credentials see: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_use-resources.html
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRef#sessionTokenSecretRef
   */
  readonly sessionTokenSecretRef?: ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSessionTokenSecretRef;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRef(
  obj: ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    accessKeyIDSecretRef:
      toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef(
        obj.accessKeyIdSecretRef,
      ),
    secretAccessKeySecretRef:
      toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef(
        obj.secretAccessKeySecretRef,
      ),
    sessionTokenSecretRef:
      toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSessionTokenSecretRef(
        obj.sessionTokenSecretRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Optional ServiceAccountToken specifies the Kubernetes service account for which to request a token for with the `TokenRequest` API.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken {
  /**
   * Optional audiences field that will be used to request a temporary Kubernetes service account token for the service account referenced by `serviceAccountRef`. Defaults to a single audience `vault` it not specified. Deprecated: use serviceAccountRef.Audiences instead
   *
   * @default a single audience `vault` it not specified. Deprecated: use serviceAccountRef.Audiences instead
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken#audiences
   */
  readonly audiences?: string[];

  /**
   * Optional expiration time in seconds that will be used to request a temporary Kubernetes service account token for the service account referenced by `serviceAccountRef`. Deprecated: this will be removed in the future. Defaults to 10 minutes.
   *
   * @default 10 minutes.
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken#expirationSeconds
   */
  readonly expirationSeconds?: number;

  /**
   * Service account field containing the name of a kubernetes ServiceAccount.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken#serviceAccountRef
   */
  readonly serviceAccountRef: ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken(
  obj:
    | ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    audiences: obj.audiences?.map((y) => y),
    expirationSeconds: obj.expirationSeconds,
    serviceAccountRef:
      toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef(
        obj.serviceAccountRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Optional SecretRef that refers to a key in a Secret resource containing JWT token to authenticate with Vault using the JWT/OIDC authentication method.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef(
  obj: ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Vault. If a name is specified without a key, `token` is the default. If one is not specified, the one bound to the controller will be used.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef(
  obj:
    | ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Optional service account field containing the name of a kubernetes ServiceAccount. If the service account is specified, the service account secret token JWT will be used for authenticating with Vault. If the service account selector is not supplied, the secretRef will be used instead.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef(
  obj:
    | ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    audiences: obj.audiences?.map((y) => y),
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * SecretRef to a key in a Secret resource containing password for the LDAP user used to authenticate with Vault using the LDAP authentication method
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef(
  obj: ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * SecretRef to a key in a Secret resource containing password for the user used to authenticate with Vault using the UserPass authentication method
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPassSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPassSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPassSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPassSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPassSecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPassSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPassSecretRef(
  obj:
    | ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPassSecretRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A reference to a ServiceAccount resource.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwtServiceAccountRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwtServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwtServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwtServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwtServiceAccountRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwtServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwtServiceAccountRef(
  obj:
    | ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwtServiceAccountRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    audiences: obj.audiences?.map((y) => y),
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The AccessKeyID is used for authentication
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef(
  obj:
    | ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The SecretAccessKey is used for authentication
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef(
  obj:
    | ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The SessionToken used for authentication This must be defined if AccessKeyID and SecretAccessKey are temporary credentials see: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_use-resources.html
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSessionTokenSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSessionTokenSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSessionTokenSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSessionTokenSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSessionTokenSecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSessionTokenSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSessionTokenSecretRef(
  obj:
    | ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSessionTokenSecretRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Service account field containing the name of a kubernetes ServiceAccount.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef(
  obj:
    | ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    audiences: obj.audiences?.map((y) => y),
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ExternalSecret is the Schema for the external-secrets API.
 *
 * @schema ExternalSecret
 */
export class ExternalSecret extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ExternalSecret"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "external-secrets.io/v1alpha1",
    kind: "ExternalSecret",
  };

  /**
   * Renders a Kubernetes manifest for "ExternalSecret".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ExternalSecretProps = {}): any {
    return {
      ...ExternalSecret.GVK,
      ...toJson_ExternalSecretProps(props),
    };
  }

  /**
   * Defines a "ExternalSecret" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(
    scope: Construct,
    id: string,
    props: ExternalSecretProps = {},
  ) {
    super(scope, id, {
      ...ExternalSecret.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ExternalSecret.GVK,
      ...toJson_ExternalSecretProps(resolved),
    };
  }
}

/**
 * ExternalSecret is the Schema for the external-secrets API.
 *
 * @schema ExternalSecret
 */
export interface ExternalSecretProps {
  /**
   * @schema ExternalSecret#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ExternalSecretSpec defines the desired state of ExternalSecret.
   *
   * @schema ExternalSecret#spec
   */
  readonly spec?: ExternalSecretSpec;
}

/**
 * Converts an object of type 'ExternalSecretProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretProps(
  obj: ExternalSecretProps | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    spec: toJson_ExternalSecretSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ExternalSecretSpec defines the desired state of ExternalSecret.
 *
 * @schema ExternalSecretSpec
 */
export interface ExternalSecretSpec {
  /**
   * Data defines the connection between the Kubernetes Secret keys and the Provider data
   *
   * @schema ExternalSecretSpec#data
   */
  readonly data?: ExternalSecretSpecData[];

  /**
   * DataFrom is used to fetch all properties from a specific Provider data If multiple entries are specified, the Secret keys are merged in the specified order
   *
   * @schema ExternalSecretSpec#dataFrom
   */
  readonly dataFrom?: ExternalSecretSpecDataFrom[];

  /**
   * RefreshInterval is the amount of time before the values are read again from the SecretStore provider Valid time units are "ns", "us" (or "Âµs"), "ms", "s", "m", "h" May be set to zero to fetch and create it once. Defaults to 1h.
   *
   * @default 1h.
   * @schema ExternalSecretSpec#refreshInterval
   */
  readonly refreshInterval?: string;

  /**
   * SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.
   *
   * @schema ExternalSecretSpec#secretStoreRef
   */
  readonly secretStoreRef: ExternalSecretSpecSecretStoreRef;

  /**
   * ExternalSecretTarget defines the Kubernetes Secret to be created There can be only one target per ExternalSecret.
   *
   * @schema ExternalSecretSpec#target
   */
  readonly target: ExternalSecretSpecTarget;
}

/**
 * Converts an object of type 'ExternalSecretSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretSpec(
  obj: ExternalSecretSpec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    data: obj.data?.map((y) => toJson_ExternalSecretSpecData(y)),
    dataFrom: obj.dataFrom?.map((y) => toJson_ExternalSecretSpecDataFrom(y)),
    refreshInterval: obj.refreshInterval,
    secretStoreRef: toJson_ExternalSecretSpecSecretStoreRef(obj.secretStoreRef),
    target: toJson_ExternalSecretSpecTarget(obj.target),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ExternalSecretData defines the connection between the Kubernetes Secret key (spec.data.<key>) and the Provider data.
 *
 * @schema ExternalSecretSpecData
 */
export interface ExternalSecretSpecData {
  /**
   * ExternalSecretDataRemoteRef defines Provider data location.
   *
   * @schema ExternalSecretSpecData#remoteRef
   */
  readonly remoteRef: ExternalSecretSpecDataRemoteRef;

  /**
   * @schema ExternalSecretSpecData#secretKey
   */
  readonly secretKey: string;
}

/**
 * Converts an object of type 'ExternalSecretSpecData' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretSpecData(
  obj: ExternalSecretSpecData | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    remoteRef: toJson_ExternalSecretSpecDataRemoteRef(obj.remoteRef),
    secretKey: obj.secretKey,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ExternalSecretDataRemoteRef defines Provider data location.
 *
 * @schema ExternalSecretSpecDataFrom
 */
export interface ExternalSecretSpecDataFrom {
  /**
   * Used to define a conversion Strategy
   *
   * @schema ExternalSecretSpecDataFrom#conversionStrategy
   */
  readonly conversionStrategy?: ExternalSecretSpecDataFromConversionStrategy;

  /**
   * Key is the key used in the Provider, mandatory
   *
   * @schema ExternalSecretSpecDataFrom#key
   */
  readonly key: string;

  /**
   * Used to select a specific property of the Provider value (if a map), if supported
   *
   * @schema ExternalSecretSpecDataFrom#property
   */
  readonly property?: string;

  /**
   * Used to select a specific version of the Provider value, if supported
   *
   * @schema ExternalSecretSpecDataFrom#version
   */
  readonly version?: string;
}

/**
 * Converts an object of type 'ExternalSecretSpecDataFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretSpecDataFrom(
  obj: ExternalSecretSpecDataFrom | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    conversionStrategy: obj.conversionStrategy,
    key: obj.key,
    property: obj.property,
    version: obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.
 *
 * @schema ExternalSecretSpecSecretStoreRef
 */
export interface ExternalSecretSpecSecretStoreRef {
  /**
   * Kind of the SecretStore resource (SecretStore or ClusterSecretStore) Defaults to `SecretStore`
   *
   * @default SecretStore`
   * @schema ExternalSecretSpecSecretStoreRef#kind
   */
  readonly kind?: string;

  /**
   * Name of the SecretStore resource
   *
   * @schema ExternalSecretSpecSecretStoreRef#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ExternalSecretSpecSecretStoreRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretSpecSecretStoreRef(
  obj: ExternalSecretSpecSecretStoreRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    kind: obj.kind,
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ExternalSecretTarget defines the Kubernetes Secret to be created There can be only one target per ExternalSecret.
 *
 * @schema ExternalSecretSpecTarget
 */
export interface ExternalSecretSpecTarget {
  /**
   * CreationPolicy defines rules on how to create the resulting Secret Defaults to 'Owner'
   *
   * @default Owner'
   * @schema ExternalSecretSpecTarget#creationPolicy
   */
  readonly creationPolicy?: ExternalSecretSpecTargetCreationPolicy;

  /**
   * Immutable defines if the final secret will be immutable
   *
   * @schema ExternalSecretSpecTarget#immutable
   */
  readonly immutable?: boolean;

  /**
   * Name defines the name of the Secret resource to be managed This field is immutable Defaults to the .metadata.name of the ExternalSecret resource
   *
   * @default the .metadata.name of the ExternalSecret resource
   * @schema ExternalSecretSpecTarget#name
   */
  readonly name?: string;

  /**
   * Template defines a blueprint for the created Secret resource.
   *
   * @schema ExternalSecretSpecTarget#template
   */
  readonly template?: ExternalSecretSpecTargetTemplate;
}

/**
 * Converts an object of type 'ExternalSecretSpecTarget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretSpecTarget(
  obj: ExternalSecretSpecTarget | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    creationPolicy: obj.creationPolicy,
    immutable: obj.immutable,
    name: obj.name,
    template: toJson_ExternalSecretSpecTargetTemplate(obj.template),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ExternalSecretDataRemoteRef defines Provider data location.
 *
 * @schema ExternalSecretSpecDataRemoteRef
 */
export interface ExternalSecretSpecDataRemoteRef {
  /**
   * Used to define a conversion Strategy
   *
   * @schema ExternalSecretSpecDataRemoteRef#conversionStrategy
   */
  readonly conversionStrategy?: ExternalSecretSpecDataRemoteRefConversionStrategy;

  /**
   * Key is the key used in the Provider, mandatory
   *
   * @schema ExternalSecretSpecDataRemoteRef#key
   */
  readonly key: string;

  /**
   * Used to select a specific property of the Provider value (if a map), if supported
   *
   * @schema ExternalSecretSpecDataRemoteRef#property
   */
  readonly property?: string;

  /**
   * Used to select a specific version of the Provider value, if supported
   *
   * @schema ExternalSecretSpecDataRemoteRef#version
   */
  readonly version?: string;
}

/**
 * Converts an object of type 'ExternalSecretSpecDataRemoteRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretSpecDataRemoteRef(
  obj: ExternalSecretSpecDataRemoteRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    conversionStrategy: obj.conversionStrategy,
    key: obj.key,
    property: obj.property,
    version: obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Used to define a conversion Strategy
 *
 * @schema ExternalSecretSpecDataFromConversionStrategy
 */
export enum ExternalSecretSpecDataFromConversionStrategy {
  /** Default */
  DEFAULT = "Default",
  /** Unicode */
  UNICODE = "Unicode",
}

/**
 * CreationPolicy defines rules on how to create the resulting Secret Defaults to 'Owner'
 *
 * @default Owner'
 * @schema ExternalSecretSpecTargetCreationPolicy
 */
export enum ExternalSecretSpecTargetCreationPolicy {
  /** Owner */
  OWNER = "Owner",
  /** Merge */
  MERGE = "Merge",
  /** None */
  NONE = "None",
}

/**
 * Template defines a blueprint for the created Secret resource.
 *
 * @schema ExternalSecretSpecTargetTemplate
 */
export interface ExternalSecretSpecTargetTemplate {
  /**
   * @schema ExternalSecretSpecTargetTemplate#data
   */
  readonly data?: { [key: string]: string };

  /**
   * EngineVersion specifies the template engine version that should be used to compile/execute the template specified in .data and .templateFrom[].
   *
   * @schema ExternalSecretSpecTargetTemplate#engineVersion
   */
  readonly engineVersion?: ExternalSecretSpecTargetTemplateEngineVersion;

  /**
   * ExternalSecretTemplateMetadata defines metadata fields for the Secret blueprint.
   *
   * @schema ExternalSecretSpecTargetTemplate#metadata
   */
  readonly metadata?: ExternalSecretSpecTargetTemplateMetadata;

  /**
   * @schema ExternalSecretSpecTargetTemplate#templateFrom
   */
  readonly templateFrom?: ExternalSecretSpecTargetTemplateTemplateFrom[];

  /**
   * @schema ExternalSecretSpecTargetTemplate#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'ExternalSecretSpecTargetTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretSpecTargetTemplate(
  obj: ExternalSecretSpecTargetTemplate | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    data:
      obj.data === undefined
        ? undefined
        : Object.entries(obj.data).reduce(
            (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
            {},
          ),
    engineVersion: obj.engineVersion,
    metadata: toJson_ExternalSecretSpecTargetTemplateMetadata(obj.metadata),
    templateFrom: obj.templateFrom?.map((y) =>
      toJson_ExternalSecretSpecTargetTemplateTemplateFrom(y),
    ),
    type: obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Used to define a conversion Strategy
 *
 * @schema ExternalSecretSpecDataRemoteRefConversionStrategy
 */
export enum ExternalSecretSpecDataRemoteRefConversionStrategy {
  /** Default */
  DEFAULT = "Default",
  /** Unicode */
  UNICODE = "Unicode",
}

/**
 * EngineVersion specifies the template engine version that should be used to compile/execute the template specified in .data and .templateFrom[].
 *
 * @schema ExternalSecretSpecTargetTemplateEngineVersion
 */
export enum ExternalSecretSpecTargetTemplateEngineVersion {
  /** v1 */
  V1 = "v1",
  /** v2 */
  V2 = "v2",
}

/**
 * ExternalSecretTemplateMetadata defines metadata fields for the Secret blueprint.
 *
 * @schema ExternalSecretSpecTargetTemplateMetadata
 */
export interface ExternalSecretSpecTargetTemplateMetadata {
  /**
   * @schema ExternalSecretSpecTargetTemplateMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * @schema ExternalSecretSpecTargetTemplateMetadata#labels
   */
  readonly labels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ExternalSecretSpecTargetTemplateMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretSpecTargetTemplateMetadata(
  obj: ExternalSecretSpecTargetTemplateMetadata | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    annotations:
      obj.annotations === undefined
        ? undefined
        : Object.entries(obj.annotations).reduce(
            (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
            {},
          ),
    labels:
      obj.labels === undefined
        ? undefined
        : Object.entries(obj.labels).reduce(
            (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
            {},
          ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ExternalSecretSpecTargetTemplateTemplateFrom
 */
export interface ExternalSecretSpecTargetTemplateTemplateFrom {
  /**
   * @schema ExternalSecretSpecTargetTemplateTemplateFrom#configMap
   */
  readonly configMap?: ExternalSecretSpecTargetTemplateTemplateFromConfigMap;

  /**
   * @schema ExternalSecretSpecTargetTemplateTemplateFrom#secret
   */
  readonly secret?: ExternalSecretSpecTargetTemplateTemplateFromSecret;
}

/**
 * Converts an object of type 'ExternalSecretSpecTargetTemplateTemplateFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretSpecTargetTemplateTemplateFrom(
  obj: ExternalSecretSpecTargetTemplateTemplateFrom | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    configMap: toJson_ExternalSecretSpecTargetTemplateTemplateFromConfigMap(
      obj.configMap,
    ),
    secret: toJson_ExternalSecretSpecTargetTemplateTemplateFromSecret(
      obj.secret,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ExternalSecretSpecTargetTemplateTemplateFromConfigMap
 */
export interface ExternalSecretSpecTargetTemplateTemplateFromConfigMap {
  /**
   * @schema ExternalSecretSpecTargetTemplateTemplateFromConfigMap#items
   */
  readonly items: ExternalSecretSpecTargetTemplateTemplateFromConfigMapItems[];

  /**
   * @schema ExternalSecretSpecTargetTemplateTemplateFromConfigMap#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ExternalSecretSpecTargetTemplateTemplateFromConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretSpecTargetTemplateTemplateFromConfigMap(
  obj: ExternalSecretSpecTargetTemplateTemplateFromConfigMap | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    items: obj.items?.map((y) =>
      toJson_ExternalSecretSpecTargetTemplateTemplateFromConfigMapItems(y),
    ),
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ExternalSecretSpecTargetTemplateTemplateFromSecret
 */
export interface ExternalSecretSpecTargetTemplateTemplateFromSecret {
  /**
   * @schema ExternalSecretSpecTargetTemplateTemplateFromSecret#items
   */
  readonly items: ExternalSecretSpecTargetTemplateTemplateFromSecretItems[];

  /**
   * @schema ExternalSecretSpecTargetTemplateTemplateFromSecret#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ExternalSecretSpecTargetTemplateTemplateFromSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretSpecTargetTemplateTemplateFromSecret(
  obj: ExternalSecretSpecTargetTemplateTemplateFromSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    items: obj.items?.map((y) =>
      toJson_ExternalSecretSpecTargetTemplateTemplateFromSecretItems(y),
    ),
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ExternalSecretSpecTargetTemplateTemplateFromConfigMapItems
 */
export interface ExternalSecretSpecTargetTemplateTemplateFromConfigMapItems {
  /**
   * @schema ExternalSecretSpecTargetTemplateTemplateFromConfigMapItems#key
   */
  readonly key: string;
}

/**
 * Converts an object of type 'ExternalSecretSpecTargetTemplateTemplateFromConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretSpecTargetTemplateTemplateFromConfigMapItems(
  obj: ExternalSecretSpecTargetTemplateTemplateFromConfigMapItems | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ExternalSecretSpecTargetTemplateTemplateFromSecretItems
 */
export interface ExternalSecretSpecTargetTemplateTemplateFromSecretItems {
  /**
   * @schema ExternalSecretSpecTargetTemplateTemplateFromSecretItems#key
   */
  readonly key: string;
}

/**
 * Converts an object of type 'ExternalSecretSpecTargetTemplateTemplateFromSecretItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretSpecTargetTemplateTemplateFromSecretItems(
  obj: ExternalSecretSpecTargetTemplateTemplateFromSecretItems | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ExternalSecret is the Schema for the external-secrets API.
 *
 * @schema ExternalSecretV1Beta1
 */
export class ExternalSecretV1Beta1 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ExternalSecretV1Beta1"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "external-secrets.io/v1beta1",
    kind: "ExternalSecret",
  };

  /**
   * Renders a Kubernetes manifest for "ExternalSecretV1Beta1".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ExternalSecretV1Beta1Props = {}): any {
    return {
      ...ExternalSecretV1Beta1.GVK,
      ...toJson_ExternalSecretV1Beta1Props(props),
    };
  }

  /**
   * Defines a "ExternalSecretV1Beta1" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(
    scope: Construct,
    id: string,
    props: ExternalSecretV1Beta1Props = {},
  ) {
    super(scope, id, {
      ...ExternalSecretV1Beta1.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ExternalSecretV1Beta1.GVK,
      ...toJson_ExternalSecretV1Beta1Props(resolved),
    };
  }
}

/**
 * ExternalSecret is the Schema for the external-secrets API.
 *
 * @schema ExternalSecretV1Beta1
 */
export interface ExternalSecretV1Beta1Props {
  /**
   * @schema ExternalSecretV1Beta1#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ExternalSecretSpec defines the desired state of ExternalSecret.
   *
   * @schema ExternalSecretV1Beta1#spec
   */
  readonly spec?: ExternalSecretV1Beta1Spec;
}

/**
 * Converts an object of type 'ExternalSecretV1Beta1Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretV1Beta1Props(
  obj: ExternalSecretV1Beta1Props | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    spec: toJson_ExternalSecretV1Beta1Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ExternalSecretSpec defines the desired state of ExternalSecret.
 *
 * @schema ExternalSecretV1Beta1Spec
 */
export interface ExternalSecretV1Beta1Spec {
  /**
   * Data defines the connection between the Kubernetes Secret keys and the Provider data
   *
   * @schema ExternalSecretV1Beta1Spec#data
   */
  readonly data?: ExternalSecretV1Beta1SpecData[];

  /**
   * DataFrom is used to fetch all properties from a specific Provider data If multiple entries are specified, the Secret keys are merged in the specified order
   *
   * @schema ExternalSecretV1Beta1Spec#dataFrom
   */
  readonly dataFrom?: ExternalSecretV1Beta1SpecDataFrom[];

  /**
   * RefreshInterval is the amount of time before the values are read again from the SecretStore provider Valid time units are "ns", "us" (or "Âµs"), "ms", "s", "m", "h" May be set to zero to fetch and create it once. Defaults to 1h.
   *
   * @default 1h.
   * @schema ExternalSecretV1Beta1Spec#refreshInterval
   */
  readonly refreshInterval?: string;

  /**
   * SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.
   *
   * @schema ExternalSecretV1Beta1Spec#secretStoreRef
   */
  readonly secretStoreRef?: ExternalSecretV1Beta1SpecSecretStoreRef;

  /**
   * ExternalSecretTarget defines the Kubernetes Secret to be created There can be only one target per ExternalSecret.
   *
   * @schema ExternalSecretV1Beta1Spec#target
   */
  readonly target?: ExternalSecretV1Beta1SpecTarget;
}

/**
 * Converts an object of type 'ExternalSecretV1Beta1Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretV1Beta1Spec(
  obj: ExternalSecretV1Beta1Spec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    data: obj.data?.map((y) => toJson_ExternalSecretV1Beta1SpecData(y)),
    dataFrom: obj.dataFrom?.map((y) =>
      toJson_ExternalSecretV1Beta1SpecDataFrom(y),
    ),
    refreshInterval: obj.refreshInterval,
    secretStoreRef: toJson_ExternalSecretV1Beta1SpecSecretStoreRef(
      obj.secretStoreRef,
    ),
    target: toJson_ExternalSecretV1Beta1SpecTarget(obj.target),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ExternalSecretData defines the connection between the Kubernetes Secret key (spec.data.<key>) and the Provider data.
 *
 * @schema ExternalSecretV1Beta1SpecData
 */
export interface ExternalSecretV1Beta1SpecData {
  /**
   * RemoteRef points to the remote secret and defines which secret (version/property/..) to fetch.
   *
   * @schema ExternalSecretV1Beta1SpecData#remoteRef
   */
  readonly remoteRef: ExternalSecretV1Beta1SpecDataRemoteRef;

  /**
   * SecretKey defines the key in which the controller stores the value. This is the key in the Kind=Secret
   *
   * @schema ExternalSecretV1Beta1SpecData#secretKey
   */
  readonly secretKey: string;

  /**
   * SourceRef allows you to override the source from which the value will pulled from.
   *
   * @schema ExternalSecretV1Beta1SpecData#sourceRef
   */
  readonly sourceRef?: ExternalSecretV1Beta1SpecDataSourceRef;
}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecData' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretV1Beta1SpecData(
  obj: ExternalSecretV1Beta1SpecData | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    remoteRef: toJson_ExternalSecretV1Beta1SpecDataRemoteRef(obj.remoteRef),
    secretKey: obj.secretKey,
    sourceRef: toJson_ExternalSecretV1Beta1SpecDataSourceRef(obj.sourceRef),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ExternalSecretV1Beta1SpecDataFrom
 */
export interface ExternalSecretV1Beta1SpecDataFrom {
  /**
   * Used to extract multiple key/value pairs from one secret Note: Extract does not support sourceRef.Generator or sourceRef.GeneratorRef.
   *
   * @schema ExternalSecretV1Beta1SpecDataFrom#extract
   */
  readonly extract?: ExternalSecretV1Beta1SpecDataFromExtract;

  /**
   * Used to find secrets based on tags or regular expressions Note: Find does not support sourceRef.Generator or sourceRef.GeneratorRef.
   *
   * @schema ExternalSecretV1Beta1SpecDataFrom#find
   */
  readonly find?: ExternalSecretV1Beta1SpecDataFromFind;

  /**
   * Used to rewrite secret Keys after getting them from the secret Provider Multiple Rewrite operations can be provided. They are applied in a layered order (first to last)
   *
   * @schema ExternalSecretV1Beta1SpecDataFrom#rewrite
   */
  readonly rewrite?: ExternalSecretV1Beta1SpecDataFromRewrite[];

  /**
   * SourceRef points to a store or generator which contains secret values ready to use. Use this in combination with Extract or Find pull values out of a specific SecretStore. When sourceRef points to a generator Extract or Find is not supported. The generator returns a static map of values
   *
   * @schema ExternalSecretV1Beta1SpecDataFrom#sourceRef
   */
  readonly sourceRef?: ExternalSecretV1Beta1SpecDataFromSourceRef;
}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecDataFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretV1Beta1SpecDataFrom(
  obj: ExternalSecretV1Beta1SpecDataFrom | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    extract: toJson_ExternalSecretV1Beta1SpecDataFromExtract(obj.extract),
    find: toJson_ExternalSecretV1Beta1SpecDataFromFind(obj.find),
    rewrite: obj.rewrite?.map((y) =>
      toJson_ExternalSecretV1Beta1SpecDataFromRewrite(y),
    ),
    sourceRef: toJson_ExternalSecretV1Beta1SpecDataFromSourceRef(obj.sourceRef),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.
 *
 * @schema ExternalSecretV1Beta1SpecSecretStoreRef
 */
export interface ExternalSecretV1Beta1SpecSecretStoreRef {
  /**
   * Kind of the SecretStore resource (SecretStore or ClusterSecretStore) Defaults to `SecretStore`
   *
   * @default SecretStore`
   * @schema ExternalSecretV1Beta1SpecSecretStoreRef#kind
   */
  readonly kind?: string;

  /**
   * Name of the SecretStore resource
   *
   * @schema ExternalSecretV1Beta1SpecSecretStoreRef#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecSecretStoreRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretV1Beta1SpecSecretStoreRef(
  obj: ExternalSecretV1Beta1SpecSecretStoreRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    kind: obj.kind,
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ExternalSecretTarget defines the Kubernetes Secret to be created There can be only one target per ExternalSecret.
 *
 * @schema ExternalSecretV1Beta1SpecTarget
 */
export interface ExternalSecretV1Beta1SpecTarget {
  /**
   * CreationPolicy defines rules on how to create the resulting Secret Defaults to 'Owner'
   *
   * @default Owner'
   * @schema ExternalSecretV1Beta1SpecTarget#creationPolicy
   */
  readonly creationPolicy?: ExternalSecretV1Beta1SpecTargetCreationPolicy;

  /**
   * DeletionPolicy defines rules on how to delete the resulting Secret Defaults to 'Retain'
   *
   * @default Retain'
   * @schema ExternalSecretV1Beta1SpecTarget#deletionPolicy
   */
  readonly deletionPolicy?: ExternalSecretV1Beta1SpecTargetDeletionPolicy;

  /**
   * Immutable defines if the final secret will be immutable
   *
   * @schema ExternalSecretV1Beta1SpecTarget#immutable
   */
  readonly immutable?: boolean;

  /**
   * Name defines the name of the Secret resource to be managed This field is immutable Defaults to the .metadata.name of the ExternalSecret resource
   *
   * @default the .metadata.name of the ExternalSecret resource
   * @schema ExternalSecretV1Beta1SpecTarget#name
   */
  readonly name?: string;

  /**
   * Template defines a blueprint for the created Secret resource.
   *
   * @schema ExternalSecretV1Beta1SpecTarget#template
   */
  readonly template?: ExternalSecretV1Beta1SpecTargetTemplate;
}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecTarget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretV1Beta1SpecTarget(
  obj: ExternalSecretV1Beta1SpecTarget | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    creationPolicy: obj.creationPolicy,
    deletionPolicy: obj.deletionPolicy,
    immutable: obj.immutable,
    name: obj.name,
    template: toJson_ExternalSecretV1Beta1SpecTargetTemplate(obj.template),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * RemoteRef points to the remote secret and defines which secret (version/property/..) to fetch.
 *
 * @schema ExternalSecretV1Beta1SpecDataRemoteRef
 */
export interface ExternalSecretV1Beta1SpecDataRemoteRef {
  /**
   * Used to define a conversion Strategy
   *
   * @schema ExternalSecretV1Beta1SpecDataRemoteRef#conversionStrategy
   */
  readonly conversionStrategy?: ExternalSecretV1Beta1SpecDataRemoteRefConversionStrategy;

  /**
   * Used to define a decoding Strategy
   *
   * @schema ExternalSecretV1Beta1SpecDataRemoteRef#decodingStrategy
   */
  readonly decodingStrategy?: ExternalSecretV1Beta1SpecDataRemoteRefDecodingStrategy;

  /**
   * Key is the key used in the Provider, mandatory
   *
   * @schema ExternalSecretV1Beta1SpecDataRemoteRef#key
   */
  readonly key: string;

  /**
   * Policy for fetching tags/labels from provider secrets, possible options are Fetch, None. Defaults to None
   *
   * @default None
   * @schema ExternalSecretV1Beta1SpecDataRemoteRef#metadataPolicy
   */
  readonly metadataPolicy?: ExternalSecretV1Beta1SpecDataRemoteRefMetadataPolicy;

  /**
   * Used to select a specific property of the Provider value (if a map), if supported
   *
   * @schema ExternalSecretV1Beta1SpecDataRemoteRef#property
   */
  readonly property?: string;

  /**
   * Used to select a specific version of the Provider value, if supported
   *
   * @schema ExternalSecretV1Beta1SpecDataRemoteRef#version
   */
  readonly version?: string;
}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecDataRemoteRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretV1Beta1SpecDataRemoteRef(
  obj: ExternalSecretV1Beta1SpecDataRemoteRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    conversionStrategy: obj.conversionStrategy,
    decodingStrategy: obj.decodingStrategy,
    key: obj.key,
    metadataPolicy: obj.metadataPolicy,
    property: obj.property,
    version: obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * SourceRef allows you to override the source from which the value will pulled from.
 *
 * @schema ExternalSecretV1Beta1SpecDataSourceRef
 */
export interface ExternalSecretV1Beta1SpecDataSourceRef {
  /**
   * GeneratorRef points to a generator custom resource.
   * Deprecated: The generatorRef is not implemented in .data[]. this will be removed with v1.
   *
   * @schema ExternalSecretV1Beta1SpecDataSourceRef#generatorRef
   */
  readonly generatorRef?: ExternalSecretV1Beta1SpecDataSourceRefGeneratorRef;

  /**
   * SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.
   *
   * @schema ExternalSecretV1Beta1SpecDataSourceRef#storeRef
   */
  readonly storeRef?: ExternalSecretV1Beta1SpecDataSourceRefStoreRef;
}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretV1Beta1SpecDataSourceRef(
  obj: ExternalSecretV1Beta1SpecDataSourceRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    generatorRef: toJson_ExternalSecretV1Beta1SpecDataSourceRefGeneratorRef(
      obj.generatorRef,
    ),
    storeRef: toJson_ExternalSecretV1Beta1SpecDataSourceRefStoreRef(
      obj.storeRef,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Used to extract multiple key/value pairs from one secret Note: Extract does not support sourceRef.Generator or sourceRef.GeneratorRef.
 *
 * @schema ExternalSecretV1Beta1SpecDataFromExtract
 */
export interface ExternalSecretV1Beta1SpecDataFromExtract {
  /**
   * Used to define a conversion Strategy
   *
   * @schema ExternalSecretV1Beta1SpecDataFromExtract#conversionStrategy
   */
  readonly conversionStrategy?: ExternalSecretV1Beta1SpecDataFromExtractConversionStrategy;

  /**
   * Used to define a decoding Strategy
   *
   * @schema ExternalSecretV1Beta1SpecDataFromExtract#decodingStrategy
   */
  readonly decodingStrategy?: ExternalSecretV1Beta1SpecDataFromExtractDecodingStrategy;

  /**
   * Key is the key used in the Provider, mandatory
   *
   * @schema ExternalSecretV1Beta1SpecDataFromExtract#key
   */
  readonly key: string;

  /**
   * Policy for fetching tags/labels from provider secrets, possible options are Fetch, None. Defaults to None
   *
   * @default None
   * @schema ExternalSecretV1Beta1SpecDataFromExtract#metadataPolicy
   */
  readonly metadataPolicy?: ExternalSecretV1Beta1SpecDataFromExtractMetadataPolicy;

  /**
   * Used to select a specific property of the Provider value (if a map), if supported
   *
   * @schema ExternalSecretV1Beta1SpecDataFromExtract#property
   */
  readonly property?: string;

  /**
   * Used to select a specific version of the Provider value, if supported
   *
   * @schema ExternalSecretV1Beta1SpecDataFromExtract#version
   */
  readonly version?: string;
}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecDataFromExtract' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretV1Beta1SpecDataFromExtract(
  obj: ExternalSecretV1Beta1SpecDataFromExtract | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    conversionStrategy: obj.conversionStrategy,
    decodingStrategy: obj.decodingStrategy,
    key: obj.key,
    metadataPolicy: obj.metadataPolicy,
    property: obj.property,
    version: obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Used to find secrets based on tags or regular expressions Note: Find does not support sourceRef.Generator or sourceRef.GeneratorRef.
 *
 * @schema ExternalSecretV1Beta1SpecDataFromFind
 */
export interface ExternalSecretV1Beta1SpecDataFromFind {
  /**
   * Used to define a conversion Strategy
   *
   * @schema ExternalSecretV1Beta1SpecDataFromFind#conversionStrategy
   */
  readonly conversionStrategy?: ExternalSecretV1Beta1SpecDataFromFindConversionStrategy;

  /**
   * Used to define a decoding Strategy
   *
   * @schema ExternalSecretV1Beta1SpecDataFromFind#decodingStrategy
   */
  readonly decodingStrategy?: ExternalSecretV1Beta1SpecDataFromFindDecodingStrategy;

  /**
   * Finds secrets based on the name.
   *
   * @schema ExternalSecretV1Beta1SpecDataFromFind#name
   */
  readonly name?: ExternalSecretV1Beta1SpecDataFromFindName;

  /**
   * A root path to start the find operations.
   *
   * @schema ExternalSecretV1Beta1SpecDataFromFind#path
   */
  readonly path?: string;

  /**
   * Find secrets based on tags.
   *
   * @schema ExternalSecretV1Beta1SpecDataFromFind#tags
   */
  readonly tags?: { [key: string]: string };
}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecDataFromFind' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretV1Beta1SpecDataFromFind(
  obj: ExternalSecretV1Beta1SpecDataFromFind | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    conversionStrategy: obj.conversionStrategy,
    decodingStrategy: obj.decodingStrategy,
    name: toJson_ExternalSecretV1Beta1SpecDataFromFindName(obj.name),
    path: obj.path,
    tags:
      obj.tags === undefined
        ? undefined
        : Object.entries(obj.tags).reduce(
            (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
            {},
          ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ExternalSecretV1Beta1SpecDataFromRewrite
 */
export interface ExternalSecretV1Beta1SpecDataFromRewrite {
  /**
   * Used to rewrite with regular expressions. The resulting key will be the output of a regexp.ReplaceAll operation.
   *
   * @schema ExternalSecretV1Beta1SpecDataFromRewrite#regexp
   */
  readonly regexp?: ExternalSecretV1Beta1SpecDataFromRewriteRegexp;

  /**
   * Used to apply string transformation on the secrets. The resulting key will be the output of the template applied by the operation.
   *
   * @schema ExternalSecretV1Beta1SpecDataFromRewrite#transform
   */
  readonly transform?: ExternalSecretV1Beta1SpecDataFromRewriteTransform;
}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecDataFromRewrite' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretV1Beta1SpecDataFromRewrite(
  obj: ExternalSecretV1Beta1SpecDataFromRewrite | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    regexp: toJson_ExternalSecretV1Beta1SpecDataFromRewriteRegexp(obj.regexp),
    transform: toJson_ExternalSecretV1Beta1SpecDataFromRewriteTransform(
      obj.transform,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * SourceRef points to a store or generator which contains secret values ready to use. Use this in combination with Extract or Find pull values out of a specific SecretStore. When sourceRef points to a generator Extract or Find is not supported. The generator returns a static map of values
 *
 * @schema ExternalSecretV1Beta1SpecDataFromSourceRef
 */
export interface ExternalSecretV1Beta1SpecDataFromSourceRef {
  /**
   * GeneratorRef points to a generator custom resource.
   *
   * @schema ExternalSecretV1Beta1SpecDataFromSourceRef#generatorRef
   */
  readonly generatorRef?: ExternalSecretV1Beta1SpecDataFromSourceRefGeneratorRef;

  /**
   * SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.
   *
   * @schema ExternalSecretV1Beta1SpecDataFromSourceRef#storeRef
   */
  readonly storeRef?: ExternalSecretV1Beta1SpecDataFromSourceRefStoreRef;
}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecDataFromSourceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretV1Beta1SpecDataFromSourceRef(
  obj: ExternalSecretV1Beta1SpecDataFromSourceRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    generatorRef: toJson_ExternalSecretV1Beta1SpecDataFromSourceRefGeneratorRef(
      obj.generatorRef,
    ),
    storeRef: toJson_ExternalSecretV1Beta1SpecDataFromSourceRefStoreRef(
      obj.storeRef,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * CreationPolicy defines rules on how to create the resulting Secret Defaults to 'Owner'
 *
 * @default Owner'
 * @schema ExternalSecretV1Beta1SpecTargetCreationPolicy
 */
export enum ExternalSecretV1Beta1SpecTargetCreationPolicy {
  /** Owner */
  OWNER = "Owner",
  /** Orphan */
  ORPHAN = "Orphan",
  /** Merge */
  MERGE = "Merge",
  /** None */
  NONE = "None",
}

/**
 * DeletionPolicy defines rules on how to delete the resulting Secret Defaults to 'Retain'
 *
 * @default Retain'
 * @schema ExternalSecretV1Beta1SpecTargetDeletionPolicy
 */
export enum ExternalSecretV1Beta1SpecTargetDeletionPolicy {
  /** Delete */
  DELETE = "Delete",
  /** Merge */
  MERGE = "Merge",
  /** Retain */
  RETAIN = "Retain",
}

/**
 * Template defines a blueprint for the created Secret resource.
 *
 * @schema ExternalSecretV1Beta1SpecTargetTemplate
 */
export interface ExternalSecretV1Beta1SpecTargetTemplate {
  /**
   * @schema ExternalSecretV1Beta1SpecTargetTemplate#data
   */
  readonly data?: { [key: string]: string };

  /**
   * EngineVersion specifies the template engine version that should be used to compile/execute the template specified in .data and .templateFrom[].
   *
   * @schema ExternalSecretV1Beta1SpecTargetTemplate#engineVersion
   */
  readonly engineVersion?: ExternalSecretV1Beta1SpecTargetTemplateEngineVersion;

  /**
   * @schema ExternalSecretV1Beta1SpecTargetTemplate#mergePolicy
   */
  readonly mergePolicy?: ExternalSecretV1Beta1SpecTargetTemplateMergePolicy;

  /**
   * ExternalSecretTemplateMetadata defines metadata fields for the Secret blueprint.
   *
   * @schema ExternalSecretV1Beta1SpecTargetTemplate#metadata
   */
  readonly metadata?: ExternalSecretV1Beta1SpecTargetTemplateMetadata;

  /**
   * @schema ExternalSecretV1Beta1SpecTargetTemplate#templateFrom
   */
  readonly templateFrom?: ExternalSecretV1Beta1SpecTargetTemplateTemplateFrom[];

  /**
   * @schema ExternalSecretV1Beta1SpecTargetTemplate#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecTargetTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretV1Beta1SpecTargetTemplate(
  obj: ExternalSecretV1Beta1SpecTargetTemplate | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    data:
      obj.data === undefined
        ? undefined
        : Object.entries(obj.data).reduce(
            (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
            {},
          ),
    engineVersion: obj.engineVersion,
    mergePolicy: obj.mergePolicy,
    metadata: toJson_ExternalSecretV1Beta1SpecTargetTemplateMetadata(
      obj.metadata,
    ),
    templateFrom: obj.templateFrom?.map((y) =>
      toJson_ExternalSecretV1Beta1SpecTargetTemplateTemplateFrom(y),
    ),
    type: obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Used to define a conversion Strategy
 *
 * @schema ExternalSecretV1Beta1SpecDataRemoteRefConversionStrategy
 */
export enum ExternalSecretV1Beta1SpecDataRemoteRefConversionStrategy {
  /** Default */
  DEFAULT = "Default",
  /** Unicode */
  UNICODE = "Unicode",
}

/**
 * Used to define a decoding Strategy
 *
 * @schema ExternalSecretV1Beta1SpecDataRemoteRefDecodingStrategy
 */
export enum ExternalSecretV1Beta1SpecDataRemoteRefDecodingStrategy {
  /** Auto */
  AUTO = "Auto",
  /** Base64 */
  BASE64 = "Base64",
  /** Base64URL */
  BASE64_URL = "Base64URL",
  /** None */
  NONE = "None",
}

/**
 * Policy for fetching tags/labels from provider secrets, possible options are Fetch, None. Defaults to None
 *
 * @default None
 * @schema ExternalSecretV1Beta1SpecDataRemoteRefMetadataPolicy
 */
export enum ExternalSecretV1Beta1SpecDataRemoteRefMetadataPolicy {
  /** None */
  NONE = "None",
  /** Fetch */
  FETCH = "Fetch",
}

/**
 * GeneratorRef points to a generator custom resource.
 * Deprecated: The generatorRef is not implemented in .data[]. this will be removed with v1.
 *
 * @schema ExternalSecretV1Beta1SpecDataSourceRefGeneratorRef
 */
export interface ExternalSecretV1Beta1SpecDataSourceRefGeneratorRef {
  /**
   * Specify the apiVersion of the generator resource
   *
   * @schema ExternalSecretV1Beta1SpecDataSourceRefGeneratorRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Specify the Kind of the resource, e.g. Password, ACRAccessToken etc.
   *
   * @schema ExternalSecretV1Beta1SpecDataSourceRefGeneratorRef#kind
   */
  readonly kind: string;

  /**
   * Specify the name of the generator resource
   *
   * @schema ExternalSecretV1Beta1SpecDataSourceRefGeneratorRef#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecDataSourceRefGeneratorRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretV1Beta1SpecDataSourceRefGeneratorRef(
  obj: ExternalSecretV1Beta1SpecDataSourceRefGeneratorRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    apiVersion: obj.apiVersion,
    kind: obj.kind,
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.
 *
 * @schema ExternalSecretV1Beta1SpecDataSourceRefStoreRef
 */
export interface ExternalSecretV1Beta1SpecDataSourceRefStoreRef {
  /**
   * Kind of the SecretStore resource (SecretStore or ClusterSecretStore) Defaults to `SecretStore`
   *
   * @default SecretStore`
   * @schema ExternalSecretV1Beta1SpecDataSourceRefStoreRef#kind
   */
  readonly kind?: string;

  /**
   * Name of the SecretStore resource
   *
   * @schema ExternalSecretV1Beta1SpecDataSourceRefStoreRef#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecDataSourceRefStoreRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretV1Beta1SpecDataSourceRefStoreRef(
  obj: ExternalSecretV1Beta1SpecDataSourceRefStoreRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    kind: obj.kind,
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Used to define a conversion Strategy
 *
 * @schema ExternalSecretV1Beta1SpecDataFromExtractConversionStrategy
 */
export enum ExternalSecretV1Beta1SpecDataFromExtractConversionStrategy {
  /** Default */
  DEFAULT = "Default",
  /** Unicode */
  UNICODE = "Unicode",
}

/**
 * Used to define a decoding Strategy
 *
 * @schema ExternalSecretV1Beta1SpecDataFromExtractDecodingStrategy
 */
export enum ExternalSecretV1Beta1SpecDataFromExtractDecodingStrategy {
  /** Auto */
  AUTO = "Auto",
  /** Base64 */
  BASE64 = "Base64",
  /** Base64URL */
  BASE64_URL = "Base64URL",
  /** None */
  NONE = "None",
}

/**
 * Policy for fetching tags/labels from provider secrets, possible options are Fetch, None. Defaults to None
 *
 * @default None
 * @schema ExternalSecretV1Beta1SpecDataFromExtractMetadataPolicy
 */
export enum ExternalSecretV1Beta1SpecDataFromExtractMetadataPolicy {
  /** None */
  NONE = "None",
  /** Fetch */
  FETCH = "Fetch",
}

/**
 * Used to define a conversion Strategy
 *
 * @schema ExternalSecretV1Beta1SpecDataFromFindConversionStrategy
 */
export enum ExternalSecretV1Beta1SpecDataFromFindConversionStrategy {
  /** Default */
  DEFAULT = "Default",
  /** Unicode */
  UNICODE = "Unicode",
}

/**
 * Used to define a decoding Strategy
 *
 * @schema ExternalSecretV1Beta1SpecDataFromFindDecodingStrategy
 */
export enum ExternalSecretV1Beta1SpecDataFromFindDecodingStrategy {
  /** Auto */
  AUTO = "Auto",
  /** Base64 */
  BASE64 = "Base64",
  /** Base64URL */
  BASE64_URL = "Base64URL",
  /** None */
  NONE = "None",
}

/**
 * Finds secrets based on the name.
 *
 * @schema ExternalSecretV1Beta1SpecDataFromFindName
 */
export interface ExternalSecretV1Beta1SpecDataFromFindName {
  /**
   * Finds secrets base
   *
   * @schema ExternalSecretV1Beta1SpecDataFromFindName#regexp
   */
  readonly regexp?: string;
}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecDataFromFindName' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretV1Beta1SpecDataFromFindName(
  obj: ExternalSecretV1Beta1SpecDataFromFindName | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    regexp: obj.regexp,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Used to rewrite with regular expressions. The resulting key will be the output of a regexp.ReplaceAll operation.
 *
 * @schema ExternalSecretV1Beta1SpecDataFromRewriteRegexp
 */
export interface ExternalSecretV1Beta1SpecDataFromRewriteRegexp {
  /**
   * Used to define the regular expression of a re.Compiler.
   *
   * @schema ExternalSecretV1Beta1SpecDataFromRewriteRegexp#source
   */
  readonly source: string;

  /**
   * Used to define the target pattern of a ReplaceAll operation.
   *
   * @schema ExternalSecretV1Beta1SpecDataFromRewriteRegexp#target
   */
  readonly target: string;
}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecDataFromRewriteRegexp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretV1Beta1SpecDataFromRewriteRegexp(
  obj: ExternalSecretV1Beta1SpecDataFromRewriteRegexp | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    source: obj.source,
    target: obj.target,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Used to apply string transformation on the secrets. The resulting key will be the output of the template applied by the operation.
 *
 * @schema ExternalSecretV1Beta1SpecDataFromRewriteTransform
 */
export interface ExternalSecretV1Beta1SpecDataFromRewriteTransform {
  /**
   * Used to define the template to apply on the secret name. `.value ` will specify the secret name in the template.
   *
   * @schema ExternalSecretV1Beta1SpecDataFromRewriteTransform#template
   */
  readonly template: string;
}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecDataFromRewriteTransform' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretV1Beta1SpecDataFromRewriteTransform(
  obj: ExternalSecretV1Beta1SpecDataFromRewriteTransform | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    template: obj.template,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * GeneratorRef points to a generator custom resource.
 *
 * @schema ExternalSecretV1Beta1SpecDataFromSourceRefGeneratorRef
 */
export interface ExternalSecretV1Beta1SpecDataFromSourceRefGeneratorRef {
  /**
   * Specify the apiVersion of the generator resource
   *
   * @schema ExternalSecretV1Beta1SpecDataFromSourceRefGeneratorRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Specify the Kind of the resource, e.g. Password, ACRAccessToken etc.
   *
   * @schema ExternalSecretV1Beta1SpecDataFromSourceRefGeneratorRef#kind
   */
  readonly kind: string;

  /**
   * Specify the name of the generator resource
   *
   * @schema ExternalSecretV1Beta1SpecDataFromSourceRefGeneratorRef#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecDataFromSourceRefGeneratorRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretV1Beta1SpecDataFromSourceRefGeneratorRef(
  obj: ExternalSecretV1Beta1SpecDataFromSourceRefGeneratorRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    apiVersion: obj.apiVersion,
    kind: obj.kind,
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.
 *
 * @schema ExternalSecretV1Beta1SpecDataFromSourceRefStoreRef
 */
export interface ExternalSecretV1Beta1SpecDataFromSourceRefStoreRef {
  /**
   * Kind of the SecretStore resource (SecretStore or ClusterSecretStore) Defaults to `SecretStore`
   *
   * @default SecretStore`
   * @schema ExternalSecretV1Beta1SpecDataFromSourceRefStoreRef#kind
   */
  readonly kind?: string;

  /**
   * Name of the SecretStore resource
   *
   * @schema ExternalSecretV1Beta1SpecDataFromSourceRefStoreRef#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecDataFromSourceRefStoreRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretV1Beta1SpecDataFromSourceRefStoreRef(
  obj: ExternalSecretV1Beta1SpecDataFromSourceRefStoreRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    kind: obj.kind,
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * EngineVersion specifies the template engine version that should be used to compile/execute the template specified in .data and .templateFrom[].
 *
 * @schema ExternalSecretV1Beta1SpecTargetTemplateEngineVersion
 */
export enum ExternalSecretV1Beta1SpecTargetTemplateEngineVersion {
  /** v1 */
  V1 = "v1",
  /** v2 */
  V2 = "v2",
}

/**
 * @schema ExternalSecretV1Beta1SpecTargetTemplateMergePolicy
 */
export enum ExternalSecretV1Beta1SpecTargetTemplateMergePolicy {
  /** Replace */
  REPLACE = "Replace",
  /** Merge */
  MERGE = "Merge",
}

/**
 * ExternalSecretTemplateMetadata defines metadata fields for the Secret blueprint.
 *
 * @schema ExternalSecretV1Beta1SpecTargetTemplateMetadata
 */
export interface ExternalSecretV1Beta1SpecTargetTemplateMetadata {
  /**
   * @schema ExternalSecretV1Beta1SpecTargetTemplateMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * @schema ExternalSecretV1Beta1SpecTargetTemplateMetadata#labels
   */
  readonly labels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecTargetTemplateMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretV1Beta1SpecTargetTemplateMetadata(
  obj: ExternalSecretV1Beta1SpecTargetTemplateMetadata | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    annotations:
      obj.annotations === undefined
        ? undefined
        : Object.entries(obj.annotations).reduce(
            (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
            {},
          ),
    labels:
      obj.labels === undefined
        ? undefined
        : Object.entries(obj.labels).reduce(
            (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
            {},
          ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ExternalSecretV1Beta1SpecTargetTemplateTemplateFrom
 */
export interface ExternalSecretV1Beta1SpecTargetTemplateTemplateFrom {
  /**
   * @schema ExternalSecretV1Beta1SpecTargetTemplateTemplateFrom#configMap
   */
  readonly configMap?: ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMap;

  /**
   * @schema ExternalSecretV1Beta1SpecTargetTemplateTemplateFrom#literal
   */
  readonly literal?: string;

  /**
   * @schema ExternalSecretV1Beta1SpecTargetTemplateTemplateFrom#secret
   */
  readonly secret?: ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecret;

  /**
   * @schema ExternalSecretV1Beta1SpecTargetTemplateTemplateFrom#target
   */
  readonly target?: ExternalSecretV1Beta1SpecTargetTemplateTemplateFromTarget;
}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecTargetTemplateTemplateFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretV1Beta1SpecTargetTemplateTemplateFrom(
  obj: ExternalSecretV1Beta1SpecTargetTemplateTemplateFrom | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    configMap:
      toJson_ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMap(
        obj.configMap,
      ),
    literal: obj.literal,
    secret: toJson_ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecret(
      obj.secret,
    ),
    target: obj.target,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMap
 */
export interface ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMap {
  /**
   * @schema ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMap#items
   */
  readonly items: ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMapItems[];

  /**
   * @schema ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMap#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMap(
  obj: ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMap | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    items: obj.items?.map((y) =>
      toJson_ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMapItems(
        y,
      ),
    ),
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecret
 */
export interface ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecret {
  /**
   * @schema ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecret#items
   */
  readonly items: ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecretItems[];

  /**
   * @schema ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecret#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecret(
  obj: ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    items: obj.items?.map((y) =>
      toJson_ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecretItems(y),
    ),
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ExternalSecretV1Beta1SpecTargetTemplateTemplateFromTarget
 */
export enum ExternalSecretV1Beta1SpecTargetTemplateTemplateFromTarget {
  /** Data */
  DATA = "Data",
  /** Annotations */
  ANNOTATIONS = "Annotations",
  /** Labels */
  LABELS = "Labels",
}

/**
 * @schema ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMapItems
 */
export interface ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMapItems {
  /**
   * @schema ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMapItems#key
   */
  readonly key: string;

  /**
   * @schema ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMapItems#templateAs
   */
  readonly templateAs?: ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMapItemsTemplateAs;
}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMapItems(
  obj:
    | ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMapItems
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    templateAs: obj.templateAs,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecretItems
 */
export interface ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecretItems {
  /**
   * @schema ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecretItems#key
   */
  readonly key: string;

  /**
   * @schema ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecretItems#templateAs
   */
  readonly templateAs?: ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecretItemsTemplateAs;
}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecretItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecretItems(
  obj:
    | ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecretItems
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    templateAs: obj.templateAs,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMapItemsTemplateAs
 */
export enum ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMapItemsTemplateAs {
  /** Values */
  VALUES = "Values",
  /** KeysAndValues */
  KEYS_AND_VALUES = "KeysAndValues",
}

/**
 * @schema ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecretItemsTemplateAs
 */
export enum ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecretItemsTemplateAs {
  /** Values */
  VALUES = "Values",
  /** KeysAndValues */
  KEYS_AND_VALUES = "KeysAndValues",
}

/**
 *
 *
 * @schema PushSecret
 */
export class PushSecret extends ApiObject {
  /**
   * Returns the apiVersion and kind for "PushSecret"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "external-secrets.io/v1alpha1",
    kind: "PushSecret",
  };

  /**
   * Renders a Kubernetes manifest for "PushSecret".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: PushSecretProps = {}): any {
    return {
      ...PushSecret.GVK,
      ...toJson_PushSecretProps(props),
    };
  }

  /**
   * Defines a "PushSecret" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(
    scope: Construct,
    id: string,
    props: PushSecretProps = {},
  ) {
    super(scope, id, {
      ...PushSecret.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...PushSecret.GVK,
      ...toJson_PushSecretProps(resolved),
    };
  }
}

/**
 * @schema PushSecret
 */
export interface PushSecretProps {
  /**
   * @schema PushSecret#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * PushSecretSpec configures the behavior of the PushSecret.
   *
   * @schema PushSecret#spec
   */
  readonly spec?: PushSecretSpec;
}

/**
 * Converts an object of type 'PushSecretProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PushSecretProps(
  obj: PushSecretProps | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    spec: toJson_PushSecretSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * PushSecretSpec configures the behavior of the PushSecret.
 *
 * @schema PushSecretSpec
 */
export interface PushSecretSpec {
  /**
   * Secret Data that should be pushed to providers
   *
   * @schema PushSecretSpec#data
   */
  readonly data?: PushSecretSpecData[];

  /**
   * Deletion Policy to handle Secrets in the provider. Possible Values: "Delete/None". Defaults to "None".
   *
   * @default None".
   * @schema PushSecretSpec#deletionPolicy
   */
  readonly deletionPolicy?: PushSecretSpecDeletionPolicy;

  /**
   * The Interval to which External Secrets will try to push a secret definition
   *
   * @schema PushSecretSpec#refreshInterval
   */
  readonly refreshInterval?: string;

  /**
   * @schema PushSecretSpec#secretStoreRefs
   */
  readonly secretStoreRefs: PushSecretSpecSecretStoreRefs[];

  /**
   * The Secret Selector (k8s source) for the Push Secret
   *
   * @schema PushSecretSpec#selector
   */
  readonly selector: PushSecretSpecSelector;

  /**
   * Template defines a blueprint for the created Secret resource.
   *
   * @schema PushSecretSpec#template
   */
  readonly template?: PushSecretSpecTemplate;
}

/**
 * Converts an object of type 'PushSecretSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PushSecretSpec(
  obj: PushSecretSpec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    data: obj.data?.map((y) => toJson_PushSecretSpecData(y)),
    deletionPolicy: obj.deletionPolicy,
    refreshInterval: obj.refreshInterval,
    secretStoreRefs: obj.secretStoreRefs?.map((y) =>
      toJson_PushSecretSpecSecretStoreRefs(y),
    ),
    selector: toJson_PushSecretSpecSelector(obj.selector),
    template: toJson_PushSecretSpecTemplate(obj.template),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PushSecretSpecData
 */
export interface PushSecretSpecData {
  /**
   * Match a given Secret Key to be pushed to the provider.
   *
   * @schema PushSecretSpecData#match
   */
  readonly match: PushSecretSpecDataMatch;

  /**
   * Metadata is metadata attached to the secret. The structure of metadata is provider specific, please look it up in the provider documentation.
   *
   * @schema PushSecretSpecData#metadata
   */
  readonly metadata?: any;
}

/**
 * Converts an object of type 'PushSecretSpecData' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PushSecretSpecData(
  obj: PushSecretSpecData | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    match: toJson_PushSecretSpecDataMatch(obj.match),
    metadata: obj.metadata,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Deletion Policy to handle Secrets in the provider. Possible Values: "Delete/None". Defaults to "None".
 *
 * @default None".
 * @schema PushSecretSpecDeletionPolicy
 */
export enum PushSecretSpecDeletionPolicy {
  /** Delete */
  DELETE = "Delete",
  /** None */
  NONE = "None",
}

/**
 * @schema PushSecretSpecSecretStoreRefs
 */
export interface PushSecretSpecSecretStoreRefs {
  /**
   * Kind of the SecretStore resource (SecretStore or ClusterSecretStore) Defaults to `SecretStore`
   *
   * @default SecretStore`
   * @schema PushSecretSpecSecretStoreRefs#kind
   */
  readonly kind?: string;

  /**
   * Optionally, sync to secret stores with label selector
   *
   * @schema PushSecretSpecSecretStoreRefs#labelSelector
   */
  readonly labelSelector?: PushSecretSpecSecretStoreRefsLabelSelector;

  /**
   * Optionally, sync to the SecretStore of the given name
   *
   * @schema PushSecretSpecSecretStoreRefs#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'PushSecretSpecSecretStoreRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PushSecretSpecSecretStoreRefs(
  obj: PushSecretSpecSecretStoreRefs | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    kind: obj.kind,
    labelSelector: toJson_PushSecretSpecSecretStoreRefsLabelSelector(
      obj.labelSelector,
    ),
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The Secret Selector (k8s source) for the Push Secret
 *
 * @schema PushSecretSpecSelector
 */
export interface PushSecretSpecSelector {
  /**
   * Select a Secret to Push.
   *
   * @schema PushSecretSpecSelector#secret
   */
  readonly secret: PushSecretSpecSelectorSecret;
}

/**
 * Converts an object of type 'PushSecretSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PushSecretSpecSelector(
  obj: PushSecretSpecSelector | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    secret: toJson_PushSecretSpecSelectorSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Template defines a blueprint for the created Secret resource.
 *
 * @schema PushSecretSpecTemplate
 */
export interface PushSecretSpecTemplate {
  /**
   * @schema PushSecretSpecTemplate#data
   */
  readonly data?: { [key: string]: string };

  /**
   * EngineVersion specifies the template engine version that should be used to compile/execute the template specified in .data and .templateFrom[].
   *
   * @schema PushSecretSpecTemplate#engineVersion
   */
  readonly engineVersion?: PushSecretSpecTemplateEngineVersion;

  /**
   * @schema PushSecretSpecTemplate#mergePolicy
   */
  readonly mergePolicy?: PushSecretSpecTemplateMergePolicy;

  /**
   * ExternalSecretTemplateMetadata defines metadata fields for the Secret blueprint.
   *
   * @schema PushSecretSpecTemplate#metadata
   */
  readonly metadata?: PushSecretSpecTemplateMetadata;

  /**
   * @schema PushSecretSpecTemplate#templateFrom
   */
  readonly templateFrom?: PushSecretSpecTemplateTemplateFrom[];

  /**
   * @schema PushSecretSpecTemplate#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'PushSecretSpecTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PushSecretSpecTemplate(
  obj: PushSecretSpecTemplate | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    data:
      obj.data === undefined
        ? undefined
        : Object.entries(obj.data).reduce(
            (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
            {},
          ),
    engineVersion: obj.engineVersion,
    mergePolicy: obj.mergePolicy,
    metadata: toJson_PushSecretSpecTemplateMetadata(obj.metadata),
    templateFrom: obj.templateFrom?.map((y) =>
      toJson_PushSecretSpecTemplateTemplateFrom(y),
    ),
    type: obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Match a given Secret Key to be pushed to the provider.
 *
 * @schema PushSecretSpecDataMatch
 */
export interface PushSecretSpecDataMatch {
  /**
   * Remote Refs to push to providers.
   *
   * @schema PushSecretSpecDataMatch#remoteRef
   */
  readonly remoteRef: PushSecretSpecDataMatchRemoteRef;

  /**
   * Secret Key to be pushed
   *
   * @schema PushSecretSpecDataMatch#secretKey
   */
  readonly secretKey?: string;
}

/**
 * Converts an object of type 'PushSecretSpecDataMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PushSecretSpecDataMatch(
  obj: PushSecretSpecDataMatch | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    remoteRef: toJson_PushSecretSpecDataMatchRemoteRef(obj.remoteRef),
    secretKey: obj.secretKey,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Optionally, sync to secret stores with label selector
 *
 * @schema PushSecretSpecSecretStoreRefsLabelSelector
 */
export interface PushSecretSpecSecretStoreRefsLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PushSecretSpecSecretStoreRefsLabelSelector#matchExpressions
   */
  readonly matchExpressions?: PushSecretSpecSecretStoreRefsLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PushSecretSpecSecretStoreRefsLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'PushSecretSpecSecretStoreRefsLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PushSecretSpecSecretStoreRefsLabelSelector(
  obj: PushSecretSpecSecretStoreRefsLabelSelector | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) =>
      toJson_PushSecretSpecSecretStoreRefsLabelSelectorMatchExpressions(y),
    ),
    matchLabels:
      obj.matchLabels === undefined
        ? undefined
        : Object.entries(obj.matchLabels).reduce(
            (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
            {},
          ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Select a Secret to Push.
 *
 * @schema PushSecretSpecSelectorSecret
 */
export interface PushSecretSpecSelectorSecret {
  /**
   * Name of the Secret. The Secret must exist in the same namespace as the PushSecret manifest.
   *
   * @schema PushSecretSpecSelectorSecret#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'PushSecretSpecSelectorSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PushSecretSpecSelectorSecret(
  obj: PushSecretSpecSelectorSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * EngineVersion specifies the template engine version that should be used to compile/execute the template specified in .data and .templateFrom[].
 *
 * @schema PushSecretSpecTemplateEngineVersion
 */
export enum PushSecretSpecTemplateEngineVersion {
  /** v1 */
  V1 = "v1",
  /** v2 */
  V2 = "v2",
}

/**
 * @schema PushSecretSpecTemplateMergePolicy
 */
export enum PushSecretSpecTemplateMergePolicy {
  /** Replace */
  REPLACE = "Replace",
  /** Merge */
  MERGE = "Merge",
}

/**
 * ExternalSecretTemplateMetadata defines metadata fields for the Secret blueprint.
 *
 * @schema PushSecretSpecTemplateMetadata
 */
export interface PushSecretSpecTemplateMetadata {
  /**
   * @schema PushSecretSpecTemplateMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * @schema PushSecretSpecTemplateMetadata#labels
   */
  readonly labels?: { [key: string]: string };
}

/**
 * Converts an object of type 'PushSecretSpecTemplateMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PushSecretSpecTemplateMetadata(
  obj: PushSecretSpecTemplateMetadata | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    annotations:
      obj.annotations === undefined
        ? undefined
        : Object.entries(obj.annotations).reduce(
            (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
            {},
          ),
    labels:
      obj.labels === undefined
        ? undefined
        : Object.entries(obj.labels).reduce(
            (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
            {},
          ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PushSecretSpecTemplateTemplateFrom
 */
export interface PushSecretSpecTemplateTemplateFrom {
  /**
   * @schema PushSecretSpecTemplateTemplateFrom#configMap
   */
  readonly configMap?: PushSecretSpecTemplateTemplateFromConfigMap;

  /**
   * @schema PushSecretSpecTemplateTemplateFrom#literal
   */
  readonly literal?: string;

  /**
   * @schema PushSecretSpecTemplateTemplateFrom#secret
   */
  readonly secret?: PushSecretSpecTemplateTemplateFromSecret;

  /**
   * @schema PushSecretSpecTemplateTemplateFrom#target
   */
  readonly target?: PushSecretSpecTemplateTemplateFromTarget;
}

/**
 * Converts an object of type 'PushSecretSpecTemplateTemplateFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PushSecretSpecTemplateTemplateFrom(
  obj: PushSecretSpecTemplateTemplateFrom | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    configMap: toJson_PushSecretSpecTemplateTemplateFromConfigMap(
      obj.configMap,
    ),
    literal: obj.literal,
    secret: toJson_PushSecretSpecTemplateTemplateFromSecret(obj.secret),
    target: obj.target,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Remote Refs to push to providers.
 *
 * @schema PushSecretSpecDataMatchRemoteRef
 */
export interface PushSecretSpecDataMatchRemoteRef {
  /**
   * Name of the property in the resulting secret
   *
   * @schema PushSecretSpecDataMatchRemoteRef#property
   */
  readonly property?: string;

  /**
   * Name of the resulting provider secret.
   *
   * @schema PushSecretSpecDataMatchRemoteRef#remoteKey
   */
  readonly remoteKey: string;
}

/**
 * Converts an object of type 'PushSecretSpecDataMatchRemoteRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PushSecretSpecDataMatchRemoteRef(
  obj: PushSecretSpecDataMatchRemoteRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    property: obj.property,
    remoteKey: obj.remoteKey,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PushSecretSpecSecretStoreRefsLabelSelectorMatchExpressions
 */
export interface PushSecretSpecSecretStoreRefsLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PushSecretSpecSecretStoreRefsLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PushSecretSpecSecretStoreRefsLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema PushSecretSpecSecretStoreRefsLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'PushSecretSpecSecretStoreRefsLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PushSecretSpecSecretStoreRefsLabelSelectorMatchExpressions(
  obj: PushSecretSpecSecretStoreRefsLabelSelectorMatchExpressions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PushSecretSpecTemplateTemplateFromConfigMap
 */
export interface PushSecretSpecTemplateTemplateFromConfigMap {
  /**
   * @schema PushSecretSpecTemplateTemplateFromConfigMap#items
   */
  readonly items: PushSecretSpecTemplateTemplateFromConfigMapItems[];

  /**
   * @schema PushSecretSpecTemplateTemplateFromConfigMap#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'PushSecretSpecTemplateTemplateFromConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PushSecretSpecTemplateTemplateFromConfigMap(
  obj: PushSecretSpecTemplateTemplateFromConfigMap | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    items: obj.items?.map((y) =>
      toJson_PushSecretSpecTemplateTemplateFromConfigMapItems(y),
    ),
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PushSecretSpecTemplateTemplateFromSecret
 */
export interface PushSecretSpecTemplateTemplateFromSecret {
  /**
   * @schema PushSecretSpecTemplateTemplateFromSecret#items
   */
  readonly items: PushSecretSpecTemplateTemplateFromSecretItems[];

  /**
   * @schema PushSecretSpecTemplateTemplateFromSecret#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'PushSecretSpecTemplateTemplateFromSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PushSecretSpecTemplateTemplateFromSecret(
  obj: PushSecretSpecTemplateTemplateFromSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    items: obj.items?.map((y) =>
      toJson_PushSecretSpecTemplateTemplateFromSecretItems(y),
    ),
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PushSecretSpecTemplateTemplateFromTarget
 */
export enum PushSecretSpecTemplateTemplateFromTarget {
  /** Data */
  DATA = "Data",
  /** Annotations */
  ANNOTATIONS = "Annotations",
  /** Labels */
  LABELS = "Labels",
}

/**
 * @schema PushSecretSpecTemplateTemplateFromConfigMapItems
 */
export interface PushSecretSpecTemplateTemplateFromConfigMapItems {
  /**
   * @schema PushSecretSpecTemplateTemplateFromConfigMapItems#key
   */
  readonly key: string;

  /**
   * @schema PushSecretSpecTemplateTemplateFromConfigMapItems#templateAs
   */
  readonly templateAs?: PushSecretSpecTemplateTemplateFromConfigMapItemsTemplateAs;
}

/**
 * Converts an object of type 'PushSecretSpecTemplateTemplateFromConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PushSecretSpecTemplateTemplateFromConfigMapItems(
  obj: PushSecretSpecTemplateTemplateFromConfigMapItems | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    templateAs: obj.templateAs,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PushSecretSpecTemplateTemplateFromSecretItems
 */
export interface PushSecretSpecTemplateTemplateFromSecretItems {
  /**
   * @schema PushSecretSpecTemplateTemplateFromSecretItems#key
   */
  readonly key: string;

  /**
   * @schema PushSecretSpecTemplateTemplateFromSecretItems#templateAs
   */
  readonly templateAs?: PushSecretSpecTemplateTemplateFromSecretItemsTemplateAs;
}

/**
 * Converts an object of type 'PushSecretSpecTemplateTemplateFromSecretItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PushSecretSpecTemplateTemplateFromSecretItems(
  obj: PushSecretSpecTemplateTemplateFromSecretItems | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    templateAs: obj.templateAs,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PushSecretSpecTemplateTemplateFromConfigMapItemsTemplateAs
 */
export enum PushSecretSpecTemplateTemplateFromConfigMapItemsTemplateAs {
  /** Values */
  VALUES = "Values",
  /** KeysAndValues */
  KEYS_AND_VALUES = "KeysAndValues",
}

/**
 * @schema PushSecretSpecTemplateTemplateFromSecretItemsTemplateAs
 */
export enum PushSecretSpecTemplateTemplateFromSecretItemsTemplateAs {
  /** Values */
  VALUES = "Values",
  /** KeysAndValues */
  KEYS_AND_VALUES = "KeysAndValues",
}

/**
 * SecretStore represents a secure external location for storing secrets, which can be referenced as part of `storeRef` fields.
 *
 * @schema SecretStore
 */
export class SecretStore extends ApiObject {
  /**
   * Returns the apiVersion and kind for "SecretStore"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "external-secrets.io/v1alpha1",
    kind: "SecretStore",
  };

  /**
   * Renders a Kubernetes manifest for "SecretStore".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SecretStoreProps = {}): any {
    return {
      ...SecretStore.GVK,
      ...toJson_SecretStoreProps(props),
    };
  }

  /**
   * Defines a "SecretStore" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(
    scope: Construct,
    id: string,
    props: SecretStoreProps = {},
  ) {
    super(scope, id, {
      ...SecretStore.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...SecretStore.GVK,
      ...toJson_SecretStoreProps(resolved),
    };
  }
}

/**
 * SecretStore represents a secure external location for storing secrets, which can be referenced as part of `storeRef` fields.
 *
 * @schema SecretStore
 */
export interface SecretStoreProps {
  /**
   * @schema SecretStore#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * SecretStoreSpec defines the desired state of SecretStore.
   *
   * @schema SecretStore#spec
   */
  readonly spec?: SecretStoreSpec;
}

/**
 * Converts an object of type 'SecretStoreProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreProps(
  obj: SecretStoreProps | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    spec: toJson_SecretStoreSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreSpec defines the desired state of SecretStore.
 *
 * @schema SecretStoreSpec
 */
export interface SecretStoreSpec {
  /**
   * Used to select the correct ESO controller (think: ingress.ingressClassName) The ESO controller is instantiated with a specific controller name and filters ES based on this property
   *
   * @schema SecretStoreSpec#controller
   */
  readonly controller?: string;

  /**
   * Used to configure the provider. Only one provider may be set
   *
   * @schema SecretStoreSpec#provider
   */
  readonly provider: SecretStoreSpecProvider;

  /**
   * Used to configure http retries if failed
   *
   * @schema SecretStoreSpec#retrySettings
   */
  readonly retrySettings?: SecretStoreSpecRetrySettings;
}

/**
 * Converts an object of type 'SecretStoreSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpec(
  obj: SecretStoreSpec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    controller: obj.controller,
    provider: toJson_SecretStoreSpecProvider(obj.provider),
    retrySettings: toJson_SecretStoreSpecRetrySettings(obj.retrySettings),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Used to configure the provider. Only one provider may be set
 *
 * @schema SecretStoreSpecProvider
 */
export interface SecretStoreSpecProvider {
  /**
   * Akeyless configures this store to sync secrets using Akeyless Vault provider
   *
   * @schema SecretStoreSpecProvider#akeyless
   */
  readonly akeyless?: SecretStoreSpecProviderAkeyless;

  /**
   * Alibaba configures this store to sync secrets using Alibaba Cloud provider
   *
   * @schema SecretStoreSpecProvider#alibaba
   */
  readonly alibaba?: SecretStoreSpecProviderAlibaba;

  /**
   * AWS configures this store to sync secrets using AWS Secret Manager provider
   *
   * @schema SecretStoreSpecProvider#aws
   */
  readonly aws?: SecretStoreSpecProviderAws;

  /**
   * AzureKV configures this store to sync secrets using Azure Key Vault provider
   *
   * @schema SecretStoreSpecProvider#azurekv
   */
  readonly azurekv?: SecretStoreSpecProviderAzurekv;

  /**
   * Fake configures a store with static key/value pairs
   *
   * @schema SecretStoreSpecProvider#fake
   */
  readonly fake?: SecretStoreSpecProviderFake;

  /**
   * GCPSM configures this store to sync secrets using Google Cloud Platform Secret Manager provider
   *
   * @schema SecretStoreSpecProvider#gcpsm
   */
  readonly gcpsm?: SecretStoreSpecProviderGcpsm;

  /**
   * GitLab configures this store to sync secrets using GitLab Variables provider
   *
   * @schema SecretStoreSpecProvider#gitlab
   */
  readonly gitlab?: SecretStoreSpecProviderGitlab;

  /**
   * IBM configures this store to sync secrets using IBM Cloud provider
   *
   * @schema SecretStoreSpecProvider#ibm
   */
  readonly ibm?: SecretStoreSpecProviderIbm;

  /**
   * Kubernetes configures this store to sync secrets using a Kubernetes cluster provider
   *
   * @schema SecretStoreSpecProvider#kubernetes
   */
  readonly kubernetes?: SecretStoreSpecProviderKubernetes;

  /**
   * Oracle configures this store to sync secrets using Oracle Vault provider
   *
   * @schema SecretStoreSpecProvider#oracle
   */
  readonly oracle?: SecretStoreSpecProviderOracle;

  /**
   * Vault configures this store to sync secrets using Hashi provider
   *
   * @schema SecretStoreSpecProvider#vault
   */
  readonly vault?: SecretStoreSpecProviderVault;

  /**
   * Webhook configures this store to sync secrets using a generic templated webhook
   *
   * @schema SecretStoreSpecProvider#webhook
   */
  readonly webhook?: SecretStoreSpecProviderWebhook;

  /**
   * YandexLockbox configures this store to sync secrets using Yandex Lockbox provider
   *
   * @schema SecretStoreSpecProvider#yandexlockbox
   */
  readonly yandexlockbox?: SecretStoreSpecProviderYandexlockbox;
}

/**
 * Converts an object of type 'SecretStoreSpecProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProvider(
  obj: SecretStoreSpecProvider | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    akeyless: toJson_SecretStoreSpecProviderAkeyless(obj.akeyless),
    alibaba: toJson_SecretStoreSpecProviderAlibaba(obj.alibaba),
    aws: toJson_SecretStoreSpecProviderAws(obj.aws),
    azurekv: toJson_SecretStoreSpecProviderAzurekv(obj.azurekv),
    fake: toJson_SecretStoreSpecProviderFake(obj.fake),
    gcpsm: toJson_SecretStoreSpecProviderGcpsm(obj.gcpsm),
    gitlab: toJson_SecretStoreSpecProviderGitlab(obj.gitlab),
    ibm: toJson_SecretStoreSpecProviderIbm(obj.ibm),
    kubernetes: toJson_SecretStoreSpecProviderKubernetes(obj.kubernetes),
    oracle: toJson_SecretStoreSpecProviderOracle(obj.oracle),
    vault: toJson_SecretStoreSpecProviderVault(obj.vault),
    webhook: toJson_SecretStoreSpecProviderWebhook(obj.webhook),
    yandexlockbox: toJson_SecretStoreSpecProviderYandexlockbox(
      obj.yandexlockbox,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Used to configure http retries if failed
 *
 * @schema SecretStoreSpecRetrySettings
 */
export interface SecretStoreSpecRetrySettings {
  /**
   * @schema SecretStoreSpecRetrySettings#maxRetries
   */
  readonly maxRetries?: number;

  /**
   * @schema SecretStoreSpecRetrySettings#retryInterval
   */
  readonly retryInterval?: string;
}

/**
 * Converts an object of type 'SecretStoreSpecRetrySettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecRetrySettings(
  obj: SecretStoreSpecRetrySettings | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    maxRetries: obj.maxRetries,
    retryInterval: obj.retryInterval,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Akeyless configures this store to sync secrets using Akeyless Vault provider
 *
 * @schema SecretStoreSpecProviderAkeyless
 */
export interface SecretStoreSpecProviderAkeyless {
  /**
   * Akeyless GW API Url from which the secrets to be fetched from.
   *
   * @schema SecretStoreSpecProviderAkeyless#akeylessGWApiURL
   */
  readonly akeylessGwApiUrl: string;

  /**
   * Auth configures how the operator authenticates with Akeyless.
   *
   * @schema SecretStoreSpecProviderAkeyless#authSecretRef
   */
  readonly authSecretRef: SecretStoreSpecProviderAkeylessAuthSecretRef;

  /**
   * PEM/base64 encoded CA bundle used to validate Akeyless Gateway certificate. Only used if the AkeylessGWApiURL URL is using HTTPS protocol. If not set the system root certificates are used to validate the TLS connection.
   *
   * @schema SecretStoreSpecProviderAkeyless#caBundle
   */
  readonly caBundle?: string;

  /**
   * The provider for the CA bundle to use to validate Akeyless Gateway certificate.
   *
   * @schema SecretStoreSpecProviderAkeyless#caProvider
   */
  readonly caProvider?: SecretStoreSpecProviderAkeylessCaProvider;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderAkeyless' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderAkeyless(
  obj: SecretStoreSpecProviderAkeyless | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    akeylessGWApiURL: obj.akeylessGwApiUrl,
    authSecretRef: toJson_SecretStoreSpecProviderAkeylessAuthSecretRef(
      obj.authSecretRef,
    ),
    caBundle: obj.caBundle,
    caProvider: toJson_SecretStoreSpecProviderAkeylessCaProvider(
      obj.caProvider,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Alibaba configures this store to sync secrets using Alibaba Cloud provider
 *
 * @schema SecretStoreSpecProviderAlibaba
 */
export interface SecretStoreSpecProviderAlibaba {
  /**
   * AlibabaAuth contains a secretRef for credentials.
   *
   * @schema SecretStoreSpecProviderAlibaba#auth
   */
  readonly auth: SecretStoreSpecProviderAlibabaAuth;

  /**
   * Alibaba Region to be used for the provider
   *
   * @schema SecretStoreSpecProviderAlibaba#regionID
   */
  readonly regionId: string;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderAlibaba' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderAlibaba(
  obj: SecretStoreSpecProviderAlibaba | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    auth: toJson_SecretStoreSpecProviderAlibabaAuth(obj.auth),
    regionID: obj.regionId,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * AWS configures this store to sync secrets using AWS Secret Manager provider
 *
 * @schema SecretStoreSpecProviderAws
 */
export interface SecretStoreSpecProviderAws {
  /**
   * Auth defines the information necessary to authenticate against AWS if not set aws sdk will infer credentials from your environment see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
   *
   * @schema SecretStoreSpecProviderAws#auth
   */
  readonly auth?: SecretStoreSpecProviderAwsAuth;

  /**
   * AWS Region to be used for the provider
   *
   * @schema SecretStoreSpecProviderAws#region
   */
  readonly region: string;

  /**
   * Role is a Role ARN which the SecretManager provider will assume
   *
   * @schema SecretStoreSpecProviderAws#role
   */
  readonly role?: string;

  /**
   * Service defines which service should be used to fetch the secrets
   *
   * @schema SecretStoreSpecProviderAws#service
   */
  readonly service: SecretStoreSpecProviderAwsService;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderAws' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderAws(
  obj: SecretStoreSpecProviderAws | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    auth: toJson_SecretStoreSpecProviderAwsAuth(obj.auth),
    region: obj.region,
    role: obj.role,
    service: obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * AzureKV configures this store to sync secrets using Azure Key Vault provider
 *
 * @schema SecretStoreSpecProviderAzurekv
 */
export interface SecretStoreSpecProviderAzurekv {
  /**
   * Auth configures how the operator authenticates with Azure. Required for ServicePrincipal auth type.
   *
   * @schema SecretStoreSpecProviderAzurekv#authSecretRef
   */
  readonly authSecretRef?: SecretStoreSpecProviderAzurekvAuthSecretRef;

  /**
   * Auth type defines how to authenticate to the keyvault service. Valid values are: - "ServicePrincipal" (default): Using a service principal (tenantId, clientId, clientSecret) - "ManagedIdentity": Using Managed Identity assigned to the pod (see aad-pod-identity)
   *
   * @schema SecretStoreSpecProviderAzurekv#authType
   */
  readonly authType?: SecretStoreSpecProviderAzurekvAuthType;

  /**
   * If multiple Managed Identity is assigned to the pod, you can select the one to be used
   *
   * @schema SecretStoreSpecProviderAzurekv#identityId
   */
  readonly identityId?: string;

  /**
   * ServiceAccountRef specified the service account that should be used when authenticating with WorkloadIdentity.
   *
   * @schema SecretStoreSpecProviderAzurekv#serviceAccountRef
   */
  readonly serviceAccountRef?: SecretStoreSpecProviderAzurekvServiceAccountRef;

  /**
   * TenantID configures the Azure Tenant to send requests to. Required for ServicePrincipal auth type.
   *
   * @schema SecretStoreSpecProviderAzurekv#tenantId
   */
  readonly tenantId?: string;

  /**
   * Vault Url from which the secrets to be fetched from.
   *
   * @schema SecretStoreSpecProviderAzurekv#vaultUrl
   */
  readonly vaultUrl: string;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderAzurekv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderAzurekv(
  obj: SecretStoreSpecProviderAzurekv | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    authSecretRef: toJson_SecretStoreSpecProviderAzurekvAuthSecretRef(
      obj.authSecretRef,
    ),
    authType: obj.authType,
    identityId: obj.identityId,
    serviceAccountRef: toJson_SecretStoreSpecProviderAzurekvServiceAccountRef(
      obj.serviceAccountRef,
    ),
    tenantId: obj.tenantId,
    vaultUrl: obj.vaultUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Fake configures a store with static key/value pairs
 *
 * @schema SecretStoreSpecProviderFake
 */
export interface SecretStoreSpecProviderFake {
  /**
   * @schema SecretStoreSpecProviderFake#data
   */
  readonly data: SecretStoreSpecProviderFakeData[];
}

/**
 * Converts an object of type 'SecretStoreSpecProviderFake' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderFake(
  obj: SecretStoreSpecProviderFake | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    data: obj.data?.map((y) => toJson_SecretStoreSpecProviderFakeData(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * GCPSM configures this store to sync secrets using Google Cloud Platform Secret Manager provider
 *
 * @schema SecretStoreSpecProviderGcpsm
 */
export interface SecretStoreSpecProviderGcpsm {
  /**
   * Auth defines the information necessary to authenticate against GCP
   *
   * @schema SecretStoreSpecProviderGcpsm#auth
   */
  readonly auth?: SecretStoreSpecProviderGcpsmAuth;

  /**
   * ProjectID project where secret is located
   *
   * @schema SecretStoreSpecProviderGcpsm#projectID
   */
  readonly projectId?: string;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderGcpsm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderGcpsm(
  obj: SecretStoreSpecProviderGcpsm | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    auth: toJson_SecretStoreSpecProviderGcpsmAuth(obj.auth),
    projectID: obj.projectId,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * GitLab configures this store to sync secrets using GitLab Variables provider
 *
 * @schema SecretStoreSpecProviderGitlab
 */
export interface SecretStoreSpecProviderGitlab {
  /**
   * Auth configures how secret-manager authenticates with a GitLab instance.
   *
   * @schema SecretStoreSpecProviderGitlab#auth
   */
  readonly auth: SecretStoreSpecProviderGitlabAuth;

  /**
   * ProjectID specifies a project where secrets are located.
   *
   * @schema SecretStoreSpecProviderGitlab#projectID
   */
  readonly projectId?: string;

  /**
   * URL configures the GitLab instance URL. Defaults to https://gitlab.com/.
   *
   * @default https://gitlab.com/.
   * @schema SecretStoreSpecProviderGitlab#url
   */
  readonly url?: string;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderGitlab' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderGitlab(
  obj: SecretStoreSpecProviderGitlab | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    auth: toJson_SecretStoreSpecProviderGitlabAuth(obj.auth),
    projectID: obj.projectId,
    url: obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * IBM configures this store to sync secrets using IBM Cloud provider
 *
 * @schema SecretStoreSpecProviderIbm
 */
export interface SecretStoreSpecProviderIbm {
  /**
   * Auth configures how secret-manager authenticates with the IBM secrets manager.
   *
   * @schema SecretStoreSpecProviderIbm#auth
   */
  readonly auth: SecretStoreSpecProviderIbmAuth;

  /**
   * ServiceURL is the Endpoint URL that is specific to the Secrets Manager service instance
   *
   * @schema SecretStoreSpecProviderIbm#serviceUrl
   */
  readonly serviceUrl?: string;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderIbm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderIbm(
  obj: SecretStoreSpecProviderIbm | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    auth: toJson_SecretStoreSpecProviderIbmAuth(obj.auth),
    serviceUrl: obj.serviceUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Kubernetes configures this store to sync secrets using a Kubernetes cluster provider
 *
 * @schema SecretStoreSpecProviderKubernetes
 */
export interface SecretStoreSpecProviderKubernetes {
  /**
   * Auth configures how secret-manager authenticates with a Kubernetes instance.
   *
   * @schema SecretStoreSpecProviderKubernetes#auth
   */
  readonly auth: SecretStoreSpecProviderKubernetesAuth;

  /**
   * Remote namespace to fetch the secrets from
   *
   * @schema SecretStoreSpecProviderKubernetes#remoteNamespace
   */
  readonly remoteNamespace?: string;

  /**
   * configures the Kubernetes server Address.
   *
   * @schema SecretStoreSpecProviderKubernetes#server
   */
  readonly server?: SecretStoreSpecProviderKubernetesServer;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderKubernetes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderKubernetes(
  obj: SecretStoreSpecProviderKubernetes | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    auth: toJson_SecretStoreSpecProviderKubernetesAuth(obj.auth),
    remoteNamespace: obj.remoteNamespace,
    server: toJson_SecretStoreSpecProviderKubernetesServer(obj.server),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Oracle configures this store to sync secrets using Oracle Vault provider
 *
 * @schema SecretStoreSpecProviderOracle
 */
export interface SecretStoreSpecProviderOracle {
  /**
   * Auth configures how secret-manager authenticates with the Oracle Vault. If empty, instance principal is used. Optionally, the authenticating principal type and/or user data may be supplied for the use of workload identity and user principal.
   *
   * @schema SecretStoreSpecProviderOracle#auth
   */
  readonly auth?: SecretStoreSpecProviderOracleAuth;

  /**
   * Compartment is the vault compartment OCID. Required for PushSecret
   *
   * @schema SecretStoreSpecProviderOracle#compartment
   */
  readonly compartment?: string;

  /**
   * EncryptionKey is the OCID of the encryption key within the vault. Required for PushSecret
   *
   * @schema SecretStoreSpecProviderOracle#encryptionKey
   */
  readonly encryptionKey?: string;

  /**
   * The type of principal to use for authentication. If left blank, the Auth struct will determine the principal type. This optional field must be specified if using workload identity.
   *
   * @schema SecretStoreSpecProviderOracle#principalType
   */
  readonly principalType?: SecretStoreSpecProviderOraclePrincipalType;

  /**
   * Region is the region where vault is located.
   *
   * @schema SecretStoreSpecProviderOracle#region
   */
  readonly region: string;

  /**
   * ServiceAccountRef specified the service account that should be used when authenticating with WorkloadIdentity.
   *
   * @schema SecretStoreSpecProviderOracle#serviceAccountRef
   */
  readonly serviceAccountRef?: SecretStoreSpecProviderOracleServiceAccountRef;

  /**
   * Vault is the vault's OCID of the specific vault where secret is located.
   *
   * @schema SecretStoreSpecProviderOracle#vault
   */
  readonly vault: string;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderOracle' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderOracle(
  obj: SecretStoreSpecProviderOracle | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    auth: toJson_SecretStoreSpecProviderOracleAuth(obj.auth),
    compartment: obj.compartment,
    encryptionKey: obj.encryptionKey,
    principalType: obj.principalType,
    region: obj.region,
    serviceAccountRef: toJson_SecretStoreSpecProviderOracleServiceAccountRef(
      obj.serviceAccountRef,
    ),
    vault: obj.vault,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Vault configures this store to sync secrets using Hashi provider
 *
 * @schema SecretStoreSpecProviderVault
 */
export interface SecretStoreSpecProviderVault {
  /**
   * Auth configures how secret-manager authenticates with the Vault server.
   *
   * @schema SecretStoreSpecProviderVault#auth
   */
  readonly auth: SecretStoreSpecProviderVaultAuth;

  /**
   * PEM encoded CA bundle used to validate Vault server certificate. Only used if the Server URL is using HTTPS protocol. This parameter is ignored for plain HTTP protocol connection. If not set the system root certificates are used to validate the TLS connection.
   *
   * @schema SecretStoreSpecProviderVault#caBundle
   */
  readonly caBundle?: string;

  /**
   * The provider for the CA bundle to use to validate Vault server certificate.
   *
   * @schema SecretStoreSpecProviderVault#caProvider
   */
  readonly caProvider?: SecretStoreSpecProviderVaultCaProvider;

  /**
   * ForwardInconsistent tells Vault to forward read-after-write requests to the Vault leader instead of simply retrying within a loop. This can increase performance if the option is enabled serverside. https://www.vaultproject.io/docs/configuration/replication#allow_forwarding_via_header
   *
   * @schema SecretStoreSpecProviderVault#forwardInconsistent
   */
  readonly forwardInconsistent?: boolean;

  /**
   * Name of the vault namespace. Namespaces is a set of features within Vault Enterprise that allows Vault environments to support Secure Multi-tenancy. e.g: "ns1". More about namespaces can be found here https://www.vaultproject.io/docs/enterprise/namespaces
   *
   * @schema SecretStoreSpecProviderVault#namespace
   */
  readonly namespace?: string;

  /**
   * Path is the mount path of the Vault KV backend endpoint, e.g: "secret". The v2 KV secret engine version specific "/data" path suffix for fetching secrets from Vault is optional and will be appended if not present in specified path.
   *
   * @schema SecretStoreSpecProviderVault#path
   */
  readonly path?: string;

  /**
   * ReadYourWrites ensures isolated read-after-write semantics by providing discovered cluster replication states in each request. More information about eventual consistency in Vault can be found here https://www.vaultproject.io/docs/enterprise/consistency
   *
   * @schema SecretStoreSpecProviderVault#readYourWrites
   */
  readonly readYourWrites?: boolean;

  /**
   * Server is the connection address for the Vault server, e.g: "https://vault.example.com:8200".
   *
   * @schema SecretStoreSpecProviderVault#server
   */
  readonly server: string;

  /**
   * Version is the Vault KV secret engine version. This can be either "v1" or "v2". Version defaults to "v2".
   *
   * @schema SecretStoreSpecProviderVault#version
   */
  readonly version?: SecretStoreSpecProviderVaultVersion;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderVault' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderVault(
  obj: SecretStoreSpecProviderVault | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    auth: toJson_SecretStoreSpecProviderVaultAuth(obj.auth),
    caBundle: obj.caBundle,
    caProvider: toJson_SecretStoreSpecProviderVaultCaProvider(obj.caProvider),
    forwardInconsistent: obj.forwardInconsistent,
    namespace: obj.namespace,
    path: obj.path,
    readYourWrites: obj.readYourWrites,
    server: obj.server,
    version: obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Webhook configures this store to sync secrets using a generic templated webhook
 *
 * @schema SecretStoreSpecProviderWebhook
 */
export interface SecretStoreSpecProviderWebhook {
  /**
   * Body
   *
   * @schema SecretStoreSpecProviderWebhook#body
   */
  readonly body?: string;

  /**
   * PEM encoded CA bundle used to validate webhook server certificate. Only used if the Server URL is using HTTPS protocol. This parameter is ignored for plain HTTP protocol connection. If not set the system root certificates are used to validate the TLS connection.
   *
   * @schema SecretStoreSpecProviderWebhook#caBundle
   */
  readonly caBundle?: string;

  /**
   * The provider for the CA bundle to use to validate webhook server certificate.
   *
   * @schema SecretStoreSpecProviderWebhook#caProvider
   */
  readonly caProvider?: SecretStoreSpecProviderWebhookCaProvider;

  /**
   * Headers
   *
   * @schema SecretStoreSpecProviderWebhook#headers
   */
  readonly headers?: { [key: string]: string };

  /**
   * Webhook Method
   *
   * @schema SecretStoreSpecProviderWebhook#method
   */
  readonly method?: string;

  /**
   * Result formatting
   *
   * @schema SecretStoreSpecProviderWebhook#result
   */
  readonly result: SecretStoreSpecProviderWebhookResult;

  /**
   * Secrets to fill in templates These secrets will be passed to the templating function as key value pairs under the given name
   *
   * @schema SecretStoreSpecProviderWebhook#secrets
   */
  readonly secrets?: SecretStoreSpecProviderWebhookSecrets[];

  /**
   * Timeout
   *
   * @schema SecretStoreSpecProviderWebhook#timeout
   */
  readonly timeout?: string;

  /**
   * Webhook url to call
   *
   * @schema SecretStoreSpecProviderWebhook#url
   */
  readonly url: string;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderWebhook' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderWebhook(
  obj: SecretStoreSpecProviderWebhook | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    body: obj.body,
    caBundle: obj.caBundle,
    caProvider: toJson_SecretStoreSpecProviderWebhookCaProvider(obj.caProvider),
    headers:
      obj.headers === undefined
        ? undefined
        : Object.entries(obj.headers).reduce(
            (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
            {},
          ),
    method: obj.method,
    result: toJson_SecretStoreSpecProviderWebhookResult(obj.result),
    secrets: obj.secrets?.map((y) =>
      toJson_SecretStoreSpecProviderWebhookSecrets(y),
    ),
    timeout: obj.timeout,
    url: obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * YandexLockbox configures this store to sync secrets using Yandex Lockbox provider
 *
 * @schema SecretStoreSpecProviderYandexlockbox
 */
export interface SecretStoreSpecProviderYandexlockbox {
  /**
   * Yandex.Cloud API endpoint (e.g. 'api.cloud.yandex.net:443')
   *
   * @schema SecretStoreSpecProviderYandexlockbox#apiEndpoint
   */
  readonly apiEndpoint?: string;

  /**
   * Auth defines the information necessary to authenticate against Yandex Lockbox
   *
   * @schema SecretStoreSpecProviderYandexlockbox#auth
   */
  readonly auth: SecretStoreSpecProviderYandexlockboxAuth;

  /**
   * The provider for the CA bundle to use to validate Yandex.Cloud server certificate.
   *
   * @schema SecretStoreSpecProviderYandexlockbox#caProvider
   */
  readonly caProvider?: SecretStoreSpecProviderYandexlockboxCaProvider;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderYandexlockbox' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderYandexlockbox(
  obj: SecretStoreSpecProviderYandexlockbox | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    apiEndpoint: obj.apiEndpoint,
    auth: toJson_SecretStoreSpecProviderYandexlockboxAuth(obj.auth),
    caProvider: toJson_SecretStoreSpecProviderYandexlockboxCaProvider(
      obj.caProvider,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Auth configures how the operator authenticates with Akeyless.
 *
 * @schema SecretStoreSpecProviderAkeylessAuthSecretRef
 */
export interface SecretStoreSpecProviderAkeylessAuthSecretRef {
  /**
   * Kubernetes authenticates with Akeyless by passing the ServiceAccount token stored in the named Secret resource.
   *
   * @schema SecretStoreSpecProviderAkeylessAuthSecretRef#kubernetesAuth
   */
  readonly kubernetesAuth?: SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth;

  /**
   * Reference to a Secret that contains the details to authenticate with Akeyless.
   *
   * @schema SecretStoreSpecProviderAkeylessAuthSecretRef#secretRef
   */
  readonly secretRef?: SecretStoreSpecProviderAkeylessAuthSecretRefSecretRef;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderAkeylessAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderAkeylessAuthSecretRef(
  obj: SecretStoreSpecProviderAkeylessAuthSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    kubernetesAuth:
      toJson_SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth(
        obj.kubernetesAuth,
      ),
    secretRef: toJson_SecretStoreSpecProviderAkeylessAuthSecretRefSecretRef(
      obj.secretRef,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The provider for the CA bundle to use to validate Akeyless Gateway certificate.
 *
 * @schema SecretStoreSpecProviderAkeylessCaProvider
 */
export interface SecretStoreSpecProviderAkeylessCaProvider {
  /**
   * The key the value inside of the provider type to use, only used with "Secret" type
   *
   * @schema SecretStoreSpecProviderAkeylessCaProvider#key
   */
  readonly key?: string;

  /**
   * The name of the object located at the provider type.
   *
   * @schema SecretStoreSpecProviderAkeylessCaProvider#name
   */
  readonly name: string;

  /**
   * The namespace the Provider type is in.
   *
   * @schema SecretStoreSpecProviderAkeylessCaProvider#namespace
   */
  readonly namespace?: string;

  /**
   * The type of provider to use such as "Secret", or "ConfigMap".
   *
   * @schema SecretStoreSpecProviderAkeylessCaProvider#type
   */
  readonly type: SecretStoreSpecProviderAkeylessCaProviderType;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderAkeylessCaProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderAkeylessCaProvider(
  obj: SecretStoreSpecProviderAkeylessCaProvider | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
    type: obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * AlibabaAuth contains a secretRef for credentials.
 *
 * @schema SecretStoreSpecProviderAlibabaAuth
 */
export interface SecretStoreSpecProviderAlibabaAuth {
  /**
   * Authenticate against Alibaba using RRSA.
   *
   * @schema SecretStoreSpecProviderAlibabaAuth#rrsa
   */
  readonly rrsa?: SecretStoreSpecProviderAlibabaAuthRrsa;

  /**
   * AlibabaAuthSecretRef holds secret references for Alibaba credentials.
   *
   * @schema SecretStoreSpecProviderAlibabaAuth#secretRef
   */
  readonly secretRef?: SecretStoreSpecProviderAlibabaAuthSecretRef;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderAlibabaAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderAlibabaAuth(
  obj: SecretStoreSpecProviderAlibabaAuth | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    rrsa: toJson_SecretStoreSpecProviderAlibabaAuthRrsa(obj.rrsa),
    secretRef: toJson_SecretStoreSpecProviderAlibabaAuthSecretRef(
      obj.secretRef,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Auth defines the information necessary to authenticate against AWS if not set aws sdk will infer credentials from your environment see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
 *
 * @schema SecretStoreSpecProviderAwsAuth
 */
export interface SecretStoreSpecProviderAwsAuth {
  /**
   * Authenticate against AWS using service account tokens.
   *
   * @schema SecretStoreSpecProviderAwsAuth#jwt
   */
  readonly jwt?: SecretStoreSpecProviderAwsAuthJwt;

  /**
   * AWSAuthSecretRef holds secret references for AWS credentials both AccessKeyID and SecretAccessKey must be defined in order to properly authenticate.
   *
   * @schema SecretStoreSpecProviderAwsAuth#secretRef
   */
  readonly secretRef?: SecretStoreSpecProviderAwsAuthSecretRef;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderAwsAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderAwsAuth(
  obj: SecretStoreSpecProviderAwsAuth | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    jwt: toJson_SecretStoreSpecProviderAwsAuthJwt(obj.jwt),
    secretRef: toJson_SecretStoreSpecProviderAwsAuthSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Service defines which service should be used to fetch the secrets
 *
 * @schema SecretStoreSpecProviderAwsService
 */
export enum SecretStoreSpecProviderAwsService {
  /** SecretsManager */
  SECRETS_MANAGER = "SecretsManager",
  /** ParameterStore */
  PARAMETER_STORE = "ParameterStore",
}

/**
 * Auth configures how the operator authenticates with Azure. Required for ServicePrincipal auth type.
 *
 * @schema SecretStoreSpecProviderAzurekvAuthSecretRef
 */
export interface SecretStoreSpecProviderAzurekvAuthSecretRef {
  /**
   * The Azure clientId of the service principle used for authentication.
   *
   * @schema SecretStoreSpecProviderAzurekvAuthSecretRef#clientId
   */
  readonly clientId?: SecretStoreSpecProviderAzurekvAuthSecretRefClientId;

  /**
   * The Azure ClientSecret of the service principle used for authentication.
   *
   * @schema SecretStoreSpecProviderAzurekvAuthSecretRef#clientSecret
   */
  readonly clientSecret?: SecretStoreSpecProviderAzurekvAuthSecretRefClientSecret;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderAzurekvAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderAzurekvAuthSecretRef(
  obj: SecretStoreSpecProviderAzurekvAuthSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    clientId: toJson_SecretStoreSpecProviderAzurekvAuthSecretRefClientId(
      obj.clientId,
    ),
    clientSecret:
      toJson_SecretStoreSpecProviderAzurekvAuthSecretRefClientSecret(
        obj.clientSecret,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Auth type defines how to authenticate to the keyvault service. Valid values are: - "ServicePrincipal" (default): Using a service principal (tenantId, clientId, clientSecret) - "ManagedIdentity": Using Managed Identity assigned to the pod (see aad-pod-identity)
 *
 * @schema SecretStoreSpecProviderAzurekvAuthType
 */
export enum SecretStoreSpecProviderAzurekvAuthType {
  /** ServicePrincipal */
  SERVICE_PRINCIPAL = "ServicePrincipal",
  /** ManagedIdentity */
  MANAGED_IDENTITY = "ManagedIdentity",
  /** WorkloadIdentity */
  WORKLOAD_IDENTITY = "WorkloadIdentity",
}

/**
 * ServiceAccountRef specified the service account that should be used when authenticating with WorkloadIdentity.
 *
 * @schema SecretStoreSpecProviderAzurekvServiceAccountRef
 */
export interface SecretStoreSpecProviderAzurekvServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
   *
   * @schema SecretStoreSpecProviderAzurekvServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema SecretStoreSpecProviderAzurekvServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderAzurekvServiceAccountRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderAzurekvServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderAzurekvServiceAccountRef(
  obj: SecretStoreSpecProviderAzurekvServiceAccountRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    audiences: obj.audiences?.map((y) => y),
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SecretStoreSpecProviderFakeData
 */
export interface SecretStoreSpecProviderFakeData {
  /**
   * @schema SecretStoreSpecProviderFakeData#key
   */
  readonly key: string;

  /**
   * @schema SecretStoreSpecProviderFakeData#value
   */
  readonly value?: string;

  /**
   * @schema SecretStoreSpecProviderFakeData#valueMap
   */
  readonly valueMap?: { [key: string]: string };

  /**
   * @schema SecretStoreSpecProviderFakeData#version
   */
  readonly version?: string;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderFakeData' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderFakeData(
  obj: SecretStoreSpecProviderFakeData | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    value: obj.value,
    valueMap:
      obj.valueMap === undefined
        ? undefined
        : Object.entries(obj.valueMap).reduce(
            (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
            {},
          ),
    version: obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Auth defines the information necessary to authenticate against GCP
 *
 * @schema SecretStoreSpecProviderGcpsmAuth
 */
export interface SecretStoreSpecProviderGcpsmAuth {
  /**
   * @schema SecretStoreSpecProviderGcpsmAuth#secretRef
   */
  readonly secretRef?: SecretStoreSpecProviderGcpsmAuthSecretRef;

  /**
   * @schema SecretStoreSpecProviderGcpsmAuth#workloadIdentity
   */
  readonly workloadIdentity?: SecretStoreSpecProviderGcpsmAuthWorkloadIdentity;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderGcpsmAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderGcpsmAuth(
  obj: SecretStoreSpecProviderGcpsmAuth | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    secretRef: toJson_SecretStoreSpecProviderGcpsmAuthSecretRef(obj.secretRef),
    workloadIdentity: toJson_SecretStoreSpecProviderGcpsmAuthWorkloadIdentity(
      obj.workloadIdentity,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Auth configures how secret-manager authenticates with a GitLab instance.
 *
 * @schema SecretStoreSpecProviderGitlabAuth
 */
export interface SecretStoreSpecProviderGitlabAuth {
  /**
   * @schema SecretStoreSpecProviderGitlabAuth#SecretRef
   */
  readonly secretRef: SecretStoreSpecProviderGitlabAuthSecretRef;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderGitlabAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderGitlabAuth(
  obj: SecretStoreSpecProviderGitlabAuth | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    SecretRef: toJson_SecretStoreSpecProviderGitlabAuthSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Auth configures how secret-manager authenticates with the IBM secrets manager.
 *
 * @schema SecretStoreSpecProviderIbmAuth
 */
export interface SecretStoreSpecProviderIbmAuth {
  /**
   * @schema SecretStoreSpecProviderIbmAuth#secretRef
   */
  readonly secretRef: SecretStoreSpecProviderIbmAuthSecretRef;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderIbmAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderIbmAuth(
  obj: SecretStoreSpecProviderIbmAuth | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    secretRef: toJson_SecretStoreSpecProviderIbmAuthSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Auth configures how secret-manager authenticates with a Kubernetes instance.
 *
 * @schema SecretStoreSpecProviderKubernetesAuth
 */
export interface SecretStoreSpecProviderKubernetesAuth {
  /**
   * has both clientCert and clientKey as secretKeySelector
   *
   * @schema SecretStoreSpecProviderKubernetesAuth#cert
   */
  readonly cert?: SecretStoreSpecProviderKubernetesAuthCert;

  /**
   * points to a service account that should be used for authentication
   *
   * @schema SecretStoreSpecProviderKubernetesAuth#serviceAccount
   */
  readonly serviceAccount?: SecretStoreSpecProviderKubernetesAuthServiceAccount;

  /**
   * use static token to authenticate with
   *
   * @schema SecretStoreSpecProviderKubernetesAuth#token
   */
  readonly token?: SecretStoreSpecProviderKubernetesAuthToken;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderKubernetesAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderKubernetesAuth(
  obj: SecretStoreSpecProviderKubernetesAuth | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    cert: toJson_SecretStoreSpecProviderKubernetesAuthCert(obj.cert),
    serviceAccount: toJson_SecretStoreSpecProviderKubernetesAuthServiceAccount(
      obj.serviceAccount,
    ),
    token: toJson_SecretStoreSpecProviderKubernetesAuthToken(obj.token),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * configures the Kubernetes server Address.
 *
 * @schema SecretStoreSpecProviderKubernetesServer
 */
export interface SecretStoreSpecProviderKubernetesServer {
  /**
   * CABundle is a base64-encoded CA certificate
   *
   * @schema SecretStoreSpecProviderKubernetesServer#caBundle
   */
  readonly caBundle?: string;

  /**
   * see: https://external-secrets.io/v0.4.1/spec/#external-secrets.io/v1alpha1.CAProvider
   *
   * @schema SecretStoreSpecProviderKubernetesServer#caProvider
   */
  readonly caProvider?: SecretStoreSpecProviderKubernetesServerCaProvider;

  /**
   * configures the Kubernetes server Address.
   *
   * @schema SecretStoreSpecProviderKubernetesServer#url
   */
  readonly url?: string;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderKubernetesServer' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderKubernetesServer(
  obj: SecretStoreSpecProviderKubernetesServer | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    caBundle: obj.caBundle,
    caProvider: toJson_SecretStoreSpecProviderKubernetesServerCaProvider(
      obj.caProvider,
    ),
    url: obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Auth configures how secret-manager authenticates with the Oracle Vault. If empty, instance principal is used. Optionally, the authenticating principal type and/or user data may be supplied for the use of workload identity and user principal.
 *
 * @schema SecretStoreSpecProviderOracleAuth
 */
export interface SecretStoreSpecProviderOracleAuth {
  /**
   * SecretRef to pass through sensitive information.
   *
   * @schema SecretStoreSpecProviderOracleAuth#secretRef
   */
  readonly secretRef: SecretStoreSpecProviderOracleAuthSecretRef;

  /**
   * Tenancy is the tenancy OCID where user is located.
   *
   * @schema SecretStoreSpecProviderOracleAuth#tenancy
   */
  readonly tenancy: string;

  /**
   * User is an access OCID specific to the account.
   *
   * @schema SecretStoreSpecProviderOracleAuth#user
   */
  readonly user: string;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderOracleAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderOracleAuth(
  obj: SecretStoreSpecProviderOracleAuth | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    secretRef: toJson_SecretStoreSpecProviderOracleAuthSecretRef(obj.secretRef),
    tenancy: obj.tenancy,
    user: obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The type of principal to use for authentication. If left blank, the Auth struct will determine the principal type. This optional field must be specified if using workload identity.
 *
 * @schema SecretStoreSpecProviderOraclePrincipalType
 */
export enum SecretStoreSpecProviderOraclePrincipalType {
  /** UserPrincipal */
  USER_PRINCIPAL = "UserPrincipal",
  /** InstancePrincipal */
  INSTANCE_PRINCIPAL = "InstancePrincipal",
  /** Workload */
  WORKLOAD = "Workload",
}

/**
 * ServiceAccountRef specified the service account that should be used when authenticating with WorkloadIdentity.
 *
 * @schema SecretStoreSpecProviderOracleServiceAccountRef
 */
export interface SecretStoreSpecProviderOracleServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
   *
   * @schema SecretStoreSpecProviderOracleServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema SecretStoreSpecProviderOracleServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderOracleServiceAccountRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderOracleServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderOracleServiceAccountRef(
  obj: SecretStoreSpecProviderOracleServiceAccountRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    audiences: obj.audiences?.map((y) => y),
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Auth configures how secret-manager authenticates with the Vault server.
 *
 * @schema SecretStoreSpecProviderVaultAuth
 */
export interface SecretStoreSpecProviderVaultAuth {
  /**
   * AppRole authenticates with Vault using the App Role auth mechanism, with the role and secret stored in a Kubernetes Secret resource.
   *
   * @schema SecretStoreSpecProviderVaultAuth#appRole
   */
  readonly appRole?: SecretStoreSpecProviderVaultAuthAppRole;

  /**
   * Cert authenticates with TLS Certificates by passing client certificate, private key and ca certificate Cert authentication method
   *
   * @schema SecretStoreSpecProviderVaultAuth#cert
   */
  readonly cert?: SecretStoreSpecProviderVaultAuthCert;

  /**
   * Jwt authenticates with Vault by passing role and JWT token using the JWT/OIDC authentication method
   *
   * @schema SecretStoreSpecProviderVaultAuth#jwt
   */
  readonly jwt?: SecretStoreSpecProviderVaultAuthJwt;

  /**
   * Kubernetes authenticates with Vault by passing the ServiceAccount token stored in the named Secret resource to the Vault server.
   *
   * @schema SecretStoreSpecProviderVaultAuth#kubernetes
   */
  readonly kubernetes?: SecretStoreSpecProviderVaultAuthKubernetes;

  /**
   * Ldap authenticates with Vault by passing username/password pair using the LDAP authentication method
   *
   * @schema SecretStoreSpecProviderVaultAuth#ldap
   */
  readonly ldap?: SecretStoreSpecProviderVaultAuthLdap;

  /**
   * TokenSecretRef authenticates with Vault by presenting a token.
   *
   * @schema SecretStoreSpecProviderVaultAuth#tokenSecretRef
   */
  readonly tokenSecretRef?: SecretStoreSpecProviderVaultAuthTokenSecretRef;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderVaultAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderVaultAuth(
  obj: SecretStoreSpecProviderVaultAuth | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    appRole: toJson_SecretStoreSpecProviderVaultAuthAppRole(obj.appRole),
    cert: toJson_SecretStoreSpecProviderVaultAuthCert(obj.cert),
    jwt: toJson_SecretStoreSpecProviderVaultAuthJwt(obj.jwt),
    kubernetes: toJson_SecretStoreSpecProviderVaultAuthKubernetes(
      obj.kubernetes,
    ),
    ldap: toJson_SecretStoreSpecProviderVaultAuthLdap(obj.ldap),
    tokenSecretRef: toJson_SecretStoreSpecProviderVaultAuthTokenSecretRef(
      obj.tokenSecretRef,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The provider for the CA bundle to use to validate Vault server certificate.
 *
 * @schema SecretStoreSpecProviderVaultCaProvider
 */
export interface SecretStoreSpecProviderVaultCaProvider {
  /**
   * The key the value inside of the provider type to use, only used with "Secret" type
   *
   * @schema SecretStoreSpecProviderVaultCaProvider#key
   */
  readonly key?: string;

  /**
   * The name of the object located at the provider type.
   *
   * @schema SecretStoreSpecProviderVaultCaProvider#name
   */
  readonly name: string;

  /**
   * The namespace the Provider type is in.
   *
   * @schema SecretStoreSpecProviderVaultCaProvider#namespace
   */
  readonly namespace?: string;

  /**
   * The type of provider to use such as "Secret", or "ConfigMap".
   *
   * @schema SecretStoreSpecProviderVaultCaProvider#type
   */
  readonly type: SecretStoreSpecProviderVaultCaProviderType;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderVaultCaProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderVaultCaProvider(
  obj: SecretStoreSpecProviderVaultCaProvider | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
    type: obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Version is the Vault KV secret engine version. This can be either "v1" or "v2". Version defaults to "v2".
 *
 * @schema SecretStoreSpecProviderVaultVersion
 */
export enum SecretStoreSpecProviderVaultVersion {
  /** v1 */
  V1 = "v1",
  /** v2 */
  V2 = "v2",
}

/**
 * The provider for the CA bundle to use to validate webhook server certificate.
 *
 * @schema SecretStoreSpecProviderWebhookCaProvider
 */
export interface SecretStoreSpecProviderWebhookCaProvider {
  /**
   * The key the value inside of the provider type to use, only used with "Secret" type
   *
   * @schema SecretStoreSpecProviderWebhookCaProvider#key
   */
  readonly key?: string;

  /**
   * The name of the object located at the provider type.
   *
   * @schema SecretStoreSpecProviderWebhookCaProvider#name
   */
  readonly name: string;

  /**
   * The namespace the Provider type is in.
   *
   * @schema SecretStoreSpecProviderWebhookCaProvider#namespace
   */
  readonly namespace?: string;

  /**
   * The type of provider to use such as "Secret", or "ConfigMap".
   *
   * @schema SecretStoreSpecProviderWebhookCaProvider#type
   */
  readonly type: SecretStoreSpecProviderWebhookCaProviderType;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderWebhookCaProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderWebhookCaProvider(
  obj: SecretStoreSpecProviderWebhookCaProvider | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
    type: obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Result formatting
 *
 * @schema SecretStoreSpecProviderWebhookResult
 */
export interface SecretStoreSpecProviderWebhookResult {
  /**
   * Json path of return value
   *
   * @schema SecretStoreSpecProviderWebhookResult#jsonPath
   */
  readonly jsonPath?: string;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderWebhookResult' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderWebhookResult(
  obj: SecretStoreSpecProviderWebhookResult | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    jsonPath: obj.jsonPath,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SecretStoreSpecProviderWebhookSecrets
 */
export interface SecretStoreSpecProviderWebhookSecrets {
  /**
   * Name of this secret in templates
   *
   * @schema SecretStoreSpecProviderWebhookSecrets#name
   */
  readonly name: string;

  /**
   * Secret ref to fill in credentials
   *
   * @schema SecretStoreSpecProviderWebhookSecrets#secretRef
   */
  readonly secretRef: SecretStoreSpecProviderWebhookSecretsSecretRef;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderWebhookSecrets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderWebhookSecrets(
  obj: SecretStoreSpecProviderWebhookSecrets | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    secretRef: toJson_SecretStoreSpecProviderWebhookSecretsSecretRef(
      obj.secretRef,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Auth defines the information necessary to authenticate against Yandex Lockbox
 *
 * @schema SecretStoreSpecProviderYandexlockboxAuth
 */
export interface SecretStoreSpecProviderYandexlockboxAuth {
  /**
   * The authorized key used for authentication
   *
   * @schema SecretStoreSpecProviderYandexlockboxAuth#authorizedKeySecretRef
   */
  readonly authorizedKeySecretRef?: SecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderYandexlockboxAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderYandexlockboxAuth(
  obj: SecretStoreSpecProviderYandexlockboxAuth | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    authorizedKeySecretRef:
      toJson_SecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef(
        obj.authorizedKeySecretRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The provider for the CA bundle to use to validate Yandex.Cloud server certificate.
 *
 * @schema SecretStoreSpecProviderYandexlockboxCaProvider
 */
export interface SecretStoreSpecProviderYandexlockboxCaProvider {
  /**
   * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
   *
   * @schema SecretStoreSpecProviderYandexlockboxCaProvider#certSecretRef
   */
  readonly certSecretRef?: SecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderYandexlockboxCaProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderYandexlockboxCaProvider(
  obj: SecretStoreSpecProviderYandexlockboxCaProvider | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    certSecretRef:
      toJson_SecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef(
        obj.certSecretRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Kubernetes authenticates with Akeyless by passing the ServiceAccount token stored in the named Secret resource.
 *
 * @schema SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth
 */
export interface SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth {
  /**
   * the Akeyless Kubernetes auth-method access-id
   *
   * @schema SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth#accessID
   */
  readonly accessId: string;

  /**
   * Kubernetes-auth configuration name in Akeyless-Gateway
   *
   * @schema SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth#k8sConfName
   */
  readonly k8SConfName: string;

  /**
   * Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Akeyless. If a name is specified without a key, `token` is the default. If one is not specified, the one bound to the controller will be used.
   *
   * @schema SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth#secretRef
   */
  readonly secretRef?: SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef;

  /**
   * Optional service account field containing the name of a kubernetes ServiceAccount. If the service account is specified, the service account secret token JWT will be used for authenticating with Akeyless. If the service account selector is not supplied, the secretRef will be used instead.
   *
   * @schema SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth#serviceAccountRef
   */
  readonly serviceAccountRef?: SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth(
  obj: SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    accessID: obj.accessId,
    k8sConfName: obj.k8SConfName,
    secretRef:
      toJson_SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef(
        obj.secretRef,
      ),
    serviceAccountRef:
      toJson_SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef(
        obj.serviceAccountRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Secret that contains the details to authenticate with Akeyless.
 *
 * @schema SecretStoreSpecProviderAkeylessAuthSecretRefSecretRef
 */
export interface SecretStoreSpecProviderAkeylessAuthSecretRefSecretRef {
  /**
   * The SecretAccessID is used for authentication
   *
   * @schema SecretStoreSpecProviderAkeylessAuthSecretRefSecretRef#accessID
   */
  readonly accessId?: SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId;

  /**
   * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
   *
   * @schema SecretStoreSpecProviderAkeylessAuthSecretRefSecretRef#accessType
   */
  readonly accessType?: SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType;

  /**
   * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
   *
   * @schema SecretStoreSpecProviderAkeylessAuthSecretRefSecretRef#accessTypeParam
   */
  readonly accessTypeParam?: SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderAkeylessAuthSecretRefSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderAkeylessAuthSecretRefSecretRef(
  obj: SecretStoreSpecProviderAkeylessAuthSecretRefSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    accessID:
      toJson_SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId(
        obj.accessId,
      ),
    accessType:
      toJson_SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType(
        obj.accessType,
      ),
    accessTypeParam:
      toJson_SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam(
        obj.accessTypeParam,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The type of provider to use such as "Secret", or "ConfigMap".
 *
 * @schema SecretStoreSpecProviderAkeylessCaProviderType
 */
export enum SecretStoreSpecProviderAkeylessCaProviderType {
  /** Secret */
  SECRET = "Secret",
  /** ConfigMap */
  CONFIG_MAP = "ConfigMap",
}

/**
 * Authenticate against Alibaba using RRSA.
 *
 * @schema SecretStoreSpecProviderAlibabaAuthRrsa
 */
export interface SecretStoreSpecProviderAlibabaAuthRrsa {
  /**
   * @schema SecretStoreSpecProviderAlibabaAuthRrsa#oidcProviderArn
   */
  readonly oidcProviderArn: string;

  /**
   * @schema SecretStoreSpecProviderAlibabaAuthRrsa#oidcTokenFilePath
   */
  readonly oidcTokenFilePath: string;

  /**
   * @schema SecretStoreSpecProviderAlibabaAuthRrsa#roleArn
   */
  readonly roleArn: string;

  /**
   * @schema SecretStoreSpecProviderAlibabaAuthRrsa#sessionName
   */
  readonly sessionName: string;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderAlibabaAuthRrsa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderAlibabaAuthRrsa(
  obj: SecretStoreSpecProviderAlibabaAuthRrsa | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    oidcProviderArn: obj.oidcProviderArn,
    oidcTokenFilePath: obj.oidcTokenFilePath,
    roleArn: obj.roleArn,
    sessionName: obj.sessionName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * AlibabaAuthSecretRef holds secret references for Alibaba credentials.
 *
 * @schema SecretStoreSpecProviderAlibabaAuthSecretRef
 */
export interface SecretStoreSpecProviderAlibabaAuthSecretRef {
  /**
   * The AccessKeyID is used for authentication
   *
   * @schema SecretStoreSpecProviderAlibabaAuthSecretRef#accessKeyIDSecretRef
   */
  readonly accessKeyIdSecretRef: SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef;

  /**
   * The AccessKeySecret is used for authentication
   *
   * @schema SecretStoreSpecProviderAlibabaAuthSecretRef#accessKeySecretSecretRef
   */
  readonly accessKeySecretSecretRef: SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderAlibabaAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderAlibabaAuthSecretRef(
  obj: SecretStoreSpecProviderAlibabaAuthSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    accessKeyIDSecretRef:
      toJson_SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef(
        obj.accessKeyIdSecretRef,
      ),
    accessKeySecretSecretRef:
      toJson_SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef(
        obj.accessKeySecretSecretRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Authenticate against AWS using service account tokens.
 *
 * @schema SecretStoreSpecProviderAwsAuthJwt
 */
export interface SecretStoreSpecProviderAwsAuthJwt {
  /**
   * A reference to a ServiceAccount resource.
   *
   * @schema SecretStoreSpecProviderAwsAuthJwt#serviceAccountRef
   */
  readonly serviceAccountRef?: SecretStoreSpecProviderAwsAuthJwtServiceAccountRef;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderAwsAuthJwt' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderAwsAuthJwt(
  obj: SecretStoreSpecProviderAwsAuthJwt | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    serviceAccountRef:
      toJson_SecretStoreSpecProviderAwsAuthJwtServiceAccountRef(
        obj.serviceAccountRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * AWSAuthSecretRef holds secret references for AWS credentials both AccessKeyID and SecretAccessKey must be defined in order to properly authenticate.
 *
 * @schema SecretStoreSpecProviderAwsAuthSecretRef
 */
export interface SecretStoreSpecProviderAwsAuthSecretRef {
  /**
   * The AccessKeyID is used for authentication
   *
   * @schema SecretStoreSpecProviderAwsAuthSecretRef#accessKeyIDSecretRef
   */
  readonly accessKeyIdSecretRef?: SecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef;

  /**
   * The SecretAccessKey is used for authentication
   *
   * @schema SecretStoreSpecProviderAwsAuthSecretRef#secretAccessKeySecretRef
   */
  readonly secretAccessKeySecretRef?: SecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderAwsAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderAwsAuthSecretRef(
  obj: SecretStoreSpecProviderAwsAuthSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    accessKeyIDSecretRef:
      toJson_SecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef(
        obj.accessKeyIdSecretRef,
      ),
    secretAccessKeySecretRef:
      toJson_SecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef(
        obj.secretAccessKeySecretRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The Azure clientId of the service principle used for authentication.
 *
 * @schema SecretStoreSpecProviderAzurekvAuthSecretRefClientId
 */
export interface SecretStoreSpecProviderAzurekvAuthSecretRefClientId {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderAzurekvAuthSecretRefClientId#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderAzurekvAuthSecretRefClientId#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderAzurekvAuthSecretRefClientId#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderAzurekvAuthSecretRefClientId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderAzurekvAuthSecretRefClientId(
  obj: SecretStoreSpecProviderAzurekvAuthSecretRefClientId | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The Azure ClientSecret of the service principle used for authentication.
 *
 * @schema SecretStoreSpecProviderAzurekvAuthSecretRefClientSecret
 */
export interface SecretStoreSpecProviderAzurekvAuthSecretRefClientSecret {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderAzurekvAuthSecretRefClientSecret#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderAzurekvAuthSecretRefClientSecret#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderAzurekvAuthSecretRefClientSecret#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderAzurekvAuthSecretRefClientSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderAzurekvAuthSecretRefClientSecret(
  obj: SecretStoreSpecProviderAzurekvAuthSecretRefClientSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SecretStoreSpecProviderGcpsmAuthSecretRef
 */
export interface SecretStoreSpecProviderGcpsmAuthSecretRef {
  /**
   * The SecretAccessKey is used for authentication
   *
   * @schema SecretStoreSpecProviderGcpsmAuthSecretRef#secretAccessKeySecretRef
   */
  readonly secretAccessKeySecretRef?: SecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderGcpsmAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderGcpsmAuthSecretRef(
  obj: SecretStoreSpecProviderGcpsmAuthSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    secretAccessKeySecretRef:
      toJson_SecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef(
        obj.secretAccessKeySecretRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SecretStoreSpecProviderGcpsmAuthWorkloadIdentity
 */
export interface SecretStoreSpecProviderGcpsmAuthWorkloadIdentity {
  /**
   * @schema SecretStoreSpecProviderGcpsmAuthWorkloadIdentity#clusterLocation
   */
  readonly clusterLocation: string;

  /**
   * @schema SecretStoreSpecProviderGcpsmAuthWorkloadIdentity#clusterName
   */
  readonly clusterName: string;

  /**
   * @schema SecretStoreSpecProviderGcpsmAuthWorkloadIdentity#clusterProjectID
   */
  readonly clusterProjectId?: string;

  /**
   * A reference to a ServiceAccount resource.
   *
   * @schema SecretStoreSpecProviderGcpsmAuthWorkloadIdentity#serviceAccountRef
   */
  readonly serviceAccountRef: SecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderGcpsmAuthWorkloadIdentity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderGcpsmAuthWorkloadIdentity(
  obj: SecretStoreSpecProviderGcpsmAuthWorkloadIdentity | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    clusterLocation: obj.clusterLocation,
    clusterName: obj.clusterName,
    clusterProjectID: obj.clusterProjectId,
    serviceAccountRef:
      toJson_SecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef(
        obj.serviceAccountRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SecretStoreSpecProviderGitlabAuthSecretRef
 */
export interface SecretStoreSpecProviderGitlabAuthSecretRef {
  /**
   * AccessToken is used for authentication.
   *
   * @schema SecretStoreSpecProviderGitlabAuthSecretRef#accessToken
   */
  readonly accessToken?: SecretStoreSpecProviderGitlabAuthSecretRefAccessToken;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderGitlabAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderGitlabAuthSecretRef(
  obj: SecretStoreSpecProviderGitlabAuthSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    accessToken: toJson_SecretStoreSpecProviderGitlabAuthSecretRefAccessToken(
      obj.accessToken,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SecretStoreSpecProviderIbmAuthSecretRef
 */
export interface SecretStoreSpecProviderIbmAuthSecretRef {
  /**
   * The SecretAccessKey is used for authentication
   *
   * @schema SecretStoreSpecProviderIbmAuthSecretRef#secretApiKeySecretRef
   */
  readonly secretApiKeySecretRef?: SecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderIbmAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderIbmAuthSecretRef(
  obj: SecretStoreSpecProviderIbmAuthSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    secretApiKeySecretRef:
      toJson_SecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef(
        obj.secretApiKeySecretRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * has both clientCert and clientKey as secretKeySelector
 *
 * @schema SecretStoreSpecProviderKubernetesAuthCert
 */
export interface SecretStoreSpecProviderKubernetesAuthCert {
  /**
   * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
   *
   * @schema SecretStoreSpecProviderKubernetesAuthCert#clientCert
   */
  readonly clientCert?: SecretStoreSpecProviderKubernetesAuthCertClientCert;

  /**
   * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
   *
   * @schema SecretStoreSpecProviderKubernetesAuthCert#clientKey
   */
  readonly clientKey?: SecretStoreSpecProviderKubernetesAuthCertClientKey;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderKubernetesAuthCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderKubernetesAuthCert(
  obj: SecretStoreSpecProviderKubernetesAuthCert | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    clientCert: toJson_SecretStoreSpecProviderKubernetesAuthCertClientCert(
      obj.clientCert,
    ),
    clientKey: toJson_SecretStoreSpecProviderKubernetesAuthCertClientKey(
      obj.clientKey,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * points to a service account that should be used for authentication
 *
 * @schema SecretStoreSpecProviderKubernetesAuthServiceAccount
 */
export interface SecretStoreSpecProviderKubernetesAuthServiceAccount {
  /**
   * A reference to a ServiceAccount resource.
   *
   * @schema SecretStoreSpecProviderKubernetesAuthServiceAccount#serviceAccount
   */
  readonly serviceAccount?: SecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderKubernetesAuthServiceAccount' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderKubernetesAuthServiceAccount(
  obj: SecretStoreSpecProviderKubernetesAuthServiceAccount | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    serviceAccount:
      toJson_SecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount(
        obj.serviceAccount,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * use static token to authenticate with
 *
 * @schema SecretStoreSpecProviderKubernetesAuthToken
 */
export interface SecretStoreSpecProviderKubernetesAuthToken {
  /**
   * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
   *
   * @schema SecretStoreSpecProviderKubernetesAuthToken#bearerToken
   */
  readonly bearerToken?: SecretStoreSpecProviderKubernetesAuthTokenBearerToken;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderKubernetesAuthToken' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderKubernetesAuthToken(
  obj: SecretStoreSpecProviderKubernetesAuthToken | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    bearerToken: toJson_SecretStoreSpecProviderKubernetesAuthTokenBearerToken(
      obj.bearerToken,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * see: https://external-secrets.io/v0.4.1/spec/#external-secrets.io/v1alpha1.CAProvider
 *
 * @schema SecretStoreSpecProviderKubernetesServerCaProvider
 */
export interface SecretStoreSpecProviderKubernetesServerCaProvider {
  /**
   * The key the value inside of the provider type to use, only used with "Secret" type
   *
   * @schema SecretStoreSpecProviderKubernetesServerCaProvider#key
   */
  readonly key?: string;

  /**
   * The name of the object located at the provider type.
   *
   * @schema SecretStoreSpecProviderKubernetesServerCaProvider#name
   */
  readonly name: string;

  /**
   * The namespace the Provider type is in.
   *
   * @schema SecretStoreSpecProviderKubernetesServerCaProvider#namespace
   */
  readonly namespace?: string;

  /**
   * The type of provider to use such as "Secret", or "ConfigMap".
   *
   * @schema SecretStoreSpecProviderKubernetesServerCaProvider#type
   */
  readonly type: SecretStoreSpecProviderKubernetesServerCaProviderType;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderKubernetesServerCaProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderKubernetesServerCaProvider(
  obj: SecretStoreSpecProviderKubernetesServerCaProvider | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
    type: obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * SecretRef to pass through sensitive information.
 *
 * @schema SecretStoreSpecProviderOracleAuthSecretRef
 */
export interface SecretStoreSpecProviderOracleAuthSecretRef {
  /**
   * Fingerprint is the fingerprint of the API private key.
   *
   * @schema SecretStoreSpecProviderOracleAuthSecretRef#fingerprint
   */
  readonly fingerprint: SecretStoreSpecProviderOracleAuthSecretRefFingerprint;

  /**
   * PrivateKey is the user's API Signing Key in PEM format, used for authentication.
   *
   * @schema SecretStoreSpecProviderOracleAuthSecretRef#privatekey
   */
  readonly privatekey: SecretStoreSpecProviderOracleAuthSecretRefPrivatekey;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderOracleAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderOracleAuthSecretRef(
  obj: SecretStoreSpecProviderOracleAuthSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    fingerprint: toJson_SecretStoreSpecProviderOracleAuthSecretRefFingerprint(
      obj.fingerprint,
    ),
    privatekey: toJson_SecretStoreSpecProviderOracleAuthSecretRefPrivatekey(
      obj.privatekey,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * AppRole authenticates with Vault using the App Role auth mechanism, with the role and secret stored in a Kubernetes Secret resource.
 *
 * @schema SecretStoreSpecProviderVaultAuthAppRole
 */
export interface SecretStoreSpecProviderVaultAuthAppRole {
  /**
   * Path where the App Role authentication backend is mounted in Vault, e.g: "approle"
   *
   * @schema SecretStoreSpecProviderVaultAuthAppRole#path
   */
  readonly path: string;

  /**
   * RoleID configured in the App Role authentication backend when setting up the authentication backend in Vault.
   *
   * @schema SecretStoreSpecProviderVaultAuthAppRole#roleId
   */
  readonly roleId: string;

  /**
   * Reference to a key in a Secret that contains the App Role secret used to authenticate with Vault. The `key` field must be specified and denotes which entry within the Secret resource is used as the app role secret.
   *
   * @schema SecretStoreSpecProviderVaultAuthAppRole#secretRef
   */
  readonly secretRef: SecretStoreSpecProviderVaultAuthAppRoleSecretRef;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderVaultAuthAppRole' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderVaultAuthAppRole(
  obj: SecretStoreSpecProviderVaultAuthAppRole | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    path: obj.path,
    roleId: obj.roleId,
    secretRef: toJson_SecretStoreSpecProviderVaultAuthAppRoleSecretRef(
      obj.secretRef,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Cert authenticates with TLS Certificates by passing client certificate, private key and ca certificate Cert authentication method
 *
 * @schema SecretStoreSpecProviderVaultAuthCert
 */
export interface SecretStoreSpecProviderVaultAuthCert {
  /**
   * ClientCert is a certificate to authenticate using the Cert Vault authentication method
   *
   * @schema SecretStoreSpecProviderVaultAuthCert#clientCert
   */
  readonly clientCert?: SecretStoreSpecProviderVaultAuthCertClientCert;

  /**
   * SecretRef to a key in a Secret resource containing client private key to authenticate with Vault using the Cert authentication method
   *
   * @schema SecretStoreSpecProviderVaultAuthCert#secretRef
   */
  readonly secretRef?: SecretStoreSpecProviderVaultAuthCertSecretRef;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderVaultAuthCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderVaultAuthCert(
  obj: SecretStoreSpecProviderVaultAuthCert | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    clientCert: toJson_SecretStoreSpecProviderVaultAuthCertClientCert(
      obj.clientCert,
    ),
    secretRef: toJson_SecretStoreSpecProviderVaultAuthCertSecretRef(
      obj.secretRef,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Jwt authenticates with Vault by passing role and JWT token using the JWT/OIDC authentication method
 *
 * @schema SecretStoreSpecProviderVaultAuthJwt
 */
export interface SecretStoreSpecProviderVaultAuthJwt {
  /**
   * Optional ServiceAccountToken specifies the Kubernetes service account for which to request a token for with the `TokenRequest` API.
   *
   * @schema SecretStoreSpecProviderVaultAuthJwt#kubernetesServiceAccountToken
   */
  readonly kubernetesServiceAccountToken?: SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken;

  /**
   * Path where the JWT authentication backend is mounted in Vault, e.g: "jwt"
   *
   * @schema SecretStoreSpecProviderVaultAuthJwt#path
   */
  readonly path: string;

  /**
   * Role is a JWT role to authenticate using the JWT/OIDC Vault authentication method
   *
   * @schema SecretStoreSpecProviderVaultAuthJwt#role
   */
  readonly role?: string;

  /**
   * Optional SecretRef that refers to a key in a Secret resource containing JWT token to authenticate with Vault using the JWT/OIDC authentication method.
   *
   * @schema SecretStoreSpecProviderVaultAuthJwt#secretRef
   */
  readonly secretRef?: SecretStoreSpecProviderVaultAuthJwtSecretRef;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderVaultAuthJwt' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderVaultAuthJwt(
  obj: SecretStoreSpecProviderVaultAuthJwt | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    kubernetesServiceAccountToken:
      toJson_SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken(
        obj.kubernetesServiceAccountToken,
      ),
    path: obj.path,
    role: obj.role,
    secretRef: toJson_SecretStoreSpecProviderVaultAuthJwtSecretRef(
      obj.secretRef,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Kubernetes authenticates with Vault by passing the ServiceAccount token stored in the named Secret resource to the Vault server.
 *
 * @schema SecretStoreSpecProviderVaultAuthKubernetes
 */
export interface SecretStoreSpecProviderVaultAuthKubernetes {
  /**
   * Path where the Kubernetes authentication backend is mounted in Vault, e.g: "kubernetes"
   *
   * @schema SecretStoreSpecProviderVaultAuthKubernetes#mountPath
   */
  readonly mountPath: string;

  /**
   * A required field containing the Vault Role to assume. A Role binds a Kubernetes ServiceAccount with a set of Vault policies.
   *
   * @schema SecretStoreSpecProviderVaultAuthKubernetes#role
   */
  readonly role: string;

  /**
   * Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Vault. If a name is specified without a key, `token` is the default. If one is not specified, the one bound to the controller will be used.
   *
   * @schema SecretStoreSpecProviderVaultAuthKubernetes#secretRef
   */
  readonly secretRef?: SecretStoreSpecProviderVaultAuthKubernetesSecretRef;

  /**
   * Optional service account field containing the name of a kubernetes ServiceAccount. If the service account is specified, the service account secret token JWT will be used for authenticating with Vault. If the service account selector is not supplied, the secretRef will be used instead.
   *
   * @schema SecretStoreSpecProviderVaultAuthKubernetes#serviceAccountRef
   */
  readonly serviceAccountRef?: SecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderVaultAuthKubernetes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderVaultAuthKubernetes(
  obj: SecretStoreSpecProviderVaultAuthKubernetes | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    mountPath: obj.mountPath,
    role: obj.role,
    secretRef: toJson_SecretStoreSpecProviderVaultAuthKubernetesSecretRef(
      obj.secretRef,
    ),
    serviceAccountRef:
      toJson_SecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef(
        obj.serviceAccountRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Ldap authenticates with Vault by passing username/password pair using the LDAP authentication method
 *
 * @schema SecretStoreSpecProviderVaultAuthLdap
 */
export interface SecretStoreSpecProviderVaultAuthLdap {
  /**
   * Path where the LDAP authentication backend is mounted in Vault, e.g: "ldap"
   *
   * @schema SecretStoreSpecProviderVaultAuthLdap#path
   */
  readonly path: string;

  /**
   * SecretRef to a key in a Secret resource containing password for the LDAP user used to authenticate with Vault using the LDAP authentication method
   *
   * @schema SecretStoreSpecProviderVaultAuthLdap#secretRef
   */
  readonly secretRef?: SecretStoreSpecProviderVaultAuthLdapSecretRef;

  /**
   * Username is a LDAP user name used to authenticate using the LDAP Vault authentication method
   *
   * @schema SecretStoreSpecProviderVaultAuthLdap#username
   */
  readonly username: string;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderVaultAuthLdap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderVaultAuthLdap(
  obj: SecretStoreSpecProviderVaultAuthLdap | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    path: obj.path,
    secretRef: toJson_SecretStoreSpecProviderVaultAuthLdapSecretRef(
      obj.secretRef,
    ),
    username: obj.username,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * TokenSecretRef authenticates with Vault by presenting a token.
 *
 * @schema SecretStoreSpecProviderVaultAuthTokenSecretRef
 */
export interface SecretStoreSpecProviderVaultAuthTokenSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderVaultAuthTokenSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderVaultAuthTokenSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderVaultAuthTokenSecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderVaultAuthTokenSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderVaultAuthTokenSecretRef(
  obj: SecretStoreSpecProviderVaultAuthTokenSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The type of provider to use such as "Secret", or "ConfigMap".
 *
 * @schema SecretStoreSpecProviderVaultCaProviderType
 */
export enum SecretStoreSpecProviderVaultCaProviderType {
  /** Secret */
  SECRET = "Secret",
  /** ConfigMap */
  CONFIG_MAP = "ConfigMap",
}

/**
 * The type of provider to use such as "Secret", or "ConfigMap".
 *
 * @schema SecretStoreSpecProviderWebhookCaProviderType
 */
export enum SecretStoreSpecProviderWebhookCaProviderType {
  /** Secret */
  SECRET = "Secret",
  /** ConfigMap */
  CONFIG_MAP = "ConfigMap",
}

/**
 * Secret ref to fill in credentials
 *
 * @schema SecretStoreSpecProviderWebhookSecretsSecretRef
 */
export interface SecretStoreSpecProviderWebhookSecretsSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderWebhookSecretsSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderWebhookSecretsSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderWebhookSecretsSecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderWebhookSecretsSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderWebhookSecretsSecretRef(
  obj: SecretStoreSpecProviderWebhookSecretsSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The authorized key used for authentication
 *
 * @schema SecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef
 */
export interface SecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef(
  obj:
    | SecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
 *
 * @schema SecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef
 */
export interface SecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef(
  obj: SecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Akeyless. If a name is specified without a key, `token` is the default. If one is not specified, the one bound to the controller will be used.
 *
 * @schema SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef
 */
export interface SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef(
  obj:
    | SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Optional service account field containing the name of a kubernetes ServiceAccount. If the service account is specified, the service account secret token JWT will be used for authenticating with Akeyless. If the service account selector is not supplied, the secretRef will be used instead.
 *
 * @schema SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef
 */
export interface SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
   *
   * @schema SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef(
  obj:
    | SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    audiences: obj.audiences?.map((y) => y),
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The SecretAccessID is used for authentication
 *
 * @schema SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId
 */
export interface SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId(
  obj:
    | SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
 *
 * @schema SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType
 */
export interface SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType(
  obj:
    | SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
 *
 * @schema SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam
 */
export interface SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam(
  obj:
    | SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The AccessKeyID is used for authentication
 *
 * @schema SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef
 */
export interface SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef(
  obj:
    | SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The AccessKeySecret is used for authentication
 *
 * @schema SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef
 */
export interface SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef(
  obj:
    | SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A reference to a ServiceAccount resource.
 *
 * @schema SecretStoreSpecProviderAwsAuthJwtServiceAccountRef
 */
export interface SecretStoreSpecProviderAwsAuthJwtServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
   *
   * @schema SecretStoreSpecProviderAwsAuthJwtServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema SecretStoreSpecProviderAwsAuthJwtServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderAwsAuthJwtServiceAccountRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderAwsAuthJwtServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderAwsAuthJwtServiceAccountRef(
  obj: SecretStoreSpecProviderAwsAuthJwtServiceAccountRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    audiences: obj.audiences?.map((y) => y),
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The AccessKeyID is used for authentication
 *
 * @schema SecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef
 */
export interface SecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef(
  obj: SecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The SecretAccessKey is used for authentication
 *
 * @schema SecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef
 */
export interface SecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef(
  obj:
    | SecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The SecretAccessKey is used for authentication
 *
 * @schema SecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef
 */
export interface SecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef(
  obj:
    | SecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A reference to a ServiceAccount resource.
 *
 * @schema SecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef
 */
export interface SecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
   *
   * @schema SecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema SecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef(
  obj:
    | SecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    audiences: obj.audiences?.map((y) => y),
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * AccessToken is used for authentication.
 *
 * @schema SecretStoreSpecProviderGitlabAuthSecretRefAccessToken
 */
export interface SecretStoreSpecProviderGitlabAuthSecretRefAccessToken {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderGitlabAuthSecretRefAccessToken#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderGitlabAuthSecretRefAccessToken#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderGitlabAuthSecretRefAccessToken#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderGitlabAuthSecretRefAccessToken' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderGitlabAuthSecretRefAccessToken(
  obj: SecretStoreSpecProviderGitlabAuthSecretRefAccessToken | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The SecretAccessKey is used for authentication
 *
 * @schema SecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef
 */
export interface SecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef(
  obj: SecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
 *
 * @schema SecretStoreSpecProviderKubernetesAuthCertClientCert
 */
export interface SecretStoreSpecProviderKubernetesAuthCertClientCert {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderKubernetesAuthCertClientCert#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderKubernetesAuthCertClientCert#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderKubernetesAuthCertClientCert#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderKubernetesAuthCertClientCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderKubernetesAuthCertClientCert(
  obj: SecretStoreSpecProviderKubernetesAuthCertClientCert | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
 *
 * @schema SecretStoreSpecProviderKubernetesAuthCertClientKey
 */
export interface SecretStoreSpecProviderKubernetesAuthCertClientKey {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderKubernetesAuthCertClientKey#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderKubernetesAuthCertClientKey#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderKubernetesAuthCertClientKey#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderKubernetesAuthCertClientKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderKubernetesAuthCertClientKey(
  obj: SecretStoreSpecProviderKubernetesAuthCertClientKey | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A reference to a ServiceAccount resource.
 *
 * @schema SecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount
 */
export interface SecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount {
  /**
   * Audience specifies the `aud` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
   *
   * @schema SecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema SecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount(
  obj:
    | SecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    audiences: obj.audiences?.map((y) => y),
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
 *
 * @schema SecretStoreSpecProviderKubernetesAuthTokenBearerToken
 */
export interface SecretStoreSpecProviderKubernetesAuthTokenBearerToken {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderKubernetesAuthTokenBearerToken#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderKubernetesAuthTokenBearerToken#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderKubernetesAuthTokenBearerToken#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderKubernetesAuthTokenBearerToken' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderKubernetesAuthTokenBearerToken(
  obj: SecretStoreSpecProviderKubernetesAuthTokenBearerToken | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The type of provider to use such as "Secret", or "ConfigMap".
 *
 * @schema SecretStoreSpecProviderKubernetesServerCaProviderType
 */
export enum SecretStoreSpecProviderKubernetesServerCaProviderType {
  /** Secret */
  SECRET = "Secret",
  /** ConfigMap */
  CONFIG_MAP = "ConfigMap",
}

/**
 * Fingerprint is the fingerprint of the API private key.
 *
 * @schema SecretStoreSpecProviderOracleAuthSecretRefFingerprint
 */
export interface SecretStoreSpecProviderOracleAuthSecretRefFingerprint {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderOracleAuthSecretRefFingerprint#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderOracleAuthSecretRefFingerprint#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderOracleAuthSecretRefFingerprint#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderOracleAuthSecretRefFingerprint' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderOracleAuthSecretRefFingerprint(
  obj: SecretStoreSpecProviderOracleAuthSecretRefFingerprint | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * PrivateKey is the user's API Signing Key in PEM format, used for authentication.
 *
 * @schema SecretStoreSpecProviderOracleAuthSecretRefPrivatekey
 */
export interface SecretStoreSpecProviderOracleAuthSecretRefPrivatekey {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderOracleAuthSecretRefPrivatekey#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderOracleAuthSecretRefPrivatekey#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderOracleAuthSecretRefPrivatekey#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderOracleAuthSecretRefPrivatekey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderOracleAuthSecretRefPrivatekey(
  obj: SecretStoreSpecProviderOracleAuthSecretRefPrivatekey | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a key in a Secret that contains the App Role secret used to authenticate with Vault. The `key` field must be specified and denotes which entry within the Secret resource is used as the app role secret.
 *
 * @schema SecretStoreSpecProviderVaultAuthAppRoleSecretRef
 */
export interface SecretStoreSpecProviderVaultAuthAppRoleSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderVaultAuthAppRoleSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderVaultAuthAppRoleSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderVaultAuthAppRoleSecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderVaultAuthAppRoleSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderVaultAuthAppRoleSecretRef(
  obj: SecretStoreSpecProviderVaultAuthAppRoleSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ClientCert is a certificate to authenticate using the Cert Vault authentication method
 *
 * @schema SecretStoreSpecProviderVaultAuthCertClientCert
 */
export interface SecretStoreSpecProviderVaultAuthCertClientCert {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderVaultAuthCertClientCert#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderVaultAuthCertClientCert#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderVaultAuthCertClientCert#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderVaultAuthCertClientCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderVaultAuthCertClientCert(
  obj: SecretStoreSpecProviderVaultAuthCertClientCert | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * SecretRef to a key in a Secret resource containing client private key to authenticate with Vault using the Cert authentication method
 *
 * @schema SecretStoreSpecProviderVaultAuthCertSecretRef
 */
export interface SecretStoreSpecProviderVaultAuthCertSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderVaultAuthCertSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderVaultAuthCertSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderVaultAuthCertSecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderVaultAuthCertSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderVaultAuthCertSecretRef(
  obj: SecretStoreSpecProviderVaultAuthCertSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Optional ServiceAccountToken specifies the Kubernetes service account for which to request a token for with the `TokenRequest` API.
 *
 * @schema SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken
 */
export interface SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken {
  /**
   * Optional audiences field that will be used to request a temporary Kubernetes service account token for the service account referenced by `serviceAccountRef`. Defaults to a single audience `vault` it not specified.
   *
   * @default a single audience `vault` it not specified.
   * @schema SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken#audiences
   */
  readonly audiences?: string[];

  /**
   * Optional expiration time in seconds that will be used to request a temporary Kubernetes service account token for the service account referenced by `serviceAccountRef`. Defaults to 10 minutes.
   *
   * @default 10 minutes.
   * @schema SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken#expirationSeconds
   */
  readonly expirationSeconds?: number;

  /**
   * Service account field containing the name of a kubernetes ServiceAccount.
   *
   * @schema SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken#serviceAccountRef
   */
  readonly serviceAccountRef: SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken(
  obj:
    | SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    audiences: obj.audiences?.map((y) => y),
    expirationSeconds: obj.expirationSeconds,
    serviceAccountRef:
      toJson_SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef(
        obj.serviceAccountRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Optional SecretRef that refers to a key in a Secret resource containing JWT token to authenticate with Vault using the JWT/OIDC authentication method.
 *
 * @schema SecretStoreSpecProviderVaultAuthJwtSecretRef
 */
export interface SecretStoreSpecProviderVaultAuthJwtSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderVaultAuthJwtSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderVaultAuthJwtSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderVaultAuthJwtSecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderVaultAuthJwtSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderVaultAuthJwtSecretRef(
  obj: SecretStoreSpecProviderVaultAuthJwtSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Vault. If a name is specified without a key, `token` is the default. If one is not specified, the one bound to the controller will be used.
 *
 * @schema SecretStoreSpecProviderVaultAuthKubernetesSecretRef
 */
export interface SecretStoreSpecProviderVaultAuthKubernetesSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderVaultAuthKubernetesSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderVaultAuthKubernetesSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderVaultAuthKubernetesSecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderVaultAuthKubernetesSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderVaultAuthKubernetesSecretRef(
  obj: SecretStoreSpecProviderVaultAuthKubernetesSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Optional service account field containing the name of a kubernetes ServiceAccount. If the service account is specified, the service account secret token JWT will be used for authenticating with Vault. If the service account selector is not supplied, the secretRef will be used instead.
 *
 * @schema SecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef
 */
export interface SecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
   *
   * @schema SecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema SecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef(
  obj: SecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    audiences: obj.audiences?.map((y) => y),
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * SecretRef to a key in a Secret resource containing password for the LDAP user used to authenticate with Vault using the LDAP authentication method
 *
 * @schema SecretStoreSpecProviderVaultAuthLdapSecretRef
 */
export interface SecretStoreSpecProviderVaultAuthLdapSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreSpecProviderVaultAuthLdapSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreSpecProviderVaultAuthLdapSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderVaultAuthLdapSecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderVaultAuthLdapSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderVaultAuthLdapSecretRef(
  obj: SecretStoreSpecProviderVaultAuthLdapSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Service account field containing the name of a kubernetes ServiceAccount.
 *
 * @schema SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef
 */
export interface SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
   *
   * @schema SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef(
  obj:
    | SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    audiences: obj.audiences?.map((y) => y),
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStore represents a secure external location for storing secrets, which can be referenced as part of `storeRef` fields.
 *
 * @schema SecretStoreV1Beta1
 */
export class SecretStoreV1Beta1 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "SecretStoreV1Beta1"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "external-secrets.io/v1beta1",
    kind: "SecretStore",
  };

  /**
   * Renders a Kubernetes manifest for "SecretStoreV1Beta1".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SecretStoreV1Beta1Props = {}): any {
    return {
      ...SecretStoreV1Beta1.GVK,
      ...toJson_SecretStoreV1Beta1Props(props),
    };
  }

  /**
   * Defines a "SecretStoreV1Beta1" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(
    scope: Construct,
    id: string,
    props: SecretStoreV1Beta1Props = {},
  ) {
    super(scope, id, {
      ...SecretStoreV1Beta1.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...SecretStoreV1Beta1.GVK,
      ...toJson_SecretStoreV1Beta1Props(resolved),
    };
  }
}

/**
 * SecretStore represents a secure external location for storing secrets, which can be referenced as part of `storeRef` fields.
 *
 * @schema SecretStoreV1Beta1
 */
export interface SecretStoreV1Beta1Props {
  /**
   * @schema SecretStoreV1Beta1#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * SecretStoreSpec defines the desired state of SecretStore.
   *
   * @schema SecretStoreV1Beta1#spec
   */
  readonly spec?: SecretStoreV1Beta1Spec;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1Props(
  obj: SecretStoreV1Beta1Props | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    spec: toJson_SecretStoreV1Beta1Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreSpec defines the desired state of SecretStore.
 *
 * @schema SecretStoreV1Beta1Spec
 */
export interface SecretStoreV1Beta1Spec {
  /**
   * Used to constraint a ClusterSecretStore to specific namespaces. Relevant only to ClusterSecretStore
   *
   * @schema SecretStoreV1Beta1Spec#conditions
   */
  readonly conditions?: SecretStoreV1Beta1SpecConditions[];

  /**
   * Used to select the correct ESO controller (think: ingress.ingressClassName) The ESO controller is instantiated with a specific controller name and filters ES based on this property
   *
   * @schema SecretStoreV1Beta1Spec#controller
   */
  readonly controller?: string;

  /**
   * Used to configure the provider. Only one provider may be set
   *
   * @schema SecretStoreV1Beta1Spec#provider
   */
  readonly provider: SecretStoreV1Beta1SpecProvider;

  /**
   * Used to configure store refresh interval in seconds. Empty or 0 will default to the controller config.
   *
   * @schema SecretStoreV1Beta1Spec#refreshInterval
   */
  readonly refreshInterval?: number;

  /**
   * Used to configure http retries if failed
   *
   * @schema SecretStoreV1Beta1Spec#retrySettings
   */
  readonly retrySettings?: SecretStoreV1Beta1SpecRetrySettings;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1Spec(
  obj: SecretStoreV1Beta1Spec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    conditions: obj.conditions?.map((y) =>
      toJson_SecretStoreV1Beta1SpecConditions(y),
    ),
    controller: obj.controller,
    provider: toJson_SecretStoreV1Beta1SpecProvider(obj.provider),
    refreshInterval: obj.refreshInterval,
    retrySettings: toJson_SecretStoreV1Beta1SpecRetrySettings(
      obj.retrySettings,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ClusterSecretStoreCondition describes a condition by which to choose namespaces to process ExternalSecrets in for a ClusterSecretStore instance.
 *
 * @schema SecretStoreV1Beta1SpecConditions
 */
export interface SecretStoreV1Beta1SpecConditions {
  /**
   * Choose namespace using a labelSelector
   *
   * @schema SecretStoreV1Beta1SpecConditions#namespaceSelector
   */
  readonly namespaceSelector?: SecretStoreV1Beta1SpecConditionsNamespaceSelector;

  /**
   * Choose namespaces by name
   *
   * @schema SecretStoreV1Beta1SpecConditions#namespaces
   */
  readonly namespaces?: string[];
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecConditions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecConditions(
  obj: SecretStoreV1Beta1SpecConditions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    namespaceSelector: toJson_SecretStoreV1Beta1SpecConditionsNamespaceSelector(
      obj.namespaceSelector,
    ),
    namespaces: obj.namespaces?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Used to configure the provider. Only one provider may be set
 *
 * @schema SecretStoreV1Beta1SpecProvider
 */
export interface SecretStoreV1Beta1SpecProvider {
  /**
   * Akeyless configures this store to sync secrets using Akeyless Vault provider
   *
   * @schema SecretStoreV1Beta1SpecProvider#akeyless
   */
  readonly akeyless?: SecretStoreV1Beta1SpecProviderAkeyless;

  /**
   * Alibaba configures this store to sync secrets using Alibaba Cloud provider
   *
   * @schema SecretStoreV1Beta1SpecProvider#alibaba
   */
  readonly alibaba?: SecretStoreV1Beta1SpecProviderAlibaba;

  /**
   * AWS configures this store to sync secrets using AWS Secret Manager provider
   *
   * @schema SecretStoreV1Beta1SpecProvider#aws
   */
  readonly aws?: SecretStoreV1Beta1SpecProviderAws;

  /**
   * AzureKV configures this store to sync secrets using Azure Key Vault provider
   *
   * @schema SecretStoreV1Beta1SpecProvider#azurekv
   */
  readonly azurekv?: SecretStoreV1Beta1SpecProviderAzurekv;

  /**
   * Conjur configures this store to sync secrets using conjur provider
   *
   * @schema SecretStoreV1Beta1SpecProvider#conjur
   */
  readonly conjur?: SecretStoreV1Beta1SpecProviderConjur;

  /**
   * Delinea DevOps Secrets Vault https://docs.delinea.com/online-help/products/devops-secrets-vault/current
   *
   * @schema SecretStoreV1Beta1SpecProvider#delinea
   */
  readonly delinea?: SecretStoreV1Beta1SpecProviderDelinea;

  /**
   * Doppler configures this store to sync secrets using the Doppler provider
   *
   * @schema SecretStoreV1Beta1SpecProvider#doppler
   */
  readonly doppler?: SecretStoreV1Beta1SpecProviderDoppler;

  /**
   * Fake configures a store with static key/value pairs
   *
   * @schema SecretStoreV1Beta1SpecProvider#fake
   */
  readonly fake?: SecretStoreV1Beta1SpecProviderFake;

  /**
   * GCPSM configures this store to sync secrets using Google Cloud Platform Secret Manager provider
   *
   * @schema SecretStoreV1Beta1SpecProvider#gcpsm
   */
  readonly gcpsm?: SecretStoreV1Beta1SpecProviderGcpsm;

  /**
   * GitLab configures this store to sync secrets using GitLab Variables provider
   *
   * @schema SecretStoreV1Beta1SpecProvider#gitlab
   */
  readonly gitlab?: SecretStoreV1Beta1SpecProviderGitlab;

  /**
   * IBM configures this store to sync secrets using IBM Cloud provider
   *
   * @schema SecretStoreV1Beta1SpecProvider#ibm
   */
  readonly ibm?: SecretStoreV1Beta1SpecProviderIbm;

  /**
   * KeeperSecurity configures this store to sync secrets using the KeeperSecurity provider
   *
   * @schema SecretStoreV1Beta1SpecProvider#keepersecurity
   */
  readonly keepersecurity?: SecretStoreV1Beta1SpecProviderKeepersecurity;

  /**
   * Kubernetes configures this store to sync secrets using a Kubernetes cluster provider
   *
   * @schema SecretStoreV1Beta1SpecProvider#kubernetes
   */
  readonly kubernetes?: SecretStoreV1Beta1SpecProviderKubernetes;

  /**
   * OnePassword configures this store to sync secrets using the 1Password Cloud provider
   *
   * @schema SecretStoreV1Beta1SpecProvider#onepassword
   */
  readonly onepassword?: SecretStoreV1Beta1SpecProviderOnepassword;

  /**
   * Oracle configures this store to sync secrets using Oracle Vault provider
   *
   * @schema SecretStoreV1Beta1SpecProvider#oracle
   */
  readonly oracle?: SecretStoreV1Beta1SpecProviderOracle;

  /**
   * Scaleway
   *
   * @schema SecretStoreV1Beta1SpecProvider#scaleway
   */
  readonly scaleway?: SecretStoreV1Beta1SpecProviderScaleway;

  /**
   * Senhasegura configures this store to sync secrets using senhasegura provider
   *
   * @schema SecretStoreV1Beta1SpecProvider#senhasegura
   */
  readonly senhasegura?: SecretStoreV1Beta1SpecProviderSenhasegura;

  /**
   * Vault configures this store to sync secrets using Hashi provider
   *
   * @schema SecretStoreV1Beta1SpecProvider#vault
   */
  readonly vault?: SecretStoreV1Beta1SpecProviderVault;

  /**
   * Webhook configures this store to sync secrets using a generic templated webhook
   *
   * @schema SecretStoreV1Beta1SpecProvider#webhook
   */
  readonly webhook?: SecretStoreV1Beta1SpecProviderWebhook;

  /**
   * YandexCertificateManager configures this store to sync secrets using Yandex Certificate Manager provider
   *
   * @schema SecretStoreV1Beta1SpecProvider#yandexcertificatemanager
   */
  readonly yandexcertificatemanager?: SecretStoreV1Beta1SpecProviderYandexcertificatemanager;

  /**
   * YandexLockbox configures this store to sync secrets using Yandex Lockbox provider
   *
   * @schema SecretStoreV1Beta1SpecProvider#yandexlockbox
   */
  readonly yandexlockbox?: SecretStoreV1Beta1SpecProviderYandexlockbox;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProvider(
  obj: SecretStoreV1Beta1SpecProvider | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    akeyless: toJson_SecretStoreV1Beta1SpecProviderAkeyless(obj.akeyless),
    alibaba: toJson_SecretStoreV1Beta1SpecProviderAlibaba(obj.alibaba),
    aws: toJson_SecretStoreV1Beta1SpecProviderAws(obj.aws),
    azurekv: toJson_SecretStoreV1Beta1SpecProviderAzurekv(obj.azurekv),
    conjur: toJson_SecretStoreV1Beta1SpecProviderConjur(obj.conjur),
    delinea: toJson_SecretStoreV1Beta1SpecProviderDelinea(obj.delinea),
    doppler: toJson_SecretStoreV1Beta1SpecProviderDoppler(obj.doppler),
    fake: toJson_SecretStoreV1Beta1SpecProviderFake(obj.fake),
    gcpsm: toJson_SecretStoreV1Beta1SpecProviderGcpsm(obj.gcpsm),
    gitlab: toJson_SecretStoreV1Beta1SpecProviderGitlab(obj.gitlab),
    ibm: toJson_SecretStoreV1Beta1SpecProviderIbm(obj.ibm),
    keepersecurity: toJson_SecretStoreV1Beta1SpecProviderKeepersecurity(
      obj.keepersecurity,
    ),
    kubernetes: toJson_SecretStoreV1Beta1SpecProviderKubernetes(obj.kubernetes),
    onepassword: toJson_SecretStoreV1Beta1SpecProviderOnepassword(
      obj.onepassword,
    ),
    oracle: toJson_SecretStoreV1Beta1SpecProviderOracle(obj.oracle),
    scaleway: toJson_SecretStoreV1Beta1SpecProviderScaleway(obj.scaleway),
    senhasegura: toJson_SecretStoreV1Beta1SpecProviderSenhasegura(
      obj.senhasegura,
    ),
    vault: toJson_SecretStoreV1Beta1SpecProviderVault(obj.vault),
    webhook: toJson_SecretStoreV1Beta1SpecProviderWebhook(obj.webhook),
    yandexcertificatemanager:
      toJson_SecretStoreV1Beta1SpecProviderYandexcertificatemanager(
        obj.yandexcertificatemanager,
      ),
    yandexlockbox: toJson_SecretStoreV1Beta1SpecProviderYandexlockbox(
      obj.yandexlockbox,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Used to configure http retries if failed
 *
 * @schema SecretStoreV1Beta1SpecRetrySettings
 */
export interface SecretStoreV1Beta1SpecRetrySettings {
  /**
   * @schema SecretStoreV1Beta1SpecRetrySettings#maxRetries
   */
  readonly maxRetries?: number;

  /**
   * @schema SecretStoreV1Beta1SpecRetrySettings#retryInterval
   */
  readonly retryInterval?: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecRetrySettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecRetrySettings(
  obj: SecretStoreV1Beta1SpecRetrySettings | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    maxRetries: obj.maxRetries,
    retryInterval: obj.retryInterval,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Choose namespace using a labelSelector
 *
 * @schema SecretStoreV1Beta1SpecConditionsNamespaceSelector
 */
export interface SecretStoreV1Beta1SpecConditionsNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema SecretStoreV1Beta1SpecConditionsNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: SecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema SecretStoreV1Beta1SpecConditionsNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecConditionsNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecConditionsNamespaceSelector(
  obj: SecretStoreV1Beta1SpecConditionsNamespaceSelector | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) =>
      toJson_SecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions(
        y,
      ),
    ),
    matchLabels:
      obj.matchLabels === undefined
        ? undefined
        : Object.entries(obj.matchLabels).reduce(
            (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
            {},
          ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Akeyless configures this store to sync secrets using Akeyless Vault provider
 *
 * @schema SecretStoreV1Beta1SpecProviderAkeyless
 */
export interface SecretStoreV1Beta1SpecProviderAkeyless {
  /**
   * Akeyless GW API Url from which the secrets to be fetched from.
   *
   * @schema SecretStoreV1Beta1SpecProviderAkeyless#akeylessGWApiURL
   */
  readonly akeylessGwApiUrl: string;

  /**
   * Auth configures how the operator authenticates with Akeyless.
   *
   * @schema SecretStoreV1Beta1SpecProviderAkeyless#authSecretRef
   */
  readonly authSecretRef: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef;

  /**
   * PEM/base64 encoded CA bundle used to validate Akeyless Gateway certificate. Only used if the AkeylessGWApiURL URL is using HTTPS protocol. If not set the system root certificates are used to validate the TLS connection.
   *
   * @schema SecretStoreV1Beta1SpecProviderAkeyless#caBundle
   */
  readonly caBundle?: string;

  /**
   * The provider for the CA bundle to use to validate Akeyless Gateway certificate.
   *
   * @schema SecretStoreV1Beta1SpecProviderAkeyless#caProvider
   */
  readonly caProvider?: SecretStoreV1Beta1SpecProviderAkeylessCaProvider;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderAkeyless' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderAkeyless(
  obj: SecretStoreV1Beta1SpecProviderAkeyless | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    akeylessGWApiURL: obj.akeylessGwApiUrl,
    authSecretRef: toJson_SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef(
      obj.authSecretRef,
    ),
    caBundle: obj.caBundle,
    caProvider: toJson_SecretStoreV1Beta1SpecProviderAkeylessCaProvider(
      obj.caProvider,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Alibaba configures this store to sync secrets using Alibaba Cloud provider
 *
 * @schema SecretStoreV1Beta1SpecProviderAlibaba
 */
export interface SecretStoreV1Beta1SpecProviderAlibaba {
  /**
   * AlibabaAuth contains a secretRef for credentials.
   *
   * @schema SecretStoreV1Beta1SpecProviderAlibaba#auth
   */
  readonly auth: SecretStoreV1Beta1SpecProviderAlibabaAuth;

  /**
   * Alibaba Region to be used for the provider
   *
   * @schema SecretStoreV1Beta1SpecProviderAlibaba#regionID
   */
  readonly regionId: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderAlibaba' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderAlibaba(
  obj: SecretStoreV1Beta1SpecProviderAlibaba | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    auth: toJson_SecretStoreV1Beta1SpecProviderAlibabaAuth(obj.auth),
    regionID: obj.regionId,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * AWS configures this store to sync secrets using AWS Secret Manager provider
 *
 * @schema SecretStoreV1Beta1SpecProviderAws
 */
export interface SecretStoreV1Beta1SpecProviderAws {
  /**
   * AdditionalRoles is a chained list of Role ARNs which the provider will sequentially assume before assuming the Role
   *
   * @schema SecretStoreV1Beta1SpecProviderAws#additionalRoles
   */
  readonly additionalRoles?: string[];

  /**
   * Auth defines the information necessary to authenticate against AWS if not set aws sdk will infer credentials from your environment see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
   *
   * @schema SecretStoreV1Beta1SpecProviderAws#auth
   */
  readonly auth?: SecretStoreV1Beta1SpecProviderAwsAuth;

  /**
   * AWS External ID set on assumed IAM roles
   *
   * @schema SecretStoreV1Beta1SpecProviderAws#externalID
   */
  readonly externalId?: string;

  /**
   * AWS Region to be used for the provider
   *
   * @schema SecretStoreV1Beta1SpecProviderAws#region
   */
  readonly region: string;

  /**
   * Role is a Role ARN which the provider will assume
   *
   * @schema SecretStoreV1Beta1SpecProviderAws#role
   */
  readonly role?: string;

  /**
   * SecretsManager defines how the provider behaves when interacting with AWS SecretsManager
   *
   * @schema SecretStoreV1Beta1SpecProviderAws#secretsManager
   */
  readonly secretsManager?: SecretStoreV1Beta1SpecProviderAwsSecretsManager;

  /**
   * Service defines which service should be used to fetch the secrets
   *
   * @schema SecretStoreV1Beta1SpecProviderAws#service
   */
  readonly service: SecretStoreV1Beta1SpecProviderAwsService;

  /**
   * AWS STS assume role session tags
   *
   * @schema SecretStoreV1Beta1SpecProviderAws#sessionTags
   */
  readonly sessionTags?: SecretStoreV1Beta1SpecProviderAwsSessionTags[];

  /**
   * AWS STS assume role transitive session tags. Required when multiple rules are used with the provider
   *
   * @schema SecretStoreV1Beta1SpecProviderAws#transitiveTagKeys
   */
  readonly transitiveTagKeys?: string[];
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderAws' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderAws(
  obj: SecretStoreV1Beta1SpecProviderAws | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    additionalRoles: obj.additionalRoles?.map((y) => y),
    auth: toJson_SecretStoreV1Beta1SpecProviderAwsAuth(obj.auth),
    externalID: obj.externalId,
    region: obj.region,
    role: obj.role,
    secretsManager: toJson_SecretStoreV1Beta1SpecProviderAwsSecretsManager(
      obj.secretsManager,
    ),
    service: obj.service,
    sessionTags: obj.sessionTags?.map((y) =>
      toJson_SecretStoreV1Beta1SpecProviderAwsSessionTags(y),
    ),
    transitiveTagKeys: obj.transitiveTagKeys?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * AzureKV configures this store to sync secrets using Azure Key Vault provider
 *
 * @schema SecretStoreV1Beta1SpecProviderAzurekv
 */
export interface SecretStoreV1Beta1SpecProviderAzurekv {
  /**
   * Auth configures how the operator authenticates with Azure. Required for ServicePrincipal auth type.
   *
   * @schema SecretStoreV1Beta1SpecProviderAzurekv#authSecretRef
   */
  readonly authSecretRef?: SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef;

  /**
   * Auth type defines how to authenticate to the keyvault service. Valid values are: - "ServicePrincipal" (default): Using a service principal (tenantId, clientId, clientSecret) - "ManagedIdentity": Using Managed Identity assigned to the pod (see aad-pod-identity)
   *
   * @schema SecretStoreV1Beta1SpecProviderAzurekv#authType
   */
  readonly authType?: SecretStoreV1Beta1SpecProviderAzurekvAuthType;

  /**
   * EnvironmentType specifies the Azure cloud environment endpoints to use for connecting and authenticating with Azure. By default it points to the public cloud AAD endpoint. The following endpoints are available, also see here: https://github.com/Azure/go-autorest/blob/main/autorest/azure/environments.go#L152 PublicCloud, USGovernmentCloud, ChinaCloud, GermanCloud
   *
   * @schema SecretStoreV1Beta1SpecProviderAzurekv#environmentType
   */
  readonly environmentType?: SecretStoreV1Beta1SpecProviderAzurekvEnvironmentType;

  /**
   * If multiple Managed Identity is assigned to the pod, you can select the one to be used
   *
   * @schema SecretStoreV1Beta1SpecProviderAzurekv#identityId
   */
  readonly identityId?: string;

  /**
   * ServiceAccountRef specified the service account that should be used when authenticating with WorkloadIdentity.
   *
   * @schema SecretStoreV1Beta1SpecProviderAzurekv#serviceAccountRef
   */
  readonly serviceAccountRef?: SecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef;

  /**
   * TenantID configures the Azure Tenant to send requests to. Required for ServicePrincipal auth type.
   *
   * @schema SecretStoreV1Beta1SpecProviderAzurekv#tenantId
   */
  readonly tenantId?: string;

  /**
   * Vault Url from which the secrets to be fetched from.
   *
   * @schema SecretStoreV1Beta1SpecProviderAzurekv#vaultUrl
   */
  readonly vaultUrl: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderAzurekv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderAzurekv(
  obj: SecretStoreV1Beta1SpecProviderAzurekv | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    authSecretRef: toJson_SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef(
      obj.authSecretRef,
    ),
    authType: obj.authType,
    environmentType: obj.environmentType,
    identityId: obj.identityId,
    serviceAccountRef:
      toJson_SecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef(
        obj.serviceAccountRef,
      ),
    tenantId: obj.tenantId,
    vaultUrl: obj.vaultUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Conjur configures this store to sync secrets using conjur provider
 *
 * @schema SecretStoreV1Beta1SpecProviderConjur
 */
export interface SecretStoreV1Beta1SpecProviderConjur {
  /**
   * @schema SecretStoreV1Beta1SpecProviderConjur#auth
   */
  readonly auth: SecretStoreV1Beta1SpecProviderConjurAuth;

  /**
   * @schema SecretStoreV1Beta1SpecProviderConjur#caBundle
   */
  readonly caBundle?: string;

  /**
   * Used to provide custom certificate authority (CA) certificates for a secret store. The CAProvider points to a Secret or ConfigMap resource that contains a PEM-encoded certificate.
   *
   * @schema SecretStoreV1Beta1SpecProviderConjur#caProvider
   */
  readonly caProvider?: SecretStoreV1Beta1SpecProviderConjurCaProvider;

  /**
   * @schema SecretStoreV1Beta1SpecProviderConjur#url
   */
  readonly url: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderConjur' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderConjur(
  obj: SecretStoreV1Beta1SpecProviderConjur | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    auth: toJson_SecretStoreV1Beta1SpecProviderConjurAuth(obj.auth),
    caBundle: obj.caBundle,
    caProvider: toJson_SecretStoreV1Beta1SpecProviderConjurCaProvider(
      obj.caProvider,
    ),
    url: obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Delinea DevOps Secrets Vault https://docs.delinea.com/online-help/products/devops-secrets-vault/current
 *
 * @schema SecretStoreV1Beta1SpecProviderDelinea
 */
export interface SecretStoreV1Beta1SpecProviderDelinea {
  /**
   * ClientID is the non-secret part of the credential.
   *
   * @schema SecretStoreV1Beta1SpecProviderDelinea#clientId
   */
  readonly clientId: SecretStoreV1Beta1SpecProviderDelineaClientId;

  /**
   * ClientSecret is the secret part of the credential.
   *
   * @schema SecretStoreV1Beta1SpecProviderDelinea#clientSecret
   */
  readonly clientSecret: SecretStoreV1Beta1SpecProviderDelineaClientSecret;

  /**
   * Tenant is the chosen hostname / site name.
   *
   * @schema SecretStoreV1Beta1SpecProviderDelinea#tenant
   */
  readonly tenant: string;

  /**
   * TLD is based on the server location that was chosen during provisioning. If unset, defaults to "com".
   *
   * @schema SecretStoreV1Beta1SpecProviderDelinea#tld
   */
  readonly tld?: string;

  /**
   * URLTemplate If unset, defaults to "https://%s.secretsvaultcloud.%s/v1/%s%s".
   *
   * @schema SecretStoreV1Beta1SpecProviderDelinea#urlTemplate
   */
  readonly urlTemplate?: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderDelinea' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderDelinea(
  obj: SecretStoreV1Beta1SpecProviderDelinea | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    clientId: toJson_SecretStoreV1Beta1SpecProviderDelineaClientId(
      obj.clientId,
    ),
    clientSecret: toJson_SecretStoreV1Beta1SpecProviderDelineaClientSecret(
      obj.clientSecret,
    ),
    tenant: obj.tenant,
    tld: obj.tld,
    urlTemplate: obj.urlTemplate,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Doppler configures this store to sync secrets using the Doppler provider
 *
 * @schema SecretStoreV1Beta1SpecProviderDoppler
 */
export interface SecretStoreV1Beta1SpecProviderDoppler {
  /**
   * Auth configures how the Operator authenticates with the Doppler API
   *
   * @schema SecretStoreV1Beta1SpecProviderDoppler#auth
   */
  readonly auth: SecretStoreV1Beta1SpecProviderDopplerAuth;

  /**
   * Doppler config (required if not using a Service Token)
   *
   * @schema SecretStoreV1Beta1SpecProviderDoppler#config
   */
  readonly config?: string;

  /**
   * Format enables the downloading of secrets as a file (string)
   *
   * @schema SecretStoreV1Beta1SpecProviderDoppler#format
   */
  readonly format?: SecretStoreV1Beta1SpecProviderDopplerFormat;

  /**
   * Environment variable compatible name transforms that change secret names to a different format
   *
   * @schema SecretStoreV1Beta1SpecProviderDoppler#nameTransformer
   */
  readonly nameTransformer?: SecretStoreV1Beta1SpecProviderDopplerNameTransformer;

  /**
   * Doppler project (required if not using a Service Token)
   *
   * @schema SecretStoreV1Beta1SpecProviderDoppler#project
   */
  readonly project?: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderDoppler' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderDoppler(
  obj: SecretStoreV1Beta1SpecProviderDoppler | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    auth: toJson_SecretStoreV1Beta1SpecProviderDopplerAuth(obj.auth),
    config: obj.config,
    format: obj.format,
    nameTransformer: obj.nameTransformer,
    project: obj.project,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Fake configures a store with static key/value pairs
 *
 * @schema SecretStoreV1Beta1SpecProviderFake
 */
export interface SecretStoreV1Beta1SpecProviderFake {
  /**
   * @schema SecretStoreV1Beta1SpecProviderFake#data
   */
  readonly data: SecretStoreV1Beta1SpecProviderFakeData[];
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderFake' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderFake(
  obj: SecretStoreV1Beta1SpecProviderFake | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    data: obj.data?.map((y) =>
      toJson_SecretStoreV1Beta1SpecProviderFakeData(y),
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * GCPSM configures this store to sync secrets using Google Cloud Platform Secret Manager provider
 *
 * @schema SecretStoreV1Beta1SpecProviderGcpsm
 */
export interface SecretStoreV1Beta1SpecProviderGcpsm {
  /**
   * Auth defines the information necessary to authenticate against GCP
   *
   * @schema SecretStoreV1Beta1SpecProviderGcpsm#auth
   */
  readonly auth?: SecretStoreV1Beta1SpecProviderGcpsmAuth;

  /**
   * ProjectID project where secret is located
   *
   * @schema SecretStoreV1Beta1SpecProviderGcpsm#projectID
   */
  readonly projectId?: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderGcpsm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderGcpsm(
  obj: SecretStoreV1Beta1SpecProviderGcpsm | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    auth: toJson_SecretStoreV1Beta1SpecProviderGcpsmAuth(obj.auth),
    projectID: obj.projectId,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * GitLab configures this store to sync secrets using GitLab Variables provider
 *
 * @schema SecretStoreV1Beta1SpecProviderGitlab
 */
export interface SecretStoreV1Beta1SpecProviderGitlab {
  /**
   * Auth configures how secret-manager authenticates with a GitLab instance.
   *
   * @schema SecretStoreV1Beta1SpecProviderGitlab#auth
   */
  readonly auth: SecretStoreV1Beta1SpecProviderGitlabAuth;

  /**
   * Environment environment_scope of gitlab CI/CD variables (Please see https://docs.gitlab.com/ee/ci/environments/#create-a-static-environment on how to create environments)
   *
   * @schema SecretStoreV1Beta1SpecProviderGitlab#environment
   */
  readonly environment?: string;

  /**
   * GroupIDs specify, which gitlab groups to pull secrets from. Group secrets are read from left to right followed by the project variables.
   *
   * @schema SecretStoreV1Beta1SpecProviderGitlab#groupIDs
   */
  readonly groupIDs?: string[];

  /**
   * InheritFromGroups specifies whether parent groups should be discovered and checked for secrets.
   *
   * @schema SecretStoreV1Beta1SpecProviderGitlab#inheritFromGroups
   */
  readonly inheritFromGroups?: boolean;

  /**
   * ProjectID specifies a project where secrets are located.
   *
   * @schema SecretStoreV1Beta1SpecProviderGitlab#projectID
   */
  readonly projectId?: string;

  /**
   * URL configures the GitLab instance URL. Defaults to https://gitlab.com/.
   *
   * @default https://gitlab.com/.
   * @schema SecretStoreV1Beta1SpecProviderGitlab#url
   */
  readonly url?: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderGitlab' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderGitlab(
  obj: SecretStoreV1Beta1SpecProviderGitlab | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    auth: toJson_SecretStoreV1Beta1SpecProviderGitlabAuth(obj.auth),
    environment: obj.environment,
    groupIDs: obj.groupIDs?.map((y) => y),
    inheritFromGroups: obj.inheritFromGroups,
    projectID: obj.projectId,
    url: obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * IBM configures this store to sync secrets using IBM Cloud provider
 *
 * @schema SecretStoreV1Beta1SpecProviderIbm
 */
export interface SecretStoreV1Beta1SpecProviderIbm {
  /**
   * Auth configures how secret-manager authenticates with the IBM secrets manager.
   *
   * @schema SecretStoreV1Beta1SpecProviderIbm#auth
   */
  readonly auth: SecretStoreV1Beta1SpecProviderIbmAuth;

  /**
   * ServiceURL is the Endpoint URL that is specific to the Secrets Manager service instance
   *
   * @schema SecretStoreV1Beta1SpecProviderIbm#serviceUrl
   */
  readonly serviceUrl?: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderIbm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderIbm(
  obj: SecretStoreV1Beta1SpecProviderIbm | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    auth: toJson_SecretStoreV1Beta1SpecProviderIbmAuth(obj.auth),
    serviceUrl: obj.serviceUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * KeeperSecurity configures this store to sync secrets using the KeeperSecurity provider
 *
 * @schema SecretStoreV1Beta1SpecProviderKeepersecurity
 */
export interface SecretStoreV1Beta1SpecProviderKeepersecurity {
  /**
   * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
   *
   * @schema SecretStoreV1Beta1SpecProviderKeepersecurity#authRef
   */
  readonly authRef: SecretStoreV1Beta1SpecProviderKeepersecurityAuthRef;

  /**
   * @schema SecretStoreV1Beta1SpecProviderKeepersecurity#folderID
   */
  readonly folderId: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderKeepersecurity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderKeepersecurity(
  obj: SecretStoreV1Beta1SpecProviderKeepersecurity | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    authRef: toJson_SecretStoreV1Beta1SpecProviderKeepersecurityAuthRef(
      obj.authRef,
    ),
    folderID: obj.folderId,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Kubernetes configures this store to sync secrets using a Kubernetes cluster provider
 *
 * @schema SecretStoreV1Beta1SpecProviderKubernetes
 */
export interface SecretStoreV1Beta1SpecProviderKubernetes {
  /**
   * Auth configures how secret-manager authenticates with a Kubernetes instance.
   *
   * @schema SecretStoreV1Beta1SpecProviderKubernetes#auth
   */
  readonly auth: SecretStoreV1Beta1SpecProviderKubernetesAuth;

  /**
   * Remote namespace to fetch the secrets from
   *
   * @schema SecretStoreV1Beta1SpecProviderKubernetes#remoteNamespace
   */
  readonly remoteNamespace?: string;

  /**
   * configures the Kubernetes server Address.
   *
   * @schema SecretStoreV1Beta1SpecProviderKubernetes#server
   */
  readonly server?: SecretStoreV1Beta1SpecProviderKubernetesServer;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderKubernetes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderKubernetes(
  obj: SecretStoreV1Beta1SpecProviderKubernetes | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    auth: toJson_SecretStoreV1Beta1SpecProviderKubernetesAuth(obj.auth),
    remoteNamespace: obj.remoteNamespace,
    server: toJson_SecretStoreV1Beta1SpecProviderKubernetesServer(obj.server),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * OnePassword configures this store to sync secrets using the 1Password Cloud provider
 *
 * @schema SecretStoreV1Beta1SpecProviderOnepassword
 */
export interface SecretStoreV1Beta1SpecProviderOnepassword {
  /**
   * Auth defines the information necessary to authenticate against OnePassword Connect Server
   *
   * @schema SecretStoreV1Beta1SpecProviderOnepassword#auth
   */
  readonly auth: SecretStoreV1Beta1SpecProviderOnepasswordAuth;

  /**
   * ConnectHost defines the OnePassword Connect Server to connect to
   *
   * @schema SecretStoreV1Beta1SpecProviderOnepassword#connectHost
   */
  readonly connectHost: string;

  /**
   * Vaults defines which OnePassword vaults to search in which order
   *
   * @schema SecretStoreV1Beta1SpecProviderOnepassword#vaults
   */
  readonly vaults: { [key: string]: number };
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderOnepassword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderOnepassword(
  obj: SecretStoreV1Beta1SpecProviderOnepassword | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    auth: toJson_SecretStoreV1Beta1SpecProviderOnepasswordAuth(obj.auth),
    connectHost: obj.connectHost,
    vaults:
      obj.vaults === undefined
        ? undefined
        : Object.entries(obj.vaults).reduce(
            (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
            {},
          ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Oracle configures this store to sync secrets using Oracle Vault provider
 *
 * @schema SecretStoreV1Beta1SpecProviderOracle
 */
export interface SecretStoreV1Beta1SpecProviderOracle {
  /**
   * Auth configures how secret-manager authenticates with the Oracle Vault. If empty, use the instance principal, otherwise the user credentials specified in Auth.
   *
   * @schema SecretStoreV1Beta1SpecProviderOracle#auth
   */
  readonly auth?: SecretStoreV1Beta1SpecProviderOracleAuth;

  /**
   * Compartment is the vault compartment OCID. Required for PushSecret
   *
   * @schema SecretStoreV1Beta1SpecProviderOracle#compartment
   */
  readonly compartment?: string;

  /**
   * EncryptionKey is the OCID of the encryption key within the vault. Required for PushSecret
   *
   * @schema SecretStoreV1Beta1SpecProviderOracle#encryptionKey
   */
  readonly encryptionKey?: string;

  /**
   * The type of principal to use for authentication. If left blank, the Auth struct will determine the principal type. This optional field must be specified if using workload identity.
   *
   * @schema SecretStoreV1Beta1SpecProviderOracle#principalType
   */
  readonly principalType?: SecretStoreV1Beta1SpecProviderOraclePrincipalType;

  /**
   * Region is the region where vault is located.
   *
   * @schema SecretStoreV1Beta1SpecProviderOracle#region
   */
  readonly region: string;

  /**
   * ServiceAccountRef specified the service account that should be used when authenticating with WorkloadIdentity.
   *
   * @schema SecretStoreV1Beta1SpecProviderOracle#serviceAccountRef
   */
  readonly serviceAccountRef?: SecretStoreV1Beta1SpecProviderOracleServiceAccountRef;

  /**
   * Vault is the vault's OCID of the specific vault where secret is located.
   *
   * @schema SecretStoreV1Beta1SpecProviderOracle#vault
   */
  readonly vault: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderOracle' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderOracle(
  obj: SecretStoreV1Beta1SpecProviderOracle | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    auth: toJson_SecretStoreV1Beta1SpecProviderOracleAuth(obj.auth),
    compartment: obj.compartment,
    encryptionKey: obj.encryptionKey,
    principalType: obj.principalType,
    region: obj.region,
    serviceAccountRef:
      toJson_SecretStoreV1Beta1SpecProviderOracleServiceAccountRef(
        obj.serviceAccountRef,
      ),
    vault: obj.vault,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Scaleway
 *
 * @schema SecretStoreV1Beta1SpecProviderScaleway
 */
export interface SecretStoreV1Beta1SpecProviderScaleway {
  /**
   * AccessKey is the non-secret part of the api key.
   *
   * @schema SecretStoreV1Beta1SpecProviderScaleway#accessKey
   */
  readonly accessKey: SecretStoreV1Beta1SpecProviderScalewayAccessKey;

  /**
   * APIURL is the url of the api to use. Defaults to https://api.scaleway.com
   *
   * @default https://api.scaleway.com
   * @schema SecretStoreV1Beta1SpecProviderScaleway#apiUrl
   */
  readonly apiUrl?: string;

  /**
   * ProjectID is the id of your project, which you can find in the console: https://console.scaleway.com/project/settings
   *
   * @schema SecretStoreV1Beta1SpecProviderScaleway#projectId
   */
  readonly projectId: string;

  /**
   * Region where your secrets are located: https://developers.scaleway.com/en/quickstart/#region-and-zone
   *
   * @schema SecretStoreV1Beta1SpecProviderScaleway#region
   */
  readonly region: string;

  /**
   * SecretKey is the non-secret part of the api key.
   *
   * @schema SecretStoreV1Beta1SpecProviderScaleway#secretKey
   */
  readonly secretKey: SecretStoreV1Beta1SpecProviderScalewaySecretKey;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderScaleway' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderScaleway(
  obj: SecretStoreV1Beta1SpecProviderScaleway | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    accessKey: toJson_SecretStoreV1Beta1SpecProviderScalewayAccessKey(
      obj.accessKey,
    ),
    apiUrl: obj.apiUrl,
    projectId: obj.projectId,
    region: obj.region,
    secretKey: toJson_SecretStoreV1Beta1SpecProviderScalewaySecretKey(
      obj.secretKey,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Senhasegura configures this store to sync secrets using senhasegura provider
 *
 * @schema SecretStoreV1Beta1SpecProviderSenhasegura
 */
export interface SecretStoreV1Beta1SpecProviderSenhasegura {
  /**
   * Auth defines parameters to authenticate in senhasegura
   *
   * @schema SecretStoreV1Beta1SpecProviderSenhasegura#auth
   */
  readonly auth: SecretStoreV1Beta1SpecProviderSenhaseguraAuth;

  /**
   * IgnoreSslCertificate defines if SSL certificate must be ignored
   *
   * @schema SecretStoreV1Beta1SpecProviderSenhasegura#ignoreSslCertificate
   */
  readonly ignoreSslCertificate?: boolean;

  /**
   * Module defines which senhasegura module should be used to get secrets
   *
   * @schema SecretStoreV1Beta1SpecProviderSenhasegura#module
   */
  readonly module: string;

  /**
   * URL of senhasegura
   *
   * @schema SecretStoreV1Beta1SpecProviderSenhasegura#url
   */
  readonly url: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderSenhasegura' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderSenhasegura(
  obj: SecretStoreV1Beta1SpecProviderSenhasegura | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    auth: toJson_SecretStoreV1Beta1SpecProviderSenhaseguraAuth(obj.auth),
    ignoreSslCertificate: obj.ignoreSslCertificate,
    module: obj.module,
    url: obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Vault configures this store to sync secrets using Hashi provider
 *
 * @schema SecretStoreV1Beta1SpecProviderVault
 */
export interface SecretStoreV1Beta1SpecProviderVault {
  /**
   * Auth configures how secret-manager authenticates with the Vault server.
   *
   * @schema SecretStoreV1Beta1SpecProviderVault#auth
   */
  readonly auth: SecretStoreV1Beta1SpecProviderVaultAuth;

  /**
   * PEM encoded CA bundle used to validate Vault server certificate. Only used if the Server URL is using HTTPS protocol. This parameter is ignored for plain HTTP protocol connection. If not set the system root certificates are used to validate the TLS connection.
   *
   * @schema SecretStoreV1Beta1SpecProviderVault#caBundle
   */
  readonly caBundle?: string;

  /**
   * The provider for the CA bundle to use to validate Vault server certificate.
   *
   * @schema SecretStoreV1Beta1SpecProviderVault#caProvider
   */
  readonly caProvider?: SecretStoreV1Beta1SpecProviderVaultCaProvider;

  /**
   * ForwardInconsistent tells Vault to forward read-after-write requests to the Vault leader instead of simply retrying within a loop. This can increase performance if the option is enabled serverside. https://www.vaultproject.io/docs/configuration/replication#allow_forwarding_via_header
   *
   * @schema SecretStoreV1Beta1SpecProviderVault#forwardInconsistent
   */
  readonly forwardInconsistent?: boolean;

  /**
   * Name of the vault namespace. Namespaces is a set of features within Vault Enterprise that allows Vault environments to support Secure Multi-tenancy. e.g: "ns1". More about namespaces can be found here https://www.vaultproject.io/docs/enterprise/namespaces
   *
   * @schema SecretStoreV1Beta1SpecProviderVault#namespace
   */
  readonly namespace?: string;

  /**
   * Path is the mount path of the Vault KV backend endpoint, e.g: "secret". The v2 KV secret engine version specific "/data" path suffix for fetching secrets from Vault is optional and will be appended if not present in specified path.
   *
   * @schema SecretStoreV1Beta1SpecProviderVault#path
   */
  readonly path?: string;

  /**
   * ReadYourWrites ensures isolated read-after-write semantics by providing discovered cluster replication states in each request. More information about eventual consistency in Vault can be found here https://www.vaultproject.io/docs/enterprise/consistency
   *
   * @schema SecretStoreV1Beta1SpecProviderVault#readYourWrites
   */
  readonly readYourWrites?: boolean;

  /**
   * Server is the connection address for the Vault server, e.g: "https://vault.example.com:8200".
   *
   * @schema SecretStoreV1Beta1SpecProviderVault#server
   */
  readonly server: string;

  /**
   * Version is the Vault KV secret engine version. This can be either "v1" or "v2". Version defaults to "v2".
   *
   * @schema SecretStoreV1Beta1SpecProviderVault#version
   */
  readonly version?: SecretStoreV1Beta1SpecProviderVaultVersion;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderVault' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderVault(
  obj: SecretStoreV1Beta1SpecProviderVault | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    auth: toJson_SecretStoreV1Beta1SpecProviderVaultAuth(obj.auth),
    caBundle: obj.caBundle,
    caProvider: toJson_SecretStoreV1Beta1SpecProviderVaultCaProvider(
      obj.caProvider,
    ),
    forwardInconsistent: obj.forwardInconsistent,
    namespace: obj.namespace,
    path: obj.path,
    readYourWrites: obj.readYourWrites,
    server: obj.server,
    version: obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Webhook configures this store to sync secrets using a generic templated webhook
 *
 * @schema SecretStoreV1Beta1SpecProviderWebhook
 */
export interface SecretStoreV1Beta1SpecProviderWebhook {
  /**
   * Body
   *
   * @schema SecretStoreV1Beta1SpecProviderWebhook#body
   */
  readonly body?: string;

  /**
   * PEM encoded CA bundle used to validate webhook server certificate. Only used if the Server URL is using HTTPS protocol. This parameter is ignored for plain HTTP protocol connection. If not set the system root certificates are used to validate the TLS connection.
   *
   * @schema SecretStoreV1Beta1SpecProviderWebhook#caBundle
   */
  readonly caBundle?: string;

  /**
   * The provider for the CA bundle to use to validate webhook server certificate.
   *
   * @schema SecretStoreV1Beta1SpecProviderWebhook#caProvider
   */
  readonly caProvider?: SecretStoreV1Beta1SpecProviderWebhookCaProvider;

  /**
   * Headers
   *
   * @schema SecretStoreV1Beta1SpecProviderWebhook#headers
   */
  readonly headers?: { [key: string]: string };

  /**
   * Webhook Method
   *
   * @schema SecretStoreV1Beta1SpecProviderWebhook#method
   */
  readonly method?: string;

  /**
   * Result formatting
   *
   * @schema SecretStoreV1Beta1SpecProviderWebhook#result
   */
  readonly result: SecretStoreV1Beta1SpecProviderWebhookResult;

  /**
   * Secrets to fill in templates These secrets will be passed to the templating function as key value pairs under the given name
   *
   * @schema SecretStoreV1Beta1SpecProviderWebhook#secrets
   */
  readonly secrets?: SecretStoreV1Beta1SpecProviderWebhookSecrets[];

  /**
   * Timeout
   *
   * @schema SecretStoreV1Beta1SpecProviderWebhook#timeout
   */
  readonly timeout?: string;

  /**
   * Webhook url to call
   *
   * @schema SecretStoreV1Beta1SpecProviderWebhook#url
   */
  readonly url: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderWebhook' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderWebhook(
  obj: SecretStoreV1Beta1SpecProviderWebhook | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    body: obj.body,
    caBundle: obj.caBundle,
    caProvider: toJson_SecretStoreV1Beta1SpecProviderWebhookCaProvider(
      obj.caProvider,
    ),
    headers:
      obj.headers === undefined
        ? undefined
        : Object.entries(obj.headers).reduce(
            (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
            {},
          ),
    method: obj.method,
    result: toJson_SecretStoreV1Beta1SpecProviderWebhookResult(obj.result),
    secrets: obj.secrets?.map((y) =>
      toJson_SecretStoreV1Beta1SpecProviderWebhookSecrets(y),
    ),
    timeout: obj.timeout,
    url: obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * YandexCertificateManager configures this store to sync secrets using Yandex Certificate Manager provider
 *
 * @schema SecretStoreV1Beta1SpecProviderYandexcertificatemanager
 */
export interface SecretStoreV1Beta1SpecProviderYandexcertificatemanager {
  /**
   * Yandex.Cloud API endpoint (e.g. 'api.cloud.yandex.net:443')
   *
   * @schema SecretStoreV1Beta1SpecProviderYandexcertificatemanager#apiEndpoint
   */
  readonly apiEndpoint?: string;

  /**
   * Auth defines the information necessary to authenticate against Yandex Certificate Manager
   *
   * @schema SecretStoreV1Beta1SpecProviderYandexcertificatemanager#auth
   */
  readonly auth: SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth;

  /**
   * The provider for the CA bundle to use to validate Yandex.Cloud server certificate.
   *
   * @schema SecretStoreV1Beta1SpecProviderYandexcertificatemanager#caProvider
   */
  readonly caProvider?: SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderYandexcertificatemanager' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderYandexcertificatemanager(
  obj: SecretStoreV1Beta1SpecProviderYandexcertificatemanager | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    apiEndpoint: obj.apiEndpoint,
    auth: toJson_SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth(
      obj.auth,
    ),
    caProvider:
      toJson_SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider(
        obj.caProvider,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * YandexLockbox configures this store to sync secrets using Yandex Lockbox provider
 *
 * @schema SecretStoreV1Beta1SpecProviderYandexlockbox
 */
export interface SecretStoreV1Beta1SpecProviderYandexlockbox {
  /**
   * Yandex.Cloud API endpoint (e.g. 'api.cloud.yandex.net:443')
   *
   * @schema SecretStoreV1Beta1SpecProviderYandexlockbox#apiEndpoint
   */
  readonly apiEndpoint?: string;

  /**
   * Auth defines the information necessary to authenticate against Yandex Lockbox
   *
   * @schema SecretStoreV1Beta1SpecProviderYandexlockbox#auth
   */
  readonly auth: SecretStoreV1Beta1SpecProviderYandexlockboxAuth;

  /**
   * The provider for the CA bundle to use to validate Yandex.Cloud server certificate.
   *
   * @schema SecretStoreV1Beta1SpecProviderYandexlockbox#caProvider
   */
  readonly caProvider?: SecretStoreV1Beta1SpecProviderYandexlockboxCaProvider;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderYandexlockbox' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderYandexlockbox(
  obj: SecretStoreV1Beta1SpecProviderYandexlockbox | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    apiEndpoint: obj.apiEndpoint,
    auth: toJson_SecretStoreV1Beta1SpecProviderYandexlockboxAuth(obj.auth),
    caProvider: toJson_SecretStoreV1Beta1SpecProviderYandexlockboxCaProvider(
      obj.caProvider,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema SecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions
 */
export interface SecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema SecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema SecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema SecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions(
  obj:
    | SecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Auth configures how the operator authenticates with Akeyless.
 *
 * @schema SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef {
  /**
   * Kubernetes authenticates with Akeyless by passing the ServiceAccount token stored in the named Secret resource.
   *
   * @schema SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef#kubernetesAuth
   */
  readonly kubernetesAuth?: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth;

  /**
   * Reference to a Secret that contains the details to authenticate with Akeyless.
   *
   * @schema SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef#secretRef
   */
  readonly secretRef?: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef(
  obj: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    kubernetesAuth:
      toJson_SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth(
        obj.kubernetesAuth,
      ),
    secretRef:
      toJson_SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef(
        obj.secretRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The provider for the CA bundle to use to validate Akeyless Gateway certificate.
 *
 * @schema SecretStoreV1Beta1SpecProviderAkeylessCaProvider
 */
export interface SecretStoreV1Beta1SpecProviderAkeylessCaProvider {
  /**
   * The key where the CA certificate can be found in the Secret or ConfigMap.
   *
   * @schema SecretStoreV1Beta1SpecProviderAkeylessCaProvider#key
   */
  readonly key?: string;

  /**
   * The name of the object located at the provider type.
   *
   * @schema SecretStoreV1Beta1SpecProviderAkeylessCaProvider#name
   */
  readonly name: string;

  /**
   * The namespace the Provider type is in. Can only be defined when used in a ClusterSecretStore.
   *
   * @schema SecretStoreV1Beta1SpecProviderAkeylessCaProvider#namespace
   */
  readonly namespace?: string;

  /**
   * The type of provider to use such as "Secret", or "ConfigMap".
   *
   * @schema SecretStoreV1Beta1SpecProviderAkeylessCaProvider#type
   */
  readonly type: SecretStoreV1Beta1SpecProviderAkeylessCaProviderType;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderAkeylessCaProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderAkeylessCaProvider(
  obj: SecretStoreV1Beta1SpecProviderAkeylessCaProvider | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
    type: obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * AlibabaAuth contains a secretRef for credentials.
 *
 * @schema SecretStoreV1Beta1SpecProviderAlibabaAuth
 */
export interface SecretStoreV1Beta1SpecProviderAlibabaAuth {
  /**
   * Authenticate against Alibaba using RRSA.
   *
   * @schema SecretStoreV1Beta1SpecProviderAlibabaAuth#rrsa
   */
  readonly rrsa?: SecretStoreV1Beta1SpecProviderAlibabaAuthRrsa;

  /**
   * AlibabaAuthSecretRef holds secret references for Alibaba credentials.
   *
   * @schema SecretStoreV1Beta1SpecProviderAlibabaAuth#secretRef
   */
  readonly secretRef?: SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderAlibabaAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderAlibabaAuth(
  obj: SecretStoreV1Beta1SpecProviderAlibabaAuth | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    rrsa: toJson_SecretStoreV1Beta1SpecProviderAlibabaAuthRrsa(obj.rrsa),
    secretRef: toJson_SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef(
      obj.secretRef,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Auth defines the information necessary to authenticate against AWS if not set aws sdk will infer credentials from your environment see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
 *
 * @schema SecretStoreV1Beta1SpecProviderAwsAuth
 */
export interface SecretStoreV1Beta1SpecProviderAwsAuth {
  /**
   * Authenticate against AWS using service account tokens.
   *
   * @schema SecretStoreV1Beta1SpecProviderAwsAuth#jwt
   */
  readonly jwt?: SecretStoreV1Beta1SpecProviderAwsAuthJwt;

  /**
   * AWSAuthSecretRef holds secret references for AWS credentials both AccessKeyID and SecretAccessKey must be defined in order to properly authenticate.
   *
   * @schema SecretStoreV1Beta1SpecProviderAwsAuth#secretRef
   */
  readonly secretRef?: SecretStoreV1Beta1SpecProviderAwsAuthSecretRef;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderAwsAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderAwsAuth(
  obj: SecretStoreV1Beta1SpecProviderAwsAuth | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    jwt: toJson_SecretStoreV1Beta1SpecProviderAwsAuthJwt(obj.jwt),
    secretRef: toJson_SecretStoreV1Beta1SpecProviderAwsAuthSecretRef(
      obj.secretRef,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * SecretsManager defines how the provider behaves when interacting with AWS SecretsManager
 *
 * @schema SecretStoreV1Beta1SpecProviderAwsSecretsManager
 */
export interface SecretStoreV1Beta1SpecProviderAwsSecretsManager {
  /**
   * Specifies whether to delete the secret without any recovery window. You can't use both this parameter and RecoveryWindowInDays in the same call. If you don't use either, then by default Secrets Manager uses a 30 day recovery window. see: https://docs.aws.amazon.com/secretsmanager/latest/apireference/API_DeleteSecret.html#SecretsManager-DeleteSecret-request-ForceDeleteWithoutRecovery
   *
   * @schema SecretStoreV1Beta1SpecProviderAwsSecretsManager#forceDeleteWithoutRecovery
   */
  readonly forceDeleteWithoutRecovery?: boolean;

  /**
   * The number of days from 7 to 30 that Secrets Manager waits before permanently deleting the secret. You can't use both this parameter and ForceDeleteWithoutRecovery in the same call. If you don't use either, then by default Secrets Manager uses a 30 day recovery window. see: https://docs.aws.amazon.com/secretsmanager/latest/apireference/API_DeleteSecret.html#SecretsManager-DeleteSecret-request-RecoveryWindowInDays
   *
   * @schema SecretStoreV1Beta1SpecProviderAwsSecretsManager#recoveryWindowInDays
   */
  readonly recoveryWindowInDays?: number;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderAwsSecretsManager' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderAwsSecretsManager(
  obj: SecretStoreV1Beta1SpecProviderAwsSecretsManager | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    forceDeleteWithoutRecovery: obj.forceDeleteWithoutRecovery,
    recoveryWindowInDays: obj.recoveryWindowInDays,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Service defines which service should be used to fetch the secrets
 *
 * @schema SecretStoreV1Beta1SpecProviderAwsService
 */
export enum SecretStoreV1Beta1SpecProviderAwsService {
  /** SecretsManager */
  SECRETS_MANAGER = "SecretsManager",
  /** ParameterStore */
  PARAMETER_STORE = "ParameterStore",
}

/**
 * @schema SecretStoreV1Beta1SpecProviderAwsSessionTags
 */
export interface SecretStoreV1Beta1SpecProviderAwsSessionTags {
  /**
   * @schema SecretStoreV1Beta1SpecProviderAwsSessionTags#key
   */
  readonly key: string;

  /**
   * @schema SecretStoreV1Beta1SpecProviderAwsSessionTags#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderAwsSessionTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderAwsSessionTags(
  obj: SecretStoreV1Beta1SpecProviderAwsSessionTags | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Auth configures how the operator authenticates with Azure. Required for ServicePrincipal auth type.
 *
 * @schema SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef {
  /**
   * The Azure clientId of the service principle used for authentication.
   *
   * @schema SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef#clientId
   */
  readonly clientId?: SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId;

  /**
   * The Azure ClientSecret of the service principle used for authentication.
   *
   * @schema SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef#clientSecret
   */
  readonly clientSecret?: SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef(
  obj: SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    clientId: toJson_SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId(
      obj.clientId,
    ),
    clientSecret:
      toJson_SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret(
        obj.clientSecret,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Auth type defines how to authenticate to the keyvault service. Valid values are: - "ServicePrincipal" (default): Using a service principal (tenantId, clientId, clientSecret) - "ManagedIdentity": Using Managed Identity assigned to the pod (see aad-pod-identity)
 *
 * @schema SecretStoreV1Beta1SpecProviderAzurekvAuthType
 */
export enum SecretStoreV1Beta1SpecProviderAzurekvAuthType {
  /** ServicePrincipal */
  SERVICE_PRINCIPAL = "ServicePrincipal",
  /** ManagedIdentity */
  MANAGED_IDENTITY = "ManagedIdentity",
  /** WorkloadIdentity */
  WORKLOAD_IDENTITY = "WorkloadIdentity",
}

/**
 * EnvironmentType specifies the Azure cloud environment endpoints to use for connecting and authenticating with Azure. By default it points to the public cloud AAD endpoint. The following endpoints are available, also see here: https://github.com/Azure/go-autorest/blob/main/autorest/azure/environments.go#L152 PublicCloud, USGovernmentCloud, ChinaCloud, GermanCloud
 *
 * @schema SecretStoreV1Beta1SpecProviderAzurekvEnvironmentType
 */
export enum SecretStoreV1Beta1SpecProviderAzurekvEnvironmentType {
  /** PublicCloud */
  PUBLIC_CLOUD = "PublicCloud",
  /** USGovernmentCloud */
  US_GOVERNMENT_CLOUD = "USGovernmentCloud",
  /** ChinaCloud */
  CHINA_CLOUD = "ChinaCloud",
  /** GermanCloud */
  GERMAN_CLOUD = "GermanCloud",
}

/**
 * ServiceAccountRef specified the service account that should be used when authenticating with WorkloadIdentity.
 *
 * @schema SecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef
 */
export interface SecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
   *
   * @schema SecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef(
  obj: SecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    audiences: obj.audiences?.map((y) => y),
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SecretStoreV1Beta1SpecProviderConjurAuth
 */
export interface SecretStoreV1Beta1SpecProviderConjurAuth {
  /**
   * @schema SecretStoreV1Beta1SpecProviderConjurAuth#apikey
   */
  readonly apikey?: SecretStoreV1Beta1SpecProviderConjurAuthApikey;

  /**
   * @schema SecretStoreV1Beta1SpecProviderConjurAuth#jwt
   */
  readonly jwt?: SecretStoreV1Beta1SpecProviderConjurAuthJwt;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderConjurAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderConjurAuth(
  obj: SecretStoreV1Beta1SpecProviderConjurAuth | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    apikey: toJson_SecretStoreV1Beta1SpecProviderConjurAuthApikey(obj.apikey),
    jwt: toJson_SecretStoreV1Beta1SpecProviderConjurAuthJwt(obj.jwt),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Used to provide custom certificate authority (CA) certificates for a secret store. The CAProvider points to a Secret or ConfigMap resource that contains a PEM-encoded certificate.
 *
 * @schema SecretStoreV1Beta1SpecProviderConjurCaProvider
 */
export interface SecretStoreV1Beta1SpecProviderConjurCaProvider {
  /**
   * The key where the CA certificate can be found in the Secret or ConfigMap.
   *
   * @schema SecretStoreV1Beta1SpecProviderConjurCaProvider#key
   */
  readonly key?: string;

  /**
   * The name of the object located at the provider type.
   *
   * @schema SecretStoreV1Beta1SpecProviderConjurCaProvider#name
   */
  readonly name: string;

  /**
   * The namespace the Provider type is in. Can only be defined when used in a ClusterSecretStore.
   *
   * @schema SecretStoreV1Beta1SpecProviderConjurCaProvider#namespace
   */
  readonly namespace?: string;

  /**
   * The type of provider to use such as "Secret", or "ConfigMap".
   *
   * @schema SecretStoreV1Beta1SpecProviderConjurCaProvider#type
   */
  readonly type: SecretStoreV1Beta1SpecProviderConjurCaProviderType;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderConjurCaProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderConjurCaProvider(
  obj: SecretStoreV1Beta1SpecProviderConjurCaProvider | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
    type: obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ClientID is the non-secret part of the credential.
 *
 * @schema SecretStoreV1Beta1SpecProviderDelineaClientId
 */
export interface SecretStoreV1Beta1SpecProviderDelineaClientId {
  /**
   * SecretRef references a key in a secret that will be used as value.
   *
   * @schema SecretStoreV1Beta1SpecProviderDelineaClientId#secretRef
   */
  readonly secretRef?: SecretStoreV1Beta1SpecProviderDelineaClientIdSecretRef;

  /**
   * Value can be specified directly to set a value without using a secret.
   *
   * @schema SecretStoreV1Beta1SpecProviderDelineaClientId#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderDelineaClientId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderDelineaClientId(
  obj: SecretStoreV1Beta1SpecProviderDelineaClientId | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    secretRef: toJson_SecretStoreV1Beta1SpecProviderDelineaClientIdSecretRef(
      obj.secretRef,
    ),
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ClientSecret is the secret part of the credential.
 *
 * @schema SecretStoreV1Beta1SpecProviderDelineaClientSecret
 */
export interface SecretStoreV1Beta1SpecProviderDelineaClientSecret {
  /**
   * SecretRef references a key in a secret that will be used as value.
   *
   * @schema SecretStoreV1Beta1SpecProviderDelineaClientSecret#secretRef
   */
  readonly secretRef?: SecretStoreV1Beta1SpecProviderDelineaClientSecretSecretRef;

  /**
   * Value can be specified directly to set a value without using a secret.
   *
   * @schema SecretStoreV1Beta1SpecProviderDelineaClientSecret#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderDelineaClientSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderDelineaClientSecret(
  obj: SecretStoreV1Beta1SpecProviderDelineaClientSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    secretRef:
      toJson_SecretStoreV1Beta1SpecProviderDelineaClientSecretSecretRef(
        obj.secretRef,
      ),
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Auth configures how the Operator authenticates with the Doppler API
 *
 * @schema SecretStoreV1Beta1SpecProviderDopplerAuth
 */
export interface SecretStoreV1Beta1SpecProviderDopplerAuth {
  /**
   * @schema SecretStoreV1Beta1SpecProviderDopplerAuth#secretRef
   */
  readonly secretRef: SecretStoreV1Beta1SpecProviderDopplerAuthSecretRef;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderDopplerAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderDopplerAuth(
  obj: SecretStoreV1Beta1SpecProviderDopplerAuth | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    secretRef: toJson_SecretStoreV1Beta1SpecProviderDopplerAuthSecretRef(
      obj.secretRef,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Format enables the downloading of secrets as a file (string)
 *
 * @schema SecretStoreV1Beta1SpecProviderDopplerFormat
 */
export enum SecretStoreV1Beta1SpecProviderDopplerFormat {
  /** json */
  JSON = "json",
  /** dotnet-json */
  DOTNET_HYPHEN_JSON = "dotnet-json",
  /** env */
  ENV = "env",
  /** yaml */
  YAML = "yaml",
  /** docker */
  DOCKER = "docker",
}

/**
 * Environment variable compatible name transforms that change secret names to a different format
 *
 * @schema SecretStoreV1Beta1SpecProviderDopplerNameTransformer
 */
export enum SecretStoreV1Beta1SpecProviderDopplerNameTransformer {
  /** upper-camel */
  UPPER_HYPHEN_CAMEL = "upper-camel",
  /** camel */
  CAMEL = "camel",
  /** lower-snake */
  LOWER_HYPHEN_SNAKE = "lower-snake",
  /** tf-var */
  TF_HYPHEN_VAR = "tf-var",
  /** dotnet-env */
  DOTNET_HYPHEN_ENV = "dotnet-env",
  /** lower-kebab */
  LOWER_HYPHEN_KEBAB = "lower-kebab",
}

/**
 * @schema SecretStoreV1Beta1SpecProviderFakeData
 */
export interface SecretStoreV1Beta1SpecProviderFakeData {
  /**
   * @schema SecretStoreV1Beta1SpecProviderFakeData#key
   */
  readonly key: string;

  /**
   * @schema SecretStoreV1Beta1SpecProviderFakeData#value
   */
  readonly value?: string;

  /**
   * Deprecated: ValueMap is deprecated and is intended to be removed in the future, use the `value` field instead.
   *
   * @schema SecretStoreV1Beta1SpecProviderFakeData#valueMap
   */
  readonly valueMap?: { [key: string]: string };

  /**
   * @schema SecretStoreV1Beta1SpecProviderFakeData#version
   */
  readonly version?: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderFakeData' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderFakeData(
  obj: SecretStoreV1Beta1SpecProviderFakeData | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    value: obj.value,
    valueMap:
      obj.valueMap === undefined
        ? undefined
        : Object.entries(obj.valueMap).reduce(
            (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
            {},
          ),
    version: obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Auth defines the information necessary to authenticate against GCP
 *
 * @schema SecretStoreV1Beta1SpecProviderGcpsmAuth
 */
export interface SecretStoreV1Beta1SpecProviderGcpsmAuth {
  /**
   * @schema SecretStoreV1Beta1SpecProviderGcpsmAuth#secretRef
   */
  readonly secretRef?: SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef;

  /**
   * @schema SecretStoreV1Beta1SpecProviderGcpsmAuth#workloadIdentity
   */
  readonly workloadIdentity?: SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderGcpsmAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderGcpsmAuth(
  obj: SecretStoreV1Beta1SpecProviderGcpsmAuth | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    secretRef: toJson_SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef(
      obj.secretRef,
    ),
    workloadIdentity:
      toJson_SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity(
        obj.workloadIdentity,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Auth configures how secret-manager authenticates with a GitLab instance.
 *
 * @schema SecretStoreV1Beta1SpecProviderGitlabAuth
 */
export interface SecretStoreV1Beta1SpecProviderGitlabAuth {
  /**
   * @schema SecretStoreV1Beta1SpecProviderGitlabAuth#SecretRef
   */
  readonly secretRef: SecretStoreV1Beta1SpecProviderGitlabAuthSecretRef;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderGitlabAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderGitlabAuth(
  obj: SecretStoreV1Beta1SpecProviderGitlabAuth | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    SecretRef: toJson_SecretStoreV1Beta1SpecProviderGitlabAuthSecretRef(
      obj.secretRef,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Auth configures how secret-manager authenticates with the IBM secrets manager.
 *
 * @schema SecretStoreV1Beta1SpecProviderIbmAuth
 */
export interface SecretStoreV1Beta1SpecProviderIbmAuth {
  /**
   * IBM Container-based auth with IAM Trusted Profile.
   *
   * @schema SecretStoreV1Beta1SpecProviderIbmAuth#containerAuth
   */
  readonly containerAuth?: SecretStoreV1Beta1SpecProviderIbmAuthContainerAuth;

  /**
   * @schema SecretStoreV1Beta1SpecProviderIbmAuth#secretRef
   */
  readonly secretRef?: SecretStoreV1Beta1SpecProviderIbmAuthSecretRef;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderIbmAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderIbmAuth(
  obj: SecretStoreV1Beta1SpecProviderIbmAuth | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    containerAuth: toJson_SecretStoreV1Beta1SpecProviderIbmAuthContainerAuth(
      obj.containerAuth,
    ),
    secretRef: toJson_SecretStoreV1Beta1SpecProviderIbmAuthSecretRef(
      obj.secretRef,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
 *
 * @schema SecretStoreV1Beta1SpecProviderKeepersecurityAuthRef
 */
export interface SecretStoreV1Beta1SpecProviderKeepersecurityAuthRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderKeepersecurityAuthRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderKeepersecurityAuthRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderKeepersecurityAuthRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderKeepersecurityAuthRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderKeepersecurityAuthRef(
  obj: SecretStoreV1Beta1SpecProviderKeepersecurityAuthRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Auth configures how secret-manager authenticates with a Kubernetes instance.
 *
 * @schema SecretStoreV1Beta1SpecProviderKubernetesAuth
 */
export interface SecretStoreV1Beta1SpecProviderKubernetesAuth {
  /**
   * has both clientCert and clientKey as secretKeySelector
   *
   * @schema SecretStoreV1Beta1SpecProviderKubernetesAuth#cert
   */
  readonly cert?: SecretStoreV1Beta1SpecProviderKubernetesAuthCert;

  /**
   * points to a service account that should be used for authentication
   *
   * @schema SecretStoreV1Beta1SpecProviderKubernetesAuth#serviceAccount
   */
  readonly serviceAccount?: SecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount;

  /**
   * use static token to authenticate with
   *
   * @schema SecretStoreV1Beta1SpecProviderKubernetesAuth#token
   */
  readonly token?: SecretStoreV1Beta1SpecProviderKubernetesAuthToken;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderKubernetesAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderKubernetesAuth(
  obj: SecretStoreV1Beta1SpecProviderKubernetesAuth | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    cert: toJson_SecretStoreV1Beta1SpecProviderKubernetesAuthCert(obj.cert),
    serviceAccount:
      toJson_SecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount(
        obj.serviceAccount,
      ),
    token: toJson_SecretStoreV1Beta1SpecProviderKubernetesAuthToken(obj.token),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * configures the Kubernetes server Address.
 *
 * @schema SecretStoreV1Beta1SpecProviderKubernetesServer
 */
export interface SecretStoreV1Beta1SpecProviderKubernetesServer {
  /**
   * CABundle is a base64-encoded CA certificate
   *
   * @schema SecretStoreV1Beta1SpecProviderKubernetesServer#caBundle
   */
  readonly caBundle?: string;

  /**
   * see: https://external-secrets.io/v0.4.1/spec/#external-secrets.io/v1alpha1.CAProvider
   *
   * @schema SecretStoreV1Beta1SpecProviderKubernetesServer#caProvider
   */
  readonly caProvider?: SecretStoreV1Beta1SpecProviderKubernetesServerCaProvider;

  /**
   * configures the Kubernetes server Address.
   *
   * @schema SecretStoreV1Beta1SpecProviderKubernetesServer#url
   */
  readonly url?: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderKubernetesServer' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderKubernetesServer(
  obj: SecretStoreV1Beta1SpecProviderKubernetesServer | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    caBundle: obj.caBundle,
    caProvider: toJson_SecretStoreV1Beta1SpecProviderKubernetesServerCaProvider(
      obj.caProvider,
    ),
    url: obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Auth defines the information necessary to authenticate against OnePassword Connect Server
 *
 * @schema SecretStoreV1Beta1SpecProviderOnepasswordAuth
 */
export interface SecretStoreV1Beta1SpecProviderOnepasswordAuth {
  /**
   * OnePasswordAuthSecretRef holds secret references for 1Password credentials.
   *
   * @schema SecretStoreV1Beta1SpecProviderOnepasswordAuth#secretRef
   */
  readonly secretRef: SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderOnepasswordAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderOnepasswordAuth(
  obj: SecretStoreV1Beta1SpecProviderOnepasswordAuth | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    secretRef: toJson_SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef(
      obj.secretRef,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Auth configures how secret-manager authenticates with the Oracle Vault. If empty, use the instance principal, otherwise the user credentials specified in Auth.
 *
 * @schema SecretStoreV1Beta1SpecProviderOracleAuth
 */
export interface SecretStoreV1Beta1SpecProviderOracleAuth {
  /**
   * SecretRef to pass through sensitive information.
   *
   * @schema SecretStoreV1Beta1SpecProviderOracleAuth#secretRef
   */
  readonly secretRef: SecretStoreV1Beta1SpecProviderOracleAuthSecretRef;

  /**
   * Tenancy is the tenancy OCID where user is located.
   *
   * @schema SecretStoreV1Beta1SpecProviderOracleAuth#tenancy
   */
  readonly tenancy: string;

  /**
   * User is an access OCID specific to the account.
   *
   * @schema SecretStoreV1Beta1SpecProviderOracleAuth#user
   */
  readonly user: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderOracleAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderOracleAuth(
  obj: SecretStoreV1Beta1SpecProviderOracleAuth | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    secretRef: toJson_SecretStoreV1Beta1SpecProviderOracleAuthSecretRef(
      obj.secretRef,
    ),
    tenancy: obj.tenancy,
    user: obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The type of principal to use for authentication. If left blank, the Auth struct will determine the principal type. This optional field must be specified if using workload identity.
 *
 * @schema SecretStoreV1Beta1SpecProviderOraclePrincipalType
 */
export enum SecretStoreV1Beta1SpecProviderOraclePrincipalType {
  /** UserPrincipal */
  USER_PRINCIPAL = "UserPrincipal",
  /** InstancePrincipal */
  INSTANCE_PRINCIPAL = "InstancePrincipal",
  /** Workload */
  WORKLOAD = "Workload",
}

/**
 * ServiceAccountRef specified the service account that should be used when authenticating with WorkloadIdentity.
 *
 * @schema SecretStoreV1Beta1SpecProviderOracleServiceAccountRef
 */
export interface SecretStoreV1Beta1SpecProviderOracleServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
   *
   * @schema SecretStoreV1Beta1SpecProviderOracleServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderOracleServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderOracleServiceAccountRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderOracleServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderOracleServiceAccountRef(
  obj: SecretStoreV1Beta1SpecProviderOracleServiceAccountRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    audiences: obj.audiences?.map((y) => y),
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * AccessKey is the non-secret part of the api key.
 *
 * @schema SecretStoreV1Beta1SpecProviderScalewayAccessKey
 */
export interface SecretStoreV1Beta1SpecProviderScalewayAccessKey {
  /**
   * SecretRef references a key in a secret that will be used as value.
   *
   * @schema SecretStoreV1Beta1SpecProviderScalewayAccessKey#secretRef
   */
  readonly secretRef?: SecretStoreV1Beta1SpecProviderScalewayAccessKeySecretRef;

  /**
   * Value can be specified directly to set a value without using a secret.
   *
   * @schema SecretStoreV1Beta1SpecProviderScalewayAccessKey#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderScalewayAccessKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderScalewayAccessKey(
  obj: SecretStoreV1Beta1SpecProviderScalewayAccessKey | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    secretRef: toJson_SecretStoreV1Beta1SpecProviderScalewayAccessKeySecretRef(
      obj.secretRef,
    ),
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKey is the non-secret part of the api key.
 *
 * @schema SecretStoreV1Beta1SpecProviderScalewaySecretKey
 */
export interface SecretStoreV1Beta1SpecProviderScalewaySecretKey {
  /**
   * SecretRef references a key in a secret that will be used as value.
   *
   * @schema SecretStoreV1Beta1SpecProviderScalewaySecretKey#secretRef
   */
  readonly secretRef?: SecretStoreV1Beta1SpecProviderScalewaySecretKeySecretRef;

  /**
   * Value can be specified directly to set a value without using a secret.
   *
   * @schema SecretStoreV1Beta1SpecProviderScalewaySecretKey#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderScalewaySecretKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderScalewaySecretKey(
  obj: SecretStoreV1Beta1SpecProviderScalewaySecretKey | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    secretRef: toJson_SecretStoreV1Beta1SpecProviderScalewaySecretKeySecretRef(
      obj.secretRef,
    ),
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Auth defines parameters to authenticate in senhasegura
 *
 * @schema SecretStoreV1Beta1SpecProviderSenhaseguraAuth
 */
export interface SecretStoreV1Beta1SpecProviderSenhaseguraAuth {
  /**
   * @schema SecretStoreV1Beta1SpecProviderSenhaseguraAuth#clientId
   */
  readonly clientId: string;

  /**
   * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
   *
   * @schema SecretStoreV1Beta1SpecProviderSenhaseguraAuth#clientSecretSecretRef
   */
  readonly clientSecretSecretRef: SecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderSenhaseguraAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderSenhaseguraAuth(
  obj: SecretStoreV1Beta1SpecProviderSenhaseguraAuth | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    clientId: obj.clientId,
    clientSecretSecretRef:
      toJson_SecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef(
        obj.clientSecretSecretRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Auth configures how secret-manager authenticates with the Vault server.
 *
 * @schema SecretStoreV1Beta1SpecProviderVaultAuth
 */
export interface SecretStoreV1Beta1SpecProviderVaultAuth {
  /**
   * AppRole authenticates with Vault using the App Role auth mechanism, with the role and secret stored in a Kubernetes Secret resource.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuth#appRole
   */
  readonly appRole?: SecretStoreV1Beta1SpecProviderVaultAuthAppRole;

  /**
   * Cert authenticates with TLS Certificates by passing client certificate, private key and ca certificate Cert authentication method
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuth#cert
   */
  readonly cert?: SecretStoreV1Beta1SpecProviderVaultAuthCert;

  /**
   * Iam authenticates with vault by passing a special AWS request signed with AWS IAM credentials AWS IAM authentication method
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuth#iam
   */
  readonly iam?: SecretStoreV1Beta1SpecProviderVaultAuthIam;

  /**
   * Jwt authenticates with Vault by passing role and JWT token using the JWT/OIDC authentication method
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuth#jwt
   */
  readonly jwt?: SecretStoreV1Beta1SpecProviderVaultAuthJwt;

  /**
   * Kubernetes authenticates with Vault by passing the ServiceAccount token stored in the named Secret resource to the Vault server.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuth#kubernetes
   */
  readonly kubernetes?: SecretStoreV1Beta1SpecProviderVaultAuthKubernetes;

  /**
   * Ldap authenticates with Vault by passing username/password pair using the LDAP authentication method
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuth#ldap
   */
  readonly ldap?: SecretStoreV1Beta1SpecProviderVaultAuthLdap;

  /**
   * TokenSecretRef authenticates with Vault by presenting a token.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuth#tokenSecretRef
   */
  readonly tokenSecretRef?: SecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef;

  /**
   * UserPass authenticates with Vault by passing username/password pair
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuth#userPass
   */
  readonly userPass?: SecretStoreV1Beta1SpecProviderVaultAuthUserPass;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderVaultAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderVaultAuth(
  obj: SecretStoreV1Beta1SpecProviderVaultAuth | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    appRole: toJson_SecretStoreV1Beta1SpecProviderVaultAuthAppRole(obj.appRole),
    cert: toJson_SecretStoreV1Beta1SpecProviderVaultAuthCert(obj.cert),
    iam: toJson_SecretStoreV1Beta1SpecProviderVaultAuthIam(obj.iam),
    jwt: toJson_SecretStoreV1Beta1SpecProviderVaultAuthJwt(obj.jwt),
    kubernetes: toJson_SecretStoreV1Beta1SpecProviderVaultAuthKubernetes(
      obj.kubernetes,
    ),
    ldap: toJson_SecretStoreV1Beta1SpecProviderVaultAuthLdap(obj.ldap),
    tokenSecretRef:
      toJson_SecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef(
        obj.tokenSecretRef,
      ),
    userPass: toJson_SecretStoreV1Beta1SpecProviderVaultAuthUserPass(
      obj.userPass,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The provider for the CA bundle to use to validate Vault server certificate.
 *
 * @schema SecretStoreV1Beta1SpecProviderVaultCaProvider
 */
export interface SecretStoreV1Beta1SpecProviderVaultCaProvider {
  /**
   * The key where the CA certificate can be found in the Secret or ConfigMap.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultCaProvider#key
   */
  readonly key?: string;

  /**
   * The name of the object located at the provider type.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultCaProvider#name
   */
  readonly name: string;

  /**
   * The namespace the Provider type is in. Can only be defined when used in a ClusterSecretStore.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultCaProvider#namespace
   */
  readonly namespace?: string;

  /**
   * The type of provider to use such as "Secret", or "ConfigMap".
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultCaProvider#type
   */
  readonly type: SecretStoreV1Beta1SpecProviderVaultCaProviderType;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderVaultCaProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderVaultCaProvider(
  obj: SecretStoreV1Beta1SpecProviderVaultCaProvider | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
    type: obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Version is the Vault KV secret engine version. This can be either "v1" or "v2". Version defaults to "v2".
 *
 * @schema SecretStoreV1Beta1SpecProviderVaultVersion
 */
export enum SecretStoreV1Beta1SpecProviderVaultVersion {
  /** v1 */
  V1 = "v1",
  /** v2 */
  V2 = "v2",
}

/**
 * The provider for the CA bundle to use to validate webhook server certificate.
 *
 * @schema SecretStoreV1Beta1SpecProviderWebhookCaProvider
 */
export interface SecretStoreV1Beta1SpecProviderWebhookCaProvider {
  /**
   * The key the value inside of the provider type to use, only used with "Secret" type
   *
   * @schema SecretStoreV1Beta1SpecProviderWebhookCaProvider#key
   */
  readonly key?: string;

  /**
   * The name of the object located at the provider type.
   *
   * @schema SecretStoreV1Beta1SpecProviderWebhookCaProvider#name
   */
  readonly name: string;

  /**
   * The namespace the Provider type is in.
   *
   * @schema SecretStoreV1Beta1SpecProviderWebhookCaProvider#namespace
   */
  readonly namespace?: string;

  /**
   * The type of provider to use such as "Secret", or "ConfigMap".
   *
   * @schema SecretStoreV1Beta1SpecProviderWebhookCaProvider#type
   */
  readonly type: SecretStoreV1Beta1SpecProviderWebhookCaProviderType;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderWebhookCaProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderWebhookCaProvider(
  obj: SecretStoreV1Beta1SpecProviderWebhookCaProvider | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
    type: obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Result formatting
 *
 * @schema SecretStoreV1Beta1SpecProviderWebhookResult
 */
export interface SecretStoreV1Beta1SpecProviderWebhookResult {
  /**
   * Json path of return value
   *
   * @schema SecretStoreV1Beta1SpecProviderWebhookResult#jsonPath
   */
  readonly jsonPath?: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderWebhookResult' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderWebhookResult(
  obj: SecretStoreV1Beta1SpecProviderWebhookResult | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    jsonPath: obj.jsonPath,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SecretStoreV1Beta1SpecProviderWebhookSecrets
 */
export interface SecretStoreV1Beta1SpecProviderWebhookSecrets {
  /**
   * Name of this secret in templates
   *
   * @schema SecretStoreV1Beta1SpecProviderWebhookSecrets#name
   */
  readonly name: string;

  /**
   * Secret ref to fill in credentials
   *
   * @schema SecretStoreV1Beta1SpecProviderWebhookSecrets#secretRef
   */
  readonly secretRef: SecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderWebhookSecrets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderWebhookSecrets(
  obj: SecretStoreV1Beta1SpecProviderWebhookSecrets | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    secretRef: toJson_SecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef(
      obj.secretRef,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Auth defines the information necessary to authenticate against Yandex Certificate Manager
 *
 * @schema SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth
 */
export interface SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth {
  /**
   * The authorized key used for authentication
   *
   * @schema SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth#authorizedKeySecretRef
   */
  readonly authorizedKeySecretRef?: SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth(
  obj: SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    authorizedKeySecretRef:
      toJson_SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef(
        obj.authorizedKeySecretRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The provider for the CA bundle to use to validate Yandex.Cloud server certificate.
 *
 * @schema SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider
 */
export interface SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider {
  /**
   * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
   *
   * @schema SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider#certSecretRef
   */
  readonly certSecretRef?: SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider(
  obj:
    | SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    certSecretRef:
      toJson_SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef(
        obj.certSecretRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Auth defines the information necessary to authenticate against Yandex Lockbox
 *
 * @schema SecretStoreV1Beta1SpecProviderYandexlockboxAuth
 */
export interface SecretStoreV1Beta1SpecProviderYandexlockboxAuth {
  /**
   * The authorized key used for authentication
   *
   * @schema SecretStoreV1Beta1SpecProviderYandexlockboxAuth#authorizedKeySecretRef
   */
  readonly authorizedKeySecretRef?: SecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderYandexlockboxAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderYandexlockboxAuth(
  obj: SecretStoreV1Beta1SpecProviderYandexlockboxAuth | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    authorizedKeySecretRef:
      toJson_SecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef(
        obj.authorizedKeySecretRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The provider for the CA bundle to use to validate Yandex.Cloud server certificate.
 *
 * @schema SecretStoreV1Beta1SpecProviderYandexlockboxCaProvider
 */
export interface SecretStoreV1Beta1SpecProviderYandexlockboxCaProvider {
  /**
   * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
   *
   * @schema SecretStoreV1Beta1SpecProviderYandexlockboxCaProvider#certSecretRef
   */
  readonly certSecretRef?: SecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderYandexlockboxCaProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderYandexlockboxCaProvider(
  obj: SecretStoreV1Beta1SpecProviderYandexlockboxCaProvider | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    certSecretRef:
      toJson_SecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef(
        obj.certSecretRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Kubernetes authenticates with Akeyless by passing the ServiceAccount token stored in the named Secret resource.
 *
 * @schema SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth
 */
export interface SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth {
  /**
   * the Akeyless Kubernetes auth-method access-id
   *
   * @schema SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth#accessID
   */
  readonly accessId: string;

  /**
   * Kubernetes-auth configuration name in Akeyless-Gateway
   *
   * @schema SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth#k8sConfName
   */
  readonly k8SConfName: string;

  /**
   * Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Akeyless. If a name is specified without a key, `token` is the default. If one is not specified, the one bound to the controller will be used.
   *
   * @schema SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth#secretRef
   */
  readonly secretRef?: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef;

  /**
   * Optional service account field containing the name of a kubernetes ServiceAccount. If the service account is specified, the service account secret token JWT will be used for authenticating with Akeyless. If the service account selector is not supplied, the secretRef will be used instead.
   *
   * @schema SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth#serviceAccountRef
   */
  readonly serviceAccountRef?: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth(
  obj:
    | SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    accessID: obj.accessId,
    k8sConfName: obj.k8SConfName,
    secretRef:
      toJson_SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef(
        obj.secretRef,
      ),
    serviceAccountRef:
      toJson_SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef(
        obj.serviceAccountRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Secret that contains the details to authenticate with Akeyless.
 *
 * @schema SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef {
  /**
   * The SecretAccessID is used for authentication
   *
   * @schema SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef#accessID
   */
  readonly accessId?: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId;

  /**
   * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
   *
   * @schema SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef#accessType
   */
  readonly accessType?: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType;

  /**
   * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
   *
   * @schema SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef#accessTypeParam
   */
  readonly accessTypeParam?: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef(
  obj: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    accessID:
      toJson_SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId(
        obj.accessId,
      ),
    accessType:
      toJson_SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType(
        obj.accessType,
      ),
    accessTypeParam:
      toJson_SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam(
        obj.accessTypeParam,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The type of provider to use such as "Secret", or "ConfigMap".
 *
 * @schema SecretStoreV1Beta1SpecProviderAkeylessCaProviderType
 */
export enum SecretStoreV1Beta1SpecProviderAkeylessCaProviderType {
  /** Secret */
  SECRET = "Secret",
  /** ConfigMap */
  CONFIG_MAP = "ConfigMap",
}

/**
 * Authenticate against Alibaba using RRSA.
 *
 * @schema SecretStoreV1Beta1SpecProviderAlibabaAuthRrsa
 */
export interface SecretStoreV1Beta1SpecProviderAlibabaAuthRrsa {
  /**
   * @schema SecretStoreV1Beta1SpecProviderAlibabaAuthRrsa#oidcProviderArn
   */
  readonly oidcProviderArn: string;

  /**
   * @schema SecretStoreV1Beta1SpecProviderAlibabaAuthRrsa#oidcTokenFilePath
   */
  readonly oidcTokenFilePath: string;

  /**
   * @schema SecretStoreV1Beta1SpecProviderAlibabaAuthRrsa#roleArn
   */
  readonly roleArn: string;

  /**
   * @schema SecretStoreV1Beta1SpecProviderAlibabaAuthRrsa#sessionName
   */
  readonly sessionName: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderAlibabaAuthRrsa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderAlibabaAuthRrsa(
  obj: SecretStoreV1Beta1SpecProviderAlibabaAuthRrsa | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    oidcProviderArn: obj.oidcProviderArn,
    oidcTokenFilePath: obj.oidcTokenFilePath,
    roleArn: obj.roleArn,
    sessionName: obj.sessionName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * AlibabaAuthSecretRef holds secret references for Alibaba credentials.
 *
 * @schema SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef {
  /**
   * The AccessKeyID is used for authentication
   *
   * @schema SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef#accessKeyIDSecretRef
   */
  readonly accessKeyIdSecretRef: SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef;

  /**
   * The AccessKeySecret is used for authentication
   *
   * @schema SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef#accessKeySecretSecretRef
   */
  readonly accessKeySecretSecretRef: SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef(
  obj: SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    accessKeyIDSecretRef:
      toJson_SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef(
        obj.accessKeyIdSecretRef,
      ),
    accessKeySecretSecretRef:
      toJson_SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef(
        obj.accessKeySecretSecretRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Authenticate against AWS using service account tokens.
 *
 * @schema SecretStoreV1Beta1SpecProviderAwsAuthJwt
 */
export interface SecretStoreV1Beta1SpecProviderAwsAuthJwt {
  /**
   * A reference to a ServiceAccount resource.
   *
   * @schema SecretStoreV1Beta1SpecProviderAwsAuthJwt#serviceAccountRef
   */
  readonly serviceAccountRef?: SecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderAwsAuthJwt' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderAwsAuthJwt(
  obj: SecretStoreV1Beta1SpecProviderAwsAuthJwt | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    serviceAccountRef:
      toJson_SecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef(
        obj.serviceAccountRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * AWSAuthSecretRef holds secret references for AWS credentials both AccessKeyID and SecretAccessKey must be defined in order to properly authenticate.
 *
 * @schema SecretStoreV1Beta1SpecProviderAwsAuthSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderAwsAuthSecretRef {
  /**
   * The AccessKeyID is used for authentication
   *
   * @schema SecretStoreV1Beta1SpecProviderAwsAuthSecretRef#accessKeyIDSecretRef
   */
  readonly accessKeyIdSecretRef?: SecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef;

  /**
   * The SecretAccessKey is used for authentication
   *
   * @schema SecretStoreV1Beta1SpecProviderAwsAuthSecretRef#secretAccessKeySecretRef
   */
  readonly secretAccessKeySecretRef?: SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef;

  /**
   * The SessionToken used for authentication This must be defined if AccessKeyID and SecretAccessKey are temporary credentials see: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_use-resources.html
   *
   * @schema SecretStoreV1Beta1SpecProviderAwsAuthSecretRef#sessionTokenSecretRef
   */
  readonly sessionTokenSecretRef?: SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSessionTokenSecretRef;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderAwsAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderAwsAuthSecretRef(
  obj: SecretStoreV1Beta1SpecProviderAwsAuthSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    accessKeyIDSecretRef:
      toJson_SecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef(
        obj.accessKeyIdSecretRef,
      ),
    secretAccessKeySecretRef:
      toJson_SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef(
        obj.secretAccessKeySecretRef,
      ),
    sessionTokenSecretRef:
      toJson_SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSessionTokenSecretRef(
        obj.sessionTokenSecretRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The Azure clientId of the service principle used for authentication.
 *
 * @schema SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId
 */
export interface SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId(
  obj: SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The Azure ClientSecret of the service principle used for authentication.
 *
 * @schema SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret
 */
export interface SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret(
  obj:
    | SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SecretStoreV1Beta1SpecProviderConjurAuthApikey
 */
export interface SecretStoreV1Beta1SpecProviderConjurAuthApikey {
  /**
   * @schema SecretStoreV1Beta1SpecProviderConjurAuthApikey#account
   */
  readonly account: string;

  /**
   * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
   *
   * @schema SecretStoreV1Beta1SpecProviderConjurAuthApikey#apiKeyRef
   */
  readonly apiKeyRef: SecretStoreV1Beta1SpecProviderConjurAuthApikeyApiKeyRef;

  /**
   * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
   *
   * @schema SecretStoreV1Beta1SpecProviderConjurAuthApikey#userRef
   */
  readonly userRef: SecretStoreV1Beta1SpecProviderConjurAuthApikeyUserRef;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderConjurAuthApikey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderConjurAuthApikey(
  obj: SecretStoreV1Beta1SpecProviderConjurAuthApikey | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    account: obj.account,
    apiKeyRef: toJson_SecretStoreV1Beta1SpecProviderConjurAuthApikeyApiKeyRef(
      obj.apiKeyRef,
    ),
    userRef: toJson_SecretStoreV1Beta1SpecProviderConjurAuthApikeyUserRef(
      obj.userRef,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SecretStoreV1Beta1SpecProviderConjurAuthJwt
 */
export interface SecretStoreV1Beta1SpecProviderConjurAuthJwt {
  /**
   * @schema SecretStoreV1Beta1SpecProviderConjurAuthJwt#account
   */
  readonly account: string;

  /**
   * Optional SecretRef that refers to a key in a Secret resource containing JWT token to authenticate with Conjur using the JWT authentication method.
   *
   * @schema SecretStoreV1Beta1SpecProviderConjurAuthJwt#secretRef
   */
  readonly secretRef?: SecretStoreV1Beta1SpecProviderConjurAuthJwtSecretRef;

  /**
   * Optional ServiceAccountRef specifies the Kubernetes service account for which to request a token for with the `TokenRequest` API.
   *
   * @schema SecretStoreV1Beta1SpecProviderConjurAuthJwt#serviceAccountRef
   */
  readonly serviceAccountRef?: SecretStoreV1Beta1SpecProviderConjurAuthJwtServiceAccountRef;

  /**
   * The conjur authn jwt webservice id
   *
   * @schema SecretStoreV1Beta1SpecProviderConjurAuthJwt#serviceID
   */
  readonly serviceId: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderConjurAuthJwt' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderConjurAuthJwt(
  obj: SecretStoreV1Beta1SpecProviderConjurAuthJwt | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    account: obj.account,
    secretRef: toJson_SecretStoreV1Beta1SpecProviderConjurAuthJwtSecretRef(
      obj.secretRef,
    ),
    serviceAccountRef:
      toJson_SecretStoreV1Beta1SpecProviderConjurAuthJwtServiceAccountRef(
        obj.serviceAccountRef,
      ),
    serviceID: obj.serviceId,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The type of provider to use such as "Secret", or "ConfigMap".
 *
 * @schema SecretStoreV1Beta1SpecProviderConjurCaProviderType
 */
export enum SecretStoreV1Beta1SpecProviderConjurCaProviderType {
  /** Secret */
  SECRET = "Secret",
  /** ConfigMap */
  CONFIG_MAP = "ConfigMap",
}

/**
 * SecretRef references a key in a secret that will be used as value.
 *
 * @schema SecretStoreV1Beta1SpecProviderDelineaClientIdSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderDelineaClientIdSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderDelineaClientIdSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderDelineaClientIdSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderDelineaClientIdSecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderDelineaClientIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderDelineaClientIdSecretRef(
  obj: SecretStoreV1Beta1SpecProviderDelineaClientIdSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * SecretRef references a key in a secret that will be used as value.
 *
 * @schema SecretStoreV1Beta1SpecProviderDelineaClientSecretSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderDelineaClientSecretSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderDelineaClientSecretSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderDelineaClientSecretSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderDelineaClientSecretSecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderDelineaClientSecretSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderDelineaClientSecretSecretRef(
  obj: SecretStoreV1Beta1SpecProviderDelineaClientSecretSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SecretStoreV1Beta1SpecProviderDopplerAuthSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderDopplerAuthSecretRef {
  /**
   * The DopplerToken is used for authentication. See https://docs.doppler.com/reference/api#authentication for auth token types. The Key attribute defaults to dopplerToken if not specified.
   *
   * @schema SecretStoreV1Beta1SpecProviderDopplerAuthSecretRef#dopplerToken
   */
  readonly dopplerToken: SecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderDopplerAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderDopplerAuthSecretRef(
  obj: SecretStoreV1Beta1SpecProviderDopplerAuthSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    dopplerToken:
      toJson_SecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken(
        obj.dopplerToken,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef {
  /**
   * The SecretAccessKey is used for authentication
   *
   * @schema SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef#secretAccessKeySecretRef
   */
  readonly secretAccessKeySecretRef?: SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef(
  obj: SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    secretAccessKeySecretRef:
      toJson_SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef(
        obj.secretAccessKeySecretRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity
 */
export interface SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity {
  /**
   * @schema SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity#clusterLocation
   */
  readonly clusterLocation: string;

  /**
   * @schema SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity#clusterName
   */
  readonly clusterName: string;

  /**
   * @schema SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity#clusterProjectID
   */
  readonly clusterProjectId?: string;

  /**
   * A reference to a ServiceAccount resource.
   *
   * @schema SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity#serviceAccountRef
   */
  readonly serviceAccountRef: SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity(
  obj: SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    clusterLocation: obj.clusterLocation,
    clusterName: obj.clusterName,
    clusterProjectID: obj.clusterProjectId,
    serviceAccountRef:
      toJson_SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef(
        obj.serviceAccountRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SecretStoreV1Beta1SpecProviderGitlabAuthSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderGitlabAuthSecretRef {
  /**
   * AccessToken is used for authentication.
   *
   * @schema SecretStoreV1Beta1SpecProviderGitlabAuthSecretRef#accessToken
   */
  readonly accessToken?: SecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderGitlabAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderGitlabAuthSecretRef(
  obj: SecretStoreV1Beta1SpecProviderGitlabAuthSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    accessToken:
      toJson_SecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken(
        obj.accessToken,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * IBM Container-based auth with IAM Trusted Profile.
 *
 * @schema SecretStoreV1Beta1SpecProviderIbmAuthContainerAuth
 */
export interface SecretStoreV1Beta1SpecProviderIbmAuthContainerAuth {
  /**
   * @schema SecretStoreV1Beta1SpecProviderIbmAuthContainerAuth#iamEndpoint
   */
  readonly iamEndpoint?: string;

  /**
   * the IBM Trusted Profile
   *
   * @schema SecretStoreV1Beta1SpecProviderIbmAuthContainerAuth#profile
   */
  readonly profile: string;

  /**
   * Location the token is mounted on the pod
   *
   * @schema SecretStoreV1Beta1SpecProviderIbmAuthContainerAuth#tokenLocation
   */
  readonly tokenLocation?: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderIbmAuthContainerAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderIbmAuthContainerAuth(
  obj: SecretStoreV1Beta1SpecProviderIbmAuthContainerAuth | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    iamEndpoint: obj.iamEndpoint,
    profile: obj.profile,
    tokenLocation: obj.tokenLocation,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SecretStoreV1Beta1SpecProviderIbmAuthSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderIbmAuthSecretRef {
  /**
   * The SecretAccessKey is used for authentication
   *
   * @schema SecretStoreV1Beta1SpecProviderIbmAuthSecretRef#secretApiKeySecretRef
   */
  readonly secretApiKeySecretRef?: SecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderIbmAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderIbmAuthSecretRef(
  obj: SecretStoreV1Beta1SpecProviderIbmAuthSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    secretApiKeySecretRef:
      toJson_SecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef(
        obj.secretApiKeySecretRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * has both clientCert and clientKey as secretKeySelector
 *
 * @schema SecretStoreV1Beta1SpecProviderKubernetesAuthCert
 */
export interface SecretStoreV1Beta1SpecProviderKubernetesAuthCert {
  /**
   * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
   *
   * @schema SecretStoreV1Beta1SpecProviderKubernetesAuthCert#clientCert
   */
  readonly clientCert?: SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert;

  /**
   * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
   *
   * @schema SecretStoreV1Beta1SpecProviderKubernetesAuthCert#clientKey
   */
  readonly clientKey?: SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderKubernetesAuthCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderKubernetesAuthCert(
  obj: SecretStoreV1Beta1SpecProviderKubernetesAuthCert | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    clientCert:
      toJson_SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert(
        obj.clientCert,
      ),
    clientKey: toJson_SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey(
      obj.clientKey,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * points to a service account that should be used for authentication
 *
 * @schema SecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount
 */
export interface SecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount {
  /**
   * Audience specifies the `aud` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
   *
   * @schema SecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount(
  obj: SecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    audiences: obj.audiences?.map((y) => y),
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * use static token to authenticate with
 *
 * @schema SecretStoreV1Beta1SpecProviderKubernetesAuthToken
 */
export interface SecretStoreV1Beta1SpecProviderKubernetesAuthToken {
  /**
   * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
   *
   * @schema SecretStoreV1Beta1SpecProviderKubernetesAuthToken#bearerToken
   */
  readonly bearerToken?: SecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderKubernetesAuthToken' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderKubernetesAuthToken(
  obj: SecretStoreV1Beta1SpecProviderKubernetesAuthToken | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    bearerToken:
      toJson_SecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken(
        obj.bearerToken,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * see: https://external-secrets.io/v0.4.1/spec/#external-secrets.io/v1alpha1.CAProvider
 *
 * @schema SecretStoreV1Beta1SpecProviderKubernetesServerCaProvider
 */
export interface SecretStoreV1Beta1SpecProviderKubernetesServerCaProvider {
  /**
   * The key where the CA certificate can be found in the Secret or ConfigMap.
   *
   * @schema SecretStoreV1Beta1SpecProviderKubernetesServerCaProvider#key
   */
  readonly key?: string;

  /**
   * The name of the object located at the provider type.
   *
   * @schema SecretStoreV1Beta1SpecProviderKubernetesServerCaProvider#name
   */
  readonly name: string;

  /**
   * The namespace the Provider type is in. Can only be defined when used in a ClusterSecretStore.
   *
   * @schema SecretStoreV1Beta1SpecProviderKubernetesServerCaProvider#namespace
   */
  readonly namespace?: string;

  /**
   * The type of provider to use such as "Secret", or "ConfigMap".
   *
   * @schema SecretStoreV1Beta1SpecProviderKubernetesServerCaProvider#type
   */
  readonly type: SecretStoreV1Beta1SpecProviderKubernetesServerCaProviderType;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderKubernetesServerCaProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderKubernetesServerCaProvider(
  obj: SecretStoreV1Beta1SpecProviderKubernetesServerCaProvider | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
    type: obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * OnePasswordAuthSecretRef holds secret references for 1Password credentials.
 *
 * @schema SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef {
  /**
   * The ConnectToken is used for authentication to a 1Password Connect Server.
   *
   * @schema SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef#connectTokenSecretRef
   */
  readonly connectTokenSecretRef: SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef(
  obj: SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    connectTokenSecretRef:
      toJson_SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef(
        obj.connectTokenSecretRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * SecretRef to pass through sensitive information.
 *
 * @schema SecretStoreV1Beta1SpecProviderOracleAuthSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderOracleAuthSecretRef {
  /**
   * Fingerprint is the fingerprint of the API private key.
   *
   * @schema SecretStoreV1Beta1SpecProviderOracleAuthSecretRef#fingerprint
   */
  readonly fingerprint: SecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint;

  /**
   * PrivateKey is the user's API Signing Key in PEM format, used for authentication.
   *
   * @schema SecretStoreV1Beta1SpecProviderOracleAuthSecretRef#privatekey
   */
  readonly privatekey: SecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderOracleAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderOracleAuthSecretRef(
  obj: SecretStoreV1Beta1SpecProviderOracleAuthSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    fingerprint:
      toJson_SecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint(
        obj.fingerprint,
      ),
    privatekey:
      toJson_SecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey(
        obj.privatekey,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * SecretRef references a key in a secret that will be used as value.
 *
 * @schema SecretStoreV1Beta1SpecProviderScalewayAccessKeySecretRef
 */
export interface SecretStoreV1Beta1SpecProviderScalewayAccessKeySecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderScalewayAccessKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderScalewayAccessKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderScalewayAccessKeySecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderScalewayAccessKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderScalewayAccessKeySecretRef(
  obj: SecretStoreV1Beta1SpecProviderScalewayAccessKeySecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * SecretRef references a key in a secret that will be used as value.
 *
 * @schema SecretStoreV1Beta1SpecProviderScalewaySecretKeySecretRef
 */
export interface SecretStoreV1Beta1SpecProviderScalewaySecretKeySecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderScalewaySecretKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderScalewaySecretKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderScalewaySecretKeySecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderScalewaySecretKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderScalewaySecretKeySecretRef(
  obj: SecretStoreV1Beta1SpecProviderScalewaySecretKeySecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
 *
 * @schema SecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef(
  obj:
    | SecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * AppRole authenticates with Vault using the App Role auth mechanism, with the role and secret stored in a Kubernetes Secret resource.
 *
 * @schema SecretStoreV1Beta1SpecProviderVaultAuthAppRole
 */
export interface SecretStoreV1Beta1SpecProviderVaultAuthAppRole {
  /**
   * Path where the App Role authentication backend is mounted in Vault, e.g: "approle"
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthAppRole#path
   */
  readonly path: string;

  /**
   * RoleID configured in the App Role authentication backend when setting up the authentication backend in Vault.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthAppRole#roleId
   */
  readonly roleId?: string;

  /**
   * Reference to a key in a Secret that contains the App Role ID used to authenticate with Vault. The `key` field must be specified and denotes which entry within the Secret resource is used as the app role id.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthAppRole#roleRef
   */
  readonly roleRef?: SecretStoreV1Beta1SpecProviderVaultAuthAppRoleRoleRef;

  /**
   * Reference to a key in a Secret that contains the App Role secret used to authenticate with Vault. The `key` field must be specified and denotes which entry within the Secret resource is used as the app role secret.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthAppRole#secretRef
   */
  readonly secretRef: SecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderVaultAuthAppRole' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderVaultAuthAppRole(
  obj: SecretStoreV1Beta1SpecProviderVaultAuthAppRole | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    path: obj.path,
    roleId: obj.roleId,
    roleRef: toJson_SecretStoreV1Beta1SpecProviderVaultAuthAppRoleRoleRef(
      obj.roleRef,
    ),
    secretRef: toJson_SecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef(
      obj.secretRef,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Cert authenticates with TLS Certificates by passing client certificate, private key and ca certificate Cert authentication method
 *
 * @schema SecretStoreV1Beta1SpecProviderVaultAuthCert
 */
export interface SecretStoreV1Beta1SpecProviderVaultAuthCert {
  /**
   * ClientCert is a certificate to authenticate using the Cert Vault authentication method
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthCert#clientCert
   */
  readonly clientCert?: SecretStoreV1Beta1SpecProviderVaultAuthCertClientCert;

  /**
   * SecretRef to a key in a Secret resource containing client private key to authenticate with Vault using the Cert authentication method
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthCert#secretRef
   */
  readonly secretRef?: SecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderVaultAuthCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderVaultAuthCert(
  obj: SecretStoreV1Beta1SpecProviderVaultAuthCert | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    clientCert: toJson_SecretStoreV1Beta1SpecProviderVaultAuthCertClientCert(
      obj.clientCert,
    ),
    secretRef: toJson_SecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef(
      obj.secretRef,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Iam authenticates with vault by passing a special AWS request signed with AWS IAM credentials AWS IAM authentication method
 *
 * @schema SecretStoreV1Beta1SpecProviderVaultAuthIam
 */
export interface SecretStoreV1Beta1SpecProviderVaultAuthIam {
  /**
   * AWS External ID set on assumed IAM roles
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthIam#externalID
   */
  readonly externalId?: string;

  /**
   * Specify a service account with IRSA enabled
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthIam#jwt
   */
  readonly jwt?: SecretStoreV1Beta1SpecProviderVaultAuthIamJwt;

  /**
   * Path where the AWS auth method is enabled in Vault, e.g: "aws"
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthIam#path
   */
  readonly path?: string;

  /**
   * AWS region
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthIam#region
   */
  readonly region?: string;

  /**
   * This is the AWS role to be assumed before talking to vault
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthIam#role
   */
  readonly role?: string;

  /**
   * Specify credentials in a Secret object
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthIam#secretRef
   */
  readonly secretRef?: SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRef;

  /**
   * X-Vault-AWS-IAM-Server-ID is an additional header used by Vault IAM auth method to mitigate against different types of replay attacks. More details here: https://developer.hashicorp.com/vault/docs/auth/aws
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthIam#vaultAwsIamServerID
   */
  readonly vaultAwsIamServerId?: string;

  /**
   * Vault Role. In vault, a role describes an identity with a set of permissions, groups, or policies you want to attach a user of the secrets engine
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthIam#vaultRole
   */
  readonly vaultRole: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderVaultAuthIam' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderVaultAuthIam(
  obj: SecretStoreV1Beta1SpecProviderVaultAuthIam | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    externalID: obj.externalId,
    jwt: toJson_SecretStoreV1Beta1SpecProviderVaultAuthIamJwt(obj.jwt),
    path: obj.path,
    region: obj.region,
    role: obj.role,
    secretRef: toJson_SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRef(
      obj.secretRef,
    ),
    vaultAwsIamServerID: obj.vaultAwsIamServerId,
    vaultRole: obj.vaultRole,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Jwt authenticates with Vault by passing role and JWT token using the JWT/OIDC authentication method
 *
 * @schema SecretStoreV1Beta1SpecProviderVaultAuthJwt
 */
export interface SecretStoreV1Beta1SpecProviderVaultAuthJwt {
  /**
   * Optional ServiceAccountToken specifies the Kubernetes service account for which to request a token for with the `TokenRequest` API.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthJwt#kubernetesServiceAccountToken
   */
  readonly kubernetesServiceAccountToken?: SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken;

  /**
   * Path where the JWT authentication backend is mounted in Vault, e.g: "jwt"
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthJwt#path
   */
  readonly path: string;

  /**
   * Role is a JWT role to authenticate using the JWT/OIDC Vault authentication method
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthJwt#role
   */
  readonly role?: string;

  /**
   * Optional SecretRef that refers to a key in a Secret resource containing JWT token to authenticate with Vault using the JWT/OIDC authentication method.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthJwt#secretRef
   */
  readonly secretRef?: SecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderVaultAuthJwt' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderVaultAuthJwt(
  obj: SecretStoreV1Beta1SpecProviderVaultAuthJwt | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    kubernetesServiceAccountToken:
      toJson_SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken(
        obj.kubernetesServiceAccountToken,
      ),
    path: obj.path,
    role: obj.role,
    secretRef: toJson_SecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef(
      obj.secretRef,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Kubernetes authenticates with Vault by passing the ServiceAccount token stored in the named Secret resource to the Vault server.
 *
 * @schema SecretStoreV1Beta1SpecProviderVaultAuthKubernetes
 */
export interface SecretStoreV1Beta1SpecProviderVaultAuthKubernetes {
  /**
   * Path where the Kubernetes authentication backend is mounted in Vault, e.g: "kubernetes"
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthKubernetes#mountPath
   */
  readonly mountPath: string;

  /**
   * A required field containing the Vault Role to assume. A Role binds a Kubernetes ServiceAccount with a set of Vault policies.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthKubernetes#role
   */
  readonly role: string;

  /**
   * Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Vault. If a name is specified without a key, `token` is the default. If one is not specified, the one bound to the controller will be used.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthKubernetes#secretRef
   */
  readonly secretRef?: SecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef;

  /**
   * Optional service account field containing the name of a kubernetes ServiceAccount. If the service account is specified, the service account secret token JWT will be used for authenticating with Vault. If the service account selector is not supplied, the secretRef will be used instead.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthKubernetes#serviceAccountRef
   */
  readonly serviceAccountRef?: SecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderVaultAuthKubernetes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderVaultAuthKubernetes(
  obj: SecretStoreV1Beta1SpecProviderVaultAuthKubernetes | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    mountPath: obj.mountPath,
    role: obj.role,
    secretRef:
      toJson_SecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef(
        obj.secretRef,
      ),
    serviceAccountRef:
      toJson_SecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef(
        obj.serviceAccountRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Ldap authenticates with Vault by passing username/password pair using the LDAP authentication method
 *
 * @schema SecretStoreV1Beta1SpecProviderVaultAuthLdap
 */
export interface SecretStoreV1Beta1SpecProviderVaultAuthLdap {
  /**
   * Path where the LDAP authentication backend is mounted in Vault, e.g: "ldap"
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthLdap#path
   */
  readonly path: string;

  /**
   * SecretRef to a key in a Secret resource containing password for the LDAP user used to authenticate with Vault using the LDAP authentication method
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthLdap#secretRef
   */
  readonly secretRef?: SecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef;

  /**
   * Username is a LDAP user name used to authenticate using the LDAP Vault authentication method
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthLdap#username
   */
  readonly username: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderVaultAuthLdap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderVaultAuthLdap(
  obj: SecretStoreV1Beta1SpecProviderVaultAuthLdap | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    path: obj.path,
    secretRef: toJson_SecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef(
      obj.secretRef,
    ),
    username: obj.username,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * TokenSecretRef authenticates with Vault by presenting a token.
 *
 * @schema SecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef(
  obj: SecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * UserPass authenticates with Vault by passing username/password pair
 *
 * @schema SecretStoreV1Beta1SpecProviderVaultAuthUserPass
 */
export interface SecretStoreV1Beta1SpecProviderVaultAuthUserPass {
  /**
   * Path where the UserPassword authentication backend is mounted in Vault, e.g: "user"
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthUserPass#path
   */
  readonly path: string;

  /**
   * SecretRef to a key in a Secret resource containing password for the user used to authenticate with Vault using the UserPass authentication method
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthUserPass#secretRef
   */
  readonly secretRef?: SecretStoreV1Beta1SpecProviderVaultAuthUserPassSecretRef;

  /**
   * Username is a user name used to authenticate using the UserPass Vault authentication method
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthUserPass#username
   */
  readonly username: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderVaultAuthUserPass' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderVaultAuthUserPass(
  obj: SecretStoreV1Beta1SpecProviderVaultAuthUserPass | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    path: obj.path,
    secretRef: toJson_SecretStoreV1Beta1SpecProviderVaultAuthUserPassSecretRef(
      obj.secretRef,
    ),
    username: obj.username,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The type of provider to use such as "Secret", or "ConfigMap".
 *
 * @schema SecretStoreV1Beta1SpecProviderVaultCaProviderType
 */
export enum SecretStoreV1Beta1SpecProviderVaultCaProviderType {
  /** Secret */
  SECRET = "Secret",
  /** ConfigMap */
  CONFIG_MAP = "ConfigMap",
}

/**
 * The type of provider to use such as "Secret", or "ConfigMap".
 *
 * @schema SecretStoreV1Beta1SpecProviderWebhookCaProviderType
 */
export enum SecretStoreV1Beta1SpecProviderWebhookCaProviderType {
  /** Secret */
  SECRET = "Secret",
  /** ConfigMap */
  CONFIG_MAP = "ConfigMap",
}

/**
 * Secret ref to fill in credentials
 *
 * @schema SecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef(
  obj: SecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The authorized key used for authentication
 *
 * @schema SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef
 */
export interface SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef(
  obj:
    | SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
 *
 * @schema SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef(
  obj:
    | SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The authorized key used for authentication
 *
 * @schema SecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef
 */
export interface SecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef(
  obj:
    | SecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
 *
 * @schema SecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef(
  obj:
    | SecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Akeyless. If a name is specified without a key, `token` is the default. If one is not specified, the one bound to the controller will be used.
 *
 * @schema SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef(
  obj:
    | SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Optional service account field containing the name of a kubernetes ServiceAccount. If the service account is specified, the service account secret token JWT will be used for authenticating with Akeyless. If the service account selector is not supplied, the secretRef will be used instead.
 *
 * @schema SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef
 */
export interface SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
   *
   * @schema SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef(
  obj:
    | SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    audiences: obj.audiences?.map((y) => y),
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The SecretAccessID is used for authentication
 *
 * @schema SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId
 */
export interface SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId(
  obj:
    | SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
 *
 * @schema SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType
 */
export interface SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType(
  obj:
    | SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
 *
 * @schema SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam
 */
export interface SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam(
  obj:
    | SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The AccessKeyID is used for authentication
 *
 * @schema SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef(
  obj:
    | SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The AccessKeySecret is used for authentication
 *
 * @schema SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef(
  obj:
    | SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A reference to a ServiceAccount resource.
 *
 * @schema SecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef
 */
export interface SecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
   *
   * @schema SecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef(
  obj: SecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    audiences: obj.audiences?.map((y) => y),
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The AccessKeyID is used for authentication
 *
 * @schema SecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef(
  obj:
    | SecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The SecretAccessKey is used for authentication
 *
 * @schema SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef
 */
export interface SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef(
  obj:
    | SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The SessionToken used for authentication This must be defined if AccessKeyID and SecretAccessKey are temporary credentials see: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_use-resources.html
 *
 * @schema SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSessionTokenSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSessionTokenSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSessionTokenSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSessionTokenSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSessionTokenSecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSessionTokenSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSessionTokenSecretRef(
  obj:
    | SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSessionTokenSecretRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
 *
 * @schema SecretStoreV1Beta1SpecProviderConjurAuthApikeyApiKeyRef
 */
export interface SecretStoreV1Beta1SpecProviderConjurAuthApikeyApiKeyRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderConjurAuthApikeyApiKeyRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderConjurAuthApikeyApiKeyRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderConjurAuthApikeyApiKeyRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderConjurAuthApikeyApiKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderConjurAuthApikeyApiKeyRef(
  obj: SecretStoreV1Beta1SpecProviderConjurAuthApikeyApiKeyRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
 *
 * @schema SecretStoreV1Beta1SpecProviderConjurAuthApikeyUserRef
 */
export interface SecretStoreV1Beta1SpecProviderConjurAuthApikeyUserRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderConjurAuthApikeyUserRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderConjurAuthApikeyUserRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderConjurAuthApikeyUserRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderConjurAuthApikeyUserRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderConjurAuthApikeyUserRef(
  obj: SecretStoreV1Beta1SpecProviderConjurAuthApikeyUserRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Optional SecretRef that refers to a key in a Secret resource containing JWT token to authenticate with Conjur using the JWT authentication method.
 *
 * @schema SecretStoreV1Beta1SpecProviderConjurAuthJwtSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderConjurAuthJwtSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderConjurAuthJwtSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderConjurAuthJwtSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderConjurAuthJwtSecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderConjurAuthJwtSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderConjurAuthJwtSecretRef(
  obj: SecretStoreV1Beta1SpecProviderConjurAuthJwtSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Optional ServiceAccountRef specifies the Kubernetes service account for which to request a token for with the `TokenRequest` API.
 *
 * @schema SecretStoreV1Beta1SpecProviderConjurAuthJwtServiceAccountRef
 */
export interface SecretStoreV1Beta1SpecProviderConjurAuthJwtServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
   *
   * @schema SecretStoreV1Beta1SpecProviderConjurAuthJwtServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderConjurAuthJwtServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderConjurAuthJwtServiceAccountRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderConjurAuthJwtServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderConjurAuthJwtServiceAccountRef(
  obj: SecretStoreV1Beta1SpecProviderConjurAuthJwtServiceAccountRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    audiences: obj.audiences?.map((y) => y),
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The DopplerToken is used for authentication. See https://docs.doppler.com/reference/api#authentication for auth token types. The Key attribute defaults to dopplerToken if not specified.
 *
 * @schema SecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken
 */
export interface SecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken(
  obj:
    | SecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The SecretAccessKey is used for authentication
 *
 * @schema SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef
 */
export interface SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef(
  obj:
    | SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A reference to a ServiceAccount resource.
 *
 * @schema SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef
 */
export interface SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
   *
   * @schema SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef(
  obj:
    | SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    audiences: obj.audiences?.map((y) => y),
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * AccessToken is used for authentication.
 *
 * @schema SecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken
 */
export interface SecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken(
  obj: SecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The SecretAccessKey is used for authentication
 *
 * @schema SecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef
 */
export interface SecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef(
  obj:
    | SecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
 *
 * @schema SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert
 */
export interface SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert(
  obj: SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
 *
 * @schema SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey
 */
export interface SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey(
  obj: SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
 *
 * @schema SecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken
 */
export interface SecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken(
  obj: SecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The type of provider to use such as "Secret", or "ConfigMap".
 *
 * @schema SecretStoreV1Beta1SpecProviderKubernetesServerCaProviderType
 */
export enum SecretStoreV1Beta1SpecProviderKubernetesServerCaProviderType {
  /** Secret */
  SECRET = "Secret",
  /** ConfigMap */
  CONFIG_MAP = "ConfigMap",
}

/**
 * The ConnectToken is used for authentication to a 1Password Connect Server.
 *
 * @schema SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef(
  obj:
    | SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Fingerprint is the fingerprint of the API private key.
 *
 * @schema SecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint
 */
export interface SecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint(
  obj: SecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * PrivateKey is the user's API Signing Key in PEM format, used for authentication.
 *
 * @schema SecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey
 */
export interface SecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey(
  obj: SecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a key in a Secret that contains the App Role ID used to authenticate with Vault. The `key` field must be specified and denotes which entry within the Secret resource is used as the app role id.
 *
 * @schema SecretStoreV1Beta1SpecProviderVaultAuthAppRoleRoleRef
 */
export interface SecretStoreV1Beta1SpecProviderVaultAuthAppRoleRoleRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthAppRoleRoleRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthAppRoleRoleRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthAppRoleRoleRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderVaultAuthAppRoleRoleRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderVaultAuthAppRoleRoleRef(
  obj: SecretStoreV1Beta1SpecProviderVaultAuthAppRoleRoleRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a key in a Secret that contains the App Role secret used to authenticate with Vault. The `key` field must be specified and denotes which entry within the Secret resource is used as the app role secret.
 *
 * @schema SecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef(
  obj: SecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ClientCert is a certificate to authenticate using the Cert Vault authentication method
 *
 * @schema SecretStoreV1Beta1SpecProviderVaultAuthCertClientCert
 */
export interface SecretStoreV1Beta1SpecProviderVaultAuthCertClientCert {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthCertClientCert#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthCertClientCert#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthCertClientCert#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderVaultAuthCertClientCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderVaultAuthCertClientCert(
  obj: SecretStoreV1Beta1SpecProviderVaultAuthCertClientCert | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * SecretRef to a key in a Secret resource containing client private key to authenticate with Vault using the Cert authentication method
 *
 * @schema SecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef(
  obj: SecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Specify a service account with IRSA enabled
 *
 * @schema SecretStoreV1Beta1SpecProviderVaultAuthIamJwt
 */
export interface SecretStoreV1Beta1SpecProviderVaultAuthIamJwt {
  /**
   * A reference to a ServiceAccount resource.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthIamJwt#serviceAccountRef
   */
  readonly serviceAccountRef?: SecretStoreV1Beta1SpecProviderVaultAuthIamJwtServiceAccountRef;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderVaultAuthIamJwt' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderVaultAuthIamJwt(
  obj: SecretStoreV1Beta1SpecProviderVaultAuthIamJwt | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    serviceAccountRef:
      toJson_SecretStoreV1Beta1SpecProviderVaultAuthIamJwtServiceAccountRef(
        obj.serviceAccountRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Specify credentials in a Secret object
 *
 * @schema SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRef {
  /**
   * The AccessKeyID is used for authentication
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRef#accessKeyIDSecretRef
   */
  readonly accessKeyIdSecretRef?: SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef;

  /**
   * The SecretAccessKey is used for authentication
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRef#secretAccessKeySecretRef
   */
  readonly secretAccessKeySecretRef?: SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef;

  /**
   * The SessionToken used for authentication This must be defined if AccessKeyID and SecretAccessKey are temporary credentials see: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_use-resources.html
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRef#sessionTokenSecretRef
   */
  readonly sessionTokenSecretRef?: SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSessionTokenSecretRef;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRef(
  obj: SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    accessKeyIDSecretRef:
      toJson_SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef(
        obj.accessKeyIdSecretRef,
      ),
    secretAccessKeySecretRef:
      toJson_SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef(
        obj.secretAccessKeySecretRef,
      ),
    sessionTokenSecretRef:
      toJson_SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSessionTokenSecretRef(
        obj.sessionTokenSecretRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Optional ServiceAccountToken specifies the Kubernetes service account for which to request a token for with the `TokenRequest` API.
 *
 * @schema SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken
 */
export interface SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken {
  /**
   * Optional audiences field that will be used to request a temporary Kubernetes service account token for the service account referenced by `serviceAccountRef`. Defaults to a single audience `vault` it not specified. Deprecated: use serviceAccountRef.Audiences instead
   *
   * @default a single audience `vault` it not specified. Deprecated: use serviceAccountRef.Audiences instead
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken#audiences
   */
  readonly audiences?: string[];

  /**
   * Optional expiration time in seconds that will be used to request a temporary Kubernetes service account token for the service account referenced by `serviceAccountRef`. Deprecated: this will be removed in the future. Defaults to 10 minutes.
   *
   * @default 10 minutes.
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken#expirationSeconds
   */
  readonly expirationSeconds?: number;

  /**
   * Service account field containing the name of a kubernetes ServiceAccount.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken#serviceAccountRef
   */
  readonly serviceAccountRef: SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken(
  obj:
    | SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    audiences: obj.audiences?.map((y) => y),
    expirationSeconds: obj.expirationSeconds,
    serviceAccountRef:
      toJson_SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef(
        obj.serviceAccountRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Optional SecretRef that refers to a key in a Secret resource containing JWT token to authenticate with Vault using the JWT/OIDC authentication method.
 *
 * @schema SecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef(
  obj: SecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Vault. If a name is specified without a key, `token` is the default. If one is not specified, the one bound to the controller will be used.
 *
 * @schema SecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef(
  obj: SecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Optional service account field containing the name of a kubernetes ServiceAccount. If the service account is specified, the service account secret token JWT will be used for authenticating with Vault. If the service account selector is not supplied, the secretRef will be used instead.
 *
 * @schema SecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef
 */
export interface SecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef(
  obj:
    | SecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    audiences: obj.audiences?.map((y) => y),
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * SecretRef to a key in a Secret resource containing password for the LDAP user used to authenticate with Vault using the LDAP authentication method
 *
 * @schema SecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef(
  obj: SecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * SecretRef to a key in a Secret resource containing password for the user used to authenticate with Vault using the UserPass authentication method
 *
 * @schema SecretStoreV1Beta1SpecProviderVaultAuthUserPassSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderVaultAuthUserPassSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthUserPassSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthUserPassSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthUserPassSecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderVaultAuthUserPassSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderVaultAuthUserPassSecretRef(
  obj: SecretStoreV1Beta1SpecProviderVaultAuthUserPassSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A reference to a ServiceAccount resource.
 *
 * @schema SecretStoreV1Beta1SpecProviderVaultAuthIamJwtServiceAccountRef
 */
export interface SecretStoreV1Beta1SpecProviderVaultAuthIamJwtServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthIamJwtServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthIamJwtServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthIamJwtServiceAccountRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderVaultAuthIamJwtServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderVaultAuthIamJwtServiceAccountRef(
  obj:
    | SecretStoreV1Beta1SpecProviderVaultAuthIamJwtServiceAccountRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    audiences: obj.audiences?.map((y) => y),
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The AccessKeyID is used for authentication
 *
 * @schema SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef(
  obj:
    | SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The SecretAccessKey is used for authentication
 *
 * @schema SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef
 */
export interface SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef(
  obj:
    | SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The SessionToken used for authentication This must be defined if AccessKeyID and SecretAccessKey are temporary credentials see: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_use-resources.html
 *
 * @schema SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSessionTokenSecretRef
 */
export interface SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSessionTokenSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSessionTokenSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSessionTokenSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSessionTokenSecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSessionTokenSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSessionTokenSecretRef(
  obj:
    | SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSessionTokenSecretRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Service account field containing the name of a kubernetes ServiceAccount.
 *
 * @schema SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef
 */
export interface SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef(
  obj:
    | SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    audiences: obj.audiences?.map((y) => y),
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */
