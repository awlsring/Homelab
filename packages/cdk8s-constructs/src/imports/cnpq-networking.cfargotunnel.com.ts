// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * ClusterTunnel is the Schema for the clustertunnels API
 *
 * @schema ClusterTunnel
 */
export class ClusterTunnel extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ClusterTunnel"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networking.cfargotunnel.com/v1alpha1',
    kind: 'ClusterTunnel',
  }

  /**
   * Renders a Kubernetes manifest for "ClusterTunnel".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ClusterTunnelProps = {}): any {
    return {
      ...ClusterTunnel.GVK,
      ...toJson_ClusterTunnelProps(props),
    };
  }

  /**
   * Defines a "ClusterTunnel" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ClusterTunnelProps = {}) {
    super(scope, id, {
      ...ClusterTunnel.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ClusterTunnel.GVK,
      ...toJson_ClusterTunnelProps(resolved),
    };
  }
}

/**
 * ClusterTunnel is the Schema for the clustertunnels API
 *
 * @schema ClusterTunnel
 */
export interface ClusterTunnelProps {
  /**
   * @schema ClusterTunnel#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * TunnelSpec defines the desired state of Tunnel
   *
   * @schema ClusterTunnel#spec
   */
  readonly spec?: ClusterTunnelSpec;

}

/**
 * Converts an object of type 'ClusterTunnelProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterTunnelProps(obj: ClusterTunnelProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ClusterTunnelSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TunnelSpec defines the desired state of Tunnel
 *
 * @schema ClusterTunnelSpec
 */
export interface ClusterTunnelSpec {
  /**
   * Cloudflare Credentials
   *
   * @schema ClusterTunnelSpec#cloudflare
   */
  readonly cloudflare?: ClusterTunnelSpecCloudflare;

  /**
   * Existing tunnel object. ExistingTunnel and NewTunnel cannot be both empty and are mutually exclusive.
   *
   * @schema ClusterTunnelSpec#existingTunnel
   */
  readonly existingTunnel?: ClusterTunnelSpecExistingTunnel;

  /**
   * FallbackTarget speficies the target for requests that do not match an ingress. Defaults to http_status:404
   *
   * @default http_status:404
   * @schema ClusterTunnelSpec#fallbackTarget
   */
  readonly fallbackTarget?: string;

  /**
   * Image sets the Cloudflared Image to use. Defaults to the image set during the release of the operator.
   *
   * @default the image set during the release of the operator.
   * @schema ClusterTunnelSpec#image
   */
  readonly image?: string;

  /**
   * New tunnel object. NewTunnel and ExistingTunnel cannot be both empty and are mutually exclusive.
   *
   * @schema ClusterTunnelSpec#newTunnel
   */
  readonly newTunnel?: ClusterTunnelSpecNewTunnel;

  /**
   * NoTlsVerify disables origin TLS certificate checks when the endpoint is HTTPS.
   *
   * @schema ClusterTunnelSpec#noTlsVerify
   */
  readonly noTlsVerify?: boolean;

  /**
   * OriginCaPool speficies the secret with tls.crt (and other certs as needed to be referred in the service annotation) of the Root CA to be trusted when sending traffic to HTTPS endpoints
   *
   * @schema ClusterTunnelSpec#originCaPool
   */
  readonly originCaPool?: string;

  /**
   * Size defines the number of Daemon pods to run for this tunnel
   *
   * @schema ClusterTunnelSpec#size
   */
  readonly size?: number;

}

/**
 * Converts an object of type 'ClusterTunnelSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterTunnelSpec(obj: ClusterTunnelSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloudflare': toJson_ClusterTunnelSpecCloudflare(obj.cloudflare),
    'existingTunnel': toJson_ClusterTunnelSpecExistingTunnel(obj.existingTunnel),
    'fallbackTarget': obj.fallbackTarget,
    'image': obj.image,
    'newTunnel': toJson_ClusterTunnelSpecNewTunnel(obj.newTunnel),
    'noTlsVerify': obj.noTlsVerify,
    'originCaPool': obj.originCaPool,
    'size': obj.size,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Cloudflare Credentials
 *
 * @schema ClusterTunnelSpecCloudflare
 */
export interface ClusterTunnelSpecCloudflare {
  /**
   * Key in the secret to use for Cloudflare API Key, defaults to CLOUDFLARE_API_KEY. Needs Email also to be provided. For Delete operations for new tunnels only, or as an alternate to API Token
   *
   * @schema ClusterTunnelSpecCloudflare#CLOUDFLARE_API_KEY
   */
  readonly cloudflareApiKey?: string;

  /**
   * Key in the secret to use for Cloudflare API token, defaults to CLOUDFLARE_API_TOKEN
   *
   * @schema ClusterTunnelSpecCloudflare#CLOUDFLARE_API_TOKEN
   */
  readonly cloudflareApiToken?: string;

  /**
   * Key in the secret to use as credentials.json for an existing tunnel, defaults to CLOUDFLARE_TUNNEL_CREDENTIAL_FILE
   *
   * @schema ClusterTunnelSpecCloudflare#CLOUDFLARE_TUNNEL_CREDENTIAL_FILE
   */
  readonly cloudflareTunnelCredentialFile?: string;

  /**
   * Key in the secret to use as tunnel secret for an existing tunnel, defaults to CLOUDFLARE_TUNNEL_CREDENTIAL_SECRET
   *
   * @schema ClusterTunnelSpecCloudflare#CLOUDFLARE_TUNNEL_CREDENTIAL_SECRET
   */
  readonly cloudflareTunnelCredentialSecret?: string;

  /**
   * Account ID in Cloudflare. AccountId and AccountName cannot be both empty. If both are provided, Account ID is used if valid, else falls back to Account Name.
   *
   * @schema ClusterTunnelSpecCloudflare#accountId
   */
  readonly accountId?: string;

  /**
   * Account Name in Cloudflare. AccountName and AccountId cannot be both empty. If both are provided, Account ID is used if valid, else falls back to Account Name.
   *
   * @schema ClusterTunnelSpecCloudflare#accountName
   */
  readonly accountName?: string;

  /**
   * Cloudflare Domain to which this tunnel belongs to
   *
   * @schema ClusterTunnelSpecCloudflare#domain
   */
  readonly domain?: string;

  /**
   * Email to use along with API Key for Delete operations for new tunnels only, or as an alternate to API Token
   *
   * @schema ClusterTunnelSpecCloudflare#email
   */
  readonly email?: string;

  /**
   * Secret containing Cloudflare API key/token
   *
   * @schema ClusterTunnelSpecCloudflare#secret
   */
  readonly secret?: string;

}

/**
 * Converts an object of type 'ClusterTunnelSpecCloudflare' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterTunnelSpecCloudflare(obj: ClusterTunnelSpecCloudflare | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'CLOUDFLARE_API_KEY': obj.cloudflareApiKey,
    'CLOUDFLARE_API_TOKEN': obj.cloudflareApiToken,
    'CLOUDFLARE_TUNNEL_CREDENTIAL_FILE': obj.cloudflareTunnelCredentialFile,
    'CLOUDFLARE_TUNNEL_CREDENTIAL_SECRET': obj.cloudflareTunnelCredentialSecret,
    'accountId': obj.accountId,
    'accountName': obj.accountName,
    'domain': obj.domain,
    'email': obj.email,
    'secret': obj.secret,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Existing tunnel object. ExistingTunnel and NewTunnel cannot be both empty and are mutually exclusive.
 *
 * @schema ClusterTunnelSpecExistingTunnel
 */
export interface ClusterTunnelSpecExistingTunnel {
  /**
   * Existing Tunnel ID to run on. Tunnel ID and Tunnel Name cannot be both empty. If both are provided, ID is used if valid, else falls back to Name.
   *
   * @schema ClusterTunnelSpecExistingTunnel#id
   */
  readonly id?: string;

  /**
   * Existing Tunnel name to run on. Tunnel Name and Tunnel ID cannot be both empty. If both are provided, ID is used if valid, else falls back to Name.
   *
   * @schema ClusterTunnelSpecExistingTunnel#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'ClusterTunnelSpecExistingTunnel' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterTunnelSpecExistingTunnel(obj: ClusterTunnelSpecExistingTunnel | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'id': obj.id,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * New tunnel object. NewTunnel and ExistingTunnel cannot be both empty and are mutually exclusive.
 *
 * @schema ClusterTunnelSpecNewTunnel
 */
export interface ClusterTunnelSpecNewTunnel {
  /**
   * Tunnel name to create on Cloudflare.
   *
   * @schema ClusterTunnelSpecNewTunnel#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'ClusterTunnelSpecNewTunnel' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterTunnelSpecNewTunnel(obj: ClusterTunnelSpecNewTunnel | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * Tunnel is the Schema for the tunnels API
 *
 * @schema Tunnel
 */
export class Tunnel extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Tunnel"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networking.cfargotunnel.com/v1alpha1',
    kind: 'Tunnel',
  }

  /**
   * Renders a Kubernetes manifest for "Tunnel".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: TunnelProps = {}): any {
    return {
      ...Tunnel.GVK,
      ...toJson_TunnelProps(props),
    };
  }

  /**
   * Defines a "Tunnel" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: TunnelProps = {}) {
    super(scope, id, {
      ...Tunnel.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Tunnel.GVK,
      ...toJson_TunnelProps(resolved),
    };
  }
}

/**
 * Tunnel is the Schema for the tunnels API
 *
 * @schema Tunnel
 */
export interface TunnelProps {
  /**
   * @schema Tunnel#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * TunnelSpec defines the desired state of Tunnel
   *
   * @schema Tunnel#spec
   */
  readonly spec?: TunnelSpec;

}

/**
 * Converts an object of type 'TunnelProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TunnelProps(obj: TunnelProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_TunnelSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TunnelSpec defines the desired state of Tunnel
 *
 * @schema TunnelSpec
 */
export interface TunnelSpec {
  /**
   * Cloudflare Credentials
   *
   * @schema TunnelSpec#cloudflare
   */
  readonly cloudflare?: TunnelSpecCloudflare;

  /**
   * Existing tunnel object. ExistingTunnel and NewTunnel cannot be both empty and are mutually exclusive.
   *
   * @schema TunnelSpec#existingTunnel
   */
  readonly existingTunnel?: TunnelSpecExistingTunnel;

  /**
   * FallbackTarget speficies the target for requests that do not match an ingress. Defaults to http_status:404
   *
   * @default http_status:404
   * @schema TunnelSpec#fallbackTarget
   */
  readonly fallbackTarget?: string;

  /**
   * Image sets the Cloudflared Image to use. Defaults to the image set during the release of the operator.
   *
   * @default the image set during the release of the operator.
   * @schema TunnelSpec#image
   */
  readonly image?: string;

  /**
   * New tunnel object. NewTunnel and ExistingTunnel cannot be both empty and are mutually exclusive.
   *
   * @schema TunnelSpec#newTunnel
   */
  readonly newTunnel?: TunnelSpecNewTunnel;

  /**
   * NoTlsVerify disables origin TLS certificate checks when the endpoint is HTTPS.
   *
   * @schema TunnelSpec#noTlsVerify
   */
  readonly noTlsVerify?: boolean;

  /**
   * OriginCaPool speficies the secret with tls.crt (and other certs as needed to be referred in the service annotation) of the Root CA to be trusted when sending traffic to HTTPS endpoints
   *
   * @schema TunnelSpec#originCaPool
   */
  readonly originCaPool?: string;

  /**
   * Size defines the number of Daemon pods to run for this tunnel
   *
   * @schema TunnelSpec#size
   */
  readonly size?: number;

}

/**
 * Converts an object of type 'TunnelSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TunnelSpec(obj: TunnelSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloudflare': toJson_TunnelSpecCloudflare(obj.cloudflare),
    'existingTunnel': toJson_TunnelSpecExistingTunnel(obj.existingTunnel),
    'fallbackTarget': obj.fallbackTarget,
    'image': obj.image,
    'newTunnel': toJson_TunnelSpecNewTunnel(obj.newTunnel),
    'noTlsVerify': obj.noTlsVerify,
    'originCaPool': obj.originCaPool,
    'size': obj.size,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Cloudflare Credentials
 *
 * @schema TunnelSpecCloudflare
 */
export interface TunnelSpecCloudflare {
  /**
   * Key in the secret to use for Cloudflare API Key, defaults to CLOUDFLARE_API_KEY. Needs Email also to be provided. For Delete operations for new tunnels only, or as an alternate to API Token
   *
   * @schema TunnelSpecCloudflare#CLOUDFLARE_API_KEY
   */
  readonly cloudflareApiKey?: string;

  /**
   * Key in the secret to use for Cloudflare API token, defaults to CLOUDFLARE_API_TOKEN
   *
   * @schema TunnelSpecCloudflare#CLOUDFLARE_API_TOKEN
   */
  readonly cloudflareApiToken?: string;

  /**
   * Key in the secret to use as credentials.json for an existing tunnel, defaults to CLOUDFLARE_TUNNEL_CREDENTIAL_FILE
   *
   * @schema TunnelSpecCloudflare#CLOUDFLARE_TUNNEL_CREDENTIAL_FILE
   */
  readonly cloudflareTunnelCredentialFile?: string;

  /**
   * Key in the secret to use as tunnel secret for an existing tunnel, defaults to CLOUDFLARE_TUNNEL_CREDENTIAL_SECRET
   *
   * @schema TunnelSpecCloudflare#CLOUDFLARE_TUNNEL_CREDENTIAL_SECRET
   */
  readonly cloudflareTunnelCredentialSecret?: string;

  /**
   * Account ID in Cloudflare. AccountId and AccountName cannot be both empty. If both are provided, Account ID is used if valid, else falls back to Account Name.
   *
   * @schema TunnelSpecCloudflare#accountId
   */
  readonly accountId?: string;

  /**
   * Account Name in Cloudflare. AccountName and AccountId cannot be both empty. If both are provided, Account ID is used if valid, else falls back to Account Name.
   *
   * @schema TunnelSpecCloudflare#accountName
   */
  readonly accountName?: string;

  /**
   * Cloudflare Domain to which this tunnel belongs to
   *
   * @schema TunnelSpecCloudflare#domain
   */
  readonly domain?: string;

  /**
   * Email to use along with API Key for Delete operations for new tunnels only, or as an alternate to API Token
   *
   * @schema TunnelSpecCloudflare#email
   */
  readonly email?: string;

  /**
   * Secret containing Cloudflare API key/token
   *
   * @schema TunnelSpecCloudflare#secret
   */
  readonly secret?: string;

}

/**
 * Converts an object of type 'TunnelSpecCloudflare' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TunnelSpecCloudflare(obj: TunnelSpecCloudflare | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'CLOUDFLARE_API_KEY': obj.cloudflareApiKey,
    'CLOUDFLARE_API_TOKEN': obj.cloudflareApiToken,
    'CLOUDFLARE_TUNNEL_CREDENTIAL_FILE': obj.cloudflareTunnelCredentialFile,
    'CLOUDFLARE_TUNNEL_CREDENTIAL_SECRET': obj.cloudflareTunnelCredentialSecret,
    'accountId': obj.accountId,
    'accountName': obj.accountName,
    'domain': obj.domain,
    'email': obj.email,
    'secret': obj.secret,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Existing tunnel object. ExistingTunnel and NewTunnel cannot be both empty and are mutually exclusive.
 *
 * @schema TunnelSpecExistingTunnel
 */
export interface TunnelSpecExistingTunnel {
  /**
   * Existing Tunnel ID to run on. Tunnel ID and Tunnel Name cannot be both empty. If both are provided, ID is used if valid, else falls back to Name.
   *
   * @schema TunnelSpecExistingTunnel#id
   */
  readonly id?: string;

  /**
   * Existing Tunnel name to run on. Tunnel Name and Tunnel ID cannot be both empty. If both are provided, ID is used if valid, else falls back to Name.
   *
   * @schema TunnelSpecExistingTunnel#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'TunnelSpecExistingTunnel' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TunnelSpecExistingTunnel(obj: TunnelSpecExistingTunnel | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'id': obj.id,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * New tunnel object. NewTunnel and ExistingTunnel cannot be both empty and are mutually exclusive.
 *
 * @schema TunnelSpecNewTunnel
 */
export interface TunnelSpecNewTunnel {
  /**
   * Tunnel name to create on Cloudflare.
   *
   * @schema TunnelSpecNewTunnel#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'TunnelSpecNewTunnel' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TunnelSpecNewTunnel(obj: TunnelSpecNewTunnel | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * TunnelBinding is the Schema for the tunnelbindings API
 *
 * @schema TunnelBinding
 */
export class TunnelBinding extends ApiObject {
  /**
   * Returns the apiVersion and kind for "TunnelBinding"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networking.cfargotunnel.com/v1alpha1',
    kind: 'TunnelBinding',
  }

  /**
   * Renders a Kubernetes manifest for "TunnelBinding".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: TunnelBindingProps): any {
    return {
      ...TunnelBinding.GVK,
      ...toJson_TunnelBindingProps(props),
    };
  }

  /**
   * Defines a "TunnelBinding" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: TunnelBindingProps) {
    super(scope, id, {
      ...TunnelBinding.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...TunnelBinding.GVK,
      ...toJson_TunnelBindingProps(resolved),
    };
  }
}

/**
 * TunnelBinding is the Schema for the tunnelbindings API
 *
 * @schema TunnelBinding
 */
export interface TunnelBindingProps {
  /**
   * @schema TunnelBinding#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema TunnelBinding#subjects
   */
  readonly subjects: TunnelBindingSubjects[];

  /**
   * TunnelRef defines the Tunnel TunnelBinding connects to
   *
   * @schema TunnelBinding#tunnelRef
   */
  readonly tunnelRef: TunnelBindingTunnelRef;

}

/**
 * Converts an object of type 'TunnelBindingProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TunnelBindingProps(obj: TunnelBindingProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'subjects': obj.subjects?.map(y => toJson_TunnelBindingSubjects(y)),
    'tunnelRef': toJson_TunnelBindingTunnelRef(obj.tunnelRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TunnelBindingSubject defines the subject TunnelBinding connects to the Tunnel
 *
 * @schema TunnelBindingSubjects
 */
export interface TunnelBindingSubjects {
  /**
   * Kind can be Service
   *
   * @schema TunnelBindingSubjects#kind
   */
  readonly kind?: string;

  /**
   * @schema TunnelBindingSubjects#name
   */
  readonly name: string;

  /**
   * @schema TunnelBindingSubjects#spec
   */
  readonly spec?: TunnelBindingSubjectsSpec;

}

/**
 * Converts an object of type 'TunnelBindingSubjects' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TunnelBindingSubjects(obj: TunnelBindingSubjects | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kind': obj.kind,
    'name': obj.name,
    'spec': toJson_TunnelBindingSubjectsSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TunnelRef defines the Tunnel TunnelBinding connects to
 *
 * @schema TunnelBindingTunnelRef
 */
export interface TunnelBindingTunnelRef {
  /**
   * DisableDNSUpdates disables the DNS updates on Cloudflare, just managing the configs. Assumes the DNS entries are manually added.
   *
   * @schema TunnelBindingTunnelRef#disableDNSUpdates
   */
  readonly disableDnsUpdates?: boolean;

  /**
   * Kind can be Tunnel or ClusterTunnel
   *
   * @schema TunnelBindingTunnelRef#kind
   */
  readonly kind: string;

  /**
   * Name of the tunnel resource
   *
   * @schema TunnelBindingTunnelRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'TunnelBindingTunnelRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TunnelBindingTunnelRef(obj: TunnelBindingTunnelRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disableDNSUpdates': obj.disableDnsUpdates,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TunnelBindingSubjectsSpec
 */
export interface TunnelBindingSubjectsSpec {
  /**
   * CaPool trusts the CA certificate referenced by the key in the secret specified in tunnel.spec.originCaPool. tls.crt is trusted globally and does not need to be specified. Only useful if the protocol is HTTPS.
   *
   * @schema TunnelBindingSubjectsSpec#caPool
   */
  readonly caPool?: string;

  /**
   * Fqdn specifies the DNS name to access this service from. Defaults to the service.metadata.name + tunnel.spec.domain. If specifying this, make sure to use the same domain that the tunnel belongs to. This is not validated and used as provided
   *
   * @default the service.metadata.name + tunnel.spec.domain. If specifying this, make sure to use the same domain that the tunnel belongs to. This is not validated and used as provided
   * @schema TunnelBindingSubjectsSpec#fqdn
   */
  readonly fqdn?: string;

  /**
   * NoTlsVerify disables TLS verification for this service. Only useful if the protocol is HTTPS.
   *
   * @schema TunnelBindingSubjectsSpec#noTlsVerify
   */
  readonly noTlsVerify?: boolean;

  /**
   * Path specifies a regular expression for to match on the request for http/https services If a rule does not specify a path, all paths will be matched.
   *
   * @schema TunnelBindingSubjectsSpec#path
   */
  readonly path?: string;

  /**
   * Protocol specifies the protocol for the service. Should be one of http, https, tcp, udp, ssh or rdp. Defaults to http, with the exceptions of https for 443, smb for 139 and 445, rdp for 3389 and ssh for 22 if the service has a TCP port. The only available option for a UDP port is udp, which is default.
   *
   * @default http, with the exceptions of https for 443, smb for 139 and 445, rdp for 3389 and ssh for 22 if the service has a TCP port. The only available option for a UDP port is udp, which is default.
   * @schema TunnelBindingSubjectsSpec#protocol
   */
  readonly protocol?: string;

  /**
   * ProxyAddress configures the listen address for that proxy
   *
   * @schema TunnelBindingSubjectsSpec#proxyAddress
   */
  readonly proxyAddress?: string;

  /**
   * ProxyPort configures the listen port for that proxy
   *
   * @schema TunnelBindingSubjectsSpec#proxyPort
   */
  readonly proxyPort?: number;

  /**
   * ProxyType configures the proxy type.
   *
   * @schema TunnelBindingSubjectsSpec#proxyType
   */
  readonly proxyType?: TunnelBindingSubjectsSpecProxyType;

  /**
   * Target specified where the tunnel should proxy to. Defaults to the form of <protocol>://<service.metadata.name>.<service.metadata.namespace>.svc:<port>
   *
   * @default the form of <protocol>://<service.metadata.name>.<service.metadata.namespace>.svc:<port>
   * @schema TunnelBindingSubjectsSpec#target
   */
  readonly target?: string;

}

/**
 * Converts an object of type 'TunnelBindingSubjectsSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TunnelBindingSubjectsSpec(obj: TunnelBindingSubjectsSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caPool': obj.caPool,
    'fqdn': obj.fqdn,
    'noTlsVerify': obj.noTlsVerify,
    'path': obj.path,
    'protocol': obj.protocol,
    'proxyAddress': obj.proxyAddress,
    'proxyPort': obj.proxyPort,
    'proxyType': obj.proxyType,
    'target': obj.target,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProxyType configures the proxy type.
 *
 * @schema TunnelBindingSubjectsSpecProxyType
 */
export enum TunnelBindingSubjectsSpecProxyType {
  /** socks */
  SOCKS = "socks",
}

