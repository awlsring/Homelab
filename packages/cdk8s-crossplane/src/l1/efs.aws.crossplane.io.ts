// @ts-nocheck
// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * AccessPoint is the Schema for the AccessPoints API
 *
 * @schema AccessPoint
 */
export class AccessPoint extends ApiObject {
  /**
   * Returns the apiVersion and kind for "AccessPoint"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'efs.aws.crossplane.io/v1alpha1',
    kind: 'AccessPoint',
  }

  /**
   * Renders a Kubernetes manifest for "AccessPoint".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AccessPointProps): any {
    return {
      ...AccessPoint.GVK,
      ...toJson_AccessPointProps(props),
    };
  }

  /**
   * Defines a "AccessPoint" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AccessPointProps) {
    super(scope, id, {
      ...AccessPoint.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...AccessPoint.GVK,
      ...toJson_AccessPointProps(resolved),
    };
  }
}

/**
 * AccessPoint is the Schema for the AccessPoints API
 *
 * @schema AccessPoint
 */
export interface AccessPointProps {
  /**
   * @schema AccessPoint#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AccessPointSpec defines the desired state of AccessPoint
   *
   * @schema AccessPoint#spec
   */
  readonly spec: AccessPointSpec;

}

/**
 * Converts an object of type 'AccessPointProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointProps(obj: AccessPointProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AccessPointSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AccessPointSpec defines the desired state of AccessPoint
 *
 * @schema AccessPointSpec
 */
export interface AccessPointSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema AccessPointSpec#deletionPolicy
   */
  readonly deletionPolicy?: AccessPointSpecDeletionPolicy;

  /**
   * AccessPointParameters defines the desired state of AccessPoint
   *
   * @schema AccessPointSpec#forProvider
   */
  readonly forProvider: AccessPointSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema AccessPointSpec#managementPolicies
   */
  readonly managementPolicies?: AccessPointSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema AccessPointSpec#providerConfigRef
   */
  readonly providerConfigRef?: AccessPointSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema AccessPointSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: AccessPointSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema AccessPointSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: AccessPointSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'AccessPointSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpec(obj: AccessPointSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_AccessPointSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_AccessPointSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_AccessPointSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_AccessPointSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema AccessPointSpecDeletionPolicy
 */
export enum AccessPointSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * AccessPointParameters defines the desired state of AccessPoint
 *
 * @schema AccessPointSpecForProvider
 */
export interface AccessPointSpecForProvider {
  /**
   * The ID of the file system for which to create the mount target.
   *
   * @schema AccessPointSpecForProvider#fileSystemID
   */
  readonly fileSystemId?: string;

  /**
   * FileSystemIDRef are references to Filesystem used to set the FileSystemID.
   *
   * @schema AccessPointSpecForProvider#fileSystemIDRef
   */
  readonly fileSystemIdRef?: AccessPointSpecForProviderFileSystemIdRef;

  /**
   * FileSystemIDSelector selects references to Filesystem used to set the FileSystemID.
   *
   * @schema AccessPointSpecForProvider#fileSystemIDSelector
   */
  readonly fileSystemIdSelector?: AccessPointSpecForProviderFileSystemIdSelector;

  /**
   * The operating system user and group applied to all file system requests made using the access point.
   *
   * @schema AccessPointSpecForProvider#posixUser
   */
  readonly posixUser?: AccessPointSpecForProviderPosixUser;

  /**
   * Region is which region the AccessPoint will be created.
   *
   * @schema AccessPointSpecForProvider#region
   */
  readonly region: string;

  /**
   * Specifies the directory on the Amazon EFS file system that the access point exposes as the root directory of your file system to NFS clients using the access point. The clients using the access point can only access the root directory and below. If the RootDirectory > Path specified does not exist, EFS creates it and applies the CreationInfo settings when a client connects to an access point. When specifying a RootDirectory, you must provide the Path, and the CreationInfo.
   * Amazon EFS creates a root directory only if you have provided the CreationInfo: OwnUid, OwnGID, and permissions for the directory. If you do not provide this information, Amazon EFS does not create the root directory. If the root directory does not exist, attempts to mount using the access point will fail.
   *
   * @schema AccessPointSpecForProvider#rootDirectory
   */
  readonly rootDirectory?: AccessPointSpecForProviderRootDirectory;

  /**
   * Creates tags associated with the access point. Each tag is a key-value pair, each key must be unique. For more information, see Tagging Amazon Web Services resources (https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) in the Amazon Web Services General Reference Guide.
   *
   * @schema AccessPointSpecForProvider#tags
   */
  readonly tags?: AccessPointSpecForProviderTags[];

}

/**
 * Converts an object of type 'AccessPointSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecForProvider(obj: AccessPointSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fileSystemID': obj.fileSystemId,
    'fileSystemIDRef': toJson_AccessPointSpecForProviderFileSystemIdRef(obj.fileSystemIdRef),
    'fileSystemIDSelector': toJson_AccessPointSpecForProviderFileSystemIdSelector(obj.fileSystemIdSelector),
    'posixUser': toJson_AccessPointSpecForProviderPosixUser(obj.posixUser),
    'region': obj.region,
    'rootDirectory': toJson_AccessPointSpecForProviderRootDirectory(obj.rootDirectory),
    'tags': obj.tags?.map(y => toJson_AccessPointSpecForProviderTags(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema AccessPointSpecManagementPolicies
 */
export enum AccessPointSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema AccessPointSpecProviderConfigRef
 */
export interface AccessPointSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AccessPointSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AccessPointSpecProviderConfigRef#policy
   */
  readonly policy?: AccessPointSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'AccessPointSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecProviderConfigRef(obj: AccessPointSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AccessPointSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema AccessPointSpecPublishConnectionDetailsTo
 */
export interface AccessPointSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema AccessPointSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: AccessPointSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema AccessPointSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: AccessPointSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema AccessPointSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'AccessPointSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecPublishConnectionDetailsTo(obj: AccessPointSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_AccessPointSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_AccessPointSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema AccessPointSpecWriteConnectionSecretToRef
 */
export interface AccessPointSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema AccessPointSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema AccessPointSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'AccessPointSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecWriteConnectionSecretToRef(obj: AccessPointSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FileSystemIDRef are references to Filesystem used to set the FileSystemID.
 *
 * @schema AccessPointSpecForProviderFileSystemIdRef
 */
export interface AccessPointSpecForProviderFileSystemIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema AccessPointSpecForProviderFileSystemIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AccessPointSpecForProviderFileSystemIdRef#policy
   */
  readonly policy?: AccessPointSpecForProviderFileSystemIdRefPolicy;

}

/**
 * Converts an object of type 'AccessPointSpecForProviderFileSystemIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecForProviderFileSystemIdRef(obj: AccessPointSpecForProviderFileSystemIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AccessPointSpecForProviderFileSystemIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FileSystemIDSelector selects references to Filesystem used to set the FileSystemID.
 *
 * @schema AccessPointSpecForProviderFileSystemIdSelector
 */
export interface AccessPointSpecForProviderFileSystemIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema AccessPointSpecForProviderFileSystemIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema AccessPointSpecForProviderFileSystemIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema AccessPointSpecForProviderFileSystemIdSelector#policy
   */
  readonly policy?: AccessPointSpecForProviderFileSystemIdSelectorPolicy;

}

/**
 * Converts an object of type 'AccessPointSpecForProviderFileSystemIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecForProviderFileSystemIdSelector(obj: AccessPointSpecForProviderFileSystemIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_AccessPointSpecForProviderFileSystemIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The operating system user and group applied to all file system requests made using the access point.
 *
 * @schema AccessPointSpecForProviderPosixUser
 */
export interface AccessPointSpecForProviderPosixUser {
  /**
   * @schema AccessPointSpecForProviderPosixUser#gid
   */
  readonly gid?: number;

  /**
   * @schema AccessPointSpecForProviderPosixUser#secondaryGids
   */
  readonly secondaryGids?: number[];

  /**
   * @schema AccessPointSpecForProviderPosixUser#uid
   */
  readonly uid?: number;

}

/**
 * Converts an object of type 'AccessPointSpecForProviderPosixUser' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecForProviderPosixUser(obj: AccessPointSpecForProviderPosixUser | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gid': obj.gid,
    'secondaryGids': obj.secondaryGids?.map(y => y),
    'uid': obj.uid,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the directory on the Amazon EFS file system that the access point exposes as the root directory of your file system to NFS clients using the access point. The clients using the access point can only access the root directory and below. If the RootDirectory > Path specified does not exist, EFS creates it and applies the CreationInfo settings when a client connects to an access point. When specifying a RootDirectory, you must provide the Path, and the CreationInfo.
 * Amazon EFS creates a root directory only if you have provided the CreationInfo: OwnUid, OwnGID, and permissions for the directory. If you do not provide this information, Amazon EFS does not create the root directory. If the root directory does not exist, attempts to mount using the access point will fail.
 *
 * @schema AccessPointSpecForProviderRootDirectory
 */
export interface AccessPointSpecForProviderRootDirectory {
  /**
   * Required if the RootDirectory > Path specified does not exist. Specifies the POSIX IDs and permissions to apply to the access point's RootDirectory > Path. If the access point root directory does not exist, EFS creates it with these settings when a client connects to the access point. When specifying CreationInfo, you must include values for all properties.
   * Amazon EFS creates a root directory only if you have provided the CreationInfo: OwnUid, OwnGID, and permissions for the directory. If you do not provide this information, Amazon EFS does not create the root directory. If the root directory does not exist, attempts to mount using the access point will fail.
   * If you do not provide CreationInfo and the specified RootDirectory does not exist, attempts to mount the file system using the access point will fail.
   *
   * @schema AccessPointSpecForProviderRootDirectory#creationInfo
   */
  readonly creationInfo?: AccessPointSpecForProviderRootDirectoryCreationInfo;

  /**
   * @schema AccessPointSpecForProviderRootDirectory#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'AccessPointSpecForProviderRootDirectory' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecForProviderRootDirectory(obj: AccessPointSpecForProviderRootDirectory | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'creationInfo': toJson_AccessPointSpecForProviderRootDirectoryCreationInfo(obj.creationInfo),
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AccessPointSpecForProviderTags
 */
export interface AccessPointSpecForProviderTags {
  /**
   * @schema AccessPointSpecForProviderTags#key
   */
  readonly key?: string;

  /**
   * @schema AccessPointSpecForProviderTags#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'AccessPointSpecForProviderTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecForProviderTags(obj: AccessPointSpecForProviderTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AccessPointSpecProviderConfigRefPolicy
 */
export interface AccessPointSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AccessPointSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: AccessPointSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AccessPointSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: AccessPointSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AccessPointSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecProviderConfigRefPolicy(obj: AccessPointSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema AccessPointSpecPublishConnectionDetailsToConfigRef
 */
export interface AccessPointSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AccessPointSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AccessPointSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: AccessPointSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'AccessPointSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecPublishConnectionDetailsToConfigRef(obj: AccessPointSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AccessPointSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema AccessPointSpecPublishConnectionDetailsToMetadata
 */
export interface AccessPointSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema AccessPointSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema AccessPointSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema AccessPointSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AccessPointSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecPublishConnectionDetailsToMetadata(obj: AccessPointSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AccessPointSpecForProviderFileSystemIdRefPolicy
 */
export interface AccessPointSpecForProviderFileSystemIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AccessPointSpecForProviderFileSystemIdRefPolicy#resolution
   */
  readonly resolution?: AccessPointSpecForProviderFileSystemIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AccessPointSpecForProviderFileSystemIdRefPolicy#resolve
   */
  readonly resolve?: AccessPointSpecForProviderFileSystemIdRefPolicyResolve;

}

/**
 * Converts an object of type 'AccessPointSpecForProviderFileSystemIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecForProviderFileSystemIdRefPolicy(obj: AccessPointSpecForProviderFileSystemIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema AccessPointSpecForProviderFileSystemIdSelectorPolicy
 */
export interface AccessPointSpecForProviderFileSystemIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AccessPointSpecForProviderFileSystemIdSelectorPolicy#resolution
   */
  readonly resolution?: AccessPointSpecForProviderFileSystemIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AccessPointSpecForProviderFileSystemIdSelectorPolicy#resolve
   */
  readonly resolve?: AccessPointSpecForProviderFileSystemIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'AccessPointSpecForProviderFileSystemIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecForProviderFileSystemIdSelectorPolicy(obj: AccessPointSpecForProviderFileSystemIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required if the RootDirectory > Path specified does not exist. Specifies the POSIX IDs and permissions to apply to the access point's RootDirectory > Path. If the access point root directory does not exist, EFS creates it with these settings when a client connects to the access point. When specifying CreationInfo, you must include values for all properties.
 * Amazon EFS creates a root directory only if you have provided the CreationInfo: OwnUid, OwnGID, and permissions for the directory. If you do not provide this information, Amazon EFS does not create the root directory. If the root directory does not exist, attempts to mount using the access point will fail.
 * If you do not provide CreationInfo and the specified RootDirectory does not exist, attempts to mount the file system using the access point will fail.
 *
 * @schema AccessPointSpecForProviderRootDirectoryCreationInfo
 */
export interface AccessPointSpecForProviderRootDirectoryCreationInfo {
  /**
   * @schema AccessPointSpecForProviderRootDirectoryCreationInfo#ownerGid
   */
  readonly ownerGid?: number;

  /**
   * @schema AccessPointSpecForProviderRootDirectoryCreationInfo#ownerUid
   */
  readonly ownerUid?: number;

  /**
   * @schema AccessPointSpecForProviderRootDirectoryCreationInfo#permissions
   */
  readonly permissions?: string;

}

/**
 * Converts an object of type 'AccessPointSpecForProviderRootDirectoryCreationInfo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecForProviderRootDirectoryCreationInfo(obj: AccessPointSpecForProviderRootDirectoryCreationInfo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ownerGid': obj.ownerGid,
    'ownerUid': obj.ownerUid,
    'permissions': obj.permissions,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AccessPointSpecProviderConfigRefPolicyResolution
 */
export enum AccessPointSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AccessPointSpecProviderConfigRefPolicyResolve
 */
export enum AccessPointSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema AccessPointSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface AccessPointSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AccessPointSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: AccessPointSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AccessPointSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: AccessPointSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AccessPointSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecPublishConnectionDetailsToConfigRefPolicy(obj: AccessPointSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AccessPointSpecForProviderFileSystemIdRefPolicyResolution
 */
export enum AccessPointSpecForProviderFileSystemIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AccessPointSpecForProviderFileSystemIdRefPolicyResolve
 */
export enum AccessPointSpecForProviderFileSystemIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AccessPointSpecForProviderFileSystemIdSelectorPolicyResolution
 */
export enum AccessPointSpecForProviderFileSystemIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AccessPointSpecForProviderFileSystemIdSelectorPolicyResolve
 */
export enum AccessPointSpecForProviderFileSystemIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AccessPointSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum AccessPointSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AccessPointSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum AccessPointSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * FileSystem is the Schema for the FileSystems API
 *
 * @schema FileSystem
 */
export class FileSystem extends ApiObject {
  /**
   * Returns the apiVersion and kind for "FileSystem"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'efs.aws.crossplane.io/v1alpha1',
    kind: 'FileSystem',
  }

  /**
   * Renders a Kubernetes manifest for "FileSystem".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: FileSystemProps): any {
    return {
      ...FileSystem.GVK,
      ...toJson_FileSystemProps(props),
    };
  }

  /**
   * Defines a "FileSystem" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: FileSystemProps) {
    super(scope, id, {
      ...FileSystem.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...FileSystem.GVK,
      ...toJson_FileSystemProps(resolved),
    };
  }
}

/**
 * FileSystem is the Schema for the FileSystems API
 *
 * @schema FileSystem
 */
export interface FileSystemProps {
  /**
   * @schema FileSystem#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * FileSystemSpec defines the desired state of FileSystem
   *
   * @schema FileSystem#spec
   */
  readonly spec: FileSystemSpec;

}

/**
 * Converts an object of type 'FileSystemProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FileSystemProps(obj: FileSystemProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_FileSystemSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FileSystemSpec defines the desired state of FileSystem
 *
 * @schema FileSystemSpec
 */
export interface FileSystemSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema FileSystemSpec#deletionPolicy
   */
  readonly deletionPolicy?: FileSystemSpecDeletionPolicy;

  /**
   * FileSystemParameters defines the desired state of FileSystem
   *
   * @schema FileSystemSpec#forProvider
   */
  readonly forProvider: FileSystemSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema FileSystemSpec#managementPolicies
   */
  readonly managementPolicies?: FileSystemSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema FileSystemSpec#providerConfigRef
   */
  readonly providerConfigRef?: FileSystemSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema FileSystemSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: FileSystemSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema FileSystemSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: FileSystemSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'FileSystemSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FileSystemSpec(obj: FileSystemSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_FileSystemSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_FileSystemSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_FileSystemSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_FileSystemSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema FileSystemSpecDeletionPolicy
 */
export enum FileSystemSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * FileSystemParameters defines the desired state of FileSystem
 *
 * @schema FileSystemSpecForProvider
 */
export interface FileSystemSpecForProvider {
  /**
   * Used to create a file system that uses One Zone storage classes. It specifies the Amazon Web Services Availability Zone in which to create the file system. Use the format us-east-1a to specify the Availability Zone. For more information about One Zone storage classes, see Using EFS storage classes (https://docs.aws.amazon.com/efs/latest/ug/storage-classes.html) in the Amazon EFS User Guide.
   * One Zone storage classes are not available in all Availability Zones in Amazon Web Services Regions where Amazon EFS is available.
   *
   * @schema FileSystemSpecForProvider#availabilityZoneName
   */
  readonly availabilityZoneName?: string;

  /**
   * Specifies whether automatic backups are enabled on the file system that you are creating. Set the value to true to enable automatic backups. If you are creating a file system that uses One Zone storage classes, automatic backups are enabled by default. For more information, see Automatic backups (https://docs.aws.amazon.com/efs/latest/ug/awsbackup.html#automatic-backups) in the Amazon EFS User Guide.
   * Default is false. However, if you specify an AvailabilityZoneName, the default is true.
   * Backup is not available in all Amazon Web Services Regions where Amazon EFS is available.
   *
   * @default false. However, if you specify an AvailabilityZoneName, the default is true.
   * @schema FileSystemSpecForProvider#backup
   */
  readonly backup?: boolean;

  /**
   * A Boolean value that, if true, creates an encrypted file system. When creating an encrypted file system, you have the option of specifying an existing Key Management Service key (KMS key). If you don't specify a KMS key, then the default KMS key for Amazon EFS, /aws/elasticfilesystem, is used to protect the encrypted file system.
   *
   * @schema FileSystemSpecForProvider#encrypted
   */
  readonly encrypted?: boolean;

  /**
   * The ID of the KMS key that you want to use to protect the encrypted file system. This parameter is required only if you want to use a non-default KMS key. If this parameter is not specified, the default KMS key for Amazon EFS is used. You can specify a KMS key ID using the following formats:
   * * Key ID - A unique identifier of the key, for example 1234abcd-12ab-34cd-56ef-1234567890ab.
   * * ARN - An Amazon Resource Name (ARN) for the key, for example arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab.
   * * Key alias - A previously created display name for a key, for example alias/projectKey1.
   * * Key alias ARN - An ARN for a key alias, for example arn:aws:kms:us-west-2:444455556666:alias/projectKey1.
   * If you use KmsKeyId, you must set the CreateFileSystemRequest$Encrypted parameter to true.
   * EFS accepts only symmetric KMS keys. You cannot use asymmetric KMS keys with Amazon EFS file systems.
   *
   * @schema FileSystemSpecForProvider#kmsKeyID
   */
  readonly kmsKeyId?: string;

  /**
   * KMSKeyIDRef is a reference to an Key used to set the KMSKeyID.
   *
   * @schema FileSystemSpecForProvider#kmsKeyIdRef
   */
  readonly kmsKeyIdRef?: FileSystemSpecForProviderKmsKeyIdRef;

  /**
   * KMSKeyIDSelector selects references to Key used to set the KMSKeyID.
   *
   * @schema FileSystemSpecForProvider#kmsKeyIdSelector
   */
  readonly kmsKeyIdSelector?: FileSystemSpecForProviderKmsKeyIdSelector;

  /**
   * The performance mode of the file system. We recommend generalPurpose performance mode for most file systems. File systems using the maxIO performance mode can scale to higher levels of aggregate throughput and operations per second with a tradeoff of slightly higher latencies for most file operations. The performance mode can't be changed after the file system has been created.
   * The maxIO mode is not supported on file systems using One Zone storage classes.
   *
   * @schema FileSystemSpecForProvider#performanceMode
   */
  readonly performanceMode?: string;

  /**
   * The throughput, measured in MiB/s, that you want to provision for a file system that you're creating. Valid values are 1-1024. Required if ThroughputMode is set to provisioned. The upper limit for throughput is 1024 MiB/s. You can get this limit increased by contacting AWS Support. For more information, see Amazon EFS Limits That You Can Increase (https://docs.aws.amazon.com/efs/latest/ug/limits.html#soft-limits) in the Amazon EFS User Guide.
   *
   * @schema FileSystemSpecForProvider#provisionedThroughputInMibps
   */
  readonly provisionedThroughputInMibps?: number;

  /**
   * Region is which region the FileSystem will be created.
   *
   * @schema FileSystemSpecForProvider#region
   */
  readonly region: string;

  /**
   * Use to create one or more tags associated with the file system. Each tag is a user-defined key-value pair. Name your file system on creation by including a "Key":"Name","Value":"{value}" key-value pair. Each key must be unique. For more information, see Tagging Amazon Web Services resources (https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) in the Amazon Web Services General Reference Guide.
   *
   * @schema FileSystemSpecForProvider#tags
   */
  readonly tags?: FileSystemSpecForProviderTags[];

  /**
   * Specifies the throughput mode for the file system. The mode can be bursting, provisioned, or elastic. If you set ThroughputMode to provisioned, you must also set a value for ProvisionedThroughputInMibps. After you create the file system, you can decrease your file system's throughput in Provisioned Throughput mode or change between the throughput modes, with certain time restrictions. For more information, see Specifying throughput with provisioned mode (https://docs.aws.amazon.com/efs/latest/ug/performance.html#provisioned-throughput) in the Amazon EFS User Guide.
   * Default is bursting.
   *
   * @default bursting.
   * @schema FileSystemSpecForProvider#throughputMode
   */
  readonly throughputMode?: string;

}

/**
 * Converts an object of type 'FileSystemSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FileSystemSpecForProvider(obj: FileSystemSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'availabilityZoneName': obj.availabilityZoneName,
    'backup': obj.backup,
    'encrypted': obj.encrypted,
    'kmsKeyID': obj.kmsKeyId,
    'kmsKeyIdRef': toJson_FileSystemSpecForProviderKmsKeyIdRef(obj.kmsKeyIdRef),
    'kmsKeyIdSelector': toJson_FileSystemSpecForProviderKmsKeyIdSelector(obj.kmsKeyIdSelector),
    'performanceMode': obj.performanceMode,
    'provisionedThroughputInMibps': obj.provisionedThroughputInMibps,
    'region': obj.region,
    'tags': obj.tags?.map(y => toJson_FileSystemSpecForProviderTags(y)),
    'throughputMode': obj.throughputMode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema FileSystemSpecManagementPolicies
 */
export enum FileSystemSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema FileSystemSpecProviderConfigRef
 */
export interface FileSystemSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FileSystemSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FileSystemSpecProviderConfigRef#policy
   */
  readonly policy?: FileSystemSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'FileSystemSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FileSystemSpecProviderConfigRef(obj: FileSystemSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FileSystemSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema FileSystemSpecPublishConnectionDetailsTo
 */
export interface FileSystemSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema FileSystemSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: FileSystemSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema FileSystemSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: FileSystemSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema FileSystemSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'FileSystemSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FileSystemSpecPublishConnectionDetailsTo(obj: FileSystemSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_FileSystemSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_FileSystemSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema FileSystemSpecWriteConnectionSecretToRef
 */
export interface FileSystemSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema FileSystemSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema FileSystemSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'FileSystemSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FileSystemSpecWriteConnectionSecretToRef(obj: FileSystemSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * KMSKeyIDRef is a reference to an Key used to set the KMSKeyID.
 *
 * @schema FileSystemSpecForProviderKmsKeyIdRef
 */
export interface FileSystemSpecForProviderKmsKeyIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema FileSystemSpecForProviderKmsKeyIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FileSystemSpecForProviderKmsKeyIdRef#policy
   */
  readonly policy?: FileSystemSpecForProviderKmsKeyIdRefPolicy;

}

/**
 * Converts an object of type 'FileSystemSpecForProviderKmsKeyIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FileSystemSpecForProviderKmsKeyIdRef(obj: FileSystemSpecForProviderKmsKeyIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FileSystemSpecForProviderKmsKeyIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * KMSKeyIDSelector selects references to Key used to set the KMSKeyID.
 *
 * @schema FileSystemSpecForProviderKmsKeyIdSelector
 */
export interface FileSystemSpecForProviderKmsKeyIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FileSystemSpecForProviderKmsKeyIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FileSystemSpecForProviderKmsKeyIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FileSystemSpecForProviderKmsKeyIdSelector#policy
   */
  readonly policy?: FileSystemSpecForProviderKmsKeyIdSelectorPolicy;

}

/**
 * Converts an object of type 'FileSystemSpecForProviderKmsKeyIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FileSystemSpecForProviderKmsKeyIdSelector(obj: FileSystemSpecForProviderKmsKeyIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FileSystemSpecForProviderKmsKeyIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FileSystemSpecForProviderTags
 */
export interface FileSystemSpecForProviderTags {
  /**
   * @schema FileSystemSpecForProviderTags#key
   */
  readonly key?: string;

  /**
   * @schema FileSystemSpecForProviderTags#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'FileSystemSpecForProviderTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FileSystemSpecForProviderTags(obj: FileSystemSpecForProviderTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FileSystemSpecProviderConfigRefPolicy
 */
export interface FileSystemSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FileSystemSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: FileSystemSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FileSystemSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: FileSystemSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FileSystemSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FileSystemSpecProviderConfigRefPolicy(obj: FileSystemSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema FileSystemSpecPublishConnectionDetailsToConfigRef
 */
export interface FileSystemSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FileSystemSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FileSystemSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: FileSystemSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'FileSystemSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FileSystemSpecPublishConnectionDetailsToConfigRef(obj: FileSystemSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FileSystemSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema FileSystemSpecPublishConnectionDetailsToMetadata
 */
export interface FileSystemSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema FileSystemSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema FileSystemSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema FileSystemSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'FileSystemSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FileSystemSpecPublishConnectionDetailsToMetadata(obj: FileSystemSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FileSystemSpecForProviderKmsKeyIdRefPolicy
 */
export interface FileSystemSpecForProviderKmsKeyIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FileSystemSpecForProviderKmsKeyIdRefPolicy#resolution
   */
  readonly resolution?: FileSystemSpecForProviderKmsKeyIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FileSystemSpecForProviderKmsKeyIdRefPolicy#resolve
   */
  readonly resolve?: FileSystemSpecForProviderKmsKeyIdRefPolicyResolve;

}

/**
 * Converts an object of type 'FileSystemSpecForProviderKmsKeyIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FileSystemSpecForProviderKmsKeyIdRefPolicy(obj: FileSystemSpecForProviderKmsKeyIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FileSystemSpecForProviderKmsKeyIdSelectorPolicy
 */
export interface FileSystemSpecForProviderKmsKeyIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FileSystemSpecForProviderKmsKeyIdSelectorPolicy#resolution
   */
  readonly resolution?: FileSystemSpecForProviderKmsKeyIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FileSystemSpecForProviderKmsKeyIdSelectorPolicy#resolve
   */
  readonly resolve?: FileSystemSpecForProviderKmsKeyIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FileSystemSpecForProviderKmsKeyIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FileSystemSpecForProviderKmsKeyIdSelectorPolicy(obj: FileSystemSpecForProviderKmsKeyIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FileSystemSpecProviderConfigRefPolicyResolution
 */
export enum FileSystemSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FileSystemSpecProviderConfigRefPolicyResolve
 */
export enum FileSystemSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema FileSystemSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface FileSystemSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FileSystemSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: FileSystemSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FileSystemSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: FileSystemSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FileSystemSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FileSystemSpecPublishConnectionDetailsToConfigRefPolicy(obj: FileSystemSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FileSystemSpecForProviderKmsKeyIdRefPolicyResolution
 */
export enum FileSystemSpecForProviderKmsKeyIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FileSystemSpecForProviderKmsKeyIdRefPolicyResolve
 */
export enum FileSystemSpecForProviderKmsKeyIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FileSystemSpecForProviderKmsKeyIdSelectorPolicyResolution
 */
export enum FileSystemSpecForProviderKmsKeyIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FileSystemSpecForProviderKmsKeyIdSelectorPolicyResolve
 */
export enum FileSystemSpecForProviderKmsKeyIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FileSystemSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum FileSystemSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FileSystemSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum FileSystemSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * MountTarget is the Schema for the MountTargets API
 *
 * @schema MountTarget
 */
export class MountTarget extends ApiObject {
  /**
   * Returns the apiVersion and kind for "MountTarget"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'efs.aws.crossplane.io/v1alpha1',
    kind: 'MountTarget',
  }

  /**
   * Renders a Kubernetes manifest for "MountTarget".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: MountTargetProps): any {
    return {
      ...MountTarget.GVK,
      ...toJson_MountTargetProps(props),
    };
  }

  /**
   * Defines a "MountTarget" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: MountTargetProps) {
    super(scope, id, {
      ...MountTarget.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...MountTarget.GVK,
      ...toJson_MountTargetProps(resolved),
    };
  }
}

/**
 * MountTarget is the Schema for the MountTargets API
 *
 * @schema MountTarget
 */
export interface MountTargetProps {
  /**
   * @schema MountTarget#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * MountTargetSpec defines the desired state of MountTarget
   *
   * @schema MountTarget#spec
   */
  readonly spec: MountTargetSpec;

}

/**
 * Converts an object of type 'MountTargetProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MountTargetProps(obj: MountTargetProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_MountTargetSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * MountTargetSpec defines the desired state of MountTarget
 *
 * @schema MountTargetSpec
 */
export interface MountTargetSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema MountTargetSpec#deletionPolicy
   */
  readonly deletionPolicy?: MountTargetSpecDeletionPolicy;

  /**
   * MountTargetParameters defines the desired state of MountTarget
   *
   * @schema MountTargetSpec#forProvider
   */
  readonly forProvider: MountTargetSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema MountTargetSpec#managementPolicies
   */
  readonly managementPolicies?: MountTargetSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema MountTargetSpec#providerConfigRef
   */
  readonly providerConfigRef?: MountTargetSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema MountTargetSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: MountTargetSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema MountTargetSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: MountTargetSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'MountTargetSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MountTargetSpec(obj: MountTargetSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_MountTargetSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_MountTargetSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_MountTargetSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_MountTargetSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema MountTargetSpecDeletionPolicy
 */
export enum MountTargetSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * MountTargetParameters defines the desired state of MountTarget
 *
 * @schema MountTargetSpecForProvider
 */
export interface MountTargetSpecForProvider {
  /**
   * The ID of the file system for which to create the mount target.
   *
   * @schema MountTargetSpecForProvider#fileSystemID
   */
  readonly fileSystemId?: string;

  /**
   * FileSystemIDRef are references to Filesystem used to set the FileSystemID.
   *
   * @schema MountTargetSpecForProvider#fileSystemIDRef
   */
  readonly fileSystemIdRef?: MountTargetSpecForProviderFileSystemIdRef;

  /**
   * FileSystemIDSelector selects references to Filesystem used to set the FileSystemID.
   *
   * @schema MountTargetSpecForProvider#fileSystemIDSelector
   */
  readonly fileSystemIdSelector?: MountTargetSpecForProviderFileSystemIdSelector;

  /**
   * Valid IPv4 address within the address range of the specified subnet.
   *
   * @schema MountTargetSpecForProvider#ipAddress
   */
  readonly ipAddress?: string;

  /**
   * Region is which region the MountTarget will be created.
   *
   * @schema MountTargetSpecForProvider#region
   */
  readonly region: string;

  /**
   * Up to five VPC security group IDs, of the form sg-xxxxxxxx. These must be for the same VPC as subnet specified.
   *
   * @schema MountTargetSpecForProvider#securityGroups
   */
  readonly securityGroups?: string[];

  /**
   * SecurityGroupIDRefs are references to SecurityGroups used to set the SecurityGroupIDs.
   *
   * @schema MountTargetSpecForProvider#securityGroupsRefs
   */
  readonly securityGroupsRefs?: MountTargetSpecForProviderSecurityGroupsRefs[];

  /**
   * SecurityGroupIDSelector selects references to SecurityGroups used to set the SecurityGroupIDs.
   *
   * @schema MountTargetSpecForProvider#securityGroupsSelector
   */
  readonly securityGroupsSelector?: MountTargetSpecForProviderSecurityGroupsSelector;

  /**
   * The ID of the subnet to add the mount target in.
   *
   * @schema MountTargetSpecForProvider#subnetID
   */
  readonly subnetId?: string;

  /**
   * SubnetIDRef are references to Subnet used to set the SubnetID.
   *
   * @schema MountTargetSpecForProvider#subnetIDRef
   */
  readonly subnetIdRef?: MountTargetSpecForProviderSubnetIdRef;

  /**
   * SubnetIDSelector selects references to Subnet used to set the SubnetID.
   *
   * @schema MountTargetSpecForProvider#subnetIDSelector
   */
  readonly subnetIdSelector?: MountTargetSpecForProviderSubnetIdSelector;

}

/**
 * Converts an object of type 'MountTargetSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MountTargetSpecForProvider(obj: MountTargetSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fileSystemID': obj.fileSystemId,
    'fileSystemIDRef': toJson_MountTargetSpecForProviderFileSystemIdRef(obj.fileSystemIdRef),
    'fileSystemIDSelector': toJson_MountTargetSpecForProviderFileSystemIdSelector(obj.fileSystemIdSelector),
    'ipAddress': obj.ipAddress,
    'region': obj.region,
    'securityGroups': obj.securityGroups?.map(y => y),
    'securityGroupsRefs': obj.securityGroupsRefs?.map(y => toJson_MountTargetSpecForProviderSecurityGroupsRefs(y)),
    'securityGroupsSelector': toJson_MountTargetSpecForProviderSecurityGroupsSelector(obj.securityGroupsSelector),
    'subnetID': obj.subnetId,
    'subnetIDRef': toJson_MountTargetSpecForProviderSubnetIdRef(obj.subnetIdRef),
    'subnetIDSelector': toJson_MountTargetSpecForProviderSubnetIdSelector(obj.subnetIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema MountTargetSpecManagementPolicies
 */
export enum MountTargetSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema MountTargetSpecProviderConfigRef
 */
export interface MountTargetSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema MountTargetSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MountTargetSpecProviderConfigRef#policy
   */
  readonly policy?: MountTargetSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'MountTargetSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MountTargetSpecProviderConfigRef(obj: MountTargetSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MountTargetSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema MountTargetSpecPublishConnectionDetailsTo
 */
export interface MountTargetSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema MountTargetSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: MountTargetSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema MountTargetSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: MountTargetSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema MountTargetSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'MountTargetSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MountTargetSpecPublishConnectionDetailsTo(obj: MountTargetSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_MountTargetSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_MountTargetSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema MountTargetSpecWriteConnectionSecretToRef
 */
export interface MountTargetSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema MountTargetSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema MountTargetSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'MountTargetSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MountTargetSpecWriteConnectionSecretToRef(obj: MountTargetSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FileSystemIDRef are references to Filesystem used to set the FileSystemID.
 *
 * @schema MountTargetSpecForProviderFileSystemIdRef
 */
export interface MountTargetSpecForProviderFileSystemIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema MountTargetSpecForProviderFileSystemIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MountTargetSpecForProviderFileSystemIdRef#policy
   */
  readonly policy?: MountTargetSpecForProviderFileSystemIdRefPolicy;

}

/**
 * Converts an object of type 'MountTargetSpecForProviderFileSystemIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MountTargetSpecForProviderFileSystemIdRef(obj: MountTargetSpecForProviderFileSystemIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MountTargetSpecForProviderFileSystemIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FileSystemIDSelector selects references to Filesystem used to set the FileSystemID.
 *
 * @schema MountTargetSpecForProviderFileSystemIdSelector
 */
export interface MountTargetSpecForProviderFileSystemIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema MountTargetSpecForProviderFileSystemIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema MountTargetSpecForProviderFileSystemIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema MountTargetSpecForProviderFileSystemIdSelector#policy
   */
  readonly policy?: MountTargetSpecForProviderFileSystemIdSelectorPolicy;

}

/**
 * Converts an object of type 'MountTargetSpecForProviderFileSystemIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MountTargetSpecForProviderFileSystemIdSelector(obj: MountTargetSpecForProviderFileSystemIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_MountTargetSpecForProviderFileSystemIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema MountTargetSpecForProviderSecurityGroupsRefs
 */
export interface MountTargetSpecForProviderSecurityGroupsRefs {
  /**
   * Name of the referenced object.
   *
   * @schema MountTargetSpecForProviderSecurityGroupsRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MountTargetSpecForProviderSecurityGroupsRefs#policy
   */
  readonly policy?: MountTargetSpecForProviderSecurityGroupsRefsPolicy;

}

/**
 * Converts an object of type 'MountTargetSpecForProviderSecurityGroupsRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MountTargetSpecForProviderSecurityGroupsRefs(obj: MountTargetSpecForProviderSecurityGroupsRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MountTargetSpecForProviderSecurityGroupsRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecurityGroupIDSelector selects references to SecurityGroups used to set the SecurityGroupIDs.
 *
 * @schema MountTargetSpecForProviderSecurityGroupsSelector
 */
export interface MountTargetSpecForProviderSecurityGroupsSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema MountTargetSpecForProviderSecurityGroupsSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema MountTargetSpecForProviderSecurityGroupsSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema MountTargetSpecForProviderSecurityGroupsSelector#policy
   */
  readonly policy?: MountTargetSpecForProviderSecurityGroupsSelectorPolicy;

}

/**
 * Converts an object of type 'MountTargetSpecForProviderSecurityGroupsSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MountTargetSpecForProviderSecurityGroupsSelector(obj: MountTargetSpecForProviderSecurityGroupsSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_MountTargetSpecForProviderSecurityGroupsSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SubnetIDRef are references to Subnet used to set the SubnetID.
 *
 * @schema MountTargetSpecForProviderSubnetIdRef
 */
export interface MountTargetSpecForProviderSubnetIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema MountTargetSpecForProviderSubnetIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MountTargetSpecForProviderSubnetIdRef#policy
   */
  readonly policy?: MountTargetSpecForProviderSubnetIdRefPolicy;

}

/**
 * Converts an object of type 'MountTargetSpecForProviderSubnetIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MountTargetSpecForProviderSubnetIdRef(obj: MountTargetSpecForProviderSubnetIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MountTargetSpecForProviderSubnetIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SubnetIDSelector selects references to Subnet used to set the SubnetID.
 *
 * @schema MountTargetSpecForProviderSubnetIdSelector
 */
export interface MountTargetSpecForProviderSubnetIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema MountTargetSpecForProviderSubnetIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema MountTargetSpecForProviderSubnetIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema MountTargetSpecForProviderSubnetIdSelector#policy
   */
  readonly policy?: MountTargetSpecForProviderSubnetIdSelectorPolicy;

}

/**
 * Converts an object of type 'MountTargetSpecForProviderSubnetIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MountTargetSpecForProviderSubnetIdSelector(obj: MountTargetSpecForProviderSubnetIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_MountTargetSpecForProviderSubnetIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MountTargetSpecProviderConfigRefPolicy
 */
export interface MountTargetSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MountTargetSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: MountTargetSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MountTargetSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: MountTargetSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'MountTargetSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MountTargetSpecProviderConfigRefPolicy(obj: MountTargetSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema MountTargetSpecPublishConnectionDetailsToConfigRef
 */
export interface MountTargetSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema MountTargetSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MountTargetSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: MountTargetSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'MountTargetSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MountTargetSpecPublishConnectionDetailsToConfigRef(obj: MountTargetSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MountTargetSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema MountTargetSpecPublishConnectionDetailsToMetadata
 */
export interface MountTargetSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema MountTargetSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema MountTargetSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema MountTargetSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'MountTargetSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MountTargetSpecPublishConnectionDetailsToMetadata(obj: MountTargetSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MountTargetSpecForProviderFileSystemIdRefPolicy
 */
export interface MountTargetSpecForProviderFileSystemIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MountTargetSpecForProviderFileSystemIdRefPolicy#resolution
   */
  readonly resolution?: MountTargetSpecForProviderFileSystemIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MountTargetSpecForProviderFileSystemIdRefPolicy#resolve
   */
  readonly resolve?: MountTargetSpecForProviderFileSystemIdRefPolicyResolve;

}

/**
 * Converts an object of type 'MountTargetSpecForProviderFileSystemIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MountTargetSpecForProviderFileSystemIdRefPolicy(obj: MountTargetSpecForProviderFileSystemIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema MountTargetSpecForProviderFileSystemIdSelectorPolicy
 */
export interface MountTargetSpecForProviderFileSystemIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MountTargetSpecForProviderFileSystemIdSelectorPolicy#resolution
   */
  readonly resolution?: MountTargetSpecForProviderFileSystemIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MountTargetSpecForProviderFileSystemIdSelectorPolicy#resolve
   */
  readonly resolve?: MountTargetSpecForProviderFileSystemIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'MountTargetSpecForProviderFileSystemIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MountTargetSpecForProviderFileSystemIdSelectorPolicy(obj: MountTargetSpecForProviderFileSystemIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MountTargetSpecForProviderSecurityGroupsRefsPolicy
 */
export interface MountTargetSpecForProviderSecurityGroupsRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MountTargetSpecForProviderSecurityGroupsRefsPolicy#resolution
   */
  readonly resolution?: MountTargetSpecForProviderSecurityGroupsRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MountTargetSpecForProviderSecurityGroupsRefsPolicy#resolve
   */
  readonly resolve?: MountTargetSpecForProviderSecurityGroupsRefsPolicyResolve;

}

/**
 * Converts an object of type 'MountTargetSpecForProviderSecurityGroupsRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MountTargetSpecForProviderSecurityGroupsRefsPolicy(obj: MountTargetSpecForProviderSecurityGroupsRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema MountTargetSpecForProviderSecurityGroupsSelectorPolicy
 */
export interface MountTargetSpecForProviderSecurityGroupsSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MountTargetSpecForProviderSecurityGroupsSelectorPolicy#resolution
   */
  readonly resolution?: MountTargetSpecForProviderSecurityGroupsSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MountTargetSpecForProviderSecurityGroupsSelectorPolicy#resolve
   */
  readonly resolve?: MountTargetSpecForProviderSecurityGroupsSelectorPolicyResolve;

}

/**
 * Converts an object of type 'MountTargetSpecForProviderSecurityGroupsSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MountTargetSpecForProviderSecurityGroupsSelectorPolicy(obj: MountTargetSpecForProviderSecurityGroupsSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MountTargetSpecForProviderSubnetIdRefPolicy
 */
export interface MountTargetSpecForProviderSubnetIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MountTargetSpecForProviderSubnetIdRefPolicy#resolution
   */
  readonly resolution?: MountTargetSpecForProviderSubnetIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MountTargetSpecForProviderSubnetIdRefPolicy#resolve
   */
  readonly resolve?: MountTargetSpecForProviderSubnetIdRefPolicyResolve;

}

/**
 * Converts an object of type 'MountTargetSpecForProviderSubnetIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MountTargetSpecForProviderSubnetIdRefPolicy(obj: MountTargetSpecForProviderSubnetIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema MountTargetSpecForProviderSubnetIdSelectorPolicy
 */
export interface MountTargetSpecForProviderSubnetIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MountTargetSpecForProviderSubnetIdSelectorPolicy#resolution
   */
  readonly resolution?: MountTargetSpecForProviderSubnetIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MountTargetSpecForProviderSubnetIdSelectorPolicy#resolve
   */
  readonly resolve?: MountTargetSpecForProviderSubnetIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'MountTargetSpecForProviderSubnetIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MountTargetSpecForProviderSubnetIdSelectorPolicy(obj: MountTargetSpecForProviderSubnetIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MountTargetSpecProviderConfigRefPolicyResolution
 */
export enum MountTargetSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MountTargetSpecProviderConfigRefPolicyResolve
 */
export enum MountTargetSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema MountTargetSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface MountTargetSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MountTargetSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: MountTargetSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MountTargetSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: MountTargetSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'MountTargetSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MountTargetSpecPublishConnectionDetailsToConfigRefPolicy(obj: MountTargetSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MountTargetSpecForProviderFileSystemIdRefPolicyResolution
 */
export enum MountTargetSpecForProviderFileSystemIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MountTargetSpecForProviderFileSystemIdRefPolicyResolve
 */
export enum MountTargetSpecForProviderFileSystemIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MountTargetSpecForProviderFileSystemIdSelectorPolicyResolution
 */
export enum MountTargetSpecForProviderFileSystemIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MountTargetSpecForProviderFileSystemIdSelectorPolicyResolve
 */
export enum MountTargetSpecForProviderFileSystemIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MountTargetSpecForProviderSecurityGroupsRefsPolicyResolution
 */
export enum MountTargetSpecForProviderSecurityGroupsRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MountTargetSpecForProviderSecurityGroupsRefsPolicyResolve
 */
export enum MountTargetSpecForProviderSecurityGroupsRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MountTargetSpecForProviderSecurityGroupsSelectorPolicyResolution
 */
export enum MountTargetSpecForProviderSecurityGroupsSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MountTargetSpecForProviderSecurityGroupsSelectorPolicyResolve
 */
export enum MountTargetSpecForProviderSecurityGroupsSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MountTargetSpecForProviderSubnetIdRefPolicyResolution
 */
export enum MountTargetSpecForProviderSubnetIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MountTargetSpecForProviderSubnetIdRefPolicyResolve
 */
export enum MountTargetSpecForProviderSubnetIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MountTargetSpecForProviderSubnetIdSelectorPolicyResolution
 */
export enum MountTargetSpecForProviderSubnetIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MountTargetSpecForProviderSubnetIdSelectorPolicyResolve
 */
export enum MountTargetSpecForProviderSubnetIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MountTargetSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum MountTargetSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MountTargetSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum MountTargetSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

