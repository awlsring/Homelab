// @ts-nocheck
// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Stream is the Schema for the Streams API
 *
 * @schema Stream
 */
export class Stream extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Stream"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'kinesis.aws.crossplane.io/v1alpha1',
    kind: 'Stream',
  }

  /**
   * Renders a Kubernetes manifest for "Stream".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: StreamProps): any {
    return {
      ...Stream.GVK,
      ...toJson_StreamProps(props),
    };
  }

  /**
   * Defines a "Stream" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: StreamProps) {
    super(scope, id, {
      ...Stream.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Stream.GVK,
      ...toJson_StreamProps(resolved),
    };
  }
}

/**
 * Stream is the Schema for the Streams API
 *
 * @schema Stream
 */
export interface StreamProps {
  /**
   * @schema Stream#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * StreamSpec defines the desired state of Stream
   *
   * @schema Stream#spec
   */
  readonly spec: StreamSpec;

}

/**
 * Converts an object of type 'StreamProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamProps(obj: StreamProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_StreamSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * StreamSpec defines the desired state of Stream
 *
 * @schema StreamSpec
 */
export interface StreamSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema StreamSpec#deletionPolicy
   */
  readonly deletionPolicy?: StreamSpecDeletionPolicy;

  /**
   * StreamParameters defines the desired state of Stream
   *
   * @schema StreamSpec#forProvider
   */
  readonly forProvider: StreamSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema StreamSpec#managementPolicies
   */
  readonly managementPolicies?: StreamSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema StreamSpec#providerConfigRef
   */
  readonly providerConfigRef?: StreamSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema StreamSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: StreamSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema StreamSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: StreamSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'StreamSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamSpec(obj: StreamSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_StreamSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_StreamSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_StreamSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_StreamSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema StreamSpecDeletionPolicy
 */
export enum StreamSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * StreamParameters defines the desired state of Stream
 *
 * @schema StreamSpecForProvider
 */
export interface StreamSpecForProvider {
  /**
   * If this parameter is unset (null) or if you set it to false, and the stream has registered consumers, the call to DeleteStream fails with a ResourceInUseException.
   *
   * @schema StreamSpecForProvider#enforceConsumerDeletion
   */
  readonly enforceConsumerDeletion?: boolean;

  /**
   * List of shard-level metrics.
   * The following are the valid shard-level metrics. The value "ALL" enhances every metric.
   * * IncomingBytes
   * * IncomingRecords
   * * OutgoingBytes
   * * OutgoingRecords
   * * WriteProvisionedThroughputExceeded
   * * ReadProvisionedThroughputExceeded
   * * IteratorAgeMilliseconds
   * * ALL
   * For more information, see Monitoring the Amazon Kinesis Data Streams Service with Amazon CloudWatch (https://docs.aws.amazon.com/kinesis/latest/dev/monitoring-with-cloudwatch.html) in the Amazon Kinesis Data Streams Developer Guide.
   *
   * @schema StreamSpecForProvider#enhancedMetrics
   */
  readonly enhancedMetrics?: StreamSpecForProviderEnhancedMetrics[];

  /**
   * @schema StreamSpecForProvider#kmsKeyARN
   */
  readonly kmsKeyArn?: string;

  /**
   * A Reference to a named object.
   *
   * @schema StreamSpecForProvider#kmsKeyARNRef
   */
  readonly kmsKeyArnRef?: StreamSpecForProviderKmsKeyArnRef;

  /**
   * A Selector selects an object.
   *
   * @schema StreamSpecForProvider#kmsKeyARNSelector
   */
  readonly kmsKeyArnSelector?: StreamSpecForProviderKmsKeyArnSelector;

  /**
   * Region is which region the Stream will be created.
   *
   * @schema StreamSpecForProvider#region
   */
  readonly region: string;

  /**
   * The retention period of the stream, in hours. Default: 24 hours
   *
   * @schema StreamSpecForProvider#retentionPeriodHours
   */
  readonly retentionPeriodHours?: number;

  /**
   * The number of shards that the stream will use. The throughput of the stream is a function of the number of shards; more shards are required for greater provisioned throughput.
   *
   * @schema StreamSpecForProvider#shardCount
   */
  readonly shardCount?: number;

  /**
   * Indicates the capacity mode of the data stream. Currently, in Kinesis Data Streams, you can choose between an on-demand capacity mode and a provisioned capacity mode for your data streams.
   *
   * @schema StreamSpecForProvider#streamModeDetails
   */
  readonly streamModeDetails?: StreamSpecForProviderStreamModeDetails;

  /**
   * @schema StreamSpecForProvider#tags
   */
  readonly tags?: StreamSpecForProviderTags[];

}

/**
 * Converts an object of type 'StreamSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamSpecForProvider(obj: StreamSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enforceConsumerDeletion': obj.enforceConsumerDeletion,
    'enhancedMetrics': obj.enhancedMetrics?.map(y => toJson_StreamSpecForProviderEnhancedMetrics(y)),
    'kmsKeyARN': obj.kmsKeyArn,
    'kmsKeyARNRef': toJson_StreamSpecForProviderKmsKeyArnRef(obj.kmsKeyArnRef),
    'kmsKeyARNSelector': toJson_StreamSpecForProviderKmsKeyArnSelector(obj.kmsKeyArnSelector),
    'region': obj.region,
    'retentionPeriodHours': obj.retentionPeriodHours,
    'shardCount': obj.shardCount,
    'streamModeDetails': toJson_StreamSpecForProviderStreamModeDetails(obj.streamModeDetails),
    'tags': obj.tags?.map(y => toJson_StreamSpecForProviderTags(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema StreamSpecManagementPolicies
 */
export enum StreamSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema StreamSpecProviderConfigRef
 */
export interface StreamSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema StreamSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StreamSpecProviderConfigRef#policy
   */
  readonly policy?: StreamSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'StreamSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamSpecProviderConfigRef(obj: StreamSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StreamSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema StreamSpecPublishConnectionDetailsTo
 */
export interface StreamSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema StreamSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: StreamSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema StreamSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: StreamSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema StreamSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'StreamSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamSpecPublishConnectionDetailsTo(obj: StreamSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_StreamSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_StreamSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema StreamSpecWriteConnectionSecretToRef
 */
export interface StreamSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema StreamSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema StreamSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'StreamSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamSpecWriteConnectionSecretToRef(obj: StreamSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StreamSpecForProviderEnhancedMetrics
 */
export interface StreamSpecForProviderEnhancedMetrics {
  /**
   * @schema StreamSpecForProviderEnhancedMetrics#shardLevelMetrics
   */
  readonly shardLevelMetrics?: string[];

}

/**
 * Converts an object of type 'StreamSpecForProviderEnhancedMetrics' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamSpecForProviderEnhancedMetrics(obj: StreamSpecForProviderEnhancedMetrics | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'shardLevelMetrics': obj.shardLevelMetrics?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema StreamSpecForProviderKmsKeyArnRef
 */
export interface StreamSpecForProviderKmsKeyArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema StreamSpecForProviderKmsKeyArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StreamSpecForProviderKmsKeyArnRef#policy
   */
  readonly policy?: StreamSpecForProviderKmsKeyArnRefPolicy;

}

/**
 * Converts an object of type 'StreamSpecForProviderKmsKeyArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamSpecForProviderKmsKeyArnRef(obj: StreamSpecForProviderKmsKeyArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StreamSpecForProviderKmsKeyArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Selector selects an object.
 *
 * @schema StreamSpecForProviderKmsKeyArnSelector
 */
export interface StreamSpecForProviderKmsKeyArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema StreamSpecForProviderKmsKeyArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema StreamSpecForProviderKmsKeyArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema StreamSpecForProviderKmsKeyArnSelector#policy
   */
  readonly policy?: StreamSpecForProviderKmsKeyArnSelectorPolicy;

}

/**
 * Converts an object of type 'StreamSpecForProviderKmsKeyArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamSpecForProviderKmsKeyArnSelector(obj: StreamSpecForProviderKmsKeyArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_StreamSpecForProviderKmsKeyArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Indicates the capacity mode of the data stream. Currently, in Kinesis Data Streams, you can choose between an on-demand capacity mode and a provisioned capacity mode for your data streams.
 *
 * @schema StreamSpecForProviderStreamModeDetails
 */
export interface StreamSpecForProviderStreamModeDetails {
  /**
   * @schema StreamSpecForProviderStreamModeDetails#streamMode
   */
  readonly streamMode?: string;

}

/**
 * Converts an object of type 'StreamSpecForProviderStreamModeDetails' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamSpecForProviderStreamModeDetails(obj: StreamSpecForProviderStreamModeDetails | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'streamMode': obj.streamMode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CustomTag contains the additional fields for Tag.
 *
 * @schema StreamSpecForProviderTags
 */
export interface StreamSpecForProviderTags {
  /**
   * A unique identifier for the tag.
   *
   * @schema StreamSpecForProviderTags#key
   */
  readonly key: string;

  /**
   * An optional string, typically used to describe or define the tag.
   *
   * @schema StreamSpecForProviderTags#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'StreamSpecForProviderTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamSpecForProviderTags(obj: StreamSpecForProviderTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema StreamSpecProviderConfigRefPolicy
 */
export interface StreamSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StreamSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: StreamSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StreamSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: StreamSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'StreamSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamSpecProviderConfigRefPolicy(obj: StreamSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema StreamSpecPublishConnectionDetailsToConfigRef
 */
export interface StreamSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema StreamSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StreamSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: StreamSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'StreamSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamSpecPublishConnectionDetailsToConfigRef(obj: StreamSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StreamSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema StreamSpecPublishConnectionDetailsToMetadata
 */
export interface StreamSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema StreamSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema StreamSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema StreamSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'StreamSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamSpecPublishConnectionDetailsToMetadata(obj: StreamSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema StreamSpecForProviderKmsKeyArnRefPolicy
 */
export interface StreamSpecForProviderKmsKeyArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StreamSpecForProviderKmsKeyArnRefPolicy#resolution
   */
  readonly resolution?: StreamSpecForProviderKmsKeyArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StreamSpecForProviderKmsKeyArnRefPolicy#resolve
   */
  readonly resolve?: StreamSpecForProviderKmsKeyArnRefPolicyResolve;

}

/**
 * Converts an object of type 'StreamSpecForProviderKmsKeyArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamSpecForProviderKmsKeyArnRefPolicy(obj: StreamSpecForProviderKmsKeyArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema StreamSpecForProviderKmsKeyArnSelectorPolicy
 */
export interface StreamSpecForProviderKmsKeyArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StreamSpecForProviderKmsKeyArnSelectorPolicy#resolution
   */
  readonly resolution?: StreamSpecForProviderKmsKeyArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StreamSpecForProviderKmsKeyArnSelectorPolicy#resolve
   */
  readonly resolve?: StreamSpecForProviderKmsKeyArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'StreamSpecForProviderKmsKeyArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamSpecForProviderKmsKeyArnSelectorPolicy(obj: StreamSpecForProviderKmsKeyArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StreamSpecProviderConfigRefPolicyResolution
 */
export enum StreamSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StreamSpecProviderConfigRefPolicyResolve
 */
export enum StreamSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema StreamSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface StreamSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StreamSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: StreamSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StreamSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: StreamSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'StreamSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamSpecPublishConnectionDetailsToConfigRefPolicy(obj: StreamSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StreamSpecForProviderKmsKeyArnRefPolicyResolution
 */
export enum StreamSpecForProviderKmsKeyArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StreamSpecForProviderKmsKeyArnRefPolicyResolve
 */
export enum StreamSpecForProviderKmsKeyArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StreamSpecForProviderKmsKeyArnSelectorPolicyResolution
 */
export enum StreamSpecForProviderKmsKeyArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StreamSpecForProviderKmsKeyArnSelectorPolicyResolve
 */
export enum StreamSpecForProviderKmsKeyArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StreamSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum StreamSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StreamSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum StreamSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

