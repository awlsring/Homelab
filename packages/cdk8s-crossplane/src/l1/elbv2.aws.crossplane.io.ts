// @ts-nocheck
// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Listener is the Schema for the Listeners API
 *
 * @schema Listener
 */
export class Listener extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Listener"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'elbv2.aws.crossplane.io/v1alpha1',
    kind: 'Listener',
  }

  /**
   * Renders a Kubernetes manifest for "Listener".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ListenerProps): any {
    return {
      ...Listener.GVK,
      ...toJson_ListenerProps(props),
    };
  }

  /**
   * Defines a "Listener" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ListenerProps) {
    super(scope, id, {
      ...Listener.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Listener.GVK,
      ...toJson_ListenerProps(resolved),
    };
  }
}

/**
 * Listener is the Schema for the Listeners API
 *
 * @schema Listener
 */
export interface ListenerProps {
  /**
   * @schema Listener#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ListenerSpec defines the desired state of Listener
   *
   * @schema Listener#spec
   */
  readonly spec: ListenerSpec;

}

/**
 * Converts an object of type 'ListenerProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerProps(obj: ListenerProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ListenerSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ListenerSpec defines the desired state of Listener
 *
 * @schema ListenerSpec
 */
export interface ListenerSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ListenerSpec#deletionPolicy
   */
  readonly deletionPolicy?: ListenerSpecDeletionPolicy;

  /**
   * ListenerParameters defines the desired state of Listener
   *
   * @schema ListenerSpec#forProvider
   */
  readonly forProvider: ListenerSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ListenerSpec#managementPolicies
   */
  readonly managementPolicies?: ListenerSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ListenerSpec#providerConfigRef
   */
  readonly providerConfigRef?: ListenerSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ListenerSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ListenerSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ListenerSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ListenerSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ListenerSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerSpec(obj: ListenerSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ListenerSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ListenerSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ListenerSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ListenerSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ListenerSpecDeletionPolicy
 */
export enum ListenerSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * ListenerParameters defines the desired state of Listener
 *
 * @schema ListenerSpecForProvider
 */
export interface ListenerSpecForProvider {
  /**
   * [TLS listeners] The name of the Application-Layer Protocol Negotiation (ALPN) policy. You can specify one policy name. The following are the possible values:
   * * HTTP1Only
   * * HTTP2Only
   * * HTTP2Optional
   * * HTTP2Preferred
   * * None
   * For more information, see ALPN policies (https://docs.aws.amazon.com/elasticloadbalancing/latest/network/create-tls-listener.html#alpn-policies) in the Network Load Balancers Guide.
   *
   * @schema ListenerSpecForProvider#alpnPolicy
   */
  readonly alpnPolicy?: string[];

  /**
   * [HTTPS and TLS listeners] The default certificate for the listener. You must provide exactly one certificate. Set CertificateArn to the certificate ARN but do not set IsDefault.
   *
   * @schema ListenerSpecForProvider#certificates
   */
  readonly certificates?: ListenerSpecForProviderCertificates[];

  /**
   * The actions for the default rule.
   *
   * @schema ListenerSpecForProvider#defaultActions
   */
  readonly defaultActions: ListenerSpecForProviderDefaultActions[];

  /**
   * The Amazon Resource Name (ARN) of the load balancer.
   *
   * @schema ListenerSpecForProvider#loadBalancerArn
   */
  readonly loadBalancerArn?: string;

  /**
   * Ref to loadbalancer ARN
   *
   * @schema ListenerSpecForProvider#loadBalancerArnRef
   */
  readonly loadBalancerArnRef?: ListenerSpecForProviderLoadBalancerArnRef;

  /**
   * Selector for references to LoadBalancer for LoadBalancerARN
   *
   * @schema ListenerSpecForProvider#loadBalancerArnSelector
   */
  readonly loadBalancerArnSelector?: ListenerSpecForProviderLoadBalancerArnSelector;

  /**
   * The port on which the load balancer is listening. You cannot specify a port for a Gateway Load Balancer.
   *
   * @schema ListenerSpecForProvider#port
   */
  readonly port?: number;

  /**
   * The protocol for connections from clients to the load balancer. For Application Load Balancers, the supported protocols are HTTP and HTTPS. For Network Load Balancers, the supported protocols are TCP, TLS, UDP, and TCP_UDP. You canâ€™t specify the UDP or TCP_UDP protocol if dual-stack mode is enabled. You cannot specify a protocol for a Gateway Load Balancer.
   *
   * @schema ListenerSpecForProvider#protocol
   */
  readonly protocol?: string;

  /**
   * Region is which region the Listener will be created.
   *
   * @schema ListenerSpecForProvider#region
   */
  readonly region: string;

  /**
   * [HTTPS and TLS listeners] The security policy that defines which protocols and ciphers are supported.
   * For more information, see Security policies (https://docs.aws.amazon.com/elasticloadbalancing/latest/application/create-https-listener.html#describe-ssl-policies) in the Application Load Balancers Guide and Security policies (https://docs.aws.amazon.com/elasticloadbalancing/latest/network/create-tls-listener.html#describe-ssl-policies) in the Network Load Balancers Guide.
   *
   * @schema ListenerSpecForProvider#sslPolicy
   */
  readonly sslPolicy?: string;

  /**
   * The tags to assign to the listener.
   *
   * @schema ListenerSpecForProvider#tags
   */
  readonly tags?: ListenerSpecForProviderTags[];

}

/**
 * Converts an object of type 'ListenerSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerSpecForProvider(obj: ListenerSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alpnPolicy': obj.alpnPolicy?.map(y => y),
    'certificates': obj.certificates?.map(y => toJson_ListenerSpecForProviderCertificates(y)),
    'defaultActions': obj.defaultActions?.map(y => toJson_ListenerSpecForProviderDefaultActions(y)),
    'loadBalancerArn': obj.loadBalancerArn,
    'loadBalancerArnRef': toJson_ListenerSpecForProviderLoadBalancerArnRef(obj.loadBalancerArnRef),
    'loadBalancerArnSelector': toJson_ListenerSpecForProviderLoadBalancerArnSelector(obj.loadBalancerArnSelector),
    'port': obj.port,
    'protocol': obj.protocol,
    'region': obj.region,
    'sslPolicy': obj.sslPolicy,
    'tags': obj.tags?.map(y => toJson_ListenerSpecForProviderTags(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ListenerSpecManagementPolicies
 */
export enum ListenerSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ListenerSpecProviderConfigRef
 */
export interface ListenerSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ListenerSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ListenerSpecProviderConfigRef#policy
   */
  readonly policy?: ListenerSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ListenerSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerSpecProviderConfigRef(obj: ListenerSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ListenerSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ListenerSpecPublishConnectionDetailsTo
 */
export interface ListenerSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ListenerSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ListenerSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ListenerSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ListenerSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ListenerSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ListenerSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerSpecPublishConnectionDetailsTo(obj: ListenerSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ListenerSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ListenerSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ListenerSpecWriteConnectionSecretToRef
 */
export interface ListenerSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ListenerSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ListenerSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ListenerSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerSpecWriteConnectionSecretToRef(obj: ListenerSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CustomCertificate includes custom fields about certificates.
 *
 * @schema ListenerSpecForProviderCertificates
 */
export interface ListenerSpecForProviderCertificates {
  /**
   * [HTTPS and TLS listeners] The default certificate for the listener.
   *
   * @schema ListenerSpecForProviderCertificates#certificateARN
   */
  readonly certificateArn?: string;

  /**
   * Reference to Certificates for Certificate ARN
   *
   * @schema ListenerSpecForProviderCertificates#certificateARNRef
   */
  readonly certificateArnRef?: ListenerSpecForProviderCertificatesCertificateArnRef;

  /**
   * Selector for references to Certificate for CertificateArn
   *
   * @schema ListenerSpecForProviderCertificates#certificateARNSelector
   */
  readonly certificateArnSelector?: ListenerSpecForProviderCertificatesCertificateArnSelector;

  /**
   * @schema ListenerSpecForProviderCertificates#isDefault
   */
  readonly isDefault?: boolean;

}

/**
 * Converts an object of type 'ListenerSpecForProviderCertificates' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerSpecForProviderCertificates(obj: ListenerSpecForProviderCertificates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateARN': obj.certificateArn,
    'certificateARNRef': toJson_ListenerSpecForProviderCertificatesCertificateArnRef(obj.certificateArnRef),
    'certificateARNSelector': toJson_ListenerSpecForProviderCertificatesCertificateArnSelector(obj.certificateArnSelector),
    'isDefault': obj.isDefault,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CustomAction includes custom fields for an action.
 * Each rule must include exactly one of the following types of actions: forward, fixed-response, or redirect, and it must be the last action to be performed.
 *
 * @schema ListenerSpecForProviderDefaultActions
 */
export interface ListenerSpecForProviderDefaultActions {
  /**
   * The type of action.
   *
   * @schema ListenerSpecForProviderDefaultActions#actionType
   */
  readonly actionType: string;

  /**
   * Request parameters to use when integrating with Amazon Cognito to authenticate users.
   *
   * @schema ListenerSpecForProviderDefaultActions#authenticateCognitoConfig
   */
  readonly authenticateCognitoConfig?: ListenerSpecForProviderDefaultActionsAuthenticateCognitoConfig;

  /**
   * Request parameters when using an identity provider (IdP) that is compliant with OpenID Connect (OIDC) to authenticate users.
   *
   * @schema ListenerSpecForProviderDefaultActions#authenticateOidcConfig
   */
  readonly authenticateOidcConfig?: ListenerSpecForProviderDefaultActionsAuthenticateOidcConfig;

  /**
   * Information about an action that returns a custom HTTP response.
   *
   * @schema ListenerSpecForProviderDefaultActions#fixedResponseConfig
   */
  readonly fixedResponseConfig?: ListenerSpecForProviderDefaultActionsFixedResponseConfig;

  /**
   * Information about a forward action.
   *
   * @schema ListenerSpecForProviderDefaultActions#forwardConfig
   */
  readonly forwardConfig?: ListenerSpecForProviderDefaultActionsForwardConfig;

  /**
   * The order for the action. This value is required for rules with multiple actions. The action with the lowest value for order is performed first.
   *
   * @schema ListenerSpecForProviderDefaultActions#order
   */
  readonly order?: number;

  /**
   * Information about a redirect action.
   * A URI consists of the following components: protocol://hostname:port/path?query. You must modify at least one of the following components to avoid a redirect loop: protocol, hostname, port, or path. Any components that you do not modify retain their original values.
   * You can reuse URI components using the following reserved keywords:
   * * #{protocol}
   * * #{host}
   * * #{port}
   * * #{path} (the leading "/" is removed)
   * * #{query}
   * For example, you can change the path to "/new/#{path}", the hostname to "example.#{host}", or the query to "#{query}&value=xyz".
   *
   * @schema ListenerSpecForProviderDefaultActions#redirectConfig
   */
  readonly redirectConfig?: ListenerSpecForProviderDefaultActionsRedirectConfig;

  /**
   * The Amazon Resource Name (ARN) of the target group. Specify only when actionType is forward and you want to route to a single target group. To route to one or more target groups, use ForwardConfig instead.
   *
   * @schema ListenerSpecForProviderDefaultActions#targetGroupArn
   */
  readonly targetGroupArn?: string;

  /**
   * Reference to TargetGroupARN used to set TargetGroupARN
   *
   * @schema ListenerSpecForProviderDefaultActions#targetGroupArnRef
   */
  readonly targetGroupArnRef?: ListenerSpecForProviderDefaultActionsTargetGroupArnRef;

  /**
   * Selector for references to TargetGroups for TargetGroupARNs
   *
   * @schema ListenerSpecForProviderDefaultActions#targetGroupArnSelector
   */
  readonly targetGroupArnSelector?: ListenerSpecForProviderDefaultActionsTargetGroupArnSelector;

}

/**
 * Converts an object of type 'ListenerSpecForProviderDefaultActions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerSpecForProviderDefaultActions(obj: ListenerSpecForProviderDefaultActions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'actionType': obj.actionType,
    'authenticateCognitoConfig': toJson_ListenerSpecForProviderDefaultActionsAuthenticateCognitoConfig(obj.authenticateCognitoConfig),
    'authenticateOidcConfig': toJson_ListenerSpecForProviderDefaultActionsAuthenticateOidcConfig(obj.authenticateOidcConfig),
    'fixedResponseConfig': toJson_ListenerSpecForProviderDefaultActionsFixedResponseConfig(obj.fixedResponseConfig),
    'forwardConfig': toJson_ListenerSpecForProviderDefaultActionsForwardConfig(obj.forwardConfig),
    'order': obj.order,
    'redirectConfig': toJson_ListenerSpecForProviderDefaultActionsRedirectConfig(obj.redirectConfig),
    'targetGroupArn': obj.targetGroupArn,
    'targetGroupArnRef': toJson_ListenerSpecForProviderDefaultActionsTargetGroupArnRef(obj.targetGroupArnRef),
    'targetGroupArnSelector': toJson_ListenerSpecForProviderDefaultActionsTargetGroupArnSelector(obj.targetGroupArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Ref to loadbalancer ARN
 *
 * @schema ListenerSpecForProviderLoadBalancerArnRef
 */
export interface ListenerSpecForProviderLoadBalancerArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ListenerSpecForProviderLoadBalancerArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ListenerSpecForProviderLoadBalancerArnRef#policy
   */
  readonly policy?: ListenerSpecForProviderLoadBalancerArnRefPolicy;

}

/**
 * Converts an object of type 'ListenerSpecForProviderLoadBalancerArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerSpecForProviderLoadBalancerArnRef(obj: ListenerSpecForProviderLoadBalancerArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ListenerSpecForProviderLoadBalancerArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for references to LoadBalancer for LoadBalancerARN
 *
 * @schema ListenerSpecForProviderLoadBalancerArnSelector
 */
export interface ListenerSpecForProviderLoadBalancerArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ListenerSpecForProviderLoadBalancerArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ListenerSpecForProviderLoadBalancerArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ListenerSpecForProviderLoadBalancerArnSelector#policy
   */
  readonly policy?: ListenerSpecForProviderLoadBalancerArnSelectorPolicy;

}

/**
 * Converts an object of type 'ListenerSpecForProviderLoadBalancerArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerSpecForProviderLoadBalancerArnSelector(obj: ListenerSpecForProviderLoadBalancerArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ListenerSpecForProviderLoadBalancerArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ListenerSpecForProviderTags
 */
export interface ListenerSpecForProviderTags {
  /**
   * @schema ListenerSpecForProviderTags#key
   */
  readonly key?: string;

  /**
   * @schema ListenerSpecForProviderTags#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ListenerSpecForProviderTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerSpecForProviderTags(obj: ListenerSpecForProviderTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ListenerSpecProviderConfigRefPolicy
 */
export interface ListenerSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ListenerSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ListenerSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ListenerSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ListenerSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ListenerSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerSpecProviderConfigRefPolicy(obj: ListenerSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ListenerSpecPublishConnectionDetailsToConfigRef
 */
export interface ListenerSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ListenerSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ListenerSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ListenerSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ListenerSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerSpecPublishConnectionDetailsToConfigRef(obj: ListenerSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ListenerSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ListenerSpecPublishConnectionDetailsToMetadata
 */
export interface ListenerSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ListenerSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ListenerSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ListenerSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ListenerSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerSpecPublishConnectionDetailsToMetadata(obj: ListenerSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to Certificates for Certificate ARN
 *
 * @schema ListenerSpecForProviderCertificatesCertificateArnRef
 */
export interface ListenerSpecForProviderCertificatesCertificateArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ListenerSpecForProviderCertificatesCertificateArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ListenerSpecForProviderCertificatesCertificateArnRef#policy
   */
  readonly policy?: ListenerSpecForProviderCertificatesCertificateArnRefPolicy;

}

/**
 * Converts an object of type 'ListenerSpecForProviderCertificatesCertificateArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerSpecForProviderCertificatesCertificateArnRef(obj: ListenerSpecForProviderCertificatesCertificateArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ListenerSpecForProviderCertificatesCertificateArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for references to Certificate for CertificateArn
 *
 * @schema ListenerSpecForProviderCertificatesCertificateArnSelector
 */
export interface ListenerSpecForProviderCertificatesCertificateArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ListenerSpecForProviderCertificatesCertificateArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ListenerSpecForProviderCertificatesCertificateArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ListenerSpecForProviderCertificatesCertificateArnSelector#policy
   */
  readonly policy?: ListenerSpecForProviderCertificatesCertificateArnSelectorPolicy;

}

/**
 * Converts an object of type 'ListenerSpecForProviderCertificatesCertificateArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerSpecForProviderCertificatesCertificateArnSelector(obj: ListenerSpecForProviderCertificatesCertificateArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ListenerSpecForProviderCertificatesCertificateArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Request parameters to use when integrating with Amazon Cognito to authenticate users.
 *
 * @schema ListenerSpecForProviderDefaultActionsAuthenticateCognitoConfig
 */
export interface ListenerSpecForProviderDefaultActionsAuthenticateCognitoConfig {
  /**
   * @schema ListenerSpecForProviderDefaultActionsAuthenticateCognitoConfig#authenticationRequestExtraParams
   */
  readonly authenticationRequestExtraParams?: { [key: string]: string };

  /**
   * @schema ListenerSpecForProviderDefaultActionsAuthenticateCognitoConfig#onUnauthenticatedRequest
   */
  readonly onUnauthenticatedRequest?: string;

  /**
   * @schema ListenerSpecForProviderDefaultActionsAuthenticateCognitoConfig#scope
   */
  readonly scope?: string;

  /**
   * @schema ListenerSpecForProviderDefaultActionsAuthenticateCognitoConfig#sessionCookieName
   */
  readonly sessionCookieName?: string;

  /**
   * @schema ListenerSpecForProviderDefaultActionsAuthenticateCognitoConfig#sessionTimeout
   */
  readonly sessionTimeout?: number;

  /**
   * @schema ListenerSpecForProviderDefaultActionsAuthenticateCognitoConfig#userPoolARN
   */
  readonly userPoolArn?: string;

  /**
   * @schema ListenerSpecForProviderDefaultActionsAuthenticateCognitoConfig#userPoolClientID
   */
  readonly userPoolClientId?: string;

  /**
   * @schema ListenerSpecForProviderDefaultActionsAuthenticateCognitoConfig#userPoolDomain
   */
  readonly userPoolDomain?: string;

}

/**
 * Converts an object of type 'ListenerSpecForProviderDefaultActionsAuthenticateCognitoConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerSpecForProviderDefaultActionsAuthenticateCognitoConfig(obj: ListenerSpecForProviderDefaultActionsAuthenticateCognitoConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authenticationRequestExtraParams': ((obj.authenticationRequestExtraParams) === undefined) ? undefined : (Object.entries(obj.authenticationRequestExtraParams).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'onUnauthenticatedRequest': obj.onUnauthenticatedRequest,
    'scope': obj.scope,
    'sessionCookieName': obj.sessionCookieName,
    'sessionTimeout': obj.sessionTimeout,
    'userPoolARN': obj.userPoolArn,
    'userPoolClientID': obj.userPoolClientId,
    'userPoolDomain': obj.userPoolDomain,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Request parameters when using an identity provider (IdP) that is compliant with OpenID Connect (OIDC) to authenticate users.
 *
 * @schema ListenerSpecForProviderDefaultActionsAuthenticateOidcConfig
 */
export interface ListenerSpecForProviderDefaultActionsAuthenticateOidcConfig {
  /**
   * @schema ListenerSpecForProviderDefaultActionsAuthenticateOidcConfig#authenticationRequestExtraParams
   */
  readonly authenticationRequestExtraParams?: { [key: string]: string };

  /**
   * @schema ListenerSpecForProviderDefaultActionsAuthenticateOidcConfig#authorizationEndpoint
   */
  readonly authorizationEndpoint?: string;

  /**
   * @schema ListenerSpecForProviderDefaultActionsAuthenticateOidcConfig#clientID
   */
  readonly clientId?: string;

  /**
   * @schema ListenerSpecForProviderDefaultActionsAuthenticateOidcConfig#clientSecret
   */
  readonly clientSecret?: string;

  /**
   * @schema ListenerSpecForProviderDefaultActionsAuthenticateOidcConfig#issuer
   */
  readonly issuer?: string;

  /**
   * @schema ListenerSpecForProviderDefaultActionsAuthenticateOidcConfig#onUnauthenticatedRequest
   */
  readonly onUnauthenticatedRequest?: string;

  /**
   * @schema ListenerSpecForProviderDefaultActionsAuthenticateOidcConfig#scope
   */
  readonly scope?: string;

  /**
   * @schema ListenerSpecForProviderDefaultActionsAuthenticateOidcConfig#sessionCookieName
   */
  readonly sessionCookieName?: string;

  /**
   * @schema ListenerSpecForProviderDefaultActionsAuthenticateOidcConfig#sessionTimeout
   */
  readonly sessionTimeout?: number;

  /**
   * @schema ListenerSpecForProviderDefaultActionsAuthenticateOidcConfig#tokenEndpoint
   */
  readonly tokenEndpoint?: string;

  /**
   * @schema ListenerSpecForProviderDefaultActionsAuthenticateOidcConfig#useExistingClientSecret
   */
  readonly useExistingClientSecret?: boolean;

  /**
   * @schema ListenerSpecForProviderDefaultActionsAuthenticateOidcConfig#userInfoEndpoint
   */
  readonly userInfoEndpoint?: string;

}

/**
 * Converts an object of type 'ListenerSpecForProviderDefaultActionsAuthenticateOidcConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerSpecForProviderDefaultActionsAuthenticateOidcConfig(obj: ListenerSpecForProviderDefaultActionsAuthenticateOidcConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authenticationRequestExtraParams': ((obj.authenticationRequestExtraParams) === undefined) ? undefined : (Object.entries(obj.authenticationRequestExtraParams).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'authorizationEndpoint': obj.authorizationEndpoint,
    'clientID': obj.clientId,
    'clientSecret': obj.clientSecret,
    'issuer': obj.issuer,
    'onUnauthenticatedRequest': obj.onUnauthenticatedRequest,
    'scope': obj.scope,
    'sessionCookieName': obj.sessionCookieName,
    'sessionTimeout': obj.sessionTimeout,
    'tokenEndpoint': obj.tokenEndpoint,
    'useExistingClientSecret': obj.useExistingClientSecret,
    'userInfoEndpoint': obj.userInfoEndpoint,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Information about an action that returns a custom HTTP response.
 *
 * @schema ListenerSpecForProviderDefaultActionsFixedResponseConfig
 */
export interface ListenerSpecForProviderDefaultActionsFixedResponseConfig {
  /**
   * @schema ListenerSpecForProviderDefaultActionsFixedResponseConfig#contentType
   */
  readonly contentType?: string;

  /**
   * @schema ListenerSpecForProviderDefaultActionsFixedResponseConfig#messageBody
   */
  readonly messageBody?: string;

  /**
   * @schema ListenerSpecForProviderDefaultActionsFixedResponseConfig#statusCode
   */
  readonly statusCode?: string;

}

/**
 * Converts an object of type 'ListenerSpecForProviderDefaultActionsFixedResponseConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerSpecForProviderDefaultActionsFixedResponseConfig(obj: ListenerSpecForProviderDefaultActionsFixedResponseConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'contentType': obj.contentType,
    'messageBody': obj.messageBody,
    'statusCode': obj.statusCode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Information about a forward action.
 *
 * @schema ListenerSpecForProviderDefaultActionsForwardConfig
 */
export interface ListenerSpecForProviderDefaultActionsForwardConfig {
  /**
   * Information about the target group stickiness for a rule.
   *
   * @schema ListenerSpecForProviderDefaultActionsForwardConfig#targetGroupStickinessConfig
   */
  readonly targetGroupStickinessConfig?: ListenerSpecForProviderDefaultActionsForwardConfigTargetGroupStickinessConfig;

  /**
   * One or more target groups. For Network Load Balancers, you can specify a single target group.
   *
   * @schema ListenerSpecForProviderDefaultActionsForwardConfig#targetGroups
   */
  readonly targetGroups?: ListenerSpecForProviderDefaultActionsForwardConfigTargetGroups[];

}

/**
 * Converts an object of type 'ListenerSpecForProviderDefaultActionsForwardConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerSpecForProviderDefaultActionsForwardConfig(obj: ListenerSpecForProviderDefaultActionsForwardConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'targetGroupStickinessConfig': toJson_ListenerSpecForProviderDefaultActionsForwardConfigTargetGroupStickinessConfig(obj.targetGroupStickinessConfig),
    'targetGroups': obj.targetGroups?.map(y => toJson_ListenerSpecForProviderDefaultActionsForwardConfigTargetGroups(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Information about a redirect action.
 * A URI consists of the following components: protocol://hostname:port/path?query. You must modify at least one of the following components to avoid a redirect loop: protocol, hostname, port, or path. Any components that you do not modify retain their original values.
 * You can reuse URI components using the following reserved keywords:
 * * #{protocol}
 * * #{host}
 * * #{port}
 * * #{path} (the leading "/" is removed)
 * * #{query}
 * For example, you can change the path to "/new/#{path}", the hostname to "example.#{host}", or the query to "#{query}&value=xyz".
 *
 * @schema ListenerSpecForProviderDefaultActionsRedirectConfig
 */
export interface ListenerSpecForProviderDefaultActionsRedirectConfig {
  /**
   * @schema ListenerSpecForProviderDefaultActionsRedirectConfig#host
   */
  readonly host?: string;

  /**
   * @schema ListenerSpecForProviderDefaultActionsRedirectConfig#path
   */
  readonly path?: string;

  /**
   * @schema ListenerSpecForProviderDefaultActionsRedirectConfig#port
   */
  readonly port?: string;

  /**
   * @schema ListenerSpecForProviderDefaultActionsRedirectConfig#protocol
   */
  readonly protocol?: string;

  /**
   * @schema ListenerSpecForProviderDefaultActionsRedirectConfig#query
   */
  readonly query?: string;

  /**
   * @schema ListenerSpecForProviderDefaultActionsRedirectConfig#statusCode
   */
  readonly statusCode?: string;

}

/**
 * Converts an object of type 'ListenerSpecForProviderDefaultActionsRedirectConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerSpecForProviderDefaultActionsRedirectConfig(obj: ListenerSpecForProviderDefaultActionsRedirectConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'path': obj.path,
    'port': obj.port,
    'protocol': obj.protocol,
    'query': obj.query,
    'statusCode': obj.statusCode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to TargetGroupARN used to set TargetGroupARN
 *
 * @schema ListenerSpecForProviderDefaultActionsTargetGroupArnRef
 */
export interface ListenerSpecForProviderDefaultActionsTargetGroupArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ListenerSpecForProviderDefaultActionsTargetGroupArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ListenerSpecForProviderDefaultActionsTargetGroupArnRef#policy
   */
  readonly policy?: ListenerSpecForProviderDefaultActionsTargetGroupArnRefPolicy;

}

/**
 * Converts an object of type 'ListenerSpecForProviderDefaultActionsTargetGroupArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerSpecForProviderDefaultActionsTargetGroupArnRef(obj: ListenerSpecForProviderDefaultActionsTargetGroupArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ListenerSpecForProviderDefaultActionsTargetGroupArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for references to TargetGroups for TargetGroupARNs
 *
 * @schema ListenerSpecForProviderDefaultActionsTargetGroupArnSelector
 */
export interface ListenerSpecForProviderDefaultActionsTargetGroupArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ListenerSpecForProviderDefaultActionsTargetGroupArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ListenerSpecForProviderDefaultActionsTargetGroupArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ListenerSpecForProviderDefaultActionsTargetGroupArnSelector#policy
   */
  readonly policy?: ListenerSpecForProviderDefaultActionsTargetGroupArnSelectorPolicy;

}

/**
 * Converts an object of type 'ListenerSpecForProviderDefaultActionsTargetGroupArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerSpecForProviderDefaultActionsTargetGroupArnSelector(obj: ListenerSpecForProviderDefaultActionsTargetGroupArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ListenerSpecForProviderDefaultActionsTargetGroupArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ListenerSpecForProviderLoadBalancerArnRefPolicy
 */
export interface ListenerSpecForProviderLoadBalancerArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ListenerSpecForProviderLoadBalancerArnRefPolicy#resolution
   */
  readonly resolution?: ListenerSpecForProviderLoadBalancerArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ListenerSpecForProviderLoadBalancerArnRefPolicy#resolve
   */
  readonly resolve?: ListenerSpecForProviderLoadBalancerArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ListenerSpecForProviderLoadBalancerArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerSpecForProviderLoadBalancerArnRefPolicy(obj: ListenerSpecForProviderLoadBalancerArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ListenerSpecForProviderLoadBalancerArnSelectorPolicy
 */
export interface ListenerSpecForProviderLoadBalancerArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ListenerSpecForProviderLoadBalancerArnSelectorPolicy#resolution
   */
  readonly resolution?: ListenerSpecForProviderLoadBalancerArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ListenerSpecForProviderLoadBalancerArnSelectorPolicy#resolve
   */
  readonly resolve?: ListenerSpecForProviderLoadBalancerArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ListenerSpecForProviderLoadBalancerArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerSpecForProviderLoadBalancerArnSelectorPolicy(obj: ListenerSpecForProviderLoadBalancerArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ListenerSpecProviderConfigRefPolicyResolution
 */
export enum ListenerSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ListenerSpecProviderConfigRefPolicyResolve
 */
export enum ListenerSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ListenerSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ListenerSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ListenerSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ListenerSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ListenerSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ListenerSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ListenerSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerSpecPublishConnectionDetailsToConfigRefPolicy(obj: ListenerSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ListenerSpecForProviderCertificatesCertificateArnRefPolicy
 */
export interface ListenerSpecForProviderCertificatesCertificateArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ListenerSpecForProviderCertificatesCertificateArnRefPolicy#resolution
   */
  readonly resolution?: ListenerSpecForProviderCertificatesCertificateArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ListenerSpecForProviderCertificatesCertificateArnRefPolicy#resolve
   */
  readonly resolve?: ListenerSpecForProviderCertificatesCertificateArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ListenerSpecForProviderCertificatesCertificateArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerSpecForProviderCertificatesCertificateArnRefPolicy(obj: ListenerSpecForProviderCertificatesCertificateArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ListenerSpecForProviderCertificatesCertificateArnSelectorPolicy
 */
export interface ListenerSpecForProviderCertificatesCertificateArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ListenerSpecForProviderCertificatesCertificateArnSelectorPolicy#resolution
   */
  readonly resolution?: ListenerSpecForProviderCertificatesCertificateArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ListenerSpecForProviderCertificatesCertificateArnSelectorPolicy#resolve
   */
  readonly resolve?: ListenerSpecForProviderCertificatesCertificateArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ListenerSpecForProviderCertificatesCertificateArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerSpecForProviderCertificatesCertificateArnSelectorPolicy(obj: ListenerSpecForProviderCertificatesCertificateArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Information about the target group stickiness for a rule.
 *
 * @schema ListenerSpecForProviderDefaultActionsForwardConfigTargetGroupStickinessConfig
 */
export interface ListenerSpecForProviderDefaultActionsForwardConfigTargetGroupStickinessConfig {
  /**
   * @schema ListenerSpecForProviderDefaultActionsForwardConfigTargetGroupStickinessConfig#durationSeconds
   */
  readonly durationSeconds?: number;

  /**
   * @schema ListenerSpecForProviderDefaultActionsForwardConfigTargetGroupStickinessConfig#enabled
   */
  readonly enabled?: boolean;

}

/**
 * Converts an object of type 'ListenerSpecForProviderDefaultActionsForwardConfigTargetGroupStickinessConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerSpecForProviderDefaultActionsForwardConfigTargetGroupStickinessConfig(obj: ListenerSpecForProviderDefaultActionsForwardConfigTargetGroupStickinessConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'durationSeconds': obj.durationSeconds,
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CustomTargetGroupTuple includes custom fields about target groups. Only used with ForwardActionConfig to route to multiple target groups.
 *
 * @schema ListenerSpecForProviderDefaultActionsForwardConfigTargetGroups
 */
export interface ListenerSpecForProviderDefaultActionsForwardConfigTargetGroups {
  /**
   * @schema ListenerSpecForProviderDefaultActionsForwardConfigTargetGroups#targetGroupARN
   */
  readonly targetGroupArn?: string;

  /**
   * Reference to TargetGroupARN used to set TargetGroupARN
   *
   * @schema ListenerSpecForProviderDefaultActionsForwardConfigTargetGroups#targetGroupArnRef
   */
  readonly targetGroupArnRef?: ListenerSpecForProviderDefaultActionsForwardConfigTargetGroupsTargetGroupArnRef;

  /**
   * Selector for references to TargetGroup for TargetGroupARN
   *
   * @schema ListenerSpecForProviderDefaultActionsForwardConfigTargetGroups#targetGroupArnSelector
   */
  readonly targetGroupArnSelector?: ListenerSpecForProviderDefaultActionsForwardConfigTargetGroupsTargetGroupArnSelector;

  /**
   * @schema ListenerSpecForProviderDefaultActionsForwardConfigTargetGroups#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'ListenerSpecForProviderDefaultActionsForwardConfigTargetGroups' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerSpecForProviderDefaultActionsForwardConfigTargetGroups(obj: ListenerSpecForProviderDefaultActionsForwardConfigTargetGroups | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'targetGroupARN': obj.targetGroupArn,
    'targetGroupArnRef': toJson_ListenerSpecForProviderDefaultActionsForwardConfigTargetGroupsTargetGroupArnRef(obj.targetGroupArnRef),
    'targetGroupArnSelector': toJson_ListenerSpecForProviderDefaultActionsForwardConfigTargetGroupsTargetGroupArnSelector(obj.targetGroupArnSelector),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ListenerSpecForProviderDefaultActionsTargetGroupArnRefPolicy
 */
export interface ListenerSpecForProviderDefaultActionsTargetGroupArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ListenerSpecForProviderDefaultActionsTargetGroupArnRefPolicy#resolution
   */
  readonly resolution?: ListenerSpecForProviderDefaultActionsTargetGroupArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ListenerSpecForProviderDefaultActionsTargetGroupArnRefPolicy#resolve
   */
  readonly resolve?: ListenerSpecForProviderDefaultActionsTargetGroupArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ListenerSpecForProviderDefaultActionsTargetGroupArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerSpecForProviderDefaultActionsTargetGroupArnRefPolicy(obj: ListenerSpecForProviderDefaultActionsTargetGroupArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ListenerSpecForProviderDefaultActionsTargetGroupArnSelectorPolicy
 */
export interface ListenerSpecForProviderDefaultActionsTargetGroupArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ListenerSpecForProviderDefaultActionsTargetGroupArnSelectorPolicy#resolution
   */
  readonly resolution?: ListenerSpecForProviderDefaultActionsTargetGroupArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ListenerSpecForProviderDefaultActionsTargetGroupArnSelectorPolicy#resolve
   */
  readonly resolve?: ListenerSpecForProviderDefaultActionsTargetGroupArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ListenerSpecForProviderDefaultActionsTargetGroupArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerSpecForProviderDefaultActionsTargetGroupArnSelectorPolicy(obj: ListenerSpecForProviderDefaultActionsTargetGroupArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ListenerSpecForProviderLoadBalancerArnRefPolicyResolution
 */
export enum ListenerSpecForProviderLoadBalancerArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ListenerSpecForProviderLoadBalancerArnRefPolicyResolve
 */
export enum ListenerSpecForProviderLoadBalancerArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ListenerSpecForProviderLoadBalancerArnSelectorPolicyResolution
 */
export enum ListenerSpecForProviderLoadBalancerArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ListenerSpecForProviderLoadBalancerArnSelectorPolicyResolve
 */
export enum ListenerSpecForProviderLoadBalancerArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ListenerSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ListenerSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ListenerSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ListenerSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ListenerSpecForProviderCertificatesCertificateArnRefPolicyResolution
 */
export enum ListenerSpecForProviderCertificatesCertificateArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ListenerSpecForProviderCertificatesCertificateArnRefPolicyResolve
 */
export enum ListenerSpecForProviderCertificatesCertificateArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ListenerSpecForProviderCertificatesCertificateArnSelectorPolicyResolution
 */
export enum ListenerSpecForProviderCertificatesCertificateArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ListenerSpecForProviderCertificatesCertificateArnSelectorPolicyResolve
 */
export enum ListenerSpecForProviderCertificatesCertificateArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Reference to TargetGroupARN used to set TargetGroupARN
 *
 * @schema ListenerSpecForProviderDefaultActionsForwardConfigTargetGroupsTargetGroupArnRef
 */
export interface ListenerSpecForProviderDefaultActionsForwardConfigTargetGroupsTargetGroupArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ListenerSpecForProviderDefaultActionsForwardConfigTargetGroupsTargetGroupArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ListenerSpecForProviderDefaultActionsForwardConfigTargetGroupsTargetGroupArnRef#policy
   */
  readonly policy?: ListenerSpecForProviderDefaultActionsForwardConfigTargetGroupsTargetGroupArnRefPolicy;

}

/**
 * Converts an object of type 'ListenerSpecForProviderDefaultActionsForwardConfigTargetGroupsTargetGroupArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerSpecForProviderDefaultActionsForwardConfigTargetGroupsTargetGroupArnRef(obj: ListenerSpecForProviderDefaultActionsForwardConfigTargetGroupsTargetGroupArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ListenerSpecForProviderDefaultActionsForwardConfigTargetGroupsTargetGroupArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for references to TargetGroup for TargetGroupARN
 *
 * @schema ListenerSpecForProviderDefaultActionsForwardConfigTargetGroupsTargetGroupArnSelector
 */
export interface ListenerSpecForProviderDefaultActionsForwardConfigTargetGroupsTargetGroupArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ListenerSpecForProviderDefaultActionsForwardConfigTargetGroupsTargetGroupArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ListenerSpecForProviderDefaultActionsForwardConfigTargetGroupsTargetGroupArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ListenerSpecForProviderDefaultActionsForwardConfigTargetGroupsTargetGroupArnSelector#policy
   */
  readonly policy?: ListenerSpecForProviderDefaultActionsForwardConfigTargetGroupsTargetGroupArnSelectorPolicy;

}

/**
 * Converts an object of type 'ListenerSpecForProviderDefaultActionsForwardConfigTargetGroupsTargetGroupArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerSpecForProviderDefaultActionsForwardConfigTargetGroupsTargetGroupArnSelector(obj: ListenerSpecForProviderDefaultActionsForwardConfigTargetGroupsTargetGroupArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ListenerSpecForProviderDefaultActionsForwardConfigTargetGroupsTargetGroupArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ListenerSpecForProviderDefaultActionsTargetGroupArnRefPolicyResolution
 */
export enum ListenerSpecForProviderDefaultActionsTargetGroupArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ListenerSpecForProviderDefaultActionsTargetGroupArnRefPolicyResolve
 */
export enum ListenerSpecForProviderDefaultActionsTargetGroupArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ListenerSpecForProviderDefaultActionsTargetGroupArnSelectorPolicyResolution
 */
export enum ListenerSpecForProviderDefaultActionsTargetGroupArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ListenerSpecForProviderDefaultActionsTargetGroupArnSelectorPolicyResolve
 */
export enum ListenerSpecForProviderDefaultActionsTargetGroupArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ListenerSpecForProviderDefaultActionsForwardConfigTargetGroupsTargetGroupArnRefPolicy
 */
export interface ListenerSpecForProviderDefaultActionsForwardConfigTargetGroupsTargetGroupArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ListenerSpecForProviderDefaultActionsForwardConfigTargetGroupsTargetGroupArnRefPolicy#resolution
   */
  readonly resolution?: ListenerSpecForProviderDefaultActionsForwardConfigTargetGroupsTargetGroupArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ListenerSpecForProviderDefaultActionsForwardConfigTargetGroupsTargetGroupArnRefPolicy#resolve
   */
  readonly resolve?: ListenerSpecForProviderDefaultActionsForwardConfigTargetGroupsTargetGroupArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ListenerSpecForProviderDefaultActionsForwardConfigTargetGroupsTargetGroupArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerSpecForProviderDefaultActionsForwardConfigTargetGroupsTargetGroupArnRefPolicy(obj: ListenerSpecForProviderDefaultActionsForwardConfigTargetGroupsTargetGroupArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ListenerSpecForProviderDefaultActionsForwardConfigTargetGroupsTargetGroupArnSelectorPolicy
 */
export interface ListenerSpecForProviderDefaultActionsForwardConfigTargetGroupsTargetGroupArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ListenerSpecForProviderDefaultActionsForwardConfigTargetGroupsTargetGroupArnSelectorPolicy#resolution
   */
  readonly resolution?: ListenerSpecForProviderDefaultActionsForwardConfigTargetGroupsTargetGroupArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ListenerSpecForProviderDefaultActionsForwardConfigTargetGroupsTargetGroupArnSelectorPolicy#resolve
   */
  readonly resolve?: ListenerSpecForProviderDefaultActionsForwardConfigTargetGroupsTargetGroupArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ListenerSpecForProviderDefaultActionsForwardConfigTargetGroupsTargetGroupArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ListenerSpecForProviderDefaultActionsForwardConfigTargetGroupsTargetGroupArnSelectorPolicy(obj: ListenerSpecForProviderDefaultActionsForwardConfigTargetGroupsTargetGroupArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ListenerSpecForProviderDefaultActionsForwardConfigTargetGroupsTargetGroupArnRefPolicyResolution
 */
export enum ListenerSpecForProviderDefaultActionsForwardConfigTargetGroupsTargetGroupArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ListenerSpecForProviderDefaultActionsForwardConfigTargetGroupsTargetGroupArnRefPolicyResolve
 */
export enum ListenerSpecForProviderDefaultActionsForwardConfigTargetGroupsTargetGroupArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ListenerSpecForProviderDefaultActionsForwardConfigTargetGroupsTargetGroupArnSelectorPolicyResolution
 */
export enum ListenerSpecForProviderDefaultActionsForwardConfigTargetGroupsTargetGroupArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ListenerSpecForProviderDefaultActionsForwardConfigTargetGroupsTargetGroupArnSelectorPolicyResolve
 */
export enum ListenerSpecForProviderDefaultActionsForwardConfigTargetGroupsTargetGroupArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * LoadBalancer is the Schema for the LoadBalancers API
 *
 * @schema LoadBalancer
 */
export class LoadBalancer extends ApiObject {
  /**
   * Returns the apiVersion and kind for "LoadBalancer"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'elbv2.aws.crossplane.io/v1alpha1',
    kind: 'LoadBalancer',
  }

  /**
   * Renders a Kubernetes manifest for "LoadBalancer".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: LoadBalancerProps): any {
    return {
      ...LoadBalancer.GVK,
      ...toJson_LoadBalancerProps(props),
    };
  }

  /**
   * Defines a "LoadBalancer" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: LoadBalancerProps) {
    super(scope, id, {
      ...LoadBalancer.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...LoadBalancer.GVK,
      ...toJson_LoadBalancerProps(resolved),
    };
  }
}

/**
 * LoadBalancer is the Schema for the LoadBalancers API
 *
 * @schema LoadBalancer
 */
export interface LoadBalancerProps {
  /**
   * @schema LoadBalancer#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * LoadBalancerSpec defines the desired state of LoadBalancer
   *
   * @schema LoadBalancer#spec
   */
  readonly spec: LoadBalancerSpec;

}

/**
 * Converts an object of type 'LoadBalancerProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LoadBalancerProps(obj: LoadBalancerProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_LoadBalancerSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LoadBalancerSpec defines the desired state of LoadBalancer
 *
 * @schema LoadBalancerSpec
 */
export interface LoadBalancerSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema LoadBalancerSpec#deletionPolicy
   */
  readonly deletionPolicy?: LoadBalancerSpecDeletionPolicy;

  /**
   * LoadBalancerParameters defines the desired state of LoadBalancer
   *
   * @schema LoadBalancerSpec#forProvider
   */
  readonly forProvider: LoadBalancerSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema LoadBalancerSpec#managementPolicies
   */
  readonly managementPolicies?: LoadBalancerSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema LoadBalancerSpec#providerConfigRef
   */
  readonly providerConfigRef?: LoadBalancerSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema LoadBalancerSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: LoadBalancerSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema LoadBalancerSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: LoadBalancerSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'LoadBalancerSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LoadBalancerSpec(obj: LoadBalancerSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_LoadBalancerSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_LoadBalancerSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_LoadBalancerSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_LoadBalancerSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema LoadBalancerSpecDeletionPolicy
 */
export enum LoadBalancerSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * LoadBalancerParameters defines the desired state of LoadBalancer
 *
 * @schema LoadBalancerSpecForProvider
 */
export interface LoadBalancerSpecForProvider {
  /**
   * [Application Load Balancers on Outposts] The ID of the customer-owned address pool (CoIP pool).
   *
   * @schema LoadBalancerSpecForProvider#customerOwnedIPv4Pool
   */
  readonly customerOwnedIPv4Pool?: string;

  /**
   * The type of IP addresses used by the subnets for your load balancer. The possible values are ipv4 (for IPv4 addresses) and dualstack (for IPv4 and IPv6 addresses).
   *
   * @schema LoadBalancerSpecForProvider#ipAddressType
   */
  readonly ipAddressType?: string;

  /**
   * The type of load balancer. The default is application.
   *
   * @schema LoadBalancerSpecForProvider#loadBalancerType
   */
  readonly loadBalancerType?: string;

  /**
   * The name of the load balancer.
   * This name must be unique per region per account, can have a maximum of 32 characters, must contain only alphanumeric characters or hyphens, must not begin or end with a hyphen, and must not begin with "internal-".
   *
   * @schema LoadBalancerSpecForProvider#name
   */
  readonly name: string;

  /**
   * Region is which region the LoadBalancer will be created.
   *
   * @schema LoadBalancerSpecForProvider#region
   */
  readonly region: string;

  /**
   * The nodes of an Internet-facing load balancer have public IP addresses. The DNS name of an Internet-facing load balancer is publicly resolvable to the public IP addresses of the nodes. Therefore, Internet-facing load balancers can route requests from clients over the internet.
   * The nodes of an internal load balancer have only private IP addresses. The DNS name of an internal load balancer is publicly resolvable to the private IP addresses of the nodes. Therefore, internal load balancers can route requests only from clients with access to the VPC for the load balancer.
   * The default is an Internet-facing load balancer.
   * You cannot specify a scheme for a Gateway Load Balancer.
   *
   * @schema LoadBalancerSpecForProvider#scheme
   */
  readonly scheme?: string;

  /**
   * Reference to Security Groups for SecurityGroups field
   *
   * @schema LoadBalancerSpecForProvider#securityGroupRefs
   */
  readonly securityGroupRefs?: LoadBalancerSpecForProviderSecurityGroupRefs[];

  /**
   * Selector for references to SecurityGroups
   *
   * @schema LoadBalancerSpecForProvider#securityGroupSelector
   */
  readonly securityGroupSelector?: LoadBalancerSpecForProviderSecurityGroupSelector;

  /**
   * [Application Load Balancers and Network Load Balancers] The IDs of the security groups for the load balancer.
   *
   * @schema LoadBalancerSpecForProvider#securityGroups
   */
  readonly securityGroups?: string[];

  /**
   * The IDs of the public subnets. You can specify only one subnet per Availability Zone. You must specify either subnets or subnet mappings, but not both.
   * [Application Load Balancers] You must specify subnets from at least two Availability Zones. You cannot specify Elastic IP addresses for your subnets.
   * [Application Load Balancers on Outposts] You must specify one Outpost subnet.
   * [Application Load Balancers on Local Zones] You can specify subnets from one or more Local Zones.
   * [Network Load Balancers] You can specify subnets from one or more Availability Zones. You can specify one Elastic IP address per subnet if you need static IP addresses for your internet-facing load balancer. For internal load balancers, you can specify one private IP address per subnet from the IPv4 range of the subnet. For internet-facing load balancer, you can specify one IPv6 address per subnet.
   * [Gateway Load Balancers] You can specify subnets from one or more Availability Zones. You cannot specify Elastic IP addresses for your subnets.
   *
   * @schema LoadBalancerSpecForProvider#subnetMappings
   */
  readonly subnetMappings?: LoadBalancerSpecForProviderSubnetMappings[];

  /**
   * Reference to Subnets for Subnets field
   *
   * @schema LoadBalancerSpecForProvider#subnetRefs
   */
  readonly subnetRefs?: LoadBalancerSpecForProviderSubnetRefs[];

  /**
   * Selector for references to Subnets
   *
   * @schema LoadBalancerSpecForProvider#subnetSelector
   */
  readonly subnetSelector?: LoadBalancerSpecForProviderSubnetSelector;

  /**
   * The IDs of the public subnets. You can specify only one subnet per Availability Zone. You must specify either subnets or subnet mappings, but not both. To specify an Elastic IP address, specify subnet mappings instead of subnets.
   * [Application Load Balancers] You must specify subnets from at least two Availability Zones.
   * [Application Load Balancers on Outposts] You must specify one Outpost subnet.
   * [Application Load Balancers on Local Zones] You can specify subnets from one or more Local Zones.
   * [Network Load Balancers] You can specify subnets from one or more Availability Zones.
   * [Gateway Load Balancers] You can specify subnets from one or more Availability Zones.
   *
   * @schema LoadBalancerSpecForProvider#subnets
   */
  readonly subnets?: string[];

  /**
   * The tags to assign to the load balancer.
   *
   * @schema LoadBalancerSpecForProvider#tags
   */
  readonly tags?: LoadBalancerSpecForProviderTags[];

}

/**
 * Converts an object of type 'LoadBalancerSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LoadBalancerSpecForProvider(obj: LoadBalancerSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customerOwnedIPv4Pool': obj.customerOwnedIPv4Pool,
    'ipAddressType': obj.ipAddressType,
    'loadBalancerType': obj.loadBalancerType,
    'name': obj.name,
    'region': obj.region,
    'scheme': obj.scheme,
    'securityGroupRefs': obj.securityGroupRefs?.map(y => toJson_LoadBalancerSpecForProviderSecurityGroupRefs(y)),
    'securityGroupSelector': toJson_LoadBalancerSpecForProviderSecurityGroupSelector(obj.securityGroupSelector),
    'securityGroups': obj.securityGroups?.map(y => y),
    'subnetMappings': obj.subnetMappings?.map(y => toJson_LoadBalancerSpecForProviderSubnetMappings(y)),
    'subnetRefs': obj.subnetRefs?.map(y => toJson_LoadBalancerSpecForProviderSubnetRefs(y)),
    'subnetSelector': toJson_LoadBalancerSpecForProviderSubnetSelector(obj.subnetSelector),
    'subnets': obj.subnets?.map(y => y),
    'tags': obj.tags?.map(y => toJson_LoadBalancerSpecForProviderTags(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema LoadBalancerSpecManagementPolicies
 */
export enum LoadBalancerSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema LoadBalancerSpecProviderConfigRef
 */
export interface LoadBalancerSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema LoadBalancerSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LoadBalancerSpecProviderConfigRef#policy
   */
  readonly policy?: LoadBalancerSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'LoadBalancerSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LoadBalancerSpecProviderConfigRef(obj: LoadBalancerSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LoadBalancerSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema LoadBalancerSpecPublishConnectionDetailsTo
 */
export interface LoadBalancerSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema LoadBalancerSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: LoadBalancerSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema LoadBalancerSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: LoadBalancerSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema LoadBalancerSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'LoadBalancerSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LoadBalancerSpecPublishConnectionDetailsTo(obj: LoadBalancerSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_LoadBalancerSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_LoadBalancerSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema LoadBalancerSpecWriteConnectionSecretToRef
 */
export interface LoadBalancerSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema LoadBalancerSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema LoadBalancerSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'LoadBalancerSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LoadBalancerSpecWriteConnectionSecretToRef(obj: LoadBalancerSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema LoadBalancerSpecForProviderSecurityGroupRefs
 */
export interface LoadBalancerSpecForProviderSecurityGroupRefs {
  /**
   * Name of the referenced object.
   *
   * @schema LoadBalancerSpecForProviderSecurityGroupRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LoadBalancerSpecForProviderSecurityGroupRefs#policy
   */
  readonly policy?: LoadBalancerSpecForProviderSecurityGroupRefsPolicy;

}

/**
 * Converts an object of type 'LoadBalancerSpecForProviderSecurityGroupRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LoadBalancerSpecForProviderSecurityGroupRefs(obj: LoadBalancerSpecForProviderSecurityGroupRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LoadBalancerSpecForProviderSecurityGroupRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for references to SecurityGroups
 *
 * @schema LoadBalancerSpecForProviderSecurityGroupSelector
 */
export interface LoadBalancerSpecForProviderSecurityGroupSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema LoadBalancerSpecForProviderSecurityGroupSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema LoadBalancerSpecForProviderSecurityGroupSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema LoadBalancerSpecForProviderSecurityGroupSelector#policy
   */
  readonly policy?: LoadBalancerSpecForProviderSecurityGroupSelectorPolicy;

}

/**
 * Converts an object of type 'LoadBalancerSpecForProviderSecurityGroupSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LoadBalancerSpecForProviderSecurityGroupSelector(obj: LoadBalancerSpecForProviderSecurityGroupSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_LoadBalancerSpecForProviderSecurityGroupSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LoadBalancerSpecForProviderSubnetMappings
 */
export interface LoadBalancerSpecForProviderSubnetMappings {
  /**
   * @schema LoadBalancerSpecForProviderSubnetMappings#allocationID
   */
  readonly allocationId?: string;

  /**
   * @schema LoadBalancerSpecForProviderSubnetMappings#iPv6Address
   */
  readonly iPv6Address?: string;

  /**
   * @schema LoadBalancerSpecForProviderSubnetMappings#privateIPv4Address
   */
  readonly privateIPv4Address?: string;

  /**
   * @schema LoadBalancerSpecForProviderSubnetMappings#subnetID
   */
  readonly subnetId?: string;

}

/**
 * Converts an object of type 'LoadBalancerSpecForProviderSubnetMappings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LoadBalancerSpecForProviderSubnetMappings(obj: LoadBalancerSpecForProviderSubnetMappings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allocationID': obj.allocationId,
    'iPv6Address': obj.iPv6Address,
    'privateIPv4Address': obj.privateIPv4Address,
    'subnetID': obj.subnetId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema LoadBalancerSpecForProviderSubnetRefs
 */
export interface LoadBalancerSpecForProviderSubnetRefs {
  /**
   * Name of the referenced object.
   *
   * @schema LoadBalancerSpecForProviderSubnetRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LoadBalancerSpecForProviderSubnetRefs#policy
   */
  readonly policy?: LoadBalancerSpecForProviderSubnetRefsPolicy;

}

/**
 * Converts an object of type 'LoadBalancerSpecForProviderSubnetRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LoadBalancerSpecForProviderSubnetRefs(obj: LoadBalancerSpecForProviderSubnetRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LoadBalancerSpecForProviderSubnetRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for references to Subnets
 *
 * @schema LoadBalancerSpecForProviderSubnetSelector
 */
export interface LoadBalancerSpecForProviderSubnetSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema LoadBalancerSpecForProviderSubnetSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema LoadBalancerSpecForProviderSubnetSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema LoadBalancerSpecForProviderSubnetSelector#policy
   */
  readonly policy?: LoadBalancerSpecForProviderSubnetSelectorPolicy;

}

/**
 * Converts an object of type 'LoadBalancerSpecForProviderSubnetSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LoadBalancerSpecForProviderSubnetSelector(obj: LoadBalancerSpecForProviderSubnetSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_LoadBalancerSpecForProviderSubnetSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LoadBalancerSpecForProviderTags
 */
export interface LoadBalancerSpecForProviderTags {
  /**
   * @schema LoadBalancerSpecForProviderTags#key
   */
  readonly key?: string;

  /**
   * @schema LoadBalancerSpecForProviderTags#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'LoadBalancerSpecForProviderTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LoadBalancerSpecForProviderTags(obj: LoadBalancerSpecForProviderTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LoadBalancerSpecProviderConfigRefPolicy
 */
export interface LoadBalancerSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LoadBalancerSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: LoadBalancerSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LoadBalancerSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: LoadBalancerSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'LoadBalancerSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LoadBalancerSpecProviderConfigRefPolicy(obj: LoadBalancerSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema LoadBalancerSpecPublishConnectionDetailsToConfigRef
 */
export interface LoadBalancerSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema LoadBalancerSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LoadBalancerSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: LoadBalancerSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'LoadBalancerSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LoadBalancerSpecPublishConnectionDetailsToConfigRef(obj: LoadBalancerSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LoadBalancerSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema LoadBalancerSpecPublishConnectionDetailsToMetadata
 */
export interface LoadBalancerSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema LoadBalancerSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema LoadBalancerSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema LoadBalancerSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'LoadBalancerSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LoadBalancerSpecPublishConnectionDetailsToMetadata(obj: LoadBalancerSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LoadBalancerSpecForProviderSecurityGroupRefsPolicy
 */
export interface LoadBalancerSpecForProviderSecurityGroupRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LoadBalancerSpecForProviderSecurityGroupRefsPolicy#resolution
   */
  readonly resolution?: LoadBalancerSpecForProviderSecurityGroupRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LoadBalancerSpecForProviderSecurityGroupRefsPolicy#resolve
   */
  readonly resolve?: LoadBalancerSpecForProviderSecurityGroupRefsPolicyResolve;

}

/**
 * Converts an object of type 'LoadBalancerSpecForProviderSecurityGroupRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LoadBalancerSpecForProviderSecurityGroupRefsPolicy(obj: LoadBalancerSpecForProviderSecurityGroupRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema LoadBalancerSpecForProviderSecurityGroupSelectorPolicy
 */
export interface LoadBalancerSpecForProviderSecurityGroupSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LoadBalancerSpecForProviderSecurityGroupSelectorPolicy#resolution
   */
  readonly resolution?: LoadBalancerSpecForProviderSecurityGroupSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LoadBalancerSpecForProviderSecurityGroupSelectorPolicy#resolve
   */
  readonly resolve?: LoadBalancerSpecForProviderSecurityGroupSelectorPolicyResolve;

}

/**
 * Converts an object of type 'LoadBalancerSpecForProviderSecurityGroupSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LoadBalancerSpecForProviderSecurityGroupSelectorPolicy(obj: LoadBalancerSpecForProviderSecurityGroupSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LoadBalancerSpecForProviderSubnetRefsPolicy
 */
export interface LoadBalancerSpecForProviderSubnetRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LoadBalancerSpecForProviderSubnetRefsPolicy#resolution
   */
  readonly resolution?: LoadBalancerSpecForProviderSubnetRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LoadBalancerSpecForProviderSubnetRefsPolicy#resolve
   */
  readonly resolve?: LoadBalancerSpecForProviderSubnetRefsPolicyResolve;

}

/**
 * Converts an object of type 'LoadBalancerSpecForProviderSubnetRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LoadBalancerSpecForProviderSubnetRefsPolicy(obj: LoadBalancerSpecForProviderSubnetRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema LoadBalancerSpecForProviderSubnetSelectorPolicy
 */
export interface LoadBalancerSpecForProviderSubnetSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LoadBalancerSpecForProviderSubnetSelectorPolicy#resolution
   */
  readonly resolution?: LoadBalancerSpecForProviderSubnetSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LoadBalancerSpecForProviderSubnetSelectorPolicy#resolve
   */
  readonly resolve?: LoadBalancerSpecForProviderSubnetSelectorPolicyResolve;

}

/**
 * Converts an object of type 'LoadBalancerSpecForProviderSubnetSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LoadBalancerSpecForProviderSubnetSelectorPolicy(obj: LoadBalancerSpecForProviderSubnetSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LoadBalancerSpecProviderConfigRefPolicyResolution
 */
export enum LoadBalancerSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LoadBalancerSpecProviderConfigRefPolicyResolve
 */
export enum LoadBalancerSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema LoadBalancerSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface LoadBalancerSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LoadBalancerSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: LoadBalancerSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LoadBalancerSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: LoadBalancerSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'LoadBalancerSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LoadBalancerSpecPublishConnectionDetailsToConfigRefPolicy(obj: LoadBalancerSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LoadBalancerSpecForProviderSecurityGroupRefsPolicyResolution
 */
export enum LoadBalancerSpecForProviderSecurityGroupRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LoadBalancerSpecForProviderSecurityGroupRefsPolicyResolve
 */
export enum LoadBalancerSpecForProviderSecurityGroupRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LoadBalancerSpecForProviderSecurityGroupSelectorPolicyResolution
 */
export enum LoadBalancerSpecForProviderSecurityGroupSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LoadBalancerSpecForProviderSecurityGroupSelectorPolicyResolve
 */
export enum LoadBalancerSpecForProviderSecurityGroupSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LoadBalancerSpecForProviderSubnetRefsPolicyResolution
 */
export enum LoadBalancerSpecForProviderSubnetRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LoadBalancerSpecForProviderSubnetRefsPolicyResolve
 */
export enum LoadBalancerSpecForProviderSubnetRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LoadBalancerSpecForProviderSubnetSelectorPolicyResolution
 */
export enum LoadBalancerSpecForProviderSubnetSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LoadBalancerSpecForProviderSubnetSelectorPolicyResolve
 */
export enum LoadBalancerSpecForProviderSubnetSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LoadBalancerSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum LoadBalancerSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LoadBalancerSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum LoadBalancerSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Target is the Schema for registering a target to an ELBV2 TargetGroup.
 *
 * @schema Target
 */
export class Target extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Target"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'elbv2.aws.crossplane.io/v1alpha1',
    kind: 'Target',
  }

  /**
   * Renders a Kubernetes manifest for "Target".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: TargetProps): any {
    return {
      ...Target.GVK,
      ...toJson_TargetProps(props),
    };
  }

  /**
   * Defines a "Target" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: TargetProps) {
    super(scope, id, {
      ...Target.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Target.GVK,
      ...toJson_TargetProps(resolved),
    };
  }
}

/**
 * Target is the Schema for registering a target to an ELBV2 TargetGroup.
 *
 * @schema Target
 */
export interface TargetProps {
  /**
   * @schema Target#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * TargetSpec defines the desired state of a Target
   *
   * @schema Target#spec
   */
  readonly spec: TargetSpec;

}

/**
 * Converts an object of type 'TargetProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetProps(obj: TargetProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_TargetSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TargetSpec defines the desired state of a Target
 *
 * @schema TargetSpec
 */
export interface TargetSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema TargetSpec#deletionPolicy
   */
  readonly deletionPolicy?: TargetSpecDeletionPolicy;

  /**
   * TargetParameters defines the desired state of a Target
   *
   * @schema TargetSpec#forProvider
   */
  readonly forProvider: TargetSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema TargetSpec#managementPolicies
   */
  readonly managementPolicies?: TargetSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema TargetSpec#providerConfigRef
   */
  readonly providerConfigRef?: TargetSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema TargetSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: TargetSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema TargetSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: TargetSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'TargetSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpec(obj: TargetSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_TargetSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_TargetSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_TargetSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_TargetSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema TargetSpecDeletionPolicy
 */
export enum TargetSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * TargetParameters defines the desired state of a Target
 *
 * @schema TargetSpecForProvider
 */
export interface TargetSpecForProvider {
  /**
   * An Availability Zone or all. This determines whether the target receives traffic from the load balancer nodes in the specified Availability Zone or from all enabled Availability Zones for the load balancer.
   * This parameter is not supported if the target type of the target group is instance or alb.
   * If the target type is ip and the IP address is in a subnet of the VPC for the target group, the Availability Zone is automatically detected and this parameter is optional. If the IP address is outside the VPC, this parameter is required.
   * With an Application Load Balancer, if the target type is ip and the IP address is outside the VPC for the target group, the only supported value is all.
   * If the target type is lambda, this parameter is optional and the only supported value is all.
   *
   * @schema TargetSpecForProvider#availabilityZone
   */
  readonly availabilityZone?: string;

  /**
   * The LambdaARN that should be used as target.
   * Note: If you want to reference anything else than Lambda you currently have to specify the crossplane.io/external-name annotation directly. If the target type of the target group is instance, specify an instance ID. If the target type is ip, specify an IP address. If the target type is lambda, specify the ARN of the Lambda function. If the target type is alb, specify the ARN of the Application Load Balancer target.
   *
   * @schema TargetSpecForProvider#lambdaArn
   */
  readonly lambdaArn?: string;

  /**
   * LambdaARNRef references a Lambda Function to set LambdaARN.
   *
   * @schema TargetSpecForProvider#lambdaArnRef
   */
  readonly lambdaArnRef?: TargetSpecForProviderLambdaArnRef;

  /**
   * LambdaARNSelector references a Lambda Function to set LambdaARN.
   *
   * @schema TargetSpecForProvider#lambdaArnSelector
   */
  readonly lambdaArnSelector?: TargetSpecForProviderLambdaArnSelector;

  /**
   * The port on which the target is listening. If the target group protocol is GENEVE, the supported port is 6081. If the target type is alb, the targeted Application Load Balancer must have at least one listener whose port matches the target group port. Not used if the target is a Lambda function.
   *
   * @schema TargetSpecForProvider#port
   */
  readonly port?: number;

  /**
   * The AWS region the target resides in.
   *
   * @schema TargetSpecForProvider#region
   */
  readonly region: string;

  /**
   * The Amazon Resource Name (ARN) of the target group.
   * One of TargetGroupARN, TargetGroupARNRef or TargetGroupARNSelector is required.
   *
   * @schema TargetSpecForProvider#targetGroupArn
   */
  readonly targetGroupArn?: string;

  /**
   * TargetGroupARNRef selects a ELBv2 TargetGroupARN with the given name.
   *
   * @schema TargetSpecForProvider#targetGroupArnRef
   */
  readonly targetGroupArnRef?: TargetSpecForProviderTargetGroupArnRef;

  /**
   * TargetGroupARNSelector selects a ELBv2 TargetGroupARN with the given labels.
   *
   * @schema TargetSpecForProvider#targetGroupArnSelector
   */
  readonly targetGroupArnSelector?: TargetSpecForProviderTargetGroupArnSelector;

}

/**
 * Converts an object of type 'TargetSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecForProvider(obj: TargetSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'availabilityZone': obj.availabilityZone,
    'lambdaArn': obj.lambdaArn,
    'lambdaArnRef': toJson_TargetSpecForProviderLambdaArnRef(obj.lambdaArnRef),
    'lambdaArnSelector': toJson_TargetSpecForProviderLambdaArnSelector(obj.lambdaArnSelector),
    'port': obj.port,
    'region': obj.region,
    'targetGroupArn': obj.targetGroupArn,
    'targetGroupArnRef': toJson_TargetSpecForProviderTargetGroupArnRef(obj.targetGroupArnRef),
    'targetGroupArnSelector': toJson_TargetSpecForProviderTargetGroupArnSelector(obj.targetGroupArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema TargetSpecManagementPolicies
 */
export enum TargetSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema TargetSpecProviderConfigRef
 */
export interface TargetSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TargetSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TargetSpecProviderConfigRef#policy
   */
  readonly policy?: TargetSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'TargetSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecProviderConfigRef(obj: TargetSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TargetSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema TargetSpecPublishConnectionDetailsTo
 */
export interface TargetSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema TargetSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: TargetSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema TargetSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: TargetSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema TargetSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'TargetSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecPublishConnectionDetailsTo(obj: TargetSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_TargetSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_TargetSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema TargetSpecWriteConnectionSecretToRef
 */
export interface TargetSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema TargetSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema TargetSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'TargetSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecWriteConnectionSecretToRef(obj: TargetSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LambdaARNRef references a Lambda Function to set LambdaARN.
 *
 * @schema TargetSpecForProviderLambdaArnRef
 */
export interface TargetSpecForProviderLambdaArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema TargetSpecForProviderLambdaArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TargetSpecForProviderLambdaArnRef#policy
   */
  readonly policy?: TargetSpecForProviderLambdaArnRefPolicy;

}

/**
 * Converts an object of type 'TargetSpecForProviderLambdaArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecForProviderLambdaArnRef(obj: TargetSpecForProviderLambdaArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TargetSpecForProviderLambdaArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LambdaARNSelector references a Lambda Function to set LambdaARN.
 *
 * @schema TargetSpecForProviderLambdaArnSelector
 */
export interface TargetSpecForProviderLambdaArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TargetSpecForProviderLambdaArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TargetSpecForProviderLambdaArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TargetSpecForProviderLambdaArnSelector#policy
   */
  readonly policy?: TargetSpecForProviderLambdaArnSelectorPolicy;

}

/**
 * Converts an object of type 'TargetSpecForProviderLambdaArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecForProviderLambdaArnSelector(obj: TargetSpecForProviderLambdaArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TargetSpecForProviderLambdaArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TargetGroupARNRef selects a ELBv2 TargetGroupARN with the given name.
 *
 * @schema TargetSpecForProviderTargetGroupArnRef
 */
export interface TargetSpecForProviderTargetGroupArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema TargetSpecForProviderTargetGroupArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TargetSpecForProviderTargetGroupArnRef#policy
   */
  readonly policy?: TargetSpecForProviderTargetGroupArnRefPolicy;

}

/**
 * Converts an object of type 'TargetSpecForProviderTargetGroupArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecForProviderTargetGroupArnRef(obj: TargetSpecForProviderTargetGroupArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TargetSpecForProviderTargetGroupArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TargetGroupARNSelector selects a ELBv2 TargetGroupARN with the given labels.
 *
 * @schema TargetSpecForProviderTargetGroupArnSelector
 */
export interface TargetSpecForProviderTargetGroupArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TargetSpecForProviderTargetGroupArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TargetSpecForProviderTargetGroupArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TargetSpecForProviderTargetGroupArnSelector#policy
   */
  readonly policy?: TargetSpecForProviderTargetGroupArnSelectorPolicy;

}

/**
 * Converts an object of type 'TargetSpecForProviderTargetGroupArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecForProviderTargetGroupArnSelector(obj: TargetSpecForProviderTargetGroupArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TargetSpecForProviderTargetGroupArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TargetSpecProviderConfigRefPolicy
 */
export interface TargetSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TargetSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: TargetSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TargetSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: TargetSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TargetSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecProviderConfigRefPolicy(obj: TargetSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema TargetSpecPublishConnectionDetailsToConfigRef
 */
export interface TargetSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TargetSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TargetSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: TargetSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'TargetSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecPublishConnectionDetailsToConfigRef(obj: TargetSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TargetSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema TargetSpecPublishConnectionDetailsToMetadata
 */
export interface TargetSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema TargetSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema TargetSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema TargetSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'TargetSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecPublishConnectionDetailsToMetadata(obj: TargetSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TargetSpecForProviderLambdaArnRefPolicy
 */
export interface TargetSpecForProviderLambdaArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TargetSpecForProviderLambdaArnRefPolicy#resolution
   */
  readonly resolution?: TargetSpecForProviderLambdaArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TargetSpecForProviderLambdaArnRefPolicy#resolve
   */
  readonly resolve?: TargetSpecForProviderLambdaArnRefPolicyResolve;

}

/**
 * Converts an object of type 'TargetSpecForProviderLambdaArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecForProviderLambdaArnRefPolicy(obj: TargetSpecForProviderLambdaArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TargetSpecForProviderLambdaArnSelectorPolicy
 */
export interface TargetSpecForProviderLambdaArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TargetSpecForProviderLambdaArnSelectorPolicy#resolution
   */
  readonly resolution?: TargetSpecForProviderLambdaArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TargetSpecForProviderLambdaArnSelectorPolicy#resolve
   */
  readonly resolve?: TargetSpecForProviderLambdaArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TargetSpecForProviderLambdaArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecForProviderLambdaArnSelectorPolicy(obj: TargetSpecForProviderLambdaArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TargetSpecForProviderTargetGroupArnRefPolicy
 */
export interface TargetSpecForProviderTargetGroupArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TargetSpecForProviderTargetGroupArnRefPolicy#resolution
   */
  readonly resolution?: TargetSpecForProviderTargetGroupArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TargetSpecForProviderTargetGroupArnRefPolicy#resolve
   */
  readonly resolve?: TargetSpecForProviderTargetGroupArnRefPolicyResolve;

}

/**
 * Converts an object of type 'TargetSpecForProviderTargetGroupArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecForProviderTargetGroupArnRefPolicy(obj: TargetSpecForProviderTargetGroupArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TargetSpecForProviderTargetGroupArnSelectorPolicy
 */
export interface TargetSpecForProviderTargetGroupArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TargetSpecForProviderTargetGroupArnSelectorPolicy#resolution
   */
  readonly resolution?: TargetSpecForProviderTargetGroupArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TargetSpecForProviderTargetGroupArnSelectorPolicy#resolve
   */
  readonly resolve?: TargetSpecForProviderTargetGroupArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TargetSpecForProviderTargetGroupArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecForProviderTargetGroupArnSelectorPolicy(obj: TargetSpecForProviderTargetGroupArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TargetSpecProviderConfigRefPolicyResolution
 */
export enum TargetSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TargetSpecProviderConfigRefPolicyResolve
 */
export enum TargetSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema TargetSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface TargetSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TargetSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: TargetSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TargetSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: TargetSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TargetSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecPublishConnectionDetailsToConfigRefPolicy(obj: TargetSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TargetSpecForProviderLambdaArnRefPolicyResolution
 */
export enum TargetSpecForProviderLambdaArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TargetSpecForProviderLambdaArnRefPolicyResolve
 */
export enum TargetSpecForProviderLambdaArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TargetSpecForProviderLambdaArnSelectorPolicyResolution
 */
export enum TargetSpecForProviderLambdaArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TargetSpecForProviderLambdaArnSelectorPolicyResolve
 */
export enum TargetSpecForProviderLambdaArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TargetSpecForProviderTargetGroupArnRefPolicyResolution
 */
export enum TargetSpecForProviderTargetGroupArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TargetSpecForProviderTargetGroupArnRefPolicyResolve
 */
export enum TargetSpecForProviderTargetGroupArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TargetSpecForProviderTargetGroupArnSelectorPolicyResolution
 */
export enum TargetSpecForProviderTargetGroupArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TargetSpecForProviderTargetGroupArnSelectorPolicyResolve
 */
export enum TargetSpecForProviderTargetGroupArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TargetSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum TargetSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TargetSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum TargetSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * TargetGroup is the Schema for the TargetGroups API
 *
 * @schema TargetGroup
 */
export class TargetGroup extends ApiObject {
  /**
   * Returns the apiVersion and kind for "TargetGroup"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'elbv2.aws.crossplane.io/v1alpha1',
    kind: 'TargetGroup',
  }

  /**
   * Renders a Kubernetes manifest for "TargetGroup".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: TargetGroupProps): any {
    return {
      ...TargetGroup.GVK,
      ...toJson_TargetGroupProps(props),
    };
  }

  /**
   * Defines a "TargetGroup" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: TargetGroupProps) {
    super(scope, id, {
      ...TargetGroup.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...TargetGroup.GVK,
      ...toJson_TargetGroupProps(resolved),
    };
  }
}

/**
 * TargetGroup is the Schema for the TargetGroups API
 *
 * @schema TargetGroup
 */
export interface TargetGroupProps {
  /**
   * @schema TargetGroup#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * TargetGroupSpec defines the desired state of TargetGroup
   *
   * @schema TargetGroup#spec
   */
  readonly spec: TargetGroupSpec;

}

/**
 * Converts an object of type 'TargetGroupProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetGroupProps(obj: TargetGroupProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_TargetGroupSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TargetGroupSpec defines the desired state of TargetGroup
 *
 * @schema TargetGroupSpec
 */
export interface TargetGroupSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema TargetGroupSpec#deletionPolicy
   */
  readonly deletionPolicy?: TargetGroupSpecDeletionPolicy;

  /**
   * TargetGroupParameters defines the desired state of TargetGroup
   *
   * @schema TargetGroupSpec#forProvider
   */
  readonly forProvider: TargetGroupSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema TargetGroupSpec#managementPolicies
   */
  readonly managementPolicies?: TargetGroupSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema TargetGroupSpec#providerConfigRef
   */
  readonly providerConfigRef?: TargetGroupSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema TargetGroupSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: TargetGroupSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema TargetGroupSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: TargetGroupSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'TargetGroupSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetGroupSpec(obj: TargetGroupSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_TargetGroupSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_TargetGroupSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_TargetGroupSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_TargetGroupSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema TargetGroupSpecDeletionPolicy
 */
export enum TargetGroupSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * TargetGroupParameters defines the desired state of TargetGroup
 *
 * @schema TargetGroupSpecForProvider
 */
export interface TargetGroupSpecForProvider {
  /**
   * Indicates whether health checks are enabled. If the target type is lambda, health checks are disabled by default but can be enabled. If the target type is instance, ip, or alb, health checks are always enabled and cannot be disabled.
   *
   * @schema TargetGroupSpecForProvider#healthCheckEnabled
   */
  readonly healthCheckEnabled?: boolean;

  /**
   * The approximate amount of time, in seconds, between health checks of an individual target. The range is 5-300. If the target group protocol is TCP, TLS, UDP, TCP_UDP, HTTP or HTTPS, the default is 30 seconds. If the target group protocol is GENEVE, the default is 10 seconds. If the target type is lambda, the default is 35 seconds.
   *
   * @schema TargetGroupSpecForProvider#healthCheckIntervalSeconds
   */
  readonly healthCheckIntervalSeconds?: number;

  /**
   * [HTTP/HTTPS health checks] The destination for health checks on the targets.
   * [HTTP1 or HTTP2 protocol version] The ping path. The default is /.
   * [GRPC protocol version] The path of a custom health check method with the format /package.service/method. The default is /Amazon Web Services.ALB/healthcheck.
   *
   * @schema TargetGroupSpecForProvider#healthCheckPath
   */
  readonly healthCheckPath?: string;

  /**
   * The port the load balancer uses when performing health checks on targets. If the protocol is HTTP, HTTPS, TCP, TLS, UDP, or TCP_UDP, the default is traffic-port, which is the port on which each target receives traffic from the load balancer. If the protocol is GENEVE, the default is port 80.
   *
   * @schema TargetGroupSpecForProvider#healthCheckPort
   */
  readonly healthCheckPort?: string;

  /**
   * The protocol the load balancer uses when performing health checks on targets. For Application Load Balancers, the default is HTTP. For Network Load Balancers and Gateway Load Balancers, the default is TCP. The TCP protocol is not supported for health checks if the protocol of the target group is HTTP or HTTPS. The GENEVE, TLS, UDP, and TCP_UDP protocols are not supported for health checks.
   *
   * @schema TargetGroupSpecForProvider#healthCheckProtocol
   */
  readonly healthCheckProtocol?: string;

  /**
   * The amount of time, in seconds, during which no response from a target means a failed health check. The range is 2â€“120 seconds. For target groups with a protocol of HTTP, the default is 6 seconds. For target groups with a protocol of TCP, TLS or HTTPS, the default is 10 seconds. For target groups with a protocol of GENEVE, the default is 5 seconds. If the target type is lambda, the default is 30 seconds.
   *
   * @schema TargetGroupSpecForProvider#healthCheckTimeoutSeconds
   */
  readonly healthCheckTimeoutSeconds?: number;

  /**
   * The number of consecutive health check successes required before considering a target healthy. The range is 2-10. If the target group protocol is TCP, TCP_UDP, UDP, TLS, HTTP or HTTPS, the default is 5. For target groups with a protocol of GENEVE, the default is 5. If the target type is lambda, the default is 5.
   *
   * @schema TargetGroupSpecForProvider#healthyThresholdCount
   */
  readonly healthyThresholdCount?: number;

  /**
   * The type of IP address used for this target group. The possible values are ipv4 and ipv6. This is an optional parameter. If not specified, the IP address type defaults to ipv4.
   *
   * @schema TargetGroupSpecForProvider#ipAddressType
   */
  readonly ipAddressType?: string;

  /**
   * [HTTP/HTTPS health checks] The HTTP or gRPC codes to use when checking for a successful response from a target. For target groups with a protocol of TCP, TCP_UDP, UDP or TLS the range is 200-599. For target groups with a protocol of HTTP or HTTPS, the range is 200-499. For target groups with a protocol of GENEVE, the range is 200-399.
   *
   * @schema TargetGroupSpecForProvider#matcher
   */
  readonly matcher?: TargetGroupSpecForProviderMatcher;

  /**
   * The name of the target group.
   * This name must be unique per region per account, can have a maximum of 32 characters, must contain only alphanumeric characters or hyphens, and must not begin or end with a hyphen.
   *
   * @schema TargetGroupSpecForProvider#name
   */
  readonly name: string;

  /**
   * The port on which the targets receive traffic. This port is used unless you specify a port override when registering the target. If the target is a Lambda function, this parameter does not apply. If the protocol is GENEVE, the supported port is 6081.
   *
   * @schema TargetGroupSpecForProvider#port
   */
  readonly port?: number;

  /**
   * The protocol to use for routing traffic to the targets. For Application Load Balancers, the supported protocols are HTTP and HTTPS. For Network Load Balancers, the supported protocols are TCP, TLS, UDP, or TCP_UDP. For Gateway Load Balancers, the supported protocol is GENEVE. A TCP_UDP listener must be associated with a TCP_UDP target group. If the target is a Lambda function, this parameter does not apply.
   *
   * @schema TargetGroupSpecForProvider#protocol
   */
  readonly protocol?: string;

  /**
   * [HTTP/HTTPS protocol] The protocol version. Specify GRPC to send requests to targets using gRPC. Specify HTTP2 to send requests to targets using HTTP/2. The default is HTTP1, which sends requests to targets using HTTP/1.1.
   *
   * @schema TargetGroupSpecForProvider#protocolVersion
   */
  readonly protocolVersion?: string;

  /**
   * Region is which region the TargetGroup will be created.
   *
   * @schema TargetGroupSpecForProvider#region
   */
  readonly region: string;

  /**
   * The tags to assign to the target group.
   *
   * @schema TargetGroupSpecForProvider#tags
   */
  readonly tags?: TargetGroupSpecForProviderTags[];

  /**
   * The type of target that you must specify when registering targets with this target group. You can't specify targets for a target group using more than one target type.
   * * instance - Register targets by instance ID. This is the default value.
   * * ip - Register targets by IP address. You can specify IP addresses from the subnets of the virtual private cloud (VPC) for the target group, the RFC 1918 range (10.0.0.0/8, 172.16.0.0/12, and 192.168.0.0/16), and the RFC 6598 range (100.64.0.0/10). You can't specify publicly routable IP addresses.
   * * lambda - Register a single Lambda function as a target.
   * * alb - Register a single Application Load Balancer as a target.
   *
   * @schema TargetGroupSpecForProvider#targetType
   */
  readonly targetType?: string;

  /**
   * The number of consecutive health check failures required before considering a target unhealthy. The range is 2-10. If the target group protocol is TCP, TCP_UDP, UDP, TLS, HTTP or HTTPS, the default is 2. For target groups with a protocol of GENEVE, the default is 2. If the target type is lambda, the default is 5.
   *
   * @schema TargetGroupSpecForProvider#unhealthyThresholdCount
   */
  readonly unhealthyThresholdCount?: number;

  /**
   * The identifier of the virtual private cloud (VPC). If the target is a Lambda function, this parameter does not apply. Otherwise, this parameter is required.
   *
   * @schema TargetGroupSpecForProvider#vpcID
   */
  readonly vpcId?: string;

  /**
   * Reference to VPC for VPCID
   *
   * @schema TargetGroupSpecForProvider#vpcIdRef
   */
  readonly vpcIdRef?: TargetGroupSpecForProviderVpcIdRef;

  /**
   * Selector for references to VPC for VPCID
   *
   * @schema TargetGroupSpecForProvider#vpcIdSelector
   */
  readonly vpcIdSelector?: TargetGroupSpecForProviderVpcIdSelector;

}

/**
 * Converts an object of type 'TargetGroupSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetGroupSpecForProvider(obj: TargetGroupSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'healthCheckEnabled': obj.healthCheckEnabled,
    'healthCheckIntervalSeconds': obj.healthCheckIntervalSeconds,
    'healthCheckPath': obj.healthCheckPath,
    'healthCheckPort': obj.healthCheckPort,
    'healthCheckProtocol': obj.healthCheckProtocol,
    'healthCheckTimeoutSeconds': obj.healthCheckTimeoutSeconds,
    'healthyThresholdCount': obj.healthyThresholdCount,
    'ipAddressType': obj.ipAddressType,
    'matcher': toJson_TargetGroupSpecForProviderMatcher(obj.matcher),
    'name': obj.name,
    'port': obj.port,
    'protocol': obj.protocol,
    'protocolVersion': obj.protocolVersion,
    'region': obj.region,
    'tags': obj.tags?.map(y => toJson_TargetGroupSpecForProviderTags(y)),
    'targetType': obj.targetType,
    'unhealthyThresholdCount': obj.unhealthyThresholdCount,
    'vpcID': obj.vpcId,
    'vpcIdRef': toJson_TargetGroupSpecForProviderVpcIdRef(obj.vpcIdRef),
    'vpcIdSelector': toJson_TargetGroupSpecForProviderVpcIdSelector(obj.vpcIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema TargetGroupSpecManagementPolicies
 */
export enum TargetGroupSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema TargetGroupSpecProviderConfigRef
 */
export interface TargetGroupSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TargetGroupSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TargetGroupSpecProviderConfigRef#policy
   */
  readonly policy?: TargetGroupSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'TargetGroupSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetGroupSpecProviderConfigRef(obj: TargetGroupSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TargetGroupSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema TargetGroupSpecPublishConnectionDetailsTo
 */
export interface TargetGroupSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema TargetGroupSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: TargetGroupSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema TargetGroupSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: TargetGroupSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema TargetGroupSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'TargetGroupSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetGroupSpecPublishConnectionDetailsTo(obj: TargetGroupSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_TargetGroupSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_TargetGroupSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema TargetGroupSpecWriteConnectionSecretToRef
 */
export interface TargetGroupSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema TargetGroupSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema TargetGroupSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'TargetGroupSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetGroupSpecWriteConnectionSecretToRef(obj: TargetGroupSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * [HTTP/HTTPS health checks] The HTTP or gRPC codes to use when checking for a successful response from a target. For target groups with a protocol of TCP, TCP_UDP, UDP or TLS the range is 200-599. For target groups with a protocol of HTTP or HTTPS, the range is 200-499. For target groups with a protocol of GENEVE, the range is 200-399.
 *
 * @schema TargetGroupSpecForProviderMatcher
 */
export interface TargetGroupSpecForProviderMatcher {
  /**
   * @schema TargetGroupSpecForProviderMatcher#grpcCode
   */
  readonly grpcCode?: string;

  /**
   * @schema TargetGroupSpecForProviderMatcher#httpCode
   */
  readonly httpCode?: string;

}

/**
 * Converts an object of type 'TargetGroupSpecForProviderMatcher' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetGroupSpecForProviderMatcher(obj: TargetGroupSpecForProviderMatcher | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'grpcCode': obj.grpcCode,
    'httpCode': obj.httpCode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TargetGroupSpecForProviderTags
 */
export interface TargetGroupSpecForProviderTags {
  /**
   * @schema TargetGroupSpecForProviderTags#key
   */
  readonly key?: string;

  /**
   * @schema TargetGroupSpecForProviderTags#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'TargetGroupSpecForProviderTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetGroupSpecForProviderTags(obj: TargetGroupSpecForProviderTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to VPC for VPCID
 *
 * @schema TargetGroupSpecForProviderVpcIdRef
 */
export interface TargetGroupSpecForProviderVpcIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema TargetGroupSpecForProviderVpcIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TargetGroupSpecForProviderVpcIdRef#policy
   */
  readonly policy?: TargetGroupSpecForProviderVpcIdRefPolicy;

}

/**
 * Converts an object of type 'TargetGroupSpecForProviderVpcIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetGroupSpecForProviderVpcIdRef(obj: TargetGroupSpecForProviderVpcIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TargetGroupSpecForProviderVpcIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for references to VPC for VPCID
 *
 * @schema TargetGroupSpecForProviderVpcIdSelector
 */
export interface TargetGroupSpecForProviderVpcIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TargetGroupSpecForProviderVpcIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TargetGroupSpecForProviderVpcIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TargetGroupSpecForProviderVpcIdSelector#policy
   */
  readonly policy?: TargetGroupSpecForProviderVpcIdSelectorPolicy;

}

/**
 * Converts an object of type 'TargetGroupSpecForProviderVpcIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetGroupSpecForProviderVpcIdSelector(obj: TargetGroupSpecForProviderVpcIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TargetGroupSpecForProviderVpcIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TargetGroupSpecProviderConfigRefPolicy
 */
export interface TargetGroupSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TargetGroupSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: TargetGroupSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TargetGroupSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: TargetGroupSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TargetGroupSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetGroupSpecProviderConfigRefPolicy(obj: TargetGroupSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema TargetGroupSpecPublishConnectionDetailsToConfigRef
 */
export interface TargetGroupSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TargetGroupSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TargetGroupSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: TargetGroupSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'TargetGroupSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetGroupSpecPublishConnectionDetailsToConfigRef(obj: TargetGroupSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TargetGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema TargetGroupSpecPublishConnectionDetailsToMetadata
 */
export interface TargetGroupSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema TargetGroupSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema TargetGroupSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema TargetGroupSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'TargetGroupSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetGroupSpecPublishConnectionDetailsToMetadata(obj: TargetGroupSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TargetGroupSpecForProviderVpcIdRefPolicy
 */
export interface TargetGroupSpecForProviderVpcIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TargetGroupSpecForProviderVpcIdRefPolicy#resolution
   */
  readonly resolution?: TargetGroupSpecForProviderVpcIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TargetGroupSpecForProviderVpcIdRefPolicy#resolve
   */
  readonly resolve?: TargetGroupSpecForProviderVpcIdRefPolicyResolve;

}

/**
 * Converts an object of type 'TargetGroupSpecForProviderVpcIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetGroupSpecForProviderVpcIdRefPolicy(obj: TargetGroupSpecForProviderVpcIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TargetGroupSpecForProviderVpcIdSelectorPolicy
 */
export interface TargetGroupSpecForProviderVpcIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TargetGroupSpecForProviderVpcIdSelectorPolicy#resolution
   */
  readonly resolution?: TargetGroupSpecForProviderVpcIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TargetGroupSpecForProviderVpcIdSelectorPolicy#resolve
   */
  readonly resolve?: TargetGroupSpecForProviderVpcIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TargetGroupSpecForProviderVpcIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetGroupSpecForProviderVpcIdSelectorPolicy(obj: TargetGroupSpecForProviderVpcIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TargetGroupSpecProviderConfigRefPolicyResolution
 */
export enum TargetGroupSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TargetGroupSpecProviderConfigRefPolicyResolve
 */
export enum TargetGroupSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema TargetGroupSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface TargetGroupSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TargetGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: TargetGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TargetGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: TargetGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TargetGroupSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj: TargetGroupSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TargetGroupSpecForProviderVpcIdRefPolicyResolution
 */
export enum TargetGroupSpecForProviderVpcIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TargetGroupSpecForProviderVpcIdRefPolicyResolve
 */
export enum TargetGroupSpecForProviderVpcIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TargetGroupSpecForProviderVpcIdSelectorPolicyResolution
 */
export enum TargetGroupSpecForProviderVpcIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TargetGroupSpecForProviderVpcIdSelectorPolicyResolve
 */
export enum TargetGroupSpecForProviderVpcIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TargetGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum TargetGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TargetGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum TargetGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

