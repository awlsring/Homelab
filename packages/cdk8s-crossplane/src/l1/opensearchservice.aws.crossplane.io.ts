// @ts-nocheck
// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Domain is the Schema for the Domains API
 *
 * @schema Domain
 */
export class Domain extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Domain"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'opensearchservice.aws.crossplane.io/v1alpha1',
    kind: 'Domain',
  }

  /**
   * Renders a Kubernetes manifest for "Domain".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DomainProps): any {
    return {
      ...Domain.GVK,
      ...toJson_DomainProps(props),
    };
  }

  /**
   * Defines a "Domain" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DomainProps) {
    super(scope, id, {
      ...Domain.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Domain.GVK,
      ...toJson_DomainProps(resolved),
    };
  }
}

/**
 * Domain is the Schema for the Domains API
 *
 * @schema Domain
 */
export interface DomainProps {
  /**
   * @schema Domain#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DomainSpec defines the desired state of Domain
   *
   * @schema Domain#spec
   */
  readonly spec: DomainSpec;

}

/**
 * Converts an object of type 'DomainProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainProps(obj: DomainProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DomainSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DomainSpec defines the desired state of Domain
 *
 * @schema DomainSpec
 */
export interface DomainSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DomainSpec#deletionPolicy
   */
  readonly deletionPolicy?: DomainSpecDeletionPolicy;

  /**
   * DomainParameters defines the desired state of Domain
   *
   * @schema DomainSpec#forProvider
   */
  readonly forProvider: DomainSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema DomainSpec#managementPolicies
   */
  readonly managementPolicies?: DomainSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DomainSpec#providerConfigRef
   */
  readonly providerConfigRef?: DomainSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DomainSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DomainSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DomainSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DomainSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DomainSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpec(obj: DomainSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DomainSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_DomainSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_DomainSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DomainSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DomainSpecDeletionPolicy
 */
export enum DomainSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * DomainParameters defines the desired state of Domain
 *
 * @schema DomainSpecForProvider
 */
export interface DomainSpecForProvider {
  /**
   * Identity and Access Management (IAM) policy document specifying the access policies for the new domain.
   *
   * @schema DomainSpecForProvider#accessPolicies
   */
  readonly accessPolicies?: string;

  /**
   * Key-value pairs to specify advanced configuration options. The following key-value pairs are supported:
   * * "rest.action.multi.allow_explicit_index": "true" | "false" - Note the use of a string rather than a boolean. Specifies whether explicit references to indexes are allowed inside the body of HTTP requests. If you want to configure access policies for domain sub-resources, such as specific indexes and domain APIs, you must disable this property. Default is true.
   * * "indices.fielddata.cache.size": "80" - Note the use of a string rather than a boolean. Specifies the percentage of heap space allocated to field data. Default is unbounded.
   * * "indices.query.bool.max_clause_count": "1024" - Note the use of a string rather than a boolean. Specifies the maximum number of clauses allowed in a Lucene boolean query. Default is 1,024. Queries with more than the permitted number of clauses result in a TooManyClauses error.
   * * "override_main_response_version": "true" | "false" - Note the use of a string rather than a boolean. Specifies whether the domain reports its version as 7.10 to allow Elasticsearch OSS clients and plugins to continue working with it. Default is false when creating a domain and true when upgrading a domain.
   * For more information, see Advanced cluster parameters (https://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html#createdomain-configure-advanced-options).
   *
   * @default true.
   * @schema DomainSpecForProvider#advancedOptions
   */
  readonly advancedOptions?: { [key: string]: string };

  /**
   * Options for fine-grained access control.
   *
   * @schema DomainSpecForProvider#advancedSecurityOptions
   */
  readonly advancedSecurityOptions?: DomainSpecForProviderAdvancedSecurityOptions;

  /**
   * Options for Auto-Tune.
   *
   * @schema DomainSpecForProvider#autoTuneOptions
   */
  readonly autoTuneOptions?: DomainSpecForProviderAutoTuneOptions;

  /**
   * Container for the cluster configuration of a domain.
   *
   * @schema DomainSpecForProvider#clusterConfig
   */
  readonly clusterConfig?: DomainSpecForProviderClusterConfig;

  /**
   * Key-value pairs to configure Amazon Cognito authentication. For more information, see Configuring Amazon Cognito authentication for OpenSearch Dashboards (https://docs.aws.amazon.com/opensearch-service/latest/developerguide/cognito-auth.html).
   *
   * @schema DomainSpecForProvider#cognitoOptions
   */
  readonly cognitoOptions?: DomainSpecForProviderCognitoOptions;

  /**
   * Additional options for the domain endpoint, such as whether to require HTTPS for all traffic.
   *
   * @schema DomainSpecForProvider#domainEndpointOptions
   */
  readonly domainEndpointOptions?: DomainSpecForProviderDomainEndpointOptions;

  /**
   * Container for the parameters required to enable EBS-based storage for an OpenSearch Service domain.
   *
   * @schema DomainSpecForProvider#ebsOptions
   */
  readonly ebsOptions?: DomainSpecForProviderEbsOptions;

  /**
   * Options for encryption of data at rest.
   *
   * @schema DomainSpecForProvider#encryptionAtRestOptions
   */
  readonly encryptionAtRestOptions?: DomainSpecForProviderEncryptionAtRestOptions;

  /**
   * String of format Elasticsearch_X.Y or OpenSearch_X.Y to specify the engine version for the OpenSearch Service domain. For example, OpenSearch_1.0 or Elasticsearch_7.9. For more information, see Creating and managing Amazon OpenSearch Service domains (https://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html#createdomains).
   *
   * @schema DomainSpecForProvider#engineVersion
   */
  readonly engineVersion?: string;

  /**
   * Key-value pairs to configure log publishing.
   *
   * @schema DomainSpecForProvider#logPublishingOptions
   */
  readonly logPublishingOptions?: { [key: string]: DomainSpecForProviderLogPublishingOptions };

  /**
   * Enables node-to-node encryption.
   *
   * @schema DomainSpecForProvider#nodeToNodeEncryptionOptions
   */
  readonly nodeToNodeEncryptionOptions?: DomainSpecForProviderNodeToNodeEncryptionOptions;

  /**
   * Specifies a daily 10-hour time block during which OpenSearch Service can perform configuration changes on the domain, including service software updates and Auto-Tune enhancements that require a blue/green deployment. If no options are specified, the default start time of 10:00 P.M. local time (for the Region that the domain is created in) is used.
   *
   * @schema DomainSpecForProvider#offPeakWindowOptions
   */
  readonly offPeakWindowOptions?: DomainSpecForProviderOffPeakWindowOptions;

  /**
   * Region is which region the Domain will be created.
   *
   * @schema DomainSpecForProvider#region
   */
  readonly region: string;

  /**
   * @schema DomainSpecForProvider#snapshotOptions
   */
  readonly snapshotOptions?: DomainSpecForProviderSnapshotOptions;

  /**
   * Software update options for the domain.
   *
   * @schema DomainSpecForProvider#softwareUpdateOptions
   */
  readonly softwareUpdateOptions?: DomainSpecForProviderSoftwareUpdateOptions;

  /**
   * List of tags to add to the domain upon creation.
   *
   * @schema DomainSpecForProvider#tags
   */
  readonly tags?: DomainSpecForProviderTags[];

  /**
   * Options to specify the subnets and security groups for the VPC endpoint. For more information, see Launching your Amazon OpenSearch Service domains using a VPC (http://docs.aws.amazon.com/opensearch-service/latest/developerguide/vpc.html).
   *
   * @schema DomainSpecForProvider#vpcOptions
   */
  readonly vpcOptions?: DomainSpecForProviderVpcOptions;

}

/**
 * Converts an object of type 'DomainSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProvider(obj: DomainSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessPolicies': obj.accessPolicies,
    'advancedOptions': ((obj.advancedOptions) === undefined) ? undefined : (Object.entries(obj.advancedOptions).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'advancedSecurityOptions': toJson_DomainSpecForProviderAdvancedSecurityOptions(obj.advancedSecurityOptions),
    'autoTuneOptions': toJson_DomainSpecForProviderAutoTuneOptions(obj.autoTuneOptions),
    'clusterConfig': toJson_DomainSpecForProviderClusterConfig(obj.clusterConfig),
    'cognitoOptions': toJson_DomainSpecForProviderCognitoOptions(obj.cognitoOptions),
    'domainEndpointOptions': toJson_DomainSpecForProviderDomainEndpointOptions(obj.domainEndpointOptions),
    'ebsOptions': toJson_DomainSpecForProviderEbsOptions(obj.ebsOptions),
    'encryptionAtRestOptions': toJson_DomainSpecForProviderEncryptionAtRestOptions(obj.encryptionAtRestOptions),
    'engineVersion': obj.engineVersion,
    'logPublishingOptions': ((obj.logPublishingOptions) === undefined) ? undefined : (Object.entries(obj.logPublishingOptions).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: toJson_DomainSpecForProviderLogPublishingOptions(i[1]) }), {})),
    'nodeToNodeEncryptionOptions': toJson_DomainSpecForProviderNodeToNodeEncryptionOptions(obj.nodeToNodeEncryptionOptions),
    'offPeakWindowOptions': toJson_DomainSpecForProviderOffPeakWindowOptions(obj.offPeakWindowOptions),
    'region': obj.region,
    'snapshotOptions': toJson_DomainSpecForProviderSnapshotOptions(obj.snapshotOptions),
    'softwareUpdateOptions': toJson_DomainSpecForProviderSoftwareUpdateOptions(obj.softwareUpdateOptions),
    'tags': obj.tags?.map(y => toJson_DomainSpecForProviderTags(y)),
    'vpcOptions': toJson_DomainSpecForProviderVpcOptions(obj.vpcOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema DomainSpecManagementPolicies
 */
export enum DomainSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DomainSpecProviderConfigRef
 */
export interface DomainSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DomainSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DomainSpecProviderConfigRef#policy
   */
  readonly policy?: DomainSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DomainSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecProviderConfigRef(obj: DomainSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DomainSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DomainSpecPublishConnectionDetailsTo
 */
export interface DomainSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DomainSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DomainSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DomainSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DomainSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DomainSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DomainSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecPublishConnectionDetailsTo(obj: DomainSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DomainSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DomainSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DomainSpecWriteConnectionSecretToRef
 */
export interface DomainSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DomainSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DomainSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DomainSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecWriteConnectionSecretToRef(obj: DomainSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Options for fine-grained access control.
 *
 * @schema DomainSpecForProviderAdvancedSecurityOptions
 */
export interface DomainSpecForProviderAdvancedSecurityOptions {
  /**
   * @schema DomainSpecForProviderAdvancedSecurityOptions#anonymousAuthEnabled
   */
  readonly anonymousAuthEnabled?: boolean;

  /**
   * @schema DomainSpecForProviderAdvancedSecurityOptions#enabled
   */
  readonly enabled?: boolean;

  /**
   * @schema DomainSpecForProviderAdvancedSecurityOptions#internalUserDatabaseEnabled
   */
  readonly internalUserDatabaseEnabled?: boolean;

  /**
   * Credentials for the master user for a domain.
   *
   * @schema DomainSpecForProviderAdvancedSecurityOptions#masterUserOptions
   */
  readonly masterUserOptions?: DomainSpecForProviderAdvancedSecurityOptionsMasterUserOptions;

  /**
   * The SAML authentication configuration for an Amazon OpenSearch Service domain.
   *
   * @schema DomainSpecForProviderAdvancedSecurityOptions#sAMLOptions
   */
  readonly sAmlOptions?: DomainSpecForProviderAdvancedSecurityOptionsSAmlOptions;

}

/**
 * Converts an object of type 'DomainSpecForProviderAdvancedSecurityOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderAdvancedSecurityOptions(obj: DomainSpecForProviderAdvancedSecurityOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'anonymousAuthEnabled': obj.anonymousAuthEnabled,
    'enabled': obj.enabled,
    'internalUserDatabaseEnabled': obj.internalUserDatabaseEnabled,
    'masterUserOptions': toJson_DomainSpecForProviderAdvancedSecurityOptionsMasterUserOptions(obj.masterUserOptions),
    'sAMLOptions': toJson_DomainSpecForProviderAdvancedSecurityOptionsSAmlOptions(obj.sAmlOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Options for Auto-Tune.
 *
 * @schema DomainSpecForProviderAutoTuneOptions
 */
export interface DomainSpecForProviderAutoTuneOptions {
  /**
   * The Auto-Tune desired state. Valid values are ENABLED and DISABLED.
   *
   * @schema DomainSpecForProviderAutoTuneOptions#desiredState
   */
  readonly desiredState?: string;

  /**
   * @schema DomainSpecForProviderAutoTuneOptions#maintenanceSchedules
   */
  readonly maintenanceSchedules?: DomainSpecForProviderAutoTuneOptionsMaintenanceSchedules[];

  /**
   * @schema DomainSpecForProviderAutoTuneOptions#useOffPeakWindow
   */
  readonly useOffPeakWindow?: boolean;

}

/**
 * Converts an object of type 'DomainSpecForProviderAutoTuneOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderAutoTuneOptions(obj: DomainSpecForProviderAutoTuneOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'desiredState': obj.desiredState,
    'maintenanceSchedules': obj.maintenanceSchedules?.map(y => toJson_DomainSpecForProviderAutoTuneOptionsMaintenanceSchedules(y)),
    'useOffPeakWindow': obj.useOffPeakWindow,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Container for the cluster configuration of a domain.
 *
 * @schema DomainSpecForProviderClusterConfig
 */
export interface DomainSpecForProviderClusterConfig {
  /**
   * Container for the parameters required to enable cold storage for an OpenSearch Service domain. For more information, see Cold storage for Amazon OpenSearch Service (https://docs.aws.amazon.com/opensearch-service/latest/developerguide/cold-storage.html).
   *
   * @schema DomainSpecForProviderClusterConfig#coldStorageOptions
   */
  readonly coldStorageOptions?: DomainSpecForProviderClusterConfigColdStorageOptions;

  /**
   * @schema DomainSpecForProviderClusterConfig#dedicatedMasterCount
   */
  readonly dedicatedMasterCount?: number;

  /**
   * @schema DomainSpecForProviderClusterConfig#dedicatedMasterEnabled
   */
  readonly dedicatedMasterEnabled?: boolean;

  /**
   * @schema DomainSpecForProviderClusterConfig#dedicatedMasterType
   */
  readonly dedicatedMasterType?: string;

  /**
   * @schema DomainSpecForProviderClusterConfig#instanceCount
   */
  readonly instanceCount?: number;

  /**
   * @schema DomainSpecForProviderClusterConfig#instanceType
   */
  readonly instanceType?: string;

  /**
   * @schema DomainSpecForProviderClusterConfig#multiAZWithStandbyEnabled
   */
  readonly multiAzWithStandbyEnabled?: boolean;

  /**
   * @schema DomainSpecForProviderClusterConfig#warmCount
   */
  readonly warmCount?: number;

  /**
   * @schema DomainSpecForProviderClusterConfig#warmEnabled
   */
  readonly warmEnabled?: boolean;

  /**
   * @schema DomainSpecForProviderClusterConfig#warmType
   */
  readonly warmType?: string;

  /**
   * The zone awareness configuration for an Amazon OpenSearch Service domain.
   *
   * @schema DomainSpecForProviderClusterConfig#zoneAwarenessConfig
   */
  readonly zoneAwarenessConfig?: DomainSpecForProviderClusterConfigZoneAwarenessConfig;

  /**
   * @schema DomainSpecForProviderClusterConfig#zoneAwarenessEnabled
   */
  readonly zoneAwarenessEnabled?: boolean;

}

/**
 * Converts an object of type 'DomainSpecForProviderClusterConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderClusterConfig(obj: DomainSpecForProviderClusterConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'coldStorageOptions': toJson_DomainSpecForProviderClusterConfigColdStorageOptions(obj.coldStorageOptions),
    'dedicatedMasterCount': obj.dedicatedMasterCount,
    'dedicatedMasterEnabled': obj.dedicatedMasterEnabled,
    'dedicatedMasterType': obj.dedicatedMasterType,
    'instanceCount': obj.instanceCount,
    'instanceType': obj.instanceType,
    'multiAZWithStandbyEnabled': obj.multiAzWithStandbyEnabled,
    'warmCount': obj.warmCount,
    'warmEnabled': obj.warmEnabled,
    'warmType': obj.warmType,
    'zoneAwarenessConfig': toJson_DomainSpecForProviderClusterConfigZoneAwarenessConfig(obj.zoneAwarenessConfig),
    'zoneAwarenessEnabled': obj.zoneAwarenessEnabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Key-value pairs to configure Amazon Cognito authentication. For more information, see Configuring Amazon Cognito authentication for OpenSearch Dashboards (https://docs.aws.amazon.com/opensearch-service/latest/developerguide/cognito-auth.html).
 *
 * @schema DomainSpecForProviderCognitoOptions
 */
export interface DomainSpecForProviderCognitoOptions {
  /**
   * @schema DomainSpecForProviderCognitoOptions#enabled
   */
  readonly enabled?: boolean;

  /**
   * @schema DomainSpecForProviderCognitoOptions#identityPoolID
   */
  readonly identityPoolId?: string;

  /**
   * @schema DomainSpecForProviderCognitoOptions#roleARN
   */
  readonly roleArn?: string;

  /**
   * @schema DomainSpecForProviderCognitoOptions#userPoolID
   */
  readonly userPoolId?: string;

}

/**
 * Converts an object of type 'DomainSpecForProviderCognitoOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderCognitoOptions(obj: DomainSpecForProviderCognitoOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'identityPoolID': obj.identityPoolId,
    'roleARN': obj.roleArn,
    'userPoolID': obj.userPoolId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Additional options for the domain endpoint, such as whether to require HTTPS for all traffic.
 *
 * @schema DomainSpecForProviderDomainEndpointOptions
 */
export interface DomainSpecForProviderDomainEndpointOptions {
  /**
   * @schema DomainSpecForProviderDomainEndpointOptions#customEndpoint
   */
  readonly customEndpoint?: string;

  /**
   * The Amazon Resource Name (ARN) of the domain. See Identifiers for IAM Entities (https://docs.aws.amazon.com/IAM/latest/UserGuide/index.html) in Using AWS Identity and Access Management for more information.
   *
   * @schema DomainSpecForProviderDomainEndpointOptions#customEndpointCertificateARN
   */
  readonly customEndpointCertificateArn?: string;

  /**
   * @schema DomainSpecForProviderDomainEndpointOptions#customEndpointEnabled
   */
  readonly customEndpointEnabled?: boolean;

  /**
   * @schema DomainSpecForProviderDomainEndpointOptions#enforceHTTPS
   */
  readonly enforceHttps?: boolean;

  /**
   * @schema DomainSpecForProviderDomainEndpointOptions#tlsSecurityPolicy
   */
  readonly tlsSecurityPolicy?: string;

}

/**
 * Converts an object of type 'DomainSpecForProviderDomainEndpointOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderDomainEndpointOptions(obj: DomainSpecForProviderDomainEndpointOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customEndpoint': obj.customEndpoint,
    'customEndpointCertificateARN': obj.customEndpointCertificateArn,
    'customEndpointEnabled': obj.customEndpointEnabled,
    'enforceHTTPS': obj.enforceHttps,
    'tlsSecurityPolicy': obj.tlsSecurityPolicy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Container for the parameters required to enable EBS-based storage for an OpenSearch Service domain.
 *
 * @schema DomainSpecForProviderEbsOptions
 */
export interface DomainSpecForProviderEbsOptions {
  /**
   * @schema DomainSpecForProviderEbsOptions#ebsEnabled
   */
  readonly ebsEnabled?: boolean;

  /**
   * @schema DomainSpecForProviderEbsOptions#iops
   */
  readonly iops?: number;

  /**
   * @schema DomainSpecForProviderEbsOptions#throughput
   */
  readonly throughput?: number;

  /**
   * @schema DomainSpecForProviderEbsOptions#volumeSize
   */
  readonly volumeSize?: number;

  /**
   * The type of EBS volume that a domain uses. For more information, see Configuring EBS-based storage (https://docs.aws.amazon.com/opensearch-service/latest/developerguide/opensearch-createupdatedomains.html#opensearch-createdomain-configure-ebs).
   *
   * @schema DomainSpecForProviderEbsOptions#volumeType
   */
  readonly volumeType?: string;

}

/**
 * Converts an object of type 'DomainSpecForProviderEbsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderEbsOptions(obj: DomainSpecForProviderEbsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ebsEnabled': obj.ebsEnabled,
    'iops': obj.iops,
    'throughput': obj.throughput,
    'volumeSize': obj.volumeSize,
    'volumeType': obj.volumeType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Options for encryption of data at rest.
 *
 * @schema DomainSpecForProviderEncryptionAtRestOptions
 */
export interface DomainSpecForProviderEncryptionAtRestOptions {
  /**
   * @schema DomainSpecForProviderEncryptionAtRestOptions#enabled
   */
  readonly enabled?: boolean;

  /**
   * @schema DomainSpecForProviderEncryptionAtRestOptions#kmsKeyId
   */
  readonly kmsKeyId?: string;

  /**
   * KMSKeyIDRef is a reference to a KMS Key used to set KMSKeyID.
   *
   * @schema DomainSpecForProviderEncryptionAtRestOptions#kmsKeyIdRef
   */
  readonly kmsKeyIdRef?: DomainSpecForProviderEncryptionAtRestOptionsKmsKeyIdRef;

  /**
   * KMSKeyIDSelector selects a reference to a KMS Key used to set KMSKeyID.
   *
   * @schema DomainSpecForProviderEncryptionAtRestOptions#kmsKeyIdSelector
   */
  readonly kmsKeyIdSelector?: DomainSpecForProviderEncryptionAtRestOptionsKmsKeyIdSelector;

}

/**
 * Converts an object of type 'DomainSpecForProviderEncryptionAtRestOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderEncryptionAtRestOptions(obj: DomainSpecForProviderEncryptionAtRestOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'kmsKeyId': obj.kmsKeyId,
    'kmsKeyIdRef': toJson_DomainSpecForProviderEncryptionAtRestOptionsKmsKeyIdRef(obj.kmsKeyIdRef),
    'kmsKeyIdSelector': toJson_DomainSpecForProviderEncryptionAtRestOptionsKmsKeyIdSelector(obj.kmsKeyIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecForProviderLogPublishingOptions
 */
export interface DomainSpecForProviderLogPublishingOptions {
  /**
   * ARN of the Cloudwatch log group to publish logs to.
   *
   * @schema DomainSpecForProviderLogPublishingOptions#cloudWatchLogsLogGroupARN
   */
  readonly cloudWatchLogsLogGroupArn?: string;

  /**
   * @schema DomainSpecForProviderLogPublishingOptions#enabled
   */
  readonly enabled?: boolean;

}

/**
 * Converts an object of type 'DomainSpecForProviderLogPublishingOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderLogPublishingOptions(obj: DomainSpecForProviderLogPublishingOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloudWatchLogsLogGroupARN': obj.cloudWatchLogsLogGroupArn,
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Enables node-to-node encryption.
 *
 * @schema DomainSpecForProviderNodeToNodeEncryptionOptions
 */
export interface DomainSpecForProviderNodeToNodeEncryptionOptions {
  /**
   * @schema DomainSpecForProviderNodeToNodeEncryptionOptions#enabled
   */
  readonly enabled?: boolean;

}

/**
 * Converts an object of type 'DomainSpecForProviderNodeToNodeEncryptionOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderNodeToNodeEncryptionOptions(obj: DomainSpecForProviderNodeToNodeEncryptionOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies a daily 10-hour time block during which OpenSearch Service can perform configuration changes on the domain, including service software updates and Auto-Tune enhancements that require a blue/green deployment. If no options are specified, the default start time of 10:00 P.M. local time (for the Region that the domain is created in) is used.
 *
 * @schema DomainSpecForProviderOffPeakWindowOptions
 */
export interface DomainSpecForProviderOffPeakWindowOptions {
  /**
   * @schema DomainSpecForProviderOffPeakWindowOptions#enabled
   */
  readonly enabled?: boolean;

  /**
   * A custom 10-hour, low-traffic window during which OpenSearch Service can perform mandatory configuration changes on the domain. These actions can include scheduled service software updates and blue/green Auto-Tune enhancements. OpenSearch Service will schedule these actions during the window that you specify.
   * If you don't specify a window start time, it defaults to 10:00 P.M. local time.
   * For more information, see Defining off-peak maintenance windows for Amazon OpenSearch Service (https://docs.aws.amazon.com/opensearch-service/latest/developerguide/off-peak.html).
   *
   * @schema DomainSpecForProviderOffPeakWindowOptions#offPeakWindow
   */
  readonly offPeakWindow?: DomainSpecForProviderOffPeakWindowOptionsOffPeakWindow;

}

/**
 * Converts an object of type 'DomainSpecForProviderOffPeakWindowOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderOffPeakWindowOptions(obj: DomainSpecForProviderOffPeakWindowOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'offPeakWindow': toJson_DomainSpecForProviderOffPeakWindowOptionsOffPeakWindow(obj.offPeakWindow),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecForProviderSnapshotOptions
 */
export interface DomainSpecForProviderSnapshotOptions {
  /**
   * @schema DomainSpecForProviderSnapshotOptions#automatedSnapshotStartHour
   */
  readonly automatedSnapshotStartHour?: number;

}

/**
 * Converts an object of type 'DomainSpecForProviderSnapshotOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderSnapshotOptions(obj: DomainSpecForProviderSnapshotOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'automatedSnapshotStartHour': obj.automatedSnapshotStartHour,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Software update options for the domain.
 *
 * @schema DomainSpecForProviderSoftwareUpdateOptions
 */
export interface DomainSpecForProviderSoftwareUpdateOptions {
  /**
   * @schema DomainSpecForProviderSoftwareUpdateOptions#autoSoftwareUpdateEnabled
   */
  readonly autoSoftwareUpdateEnabled?: boolean;

}

/**
 * Converts an object of type 'DomainSpecForProviderSoftwareUpdateOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderSoftwareUpdateOptions(obj: DomainSpecForProviderSoftwareUpdateOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoSoftwareUpdateEnabled': obj.autoSoftwareUpdateEnabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecForProviderTags
 */
export interface DomainSpecForProviderTags {
  /**
   * A string between 1 to 128 characters that specifies the key for a tag. Tag keys must be unique for the domain to which they're attached.
   *
   * @schema DomainSpecForProviderTags#key
   */
  readonly key?: string;

  /**
   * A string between 0 to 256 characters that specifies the value for a tag. Tag values can be null and don't have to be unique in a tag set.
   *
   * @schema DomainSpecForProviderTags#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'DomainSpecForProviderTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderTags(obj: DomainSpecForProviderTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Options to specify the subnets and security groups for the VPC endpoint. For more information, see Launching your Amazon OpenSearch Service domains using a VPC (http://docs.aws.amazon.com/opensearch-service/latest/developerguide/vpc.html).
 *
 * @schema DomainSpecForProviderVpcOptions
 */
export interface DomainSpecForProviderVpcOptions {
  /**
   * SecurityGroupIDRefs is a list of references to SecurityGroups used to set the SecurityGroupIDs.
   *
   * @schema DomainSpecForProviderVpcOptions#securityGroupIdRefs
   */
  readonly securityGroupIdRefs?: DomainSpecForProviderVpcOptionsSecurityGroupIdRefs[];

  /**
   * SecurityGroupIDsSelector selects references to SecurityGroupID used to set the SecurityGroupIDs.
   *
   * @schema DomainSpecForProviderVpcOptions#securityGroupIdSelector
   */
  readonly securityGroupIdSelector?: DomainSpecForProviderVpcOptionsSecurityGroupIdSelector;

  /**
   * @schema DomainSpecForProviderVpcOptions#securityGroupIds
   */
  readonly securityGroupIds?: string[];

  /**
   * SubnetIDRefs is a list of references to Subnets used to set the SubnetIDs.
   *
   * @schema DomainSpecForProviderVpcOptions#subnetIdRefs
   */
  readonly subnetIdRefs?: DomainSpecForProviderVpcOptionsSubnetIdRefs[];

  /**
   * SubnetIDsSelector selects references to Subnets used to set the SubnetIDs.
   *
   * @schema DomainSpecForProviderVpcOptions#subnetIdSelector
   */
  readonly subnetIdSelector?: DomainSpecForProviderVpcOptionsSubnetIdSelector;

  /**
   * SecurityGroupIDs is the list of IDs for the SecurityGroups.
   *
   * @schema DomainSpecForProviderVpcOptions#subnetIds
   */
  readonly subnetIds?: string[];

}

/**
 * Converts an object of type 'DomainSpecForProviderVpcOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderVpcOptions(obj: DomainSpecForProviderVpcOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'securityGroupIdRefs': obj.securityGroupIdRefs?.map(y => toJson_DomainSpecForProviderVpcOptionsSecurityGroupIdRefs(y)),
    'securityGroupIdSelector': toJson_DomainSpecForProviderVpcOptionsSecurityGroupIdSelector(obj.securityGroupIdSelector),
    'securityGroupIds': obj.securityGroupIds?.map(y => y),
    'subnetIdRefs': obj.subnetIdRefs?.map(y => toJson_DomainSpecForProviderVpcOptionsSubnetIdRefs(y)),
    'subnetIdSelector': toJson_DomainSpecForProviderVpcOptionsSubnetIdSelector(obj.subnetIdSelector),
    'subnetIds': obj.subnetIds?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DomainSpecProviderConfigRefPolicy
 */
export interface DomainSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DomainSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DomainSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DomainSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DomainSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DomainSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecProviderConfigRefPolicy(obj: DomainSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DomainSpecPublishConnectionDetailsToConfigRef
 */
export interface DomainSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DomainSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DomainSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DomainSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DomainSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecPublishConnectionDetailsToConfigRef(obj: DomainSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DomainSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DomainSpecPublishConnectionDetailsToMetadata
 */
export interface DomainSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DomainSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DomainSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DomainSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DomainSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecPublishConnectionDetailsToMetadata(obj: DomainSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Credentials for the master user for a domain.
 *
 * @schema DomainSpecForProviderAdvancedSecurityOptionsMasterUserOptions
 */
export interface DomainSpecForProviderAdvancedSecurityOptionsMasterUserOptions {
  /**
   * The Amazon Resource Name (ARN) of the domain. See Identifiers for IAM Entities (https://docs.aws.amazon.com/IAM/latest/UserGuide/index.html) in Using AWS Identity and Access Management for more information.
   *
   * @schema DomainSpecForProviderAdvancedSecurityOptionsMasterUserOptions#masterUserARN
   */
  readonly masterUserArn?: string;

  /**
   * @schema DomainSpecForProviderAdvancedSecurityOptionsMasterUserOptions#masterUserName
   */
  readonly masterUserName?: string;

  /**
   * @schema DomainSpecForProviderAdvancedSecurityOptionsMasterUserOptions#masterUserPassword
   */
  readonly masterUserPassword?: string;

}

/**
 * Converts an object of type 'DomainSpecForProviderAdvancedSecurityOptionsMasterUserOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderAdvancedSecurityOptionsMasterUserOptions(obj: DomainSpecForProviderAdvancedSecurityOptionsMasterUserOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'masterUserARN': obj.masterUserArn,
    'masterUserName': obj.masterUserName,
    'masterUserPassword': obj.masterUserPassword,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The SAML authentication configuration for an Amazon OpenSearch Service domain.
 *
 * @schema DomainSpecForProviderAdvancedSecurityOptionsSAmlOptions
 */
export interface DomainSpecForProviderAdvancedSecurityOptionsSAmlOptions {
  /**
   * @schema DomainSpecForProviderAdvancedSecurityOptionsSAmlOptions#enabled
   */
  readonly enabled?: boolean;

  /**
   * The SAML identity povider information.
   *
   * @schema DomainSpecForProviderAdvancedSecurityOptionsSAmlOptions#idp
   */
  readonly idp?: DomainSpecForProviderAdvancedSecurityOptionsSAmlOptionsIdp;

  /**
   * @schema DomainSpecForProviderAdvancedSecurityOptionsSAmlOptions#masterBackendRole
   */
  readonly masterBackendRole?: string;

  /**
   * @schema DomainSpecForProviderAdvancedSecurityOptionsSAmlOptions#masterUserName
   */
  readonly masterUserName?: string;

  /**
   * @schema DomainSpecForProviderAdvancedSecurityOptionsSAmlOptions#rolesKey
   */
  readonly rolesKey?: string;

  /**
   * @schema DomainSpecForProviderAdvancedSecurityOptionsSAmlOptions#sessionTimeoutMinutes
   */
  readonly sessionTimeoutMinutes?: number;

  /**
   * @schema DomainSpecForProviderAdvancedSecurityOptionsSAmlOptions#subjectKey
   */
  readonly subjectKey?: string;

}

/**
 * Converts an object of type 'DomainSpecForProviderAdvancedSecurityOptionsSAmlOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderAdvancedSecurityOptionsSAmlOptions(obj: DomainSpecForProviderAdvancedSecurityOptionsSAmlOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'idp': toJson_DomainSpecForProviderAdvancedSecurityOptionsSAmlOptionsIdp(obj.idp),
    'masterBackendRole': obj.masterBackendRole,
    'masterUserName': obj.masterUserName,
    'rolesKey': obj.rolesKey,
    'sessionTimeoutMinutes': obj.sessionTimeoutMinutes,
    'subjectKey': obj.subjectKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecForProviderAutoTuneOptionsMaintenanceSchedules
 */
export interface DomainSpecForProviderAutoTuneOptionsMaintenanceSchedules {
  /**
   * @schema DomainSpecForProviderAutoTuneOptionsMaintenanceSchedules#cronExpressionForRecurrence
   */
  readonly cronExpressionForRecurrence?: string;

  /**
   * The duration of a maintenance schedule. For more information, see Auto-Tune for Amazon OpenSearch Service (https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html).
   *
   * @schema DomainSpecForProviderAutoTuneOptionsMaintenanceSchedules#duration
   */
  readonly duration?: DomainSpecForProviderAutoTuneOptionsMaintenanceSchedulesDuration;

  /**
   * @schema DomainSpecForProviderAutoTuneOptionsMaintenanceSchedules#startAt
   */
  readonly startAt?: Date;

}

/**
 * Converts an object of type 'DomainSpecForProviderAutoTuneOptionsMaintenanceSchedules' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderAutoTuneOptionsMaintenanceSchedules(obj: DomainSpecForProviderAutoTuneOptionsMaintenanceSchedules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cronExpressionForRecurrence': obj.cronExpressionForRecurrence,
    'duration': toJson_DomainSpecForProviderAutoTuneOptionsMaintenanceSchedulesDuration(obj.duration),
    'startAt': obj.startAt?.toISOString(),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Container for the parameters required to enable cold storage for an OpenSearch Service domain. For more information, see Cold storage for Amazon OpenSearch Service (https://docs.aws.amazon.com/opensearch-service/latest/developerguide/cold-storage.html).
 *
 * @schema DomainSpecForProviderClusterConfigColdStorageOptions
 */
export interface DomainSpecForProviderClusterConfigColdStorageOptions {
  /**
   * @schema DomainSpecForProviderClusterConfigColdStorageOptions#enabled
   */
  readonly enabled?: boolean;

}

/**
 * Converts an object of type 'DomainSpecForProviderClusterConfigColdStorageOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderClusterConfigColdStorageOptions(obj: DomainSpecForProviderClusterConfigColdStorageOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The zone awareness configuration for an Amazon OpenSearch Service domain.
 *
 * @schema DomainSpecForProviderClusterConfigZoneAwarenessConfig
 */
export interface DomainSpecForProviderClusterConfigZoneAwarenessConfig {
  /**
   * @schema DomainSpecForProviderClusterConfigZoneAwarenessConfig#availabilityZoneCount
   */
  readonly availabilityZoneCount?: number;

}

/**
 * Converts an object of type 'DomainSpecForProviderClusterConfigZoneAwarenessConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderClusterConfigZoneAwarenessConfig(obj: DomainSpecForProviderClusterConfigZoneAwarenessConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'availabilityZoneCount': obj.availabilityZoneCount,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * KMSKeyIDRef is a reference to a KMS Key used to set KMSKeyID.
 *
 * @schema DomainSpecForProviderEncryptionAtRestOptionsKmsKeyIdRef
 */
export interface DomainSpecForProviderEncryptionAtRestOptionsKmsKeyIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema DomainSpecForProviderEncryptionAtRestOptionsKmsKeyIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DomainSpecForProviderEncryptionAtRestOptionsKmsKeyIdRef#policy
   */
  readonly policy?: DomainSpecForProviderEncryptionAtRestOptionsKmsKeyIdRefPolicy;

}

/**
 * Converts an object of type 'DomainSpecForProviderEncryptionAtRestOptionsKmsKeyIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderEncryptionAtRestOptionsKmsKeyIdRef(obj: DomainSpecForProviderEncryptionAtRestOptionsKmsKeyIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DomainSpecForProviderEncryptionAtRestOptionsKmsKeyIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * KMSKeyIDSelector selects a reference to a KMS Key used to set KMSKeyID.
 *
 * @schema DomainSpecForProviderEncryptionAtRestOptionsKmsKeyIdSelector
 */
export interface DomainSpecForProviderEncryptionAtRestOptionsKmsKeyIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DomainSpecForProviderEncryptionAtRestOptionsKmsKeyIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DomainSpecForProviderEncryptionAtRestOptionsKmsKeyIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DomainSpecForProviderEncryptionAtRestOptionsKmsKeyIdSelector#policy
   */
  readonly policy?: DomainSpecForProviderEncryptionAtRestOptionsKmsKeyIdSelectorPolicy;

}

/**
 * Converts an object of type 'DomainSpecForProviderEncryptionAtRestOptionsKmsKeyIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderEncryptionAtRestOptionsKmsKeyIdSelector(obj: DomainSpecForProviderEncryptionAtRestOptionsKmsKeyIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DomainSpecForProviderEncryptionAtRestOptionsKmsKeyIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A custom 10-hour, low-traffic window during which OpenSearch Service can perform mandatory configuration changes on the domain. These actions can include scheduled service software updates and blue/green Auto-Tune enhancements. OpenSearch Service will schedule these actions during the window that you specify.
 * If you don't specify a window start time, it defaults to 10:00 P.M. local time.
 * For more information, see Defining off-peak maintenance windows for Amazon OpenSearch Service (https://docs.aws.amazon.com/opensearch-service/latest/developerguide/off-peak.html).
 *
 * @schema DomainSpecForProviderOffPeakWindowOptionsOffPeakWindow
 */
export interface DomainSpecForProviderOffPeakWindowOptionsOffPeakWindow {
  /**
   * The desired start time for an off-peak maintenance window (https://docs.aws.amazon.com/opensearch-service/latest/APIReference/API_OffPeakWindow.html).
   *
   * @schema DomainSpecForProviderOffPeakWindowOptionsOffPeakWindow#windowStartTime
   */
  readonly windowStartTime?: DomainSpecForProviderOffPeakWindowOptionsOffPeakWindowWindowStartTime;

}

/**
 * Converts an object of type 'DomainSpecForProviderOffPeakWindowOptionsOffPeakWindow' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderOffPeakWindowOptionsOffPeakWindow(obj: DomainSpecForProviderOffPeakWindowOptionsOffPeakWindow | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'windowStartTime': toJson_DomainSpecForProviderOffPeakWindowOptionsOffPeakWindowWindowStartTime(obj.windowStartTime),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema DomainSpecForProviderVpcOptionsSecurityGroupIdRefs
 */
export interface DomainSpecForProviderVpcOptionsSecurityGroupIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema DomainSpecForProviderVpcOptionsSecurityGroupIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DomainSpecForProviderVpcOptionsSecurityGroupIdRefs#policy
   */
  readonly policy?: DomainSpecForProviderVpcOptionsSecurityGroupIdRefsPolicy;

}

/**
 * Converts an object of type 'DomainSpecForProviderVpcOptionsSecurityGroupIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderVpcOptionsSecurityGroupIdRefs(obj: DomainSpecForProviderVpcOptionsSecurityGroupIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DomainSpecForProviderVpcOptionsSecurityGroupIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecurityGroupIDsSelector selects references to SecurityGroupID used to set the SecurityGroupIDs.
 *
 * @schema DomainSpecForProviderVpcOptionsSecurityGroupIdSelector
 */
export interface DomainSpecForProviderVpcOptionsSecurityGroupIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DomainSpecForProviderVpcOptionsSecurityGroupIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DomainSpecForProviderVpcOptionsSecurityGroupIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DomainSpecForProviderVpcOptionsSecurityGroupIdSelector#policy
   */
  readonly policy?: DomainSpecForProviderVpcOptionsSecurityGroupIdSelectorPolicy;

}

/**
 * Converts an object of type 'DomainSpecForProviderVpcOptionsSecurityGroupIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderVpcOptionsSecurityGroupIdSelector(obj: DomainSpecForProviderVpcOptionsSecurityGroupIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DomainSpecForProviderVpcOptionsSecurityGroupIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema DomainSpecForProviderVpcOptionsSubnetIdRefs
 */
export interface DomainSpecForProviderVpcOptionsSubnetIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema DomainSpecForProviderVpcOptionsSubnetIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DomainSpecForProviderVpcOptionsSubnetIdRefs#policy
   */
  readonly policy?: DomainSpecForProviderVpcOptionsSubnetIdRefsPolicy;

}

/**
 * Converts an object of type 'DomainSpecForProviderVpcOptionsSubnetIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderVpcOptionsSubnetIdRefs(obj: DomainSpecForProviderVpcOptionsSubnetIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DomainSpecForProviderVpcOptionsSubnetIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SubnetIDsSelector selects references to Subnets used to set the SubnetIDs.
 *
 * @schema DomainSpecForProviderVpcOptionsSubnetIdSelector
 */
export interface DomainSpecForProviderVpcOptionsSubnetIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DomainSpecForProviderVpcOptionsSubnetIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DomainSpecForProviderVpcOptionsSubnetIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DomainSpecForProviderVpcOptionsSubnetIdSelector#policy
   */
  readonly policy?: DomainSpecForProviderVpcOptionsSubnetIdSelectorPolicy;

}

/**
 * Converts an object of type 'DomainSpecForProviderVpcOptionsSubnetIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderVpcOptionsSubnetIdSelector(obj: DomainSpecForProviderVpcOptionsSubnetIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DomainSpecForProviderVpcOptionsSubnetIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DomainSpecProviderConfigRefPolicyResolution
 */
export enum DomainSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DomainSpecProviderConfigRefPolicyResolve
 */
export enum DomainSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DomainSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DomainSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DomainSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DomainSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DomainSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DomainSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DomainSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecPublishConnectionDetailsToConfigRefPolicy(obj: DomainSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The SAML identity povider information.
 *
 * @schema DomainSpecForProviderAdvancedSecurityOptionsSAmlOptionsIdp
 */
export interface DomainSpecForProviderAdvancedSecurityOptionsSAmlOptionsIdp {
  /**
   * @schema DomainSpecForProviderAdvancedSecurityOptionsSAmlOptionsIdp#entityID
   */
  readonly entityId?: string;

  /**
   * @schema DomainSpecForProviderAdvancedSecurityOptionsSAmlOptionsIdp#metadataContent
   */
  readonly metadataContent?: string;

}

/**
 * Converts an object of type 'DomainSpecForProviderAdvancedSecurityOptionsSAmlOptionsIdp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderAdvancedSecurityOptionsSAmlOptionsIdp(obj: DomainSpecForProviderAdvancedSecurityOptionsSAmlOptionsIdp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'entityID': obj.entityId,
    'metadataContent': obj.metadataContent,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The duration of a maintenance schedule. For more information, see Auto-Tune for Amazon OpenSearch Service (https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html).
 *
 * @schema DomainSpecForProviderAutoTuneOptionsMaintenanceSchedulesDuration
 */
export interface DomainSpecForProviderAutoTuneOptionsMaintenanceSchedulesDuration {
  /**
   * The unit of a maintenance schedule duration. Valid value is HOUR.
   *
   * @schema DomainSpecForProviderAutoTuneOptionsMaintenanceSchedulesDuration#unit
   */
  readonly unit?: string;

  /**
   * Integer that specifies the value of a maintenance schedule duration.
   *
   * @schema DomainSpecForProviderAutoTuneOptionsMaintenanceSchedulesDuration#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'DomainSpecForProviderAutoTuneOptionsMaintenanceSchedulesDuration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderAutoTuneOptionsMaintenanceSchedulesDuration(obj: DomainSpecForProviderAutoTuneOptionsMaintenanceSchedulesDuration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'unit': obj.unit,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DomainSpecForProviderEncryptionAtRestOptionsKmsKeyIdRefPolicy
 */
export interface DomainSpecForProviderEncryptionAtRestOptionsKmsKeyIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DomainSpecForProviderEncryptionAtRestOptionsKmsKeyIdRefPolicy#resolution
   */
  readonly resolution?: DomainSpecForProviderEncryptionAtRestOptionsKmsKeyIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DomainSpecForProviderEncryptionAtRestOptionsKmsKeyIdRefPolicy#resolve
   */
  readonly resolve?: DomainSpecForProviderEncryptionAtRestOptionsKmsKeyIdRefPolicyResolve;

}

/**
 * Converts an object of type 'DomainSpecForProviderEncryptionAtRestOptionsKmsKeyIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderEncryptionAtRestOptionsKmsKeyIdRefPolicy(obj: DomainSpecForProviderEncryptionAtRestOptionsKmsKeyIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DomainSpecForProviderEncryptionAtRestOptionsKmsKeyIdSelectorPolicy
 */
export interface DomainSpecForProviderEncryptionAtRestOptionsKmsKeyIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DomainSpecForProviderEncryptionAtRestOptionsKmsKeyIdSelectorPolicy#resolution
   */
  readonly resolution?: DomainSpecForProviderEncryptionAtRestOptionsKmsKeyIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DomainSpecForProviderEncryptionAtRestOptionsKmsKeyIdSelectorPolicy#resolve
   */
  readonly resolve?: DomainSpecForProviderEncryptionAtRestOptionsKmsKeyIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DomainSpecForProviderEncryptionAtRestOptionsKmsKeyIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderEncryptionAtRestOptionsKmsKeyIdSelectorPolicy(obj: DomainSpecForProviderEncryptionAtRestOptionsKmsKeyIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The desired start time for an off-peak maintenance window (https://docs.aws.amazon.com/opensearch-service/latest/APIReference/API_OffPeakWindow.html).
 *
 * @schema DomainSpecForProviderOffPeakWindowOptionsOffPeakWindowWindowStartTime
 */
export interface DomainSpecForProviderOffPeakWindowOptionsOffPeakWindowWindowStartTime {
  /**
   * @schema DomainSpecForProviderOffPeakWindowOptionsOffPeakWindowWindowStartTime#hours
   */
  readonly hours?: number;

  /**
   * @schema DomainSpecForProviderOffPeakWindowOptionsOffPeakWindowWindowStartTime#minutes
   */
  readonly minutes?: number;

}

/**
 * Converts an object of type 'DomainSpecForProviderOffPeakWindowOptionsOffPeakWindowWindowStartTime' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderOffPeakWindowOptionsOffPeakWindowWindowStartTime(obj: DomainSpecForProviderOffPeakWindowOptionsOffPeakWindowWindowStartTime | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hours': obj.hours,
    'minutes': obj.minutes,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DomainSpecForProviderVpcOptionsSecurityGroupIdRefsPolicy
 */
export interface DomainSpecForProviderVpcOptionsSecurityGroupIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DomainSpecForProviderVpcOptionsSecurityGroupIdRefsPolicy#resolution
   */
  readonly resolution?: DomainSpecForProviderVpcOptionsSecurityGroupIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DomainSpecForProviderVpcOptionsSecurityGroupIdRefsPolicy#resolve
   */
  readonly resolve?: DomainSpecForProviderVpcOptionsSecurityGroupIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'DomainSpecForProviderVpcOptionsSecurityGroupIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderVpcOptionsSecurityGroupIdRefsPolicy(obj: DomainSpecForProviderVpcOptionsSecurityGroupIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DomainSpecForProviderVpcOptionsSecurityGroupIdSelectorPolicy
 */
export interface DomainSpecForProviderVpcOptionsSecurityGroupIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DomainSpecForProviderVpcOptionsSecurityGroupIdSelectorPolicy#resolution
   */
  readonly resolution?: DomainSpecForProviderVpcOptionsSecurityGroupIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DomainSpecForProviderVpcOptionsSecurityGroupIdSelectorPolicy#resolve
   */
  readonly resolve?: DomainSpecForProviderVpcOptionsSecurityGroupIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DomainSpecForProviderVpcOptionsSecurityGroupIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderVpcOptionsSecurityGroupIdSelectorPolicy(obj: DomainSpecForProviderVpcOptionsSecurityGroupIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DomainSpecForProviderVpcOptionsSubnetIdRefsPolicy
 */
export interface DomainSpecForProviderVpcOptionsSubnetIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DomainSpecForProviderVpcOptionsSubnetIdRefsPolicy#resolution
   */
  readonly resolution?: DomainSpecForProviderVpcOptionsSubnetIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DomainSpecForProviderVpcOptionsSubnetIdRefsPolicy#resolve
   */
  readonly resolve?: DomainSpecForProviderVpcOptionsSubnetIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'DomainSpecForProviderVpcOptionsSubnetIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderVpcOptionsSubnetIdRefsPolicy(obj: DomainSpecForProviderVpcOptionsSubnetIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DomainSpecForProviderVpcOptionsSubnetIdSelectorPolicy
 */
export interface DomainSpecForProviderVpcOptionsSubnetIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DomainSpecForProviderVpcOptionsSubnetIdSelectorPolicy#resolution
   */
  readonly resolution?: DomainSpecForProviderVpcOptionsSubnetIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DomainSpecForProviderVpcOptionsSubnetIdSelectorPolicy#resolve
   */
  readonly resolve?: DomainSpecForProviderVpcOptionsSubnetIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DomainSpecForProviderVpcOptionsSubnetIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderVpcOptionsSubnetIdSelectorPolicy(obj: DomainSpecForProviderVpcOptionsSubnetIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DomainSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DomainSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DomainSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DomainSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DomainSpecForProviderEncryptionAtRestOptionsKmsKeyIdRefPolicyResolution
 */
export enum DomainSpecForProviderEncryptionAtRestOptionsKmsKeyIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DomainSpecForProviderEncryptionAtRestOptionsKmsKeyIdRefPolicyResolve
 */
export enum DomainSpecForProviderEncryptionAtRestOptionsKmsKeyIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DomainSpecForProviderEncryptionAtRestOptionsKmsKeyIdSelectorPolicyResolution
 */
export enum DomainSpecForProviderEncryptionAtRestOptionsKmsKeyIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DomainSpecForProviderEncryptionAtRestOptionsKmsKeyIdSelectorPolicyResolve
 */
export enum DomainSpecForProviderEncryptionAtRestOptionsKmsKeyIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DomainSpecForProviderVpcOptionsSecurityGroupIdRefsPolicyResolution
 */
export enum DomainSpecForProviderVpcOptionsSecurityGroupIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DomainSpecForProviderVpcOptionsSecurityGroupIdRefsPolicyResolve
 */
export enum DomainSpecForProviderVpcOptionsSecurityGroupIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DomainSpecForProviderVpcOptionsSecurityGroupIdSelectorPolicyResolution
 */
export enum DomainSpecForProviderVpcOptionsSecurityGroupIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DomainSpecForProviderVpcOptionsSecurityGroupIdSelectorPolicyResolve
 */
export enum DomainSpecForProviderVpcOptionsSecurityGroupIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DomainSpecForProviderVpcOptionsSubnetIdRefsPolicyResolution
 */
export enum DomainSpecForProviderVpcOptionsSubnetIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DomainSpecForProviderVpcOptionsSubnetIdRefsPolicyResolve
 */
export enum DomainSpecForProviderVpcOptionsSubnetIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DomainSpecForProviderVpcOptionsSubnetIdSelectorPolicyResolution
 */
export enum DomainSpecForProviderVpcOptionsSubnetIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DomainSpecForProviderVpcOptionsSubnetIdSelectorPolicyResolve
 */
export enum DomainSpecForProviderVpcOptionsSubnetIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

