// @ts-nocheck
// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Backup is the Schema for the Backups API
 *
 * @schema Backup
 */
export class Backup extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Backup"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'dynamodb.aws.crossplane.io/v1alpha1',
    kind: 'Backup',
  }

  /**
   * Renders a Kubernetes manifest for "Backup".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BackupProps): any {
    return {
      ...Backup.GVK,
      ...toJson_BackupProps(props),
    };
  }

  /**
   * Defines a "Backup" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BackupProps) {
    super(scope, id, {
      ...Backup.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Backup.GVK,
      ...toJson_BackupProps(resolved),
    };
  }
}

/**
 * Backup is the Schema for the Backups API
 *
 * @schema Backup
 */
export interface BackupProps {
  /**
   * @schema Backup#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BackupSpec defines the desired state of Backup
   *
   * @schema Backup#spec
   */
  readonly spec: BackupSpec;

}

/**
 * Converts an object of type 'BackupProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupProps(obj: BackupProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BackupSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BackupSpec defines the desired state of Backup
 *
 * @schema BackupSpec
 */
export interface BackupSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema BackupSpec#deletionPolicy
   */
  readonly deletionPolicy?: BackupSpecDeletionPolicy;

  /**
   * BackupParameters defines the desired state of Backup
   *
   * @schema BackupSpec#forProvider
   */
  readonly forProvider: BackupSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema BackupSpec#managementPolicies
   */
  readonly managementPolicies?: BackupSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema BackupSpec#providerConfigRef
   */
  readonly providerConfigRef?: BackupSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema BackupSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: BackupSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema BackupSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: BackupSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'BackupSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupSpec(obj: BackupSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_BackupSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_BackupSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_BackupSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_BackupSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema BackupSpecDeletionPolicy
 */
export enum BackupSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * BackupParameters defines the desired state of Backup
 *
 * @schema BackupSpecForProvider
 */
export interface BackupSpecForProvider {
  /**
   * Specified name for the backup.
   *
   * @schema BackupSpecForProvider#backupName
   */
  readonly backupName: string;

  /**
   * Region is which region the Backup will be created.
   *
   * @schema BackupSpecForProvider#region
   */
  readonly region: string;

  /**
   * TableName is the name of the Table whose backup will be taken.
   *
   * @schema BackupSpecForProvider#tableName
   */
  readonly tableName?: string;

  /**
   * TableNameRef points to the Table resource whose Name will be used to fill TableName field.
   *
   * @schema BackupSpecForProvider#tableNameRef
   */
  readonly tableNameRef?: BackupSpecForProviderTableNameRef;

  /**
   * TableNameSelector selects a Table resource.
   *
   * @schema BackupSpecForProvider#tableNameSelector
   */
  readonly tableNameSelector?: BackupSpecForProviderTableNameSelector;

}

/**
 * Converts an object of type 'BackupSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupSpecForProvider(obj: BackupSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'backupName': obj.backupName,
    'region': obj.region,
    'tableName': obj.tableName,
    'tableNameRef': toJson_BackupSpecForProviderTableNameRef(obj.tableNameRef),
    'tableNameSelector': toJson_BackupSpecForProviderTableNameSelector(obj.tableNameSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema BackupSpecManagementPolicies
 */
export enum BackupSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema BackupSpecProviderConfigRef
 */
export interface BackupSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BackupSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BackupSpecProviderConfigRef#policy
   */
  readonly policy?: BackupSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'BackupSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupSpecProviderConfigRef(obj: BackupSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BackupSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema BackupSpecPublishConnectionDetailsTo
 */
export interface BackupSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema BackupSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: BackupSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema BackupSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: BackupSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema BackupSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'BackupSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupSpecPublishConnectionDetailsTo(obj: BackupSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_BackupSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_BackupSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema BackupSpecWriteConnectionSecretToRef
 */
export interface BackupSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema BackupSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema BackupSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'BackupSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupSpecWriteConnectionSecretToRef(obj: BackupSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TableNameRef points to the Table resource whose Name will be used to fill TableName field.
 *
 * @schema BackupSpecForProviderTableNameRef
 */
export interface BackupSpecForProviderTableNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema BackupSpecForProviderTableNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BackupSpecForProviderTableNameRef#policy
   */
  readonly policy?: BackupSpecForProviderTableNameRefPolicy;

}

/**
 * Converts an object of type 'BackupSpecForProviderTableNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupSpecForProviderTableNameRef(obj: BackupSpecForProviderTableNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BackupSpecForProviderTableNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TableNameSelector selects a Table resource.
 *
 * @schema BackupSpecForProviderTableNameSelector
 */
export interface BackupSpecForProviderTableNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BackupSpecForProviderTableNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BackupSpecForProviderTableNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BackupSpecForProviderTableNameSelector#policy
   */
  readonly policy?: BackupSpecForProviderTableNameSelectorPolicy;

}

/**
 * Converts an object of type 'BackupSpecForProviderTableNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupSpecForProviderTableNameSelector(obj: BackupSpecForProviderTableNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BackupSpecForProviderTableNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BackupSpecProviderConfigRefPolicy
 */
export interface BackupSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BackupSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: BackupSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BackupSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: BackupSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BackupSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupSpecProviderConfigRefPolicy(obj: BackupSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema BackupSpecPublishConnectionDetailsToConfigRef
 */
export interface BackupSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BackupSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BackupSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: BackupSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'BackupSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupSpecPublishConnectionDetailsToConfigRef(obj: BackupSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BackupSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema BackupSpecPublishConnectionDetailsToMetadata
 */
export interface BackupSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema BackupSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema BackupSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema BackupSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'BackupSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupSpecPublishConnectionDetailsToMetadata(obj: BackupSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BackupSpecForProviderTableNameRefPolicy
 */
export interface BackupSpecForProviderTableNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BackupSpecForProviderTableNameRefPolicy#resolution
   */
  readonly resolution?: BackupSpecForProviderTableNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BackupSpecForProviderTableNameRefPolicy#resolve
   */
  readonly resolve?: BackupSpecForProviderTableNameRefPolicyResolve;

}

/**
 * Converts an object of type 'BackupSpecForProviderTableNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupSpecForProviderTableNameRefPolicy(obj: BackupSpecForProviderTableNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BackupSpecForProviderTableNameSelectorPolicy
 */
export interface BackupSpecForProviderTableNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BackupSpecForProviderTableNameSelectorPolicy#resolution
   */
  readonly resolution?: BackupSpecForProviderTableNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BackupSpecForProviderTableNameSelectorPolicy#resolve
   */
  readonly resolve?: BackupSpecForProviderTableNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BackupSpecForProviderTableNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupSpecForProviderTableNameSelectorPolicy(obj: BackupSpecForProviderTableNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BackupSpecProviderConfigRefPolicyResolution
 */
export enum BackupSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BackupSpecProviderConfigRefPolicyResolve
 */
export enum BackupSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema BackupSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface BackupSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BackupSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: BackupSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BackupSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: BackupSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BackupSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupSpecPublishConnectionDetailsToConfigRefPolicy(obj: BackupSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BackupSpecForProviderTableNameRefPolicyResolution
 */
export enum BackupSpecForProviderTableNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BackupSpecForProviderTableNameRefPolicyResolve
 */
export enum BackupSpecForProviderTableNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BackupSpecForProviderTableNameSelectorPolicyResolution
 */
export enum BackupSpecForProviderTableNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BackupSpecForProviderTableNameSelectorPolicyResolve
 */
export enum BackupSpecForProviderTableNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BackupSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum BackupSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BackupSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum BackupSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * GlobalTable is the Schema for the GlobalTables API
 *
 * @schema GlobalTable
 */
export class GlobalTable extends ApiObject {
  /**
   * Returns the apiVersion and kind for "GlobalTable"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'dynamodb.aws.crossplane.io/v1alpha1',
    kind: 'GlobalTable',
  }

  /**
   * Renders a Kubernetes manifest for "GlobalTable".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: GlobalTableProps): any {
    return {
      ...GlobalTable.GVK,
      ...toJson_GlobalTableProps(props),
    };
  }

  /**
   * Defines a "GlobalTable" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: GlobalTableProps) {
    super(scope, id, {
      ...GlobalTable.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...GlobalTable.GVK,
      ...toJson_GlobalTableProps(resolved),
    };
  }
}

/**
 * GlobalTable is the Schema for the GlobalTables API
 *
 * @schema GlobalTable
 */
export interface GlobalTableProps {
  /**
   * @schema GlobalTable#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * GlobalTableSpec defines the desired state of GlobalTable
   *
   * @schema GlobalTable#spec
   */
  readonly spec: GlobalTableSpec;

}

/**
 * Converts an object of type 'GlobalTableProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalTableProps(obj: GlobalTableProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_GlobalTableSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GlobalTableSpec defines the desired state of GlobalTable
 *
 * @schema GlobalTableSpec
 */
export interface GlobalTableSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema GlobalTableSpec#deletionPolicy
   */
  readonly deletionPolicy?: GlobalTableSpecDeletionPolicy;

  /**
   * GlobalTableParameters defines the desired state of GlobalTable
   *
   * @schema GlobalTableSpec#forProvider
   */
  readonly forProvider: GlobalTableSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema GlobalTableSpec#managementPolicies
   */
  readonly managementPolicies?: GlobalTableSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema GlobalTableSpec#providerConfigRef
   */
  readonly providerConfigRef?: GlobalTableSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema GlobalTableSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: GlobalTableSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema GlobalTableSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: GlobalTableSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'GlobalTableSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalTableSpec(obj: GlobalTableSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_GlobalTableSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_GlobalTableSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_GlobalTableSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_GlobalTableSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema GlobalTableSpecDeletionPolicy
 */
export enum GlobalTableSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * GlobalTableParameters defines the desired state of GlobalTable
 *
 * @schema GlobalTableSpecForProvider
 */
export interface GlobalTableSpecForProvider {
  /**
   * Region is which region the GlobalTable will be created.
   *
   * @schema GlobalTableSpecForProvider#region
   */
  readonly region: string;

  /**
   * The Regions where the global table needs to be created.
   *
   * @schema GlobalTableSpecForProvider#replicationGroup
   */
  readonly replicationGroup: GlobalTableSpecForProviderReplicationGroup[];

}

/**
 * Converts an object of type 'GlobalTableSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalTableSpecForProvider(obj: GlobalTableSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'region': obj.region,
    'replicationGroup': obj.replicationGroup?.map(y => toJson_GlobalTableSpecForProviderReplicationGroup(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema GlobalTableSpecManagementPolicies
 */
export enum GlobalTableSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema GlobalTableSpecProviderConfigRef
 */
export interface GlobalTableSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema GlobalTableSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GlobalTableSpecProviderConfigRef#policy
   */
  readonly policy?: GlobalTableSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'GlobalTableSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalTableSpecProviderConfigRef(obj: GlobalTableSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GlobalTableSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema GlobalTableSpecPublishConnectionDetailsTo
 */
export interface GlobalTableSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema GlobalTableSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: GlobalTableSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema GlobalTableSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: GlobalTableSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema GlobalTableSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'GlobalTableSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalTableSpecPublishConnectionDetailsTo(obj: GlobalTableSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_GlobalTableSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_GlobalTableSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema GlobalTableSpecWriteConnectionSecretToRef
 */
export interface GlobalTableSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema GlobalTableSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema GlobalTableSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'GlobalTableSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalTableSpecWriteConnectionSecretToRef(obj: GlobalTableSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GlobalTableSpecForProviderReplicationGroup
 */
export interface GlobalTableSpecForProviderReplicationGroup {
  /**
   * @schema GlobalTableSpecForProviderReplicationGroup#regionName
   */
  readonly regionName?: string;

}

/**
 * Converts an object of type 'GlobalTableSpecForProviderReplicationGroup' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalTableSpecForProviderReplicationGroup(obj: GlobalTableSpecForProviderReplicationGroup | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'regionName': obj.regionName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema GlobalTableSpecProviderConfigRefPolicy
 */
export interface GlobalTableSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GlobalTableSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: GlobalTableSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GlobalTableSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: GlobalTableSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'GlobalTableSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalTableSpecProviderConfigRefPolicy(obj: GlobalTableSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema GlobalTableSpecPublishConnectionDetailsToConfigRef
 */
export interface GlobalTableSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema GlobalTableSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GlobalTableSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: GlobalTableSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'GlobalTableSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalTableSpecPublishConnectionDetailsToConfigRef(obj: GlobalTableSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GlobalTableSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema GlobalTableSpecPublishConnectionDetailsToMetadata
 */
export interface GlobalTableSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema GlobalTableSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema GlobalTableSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema GlobalTableSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'GlobalTableSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalTableSpecPublishConnectionDetailsToMetadata(obj: GlobalTableSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GlobalTableSpecProviderConfigRefPolicyResolution
 */
export enum GlobalTableSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GlobalTableSpecProviderConfigRefPolicyResolve
 */
export enum GlobalTableSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema GlobalTableSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface GlobalTableSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GlobalTableSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: GlobalTableSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GlobalTableSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: GlobalTableSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'GlobalTableSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalTableSpecPublishConnectionDetailsToConfigRefPolicy(obj: GlobalTableSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GlobalTableSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum GlobalTableSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GlobalTableSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum GlobalTableSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Table is the Schema for the Tables API
 *
 * @schema Table
 */
export class Table extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Table"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'dynamodb.aws.crossplane.io/v1alpha1',
    kind: 'Table',
  }

  /**
   * Renders a Kubernetes manifest for "Table".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: TableProps): any {
    return {
      ...Table.GVK,
      ...toJson_TableProps(props),
    };
  }

  /**
   * Defines a "Table" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: TableProps) {
    super(scope, id, {
      ...Table.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Table.GVK,
      ...toJson_TableProps(resolved),
    };
  }
}

/**
 * Table is the Schema for the Tables API
 *
 * @schema Table
 */
export interface TableProps {
  /**
   * @schema Table#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * TableSpec defines the desired state of Table
   *
   * @schema Table#spec
   */
  readonly spec: TableSpec;

}

/**
 * Converts an object of type 'TableProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableProps(obj: TableProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_TableSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TableSpec defines the desired state of Table
 *
 * @schema TableSpec
 */
export interface TableSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema TableSpec#deletionPolicy
   */
  readonly deletionPolicy?: TableSpecDeletionPolicy;

  /**
   * TableParameters defines the desired state of Table
   *
   * @schema TableSpec#forProvider
   */
  readonly forProvider: TableSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema TableSpec#managementPolicies
   */
  readonly managementPolicies?: TableSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema TableSpec#providerConfigRef
   */
  readonly providerConfigRef?: TableSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema TableSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: TableSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema TableSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: TableSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'TableSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpec(obj: TableSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_TableSpecForProvider(obj.forProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_TableSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_TableSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_TableSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema TableSpecDeletionPolicy
 */
export enum TableSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * TableParameters defines the desired state of Table
 *
 * @schema TableSpecForProvider
 */
export interface TableSpecForProvider {
  /**
   * An array of attributes that describe the key schema for the table and indexes.
   *
   * @schema TableSpecForProvider#attributeDefinitions
   */
  readonly attributeDefinitions: TableSpecForProviderAttributeDefinitions[];

  /**
   * Controls how you are charged for read and write throughput and how you manage capacity. This setting can be changed later.
   * * PROVISIONED - We recommend using PROVISIONED for predictable workloads. PROVISIONED sets the billing mode to Provisioned Mode (https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.ReadWriteCapacityMode.html#HowItWorks.ProvisionedThroughput.Manual).
   * * PAY_PER_REQUEST - We recommend using PAY_PER_REQUEST for unpredictable workloads. PAY_PER_REQUEST sets the billing mode to On-Demand Mode (https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.ReadWriteCapacityMode.html#HowItWorks.OnDemand).
   *
   * @schema TableSpecForProvider#billingMode
   */
  readonly billingMode?: string;

  /**
   * Indicates whether deletion protection is to be enabled (true) or disabled (false) on the table.
   *
   * @schema TableSpecForProvider#deletionProtectionEnabled
   */
  readonly deletionProtectionEnabled?: boolean;

  /**
   * One or more global secondary indexes (the maximum is 20) to be created on the table. Each global secondary index in the array includes the following:
   * * IndexName - The name of the global secondary index. Must be unique only for this table.
   * * KeySchema - Specifies the key schema for the global secondary index.
   * * Projection - Specifies attributes that are copied (projected) from the table into the index. These are in addition to the primary key attributes and index key attributes, which are automatically projected. Each attribute specification is composed of: ProjectionType - One of the following: KEYS_ONLY - Only the index and primary keys are projected into the index. INCLUDE - Only the specified table attributes are projected into the index. The list of projected attributes is in NonKeyAttributes. ALL - All of the table attributes are projected into the index. NonKeyAttributes - A list of one or more non-key attribute names that are projected into the secondary index. The total count of attributes provided in NonKeyAttributes, summed across all of the secondary indexes, must not exceed 100. If you project the same attribute into two different indexes, this counts as two distinct attributes when determining the total.
   * * ProvisionedThroughput - The provisioned throughput settings for the global secondary index, consisting of read and write capacity units.
   *
   * @schema TableSpecForProvider#globalSecondaryIndexes
   */
  readonly globalSecondaryIndexes?: TableSpecForProviderGlobalSecondaryIndexes[];

  /**
   * Specifies the attributes that make up the primary key for a table or an index. The attributes in KeySchema must also be defined in the AttributeDefinitions array. For more information, see Data Model (https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DataModel.html) in the Amazon DynamoDB Developer Guide.
   * Each KeySchemaElement in the array is composed of:
   * * AttributeName - The name of this key attribute.
   * * KeyType - The role that the key attribute will assume: HASH - partition key RANGE - sort key
   * The partition key of an item is also known as its hash attribute. The term "hash attribute" derives from the DynamoDB usage of an internal hash function to evenly distribute data items across partitions, based on their partition key values.
   * The sort key of an item is also known as its range attribute. The term "range attribute" derives from the way DynamoDB stores items with the same partition key physically close together, in sorted order by the sort key value.
   * For a simple primary key (partition key), you must provide exactly one element with a KeyType of HASH.
   * For a composite primary key (partition key and sort key), you must provide exactly two elements, in this order: The first element must have a KeyType of HASH, and the second element must have a KeyType of RANGE.
   * For more information, see Working with Tables (https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/WorkingWithTables.html#WorkingWithTables.primary.key) in the Amazon DynamoDB Developer Guide.
   *
   * @schema TableSpecForProvider#keySchema
   */
  readonly keySchema: TableSpecForProviderKeySchema[];

  /**
   * One or more local secondary indexes (the maximum is 5) to be created on the table. Each index is scoped to a given partition key value. There is a 10 GB size limit per partition key value; otherwise, the size of a local secondary index is unconstrained.
   * Each local secondary index in the array includes the following:
   * * IndexName - The name of the local secondary index. Must be unique only for this table.
   * * KeySchema - Specifies the key schema for the local secondary index. The key schema must begin with the same partition key as the table.
   * * Projection - Specifies attributes that are copied (projected) from the table into the index. These are in addition to the primary key attributes and index key attributes, which are automatically projected. Each attribute specification is composed of: ProjectionType - One of the following: KEYS_ONLY - Only the index and primary keys are projected into the index. INCLUDE - Only the specified table attributes are projected into the index. The list of projected attributes is in NonKeyAttributes. ALL - All of the table attributes are projected into the index. NonKeyAttributes - A list of one or more non-key attribute names that are projected into the secondary index. The total count of attributes provided in NonKeyAttributes, summed across all of the secondary indexes, must not exceed 100. If you project the same attribute into two different indexes, this counts as two distinct attributes when determining the total.
   *
   * @schema TableSpecForProvider#localSecondaryIndexes
   */
  readonly localSecondaryIndexes?: TableSpecForProviderLocalSecondaryIndexes[];

  /**
   * Indicates whether point in time recovery is enabled (true) or disabled (false) on the table.
   *
   * @schema TableSpecForProvider#pointInTimeRecoveryEnabled
   */
  readonly pointInTimeRecoveryEnabled?: boolean;

  /**
   * Represents the provisioned throughput settings for a specified table or index. The settings can be modified using the UpdateTable operation.
   * If you set BillingMode as PROVISIONED, you must specify this property. If you set BillingMode as PAY_PER_REQUEST, you cannot specify this property.
   * For current minimum and maximum provisioned throughput values, see Service, Account, and Table Quotas (https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Limits.html) in the Amazon DynamoDB Developer Guide.
   *
   * @schema TableSpecForProvider#provisionedThroughput
   */
  readonly provisionedThroughput?: TableSpecForProviderProvisionedThroughput;

  /**
   * Region is which region the Table will be created.
   *
   * @schema TableSpecForProvider#region
   */
  readonly region: string;

  /**
   * Represents the settings used to enable server-side encryption.
   *
   * @schema TableSpecForProvider#sseSpecification
   */
  readonly sseSpecification?: TableSpecForProviderSseSpecification;

  /**
   * The settings for DynamoDB Streams on the table. These settings consist of:
   * * StreamEnabled - Indicates whether DynamoDB Streams is to be enabled (true) or disabled (false).
   * * StreamViewType - When an item in the table is modified, StreamViewType determines what information is written to the table's stream. Valid values for StreamViewType are: KEYS_ONLY - Only the key attributes of the modified item are written to the stream. NEW_IMAGE - The entire item, as it appears after it was modified, is written to the stream. OLD_IMAGE - The entire item, as it appeared before it was modified, is written to the stream. NEW_AND_OLD_IMAGES - Both the new and the old item images of the item are written to the stream.
   *
   * @schema TableSpecForProvider#streamSpecification
   */
  readonly streamSpecification?: TableSpecForProviderStreamSpecification;

  /**
   * The table class of the new table. Valid values are STANDARD and STANDARD_INFREQUENT_ACCESS.
   *
   * @schema TableSpecForProvider#tableClass
   */
  readonly tableClass?: string;

  /**
   * A list of key-value pairs to label the table. For more information, see Tagging for DynamoDB (https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Tagging.html).
   *
   * @schema TableSpecForProvider#tags
   */
  readonly tags?: TableSpecForProviderTags[];

}

/**
 * Converts an object of type 'TableSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecForProvider(obj: TableSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'attributeDefinitions': obj.attributeDefinitions?.map(y => toJson_TableSpecForProviderAttributeDefinitions(y)),
    'billingMode': obj.billingMode,
    'deletionProtectionEnabled': obj.deletionProtectionEnabled,
    'globalSecondaryIndexes': obj.globalSecondaryIndexes?.map(y => toJson_TableSpecForProviderGlobalSecondaryIndexes(y)),
    'keySchema': obj.keySchema?.map(y => toJson_TableSpecForProviderKeySchema(y)),
    'localSecondaryIndexes': obj.localSecondaryIndexes?.map(y => toJson_TableSpecForProviderLocalSecondaryIndexes(y)),
    'pointInTimeRecoveryEnabled': obj.pointInTimeRecoveryEnabled,
    'provisionedThroughput': toJson_TableSpecForProviderProvisionedThroughput(obj.provisionedThroughput),
    'region': obj.region,
    'sseSpecification': toJson_TableSpecForProviderSseSpecification(obj.sseSpecification),
    'streamSpecification': toJson_TableSpecForProviderStreamSpecification(obj.streamSpecification),
    'tableClass': obj.tableClass,
    'tags': obj.tags?.map(y => toJson_TableSpecForProviderTags(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema TableSpecManagementPolicies
 */
export enum TableSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema TableSpecProviderConfigRef
 */
export interface TableSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TableSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TableSpecProviderConfigRef#policy
   */
  readonly policy?: TableSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'TableSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecProviderConfigRef(obj: TableSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TableSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema TableSpecPublishConnectionDetailsTo
 */
export interface TableSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema TableSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: TableSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema TableSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: TableSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema TableSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'TableSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecPublishConnectionDetailsTo(obj: TableSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_TableSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_TableSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema TableSpecWriteConnectionSecretToRef
 */
export interface TableSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema TableSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema TableSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'TableSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecWriteConnectionSecretToRef(obj: TableSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TableSpecForProviderAttributeDefinitions
 */
export interface TableSpecForProviderAttributeDefinitions {
  /**
   * @schema TableSpecForProviderAttributeDefinitions#attributeName
   */
  readonly attributeName?: string;

  /**
   * @schema TableSpecForProviderAttributeDefinitions#attributeType
   */
  readonly attributeType?: string;

}

/**
 * Converts an object of type 'TableSpecForProviderAttributeDefinitions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecForProviderAttributeDefinitions(obj: TableSpecForProviderAttributeDefinitions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'attributeName': obj.attributeName,
    'attributeType': obj.attributeType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TableSpecForProviderGlobalSecondaryIndexes
 */
export interface TableSpecForProviderGlobalSecondaryIndexes {
  /**
   * @schema TableSpecForProviderGlobalSecondaryIndexes#indexName
   */
  readonly indexName?: string;

  /**
   * @schema TableSpecForProviderGlobalSecondaryIndexes#keySchema
   */
  readonly keySchema?: TableSpecForProviderGlobalSecondaryIndexesKeySchema[];

  /**
   * Represents attributes that are copied (projected) from the table into an index. These are in addition to the primary key attributes and index key attributes, which are automatically projected.
   *
   * @schema TableSpecForProviderGlobalSecondaryIndexes#projection
   */
  readonly projection?: TableSpecForProviderGlobalSecondaryIndexesProjection;

  /**
   * Represents the provisioned throughput settings for a specified table or index. The settings can be modified using the UpdateTable operation.
   * For current minimum and maximum provisioned throughput values, see Service, Account, and Table Quotas (https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Limits.html) in the Amazon DynamoDB Developer Guide.
   *
   * @schema TableSpecForProviderGlobalSecondaryIndexes#provisionedThroughput
   */
  readonly provisionedThroughput?: TableSpecForProviderGlobalSecondaryIndexesProvisionedThroughput;

}

/**
 * Converts an object of type 'TableSpecForProviderGlobalSecondaryIndexes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecForProviderGlobalSecondaryIndexes(obj: TableSpecForProviderGlobalSecondaryIndexes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'indexName': obj.indexName,
    'keySchema': obj.keySchema?.map(y => toJson_TableSpecForProviderGlobalSecondaryIndexesKeySchema(y)),
    'projection': toJson_TableSpecForProviderGlobalSecondaryIndexesProjection(obj.projection),
    'provisionedThroughput': toJson_TableSpecForProviderGlobalSecondaryIndexesProvisionedThroughput(obj.provisionedThroughput),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TableSpecForProviderKeySchema
 */
export interface TableSpecForProviderKeySchema {
  /**
   * @schema TableSpecForProviderKeySchema#attributeName
   */
  readonly attributeName?: string;

  /**
   * @schema TableSpecForProviderKeySchema#keyType
   */
  readonly keyType?: string;

}

/**
 * Converts an object of type 'TableSpecForProviderKeySchema' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecForProviderKeySchema(obj: TableSpecForProviderKeySchema | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'attributeName': obj.attributeName,
    'keyType': obj.keyType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TableSpecForProviderLocalSecondaryIndexes
 */
export interface TableSpecForProviderLocalSecondaryIndexes {
  /**
   * @schema TableSpecForProviderLocalSecondaryIndexes#indexName
   */
  readonly indexName?: string;

  /**
   * @schema TableSpecForProviderLocalSecondaryIndexes#keySchema
   */
  readonly keySchema?: TableSpecForProviderLocalSecondaryIndexesKeySchema[];

  /**
   * Represents attributes that are copied (projected) from the table into an index. These are in addition to the primary key attributes and index key attributes, which are automatically projected.
   *
   * @schema TableSpecForProviderLocalSecondaryIndexes#projection
   */
  readonly projection?: TableSpecForProviderLocalSecondaryIndexesProjection;

}

/**
 * Converts an object of type 'TableSpecForProviderLocalSecondaryIndexes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecForProviderLocalSecondaryIndexes(obj: TableSpecForProviderLocalSecondaryIndexes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'indexName': obj.indexName,
    'keySchema': obj.keySchema?.map(y => toJson_TableSpecForProviderLocalSecondaryIndexesKeySchema(y)),
    'projection': toJson_TableSpecForProviderLocalSecondaryIndexesProjection(obj.projection),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Represents the provisioned throughput settings for a specified table or index. The settings can be modified using the UpdateTable operation.
 * If you set BillingMode as PROVISIONED, you must specify this property. If you set BillingMode as PAY_PER_REQUEST, you cannot specify this property.
 * For current minimum and maximum provisioned throughput values, see Service, Account, and Table Quotas (https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Limits.html) in the Amazon DynamoDB Developer Guide.
 *
 * @schema TableSpecForProviderProvisionedThroughput
 */
export interface TableSpecForProviderProvisionedThroughput {
  /**
   * @schema TableSpecForProviderProvisionedThroughput#readCapacityUnits
   */
  readonly readCapacityUnits?: number;

  /**
   * @schema TableSpecForProviderProvisionedThroughput#writeCapacityUnits
   */
  readonly writeCapacityUnits?: number;

}

/**
 * Converts an object of type 'TableSpecForProviderProvisionedThroughput' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecForProviderProvisionedThroughput(obj: TableSpecForProviderProvisionedThroughput | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'readCapacityUnits': obj.readCapacityUnits,
    'writeCapacityUnits': obj.writeCapacityUnits,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Represents the settings used to enable server-side encryption.
 *
 * @schema TableSpecForProviderSseSpecification
 */
export interface TableSpecForProviderSseSpecification {
  /**
   * @schema TableSpecForProviderSseSpecification#enabled
   */
  readonly enabled?: boolean;

  /**
   * @schema TableSpecForProviderSseSpecification#kmsMasterKeyID
   */
  readonly kmsMasterKeyId?: string;

  /**
   * @schema TableSpecForProviderSseSpecification#sseType
   */
  readonly sseType?: string;

}

/**
 * Converts an object of type 'TableSpecForProviderSseSpecification' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecForProviderSseSpecification(obj: TableSpecForProviderSseSpecification | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'kmsMasterKeyID': obj.kmsMasterKeyId,
    'sseType': obj.sseType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The settings for DynamoDB Streams on the table. These settings consist of:
 * * StreamEnabled - Indicates whether DynamoDB Streams is to be enabled (true) or disabled (false).
 * * StreamViewType - When an item in the table is modified, StreamViewType determines what information is written to the table's stream. Valid values for StreamViewType are: KEYS_ONLY - Only the key attributes of the modified item are written to the stream. NEW_IMAGE - The entire item, as it appears after it was modified, is written to the stream. OLD_IMAGE - The entire item, as it appeared before it was modified, is written to the stream. NEW_AND_OLD_IMAGES - Both the new and the old item images of the item are written to the stream.
 *
 * @schema TableSpecForProviderStreamSpecification
 */
export interface TableSpecForProviderStreamSpecification {
  /**
   * @schema TableSpecForProviderStreamSpecification#streamEnabled
   */
  readonly streamEnabled?: boolean;

  /**
   * @schema TableSpecForProviderStreamSpecification#streamViewType
   */
  readonly streamViewType?: string;

}

/**
 * Converts an object of type 'TableSpecForProviderStreamSpecification' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecForProviderStreamSpecification(obj: TableSpecForProviderStreamSpecification | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'streamEnabled': obj.streamEnabled,
    'streamViewType': obj.streamViewType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TableSpecForProviderTags
 */
export interface TableSpecForProviderTags {
  /**
   * @schema TableSpecForProviderTags#key
   */
  readonly key?: string;

  /**
   * @schema TableSpecForProviderTags#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'TableSpecForProviderTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecForProviderTags(obj: TableSpecForProviderTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TableSpecProviderConfigRefPolicy
 */
export interface TableSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TableSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: TableSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TableSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: TableSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TableSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecProviderConfigRefPolicy(obj: TableSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema TableSpecPublishConnectionDetailsToConfigRef
 */
export interface TableSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TableSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TableSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: TableSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'TableSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecPublishConnectionDetailsToConfigRef(obj: TableSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TableSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema TableSpecPublishConnectionDetailsToMetadata
 */
export interface TableSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema TableSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema TableSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema TableSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'TableSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecPublishConnectionDetailsToMetadata(obj: TableSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TableSpecForProviderGlobalSecondaryIndexesKeySchema
 */
export interface TableSpecForProviderGlobalSecondaryIndexesKeySchema {
  /**
   * @schema TableSpecForProviderGlobalSecondaryIndexesKeySchema#attributeName
   */
  readonly attributeName?: string;

  /**
   * @schema TableSpecForProviderGlobalSecondaryIndexesKeySchema#keyType
   */
  readonly keyType?: string;

}

/**
 * Converts an object of type 'TableSpecForProviderGlobalSecondaryIndexesKeySchema' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecForProviderGlobalSecondaryIndexesKeySchema(obj: TableSpecForProviderGlobalSecondaryIndexesKeySchema | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'attributeName': obj.attributeName,
    'keyType': obj.keyType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Represents attributes that are copied (projected) from the table into an index. These are in addition to the primary key attributes and index key attributes, which are automatically projected.
 *
 * @schema TableSpecForProviderGlobalSecondaryIndexesProjection
 */
export interface TableSpecForProviderGlobalSecondaryIndexesProjection {
  /**
   * @schema TableSpecForProviderGlobalSecondaryIndexesProjection#nonKeyAttributes
   */
  readonly nonKeyAttributes?: string[];

  /**
   * @schema TableSpecForProviderGlobalSecondaryIndexesProjection#projectionType
   */
  readonly projectionType?: string;

}

/**
 * Converts an object of type 'TableSpecForProviderGlobalSecondaryIndexesProjection' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecForProviderGlobalSecondaryIndexesProjection(obj: TableSpecForProviderGlobalSecondaryIndexesProjection | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nonKeyAttributes': obj.nonKeyAttributes?.map(y => y),
    'projectionType': obj.projectionType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Represents the provisioned throughput settings for a specified table or index. The settings can be modified using the UpdateTable operation.
 * For current minimum and maximum provisioned throughput values, see Service, Account, and Table Quotas (https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Limits.html) in the Amazon DynamoDB Developer Guide.
 *
 * @schema TableSpecForProviderGlobalSecondaryIndexesProvisionedThroughput
 */
export interface TableSpecForProviderGlobalSecondaryIndexesProvisionedThroughput {
  /**
   * @schema TableSpecForProviderGlobalSecondaryIndexesProvisionedThroughput#readCapacityUnits
   */
  readonly readCapacityUnits?: number;

  /**
   * @schema TableSpecForProviderGlobalSecondaryIndexesProvisionedThroughput#writeCapacityUnits
   */
  readonly writeCapacityUnits?: number;

}

/**
 * Converts an object of type 'TableSpecForProviderGlobalSecondaryIndexesProvisionedThroughput' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecForProviderGlobalSecondaryIndexesProvisionedThroughput(obj: TableSpecForProviderGlobalSecondaryIndexesProvisionedThroughput | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'readCapacityUnits': obj.readCapacityUnits,
    'writeCapacityUnits': obj.writeCapacityUnits,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TableSpecForProviderLocalSecondaryIndexesKeySchema
 */
export interface TableSpecForProviderLocalSecondaryIndexesKeySchema {
  /**
   * @schema TableSpecForProviderLocalSecondaryIndexesKeySchema#attributeName
   */
  readonly attributeName?: string;

  /**
   * @schema TableSpecForProviderLocalSecondaryIndexesKeySchema#keyType
   */
  readonly keyType?: string;

}

/**
 * Converts an object of type 'TableSpecForProviderLocalSecondaryIndexesKeySchema' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecForProviderLocalSecondaryIndexesKeySchema(obj: TableSpecForProviderLocalSecondaryIndexesKeySchema | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'attributeName': obj.attributeName,
    'keyType': obj.keyType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Represents attributes that are copied (projected) from the table into an index. These are in addition to the primary key attributes and index key attributes, which are automatically projected.
 *
 * @schema TableSpecForProviderLocalSecondaryIndexesProjection
 */
export interface TableSpecForProviderLocalSecondaryIndexesProjection {
  /**
   * @schema TableSpecForProviderLocalSecondaryIndexesProjection#nonKeyAttributes
   */
  readonly nonKeyAttributes?: string[];

  /**
   * @schema TableSpecForProviderLocalSecondaryIndexesProjection#projectionType
   */
  readonly projectionType?: string;

}

/**
 * Converts an object of type 'TableSpecForProviderLocalSecondaryIndexesProjection' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecForProviderLocalSecondaryIndexesProjection(obj: TableSpecForProviderLocalSecondaryIndexesProjection | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nonKeyAttributes': obj.nonKeyAttributes?.map(y => y),
    'projectionType': obj.projectionType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TableSpecProviderConfigRefPolicyResolution
 */
export enum TableSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TableSpecProviderConfigRefPolicyResolve
 */
export enum TableSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema TableSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface TableSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TableSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: TableSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TableSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: TableSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TableSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TableSpecPublishConnectionDetailsToConfigRefPolicy(obj: TableSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TableSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum TableSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TableSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum TableSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

